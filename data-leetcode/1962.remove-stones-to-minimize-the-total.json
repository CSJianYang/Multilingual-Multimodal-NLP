[
    {
        "title": "Maximum Product of the Length of Two Palindromic Substrings",
        "question_content": "You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized.\nMore formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive.\nReturn the maximum possible product of the lengths of the two non-intersecting palindromic substrings.\nA palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.\n&nbsp;\nExample 1:\n\nInput: s = \"ababbb\"\nOutput: 9\nExplanation: Substrings \"aba\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9.\n\nExample 2:\n\nInput: s = \"zaaaxbbby\"\nOutput: 9\nExplanation: Substrings \"aaa\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9.\n\n&nbsp;\nConstraints:\n\n\t2 <= s.length <= 105\n\ts consists of lowercase English letters.",
        "solutions": [
            {
                "id": 1389958,
                "title": "manacher-and-queue",
                "content": "Finding the longest palindrome in `[i, j]` is trivial using quadratic DP. Then, we can just find the biggest product of `[0, i] * [i + 1, n)`, moving the split point `i` left-to-right. However, quadratic would be too slow for n = 100,000.\\n \\nManacher\\'s algorithm (easy to find online) can identify all palindromes in O(n). It has two flavors for finding odd and even palindromes. Fortunately, we only care about odd palindromes here,  which is the simpler case.\\n\\nFor each position as the center of the palindrome, the algorithm finds how far the palindrome extends left and right. For example, for string `\"aaabaaaba\"`, the result will be `[1, 2, 1, 4, 1, 2, 2]`. And true - from position `3`, the palindrome extends 4 characters (the initial character is included) left and right, giving us \"aaa**b**aaa\".\\n\\nThis output needs additional massaging to tell the longest palindrome in `[0, i]` and [`i + 1, n)`. Re-using the above example, we are looking for something like this:\\n- Left-to-right (`[0, i]`): `[1, 1, 3, 3, 3, 5, 7, 7, 7]`\\n- Right-to-left (`[i, n]`): `[7, 7, 7, 5, 3, 3, 3, 1, 1]`\\n\\nFor this example, the maximum product is 15, with parts being `[0, 2]` and `[3, 8]`: `3 * 5`.\\n\\nThis transformation was the hardest part for me. I tried a few simpler approaches, which work for some test cases but not for the others. I had to brush up a bit on how Manacher\\'s algorithm works to figure out the transformation using a queue (the front of the queue is the center of the engulfing palindrome).\\n\\n> Update: we can also modify Manacher\\'s algo to produce the output we need. In this case, we will run that algo twice - for the original and inverted string. See approach 2 below. The idea was proposed by [thin_k_ing](https://leetcode.com/thin_k_ing/).\\n\\n#### Approach 1: Manacher and Queue\\n**C++**\\n```cpp\\nlong long maxProduct(string s) {\\n    long long res = 0, l = 0, n = s.size();\\n    vector<int> m(n), r(n);\\n    // Manacher\\'s Algorithm (https://cp-algorithms.com/string/manacher.html)\\n    for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(m[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            k++;\\n        m[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n    }\\n    queue<array<int, 2>> q, q1;\\n    // Right-to-left to track max palindrome in [i, n).\\n    for (int i = n - 1; i >= 0; --i) {\\n        while (!q.empty() && q.front()[0] - q.front()[1] > i - 1)\\n            q.pop();\\n        r[i] = 1 + (q.empty() ? 0 : (q.front()[0] - i) * 2);\\n        q.push({i, m[i]});\\n    }\\n    // Left-to-right to track max palindrome in [0, i].\\n    for (int i = 0; i < n - 1; i += 1) {\\n        while (!q1.empty() && q1.front()[0] + q1.front()[1] < i + 1)\\n            q1.pop();\\n        l = max(l, 1ll + (q1.empty() ? 0 : (i - q1.front()[0]) * 2));\\n        res = max(res, l * r[i + 1]);\\n        q1.push({i, m[i]});\\n    }\\n    return res;\\n}\\n```\\n#### Approach 2: Modified Manacher\\n**C++**\\n```cpp\\nvector<int> manachers(string s, int n) {\\n    vector<int> m(n), l2r(n, 1);\\n    for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(m[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\\n            l2r[i + k] = 2 * k + 1;\\n            k++;\\n        }\\n        m[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n    }\\n    for(int i = 1; i < n; i++) \\n        l2r[i] = max(l2r[i], l2r[i - 1]);\\n    return l2r;\\n}\\nlong long maxProduct(string s) {\\n    long long res = 1, n = s.size();\\n    auto l2r = manachers(s, n), r2l = manachers(string(rbegin(s), rend(s)), n);\\n    for (int i = 0, j = n - 2; i < n - 1; ++i, --j)\\n        res = max(res, (long long)l2r[i] * r2l[j]);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long maxProduct(string s) {\\n    long long res = 0, l = 0, n = s.size();\\n    vector<int> m(n), r(n);\\n    // Manacher\\'s Algorithm (https://cp-algorithms.com/string/manacher.html)\\n    for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(m[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            k++;\\n        m[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n    }\\n    queue<array<int, 2>> q, q1;\\n    // Right-to-left to track max palindrome in [i, n).\\n    for (int i = n - 1; i >= 0; --i) {\\n        while (!q.empty() && q.front()[0] - q.front()[1] > i - 1)\\n            q.pop();\\n        r[i] = 1 + (q.empty() ? 0 : (q.front()[0] - i) * 2);\\n        q.push({i, m[i]});\\n    }\\n    // Left-to-right to track max palindrome in [0, i].\\n    for (int i = 0; i < n - 1; i += 1) {\\n        while (!q1.empty() && q1.front()[0] + q1.front()[1] < i + 1)\\n            q1.pop();\\n        l = max(l, 1ll + (q1.empty() ? 0 : (i - q1.front()[0]) * 2));\\n        res = max(res, l * r[i + 1]);\\n        q1.push({i, m[i]});\\n    }\\n    return res;\\n}\\n```\n```cpp\\nvector<int> manachers(string s, int n) {\\n    vector<int> m(n), l2r(n, 1);\\n    for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(m[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\\n            l2r[i + k] = 2 * k + 1;\\n            k++;\\n        }\\n        m[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n    }\\n    for(int i = 1; i < n; i++) \\n        l2r[i] = max(l2r[i], l2r[i - 1]);\\n    return l2r;\\n}\\nlong long maxProduct(string s) {\\n    long long res = 1, n = s.size();\\n    auto l2r = manachers(s, n), r2l = manachers(string(rbegin(s), rend(s)), n);\\n    for (int i = 0, j = n - 2; i < n - 1; ++i, --j)\\n        res = max(res, (long long)l2r[i] * r2l[j]);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389421,
                "title": "python-o-n-with-manacher-explained",
                "content": "In this problem we deal with palindromes, so it is good idea to think about Manachers algorithm, because the length of our string is quite big. For more details, you can go to wikipedia, imagine now that we have result already for manacher algorithm and now we want to work with results it gave to us. On leetcode contest you do not need to code it youself, you can find template online, and you should know how to use it. Let us consider string \\n\\n`abayabyxaba`, \\n\\nthen we have the following result:\\n\\n`[1, 3, 1, 5, 1, 1, 1, 1, 1, 3, 1]`\\n\\nThat is for index `0` we have palindrome `a`, for index `2` it is `aba`, then `a`, then `bayab` and so on. What we need to do with this information? Let us construct intervals:\\n`ints = [(0, 0), (0, 2), (2, 2), (1, 5), (4, 4), (5, 5), (6, 6), (7, 7), (8, 8), (8, 10), (10, 10)]` it is the size of biggest intervals for each middle point.\\n\\nNow, we need to solve the following problem: let us fix point `i`, so all string `s` will be separated into two parts:\\n`----------|---------`.  What we want to find is the biggest length of palindrom on the left and the biggest length of palindrome on the right, multiply them and do it for every `i` we have. If we do it directly, we will have `O(n^2)`, so we need to think about something better.\\n\\nLet us ask the question: given `i`, what is the maximum length of palindrome, which we meet before `i`? \\n1. Create empty array `arr1 = [0]*n`\\n2. For `a, b in ints`, that is for all intervals we have, update `arr1[b]` with length of interval. It can happen, that we have several intervals ending on the same points, so we use `max` here. After this update we have `[1, 0, 3, 0, 1, 5, 1, 1, 1, 0, 3]`.\\n3. It is imortant, and I forgot it on contest, and was not able to do it on time: we need to check `arr1[i+1] - 2` for each element. Imagine, that we have `[1, 1, 3, 1, 3, 5, 1, 1, 1, 1, 3]`. Note for example that `arr1[4]` was equal to `1` because there is only one segment ending with it. However `arr1[5] = 5` and we have `.bayab...`, so we can be sure that length of palindrome ending with place `4` is at least `arr1[5] - 2 = 3`.\\n4. Finally, we need to evaluate cumulative maximums of `arr1`: `[1, 1, 3, 3, 3, 5, 5, 5, 5, 5, 5]`. Now what we have is answer for the question: given `i`, what is the maximum lengh of palindrome lying before `i`.\\n\\nNow, we need to do exaclty the same logic for question: `what is the maximum length of palindrome after i`? We can use exactly the same function `helper` and reverse results!\\n\\nFinally, when we have answer for two questions:  `what is the maximum length of palindrome after i`? and  `what is the maximum length of palindrome before i`? - we can iterate over all indexes `i` and return `max`.\\n\\n#### Complexity\\nIt is `O(n)` to apply manacher and then we have several `O(n)` passes, so total complexity is `O(n)` both for time and space.\\n\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxProduct(self, s):\\n        def manachers(S):\\n            A = \\'@#\\' + \\'#\\'.join(S) + \\'#$\\'\\n            Z = [0] * len(A)\\n            center = right = 0\\n            for i in range(1, len(A) - 1):\\n                if i < right:\\n                    Z[i] = min(right - i, Z[2 * center - i])\\n                while A[i + Z[i] + 1] == A[i - Z[i] - 1]:\\n                    Z[i] += 1\\n                if i + Z[i] > right:\\n                    center, right = i, i + Z[i]\\n            return Z[2:-2:2]\\n\\n        def helper(s):\\n            man, n = manachers(s), len(s)\\n            ints = [(i - man[i]//2, i + man[i]//2) for i in range(n)]\\n            arr = [0]*n\\n            for a, b in ints: \\n                arr[b] = max(arr[b], b - a + 1)\\n            for i in range(n-2, -1, -1):\\n                arr[i] = max(arr[i], arr[i + 1] - 2)\\n            return list(accumulate(arr, max))\\n        \\n        t1, t2 = helper(s), helper(s[::-1])[::-1][1:] + [0]   \\n        return max(x*y for x, y in zip(t1, t2))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxProduct(self, s):\\n        def manachers(S):\\n            A = \\'@#\\' + \\'#\\'.join(S) + \\'#$\\'\\n            Z = [0] * len(A)\\n            center = right = 0\\n            for i in range(1, len(A) - 1):\\n                if i < right:\\n                    Z[i] = min(right - i, Z[2 * center - i])\\n                while A[i + Z[i] + 1] == A[i - Z[i] - 1]:\\n                    Z[i] += 1\\n                if i + Z[i] > right:\\n                    center, right = i, i + Z[i]\\n            return Z[2:-2:2]\\n\\n        def helper(s):\\n            man, n = manachers(s), len(s)\\n            ints = [(i - man[i]//2, i + man[i]//2) for i in range(n)]\\n            arr = [0]*n\\n            for a, b in ints: \\n                arr[b] = max(arr[b], b - a + 1)\\n            for i in range(n-2, -1, -1):\\n                arr[i] = max(arr[i], arr[i + 1] - 2)\\n            return list(accumulate(arr, max))\\n        \\n        t1, t2 = helper(s), helper(s[::-1])[::-1][1:] + [0]   \\n        return max(x*y for x, y in zip(t1, t2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390099,
                "title": "java-rolling-hash-solution-o-n-c-and-python-versions-in-comments",
                "content": "Prepare rolling hash for the string and its reverse. A substring is palindromic if its hash and hash for it\\'s reversion are equal.\\nThis solution don\\'t check possible collisions. Also it uses fact that if maximum palindrome has end at i and its length is L, then there\\'s a palindrome of length L-2 with end at position i-1. Same fact for beginnings of palindromes. Also we don\\'t need to find the longest plaindrome for each position if its length is less than previously found.\\n\\nTime complexity - O(n), space compelxity - O(n).\\n\\nAlso you can see my solution using Manacher\\'s algorithm there\\nhttps://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/discuss/1389859/Java-Manacher-algorithm-O(n)\\n\\n```\\npublic class Solution {\\n    private static final long base = 29L;\\n    private static final long mod = Integer.MAX_VALUE;\\n\\n    private static boolean isPalindromic(int l, int r, long[] lh, long[] rh, long[] pow) {\\n        return lh(l, r, lh, pow) == rh(l, r, rh, pow);\\n    }\\n\\n    private static long lh(int l, int r, long[] hash, long[] pow) {\\n        long ans = (hash[r] - hash[l] * pow[r - l]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n    private static long rh(int l, int r, long[] hash, long[] pow) {\\n        long ans = (hash[l] - hash[r] * pow[r - l]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n    public long maxProduct(String s) {\\n        int n = s.length();\\n\\n        long[] pow = new long[n + 1]; // pow[i] = BASE^i\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) pow[i] = pow[i - 1] * base % mod;\\n\\n        long[] lh = new long[n + 1]; // hash[i] is hash value from str[0..i)\\n        for (int i = 1; i <= n; i++) lh[i] = (lh[i - 1] * base + s.charAt(i - 1) - \\'a\\') % mod;\\n\\n        long[] rh = new long[n + 1]; // hash[i] is hash value from str[i..n)\\n        for (int i = n - 1; i >= 0; i--) rh[i] = (rh[i + 1] * base + s.charAt(i) - \\'a\\') % mod;\\n\\n        int[] left = new int[n];\\n        for (int i = 0, max = 1; i < n; i++) {\\n            if (max < i && isPalindromic(i - max - 1, i + 1, lh, rh, pow)) max += 2;\\n            left[i] = max;\\n        }\\n\\n        int[] right = new int[n];\\n        for (int i = n - 1, max = 1; i >= 0; i--) {\\n            if (i + max + 2 <= n && isPalindromic(i, i + max + 2, lh, rh, pow)) max += 2;\\n            right[i] = max;\\n        }\\n\\n        long ans = 1;\\n        for (int i = 1; i < n; i++) ans = Math.max(ans, (long) left[i - 1] * right[i]);\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Rolling Hash"
                ],
                "code": "```\\npublic class Solution {\\n    private static final long base = 29L;\\n    private static final long mod = Integer.MAX_VALUE;\\n\\n    private static boolean isPalindromic(int l, int r, long[] lh, long[] rh, long[] pow) {\\n        return lh(l, r, lh, pow) == rh(l, r, rh, pow);\\n    }\\n\\n    private static long lh(int l, int r, long[] hash, long[] pow) {\\n        long ans = (hash[r] - hash[l] * pow[r - l]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n    private static long rh(int l, int r, long[] hash, long[] pow) {\\n        long ans = (hash[l] - hash[r] * pow[r - l]) % mod;\\n        if (ans < 0) ans += mod;\\n        return ans;\\n    }\\n\\n    public long maxProduct(String s) {\\n        int n = s.length();\\n\\n        long[] pow = new long[n + 1]; // pow[i] = BASE^i\\n        pow[0] = 1;\\n        for (int i = 1; i <= n; i++) pow[i] = pow[i - 1] * base % mod;\\n\\n        long[] lh = new long[n + 1]; // hash[i] is hash value from str[0..i)\\n        for (int i = 1; i <= n; i++) lh[i] = (lh[i - 1] * base + s.charAt(i - 1) - \\'a\\') % mod;\\n\\n        long[] rh = new long[n + 1]; // hash[i] is hash value from str[i..n)\\n        for (int i = n - 1; i >= 0; i--) rh[i] = (rh[i + 1] * base + s.charAt(i) - \\'a\\') % mod;\\n\\n        int[] left = new int[n];\\n        for (int i = 0, max = 1; i < n; i++) {\\n            if (max < i && isPalindromic(i - max - 1, i + 1, lh, rh, pow)) max += 2;\\n            left[i] = max;\\n        }\\n\\n        int[] right = new int[n];\\n        for (int i = n - 1, max = 1; i >= 0; i--) {\\n            if (i + max + 2 <= n && isPalindromic(i, i + max + 2, lh, rh, pow)) max += 2;\\n            right[i] = max;\\n        }\\n\\n        long ans = 1;\\n        for (int i = 1; i < n; i++) ans = Math.max(ans, (long) left[i - 1] * right[i]);\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389706,
                "title": "python3-hashing-nlogn-accepted",
                "content": "Idea:\\n1. We can compute hash for all prefixes and suffixes in linear time.\\n2. Then we can find if `a[i-k:i +k]` is palindrome in costant time.\\n3. So we can find the longest palindrome in logarithmic time by applying binary search.\\n4. Then we can find the longest for all `i` in linearithmic time.\\n5. Then just iterate over the finding to get the final result (similar to all other solutions).\\n\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        alphabet_size = 26\\n        mod = 10 ** 9 + 7\\n        straight_hash = [0] * len(s)\\n        reverse_hash = [0] * len(s)\\n        for i in range(len(s)):\\n            straight_hash[i] = (straight_hash[i - 1] * alphabet_size + ord(s[i]) - ord(\"a\")) % mod\\n            reverse_hash[~i] = (reverse_hash[~i + 1] * alphabet_size + ord(s[~i]) - ord(\"a\")) % mod\\n        straight_hash.append(0)\\n        reverse_hash.append(0)\\n\\n        longest_palindrome_from_left = [0] * len(s)\\n        longest_palindrome_from_right = [0] * len(s)\\n        for i in range(len(s)):\\n            low = 1\\n            high = min(i + 1, len(s) - i)\\n            \\n            if 0 < i < len(s) - 1 and s[i - 1] == s[i + 1]:     # hack (otherwise TLE): don\\'t run binary search if adjecent letters are different\\n                while low < high:\\n                    mid = (low + high + 1) // 2\\n                    m = pow(alphabet_size, mid, mod)\\n                    if (straight_hash[i] - straight_hash[i - mid] * m) % mod == (reverse_hash[i] - reverse_hash[i + mid] * m) % mod:\\n                        low = mid\\n                    else:\\n                        high = mid - 1\\n            longest_palindrome_from_left[i + low - 1] = max(low * 2 - 1, longest_palindrome_from_left[i + low - 1])\\n            longest_palindrome_from_right[i - low + 1] = max(low * 2 - 1, longest_palindrome_from_right[i - low + 1])\\n\\n        for i in range(1, len(s)):\\n            longest_palindrome_from_left[i] = max(longest_palindrome_from_left[i], longest_palindrome_from_left[i - 1])\\n            longest_palindrome_from_right[~i] = max(longest_palindrome_from_right[~i], longest_palindrome_from_right[~i + 1])\\n        for i in range(1, len(s)):\\n            longest_palindrome_from_left[~i] = max(longest_palindrome_from_left[~i], longest_palindrome_from_left[~i + 1] - 2)\\n            longest_palindrome_from_right[i] = max(longest_palindrome_from_right[i], longest_palindrome_from_right[i - 1] - 2)\\n\\n        res = 0\\n        for i in range(1, len(s)):\\n            res = max(res, longest_palindrome_from_left[i - 1] * longest_palindrome_from_right[i])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        alphabet_size = 26\\n        mod = 10 ** 9 + 7\\n        straight_hash = [0] * len(s)\\n        reverse_hash = [0] * len(s)\\n        for i in range(len(s)):\\n            straight_hash[i] = (straight_hash[i - 1] * alphabet_size + ord(s[i]) - ord(\"a\")) % mod\\n            reverse_hash[~i] = (reverse_hash[~i + 1] * alphabet_size + ord(s[~i]) - ord(\"a\")) % mod\\n        straight_hash.append(0)\\n        reverse_hash.append(0)\\n\\n        longest_palindrome_from_left = [0] * len(s)\\n        longest_palindrome_from_right = [0] * len(s)\\n        for i in range(len(s)):\\n            low = 1\\n            high = min(i + 1, len(s) - i)\\n            \\n            if 0 < i < len(s) - 1 and s[i - 1] == s[i + 1]:     # hack (otherwise TLE): don\\'t run binary search if adjecent letters are different\\n                while low < high:\\n                    mid = (low + high + 1) // 2\\n                    m = pow(alphabet_size, mid, mod)\\n                    if (straight_hash[i] - straight_hash[i - mid] * m) % mod == (reverse_hash[i] - reverse_hash[i + mid] * m) % mod:\\n                        low = mid\\n                    else:\\n                        high = mid - 1\\n            longest_palindrome_from_left[i + low - 1] = max(low * 2 - 1, longest_palindrome_from_left[i + low - 1])\\n            longest_palindrome_from_right[i - low + 1] = max(low * 2 - 1, longest_palindrome_from_right[i - low + 1])\\n\\n        for i in range(1, len(s)):\\n            longest_palindrome_from_left[i] = max(longest_palindrome_from_left[i], longest_palindrome_from_left[i - 1])\\n            longest_palindrome_from_right[~i] = max(longest_palindrome_from_right[~i], longest_palindrome_from_right[~i + 1])\\n        for i in range(1, len(s)):\\n            longest_palindrome_from_left[~i] = max(longest_palindrome_from_left[~i], longest_palindrome_from_left[~i + 1] - 2)\\n            longest_palindrome_from_right[i] = max(longest_palindrome_from_right[i], longest_palindrome_from_right[i - 1] - 2)\\n\\n        res = 0\\n        for i in range(1, len(s)):\\n            res = max(res, longest_palindrome_from_left[i - 1] * longest_palindrome_from_right[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396545,
                "title": "python-rolling-hash-binary-search-with-code-comments",
                "content": "Got the idea from post \\nhttps://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/discuss/1389706/Python3.-Hashing.-NlogN.-Accepted.\\nand added more explanations.\\n\\nThe idea is to decompose the problem into subproblems:\\n1. Create rolling hash from left and from right. This is O(n).\\n2. Judge if it is a palindrome with a given center and given radius in O(1) time. This is done by comparing hash value.\\n3. Use each position as center, find the longest parlindrome extension. This is done by binary search, with step 2 as a subproblem, in total O (n log(n) ).\\n4. Now we know the max len parlindrome ending at a position from both left and right, apply next array type idea to get the final answer: to get the max len till a position (not necessarily ending with it), it has two cases to consider, see code comments..\\n\\nOverall, the time limit is pretty tight, guess applying Manacher is faster (O(n) ) but I don\\'t have that knowledge.\\n\\n```\\nclass Solution:\\n    \\n    def maxProduct(self, s: str) -> int:\\n        mod = 10**9 + 7\\n        base = 27\\n        n = len(s)\\n        forward_hash = [0] * (len(s) + 1)\\n        backward_hash = [0] * (len(s) + 1)\\n        for i in range(1, n+1):\\n            forward_hash[i] = (forward_hash[i-1] * base + (ord(s[i-1]) - ord(\\'a\\'))) % mod\\n        for i in range(n-1, -1, -1):\\n            backward_hash[i] = (backward_hash[i+1] * base + (ord(s[i]) - ord(\\'a\\'))) % mod\\n            \\n        def is_parlin(s, center, l):\\n            # check if it is a palin, with l being the radius\\n            # [left, center-1] vs [center+1, right]\\n            p = pow(base, l, mod)\\n            left_hash = (forward_hash[center] - forward_hash[center-l] * p) % mod\\n            right_hash = (backward_hash[center+1] - backward_hash[center+l+1] * p) % mod\\n            return left_hash == right_hash\\n        \\n        # inclusive\\n        before_idx_max_len = [1] * n\\n        after_idx_max_len = [1] * n\\n        \\n        # for each center, expand\\n        for i in range(1, n-1):\\n            max_radius = 1\\n            if s[i-1] != s[i+1]: # radius = 1 fails\\n                continue\\n            # find the largest extention so that [center+1, right] is the same as [left, center-1]\\n            start, end = 1, min(i, n-i)\\n            while start + 1 < end:\\n                mid = (start + end) // 2\\n                if is_parlin(s, i, mid):\\n                    start = mid\\n                else:\\n                    end = mid\\n            if i + end < n and is_parlin(s, i, end):\\n                max_radius = end\\n            else:\\n                max_radius = start\\n                \\n            left = i - max_radius\\n            right = i + max_radius\\n            before_idx_max_len[right] = max(before_idx_max_len[right], 2*max_radius+1)\\n            after_idx_max_len[left] = max(after_idx_max_len[left], 2*max_radius+1)\\n        \\n        # handle trick case1: if ending with i is palin with len, then end with i-1 should be parlin with at least len-2!\\n        for i in range(n-2, -1, -1):\\n            before_idx_max_len[i] = max(before_idx_max_len[i], before_idx_max_len[i+1]-2)\\n        for i in range(1, n):\\n            after_idx_max_len[i] = max(after_idx_max_len[i], after_idx_max_len[i-1]-2)\\n        \\n        # case2: find max till now using next array\\n        for i in range(n-1, 0, -1):\\n            before_idx_max_len[i] = max(before_idx_max_len[i-1], before_idx_max_len[i])\\n        for i in range(n-2, -1, -1):\\n            after_idx_max_len[i] = max(after_idx_max_len[i+1], after_idx_max_len[i])\\n        \\n        # print(before_idx_max_len, after_idx_max_len)\\n        # find the best possible\\n        res = 1\\n        for i in range(n-1):\\n            res = max(res, before_idx_max_len[i] * after_idx_max_len[i+1])\\n            \\n        return res\\n",
                "solutionTags": [],
                "code": "Got the idea from post \\nhttps://leetcode.com/problems/maximum-product-of-the-length-of-two-palindromic-substrings/discuss/1389706/Python3.-Hashing.-NlogN.-Accepted.\\nand added more explanations.\\n\\nThe idea is to decompose the problem into subproblems:\\n1. Create rolling hash from left and from right. This is O(n).\\n2. Judge if it is a palindrome with a given center and given radius in O(1) time. This is done by comparing hash value.\\n3. Use each position as center, find the longest parlindrome extension. This is done by binary search, with step 2 as a subproblem, in total O (n log(n) ).\\n4. Now we know the max len parlindrome ending at a position from both left and right, apply next array type idea to get the final answer: to get the max len till a position (not necessarily ending with it), it has two cases to consider, see code comments..\\n\\nOverall, the time limit is pretty tight, guess applying Manacher is faster (O(n) ) but I don\\'t have that knowledge.\\n\\n```\\nclass Solution:\\n    \\n    def maxProduct(self, s: str) -> int:\\n        mod = 10**9 + 7\\n        base = 27\\n        n = len(s)\\n        forward_hash = [0] * (len(s) + 1)\\n        backward_hash = [0] * (len(s) + 1)\\n        for i in range(1, n+1):\\n            forward_hash[i] = (forward_hash[i-1] * base + (ord(s[i-1]) - ord(\\'a\\'))) % mod\\n        for i in range(n-1, -1, -1):\\n            backward_hash[i] = (backward_hash[i+1] * base + (ord(s[i]) - ord(\\'a\\'))) % mod\\n            \\n        def is_parlin(s, center, l):\\n            # check if it is a palin, with l being the radius\\n            # [left, center-1] vs [center+1, right]\\n            p = pow(base, l, mod)\\n            left_hash = (forward_hash[center] - forward_hash[center-l] * p) % mod\\n            right_hash = (backward_hash[center+1] - backward_hash[center+l+1] * p) % mod\\n            return left_hash == right_hash\\n        \\n        # inclusive\\n        before_idx_max_len = [1] * n\\n        after_idx_max_len = [1] * n\\n        \\n        # for each center, expand\\n        for i in range(1, n-1):\\n            max_radius = 1\\n            if s[i-1] != s[i+1]: # radius = 1 fails\\n                continue\\n            # find the largest extention so that [center+1, right] is the same as [left, center-1]\\n            start, end = 1, min(i, n-i)\\n            while start + 1 < end:\\n                mid = (start + end) // 2\\n                if is_parlin(s, i, mid):\\n                    start = mid\\n                else:\\n                    end = mid\\n            if i + end < n and is_parlin(s, i, end):\\n                max_radius = end\\n            else:\\n                max_radius = start\\n                \\n            left = i - max_radius\\n            right = i + max_radius\\n            before_idx_max_len[right] = max(before_idx_max_len[right], 2*max_radius+1)\\n            after_idx_max_len[left] = max(after_idx_max_len[left], 2*max_radius+1)\\n        \\n        # handle trick case1: if ending with i is palin with len, then end with i-1 should be parlin with at least len-2!\\n        for i in range(n-2, -1, -1):\\n            before_idx_max_len[i] = max(before_idx_max_len[i], before_idx_max_len[i+1]-2)\\n        for i in range(1, n):\\n            after_idx_max_len[i] = max(after_idx_max_len[i], after_idx_max_len[i-1]-2)\\n        \\n        # case2: find max till now using next array\\n        for i in range(n-1, 0, -1):\\n            before_idx_max_len[i] = max(before_idx_max_len[i-1], before_idx_max_len[i])\\n        for i in range(n-2, -1, -1):\\n            after_idx_max_len[i] = max(after_idx_max_len[i+1], after_idx_max_len[i])\\n        \\n        # print(before_idx_max_len, after_idx_max_len)\\n        # find the best possible\\n        res = 1\\n        for i in range(n-1):\\n            res = max(res, before_idx_max_len[i] * after_idx_max_len[i+1])\\n            \\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2017147,
                "title": "manachers-algo-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    long long max(long long x,long long y)\\n    {\\n        if(x>y)\\n            return x;\\n        return y;\\n    }\\n    \\n    long long maxProduct(string t) {\\n        int n=t.length();\\n        vector<int> left(n,0),lpso(n,0);\\n        int r=0,c=0;\\n\\t    // Manachar\\'s algo\\n        for(int i=0;i<n;i++)\\n        {\\n            int m=2*c-i;\\n            if(i<r)\\n                lpso[i]= min(lpso[m],r-i);\\n            while(i-lpso[i]-1 >=0 && i+lpso[i]+1<n && t[i-lpso[i]-1] == t[i+lpso[i]+1])\\n                lpso[i]++;\\n            if(r<i+lpso[i])\\n                r=i+lpso[i],c=i;\\n        }\\n\\t\\t// Finding the longest palindrome ending before ith index or at ith index \\n        left[0] = 1;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=1;i<=n-1;i++)\\n        {\\n            if(lpso[i]>0)\\n                pq.push({i,lpso[i]}),left[i]=1;\\n            if(!pq.empty())\\n            {\\n\\t\\t\\t    // Number of elements between the ith position and the center of palindrome\\n                while(!pq.empty() && pq.top().first+pq.top().second<i)\\n                    pq.pop();\\n                if(!pq.empty())\\n                    left[i]= 2*(i-pq.top().first)+1;\\n                else\\n                    left[i]=1;\\n            }\\n            left[i]=max(left[i],left[i-1]);\\n        }\\n\\t\\t\\n\\t\\t// Finding the longest palindrome ending after ith index or at ith index \\n        priority_queue<pair<int,int>> pql;\\n        int m=1,l=1;\\n        long long ans=0;\\n        ans = max(ans,1LL*left[n-2]*m);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(lpso[i]>0)\\n                pql.push({i,lpso[i]}),l=1;\\n            if(!pql.empty())\\n            {\\n\\t\\t    \\t// Number of elements between the ith position and the center of palindrome\\n                while(!pql.empty() && pql.top().first-pql.top().second>i)\\n                    pql.pop();\\n                if(!pql.empty())\\n                    l= 2*(pql.top().first-i)+1;\\n                else\\n                    l=1;\\n            }\\n            m=max(m,l);\\n\\t\\t\\t// Directly calculating by multiplying (ending before ith) * (ending after or at ith)\\n            if(i>0)\\n                ans= max(ans, 1LL*left[i-1]*m);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long max(long long x,long long y)\\n    {\\n        if(x>y)\\n            return x;\\n        return y;\\n    }\\n    \\n    long long maxProduct(string t) {\\n        int n=t.length();\\n        vector<int> left(n,0),lpso(n,0);\\n        int r=0,c=0;\\n\\t    // Manachar\\'s algo\\n        for(int i=0;i<n;i++)\\n        {\\n            int m=2*c-i;\\n            if(i<r)\\n                lpso[i]= min(lpso[m],r-i);\\n            while(i-lpso[i]-1 >=0 && i+lpso[i]+1<n && t[i-lpso[i]-1] == t[i+lpso[i]+1])\\n                lpso[i]++;\\n            if(r<i+lpso[i])\\n                r=i+lpso[i],c=i;\\n        }\\n\\t\\t// Finding the longest palindrome ending before ith index or at ith index \\n        left[0] = 1;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        for(int i=1;i<=n-1;i++)\\n        {\\n            if(lpso[i]>0)\\n                pq.push({i,lpso[i]}),left[i]=1;\\n            if(!pq.empty())\\n            {\\n\\t\\t\\t    // Number of elements between the ith position and the center of palindrome\\n                while(!pq.empty() && pq.top().first+pq.top().second<i)\\n                    pq.pop();\\n                if(!pq.empty())\\n                    left[i]= 2*(i-pq.top().first)+1;\\n                else\\n                    left[i]=1;\\n            }\\n            left[i]=max(left[i],left[i-1]);\\n        }\\n\\t\\t\\n\\t\\t// Finding the longest palindrome ending after ith index or at ith index \\n        priority_queue<pair<int,int>> pql;\\n        int m=1,l=1;\\n        long long ans=0;\\n        ans = max(ans,1LL*left[n-2]*m);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(lpso[i]>0)\\n                pql.push({i,lpso[i]}),l=1;\\n            if(!pql.empty())\\n            {\\n\\t\\t    \\t// Number of elements between the ith position and the center of palindrome\\n                while(!pql.empty() && pql.top().first-pql.top().second>i)\\n                    pql.pop();\\n                if(!pql.empty())\\n                    l= 2*(pql.top().first-i)+1;\\n                else\\n                    l=1;\\n            }\\n            m=max(m,l);\\n\\t\\t\\t// Directly calculating by multiplying (ending before ith) * (ending after or at ith)\\n            if(i>0)\\n                ans= max(ans, 1LL*left[i-1]*m);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393832,
                "title": "python3-manacher",
                "content": "\\n```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # Manacher\\'s algo\\n        hlen = [0]*n # half-length\\n        center = right = 0 \\n        for i in range(n): \\n            if i < right: hlen[i] = min(right - i, hlen[2*center - i])\\n            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]: \\n                hlen[i] += 1\\n            if right < i+hlen[i]: center, right = i, i+hlen[i]\\n        \\n        prefix = [0]*n\\n        suffix = [0]*n\\n        for i in range(n): \\n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i]+1)\\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i]+1)\\n        \\n        for i in range(1, n): \\n            prefix[~i] = max(prefix[~i], prefix[~i+1]-2)\\n            suffix[i] = max(suffix[i], suffix[i-1]-2)\\n        \\n        for i in range(1, n): \\n            prefix[i] = max(prefix[i-1], prefix[i])\\n            suffix[~i] = max(suffix[~i], suffix[~i+1])\\n        \\n        return max(prefix[i-1]*suffix[i] for i in range(1, n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # Manacher\\'s algo\\n        hlen = [0]*n # half-length\\n        center = right = 0 \\n        for i in range(n): \\n            if i < right: hlen[i] = min(right - i, hlen[2*center - i])\\n            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]: \\n                hlen[i] += 1\\n            if right < i+hlen[i]: center, right = i, i+hlen[i]\\n        \\n        prefix = [0]*n\\n        suffix = [0]*n\\n        for i in range(n): \\n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i]+1)\\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i]+1)\\n        \\n        for i in range(1, n): \\n            prefix[~i] = max(prefix[~i], prefix[~i+1]-2)\\n            suffix[i] = max(suffix[i], suffix[i-1]-2)\\n        \\n        for i in range(1, n): \\n            prefix[i] = max(prefix[i-1], prefix[i])\\n            suffix[~i] = max(suffix[~i], suffix[~i+1])\\n        \\n        return max(prefix[i-1]*suffix[i] for i in range(1, n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389279,
                "title": "o-n-with-manacher-s-algorithm",
                "content": "n is in the order of 10^5, so I think O(n^2) will TLE. We need to use Manacher\\'s algorithm to get the longest palindrome substring at each index, which is O(n).\\n\\nFor Manacher\\'s algorithm, go to wiki\\nhttps://en.wikipedia.org/wiki/Longest_palindromic_substring\\n```\\n    def maxProduct(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        T = \\'$#\\' + \\'#\\'.join(s) + \\'#@\\'\\n        P = [0] * len(T) # store the length at each index\\n        right, center = 0, 0\\n        for i in range(1,len(T)-1):\\n            if i < right:\\n                P[i] = min(P[2 * center - i], right - i)\\n            while T[i+(P[i]+1)] == T[i-(P[i]+1)]:\\n                P[i] += 1\\n            if P[i] + i > right:\\n                right = P[i] + i\\n                center = i\\n                \\n        arr = []#the longest length centering at each index of original array, odd length\\n        for i in range(len(T)):\\n            if T[i].isalpha():\\n                arr.append(P[i])\\n                \\n        pre = [1 for _ in range(len(s))]\\n        for i in range(len(s)):# the ending point of each longest substring\\n            pre[i+(arr[i]-1)//2] = max(pre[i+(arr[i]-1)//2],arr[i])\\n        for i in range(len(s)-2,-1,-1):# the end can be shorter, like \"aba\" is a substring of \"cabac\"\\n            pre[i] = max(pre[i],pre[i+1]-2)\\n        for i in range(len(pre)-1):#the maximum length before and at i\\n            pre[i+1] = max(pre[i],pre[i+1])\\n\\n        post = [1 for _ in range(len(s))]#do it again for the suffix array\\n        for i in range(len(s)-1,-1,-1):\\n            post[i-(arr[i]-1)//2] = max(post[i-(arr[i]-1)//2],arr[i])\\n        for i in range(1,len(s)):\\n            post[i] = max(post[i],post[i-1]-2)    \\n        post = post[1:]+[0]\\n        for i in range(len(s)-1,0,-1):#the maximum length after i\\n            post[i-1] = max(post[i-1],post[i])\\n            \\n        res = 0\\n        for i in range(len(pre)):\\n            res = max(res,pre[i]*post[i])\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProduct(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        T = \\'$#\\' + \\'#\\'.join(s) + \\'#@\\'\\n        P = [0] * len(T) # store the length at each index\\n        right, center = 0, 0\\n        for i in range(1,len(T)-1):\\n            if i < right:\\n                P[i] = min(P[2 * center - i], right - i)\\n            while T[i+(P[i]+1)] == T[i-(P[i]+1)]:\\n                P[i] += 1\\n            if P[i] + i > right:\\n                right = P[i] + i\\n                center = i\\n                \\n        arr = []#the longest length centering at each index of original array, odd length\\n        for i in range(len(T)):\\n            if T[i].isalpha():\\n                arr.append(P[i])\\n                \\n        pre = [1 for _ in range(len(s))]\\n        for i in range(len(s)):# the ending point of each longest substring\\n            pre[i+(arr[i]-1)//2] = max(pre[i+(arr[i]-1)//2],arr[i])\\n        for i in range(len(s)-2,-1,-1):# the end can be shorter, like \"aba\" is a substring of \"cabac\"\\n            pre[i] = max(pre[i],pre[i+1]-2)\\n        for i in range(len(pre)-1):#the maximum length before and at i\\n            pre[i+1] = max(pre[i],pre[i+1])\\n\\n        post = [1 for _ in range(len(s))]#do it again for the suffix array\\n        for i in range(len(s)-1,-1,-1):\\n            post[i-(arr[i]-1)//2] = max(post[i-(arr[i]-1)//2],arr[i])\\n        for i in range(1,len(s)):\\n            post[i] = max(post[i],post[i-1]-2)    \\n        post = post[1:]+[0]\\n        for i in range(len(s)-1,0,-1):#the maximum length after i\\n            post[i-1] = max(post[i-1],post[i])\\n            \\n        res = 0\\n        for i in range(len(pre)):\\n            res = max(res,pre[i]*post[i])\\n        return res\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1393288,
                "title": "java-100-o-n-time-o-n-space-using-manacher-s-algorithm",
                "content": "```\\n// using manachers algorithm\\n\\nclass Solution {\\n\\n    public long maxProduct(String s) {\\n        int n = s.length();\\n        if (n == 2) return 1;\\n        int[] len = manachers(s);               // get lengths of palindromes at each element\\n        \\n        long left[] = new long[n];                // stores the max length of palindrome to left of each index\\n        \\n        int max = 1;\\n        left[0] = max;\\n        for (int i = 1; i <= n - 1; i++) {\\n            // does any palindrome end at i with length greater than max\\n            if (len[(i - max - 1 + i)/2] > max) max += 2;\\n            left[i] = max;\\n        }\\n        max = 1;\\n        long[] right = new long[n];             // stores the max length of palindrome to right of each index\\n        right[n - 1] = max;\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            // does any palindrome start at i with length greater than max\\n            if (len[(i + max + 1 + i)/2] > max) max += 2;\\n            right[i] = max;\\n        }\\n        \\n        long res = 1;\\n        \\n        for (int i = 1; i < n; i++) {            \\n            res = Math.max(res, left[i - 1] * right[i]);\\n        }\\n        return res;\\n    }\\n    \\n\\t// credit : https://hackernoon.com/manachers-algorithm-explained-longest-palindromic-substring-22cb27a5e96f\\n\\tprivate int[] manachers(String s) {\\n        \\n        int len = s.length();\\n        int[] P = new int[len];\\n        int c = 0; //stores the center of the longest palindromic substring until now\\n        int r = 0; //stores the right boundary of the longest palindromic substring until now\\n        int maxLen = 0;\\n       \\n        for(int i = 0; i < len; i++) {\\n            //get mirror index of i\\n            int mirror = (2 * c) - i;\\n            \\n            //see if the mirror of i is expanding beyond the left boundary of current longest palindrome at center c\\n            //if it is, then take r - i as P[i]\\n            //else take P[mirror] as P[i]\\n            if(i < r) {\\n                P[i] = Math.min(r - i, P[mirror]);\\n            }\\n            \\n            //expand at i\\n            int a = i + (1 + P[i]);\\n            int b = i - (1 + P[i]);\\n            while(a < len && b >= 0 && s.charAt(a) == s.charAt(b)) {\\n                P[i]++;\\n                a++;\\n                b--;\\n            }\\n            \\n            //check if the expanded palindrome at i is expanding beyond the right boundary of current longest palindrome at center c\\n            //if it is, the new center is i\\n            if(i + P[i] > r) {\\n                c = i;\\n                r = i + P[i];\\n            }\\n        }\\n        for (int i = 0; i < len; i++) P[i] = 1 + 2*P[i];\\n        return P;\\n\\t}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// using manachers algorithm\\n\\nclass Solution {\\n\\n    public long maxProduct(String s) {\\n        int n = s.length();\\n        if (n == 2) return 1;\\n        int[] len = manachers(s);               // get lengths of palindromes at each element\\n        \\n        long left[] = new long[n];                // stores the max length of palindrome to left of each index\\n        \\n        int max = 1;\\n        left[0] = max;\\n        for (int i = 1; i <= n - 1; i++) {\\n            // does any palindrome end at i with length greater than max\\n            if (len[(i - max - 1 + i)/2] > max) max += 2;\\n            left[i] = max;\\n        }\\n        max = 1;\\n        long[] right = new long[n];             // stores the max length of palindrome to right of each index\\n        right[n - 1] = max;\\n        \\n        for (int i = n - 2; i >= 0; i--) {\\n            // does any palindrome start at i with length greater than max\\n            if (len[(i + max + 1 + i)/2] > max) max += 2;\\n            right[i] = max;\\n        }\\n        \\n        long res = 1;\\n        \\n        for (int i = 1; i < n; i++) {            \\n            res = Math.max(res, left[i - 1] * right[i]);\\n        }\\n        return res;\\n    }\\n    \\n\\t// credit : https://hackernoon.com/manachers-algorithm-explained-longest-palindromic-substring-22cb27a5e96f\\n\\tprivate int[] manachers(String s) {\\n        \\n        int len = s.length();\\n        int[] P = new int[len];\\n        int c = 0; //stores the center of the longest palindromic substring until now\\n        int r = 0; //stores the right boundary of the longest palindromic substring until now\\n        int maxLen = 0;\\n       \\n        for(int i = 0; i < len; i++) {\\n            //get mirror index of i\\n            int mirror = (2 * c) - i;\\n            \\n            //see if the mirror of i is expanding beyond the left boundary of current longest palindrome at center c\\n            //if it is, then take r - i as P[i]\\n            //else take P[mirror] as P[i]\\n            if(i < r) {\\n                P[i] = Math.min(r - i, P[mirror]);\\n            }\\n            \\n            //expand at i\\n            int a = i + (1 + P[i]);\\n            int b = i - (1 + P[i]);\\n            while(a < len && b >= 0 && s.charAt(a) == s.charAt(b)) {\\n                P[i]++;\\n                a++;\\n                b--;\\n            }\\n            \\n            //check if the expanded palindrome at i is expanding beyond the right boundary of current longest palindrome at center c\\n            //if it is, the new center is i\\n            if(i + P[i] > r) {\\n                c = i;\\n                r = i + P[i];\\n            }\\n        }\\n        for (int i = 0; i < len; i++) P[i] = 1 + 2*P[i];\\n        return P;\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389320,
                "title": "c-manacher-set-priority-queue-to-build-maxl-and-maxr",
                "content": "I got WA at last second because i forgot to cast to long long, got accepted after 1 second of contest end ;(\\n\\nAnyway the idea here is to just use manacher\\'s algorithm and then build the prefix and suffix max palindrome length, by using a priority queue (set here is used to quickly make a min priority queue instead of max priority queue).\\n\\nThen at every index just update the result if we find a new best product.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    long long maxProduct(string s)\\n    {\\n\\n        int n = s.size();\\n        vector<int> d1 = vector<int>(s.size(), 0);\\n        for (int i = 0, l = 0, r = -1; i < n; i++)\\n        {\\n            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            {\\n                k++;\\n            }\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i - k;\\n                r = i + k;\\n            }\\n        }\\n\\n        vector<int> maxL = vector<int>(s.size(), 1);\\n        auto lQueue = set<pair<int, int>>();\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                maxL[i] = max(maxL[i], maxL[i - 1]);\\n\\n            lQueue.insert({i, d1[i]});\\n\\n            while (lQueue.begin()->first + lQueue.begin()->second - 1 < i)\\n            {\\n                lQueue.erase(lQueue.begin());\\n            }\\n\\n            maxL[i] = max(maxL[i], ((i - lQueue.begin()->first) * 2) + 1);\\n        }\\n\\n        vector<int> maxR = vector<int>(s.size(), 1);\\n        auto rQueue = priority_queue<pair<int, int>>();\\n\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                maxR[i] = max(maxR[i], maxR[i + 1]);\\n\\n            rQueue.push({i, d1[i]});\\n\\n            while (rQueue.top().first - (rQueue.top().second - 1) > i)\\n            {\\n                rQueue.pop();\\n            }\\n\\n            maxR[i] = max(maxR[i], ((rQueue.top().first - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) maxL[i] * (long long)maxR[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long maxProduct(string s)\\n    {\\n\\n        int n = s.size();\\n        vector<int> d1 = vector<int>(s.size(), 0);\\n        for (int i = 0, l = 0, r = -1; i < n; i++)\\n        {\\n            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            {\\n                k++;\\n            }\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i - k;\\n                r = i + k;\\n            }\\n        }\\n\\n        vector<int> maxL = vector<int>(s.size(), 1);\\n        auto lQueue = set<pair<int, int>>();\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                maxL[i] = max(maxL[i], maxL[i - 1]);\\n\\n            lQueue.insert({i, d1[i]});\\n\\n            while (lQueue.begin()->first + lQueue.begin()->second - 1 < i)\\n            {\\n                lQueue.erase(lQueue.begin());\\n            }\\n\\n            maxL[i] = max(maxL[i], ((i - lQueue.begin()->first) * 2) + 1);\\n        }\\n\\n        vector<int> maxR = vector<int>(s.size(), 1);\\n        auto rQueue = priority_queue<pair<int, int>>();\\n\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                maxR[i] = max(maxR[i], maxR[i + 1]);\\n\\n            rQueue.push({i, d1[i]});\\n\\n            while (rQueue.top().first - (rQueue.top().second - 1) > i)\\n            {\\n                rQueue.pop();\\n            }\\n\\n            maxR[i] = max(maxR[i], ((rQueue.top().first - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) maxL[i] * (long long)maxR[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961860,
                "title": "c-manacher-and-queue-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        vector<int> d1(s.size());\\n        int n=s.size();\\n        for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            k++;\\n        d1[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n        cout<<d1[i]<<\\' \\';\\n    }\\n        vector<int> l(s.size(),1),r(s.size(),1);\\n        queue<int> q;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                l[i] = max(l[i], l[i - 1]);\\n\\n            q.push(i);\\n\\n            while (q.front() + d1[q.front()] - 1 < i)\\n            {\\n                q.pop();\\n            }\\n\\n            l[i] = max(l[i], ((i - q.front()) * 2) + 1);\\n        }\\n        while(!q.empty()) q.pop();\\n      \\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                r[i] = max(r[i], r[i + 1]);\\n\\n            q.push(i);\\n\\n            while (q.front() - d1[q.front()] + 1 > i)\\n            {\\n                q.pop();\\n            }\\n\\n            r[i] = max(r[i], ((q.front() - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) l[i] * (long long)r[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        vector<int> d1(s.size());\\n        int n=s.size();\\n        for (int i = 0, l = 0, r = -1; i < n; ++i) {\\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            k++;\\n        d1[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n        cout<<d1[i]<<\\' \\';\\n    }\\n        vector<int> l(s.size(),1),r(s.size(),1);\\n        queue<int> q;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                l[i] = max(l[i], l[i - 1]);\\n\\n            q.push(i);\\n\\n            while (q.front() + d1[q.front()] - 1 < i)\\n            {\\n                q.pop();\\n            }\\n\\n            l[i] = max(l[i], ((i - q.front()) * 2) + 1);\\n        }\\n        while(!q.empty()) q.pop();\\n      \\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                r[i] = max(r[i], r[i + 1]);\\n\\n            q.push(i);\\n\\n            while (q.front() - d1[q.front()] + 1 > i)\\n            {\\n                q.pop();\\n            }\\n\\n            r[i] = max(r[i], ((q.front() - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) l[i] * (long long)r[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2127513,
                "title": "manacher-algorithm-prefix-suffix-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> build_pal(string &s) // Manacher\\'s algo\\n    {\\n        int n=s.length();\\n        vector<long long> d1(n);   // [ i-d1[i]+1 , i+d1[i]-1 ];  length = 2*d1[i] - 1   \\n        for (long long i=0,l=0,r=-1; i<n; i++) \\n        {\\n            long long k = (i>r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i-k && i+k < n && s[i-k] == s[i+k]) k++;\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i-k;\\n                r = i+k;\\n            }\\n        }\\n        return d1;\\n    }\\n\\n\\n    long long maxProduct(string s) \\n    {\\n        int n=s.length();\\n        vector<long long> d1=build_pal(s);\\n        long long l[n+5],r[n+5],ans=0;\\n        memset(l,0,sizeof(l)); memset(r,0,sizeof(r));\\n        for(int i=0;i<n;i++)\\n        {\\n            r[i-d1[i]+1]=max(r[i-d1[i]+1],2*d1[i]-1);\\n            l[i+d1[i]-1]=max(l[i+d1[i]-1],2*d1[i]-1);\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n            r[i]=max(r[i],r[i-1]-2);\\n        for(int i=n-2;i>=0;i--)\\n            l[i]=max(l[i],l[i+1]-2);\\n        \\n        for(int i=1;i<n;i++)\\n            l[i]=max(l[i],l[i-1]);\\n        for(int i=n-2;i>=0;i--)\\n            r[i]=max(r[i],r[i+1]);\\n        for(int i=0;i<n;i++)\\n            ans=max(ans,l[i]*r[i+1]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> build_pal(string &s) // Manacher\\'s algo\\n    {\\n        int n=s.length();\\n        vector<long long> d1(n);   // [ i-d1[i]+1 , i+d1[i]-1 ];  length = 2*d1[i] - 1   \\n        for (long long i=0,l=0,r=-1; i<n; i++) \\n        {\\n            long long k = (i>r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i-k && i+k < n && s[i-k] == s[i+k]) k++;\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i-k;\\n                r = i+k;\\n            }\\n        }\\n        return d1;\\n    }\\n\\n\\n    long long maxProduct(string s) \\n    {\\n        int n=s.length();\\n        vector<long long> d1=build_pal(s);\\n        long long l[n+5],r[n+5],ans=0;\\n        memset(l,0,sizeof(l)); memset(r,0,sizeof(r));\\n        for(int i=0;i<n;i++)\\n        {\\n            r[i-d1[i]+1]=max(r[i-d1[i]+1],2*d1[i]-1);\\n            l[i+d1[i]-1]=max(l[i+d1[i]-1],2*d1[i]-1);\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n            r[i]=max(r[i],r[i-1]-2);\\n        for(int i=n-2;i>=0;i--)\\n            l[i]=max(l[i],l[i+1]-2);\\n        \\n        for(int i=1;i<n;i++)\\n            l[i]=max(l[i],l[i-1]);\\n        for(int i=n-2;i>=0;i--)\\n            r[i]=max(r[i],r[i+1]);\\n        for(int i=0;i<n;i++)\\n            ans=max(ans,l[i]*r[i+1]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601474,
                "title": "go-manachers-prefixmax",
                "content": "This problem is a mouthful.. I sure do hate palindromes.\\n\\nAs with many other solutions here, I use Manacher\\'s algorithm to find the maximum palindrome for each position in the input string. For more info on Manacher\\'s, please see\\nhttps://cp-algorithms.com/string/manacher.html\\n\\nWe only need to consider odd-length palindromes for this exercise.\\n\\nOnce a palindrome has been found by Manacher\\'s, store the size of the paindrome just outside the right boundary of the palindrome to the right. This will be used to form a prefix-max.\\n\\nTo get the prefix-max for left-to-right, reverse the string and the result.\\n\\nFinally, find the maximum product by combining the max palindrome to the left/right of each position in the input string.\\n\\n<iframe src=\"https://leetcode.com/playground/HvuT3KuH/shared\" frameBorder=\"0\" width=\"700\" height=\"1200\"></iframe>",
                "solutionTags": [
                    "Go"
                ],
                "code": "This problem is a mouthful.. I sure do hate palindromes.\\n\\nAs with many other solutions here, I use Manacher\\'s algorithm to find the maximum palindrome for each position in the input string. For more info on Manacher\\'s, please see\\nhttps://cp-algorithms.com/string/manacher.html\\n\\nWe only need to consider odd-length palindromes for this exercise.\\n\\nOnce a palindrome has been found by Manacher\\'s, store the size of the paindrome just outside the right boundary of the palindrome to the right. This will be used to form a prefix-max.\\n\\nTo get the prefix-max for left-to-right, reverse the string and the result.\\n\\nFinally, find the maximum product by combining the max palindrome to the left/right of each position in the input string.\\n\\n<iframe src=\"https://leetcode.com/playground/HvuT3KuH/shared\" frameBorder=\"0\" width=\"700\" height=\"1200\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2203333,
                "title": "here-is-simple-o-n-approach-self-explanatory-c-dp",
                "content": "class Solution {\\npublic:\\n    long long int maxProduct(string s) {\\n        long long int n = s.size();\\n        \\n        vector<long long int> dp(n + 1, 1);\\n        vector<long long int> udp(n + 1, 1);\\n        \\n        for (long long int i = 2; i < n; i++) {\\n            // cout << \"i = \" << i << \" i2 = \" << i - dp[i - 1] - 1 <<  endl;\\n            if (i - dp[i - 1] - 1 >= 0 && s[i] == s[i - dp[i - 1] - 1]) {\\n                dp[i] = dp[i - 1] + 2;\\n            }\\n            else\\n                dp[i] = 1;\\n            // cout << \"dpi = \" << dp[i] << endl;\\n        }\\n        \\n        \\n        for (long long int i = n - 3; i >= 0; i--) {\\n            if (i + udp[i + 1] + 1 < n && s[i] == s[i + udp[i + 1] + 1])\\n                udp[i] = udp[i + 1]  + 2;\\n            else\\n                udp[i] = 1;\\n        }\\n        \\n        \\n        vector<long long int> pl(n + 1, 1), pr(n + 1, 1);\\n        \\n        for (int i = 1; i < n; i++) {\\n            pl[i] = max(pl[i - 1], dp[i]);\\n        }\\n        for (int i = n - 2; i >= 0; i--) {\\n            pr[i] = max(pr[i + 1], udp[i]);\\n        }\\n        \\n        long long int ans = 0;\\n        \\n        for (long long int i = 0; i < n - 1; i++) {\\n            ans = max(ans, pl[i] * pr[i + 1]);\\n            if (ans < pl[i] * pr[i + 1])\\n                ans = pl[i] * pr[i + 1];\\n            // long long int t1 = pl[i], t2 = pr[i + 1];\\n            // if (t1 * t2 > 2147385345)\\n            //     cout << t1 * t2 << endl;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long int maxProduct(string s) {\\n        long long int n = s.size();\\n        \\n        vector<long long int> dp(n + 1, 1);\\n        vector<long long int> udp(n + 1, 1);\\n        \\n        for (long long int i = 2; i < n; i++) {\\n            // cout << \"i = \" << i << \" i2 = \" << i - dp[i - 1] - 1 <<  endl;\\n            if (i - dp[i - 1] - 1 >= 0 && s[i] == s[i - dp[i - 1] - 1]) {\\n                dp[i] = dp[i - 1] + 2;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1427632,
                "title": "c-manacher-o-n-103-ms-49-34-26-2-mb-57-73",
                "content": "It is known that the Manacher\\'s algorithm can obtain each maximum palindromic sequence with the odd length at different centers.\\nFrom an array of the maximum length of the given sequence, the maximum length in the interval [0, i] is easily derived.\\nTo derive the maxiimum length in the interval [j, s.size()-1], the desired array is derived when the given string is reversed.\\n\\n```\\nclass Solution {\\npublic:\\ntypedef long long int ll;\\nstd::vector<int> manacher(std::string& s){\\n  std::vector<int> R(s.size());\\n  int i = 0, j = 0;\\n  while (i < s.size()) {\\n    while (i-j >= 0 && i+j < s.size() && s[i-j] == s[i+j]) ++j;\\n    R[i] = j;\\n    int k = 1;\\n    while (i-k >= 0 && k+R[i-k] < j) R[i+k] = R[i-k], ++k;\\n    i += k; j -= k;\\n  }\\n  return std::move(R);\\n}\\n\\n  vector<int> maxlength(string &s){\\n    vector<int> center_l = manacher(s);\\n    vector<int> ans(s.size());\\n    int num = 1;\\n    int maxv = 1;\\n    for(int i=0;i<s.size()-1;i++){\\n        int len = 2 * (center_l[i] - 1) + 1;\\n        int loc = center_l[i] - 1;\\n        ans[i+loc] = max(ans[i+loc], len);\\n    }\\n    int tmp = 0;\\n    for(int i=0;i<s.size();i++){\\n        if(tmp < ans[i])\\n            tmp = ans[i];\\n        ans[i] = tmp;\\n    }\\n    int cnt = ans[s.size()-1];\\n    for(int i=s.size()-2;i>=0;i--){\\n        if(ans[i] < cnt)\\n            cnt = cnt - 2;\\n        ans[i] = cnt;\\n    }\\n    return std::move(ans);\\n  }\\n    \\n  long long maxProduct(string s) {\\n    vector<int> left = maxlength(s);\\n    reverse(s.begin(), s.end());\\n    vector<int> right = maxlength(s);\\n    ll ans = 0;\\n    for(int i=0;i<s.size()-1;i++){\\n        ll l = left[i];\\n        ll r = right[s.size() - i -2];\\n        if(ans < l * r)\\n            ans = l * r;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long int ll;\\nstd::vector<int> manacher(std::string& s){\\n  std::vector<int> R(s.size());\\n  int i = 0, j = 0;\\n  while (i < s.size()) {\\n    while (i-j >= 0 && i+j < s.size() && s[i-j] == s[i+j]) ++j;\\n    R[i] = j;\\n    int k = 1;\\n    while (i-k >= 0 && k+R[i-k] < j) R[i+k] = R[i-k], ++k;\\n    i += k; j -= k;\\n  }\\n  return std::move(R);\\n}\\n\\n  vector<int> maxlength(string &s){\\n    vector<int> center_l = manacher(s);\\n    vector<int> ans(s.size());\\n    int num = 1;\\n    int maxv = 1;\\n    for(int i=0;i<s.size()-1;i++){\\n        int len = 2 * (center_l[i] - 1) + 1;\\n        int loc = center_l[i] - 1;\\n        ans[i+loc] = max(ans[i+loc], len);\\n    }\\n    int tmp = 0;\\n    for(int i=0;i<s.size();i++){\\n        if(tmp < ans[i])\\n            tmp = ans[i];\\n        ans[i] = tmp;\\n    }\\n    int cnt = ans[s.size()-1];\\n    for(int i=s.size()-2;i>=0;i--){\\n        if(ans[i] < cnt)\\n            cnt = cnt - 2;\\n        ans[i] = cnt;\\n    }\\n    return std::move(ans);\\n  }\\n    \\n  long long maxProduct(string s) {\\n    vector<int> left = maxlength(s);\\n    reverse(s.begin(), s.end());\\n    vector<int> right = maxlength(s);\\n    ll ans = 0;\\n    for(int i=0;i<s.size()-1;i++){\\n        ll l = left[i];\\n        ll r = right[s.size() - i -2];\\n        if(ans < l * r)\\n            ans = l * r;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394034,
                "title": "c-1960-maximum-product-of-the-length-of-two-palindromic-substrings",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.size(), center = 0, right = 0; \\n        vector<int> hlen(n, 0), prefix(n, 0), suffix(n, 0); \\n        for (int i = 0; i < n; ++i) {\\n            if (i < right) hlen[i] = min(right - i, hlen[2*center - i]); \\n            while (0 <= i-1-hlen[i] && i+1+hlen[i] < n && s[i-1-hlen[i]] == s[i+1+hlen[i]]) ++hlen[i]; \\n            if (right < i + hlen[i]) {\\n                center = i; \\n                right = i + hlen[i]; \\n            }\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i] + 1); \\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i] + 1); \\n        }\\n        \\n        for (int i = 1; i < n; ++i) {\\n            prefix[n-1-i] = max(prefix[n-1-i], prefix[n-i]-2); \\n            suffix[i] = max(suffix[i], suffix[i-1]-2); \\n        }\\n        \\n        for (int i = 1; i < n; ++i) {\\n            prefix[i] = max(prefix[i-1], prefix[i]); \\n            suffix[n-1-i] = max(suffix[n-1-i], suffix[n-i]); \\n        }\\n        \\n        long long ans = 0ll; \\n        for (int i = 1; i < n; ++i) ans = max(ans, (long long) prefix[i-1] * suffix[i]); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.size(), center = 0, right = 0; \\n        vector<int> hlen(n, 0), prefix(n, 0), suffix(n, 0); \\n        for (int i = 0; i < n; ++i) {\\n            if (i < right) hlen[i] = min(right - i, hlen[2*center - i]); \\n            while (0 <= i-1-hlen[i] && i+1+hlen[i] < n && s[i-1-hlen[i]] == s[i+1+hlen[i]]) ++hlen[i]; \\n            if (right < i + hlen[i]) {\\n                center = i; \\n                right = i + hlen[i]; \\n            }\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i] + 1); \\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i] + 1); \\n        }\\n        \\n        for (int i = 1; i < n; ++i) {\\n            prefix[n-1-i] = max(prefix[n-1-i], prefix[n-i]-2); \\n            suffix[i] = max(suffix[i], suffix[i-1]-2); \\n        }\\n        \\n        for (int i = 1; i < n; ++i) {\\n            prefix[i] = max(prefix[i-1], prefix[i]); \\n            suffix[n-1-i] = max(suffix[n-1-i], suffix[n-i]); \\n        }\\n        \\n        long long ans = 0ll; \\n        for (int i = 1; i < n; ++i) ans = max(ans, (long long) prefix[i-1] * suffix[i]); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391003,
                "title": "c-o-n-manacher-s-algorithm",
                "content": "```csharp\\npublic int[] helper(string s)\\n{\\n\\t// Manacher\\'s Algorithm\\n\\tint[] d = new int[s.Length];\\n\\tint left = 0, right = -1;\\n\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t{\\n\\t\\tint k = (i > right) ? 1 : Math.Min(d[left + right - i], right - i + 1);\\n\\t\\twhile (0 <= i - k && i + k < s.Length && s[i - k] == s[i + k])\\n\\t\\t{\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\n\\t\\td[i] = k;\\n\\t\\tk--;\\n\\t\\tif (i + k > right)\\n\\t\\t{\\n\\t\\t\\tleft = i - k;\\n\\t\\t\\tright = i + k;\\n\\t\\t}\\n\\t}\\n\\n\\t// Find max range for given element and find max palindrome upto i\\n\\tint[] maxRange = new int[s.Length];\\n\\tint n = s.Length;\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tmaxRange[i - d[i] + 1] = i;\\n\\t}\\n\\n\\tint max = 0;\\n\\tint[] maxL = new int[n];\\n\\tArray.Fill(maxL, 1);\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tmax = Math.Max(maxRange[i], max);\\n\\t\\tmaxL[i] = Math.Max((max - i) * 2 + 1, maxL[i]);\\n\\t}\\n\\n\\tfor (int i = n - 2; i >= 0; i--)\\n\\t{\\n\\t\\tmaxL[i] = Math.Max(maxL[i + 1], maxL[i]);\\n\\t}\\n\\n\\treturn maxL;\\n}\\n\\npublic long MaxProduct(string s)\\n{\\n\\tint[] left = helper(s);\\n\\tint[] right = helper(new string(s.Reverse().ToArray()));\\n\\n\\tlong result = 0L;\\n\\tfor (int i = 1; i < s.Length; i++)\\n\\t{\\n\\t\\tresult = Math.Max(result, 1L * left[i] * right[s.Length - i]);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int[] helper(string s)\\n{\\n\\t// Manacher\\'s Algorithm\\n\\tint[] d = new int[s.Length];\\n\\tint left = 0, right = -1;\\n\\n\\tfor (int i = 0; i < s.Length; i++)\\n\\t{\\n\\t\\tint k = (i > right) ? 1 : Math.Min(d[left + right - i], right - i + 1);\\n\\t\\twhile (0 <= i - k && i + k < s.Length && s[i - k] == s[i + k])\\n\\t\\t{\\n\\t\\t\\tk++;\\n\\t\\t}\\n\\n\\t\\td[i] = k;\\n\\t\\tk--;\\n\\t\\tif (i + k > right)\\n\\t\\t{\\n\\t\\t\\tleft = i - k;\\n\\t\\t\\tright = i + k;\\n\\t\\t}\\n\\t}\\n\\n\\t// Find max range for given element and find max palindrome upto i\\n\\tint[] maxRange = new int[s.Length];\\n\\tint n = s.Length;\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tmaxRange[i - d[i] + 1] = i;\\n\\t}\\n\\n\\tint max = 0;\\n\\tint[] maxL = new int[n];\\n\\tArray.Fill(maxL, 1);\\n\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tmax = Math.Max(maxRange[i], max);\\n\\t\\tmaxL[i] = Math.Max((max - i) * 2 + 1, maxL[i]);\\n\\t}\\n\\n\\tfor (int i = n - 2; i >= 0; i--)\\n\\t{\\n\\t\\tmaxL[i] = Math.Max(maxL[i + 1], maxL[i]);\\n\\t}\\n\\n\\treturn maxL;\\n}\\n\\npublic long MaxProduct(string s)\\n{\\n\\tint[] left = helper(s);\\n\\tint[] right = helper(new string(s.Reverse().ToArray()));\\n\\n\\tlong result = 0L;\\n\\tfor (int i = 1; i < s.Length; i++)\\n\\t{\\n\\t\\tresult = Math.Max(result, 1L * left[i] * right[s.Length - i]);\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389963,
                "title": "rolling-hash-preprocessing-and-binary-search-at-each-position-o-n-log-n",
                "content": "```\\ntypedef long long ll;\\nll H = 1000000007;\\n\\n\\nclass RollingHash {\\npublic:\\n    RollingHash(const string& s) {\\n        int n = s.length();\\n        pre.resize(n + 1);\\n        for (int i = 0; i < n; i++) {\\n            pre[i + 1] = (pre[i] * 26 + s[i]) % H;\\n        }\\n        b.resize(n + 1);\\n        b[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            b[i] = (b[i - 1] * 26) % H;\\n        }\\n    }\\n\\n    // [start, limit)\\n    ll Query(int start, int limit) const {\\n        int len = limit - start;\\n        ll res = (pre[limit] - pre[start] * b[len]) % H;\\n        if (res < 0) res += H;\\n        return res;\\n    }\\n    \\n    private:\\n    vector<ll> pre;\\n    vector<ll> b;\\n};\\n\\nint FindMaxPalLen(int i, int n, const RollingHash& left_rolling, const RollingHash& right_rolling) {\\n    int l = 1;\\n    int r = min<int>(i + 1, n - i);\\n    while (l <= r) {\\n        int m = (l + r) / 2;\\n        ll h1 = left_rolling.Query(i, i + m);\\n        ll h2 = right_rolling.Query(n - 1 - i, n - 1 - i + m);\\n        if (h1 == h2) {\\n            l = m + 1;\\n        } else {\\n            r = m - 1;\\n        }\\n    }\\n    return r;\\n}\\n\\nvector<int> PrefixMaxPalLen(const vector<int>& v) {\\n    int n = v.size();\\n    vector<int> res(n, 1);\\n    for (int i = 0; i < n; i++) {\\n        int& tar = res[i + v[i] - 1];\\n        tar = max(tar, v[i] * 2 - 1);\\n    }\\n    for (int i = 1; i < n; i++) {\\n        res[i] = max(res[i - 1], res[i]);\\n    }\\n    for (int i = n - 2; i >= 0; i--) {\\n        res[i] = max(res[i], res[i + 1] - 2);\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length();\\n        RollingHash left_rolling(s);\\n\\n        string r = s;\\n        reverse(r.begin(), r.end());\\n        RollingHash right_rolling(r);\\n        \\n        vector<int> g(n);\\n        for (int i = 0; i < n; i++) {\\n            g[i] = FindMaxPalLen(i, n, left_rolling, right_rolling);\\n        }\\n        \\n        auto vl = PrefixMaxPalLen(g);\\n\\n        vector<int> gr = g;\\n        reverse(gr.begin(), gr.end());\\n        auto vr = PrefixMaxPalLen(gr);\\n\\n        ll res = 0;\\n        for (int i = 1; i < n; i++) {\\n            ll t = vl[i - 1];\\n            t *= vr[n - i - 1];\\n            res = max(res, t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nll H = 1000000007;\\n\\n\\nclass RollingHash {\\npublic:\\n    RollingHash(const string& s) {\\n        int n = s.length();\\n        pre.resize(n + 1);\\n        for (int i = 0; i < n; i++) {\\n            pre[i + 1] = (pre[i] * 26 + s[i]) % H;\\n        }\\n        b.resize(n + 1);\\n        b[0] = 1;\\n        for (int i = 1; i <= n; i++) {\\n            b[i] = (b[i - 1] * 26) % H;\\n        }\\n    }\\n\\n    // [start, limit)\\n    ll Query(int start, int limit) const {\\n        int len = limit - start;\\n        ll res = (pre[limit] - pre[start] * b[len]) % H;\\n        if (res < 0) res += H;\\n        return res;\\n    }\\n    \\n    private:\\n    vector<ll> pre;\\n    vector<ll> b;\\n};\\n\\nint FindMaxPalLen(int i, int n, const RollingHash& left_rolling, const RollingHash& right_rolling) {\\n    int l = 1;\\n    int r = min<int>(i + 1, n - i);\\n    while (l <= r) {\\n        int m = (l + r) / 2;\\n        ll h1 = left_rolling.Query(i, i + m);\\n        ll h2 = right_rolling.Query(n - 1 - i, n - 1 - i + m);\\n        if (h1 == h2) {\\n            l = m + 1;\\n        } else {\\n            r = m - 1;\\n        }\\n    }\\n    return r;\\n}\\n\\nvector<int> PrefixMaxPalLen(const vector<int>& v) {\\n    int n = v.size();\\n    vector<int> res(n, 1);\\n    for (int i = 0; i < n; i++) {\\n        int& tar = res[i + v[i] - 1];\\n        tar = max(tar, v[i] * 2 - 1);\\n    }\\n    for (int i = 1; i < n; i++) {\\n        res[i] = max(res[i - 1], res[i]);\\n    }\\n    for (int i = n - 2; i >= 0; i--) {\\n        res[i] = max(res[i], res[i + 1] - 2);\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length();\\n        RollingHash left_rolling(s);\\n\\n        string r = s;\\n        reverse(r.begin(), r.end());\\n        RollingHash right_rolling(r);\\n        \\n        vector<int> g(n);\\n        for (int i = 0; i < n; i++) {\\n            g[i] = FindMaxPalLen(i, n, left_rolling, right_rolling);\\n        }\\n        \\n        auto vl = PrefixMaxPalLen(g);\\n\\n        vector<int> gr = g;\\n        reverse(gr.begin(), gr.end());\\n        auto vr = PrefixMaxPalLen(gr);\\n\\n        ll res = 0;\\n        for (int i = 1; i < n; i++) {\\n            ll t = vl[i - 1];\\n            t *= vr[n - i - 1];\\n            res = max(res, t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389276,
                "title": "c-57-60",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n    \\n     int n=s.length();\\n       \\n      vector<int> d1(n);\\n       for (int i = 0, l = 0, r = -1; i < n; i++) {\\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\\n            k++;\\n        }\\n        d1[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n           \\n           \\n    }\\n\\n       \\n        vector<int>right(n,0);\\n        vector<int>left(n,0);\\n       \\n        for(int i=n-1;i>=0;i--){\\n            right[i-d1[i]+1]=max(2*d1[i]-1,right[i-d1[i]+1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            left[i+d1[i]-1]=max(2*d1[i]-1,left[i+d1[i]-1]);\\n        }\\n        for(int i=1;i<n;i++){\\n            left[i]=max(left[i],left[i-1]);\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            right[i]=max(right[i],right[i+1]);\\n        }\\n        int i=0;\\n       long long  int ans=0;\\n        while(i<n){\\n            \\n            long long int x=d1[i];\\n            while(x){\\n                if(i-x>=0){\\n                ans=max(ans,left[i-x]*1ll*(2*1ll*x-1ll));\\n                }\\n                if(i+x<n){\\n                ans=max(ans,right[i+x]*1ll*(2*1ll*x-1ll));\\n                }\\n                x--;\\n            }\\n            i+=d1[i];\\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n    \\n     int n=s.length();\\n       \\n      vector<int> d1(n);\\n       for (int i = 0, l = 0, r = -1; i < n; i++) {\\n        int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n        while (0 <= i - k && i + k < n && s[i - k] == s[i + k]) {\\n            k++;\\n        }\\n        d1[i] = k--;\\n        if (i + k > r) {\\n            l = i - k;\\n            r = i + k;\\n        }\\n           \\n           \\n    }\\n\\n       \\n        vector<int>right(n,0);\\n        vector<int>left(n,0);\\n       \\n        for(int i=n-1;i>=0;i--){\\n            right[i-d1[i]+1]=max(2*d1[i]-1,right[i-d1[i]+1]);\\n        }\\n        for(int i=0;i<n;i++){\\n            left[i+d1[i]-1]=max(2*d1[i]-1,left[i+d1[i]-1]);\\n        }\\n        for(int i=1;i<n;i++){\\n            left[i]=max(left[i],left[i-1]);\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            right[i]=max(right[i],right[i+1]);\\n        }\\n        int i=0;\\n       long long  int ans=0;\\n        while(i<n){\\n            \\n            long long int x=d1[i];\\n            while(x){\\n                if(i-x>=0){\\n                ans=max(ans,left[i-x]*1ll*(2*1ll*x-1ll));\\n                }\\n                if(i+x<n){\\n                ans=max(ans,right[i+x]*1ll*(2*1ll*x-1ll));\\n                }\\n                x--;\\n            }\\n            i+=d1[i];\\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886037,
                "title": "o-n-manacher-dp-easy-to-understand-link-to-manacher-blog",
                "content": "Before checking out the solution please check out this blog(https://cp-algorithms.com/string/manacher.html#implementation-of-manachers-algorithm)for manacher algorithm.\\nJust used manacher to find odd palindromes and then use dp to store the length of palindrome and compute the value of ans at each step.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long maxProduct(string str) {\\n        int n = str.length();\\n        ll ans = 1;\\n\\n        str = \"!\" + str + \"?\";\\n        vector<ll > p(n + 2, 1);\\n        vector<ll > dp(n + 1, 0);\\n        dp[2] = 1;\\n        ll l = 1; ll r = 1;\\n        for(ll i = 1; i <= n; i++)\\n        {\\n            p[i] = max(0LL, min(r - i, p[l + (r - i)]));\\n            while(str[i - p[i]] == str[i + p[i]])\\n            {\\n                p[i]++;\\n                dp[i + p[i] - 1] = max(dp[i + p[i] - 1], (2 * p[i] - 1));\\n                ans = max(ans, (2 * p[i] - 1) * dp[i - p[i]]);\\n            }\\n            ans = max(ans, (2 * p[i] - 1) * dp[i - p[i]]);\\n            dp[i] = max(dp[i], dp[i - 1]);\\n            if(i + p[i] > r){r = i + p[i], l = i - p[i];}\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long maxProduct(string str) {\\n        int n = str.length();\\n        ll ans = 1;\\n\\n        str = \"!\" + str + \"?\";\\n        vector<ll > p(n + 2, 1);\\n        vector<ll > dp(n + 1, 0);\\n        dp[2] = 1;\\n        ll l = 1; ll r = 1;\\n        for(ll i = 1; i <= n; i++)\\n        {\\n            p[i] = max(0LL, min(r - i, p[l + (r - i)]));\\n            while(str[i - p[i]] == str[i + p[i]])\\n            {\\n                p[i]++;\\n                dp[i + p[i] - 1] = max(dp[i + p[i] - 1], (2 * p[i] - 1));\\n                ans = max(ans, (2 * p[i] - 1) * dp[i - p[i]]);\\n            }\\n            ans = max(ans, (2 * p[i] - 1) * dp[i - p[i]]);\\n            dp[i] = max(dp[i], dp[i - 1]);\\n            if(i + p[i] > r){r = i + p[i], l = i - p[i];}\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808911,
                "title": "manachers-s-algo-beats-90-time",
                "content": "# Complexity\\n- Time complexity:\\n4 * O(N)\\n\\n- Space complexity:\\n3 * O(N)\\n\\n# Code\\n```\\nclass Solution {\\n  public long maxProduct(String s) {\\n    if (s.length() == 2) {\\n      return 1;\\n    }\\n\\n    long[] starts = new long[s.length()];\\n    long[] ends = new long[s.length()];\\n    long[] lps = new long[s.length()];\\n    Arrays.fill(starts, 1);\\n    Arrays.fill(ends, 1);\\n    int center = 0, r = 0;\\n    for (int i = 0; i < s.length(); i++) {\\n      int cl = i - 1;\\n      int cr = i + 1;\\n      if (i != center && i < r) {\\n        int mirrEl = center - (i - center);\\n        if (lps[mirrEl] < r - i) {\\n          lps[i] = lps[mirrEl];\\n          starts[i - (int)lps[i]] = Math.max(starts[i - (int)lps[i]], 2 * lps[i] + 1);\\n          continue;\\n        }\\n\\n        cl = 2 * i  - r - 1;\\n        cr = r + 1;\\n        lps[i] = r - i;\\n        starts[cl + 1] = Math.max(starts[cl + 1], 2 * lps[i] + 1);\\n      }\\n\\n      center = i;\\n      while (cl >= 0 && cr < s.length() &&\\n        s.charAt(cl) == s.charAt(cr)) {\\n        lps[i]++;\\n        starts[cl] = 2 * lps[i] + 1;\\n        ends[cr] = 2 * lps[i] + 1;\\n        cl--;\\n        cr++;\\n      }\\n      \\n      r = cr - 1;\\n    }\\n\\n    long maxProd = 1;\\n    for (int i = 1; i < s.length(); i++) {\\n      if (starts[i - 1] > 1 && starts[i] == 1) {\\n        starts[i] = starts[i - 1] - 2;\\n      }\\n\\n      ends[i] = Math.max(ends[i - 1], ends[i]);\\n    }\\n\\n    for (int j = s.length() - 2; j >= 0; j--) {\\n      starts[j] = Math.max(starts[j + 1], starts[j]);\\n      maxProd = Math.max(maxProd, ends[j] * starts[j + 1]);\\n    }\\n\\n    return maxProd;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long maxProduct(String s) {\\n    if (s.length() == 2) {\\n      return 1;\\n    }\\n\\n    long[] starts = new long[s.length()];\\n    long[] ends = new long[s.length()];\\n    long[] lps = new long[s.length()];\\n    Arrays.fill(starts, 1);\\n    Arrays.fill(ends, 1);\\n    int center = 0, r = 0;\\n    for (int i = 0; i < s.length(); i++) {\\n      int cl = i - 1;\\n      int cr = i + 1;\\n      if (i != center && i < r) {\\n        int mirrEl = center - (i - center);\\n        if (lps[mirrEl] < r - i) {\\n          lps[i] = lps[mirrEl];\\n          starts[i - (int)lps[i]] = Math.max(starts[i - (int)lps[i]], 2 * lps[i] + 1);\\n          continue;\\n        }\\n\\n        cl = 2 * i  - r - 1;\\n        cr = r + 1;\\n        lps[i] = r - i;\\n        starts[cl + 1] = Math.max(starts[cl + 1], 2 * lps[i] + 1);\\n      }\\n\\n      center = i;\\n      while (cl >= 0 && cr < s.length() &&\\n        s.charAt(cl) == s.charAt(cr)) {\\n        lps[i]++;\\n        starts[cl] = 2 * lps[i] + 1;\\n        ends[cr] = 2 * lps[i] + 1;\\n        cl--;\\n        cr++;\\n      }\\n      \\n      r = cr - 1;\\n    }\\n\\n    long maxProd = 1;\\n    for (int i = 1; i < s.length(); i++) {\\n      if (starts[i - 1] > 1 && starts[i] == 1) {\\n        starts[i] = starts[i - 1] - 2;\\n      }\\n\\n      ends[i] = Math.max(ends[i - 1], ends[i]);\\n    }\\n\\n    for (int j = s.length() - 2; j >= 0; j--) {\\n      starts[j] = Math.max(starts[j + 1], starts[j]);\\n      maxProd = Math.max(maxProd, ends[j] * starts[j + 1]);\\n    }\\n\\n    return maxProd;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776217,
                "title": "lines-sweep-on-largest-pall-from-center",
                "content": "# Intuition\\nyou must be clear with the concept that we can check weather string is pallindrome or not by matching string\\'s hash and it\\'s reverse hash. After then we can use computation of largest pallindrome possible from any index as center to get desired solution \\n\\n# Approach\\nfirst find hashes for string and it\\'s reverse, such that we can find hash of any substring in O(1) and hence check for pallindrome of some substring becomes O(1). \\n    After then find largest pallindrome that is possible taking every index as center, this can be optimized using binary search. \\n    Now we are required to find largest pallindrome possible for some prefix starting at i , and for some suffix starting from i, this is required to make computation of product by considering each breaking point (i,i+1)th indexes. \\n    These computations are performed using something like line sweep which can be easily understood by implementation, basically idea is to remove elements from our set when they have gone out of bound, and use elements in our set to make computation. \\n    After then we can find largest pallindromic string possible in some prefix i/suffix i (not necessarily ending at i), that will make product computation faster as shown in implemenation \\n\\n# Complexity\\n- Time complexity:\\nNlogN\\n\\n- Space complexity:\\nN\\n\\n# Code\\n```\\n#define ll long long\\nclass Hashing{\\n    int prime = 35, MOD = 1e9+7; \\n    vector<ll> power, left, right;\\n    long long lhash(int l, int r){\\n        return (left[r+1] - (left[l]*power[r - l + 1])%MOD + MOD)%MOD;\\n    }\\n    long long rhash(int l, int r){\\n        return (right[l] - (right[r+1]*power[r - l + 1])%MOD + MOD)%MOD;\\n    }\\n    public: \\n    bool isPalindrome(int l, int r){\\n        return lhash(l,r) == rhash(l,r);\\n    }\\n    Hashing(string &s): power(s.length()+1,1),left(s.length()+1),right(s.length()+1){\\n        int n = s.length();\\n        for(int i=1;i<n;i+=1) power[i] = (power[i-1]*prime)%MOD; \\n        left[0] = right[n] = 1; \\n        for(int i=0; i<n; i++){\\n            left[i+1] = (prime*left[i] + s[i] - \\'a\\')%MOD;\\n        }\\n        for(int i=n-1;i>=0;i-=1){\\n            right[i] = (right[i+1]*prime + s[i] - \\'a\\')%MOD; \\n        }\\n    }\\n}; \\nint search(Hashing &hash,string &s,int i){\\n    // find index after which increasing length will result in non pall string\\n    int left = 0,right = s.length(); \\n    while(left < right){\\n        int mid = (left + right+1)/2; \\n        if(i-mid >=0 and i+mid < s.length() and hash.isPalindrome(i-mid,i + mid)){\\n            // then try to increase it further \\n            left = mid; \\n        }\\n        else{\\n            right = mid-1; \\n        }\\n    }\\n    return left;  \\n}\\nvector<int> findSuffix(vector<int> &centers){\\n    int n = centers.size(); \\n    vector<int> left(n); \\n    set<pair<int,int> > end; \\n    set<int> center; \\n    for(int i=0;i<n;i+=1){\\n        // insertion time \\n        end.insert({i + centers[i],i}); \\n        center.insert(i); \\n        // removal time \\n        while(end.begin()->first < i) center.erase(end.begin()->second),end.erase(end.begin()); \\n\\n        // value finding time \\n        int minLeftCenter = *center.begin(); \\n        left[i] = 2*(i - minLeftCenter) + 1; \\n\\n        // one of important step \\n        if(i) left[i] = max(left[i],left[i-1]); \\n    }\\n    return left; \\n}\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length(); \\n        Hashing hash(s);  // creates hash of string and reverseString then tells weather l,r is pall or not\\n        vector<int> centers(n,1);\\n        for(int i=0;i<n;i+=1) centers[i] = search(hash,s,i);\\n        vector<int> left = findSuffix(centers); \\n        reverse(centers.begin(),centers.end()); \\n        vector<int> right = findSuffix(centers); \\n        reverse(right.begin(),right.end());\\n        ll ans =0 ; \\n        for(int i=0;i<n-1;i+=1){\\n            ans = max(ans,left[i]*1ll*right[i+1]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Hashing{\\n    int prime = 35, MOD = 1e9+7; \\n    vector<ll> power, left, right;\\n    long long lhash(int l, int r){\\n        return (left[r+1] - (left[l]*power[r - l + 1])%MOD + MOD)%MOD;\\n    }\\n    long long rhash(int l, int r){\\n        return (right[l] - (right[r+1]*power[r - l + 1])%MOD + MOD)%MOD;\\n    }\\n    public: \\n    bool isPalindrome(int l, int r){\\n        return lhash(l,r) == rhash(l,r);\\n    }\\n    Hashing(string &s): power(s.length()+1,1),left(s.length()+1),right(s.length()+1){\\n        int n = s.length();\\n        for(int i=1;i<n;i+=1) power[i] = (power[i-1]*prime)%MOD; \\n        left[0] = right[n] = 1; \\n        for(int i=0; i<n; i++){\\n            left[i+1] = (prime*left[i] + s[i] - \\'a\\')%MOD;\\n        }\\n        for(int i=n-1;i>=0;i-=1){\\n            right[i] = (right[i+1]*prime + s[i] - \\'a\\')%MOD; \\n        }\\n    }\\n}; \\nint search(Hashing &hash,string &s,int i){\\n    // find index after which increasing length will result in non pall string\\n    int left = 0,right = s.length(); \\n    while(left < right){\\n        int mid = (left + right+1)/2; \\n        if(i-mid >=0 and i+mid < s.length() and hash.isPalindrome(i-mid,i + mid)){\\n            // then try to increase it further \\n            left = mid; \\n        }\\n        else{\\n            right = mid-1; \\n        }\\n    }\\n    return left;  \\n}\\nvector<int> findSuffix(vector<int> &centers){\\n    int n = centers.size(); \\n    vector<int> left(n); \\n    set<pair<int,int> > end; \\n    set<int> center; \\n    for(int i=0;i<n;i+=1){\\n        // insertion time \\n        end.insert({i + centers[i],i}); \\n        center.insert(i); \\n        // removal time \\n        while(end.begin()->first < i) center.erase(end.begin()->second),end.erase(end.begin()); \\n\\n        // value finding time \\n        int minLeftCenter = *center.begin(); \\n        left[i] = 2*(i - minLeftCenter) + 1; \\n\\n        // one of important step \\n        if(i) left[i] = max(left[i],left[i-1]); \\n    }\\n    return left; \\n}\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length(); \\n        Hashing hash(s);  // creates hash of string and reverseString then tells weather l,r is pall or not\\n        vector<int> centers(n,1);\\n        for(int i=0;i<n;i+=1) centers[i] = search(hash,s,i);\\n        vector<int> left = findSuffix(centers); \\n        reverse(centers.begin(),centers.end()); \\n        vector<int> right = findSuffix(centers); \\n        reverse(right.begin(),right.end());\\n        ll ans =0 ; \\n        for(int i=0;i<n-1;i+=1){\\n            ans = max(ans,left[i]*1ll*right[i+1]); \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3721119,
                "title": "c-manacher-s-algorithm-easy-to-understand-well-documented",
                "content": "# Intuition\\nUse Recursion and DP will still be too slow to solve the question.\\n\\nInstead, use Manacher\\'s algorithm to solve this.\\nManacher\\'s algorithm finds the odd palindrome length on different s[i]\\n\\nAnd then we can calculate the max palindrome len when cutting the string on different s[i].\\n\\n# Approach\\n1. Find all odd palindrome on different s[i]\\n2. Calculate all the max palindrome len on different cut on the left\\n3. Calculate all the max palindrome len on different cut on the right\\n4. For each cut i, times the max len on both side\\n5. Return the max product\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n``` C++\\nclass Solution {\\npublic:\\n\\n    long long maxProduct(string s) {\\n        vector<int> result = getOddPalindromeManacher(s, 0, s.size()-1);\\n        vector<int> left_result = maxLeftOnDifferentCut(result);\\n        vector<int> right_result = maxRightOnDifferentCut(result);\\n\\n        long long max_product = 0;\\n        for(int i=0; i<s.size()-1; i++){\\n            long long product = (long long)left_result[i] * right_result[i+1];\\n            if(product>max_product)\\n                max_product = product;\\n        }\\n        return max_product;\\n    }\\n\\n    vector<int> getOddPalindromeManacher(string& s, int f, int t){\\n        \\n        vector<int> result(s.size(), 1);\\n\\n        int previous_center = -1;\\n        int previous_left = -1;\\n        int previous_right = -1;\\n        for(int i=f; i<=t; i++){\\n            int temp_l = i;\\n            int temp_r = i;\\n            if(previous_right > i){\\n                int mirror_i = previous_center - (i-previous_center);\\n                int mirror_len = result[mirror_i];\\n                int mirror_left = mirror_i - mirror_len/2;\\n                if(mirror_left > previous_left){\\n                    result[i] = mirror_len;\\n                    continue;\\n                }\\n                temp_r = previous_right;\\n                temp_l = i - (previous_right - i);\\n            }\\n\\n            auto [l, r] = getPalindromeRange(s, f, t, i, temp_l, temp_r);\\n            previous_center = i;\\n            previous_left = l;\\n            previous_right = r;\\n            result[i] = r-l+1;\\n\\n        }\\n        return result;\\n    }\\n\\n    inline tuple<int, int> getPalindromeRange(string& s, int f, int t, int i, int l, int r){\\n        l--; r++;\\n\\n        while(l>=f && r<=t){\\n            if(s[l]!=s[r])\\n                break;\\n\\n            l--; r++;\\n        }\\n\\n        l++; r--;\\n        return {l, r};\\n    }\\n\\n    vector<int> maxLeftOnDifferentCut(vector<int>& result) {\\n        /*\\n        Determine the max palindrome len of the left on different cut\\n        left_result[i] = the max palindrome len when cutting the array into [0, i] (i, result.size()-1] two slices\\n                         the max_len on the [0, i] side\\n\\n        left_result[i] means the max palindrome len on the left side when s[i] is included in the left side\\n        */\\n        vector<int> left_result = vector<int>(result.size());\\n\\n        left_result[0] = 1;\\n        int limit = 1;\\n        int max_len = 1;\\n        for (int center = 0; center < left_result.size(); center++) {\\n            int most_right = center + ( result[center]-1 ) / 2;\\n\\n            while (limit <= most_right) {\\n                int len = ( limit - center ) * 2 + 1;\\n                if(len>max_len)\\n                    max_len = len;\\n                left_result[limit++] = max_len;\\n            }\\n        }\\n        return left_result;\\n    }\\n\\n    vector<int> maxRightOnDifferentCut(vector<int>& result) {\\n        /*\\n        Determine the max palindrome len of the right on different cut\\n        right_result[i] = the max palindrome len when cutting the array into [0, i) [i, result.size()-1] two slices\\n                          the max_len on the [i, result.size()-1] side\\n        \\n        right_result[i] means the max palindrome len on the right side when s[i] is included in the right side\\n        */\\n        vector<int> right_result = vector<int>(result.size());\\n\\n        right_result[result.size()-1] = 1;\\n        int limit = result.size()-2;\\n        int max_len = 1;\\n        for (int center = right_result.size()-1; center >= 0; center--) {\\n            int most_left = center - ( result[center]-1 ) / 2;\\n            \\n            while (most_left <= limit) {\\n                int len = ( center - limit ) * 2 + 1;\\n                if(len > max_len){\\n                    max_len = len;\\n                }\\n                right_result[limit--] = max_len;\\n            }\\n        }\\n        return right_result;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++\\nclass Solution {\\npublic:\\n\\n    long long maxProduct(string s) {\\n        vector<int> result = getOddPalindromeManacher(s, 0, s.size()-1);\\n        vector<int> left_result = maxLeftOnDifferentCut(result);\\n        vector<int> right_result = maxRightOnDifferentCut(result);\\n\\n        long long max_product = 0;\\n        for(int i=0; i<s.size()-1; i++){\\n            long long product = (long long)left_result[i] * right_result[i+1];\\n            if(product>max_product)\\n                max_product = product;\\n        }\\n        return max_product;\\n    }\\n\\n    vector<int> getOddPalindromeManacher(string& s, int f, int t){\\n        \\n        vector<int> result(s.size(), 1);\\n\\n        int previous_center = -1;\\n        int previous_left = -1;\\n        int previous_right = -1;\\n        for(int i=f; i<=t; i++){\\n            int temp_l = i;\\n            int temp_r = i;\\n            if(previous_right > i){\\n                int mirror_i = previous_center - (i-previous_center);\\n                int mirror_len = result[mirror_i];\\n                int mirror_left = mirror_i - mirror_len/2;\\n                if(mirror_left > previous_left){\\n                    result[i] = mirror_len;\\n                    continue;\\n                }\\n                temp_r = previous_right;\\n                temp_l = i - (previous_right - i);\\n            }\\n\\n            auto [l, r] = getPalindromeRange(s, f, t, i, temp_l, temp_r);\\n            previous_center = i;\\n            previous_left = l;\\n            previous_right = r;\\n            result[i] = r-l+1;\\n\\n        }\\n        return result;\\n    }\\n\\n    inline tuple<int, int> getPalindromeRange(string& s, int f, int t, int i, int l, int r){\\n        l--; r++;\\n\\n        while(l>=f && r<=t){\\n            if(s[l]!=s[r])\\n                break;\\n\\n            l--; r++;\\n        }\\n\\n        l++; r--;\\n        return {l, r};\\n    }\\n\\n    vector<int> maxLeftOnDifferentCut(vector<int>& result) {\\n        /*\\n        Determine the max palindrome len of the left on different cut\\n        left_result[i] = the max palindrome len when cutting the array into [0, i] (i, result.size()-1] two slices\\n                         the max_len on the [0, i] side\\n\\n        left_result[i] means the max palindrome len on the left side when s[i] is included in the left side\\n        */\\n        vector<int> left_result = vector<int>(result.size());\\n\\n        left_result[0] = 1;\\n        int limit = 1;\\n        int max_len = 1;\\n        for (int center = 0; center < left_result.size(); center++) {\\n            int most_right = center + ( result[center]-1 ) / 2;\\n\\n            while (limit <= most_right) {\\n                int len = ( limit - center ) * 2 + 1;\\n                if(len>max_len)\\n                    max_len = len;\\n                left_result[limit++] = max_len;\\n            }\\n        }\\n        return left_result;\\n    }\\n\\n    vector<int> maxRightOnDifferentCut(vector<int>& result) {\\n        /*\\n        Determine the max palindrome len of the right on different cut\\n        right_result[i] = the max palindrome len when cutting the array into [0, i) [i, result.size()-1] two slices\\n                          the max_len on the [i, result.size()-1] side\\n        \\n        right_result[i] means the max palindrome len on the right side when s[i] is included in the right side\\n        */\\n        vector<int> right_result = vector<int>(result.size());\\n\\n        right_result[result.size()-1] = 1;\\n        int limit = result.size()-2;\\n        int max_len = 1;\\n        for (int center = right_result.size()-1; center >= 0; center--) {\\n            int most_left = center - ( result[center]-1 ) / 2;\\n            \\n            while (most_left <= limit) {\\n                int len = ( center - limit ) * 2 + 1;\\n                if(len > max_len){\\n                    max_len = len;\\n                }\\n                right_result[limit--] = max_len;\\n            }\\n        }\\n        return right_result;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669026,
                "title": "rolling-hash-binary-search",
                "content": "We have to do hashing of string and its reverse string so that we can compare two strings by their hash value.\\nIf string and its reverse have same hashed value, then are palindrome.\\nWe will continue expanding from each center to left and right and apply binary search to find maximum length.\\nYou can read about string hashing from here: https://cp-algorithms.com/string/string-hashing.html#search-for-duplicate-strings-in-an-array-of-strings\\n\\nNote: We having followed rolling hash algorithm which itself is deterministic algorithm. \\n\\n**BUT WHO CARES AS LONG AS WE GET AC AND WE DON\\'T WANT TO DEAL WITH GARBAGE ALGORITHM SUCH AS MANACHER WHICH IS NOT INTUITIVE AT ALL.\\nREMEMBER, ANY INTERVIEWER WHO ASKS MANACHER IS PURE EVIL AND DON\\'T WANT YOU IN THEIR COMPANY. **\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    const ll mod=1e9+7;\\n    const ll p=31;\\n    ll n;\\n    \\n    vector<ll> p_pow;\\n    vector<ll> p_inv;\\n    vector<ll> hash,rev_hash;\\n    \\n    \\n    ll fpm(ll x,ll y,ll mod){\\n        ll ans=1;\\n        while(y>0){\\n            if(y&1){\\n                ans=(ans*x)%mod;\\n            }\\n            y>>=1;\\n            x=(x*x)%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    ll substr_hash(ll l,ll r,vector<ll> &h){\\n        ll ans=0;\\n        ans+=h[r];\\n        if(l-1>=0){\\n            ans-=h[l-1];\\n        }\\n        if(ans<0){\\n            ans+=mod;\\n        }\\n        ans%=mod;\\n        ans*=p_inv[l];\\n        ans%=mod;\\n        return ans;\\n    }\\n    \\n    // asdsahjkl\\n    // _____\\n    \\n    // lkjhasdsa\\n    //     _____  \\n    \\n    bool pal(ll idx,ll len){\\n        return substr_hash(idx-len,idx,hash)==substr_hash(n-1-idx-len,n-1-idx,rev_hash);\\n    }\\n        \\n    long long maxProduct(string s) {\\n        this->n=s.size();\\n        \\n        p_pow.resize(n);\\n        p_inv.resize(n);\\n        p_pow[0]=1;\\n        p_inv[0]=1;\\n        for(ll i=1;i<n;i++){\\n            p_pow[i]=(p_pow[i-1]*p)%mod;\\n            p_inv[i]=fpm(p_pow[i],mod-2,mod);\\n        }\\n        \\n        hash.resize(n);\\n        hash[0]=(s[0]-\\'a\\'+1)%mod;\\n        for(ll i=1;i<n;i++){\\n            hash[i]=(hash[i-1]+((s[i]-\\'a\\'+1)*p_pow[i])%mod)%mod;\\n        }\\n        \\n        string t=s;\\n        reverse(t.begin(),t.end());\\n        rev_hash.resize(n);\\n        rev_hash[0]=(t[0]-\\'a\\'+1)%mod;\\n        for(ll i=1;i<n;i++){\\n            rev_hash[i]=(rev_hash[i-1]+((t[i]-\\'a\\'+1)*p_pow[i])%mod)%mod;\\n        }\\n        \\n        vector<ll> pref(n,1),suff(n,1);\\n        \\n        for(ll i=0;i<n;i++){\\n            ll l=0, r=min(i,n-i-1);\\n            ll len=0;\\n            while(l<=r){\\n                ll mid=(l+r)/2;\\n                if(pal(i,mid)){\\n                    len=mid;\\n                    l=mid+1;\\n                }else{\\n                    r=mid-1;\\n                }\\n            }\\n            pref[i+len]=max(pref[i+len],2*len+1);\\n            suff[i-len]=max(suff[i-len],2*len+1);\\n        }\\n        \\n        for(ll i=n-2;i>=0;i--){\\n            pref[i]=max(pref[i],pref[i+1]-2);\\n        }\\n        \\n        for(ll i=1;i<n;i++){\\n            suff[i]=max(suff[i],suff[i-1]-2);\\n        }\\n        \\n        for(ll i=1;i<n;i++){\\n            pref[i]=max(pref[i],pref[i-1]);\\n        }\\n        for(ll i=n-2;i>=0;i--){\\n            suff[i]=max(suff[i],suff[i+1]);\\n        }\\n        \\n        ll ans=1;\\n        for(ll i=1;i<n;i++){\\n            ans=max(ans,pref[i-1]*suff[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Rolling Hash",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    const ll mod=1e9+7;\\n    const ll p=31;\\n    ll n;\\n    \\n    vector<ll> p_pow;\\n    vector<ll> p_inv;\\n    vector<ll> hash,rev_hash;\\n    \\n    \\n    ll fpm(ll x,ll y,ll mod){\\n        ll ans=1;\\n        while(y>0){\\n            if(y&1){\\n                ans=(ans*x)%mod;\\n            }\\n            y>>=1;\\n            x=(x*x)%mod;\\n        }\\n        return ans;\\n    }\\n    \\n    ll substr_hash(ll l,ll r,vector<ll> &h){\\n        ll ans=0;\\n        ans+=h[r];\\n        if(l-1>=0){\\n            ans-=h[l-1];\\n        }\\n        if(ans<0){\\n            ans+=mod;\\n        }\\n        ans%=mod;\\n        ans*=p_inv[l];\\n        ans%=mod;\\n        return ans;\\n    }\\n    \\n    // asdsahjkl\\n    // _____\\n    \\n    // lkjhasdsa\\n    //     _____  \\n    \\n    bool pal(ll idx,ll len){\\n        return substr_hash(idx-len,idx,hash)==substr_hash(n-1-idx-len,n-1-idx,rev_hash);\\n    }\\n        \\n    long long maxProduct(string s) {\\n        this->n=s.size();\\n        \\n        p_pow.resize(n);\\n        p_inv.resize(n);\\n        p_pow[0]=1;\\n        p_inv[0]=1;\\n        for(ll i=1;i<n;i++){\\n            p_pow[i]=(p_pow[i-1]*p)%mod;\\n            p_inv[i]=fpm(p_pow[i],mod-2,mod);\\n        }\\n        \\n        hash.resize(n);\\n        hash[0]=(s[0]-\\'a\\'+1)%mod;\\n        for(ll i=1;i<n;i++){\\n            hash[i]=(hash[i-1]+((s[i]-\\'a\\'+1)*p_pow[i])%mod)%mod;\\n        }\\n        \\n        string t=s;\\n        reverse(t.begin(),t.end());\\n        rev_hash.resize(n);\\n        rev_hash[0]=(t[0]-\\'a\\'+1)%mod;\\n        for(ll i=1;i<n;i++){\\n            rev_hash[i]=(rev_hash[i-1]+((t[i]-\\'a\\'+1)*p_pow[i])%mod)%mod;\\n        }\\n        \\n        vector<ll> pref(n,1),suff(n,1);\\n        \\n        for(ll i=0;i<n;i++){\\n            ll l=0, r=min(i,n-i-1);\\n            ll len=0;\\n            while(l<=r){\\n                ll mid=(l+r)/2;\\n                if(pal(i,mid)){\\n                    len=mid;\\n                    l=mid+1;\\n                }else{\\n                    r=mid-1;\\n                }\\n            }\\n            pref[i+len]=max(pref[i+len],2*len+1);\\n            suff[i-len]=max(suff[i-len],2*len+1);\\n        }\\n        \\n        for(ll i=n-2;i>=0;i--){\\n            pref[i]=max(pref[i],pref[i+1]-2);\\n        }\\n        \\n        for(ll i=1;i<n;i++){\\n            suff[i]=max(suff[i],suff[i-1]-2);\\n        }\\n        \\n        for(ll i=1;i<n;i++){\\n            pref[i]=max(pref[i],pref[i-1]);\\n        }\\n        for(ll i=n-2;i>=0;i--){\\n            suff[i]=max(suff[i],suff[i+1]);\\n        }\\n        \\n        ll ans=1;\\n        for(ll i=1;i<n;i++){\\n            ans=max(ans,pref[i-1]*suff[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485021,
                "title": "manchter-algo-c-solution-with-intitution",
                "content": "# Intuition\\n\\nFirst i figure that it is a string question . \\nSo generally people may know only kmp and rabin carp . \\nAfter 20-30 min you may figure that both cannot be used to find palindromes in o(n) ;\\nNow there should another algo , \\nthat is :  manchter algo to find maximum length string centered at i for whole string from (i = 1 to n ) in o(n) time . \\nand the rest is manchter algo theory .\\nYou may refer cp algorithm for this . \\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nTC = o(n) .\\nas outer loop from 1 to n . \\nfor inner while loop . if statement will overcome that \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> manacher_odd(string s ){\\n        int n = s.length();\\n        s = \"^\" + s + \"$\" ; \\n        vector<int> p(n+2 , 1);\\n        vector<int> lr(n+2 , 1 );\\n        int l = 1 , r = 1 ;\\n        for(int i = 1 ; i<= n ; ++i ){\\n        \\n            if( r >= i )p[i] = max(p[i] , min( 2*(r-i) + 1 , p[l+(r-i)] )) ;\\n            int c = (p[i] + 1 ) / 2  ;\\n            while(s[i-c] == s[c+i]){\\n                p[i] += 2 ;\\n                lr[i + c] = p[i] ;\\n                ++c ;\\n            } \\n            --c;\\n            if(i+c > r ){\\n                l = i-c ;\\n                r = i+c ;\\n            }\\n        }\\n        for(int i = 1 ; i<= n ; ++i ){\\n            lr[i] = max( lr[i] , lr[i-1] ) ;\\n        }\\n        return vector<int>(begin(lr) +1 , end(lr) -1) ;\\n    }\\n\\n    long long maxProduct(string s) {\\n        vector<int> pre = manacher_odd(s) ;\\n        reverse(s.begin() , s.end() ) ; \\n        vector<int> suff = manacher_odd(s) ;\\n        reverse(suff.begin() , suff.end() ) ;\\n        int n = pre.size() ;\\n        \\n        long long res = 1 ;\\n        for(int i = 0 ; i< n-1 ; ++i ){\\n            res = max( pre[i] * 1LL * suff[i+1] , res ) ;\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> manacher_odd(string s ){\\n        int n = s.length();\\n        s = \"^\" + s + \"$\" ; \\n        vector<int> p(n+2 , 1);\\n        vector<int> lr(n+2 , 1 );\\n        int l = 1 , r = 1 ;\\n        for(int i = 1 ; i<= n ; ++i ){\\n        \\n            if( r >= i )p[i] = max(p[i] , min( 2*(r-i) + 1 , p[l+(r-i)] )) ;\\n            int c = (p[i] + 1 ) / 2  ;\\n            while(s[i-c] == s[c+i]){\\n                p[i] += 2 ;\\n                lr[i + c] = p[i] ;\\n                ++c ;\\n            } \\n            --c;\\n            if(i+c > r ){\\n                l = i-c ;\\n                r = i+c ;\\n            }\\n        }\\n        for(int i = 1 ; i<= n ; ++i ){\\n            lr[i] = max( lr[i] , lr[i-1] ) ;\\n        }\\n        return vector<int>(begin(lr) +1 , end(lr) -1) ;\\n    }\\n\\n    long long maxProduct(string s) {\\n        vector<int> pre = manacher_odd(s) ;\\n        reverse(s.begin() , s.end() ) ; \\n        vector<int> suff = manacher_odd(s) ;\\n        reverse(suff.begin() , suff.end() ) ;\\n        int n = pre.size() ;\\n        \\n        long long res = 1 ;\\n        for(int i = 0 ; i< n-1 ; ++i ){\\n            res = max( pre[i] * 1LL * suff[i+1] , res ) ;\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450051,
                "title": "find-the-maximum-product-of-two-non-intersecting-palindromic-substrings-in-javascript",
                "content": "# Intuition\\nThe code uses dynamic programming to solve the problem of finding the maximum product of the lengths of two non-intersecting palindromic substrings of odd length in a given string.\\n\\nThe approach is to first calculate the longest palindrome centered at each index of the string using Manacher\\'s algorithm. This is done by maintaining two pointers c and r that keep track of the center and right boundary of the palindrome, respectively. For each index i, we check if it is within the current palindrome (i.e., i <= r). If it is, we can take advantage of the palindrome\\'s symmetry to determine the length of the palindrome centered at i. Otherwise, we start a new palindrome centered at i and expand it until it can no longer be extended.\\n\\nOnce we have computed the length of the longest palindrome centered at each index, we can use this information to calculate the length of the longest palindrome to the left and right of each index. This is done by iterating through the string and keeping track of the maximum length of palindrome seen so far to the left and right of each index.\\n\\nFinally, we iterate through the string and calculate the product of the lengths of the two non-intersecting palindromic substrings of odd length that can be formed using the palindromes to the left and right of each index. We keep track of the maximum product seen so far and return it as the result.\\n\\n# Approach\\nThe approach used in the code is to find all the palindromic substrings in the given string and then choose two non-intersecting palindromic substrings of odd length such that their product of lengths is maximized.\\n\\nThe algorithm uses Manacher\\'s algorithm to find all palindromic substrings in the given string. Manacher\\'s algorithm is a linear time algorithm that finds all palindromic substrings in a given string.\\n\\nThe algorithm uses three arrays to keep track of information about each character in the string:\\n\\n1. dp[i]: the length of the longest palindromic substring centered at i.\\n\\n2. before[i]: the length of the longest palindromic substring to the left of i.\\n\\n3. after[i]: the length of the longest palindromic substring to the right of i.\\n\\nTo find the palindromic substrings, the algorithm iterates through the string and uses two pointers, p and q, to expand around each character in the string. It checks if the characters at positions p and q are equal, and if they are, it updates the before and after arrays accordingly. It also updates the dp array to keep track of the longest palindromic substring centered at each character.\\n\\nOnce the algorithm has found all the palindromic substrings in the string, it iterates through the string again and computes the product of the lengths of the two non-intersecting palindromic substrings of odd length that have the maximum product. It does this by computing the maximum product for each position in the string and keeping track of the maximum product seen so far.\\n\\nFinally, the algorithm returns the maximum product of the lengths of the two non-intersecting palindromic substrings of odd length.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * Title: Maximum Product of the Length of Two Palindromic Substrings\\n * Description: You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized. More formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive. Return the maximum possible product of the lengths of the two non-intersecting palindromic substrings. A palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.\\n * Author: Hasibul Islam\\n * Date: 24/04/2023\\n */\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nfunction maxProduct(s) {\\n    let n = s.length;\\n\\n    let dp = new Array(n).fill(0);\\n    let before = new Array(n).fill(0);\\n    let after = new Array(n).fill(0);\\n\\n    let c = -1;\\n    let r = -1;\\n\\n    for (let i = 0; i < n; i++) {\\n        let k = i <= r ? Math.min(dp[2 * c - i], r - i) : 0;\\n        let p = i - k;\\n        let q = i + k;\\n\\n        while (p >= 0 && q < n && s[p] === s[q]) {\\n            before[q] = Math.max(before[q], q - p + 1);\\n            after[p] = Math.max(after[p], q - p + 1);\\n            p--;\\n            q++;\\n        }\\n\\n        dp[i] = q - i - 1;\\n\\n        if (q - 1 > r) {\\n            c = i;\\n            r = q - 1;\\n        }\\n    }\\n\\n    for (let i = 1; i < n; i++) {\\n        before[i] = Math.max(before[i - 1], before[i]);\\n    }\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        after[i] = Math.max(after[i + 1], after[i]);\\n    }\\n\\n    let result = 0;\\n\\n    for (let i = 1; i < n; i++) {\\n        result = Math.max(result, before[i - 1] * after[i]);\\n    }\\n\\n    return result;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Title: Maximum Product of the Length of Two Palindromic Substrings\\n * Description: You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized. More formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive. Return the maximum possible product of the lengths of the two non-intersecting palindromic substrings. A palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string.\\n * Author: Hasibul Islam\\n * Date: 24/04/2023\\n */\\n\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nfunction maxProduct(s) {\\n    let n = s.length;\\n\\n    let dp = new Array(n).fill(0);\\n    let before = new Array(n).fill(0);\\n    let after = new Array(n).fill(0);\\n\\n    let c = -1;\\n    let r = -1;\\n\\n    for (let i = 0; i < n; i++) {\\n        let k = i <= r ? Math.min(dp[2 * c - i], r - i) : 0;\\n        let p = i - k;\\n        let q = i + k;\\n\\n        while (p >= 0 && q < n && s[p] === s[q]) {\\n            before[q] = Math.max(before[q], q - p + 1);\\n            after[p] = Math.max(after[p], q - p + 1);\\n            p--;\\n            q++;\\n        }\\n\\n        dp[i] = q - i - 1;\\n\\n        if (q - 1 > r) {\\n            c = i;\\n            r = q - 1;\\n        }\\n    }\\n\\n    for (let i = 1; i < n; i++) {\\n        before[i] = Math.max(before[i - 1], before[i]);\\n    }\\n\\n    for (let i = n - 2; i >= 0; i--) {\\n        after[i] = Math.max(after[i + 1], after[i]);\\n    }\\n\\n    let result = 0;\\n\\n    for (let i = 1; i < n; i++) {\\n        result = Math.max(result, before[i - 1] * after[i]);\\n    }\\n\\n    return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3442147,
                "title": "python-simple-manacher-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProduct(self, s):\\n        n = len(s)\\n\\n        dp, before, after = [0]*n, [0]*n, [0]*n\\n\\n        c, r = -1, -1\\n\\n        for i in range(n):\\n            k = min(dp[2*c-i],r-i) if i<=r else 0\\n            p, q = i-k, i+k\\n\\n            while p>=0 and q<n and s[p] == s[q]:\\n                before[q] = max(before[q],q-p+1)\\n                after[p] = max(after[p],q-p+1)\\n                p -= 1\\n                q += 1\\n\\n            dp[i] = q-i-1\\n\\n            if q-1 > r: c, r = i, q-1\\n\\n        for i in range(1,n):\\n            before[i] = max(before[i-1],before[i])\\n\\n        for i in range(n-2,-1,-1):\\n            after[i] = max(after[i+1],after[i])\\n\\n        return max([before[i-1]*after[i] for i in range(1,n)])\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProduct(self, s):\\n        n = len(s)\\n\\n        dp, before, after = [0]*n, [0]*n, [0]*n\\n\\n        c, r = -1, -1\\n\\n        for i in range(n):\\n            k = min(dp[2*c-i],r-i) if i<=r else 0\\n            p, q = i-k, i+k\\n\\n            while p>=0 and q<n and s[p] == s[q]:\\n                before[q] = max(before[q],q-p+1)\\n                after[p] = max(after[p],q-p+1)\\n                p -= 1\\n                q += 1\\n\\n            dp[i] = q-i-1\\n\\n            if q-1 > r: c, r = i, q-1\\n\\n        for i in range(1,n):\\n            before[i] = max(before[i-1],before[i])\\n\\n        for i in range(n-2,-1,-1):\\n            after[i] = max(after[i+1],after[i])\\n\\n        return max([before[i-1]*after[i] for i in range(1,n)])\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357650,
                "title": "c-manacher-s-prefix-max-array",
                "content": "# Approach\\nFirst we need to find Longest Palindromic Substring using Manacher\\'s.\\n\\nWhen expanding palindroms in Manacher\\'s, we also update `L` and `R`\\n- `L[i]`: the max length of palindrom that ends at `i`\\n- `R[i]`: the max length of palindrom that starts at `i`\\n\\nThen we compute a prefix for `R` from right to left, and try to combine it with `L` to find the answer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll maxProduct(string s0) {\\n      int n = s0.size();\\n      string s(n*2+1, \\'-\\');\\n      for (int i = 0; i < n; ++i) s[2*i+1] = s0[i];\\n      vector<int> DP(s.size(), 0), L(n, 0), R(n, 0);\\n      auto update = [&](int i, int len) {\\n        int j = (i-1)/2, h = len/2;\\n        int l = j-h, r = j+h;\\n        if (s[i] != \\'-\\') L[r] = max(L[r], len), R[l] = max(R[l], len);\\n        DP[i] = len;\\n      };\\n      for (int i = 0, r = 0, c = 0; i < s.size(); ++i) {\\n        auto& len = DP[i];\\n        if (i < r) update(i, min(DP[2*c-i], r-i));\\n        while (i+len+1 < s.size() && i-len-1 >= 0 && s[i+len+1] == s[i-len-1]) {\\n          update(i, len+1);\\n        }\\n        if (i+len > r) c = i, r = i+len;\\n      }\\n      for (int i = R.size()-2; i >= 0; --i) {\\n        R[i] = max(R[i], R[i+1]);\\n      }\\n      ll res = 0;\\n      for (int i = 1; i < n; ++i) {\\n        res = max(res, (ll)L[i-1]*R[i]);\\n      }\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll = long long;\\n    ll maxProduct(string s0) {\\n      int n = s0.size();\\n      string s(n*2+1, \\'-\\');\\n      for (int i = 0; i < n; ++i) s[2*i+1] = s0[i];\\n      vector<int> DP(s.size(), 0), L(n, 0), R(n, 0);\\n      auto update = [&](int i, int len) {\\n        int j = (i-1)/2, h = len/2;\\n        int l = j-h, r = j+h;\\n        if (s[i] != \\'-\\') L[r] = max(L[r], len), R[l] = max(R[l], len);\\n        DP[i] = len;\\n      };\\n      for (int i = 0, r = 0, c = 0; i < s.size(); ++i) {\\n        auto& len = DP[i];\\n        if (i < r) update(i, min(DP[2*c-i], r-i));\\n        while (i+len+1 < s.size() && i-len-1 >= 0 && s[i+len+1] == s[i-len-1]) {\\n          update(i, len+1);\\n        }\\n        if (i+len > r) c = i, r = i+len;\\n      }\\n      for (int i = R.size()-2; i >= 0; --i) {\\n        R[i] = max(R[i], R[i+1]);\\n      }\\n      ll res = 0;\\n      for (int i = 1; i < n; ++i) {\\n        res = max(res, (ll)L[i-1]*R[i]);\\n      }\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141405,
                "title": "python-manacher",
                "content": "```\\n    def maxProduct(self, s: str) -> int:\\n        dp, before, after = [0] * len(s), [0] * len(s), [0] * len(s)\\n        c, r = -1, -1\\n        for i in range(len(s)):\\n            k = min(dp[2 * c - i], r - i) if i <= r else 0\\n            p, q = i - k, i + k\\n            while p >= 0 and q < len(s) and s[p] == s[q]:\\n                before[q] = max(before[q], q - p + 1)\\n                after[p] = max(after[p], q - p + 1)\\n                p -= 1; q += 1\\n            dp[i] = q - i - 1\\n            if q - 1 > r: c, r = i, q - 1\\n        for i in range(1, len(s)): before[i] = max(before[i - 1], before[i])\\n        for i in range(len(s) - 2, -1, -1): after[i] = max(after[i + 1], after[i])\\n        return max(before[i - 1] * after[i] for i in range(1, len(s)))\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProduct(self, s: str) -> int:\\n        dp, before, after = [0] * len(s), [0] * len(s), [0] * len(s)\\n        c, r = -1, -1\\n        for i in range(len(s)):\\n            k = min(dp[2 * c - i], r - i) if i <= r else 0\\n            p, q = i - k, i + k\\n            while p >= 0 and q < len(s) and s[p] == s[q]:\\n                before[q] = max(before[q], q - p + 1)\\n                after[p] = max(after[p], q - p + 1)\\n                p -= 1; q += 1\\n            dp[i] = q - i - 1\\n            if q - 1 > r: c, r = i, q - 1\\n        for i in range(1, len(s)): before[i] = max(before[i - 1], before[i])\\n        for i in range(len(s) - 2, -1, -1): after[i] = max(after[i + 1], after[i])\\n        return max(before[i - 1] * after[i] for i in range(1, len(s)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3099551,
                "title": "premium-limited-explained-solution",
                "content": "\\n```\\nclass Solution\\n{\\npublic:\\n    long long maxProduct(string s)\\n    {\\n\\n        int n = s.size();\\n        vector<int> d1 = vector<int>(s.size(), 0);\\n        for (int i = 0, l = 0, r = -1; i < n; i++)\\n        {\\n            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            {\\n                k++;\\n            }\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i - k;\\n                r = i + k;\\n            }\\n        }\\n\\n        vector<int> maxL = vector<int>(s.size(), 1);\\n        auto lQueue = set<pair<int, int>>();\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                maxL[i] = max(maxL[i], maxL[i - 1]);\\n\\n            lQueue.insert({i, d1[i]});\\n\\n            while (lQueue.begin()->first + lQueue.begin()->second - 1 < i)\\n            {\\n                lQueue.erase(lQueue.begin());\\n            }\\n\\n            maxL[i] = max(maxL[i], ((i - lQueue.begin()->first) * 2) + 1);\\n        }\\n\\n        vector<int> maxR = vector<int>(s.size(), 1);\\n        auto rQueue = priority_queue<pair<int, int>>();\\n\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                maxR[i] = max(maxR[i], maxR[i + 1]);\\n\\n            rQueue.push({i, d1[i]});\\n\\n            while (rQueue.top().first - (rQueue.top().second - 1) > i)\\n            {\\n                rQueue.pop();\\n            }\\n\\n            maxR[i] = max(maxR[i], ((rQueue.top().first - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) maxL[i] * (long long)maxR[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    long long maxProduct(string s)\\n    {\\n\\n        int n = s.size();\\n        vector<int> d1 = vector<int>(s.size(), 0);\\n        for (int i = 0, l = 0, r = -1; i < n; i++)\\n        {\\n            int k = (i > r) ? 1 : min(d1[l + r - i], r - i + 1);\\n            while (0 <= i - k && i + k < n && s[i - k] == s[i + k])\\n            {\\n                k++;\\n            }\\n            d1[i] = k--;\\n            if (i + k > r)\\n            {\\n                l = i - k;\\n                r = i + k;\\n            }\\n        }\\n\\n        vector<int> maxL = vector<int>(s.size(), 1);\\n        auto lQueue = set<pair<int, int>>();\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (i > 0)\\n                maxL[i] = max(maxL[i], maxL[i - 1]);\\n\\n            lQueue.insert({i, d1[i]});\\n\\n            while (lQueue.begin()->first + lQueue.begin()->second - 1 < i)\\n            {\\n                lQueue.erase(lQueue.begin());\\n            }\\n\\n            maxL[i] = max(maxL[i], ((i - lQueue.begin()->first) * 2) + 1);\\n        }\\n\\n        vector<int> maxR = vector<int>(s.size(), 1);\\n        auto rQueue = priority_queue<pair<int, int>>();\\n\\n        for (int i = s.size() - 1; i >= 0; i--)\\n        {\\n            if (i < s.size() - 1)\\n                maxR[i] = max(maxR[i], maxR[i + 1]);\\n\\n            rQueue.push({i, d1[i]});\\n\\n            while (rQueue.top().first - (rQueue.top().second - 1) > i)\\n            {\\n                rQueue.pop();\\n            }\\n\\n            maxR[i] = max(maxR[i], ((rQueue.top().first - i) * 2) + 1);\\n        }\\n\\n        long long res = 0;\\n        for (int i = 0; i < s.size() - 1; i++)\\n        {\\n            res = max(res, (long long) maxL[i] * (long long)maxR[i + 1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854992,
                "title": "o-n-log-n-rolling-hash-binary-search-dp-w-priority-queue",
                "content": "The idea is that we treat every `i` as the center of the palindrome and do a binary search on the side length of the palindrome. To make comparing the sides of the palindrome O(1), we precompute the rolling hash for the string in both directions (because palindrome mirrors each other at the center). We store for every `i` the width of the side length of the longest palindrome when `i` is the center.\\n\\nAfter that, we\\'d like a DP to tell us the longest palindrome to either the left or the right of the current position, so that in the end we can do `left_dp[i] * right_dp[i + 1]`. To do this, we\\'ll take `left_dp` as an example. We want to keep track of the **leftmost center of the palindrome that can reach the current position**, because that\\'d give us the longest palindrome that can reach the current position. Let\\'s keep track of that via a priority queue, and we\\'ll pop off the palindromes that can\\'t reach here. What if the longest palindrome to the left isn\\'t directly reaching the current `i`? well we\\'ll just take the maximum answer so far from the left, via `left_dp[i - 1]`. This way, the longest palindrome will be carried over and updated at a certain point if necessary. Then, we use this logic for `right_dp` too.\\n\\n---\\n\\n```cpp\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\n\\ntemplate <int MOD = 1\\'000\\'000\\'007> struct mod_int {\\n  long long v{};\\n  mod_int() = default;\\n  mod_int(long long vx) : v((vx + MOD) % MOD) {}\\n  mod_int &operator=(long long vx) {\\n    v = (vx + MOD) % MOD;\\n    return *this;\\n  }\\n  friend mod_int operator+(const mod_int &a, const mod_int &b) { return (a.v + b.v) % MOD; }\\n  friend mod_int operator+(long long a, const mod_int &b) { return ((a + MOD) % MOD + b.v) % MOD; }\\n  friend mod_int operator+(const mod_int &a, long long b) { return (a.v + (b + MOD) % MOD) % MOD; }\\n  friend mod_int operator-(const mod_int &a, const mod_int &b) { return (a.v - b.v + MOD) % MOD; }\\n  friend mod_int operator-(long long a, const mod_int &b) { return ((a + MOD) % MOD - b.v + MOD) % MOD; }\\n  friend mod_int operator-(const mod_int &a, long long b) { return (a.v - (b + MOD) % MOD + MOD) % MOD; }\\n  friend mod_int operator*(const mod_int &a, const mod_int &b) { return (a.v * b.v) % MOD; }\\n  friend mod_int operator*(long long a, const mod_int &b) { return (((a + MOD) % MOD) * b.v) % MOD; }\\n  friend mod_int operator*(const mod_int &a, long long b) { return (a.v * ((b + MOD) % MOD)) % MOD; }\\n  friend bool operator==(const mod_int &a, const mod_int &b) { return a.v == b.v; }\\n  friend bool operator!=(const mod_int &a, const mod_int &b) { return a.v != b.v; }\\n};\\n\\nclass Solution {\\npublic:\\n  long long maxProduct(string s) {\\n    int n = s.size();\\n    constexpr int P1 = 31, P2 = 33, M1 = 1e9 + 7, M2 = 1e9 + 9;\\n\\n    using num1 = mod_int<M1>;\\n    using num2 = mod_int<M2>;\\n\\n    vector<pair<num1, num2>> powers(n + 1, {1, 1});\\n    for (int i = 1; i <= n; i++) {\\n      powers[i].first = powers[i - 1].first * P1;\\n      powers[i].second = powers[i - 1].second * P2;\\n    }\\n\\n    vector<pair<num1, num2>> fwd_hash(n + 1);\\n    for (int i = 0; i < n; i++) {\\n      fwd_hash[i + 1].first = fwd_hash[i].first + (s[i] - \\'a\\' + 1) * powers[i].first;\\n      fwd_hash[i + 1].second = fwd_hash[i].second + (s[i] - \\'a\\' + 1) * powers[i].second;\\n    }\\n\\n    vector<pair<num1, num2>> back_hash(n + 1);\\n    for (int i = 0; i < n; i++) {\\n      back_hash[i + 1].first = back_hash[i].first + (s[n - i - 1] - \\'a\\' + 1) * powers[i].first;\\n      back_hash[i + 1].second = back_hash[i].second + (s[n - i - 1] - \\'a\\' + 1) * powers[i].second;\\n    }\\n\\n    vector<int> center_width(n);\\n    for (int i = 0; i < n; i++) {\\n      int l = 1, r = min(n - i, n - (n - i - 1)), res = 1;\\n      while (l <= r) {\\n        int m = (l + r) / 2;\\n\\n        num1 fwd_hash1 = fwd_hash[i + m].first - fwd_hash[i].first;\\n        num2 fwd_hash2 = fwd_hash[i + m].second - fwd_hash[i].second;\\n        num1 back_hash1 = back_hash[n - i - 1 + m].first - back_hash[n - i - 1].first;\\n        num2 back_hash2 = back_hash[n - i - 1 + m].second - back_hash[n - i - 1].second;\\n\\n        num1 fwd_hash1_exp = 1;\\n        num2 fwd_hash2_exp = 1;\\n        num1 back_hash1_exp = 1;\\n        num2 back_hash2_exp = 1;\\n        int dist1 = i + 1, dist2 = n - i;\\n        if (dist1 > dist2) {\\n          back_hash1_exp = powers[dist1 - dist2].first;\\n          back_hash2_exp = powers[dist1 - dist2].second;\\n        } else if (dist1 < dist2) {\\n          fwd_hash1_exp = powers[dist2 - dist1].first;\\n          fwd_hash2_exp = powers[dist2 - dist1].second;\\n        }\\n\\n        if (fwd_hash1 * fwd_hash1_exp == back_hash1 * back_hash1_exp &&\\n            fwd_hash2 * fwd_hash2_exp == back_hash2 * back_hash2_exp) {\\n          l = m + 1;\\n          res = m;\\n        } else {\\n          r = m - 1;\\n        }\\n      }\\n      center_width[i] = res;\\n    }\\n\\n    using T = pair<int, int>; // [center, end]\\n\\n    priority_queue<T, vector<T>, greater<T>> min_centers;\\n    vector<int> left_dp(n + 1, 1);\\n    for (int i = 0; i < n; i++) {\\n      left_dp[i + 1] = left_dp[i];\\n\\n      min_centers.emplace(i, i + center_width[i] - 1);\\n      while (!min_centers.empty() && min_centers.top().second < i) {\\n        min_centers.pop();\\n      }\\n      if (!min_centers.empty()) {\\n        amax(left_dp[i + 1], (i - min_centers.top().first) * 2 + 1);\\n      }\\n    }\\n\\n    priority_queue<T> max_centers;\\n    vector<int> right_dp(n + 1, 1);\\n    for (int i = 0, j = n - 1; i < n; i++, j--) {\\n      right_dp[i + 1] = right_dp[i];\\n\\n      max_centers.emplace(j, j - center_width[j] + 1);\\n      while (!max_centers.empty() && max_centers.top().second > j) {\\n        max_centers.pop();\\n      }\\n      if (!max_centers.empty()) {\\n        amax(right_dp[i + 1], (max_centers.top().first - j) * 2 + 1);\\n      }\\n    }\\n\\n    long long ans = 1;\\n    for (int i = 1, j = n - 1; i < n; i++, j--) {\\n      amax(ans, (long long)left_dp[i] * (long long)right_dp[j]);\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Rolling Hash",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\ntemplate <typename T> T &amin(T &a, const T &b) { return a = min(a, b); }\\n\\ntemplate <int MOD = 1\\'000\\'000\\'007> struct mod_int {\\n  long long v{};\\n  mod_int() = default;\\n  mod_int(long long vx) : v((vx + MOD) % MOD) {}\\n  mod_int &operator=(long long vx) {\\n    v = (vx + MOD) % MOD;\\n    return *this;\\n  }\\n  friend mod_int operator+(const mod_int &a, const mod_int &b) { return (a.v + b.v) % MOD; }\\n  friend mod_int operator+(long long a, const mod_int &b) { return ((a + MOD) % MOD + b.v) % MOD; }\\n  friend mod_int operator+(const mod_int &a, long long b) { return (a.v + (b + MOD) % MOD) % MOD; }\\n  friend mod_int operator-(const mod_int &a, const mod_int &b) { return (a.v - b.v + MOD) % MOD; }\\n  friend mod_int operator-(long long a, const mod_int &b) { return ((a + MOD) % MOD - b.v + MOD) % MOD; }\\n  friend mod_int operator-(const mod_int &a, long long b) { return (a.v - (b + MOD) % MOD + MOD) % MOD; }\\n  friend mod_int operator*(const mod_int &a, const mod_int &b) { return (a.v * b.v) % MOD; }\\n  friend mod_int operator*(long long a, const mod_int &b) { return (((a + MOD) % MOD) * b.v) % MOD; }\\n  friend mod_int operator*(const mod_int &a, long long b) { return (a.v * ((b + MOD) % MOD)) % MOD; }\\n  friend bool operator==(const mod_int &a, const mod_int &b) { return a.v == b.v; }\\n  friend bool operator!=(const mod_int &a, const mod_int &b) { return a.v != b.v; }\\n};\\n\\nclass Solution {\\npublic:\\n  long long maxProduct(string s) {\\n    int n = s.size();\\n    constexpr int P1 = 31, P2 = 33, M1 = 1e9 + 7, M2 = 1e9 + 9;\\n\\n    using num1 = mod_int<M1>;\\n    using num2 = mod_int<M2>;\\n\\n    vector<pair<num1, num2>> powers(n + 1, {1, 1});\\n    for (int i = 1; i <= n; i++) {\\n      powers[i].first = powers[i - 1].first * P1;\\n      powers[i].second = powers[i - 1].second * P2;\\n    }\\n\\n    vector<pair<num1, num2>> fwd_hash(n + 1);\\n    for (int i = 0; i < n; i++) {\\n      fwd_hash[i + 1].first = fwd_hash[i].first + (s[i] - \\'a\\' + 1) * powers[i].first;\\n      fwd_hash[i + 1].second = fwd_hash[i].second + (s[i] - \\'a\\' + 1) * powers[i].second;\\n    }\\n\\n    vector<pair<num1, num2>> back_hash(n + 1);\\n    for (int i = 0; i < n; i++) {\\n      back_hash[i + 1].first = back_hash[i].first + (s[n - i - 1] - \\'a\\' + 1) * powers[i].first;\\n      back_hash[i + 1].second = back_hash[i].second + (s[n - i - 1] - \\'a\\' + 1) * powers[i].second;\\n    }\\n\\n    vector<int> center_width(n);\\n    for (int i = 0; i < n; i++) {\\n      int l = 1, r = min(n - i, n - (n - i - 1)), res = 1;\\n      while (l <= r) {\\n        int m = (l + r) / 2;\\n\\n        num1 fwd_hash1 = fwd_hash[i + m].first - fwd_hash[i].first;\\n        num2 fwd_hash2 = fwd_hash[i + m].second - fwd_hash[i].second;\\n        num1 back_hash1 = back_hash[n - i - 1 + m].first - back_hash[n - i - 1].first;\\n        num2 back_hash2 = back_hash[n - i - 1 + m].second - back_hash[n - i - 1].second;\\n\\n        num1 fwd_hash1_exp = 1;\\n        num2 fwd_hash2_exp = 1;\\n        num1 back_hash1_exp = 1;\\n        num2 back_hash2_exp = 1;\\n        int dist1 = i + 1, dist2 = n - i;\\n        if (dist1 > dist2) {\\n          back_hash1_exp = powers[dist1 - dist2].first;\\n          back_hash2_exp = powers[dist1 - dist2].second;\\n        } else if (dist1 < dist2) {\\n          fwd_hash1_exp = powers[dist2 - dist1].first;\\n          fwd_hash2_exp = powers[dist2 - dist1].second;\\n        }\\n\\n        if (fwd_hash1 * fwd_hash1_exp == back_hash1 * back_hash1_exp &&\\n            fwd_hash2 * fwd_hash2_exp == back_hash2 * back_hash2_exp) {\\n          l = m + 1;\\n          res = m;\\n        } else {\\n          r = m - 1;\\n        }\\n      }\\n      center_width[i] = res;\\n    }\\n\\n    using T = pair<int, int>; // [center, end]\\n\\n    priority_queue<T, vector<T>, greater<T>> min_centers;\\n    vector<int> left_dp(n + 1, 1);\\n    for (int i = 0; i < n; i++) {\\n      left_dp[i + 1] = left_dp[i];\\n\\n      min_centers.emplace(i, i + center_width[i] - 1);\\n      while (!min_centers.empty() && min_centers.top().second < i) {\\n        min_centers.pop();\\n      }\\n      if (!min_centers.empty()) {\\n        amax(left_dp[i + 1], (i - min_centers.top().first) * 2 + 1);\\n      }\\n    }\\n\\n    priority_queue<T> max_centers;\\n    vector<int> right_dp(n + 1, 1);\\n    for (int i = 0, j = n - 1; i < n; i++, j--) {\\n      right_dp[i + 1] = right_dp[i];\\n\\n      max_centers.emplace(j, j - center_width[j] + 1);\\n      while (!max_centers.empty() && max_centers.top().second > j) {\\n        max_centers.pop();\\n      }\\n      if (!max_centers.empty()) {\\n        amax(right_dp[i + 1], (max_centers.top().first - j) * 2 + 1);\\n      }\\n    }\\n\\n    long long ans = 1;\\n    for (int i = 1, j = n - 1; i < n; i++, j--) {\\n      amax(ans, (long long)left_dp[i] * (long long)right_dp[j]);\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783052,
                "title": "c-manacher",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        auto t = s;\\n        reverse(t.begin(), t.end());\\n        auto v =prefixLen(s), u = prefixLen(t);\\n        long long res = 0;\\n        for(int i=0, n = s.size();i<n-1;i++){\\n            res = max(res, (long long)v[i] * u[n-i-2]);\\n        }\\n        return res;\\n    }\\n    \\n    //https://cp-algorithms.com/string/manacher.html#solution\\n    vector<int> manacher_odd(string s) {\\n        int n = s.size();\\n        s = \"$\" + s + \"^\";\\n        vector<int> p(n + 2);\\n        int l = 1, r = 1;\\n        for(int i = 1; i <= n; i++) {\\n            p[i] = max(0, min(r - i, p[l + (r - i)]));\\n            while(s[i - p[i]] == s[i + p[i]]) {\\n                p[i]++;\\n            }\\n            if(i + p[i] > r) {\\n                l = i - p[i], r = i + p[i];\\n            }\\n        }\\n        return vector<int>(begin(p) + 1, end(p) - 1);\\n    }\\n    \\n    vector<int> prefixLen(const string& s){\\n        int maxLen = 0;\\n        auto manacher = manacher_odd(s);\\n        const int n = s.size();\\n        vector<int> res(n, 1);\\n        for(int i=0, j=0;i<n;i++){\\n            int len = manacher[i]-1;\\n            for(; j <= i+len; j++){\\n                maxLen = max(maxLen, 1+2*(j-i));\\n                res[j] = maxLen;\\n            } \\n        }\\n        return res;\\n    }   \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        auto t = s;\\n        reverse(t.begin(), t.end());\\n        auto v =prefixLen(s), u = prefixLen(t);\\n        long long res = 0;\\n        for(int i=0, n = s.size();i<n-1;i++){\\n            res = max(res, (long long)v[i] * u[n-i-2]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2664337,
                "title": "rust-solution-using-manacher-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt needs something no worse than O(NLogN) since N could be as  big as 100000. Manacher algorithm is a good candidate since it calculates all odd length palindromic substrings in O(N) time.      \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnce we the length vector of palindromic substrings  calculated using Manacher algorithm, we can use VecDeque to calculate the max lengths of odd length palindromic substrings for two groups [..i] &  [i+1..].\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn max_product(s: String) -> i64 {\\n        let data = Self::manacher_odd(&s);\\n        //for d in v { println![\"{}\", d]; } \\n        \\n        let n = data.len();\\n        let mut q = VecDeque::<(i32, i32)>::new();\\n        let mut right= vec![1; n];\\n\\n        for i in (0..n).rev() {\\n            while let Some(a) = q.front() {\\n                if a.0 - a.1 <= i as i32 { break }\\n                q.pop_front();\\n            }\\n            \\n            if let Some(a) = q.front() {\\n                right[i] += (a.0 - i as i32) * 2;\\n            }\\n\\n            q.push_back((i as i32, data[i] - 1));\\n        }\\n\\n        while q.is_empty() == false { q.pop_front(); } \\n        let (mut ret, mut mx_left) = (1, 1);\\n        for i in 0..n - 1 {\\n            let mut temp = 1;\\n\\n            while let Some(a) = q.front() {\\n                if a.0 + a.1 >= i as i32 { break }\\n                q.pop_front();\\n            }\\n\\n            if let Some(a) = q.front() {\\n                temp += (i as i32 - a.0) as i64 * 2;\\n            }\\n\\n            q.push_back((i as i32, data[i] - 1));\\n\\n            mx_left = mx_left.max(temp);\\n            ret = ret.max(mx_left * right[i + 1] as i64);\\n        }\\n\\n        ret\\n    }\\n\\n    // Adapted from:   https://cp-algorithms.com/string/manacher.html\\n    fn manacher_odd(s: &String) -> Vec<i32> {\\n        let n = s.len();\\n        let s = String::from(\"$\") + s + &String::from(\"^\");\\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut p = vec![0; n + 2];\\n        \\n        let (mut l, mut r) = (1, 1);\\n\\n        for i in 1..=n {\\n            p[i] = i32::max(0, i32::min(r - i as i32, p[(l + (r - i as i32)) as usize]));\\n            while (s[i - p[i] as usize] == s[i + p[i] as usize]) {\\n                p[i] += 1;\\n            }\\n\\n            if i as i32 + p[i] > r {\\n                l = i as i32 - p[i];\\n                r = i as i32 + p[i];\\n            }\\n        }\\n\\n         p.pop();\\n         p.remove(0);         \\n         p\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::VecDeque;\\n\\nimpl Solution {\\n    pub fn max_product(s: String) -> i64 {\\n        let data = Self::manacher_odd(&s);\\n        //for d in v { println![\"{}\", d]; } \\n        \\n        let n = data.len();\\n        let mut q = VecDeque::<(i32, i32)>::new();\\n        let mut right= vec![1; n];\\n\\n        for i in (0..n).rev() {\\n            while let Some(a) = q.front() {\\n                if a.0 - a.1 <= i as i32 { break }\\n                q.pop_front();\\n            }\\n            \\n            if let Some(a) = q.front() {\\n                right[i] += (a.0 - i as i32) * 2;\\n            }\\n\\n            q.push_back((i as i32, data[i] - 1));\\n        }\\n\\n        while q.is_empty() == false { q.pop_front(); } \\n        let (mut ret, mut mx_left) = (1, 1);\\n        for i in 0..n - 1 {\\n            let mut temp = 1;\\n\\n            while let Some(a) = q.front() {\\n                if a.0 + a.1 >= i as i32 { break }\\n                q.pop_front();\\n            }\\n\\n            if let Some(a) = q.front() {\\n                temp += (i as i32 - a.0) as i64 * 2;\\n            }\\n\\n            q.push_back((i as i32, data[i] - 1));\\n\\n            mx_left = mx_left.max(temp);\\n            ret = ret.max(mx_left * right[i + 1] as i64);\\n        }\\n\\n        ret\\n    }\\n\\n    // Adapted from:   https://cp-algorithms.com/string/manacher.html\\n    fn manacher_odd(s: &String) -> Vec<i32> {\\n        let n = s.len();\\n        let s = String::from(\"$\") + s + &String::from(\"^\");\\n        let s = s.chars().collect::<Vec<char>>();\\n        let mut p = vec![0; n + 2];\\n        \\n        let (mut l, mut r) = (1, 1);\\n\\n        for i in 1..=n {\\n            p[i] = i32::max(0, i32::min(r - i as i32, p[(l + (r - i as i32)) as usize]));\\n            while (s[i - p[i] as usize] == s[i + p[i] as usize]) {\\n                p[i] += 1;\\n            }\\n\\n            if i as i32 + p[i] > r {\\n                l = i as i32 - p[i];\\n                r = i as i32 + p[i];\\n            }\\n        }\\n\\n         p.pop();\\n         p.remove(0);         \\n         p\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2216044,
                "title": "manachers-algo-without-queue-with-explanation",
                "content": "We need to find a place to split the string so that we can use the max lengths of the palindrom of the two substrings to multiply. The manachers algo can give us the longest palindrom at each center location. So the idea becomes how to convert the center to its left and right boundary, then we can scan the boundaries to find the largest palindrom on the left or right of a particular index.\\n\\nAs a starting point, below is the original manachers algo code with some explanation for reference.\\n\\n```\\n    int longestPalindrom(string s) {\\n        int n = s.length();\\n        vector<int> p(n,1);\\n        \\n        int lp = 0;   // the index of the center position of previous longer palindrom, used as mirror\\n\\t\\tint ans = 1;\\n        for(int i=1;i<n-1;i++) {\\n            int l = 1;\\n            if(lp + p[lp]/2 >= i) {                                   // check if a mirrored version exists.\\n                int j = lp - (i - lp);                                // this is the mirror of the current number\\n                l = 2 * (j - max(lp - p[lp] / 2, j - p[j] / 2)) + 1;  // using the portion contained within the longer palindrom\\n            }\\n            if(lp + p[lp]/2 <= i + l/2) {                              // try to extend the new palindrom over the longer palindrom\\n                while(i+l/2+1<n && i-l/2-1>=0 && s[i+l/2+1]==s[i-l/2-1]){\\n                    l+=2;\\n                }\\n                lp = i; \\n            }\\n            p[i] = l;\\n\\t\\t\\tans = max(l, ans);\\n        }\\n        return ans;\\n\\t}\\n```\\n\\nNow, we need to add some statements to keep track of the boundaries of the palindroms.\\n\\n```\\n    long long maxProduct(string s) {\\n        int n = s.length();\\n        vector<int> p(n,1), lb(n,1), rb(n,1); // two more array to keep track of the size at left and right boundaries\\n        \\n        int lp = 0;\\n        for(int i=1;i<n-1;i++) {\\n            int l = 1;\\n            if(lp + p[lp]/2 >= i) {\\n                int j = lp - (i - lp);\\n                l = 2 * (j - max(lp - p[lp] / 2, j - p[j] / 2)) + 1;\\n            }\\n            if(lp + p[lp]/2 <= i + l/2) {\\n                while(i+l/2+1<n && i-l/2-1>=0 && s[i+l/2+1]==s[i-l/2-1]){\\n                    rb[i+l/2+1] = max(rb[i+l/2+1], l+2);                     // store the size at the right boundary of the palingdrom\\n                    lb[i-l/2-1] = max(lb[i-l/2-1], l+2);                     // now on the left boundary\\n                    l+=2;\\n                }\\n                lp = i; \\n            }\\n            p[i] = l;\\n            lb[i-p[i]/2] = max(lb[i-p[i]/2], p[i]);              // in case we dont get to store it during the extending part\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // why do we only fix the left boundaries here? think about it \\n        }\\n\\n\\t\\t// ...\\n\\t\\t// to be continued\\n\\t\\t// ...\\n\\t}\\n```\\n\\nNow, aggregate on the boundaries to get the maxmum on each side of each indices.\\n\\n```\\n        for(int i=1;i<n;i++) rb[i] = max(rb[i],rb[i-1]);  // each position now stores the largest size of palingroms on its left side\\n        for(int i=n-2;i>=0;i--) lb[i] = max(lb[i], lb[i+1]);  // same on the right side\\n```\\n\\nIn the end, get the max products.\\n\\n```\\n        long long product = 0;\\n        for(int i=0;i<n-1;i++) {\\n            product = max(product, (long long)rb[i]*lb[i+1]); // max palindrom to the left of i is rb[i] (inclusive), and\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // max palindrom to the right of i is lb[i+1](exclusive)\\n        }\\n        return product;\\n```\\nPlease vote if you feel this is helpful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int longestPalindrom(string s) {\\n        int n = s.length();\\n        vector<int> p(n,1);\\n        \\n        int lp = 0;   // the index of the center position of previous longer palindrom, used as mirror\\n\\t\\tint ans = 1;\\n        for(int i=1;i<n-1;i++) {\\n            int l = 1;\\n            if(lp + p[lp]/2 >= i) {                                   // check if a mirrored version exists.\\n                int j = lp - (i - lp);                                // this is the mirror of the current number\\n                l = 2 * (j - max(lp - p[lp] / 2, j - p[j] / 2)) + 1;  // using the portion contained within the longer palindrom\\n            }\\n            if(lp + p[lp]/2 <= i + l/2) {                              // try to extend the new palindrom over the longer palindrom\\n                while(i+l/2+1<n && i-l/2-1>=0 && s[i+l/2+1]==s[i-l/2-1]){\\n                    l+=2;\\n                }\\n                lp = i; \\n            }\\n            p[i] = l;\\n\\t\\t\\tans = max(l, ans);\\n        }\\n        return ans;\\n\\t}\\n```\n```\\n    long long maxProduct(string s) {\\n        int n = s.length();\\n        vector<int> p(n,1), lb(n,1), rb(n,1); // two more array to keep track of the size at left and right boundaries\\n        \\n        int lp = 0;\\n        for(int i=1;i<n-1;i++) {\\n            int l = 1;\\n            if(lp + p[lp]/2 >= i) {\\n                int j = lp - (i - lp);\\n                l = 2 * (j - max(lp - p[lp] / 2, j - p[j] / 2)) + 1;\\n            }\\n            if(lp + p[lp]/2 <= i + l/2) {\\n                while(i+l/2+1<n && i-l/2-1>=0 && s[i+l/2+1]==s[i-l/2-1]){\\n                    rb[i+l/2+1] = max(rb[i+l/2+1], l+2);                     // store the size at the right boundary of the palingdrom\\n                    lb[i-l/2-1] = max(lb[i-l/2-1], l+2);                     // now on the left boundary\\n                    l+=2;\\n                }\\n                lp = i; \\n            }\\n            p[i] = l;\\n            lb[i-p[i]/2] = max(lb[i-p[i]/2], p[i]);              // in case we dont get to store it during the extending part\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // why do we only fix the left boundaries here? think about it \\n        }\\n\\n\\t\\t// ...\\n\\t\\t// to be continued\\n\\t\\t// ...\\n\\t}\\n```\n```\\n        for(int i=1;i<n;i++) rb[i] = max(rb[i],rb[i-1]);  // each position now stores the largest size of palingroms on its left side\\n        for(int i=n-2;i>=0;i--) lb[i] = max(lb[i], lb[i+1]);  // same on the right side\\n```\n```\\n        long long product = 0;\\n        for(int i=0;i<n-1;i++) {\\n            product = max(product, (long long)rb[i]*lb[i+1]); // max palindrom to the left of i is rb[i] (inclusive), and\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // max palindrom to the right of i is lb[i+1](exclusive)\\n        }\\n        return product;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2193011,
                "title": "manacher-algorithm-dp-90-100",
                "content": "```\\nclass Solution {\\n    public long maxProduct(String s) {\\n        return this.maxP(s);\\n    }\\n    int[] left(int[] ps) {\\n        int[] ret = new int[ps.length];\\n        ret[0] = 1;\\n        int j = 1;\\n        for (int i = 0; i < ps.length; i++) {\\n            int r = i + (ps[i]-1)/2;\\n            while (j <= r) {\\n                ret[j] = (j-i)*2+1;\\n                j++;\\n            }\\n        }\\n        return ret;\\n    }\\n    long maxP(String s) {\\n        int[] ps = this.computePalindrome(s);\\n        int[] ls = this.left(ps);\\n        //System.out.println(Arrays.toString(ls));\\n        long c = 0, maxr = 0;\\n        int j = s.length()-1;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            int l = i - (ps[i]-1)/2;\\n            while (j >= l) {\\n                int k = (i - j)*2 + 1;\\n                if (j > 0) {\\n                    maxr = Math.max(maxr, k);\\n                    c = Math.max(c, maxr * ls[j-1]);\\n                }\\n                j--;\\n            }\\n        }\\n        return c;\\n    }\\n    int[] computePalindrome(String s) {\\n        int j = 0, l = 0, r = 0;\\n        int[] ret = new int[s.length()];\\n        ret[0] = 1;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (i > r) {\\n                j = i; \\n                l=r=i;\\n                while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\\n                    l--; r++;\\n                }\\n                l++; r--;\\n                ret[i] = r -l + 1;\\n            } else {\\n                int k = l + r -i;\\n                if ((ret[k] -1)/2 < (r-i)) {\\n                    ret[i] = ret[k];\\n                } else {\\n                    ret[i] = 1 + 2*(r-i);\\n                    l = i - (r-i);\\n                    r = i + (r-i);\\n                    while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\\n                        l--;r++;\\n                    }\\n                    l++; r--;\\n                    ret[i] = r -l +1;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long maxProduct(String s) {\\n        return this.maxP(s);\\n    }\\n    int[] left(int[] ps) {\\n        int[] ret = new int[ps.length];\\n        ret[0] = 1;\\n        int j = 1;\\n        for (int i = 0; i < ps.length; i++) {\\n            int r = i + (ps[i]-1)/2;\\n            while (j <= r) {\\n                ret[j] = (j-i)*2+1;\\n                j++;\\n            }\\n        }\\n        return ret;\\n    }\\n    long maxP(String s) {\\n        int[] ps = this.computePalindrome(s);\\n        int[] ls = this.left(ps);\\n        //System.out.println(Arrays.toString(ls));\\n        long c = 0, maxr = 0;\\n        int j = s.length()-1;\\n        for (int i = s.length()-1; i >= 0; i--) {\\n            int l = i - (ps[i]-1)/2;\\n            while (j >= l) {\\n                int k = (i - j)*2 + 1;\\n                if (j > 0) {\\n                    maxr = Math.max(maxr, k);\\n                    c = Math.max(c, maxr * ls[j-1]);\\n                }\\n                j--;\\n            }\\n        }\\n        return c;\\n    }\\n    int[] computePalindrome(String s) {\\n        int j = 0, l = 0, r = 0;\\n        int[] ret = new int[s.length()];\\n        ret[0] = 1;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (i > r) {\\n                j = i; \\n                l=r=i;\\n                while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\\n                    l--; r++;\\n                }\\n                l++; r--;\\n                ret[i] = r -l + 1;\\n            } else {\\n                int k = l + r -i;\\n                if ((ret[k] -1)/2 < (r-i)) {\\n                    ret[i] = ret[k];\\n                } else {\\n                    ret[i] = 1 + 2*(r-i);\\n                    l = i - (r-i);\\n                    r = i + (r-i);\\n                    while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\\n                        l--;r++;\\n                    }\\n                    l++; r--;\\n                    ret[i] = r -l +1;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863436,
                "title": "incorrected-expected-output",
                "content": "\"rofcjxfkbzcvvlbkgcwtcjctwcgkblvvczbkfxjcfor\" is a of length 43 which is a palendrome but expected output is 41 , any reason why?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1428950,
                "title": "using-manacher-and-queue",
                "content": "```\\nclass Solution {\\n    vector<int> pref, suf, lps;\\n    int sz;\\npublic:\\n    long long maxProduct(string s) {\\n        sz = s.size();\\n        lps.resize(sz); \\n        pref.resize(sz, 1);\\n        suf.resize(sz, 1);\\n        manacher(s);\\n        construct();\\n        \\n        for(int i =1 ; i<sz; i++){\\n            pref[i] = max(pref[i-1], pref[i]);\\n        }\\n        for(int i =sz-2 ; i>-1; i--){\\n            suf[i] = max(suf[i+1], suf[i]);\\n        }\\n        long long ret = 1;\\n        \\n        \\n        for(int i= 0; i< sz-1; i++){\\n            ret = max(ret, 1LL*pref[i]*suf[i+1]);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    \\n    void construct(){\\n        queue<int> bag1, bag2;\\n        \\n        for(int i = 0 ;i < sz; i++){\\n            bag1.push(i);\\n            while(bag1.front() + lps[bag1.front()] < i){\\n                bag1.pop();\\n            }\\n            if(i!=0) pref[i] = max(pref[i-1], 2*(i - bag1.front()) + 1); \\n        }\\n        \\n        for(int i = sz-1; i > -1; i--){\\n            bag2.push(i);\\n            while(bag2.front() - lps[bag2.front()] > i){\\n                bag2.pop();\\n            }\\n            if(i!=sz-1) suf[i] = max(suf[i+1], 2*(bag2.front() - i) + 1); \\n        }\\n    }\\n    \\n    \\n    void manacher(string & s){\\n        int center = -1, right  = -1;\\n        for(int i = 0; i<sz; i++){\\n            int d = (i>right? 1:min(lps[2*center - i] + 1, right+1- i));\\n            while(i+d< sz && i-d >-1 && s[i-d] == s[i+d]) d++;\\n            lps[i] = d - 1;\\n            if(i+d-1 > right){\\n                center = i, right = i + d - 1 ;\\n            }  \\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> pref, suf, lps;\\n    int sz;\\npublic:\\n    long long maxProduct(string s) {\\n        sz = s.size();\\n        lps.resize(sz); \\n        pref.resize(sz, 1);\\n        suf.resize(sz, 1);\\n        manacher(s);\\n        construct();\\n        \\n        for(int i =1 ; i<sz; i++){\\n            pref[i] = max(pref[i-1], pref[i]);\\n        }\\n        for(int i =sz-2 ; i>-1; i--){\\n            suf[i] = max(suf[i+1], suf[i]);\\n        }\\n        long long ret = 1;\\n        \\n        \\n        for(int i= 0; i< sz-1; i++){\\n            ret = max(ret, 1LL*pref[i]*suf[i+1]);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    \\n    void construct(){\\n        queue<int> bag1, bag2;\\n        \\n        for(int i = 0 ;i < sz; i++){\\n            bag1.push(i);\\n            while(bag1.front() + lps[bag1.front()] < i){\\n                bag1.pop();\\n            }\\n            if(i!=0) pref[i] = max(pref[i-1], 2*(i - bag1.front()) + 1); \\n        }\\n        \\n        for(int i = sz-1; i > -1; i--){\\n            bag2.push(i);\\n            while(bag2.front() - lps[bag2.front()] > i){\\n                bag2.pop();\\n            }\\n            if(i!=sz-1) suf[i] = max(suf[i+1], 2*(bag2.front() - i) + 1); \\n        }\\n    }\\n    \\n    \\n    void manacher(string & s){\\n        int center = -1, right  = -1;\\n        for(int i = 0; i<sz; i++){\\n            int d = (i>right? 1:min(lps[2*center - i] + 1, right+1- i));\\n            while(i+d< sz && i-d >-1 && s[i-d] == s[i+d]) d++;\\n            lps[i] = d - 1;\\n            if(i+d-1 > right){\\n                center = i, right = i + d - 1 ;\\n            }  \\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426256,
                "title": "how-do-you-get-a-length-product-of-45-for-this-input-string",
                "content": "LeetCode has 45 as the answer for this input: \"ggbswiymmlevedhkbdhntnhdbkhdevelmmyiwsbgg\"\\nWhat two odd-length palindrome lengths form that product? I use a brute-force palidrome algoirithm which comes up with only 3 odd-length palidromes that aren\\'t single letter:\\n\\n(center at index, total length)\\n(11,3)\\n(20,41)\\n(29,3)\\n\\nMy algo therefore says the max product is 9\\n",
                "solutionTags": [],
                "code": "LeetCode has 45 as the answer for this input: \"ggbswiymmlevedhkbdhntnhdbkhdevelmmyiwsbgg\"\\nWhat two odd-length palindrome lengths form that product? I use a brute-force palidrome algoirithm which comes up with only 3 odd-length palidromes that aren\\'t single letter:\\n\\n(center at index, total length)\\n(11,3)\\n(20,41)\\n(29,3)\\n\\nMy algo therefore says the max product is 9\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1402462,
                "title": "c-28-ms-faster-than-98-10-5-mb-less-space-than-100",
                "content": "class Solution {\\npublic:\\n    long long maxProduct(string &s) {\\n        \\n        int n = s.size(),c=0,r=0,mx=1,p[n],left[100000]={0};\\n        left[0]=1;\\n        for(int i=0;i<n;i++){\\n            p[i]=1;\\n            if(i<r)\\n                p[i] = min((r-i)*2+1,p[c-(i-c)]);\\n            \\n            int dist=p[i]/2 + 1;\\n            while(i+dist<n && i-dist>=0 && s[i+dist]==s[i-dist])\\n                p[i]+=2, dist++;\\n            \\n            if(i+dist-1>r)\\n                c=i, r= i + dist-1;\\n            for(int val = p[i],x=i+p[i]/2;left[x]==0;x--,val-=2)\\n                left[x]=max(mx,val);\\n            mx = max(mx,p[i]);\\n        }\\n        mx=1;\\n        long long ans = 1;\\n        int lefti = n;\\n        for(int i=n-1;i>=1;i--){\\n            int l, r, x=i-p[i]/2, val=p[i];\\n            \\n            if(i-p[i]/2 <1)\\n                x++,val-=2;\\n\\t\\t\\tr = left[x-1];\\n\\t\\t\\t\\n            for(;x<lefti ; x++,val-=2){\\n                l = r, r = left[x], left[x]=max(mx,val);\\n                ans = max(ans,1ll*l*left[x]);\\n            }\\n            mx = max(mx,p[i]);\\n            lefti = min(lefti,i-p[i]/2);\\n        }\\n        return ans;\\n    }                                               \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maxProduct(string &s) {\\n        \\n        int n = s.size(),c=0,r=0,mx=1,p[n],left[100000]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1399400,
                "title": "c-manacher",
                "content": "```\\nclass Solution {\\npublic:\\n\\tlong long maxProduct(string s) {\\n\\t\\tvector<long long> len(s.size());\\n\\t\\tint mx = 0;\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tif (i < mx + len[mx]) {\\n\\t\\t\\t\\tlen[i] = min(len[2 * mx - i], (long long)mx + len[mx] - i);\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (i - len[i] >= 0 && i + len[i] < s.size() && s[i - len[i]] == s[i + len[i]]) {\\n\\t\\t\\t\\tlen[i]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (mx + len[mx] < i + len[i]) {\\n\\t\\t\\t\\tmx = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<int> left(s.size()) , right(s.size());\\n\\n\\t\\tleft[0] = 1;\\n\\t\\tfor (int i = 1, p = 0; i < s.size(); ++i) {\\n\\t\\t\\twhile (p + len[p] - 1 < i) ++p;\\n\\t\\t\\tleft[i] = max(left[i - 1], 2 * (i - p) + 1);\\n\\t\\t}\\n\\n\\t\\tright[s.size() - 1] = 1;\\n\\t\\tfor (int i = s.size() - 2, p = s.size() - 1; i >= 0; --i) {\\n\\t\\t\\twhile (p - len[p] + 1 > i) --p;\\n\\t\\t\\tright[i] = max(right[i + 1], 2 * (p - i) + 1);\\n\\t\\t}\\n\\n\\t\\tlong long ret = 0;\\n\\t\\tfor (int i = 0; i + 1 < s.size(); ++i)\\n\\t\\t\\tret = max(ret, 1ll * left[i] * right[i + 1]);\\n\\t\\treturn ret;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tlong long maxProduct(string s) {\\n\\t\\tvector<long long> len(s.size());\\n\\t\\tint mx = 0;\\n\\t\\tfor (int i = 0; i < s.size(); i++) {\\n\\t\\t\\tif (i < mx + len[mx]) {\\n\\t\\t\\t\\tlen[i] = min(len[2 * mx - i], (long long)mx + len[mx] - i);\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (i - len[i] >= 0 && i + len[i] < s.size() && s[i - len[i]] == s[i + len[i]]) {\\n\\t\\t\\t\\tlen[i]++;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (mx + len[mx] < i + len[i]) {\\n\\t\\t\\t\\tmx = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tvector<int> left(s.size()) , right(s.size());\\n\\n\\t\\tleft[0] = 1;\\n\\t\\tfor (int i = 1, p = 0; i < s.size(); ++i) {\\n\\t\\t\\twhile (p + len[p] - 1 < i) ++p;\\n\\t\\t\\tleft[i] = max(left[i - 1], 2 * (i - p) + 1);\\n\\t\\t}\\n\\n\\t\\tright[s.size() - 1] = 1;\\n\\t\\tfor (int i = s.size() - 2, p = s.size() - 1; i >= 0; --i) {\\n\\t\\t\\twhile (p - len[p] + 1 > i) --p;\\n\\t\\t\\tright[i] = max(right[i + 1], 2 * (p - i) + 1);\\n\\t\\t}\\n\\n\\t\\tlong long ret = 0;\\n\\t\\tfor (int i = 0; i + 1 < s.size(); ++i)\\n\\t\\t\\tret = max(ret, 1ll * left[i] * right[i + 1]);\\n\\t\\treturn ret;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399080,
                "title": "java-o-n-modified-odd-manacher",
                "content": "Didn\\'t know anything about Manacher algorithm so far.\\nhttps://cp-algorithms.com/string/manacher.html#toc-tgt-6\\n\\n```\\n    public long maxProduct(String str) {\\n        StringBuilder sb = new StringBuilder(str);\\n        int len = sb.length();\\n        int[] dpl = new int[len];\\n        int[] dpr = new int[len];\\n        modifiedOddManacher(sb.toString(), dpl);\\n        modifiedOddManacher(sb.reverse().toString(), dpr);\\n        long max=1;\\n        for(int i=0;i<len-1;i++)\\n            max=Math.max(max, (1+(dpl[i]-1)*2L)*(1+(dpr[len-(i+1)-1]-1)*2L));\\n        return max;\\n    }\\n    private void modifiedOddManacher(String str, int[] dp){\\n        int len = str.length();\\n        int[] center = new int[len];\\n        for(int l=0,r=-1,i=0;i<len;i++){\\n            int radius = (i > r) ? 1 : Math.min(center[l+(r-i)], r-i+1);\\n               while(i-radius>=0 && i+radius<len && str.charAt(i-radius)==str.charAt(i+radius)) {\\n                  dp[i+radius] = radius+1;\\n                  radius++;\\n               }\\n            center[i] = radius--;\\n            if(i+radius>r){\\n                l = i-radius;\\n                r = i+radius;\\n            }\\n        }\\n        for(int i=0, max=1;i<len;i++){\\n            max = Math.max(max, dp[i]);\\n            dp[i] = max;\\n        }\\n    }\\n```\\n\\nJust comapare with basic odd Manacher for better understanding.\\n```\\n   private void oddManacher(String str){\\n        int len = str.length();\\n        int[] center = new int[len];\\n\\n        for(int l=0,r=-1,i=0;i<len;i++){\\n            int radius = (i > r) ? 1 : Math.min(center[l+(r-i)], r-i+1);\\n            while(i-radius>=0 && i+radius<len && str.charAt(i-radius)==str.charAt(i+radius)) \\n                radius++;\\n\\n            center[i] = radius--;\\n            if(i+radius > r){\\n                l = i-radius;\\n                r = i+radius;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long maxProduct(String str) {\\n        StringBuilder sb = new StringBuilder(str);\\n        int len = sb.length();\\n        int[] dpl = new int[len];\\n        int[] dpr = new int[len];\\n        modifiedOddManacher(sb.toString(), dpl);\\n        modifiedOddManacher(sb.reverse().toString(), dpr);\\n        long max=1;\\n        for(int i=0;i<len-1;i++)\\n            max=Math.max(max, (1+(dpl[i]-1)*2L)*(1+(dpr[len-(i+1)-1]-1)*2L));\\n        return max;\\n    }\\n    private void modifiedOddManacher(String str, int[] dp){\\n        int len = str.length();\\n        int[] center = new int[len];\\n        for(int l=0,r=-1,i=0;i<len;i++){\\n            int radius = (i > r) ? 1 : Math.min(center[l+(r-i)], r-i+1);\\n               while(i-radius>=0 && i+radius<len && str.charAt(i-radius)==str.charAt(i+radius)) {\\n                  dp[i+radius] = radius+1;\\n                  radius++;\\n               }\\n            center[i] = radius--;\\n            if(i+radius>r){\\n                l = i-radius;\\n                r = i+radius;\\n            }\\n        }\\n        for(int i=0, max=1;i<len;i++){\\n            max = Math.max(max, dp[i]);\\n            dp[i] = max;\\n        }\\n    }\\n```\n```\\n   private void oddManacher(String str){\\n        int len = str.length();\\n        int[] center = new int[len];\\n\\n        for(int l=0,r=-1,i=0;i<len;i++){\\n            int radius = (i > r) ? 1 : Math.min(center[l+(r-i)], r-i+1);\\n            while(i-radius>=0 && i+radius<len && str.charAt(i-radius)==str.charAt(i+radius)) \\n                radius++;\\n\\n            center[i] = radius--;\\n            if(i+radius > r){\\n                l = i-radius;\\n                r = i+radius;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1396294,
                "title": "java-dp-bottom-up-easy-to-understand-beats-100",
                "content": "- cost[i][j] denotes the minimum space wasted between index i to j\\n- dp[i][k] denotes the minumum space wasted between index 0 to i with k resizing operations\\n```\\npublic int minSpaceWastedKResizing(int[] nums, int K) {\\n\\tfinal int n = nums.length;\\n\\tint[][] cost = new int[n][n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint max = nums[i];\\n\\t\\tint sum = 0;\\n\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\tsum += nums[j];\\n\\t\\t\\tmax = Math.max(max, nums[j]);\\n\\t\\t\\tcost[i][j] = max * (j - i + 1) - sum;\\n\\t\\t}\\n\\t}\\n\\tint[][] dp = new int[n][K+1];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tdp[i][0] = cost[0][i];\\n\\t}\\n\\tfor (int k = 1; k <= K; k++) {\\n\\t\\tdp[0][k] = 0;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tdp[i][k] = Integer.MAX_VALUE;\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tdp[i][k] = Math.min(dp[i][k], dp[j][k-1] + cost[j+1][i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[n-1][K];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minSpaceWastedKResizing(int[] nums, int K) {\\n\\tfinal int n = nums.length;\\n\\tint[][] cost = new int[n][n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint max = nums[i];\\n\\t\\tint sum = 0;\\n\\t\\tfor (int j = i; j < n; j++) {\\n\\t\\t\\tsum += nums[j];\\n\\t\\t\\tmax = Math.max(max, nums[j]);\\n\\t\\t\\tcost[i][j] = max * (j - i + 1) - sum;\\n\\t\\t}\\n\\t}\\n\\tint[][] dp = new int[n][K+1];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tdp[i][0] = cost[0][i];\\n\\t}\\n\\tfor (int k = 1; k <= K; k++) {\\n\\t\\tdp[0][k] = 0;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tdp[i][k] = Integer.MAX_VALUE;\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tdp[i][k] = Math.min(dp[i][k], dp[j][k-1] + cost[j+1][i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[n-1][K];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1395341,
                "title": "c-kmp-like-without-manacher-o-n-time-o-n-space",
                "content": "1. Let\\'s go left ot right and remember all palindroms ends on position and hold in in allpals = std::vector<std::vector<int>>. So    allpals[5] == {1,3,5} means we have 3 palindroms size 1 (subsbring [5,5]), 3 ([3,5]) and 5 ([1,5])\\n2. allpals[0] == {1}\\n3. On position pos > 1 we could check all palindroms allpals[pos - 1] and for palindrom p_i we check if s[pos] == s[pos - p_i - 1]. This is enough for add new palindrom with len (p_i + 2) to allpals[pos]\\n\\n```\\n\\n....?PPPPPPPPC\\nc - is current position,\\n(P) - is palindrome with len = p_i\\n\\n```\\n4. But this it require O(n* n) mem &time.\\n6.  Lets see closer to all palindroms, end on pos = pos.   \\np_1...p_n\\n```\\nour string\\n............................\\n...........PPPPPPPPP    -first palindrome\\n.............DDDDDDD   -second palindrome\\n...........DDDDDDD..   -second palindrome reverse (because P - is palindrome)\\n```\\n8.    As we see below, d* and D* also palindrome\\n9.    all palindrome which less than d for pos = pos, are alse palindrome for (pos - 2) (in this example.\\n10.    So, we just need take largest palindrome P, and second appropriate (D). and store position, when D is holds. (in this example pos - 2)\\n11.    Idea is the same, as for prefix-function KMP algo or Aho\\u2013Corasick (for backlinks)\\n12. so, we need to store largest palindrom. and link to previous. So, jump to this links we can enumerate all palindroms, ends on position.\\n13. for this task there is smaxforw array for max palindrome, end no far than pos\\n14. This algo works good for odd & even palindroms. (rather than manacher ;)\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        const int nsize = s.size();\\n        \\n        using vi = std::vector<long long>;\\n        \\n        auto make_buf = [&]() {\\n            vi maxforw(nsize, 1);\\n            vi smaxforw(nsize, 1);\\n            vi prevpos(nsize, -1);\\n\\n\\n            maxforw[0] = 1;\\n            smaxforw[0] = 1;\\n            prevpos[0] = -1;\\n\\n            for (int pos = 1; pos < nsize; ++pos) {\\n                int prev = pos - 1;\\n                int curmax = 1;\\n                while (prev >= 0) {\\n                    int prevlen = maxforw[prev];\\n                    int pp = pos - prevlen - 1;\\n                    if (pp >= 0 && s[pos] == s[pp]) {\\n                        curmax = prevlen + 2;\\n                        break;\\n                    }\\n                    prev = prevpos[prev];\\n                }\\n                prevpos[pos] = prev;\\n                maxforw[pos] = curmax;\\n                smaxforw[pos] = std::max(smaxforw[pos - 1], maxforw[pos]);\\n            }\\n            return std::move(smaxforw);\\n        };\\n        \\n        auto&& forw = make_buf();\\n        std::reverse(s.begin(), s.end());\\n        auto&& rev = make_buf();\\n        \\n        long long best = 1;\\n        \\n        for (int pos = 1; pos < nsize; ++pos) {\\n            best = std::max(best, forw[pos - 1] * rev[nsize - 1 - pos]);\\n        }\\n        return best;\\n    }\\n};\\n```\\n\\nalgo need  2 * n memorty. (value + prev position for each posigion)",
                "solutionTags": [],
                "code": "```\\n\\n....?PPPPPPPPC\\nc - is current position,\\n(P) - is palindrome with len = p_i\\n\\n```\n```\\nour string\\n............................\\n...........PPPPPPPPP    -first palindrome\\n.............DDDDDDD   -second palindrome\\n...........DDDDDDD..   -second palindrome reverse (because P - is palindrome)\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        const int nsize = s.size();\\n        \\n        using vi = std::vector<long long>;\\n        \\n        auto make_buf = [&]() {\\n            vi maxforw(nsize, 1);\\n            vi smaxforw(nsize, 1);\\n            vi prevpos(nsize, -1);\\n\\n\\n            maxforw[0] = 1;\\n            smaxforw[0] = 1;\\n            prevpos[0] = -1;\\n\\n            for (int pos = 1; pos < nsize; ++pos) {\\n                int prev = pos - 1;\\n                int curmax = 1;\\n                while (prev >= 0) {\\n                    int prevlen = maxforw[prev];\\n                    int pp = pos - prevlen - 1;\\n                    if (pp >= 0 && s[pos] == s[pp]) {\\n                        curmax = prevlen + 2;\\n                        break;\\n                    }\\n                    prev = prevpos[prev];\\n                }\\n                prevpos[pos] = prev;\\n                maxforw[pos] = curmax;\\n                smaxforw[pos] = std::max(smaxforw[pos - 1], maxforw[pos]);\\n            }\\n            return std::move(smaxforw);\\n        };\\n        \\n        auto&& forw = make_buf();\\n        std::reverse(s.begin(), s.end());\\n        auto&& rev = make_buf();\\n        \\n        long long best = 1;\\n        \\n        for (int pos = 1; pos < nsize; ++pos) {\\n            best = std::max(best, forw[pos - 1] * rev[nsize - 1 - pos]);\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391496,
                "title": "rolling-hash-cpp-nlogn-solution",
                "content": "First we find the longest palindrome we can get from each point, for this we can use [Manacher\\'s Algorithm](https://cp-algorithms.com/string/manacher.html) or we can use [polynomial hashing](https://codeforces.com/blog/entry/60445) .\\n\\\\\\nHere we used polynomial hashing with binary search to optimise our palindrome search\\n\\n```\\nvector<long long> pows;\\nlong long hash = 3137;\\nbool done = true;\\nconst int mod = 1e9 + 7;\\nlong long LeftHash[100005], RightHash[100005];\\nvoid init() {\\n    done = false;\\n    pows.resize(100005, 1);\\n    for(int i = 1; i < 100005; i++){\\n        pows[i] = (1LL*pows[i-1]*(::hash)) % mod;\\n    }\\n}\\nlong long HashValue(int ind, int len, long long a[100005]) {\\n    long long retval =  a[ind + len] - a[ind]*pows[len];\\n    retval %= mod;\\n    if(retval < 0) retval += mod;\\n    return retval;\\n}\\n\\nlong long Find_Longest_Palindrome_From_Current_Index(string &str, int i) {\\n    int n = str.length();\\n    int s = 0, e = min(i , n - i - 1);\\n    while(s < e) {\\n        int lens = (s + e + 1) >> 1;\\n        if(HashValue(i - lens, lens, LeftHash) ==  HashValue(n - i - lens - 1, lens, RightHash)) {\\n            s = lens;\\n        } else {\\n            e = lens - 1;\\n        }\\n    }\\n    return s;\\n }\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        if(done) init();\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            LeftHash[i+1] = (LeftHash[i]* ::hash + s[i]) % mod;\\n            RightHash[i+1] = (RightHash[i]*::hash + s[n - i - 1]) % mod;\\n        }\\n        vector<long long> left(n, 1), right(n,1);\\n        for(int i = 0; i < n; i++) {\\n            int get =  Find_Longest_Palindrome_From_Current_Index(s,i);\\n            left[i + get] = max<long long>(left[i + get], 2*get + 1);\\n            right[i - get] = max<long long>(right[i - get], 2*get + 1);\\n        }\\n        for(int i = n-2; i >= 0; i--){\\n            left[i] = max<long long>(left[i], left[i+1] - 2);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            right[i] = max<long long>(right[i], right[i-1] - 2);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            left[i] = max<long long>(left[i-1], left[i]);\\n            right[n-i-1] = max<long long>(right[n-i], right[n-i-1]);\\n        }\\n        long long ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            ans = max<long long>(ans, left[i-1]*right[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvector<long long> pows;\\nlong long hash = 3137;\\nbool done = true;\\nconst int mod = 1e9 + 7;\\nlong long LeftHash[100005], RightHash[100005];\\nvoid init() {\\n    done = false;\\n    pows.resize(100005, 1);\\n    for(int i = 1; i < 100005; i++){\\n        pows[i] = (1LL*pows[i-1]*(::hash)) % mod;\\n    }\\n}\\nlong long HashValue(int ind, int len, long long a[100005]) {\\n    long long retval =  a[ind + len] - a[ind]*pows[len];\\n    retval %= mod;\\n    if(retval < 0) retval += mod;\\n    return retval;\\n}\\n\\nlong long Find_Longest_Palindrome_From_Current_Index(string &str, int i) {\\n    int n = str.length();\\n    int s = 0, e = min(i , n - i - 1);\\n    while(s < e) {\\n        int lens = (s + e + 1) >> 1;\\n        if(HashValue(i - lens, lens, LeftHash) ==  HashValue(n - i - lens - 1, lens, RightHash)) {\\n            s = lens;\\n        } else {\\n            e = lens - 1;\\n        }\\n    }\\n    return s;\\n }\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        if(done) init();\\n        int n = s.length();\\n        for(int i = 0; i < n; i++) {\\n            LeftHash[i+1] = (LeftHash[i]* ::hash + s[i]) % mod;\\n            RightHash[i+1] = (RightHash[i]*::hash + s[n - i - 1]) % mod;\\n        }\\n        vector<long long> left(n, 1), right(n,1);\\n        for(int i = 0; i < n; i++) {\\n            int get =  Find_Longest_Palindrome_From_Current_Index(s,i);\\n            left[i + get] = max<long long>(left[i + get], 2*get + 1);\\n            right[i - get] = max<long long>(right[i - get], 2*get + 1);\\n        }\\n        for(int i = n-2; i >= 0; i--){\\n            left[i] = max<long long>(left[i], left[i+1] - 2);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            right[i] = max<long long>(right[i], right[i-1] - 2);\\n        }\\n        for(int i = 1; i < n; i++) {\\n            left[i] = max<long long>(left[i-1], left[i]);\\n            right[n-i-1] = max<long long>(right[n-i], right[n-i-1]);\\n        }\\n        long long ans = 0;\\n        for(int i = 1; i < n; i++) {\\n            ans = max<long long>(ans, left[i-1]*right[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390752,
                "title": "c-manacher-no-queue-o-n",
                "content": "Manacher algorithm with a small patch: every time we find a new palindrome, we record it in two arrays: left and right.\\nleft(x) means there is a palindrome on the left side of x ending at x, right(x) means there is a palindrome on the right side of x.\\nThe arrays hold the radii of the respective palindromes.\\nIf a few palindromes end at the same x, we store the largest radius only.\\n\\nIn the end, we do two passes over the arrays to find for each x the largest palindrome ending at x or before, and starting at x or later.\\n\\nThen we consider all pairs (left(x-1)\\\\*2+1) * (right(x)\\\\*2+1) to find the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length(), c = 0, r = 0;\\n        vector<int> rr(n), left(n), right(n);\\n        while(c < n)\\n        {\\n            // grow the palindrome\\n            while(c-(r+1)>=0 && c+(r+1)<n && s[c-(r+1)]==s[c+(r+1)])\\n            {\\n                r++;\\n                // record palindrome radius r ending at c+r and c-r\\n                left [c+r] = max(left [c+r],r);\\n                right[c-r] = max(right[c-r],r);\\n            }\\n\\n            // done at c, move on\\n            int c_old = c, r_old = r;\\n            rr[c++] = r;\\n            r = 0;\\n            \\n            // Manacher\\'s mirror\\n            for(;c-c_old <= r_old && c-c_old <= c_old;c++)\\n            {\\n                int c_mirr = c_old - (c-c_old);\\n                int r_mirr = r_old - (c-c_old);\\n                if(rr[c_mirr]==r_mirr) {r = r_mirr; break;}\\n                rr[c] = min(r_mirr,rr[c_mirr]);\\n                \\n                // record palindrom radius rr[c] ending at c+rr[c], c-rr[c]\\n                left [c+rr[c]] = max(left [c+rr[c]],rr[c]);\\n                right[c-rr[c]] = max(right[c-rr[c]],rr[c]);\\n            }\\n        }\\n        \\n\\t\\t// process the arrays to track the best palindromes found on the left and the right side\\n        int mx = 0; for(int i = 0;   i <  n; i++) left[i]  = max( left [i], mx = max(mx,left [i]) );\\n            mx = 0; for(int i = n-1; i >= 0; i--) right[i] = max( right[i], mx = max(mx,right[i]) );\\n\\n        // consider all left[x-1] * right[x] pairs, but remember to convert radii to lengths\\n        long long o = 0;\\n        for(int i = 1; i < n; i++) o = max(o, (left[i-1]*2+1)*(long long)(right[i]*2+1));\\n        return o;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxProduct(string s) {\\n        int n = s.length(), c = 0, r = 0;\\n        vector<int> rr(n), left(n), right(n);\\n        while(c < n)\\n        {\\n            // grow the palindrome\\n            while(c-(r+1)>=0 && c+(r+1)<n && s[c-(r+1)]==s[c+(r+1)])\\n            {\\n                r++;\\n                // record palindrome radius r ending at c+r and c-r\\n                left [c+r] = max(left [c+r],r);\\n                right[c-r] = max(right[c-r],r);\\n            }\\n\\n            // done at c, move on\\n            int c_old = c, r_old = r;\\n            rr[c++] = r;\\n            r = 0;\\n            \\n            // Manacher\\'s mirror\\n            for(;c-c_old <= r_old && c-c_old <= c_old;c++)\\n            {\\n                int c_mirr = c_old - (c-c_old);\\n                int r_mirr = r_old - (c-c_old);\\n                if(rr[c_mirr]==r_mirr) {r = r_mirr; break;}\\n                rr[c] = min(r_mirr,rr[c_mirr]);\\n                \\n                // record palindrom radius rr[c] ending at c+rr[c], c-rr[c]\\n                left [c+rr[c]] = max(left [c+rr[c]],rr[c]);\\n                right[c-rr[c]] = max(right[c-rr[c]],rr[c]);\\n            }\\n        }\\n        \\n\\t\\t// process the arrays to track the best palindromes found on the left and the right side\\n        int mx = 0; for(int i = 0;   i <  n; i++) left[i]  = max( left [i], mx = max(mx,left [i]) );\\n            mx = 0; for(int i = n-1; i >= 0; i--) right[i] = max( right[i], mx = max(mx,right[i]) );\\n\\n        // consider all left[x-1] * right[x] pairs, but remember to convert radii to lengths\\n        long long o = 0;\\n        for(int i = 1; i < n; i++) o = max(o, (left[i-1]*2+1)*(long long)(right[i]*2+1));\\n        return o;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566188,
                "content": [
                    {
                        "username": "megaspazz",
                        "content": "I was unable to come up with any alternatives, and ended up using Manacher\\'s Algorithm, but I had thought that this was typically out of the scope of LeetCode problems.\\n\\nIt is mentioned in [Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/solution/), which I\\'d consider to be the most direct application / use of Manacher\\'s Algorithm, but even for that problem, it was optional as an O(N^2) solution was accepted due to the smaller constraints.\\n\\nIn my memory, this is the first problem to actually need Manacher\\'s Algorithm to pass all test cases, but was wondering if this isn\\'t the first one and/or if there were alternate solutions to this problem.\\n\\nHas LeetCode has raised the bar of difficulty on contest problems?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Check If String Is a Prefix of Array",
        "question_content": "<p>Given a string <code>s</code> and an array of strings <code>words</code>, determine whether <code>s</code> is a <strong>prefix string</strong> of <code>words</code>.</p>\n\n<p>A string <code>s</code> is a <strong>prefix string</strong> of <code>words</code> if <code>s</code> can be made by concatenating the first <code>k</code> strings in <code>words</code> for some <strong>positive</strong> <code>k</code> no larger than <code>words.length</code>.</p>\n\n<p>Return <code>true</code><em> if </em><code>s</code><em> is a <strong>prefix string</strong> of </em><code>words</code><em>, or </em><code>false</code><em> otherwise</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;iloveleetcode&quot;, words = [&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;,&quot;apples&quot;]\n<strong>Output:</strong> true\n<strong>Explanation:</strong>\ns can be made by concatenating &quot;i&quot;, &quot;love&quot;, and &quot;leetcode&quot; together.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;iloveleetcode&quot;, words = [&quot;apples&quot;,&quot;i&quot;,&quot;love&quot;,&quot;leetcode&quot;]\n<strong>Output:</strong> false\n<strong>Explanation:</strong>\nIt is impossible to make s using a prefix of arr.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 20</code></li>\n\t<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n\t<li><code>words[i]</code> and <code>s</code> consist of only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1390325,
                "title": "java-simple-append-and-check-algorithmic-explanation",
                "content": "*------Please **upvote!** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**Algorithm:**\\n\\n1.\\tKeep appending the strings in the array 1-by-1.\\n2.\\tIf the appended string matches the given string, return true.\\n3.\\tIf the given string does not contain the appended string, return false.\\n4.\\tIf the loop terminates, return false.\\n\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder res = new StringBuilder (\"\");\\n        for (String word : words) {\\n            res.append (word);\\n            if (s.equals (res.toString()))\\n                return true;\\n            if (s.indexOf (res.toString()) == -1)\\n                return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder res = new StringBuilder (\"\");\\n        for (String word : words) {\\n            res.append (word);\\n            if (s.equals (res.toString()))\\n                return true;\\n            if (s.indexOf (res.toString()) == -1)\\n                return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390619,
                "title": "tricky-description",
                "content": "I missed few conditions and got 2 WA. Embarassing.\\n\\nSo, first catch is that we need to match the entire string `s`. The second catch is that we cannot stop in the middle of a word, only in between.\\n\\n**C++**\\n```cpp\\nbool isPrefixString(string s, vector<string>& words) {\\n    int i = 0;\\n    for (int j = 0; j < words.size() && i < s.size(); ++j)\\n        for (auto ch : words[j])\\n            if (i == s.size() || s[i++] != ch)\\n                return false;\\n    return i == s.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool isPrefixString(string s, vector<string>& words) {\\n    int i = 0;\\n    for (int j = 0; j < words.size() && i < s.size(); ++j)\\n        for (auto ch : words[j])\\n            if (i == s.size() || s[i++] != ch)\\n                return false;\\n    return i == s.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390199,
                "title": "python3-move-along-s",
                "content": "\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        i = 0\\n        for word in words: \\n            if s[i:i+len(word)] != word: return False \\n            i += len(word)\\n            if i == len(s): return True \\n        return False \\n```\\n\\nThe solutions for weekly 255 can be found in this [commit](https://github.com/gaosanyong/leetcode/commit/312849ed66e5ad76fa278cbb34dd57772fb3ceeb).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        i = 0\\n        for word in words: \\n            if s[i:i+len(word)] != word: return False \\n            i += len(word)\\n            if i == len(s): return True \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390270,
                "title": "c-simple",
                "content": "```\\n/*\\n    straight forward, just keep appending the string and \\n    checking at the same time if it matches \\'s\\'\\n\\tWe can break earlier when the length exceeds the length of \\'s\\'. Thanks to @MSR_Yang\\n*/\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string check = \"\";\\n        \\n        for(const string &word : words) {\\n            check += word;\\n            \\n\\t\\t\\tif(check == s)                   return true;\\n\\t\\t\\tif(check.length() >= s.length()) return false;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    straight forward, just keep appending the string and \\n    checking at the same time if it matches \\'s\\'\\n\\tWe can break earlier when the length exceeds the length of \\'s\\'. Thanks to @MSR_Yang\\n*/\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string check = \"\";\\n        \\n        for(const string &word : words) {\\n            check += word;\\n            \\n\\t\\t\\tif(check == s)                   return true;\\n\\t\\t\\tif(check.length() >= s.length()) return false;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390509,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        \\n        a = \\'\\'\\n    \\n        for i in words:\\n            \\n            a += i\\n            \\n            if a == s:\\n                return True\\n            if not s.startswith(a):\\n                break\\n                     \\n        return False \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        \\n        a = \\'\\'\\n    \\n        for i in words:\\n            \\n            a += i\\n            \\n            if a == s:\\n                return True\\n            if not s.startswith(a):\\n                break\\n                     \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390332,
                "title": "javascript-direct-way-117ms",
                "content": "```\\nconst isPrefixString = (s, w) => {\\n    let tmp = \\'\\';\\n    for (const e of w) {\\n        tmp += e;\\n        if (tmp == s) return true; \\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isPrefixString = (s, w) => {\\n    let tmp = \\'\\';\\n    for (const e of w) {\\n        tmp += e;\\n        if (tmp == s) return true; \\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1393474,
                "title": "c-easy-peasy-simple-solution-4-short-lines",
                "content": "Append each word to `res` and check if it equals to s.\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string res = \"\";\\n        for (auto w : words) {\\n            res += w;\\n            if (res == s) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string res = \"\";\\n        for (auto w : words) {\\n            res += w;\\n            if (res == s) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390473,
                "title": "python-brute-force-o-mn",
                "content": "Start from an empty string and build the prefix string word by word. Every time we build the prefix string, check if it\\'s equal to `s`.\\n\\nLet `n` be length of `s` and `m` be length of all words combined. Then in the worst case we check equality `m` times for length of string `n`.\\n\\nO(mn) time complexity.\\n\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        cur_prefix = \"\"\\n        for i in range(len(words)):\\n            cur_prefix += words[i]\\n            if s == cur_prefix:\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        cur_prefix = \"\"\\n        for i in range(len(words)):\\n            cur_prefix += words[i]\\n            if s == cur_prefix:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003861,
                "title": "python-most-simple-solution-one-liner",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def isPrefixString(self, s, words):\\n        return s in accumulate(words)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s, words):\\n        return s in accumulate(words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390260,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int n = s.size();\\n        string res;\\n        int m = words.size();\\n        for(int i = 0;i<m && res.size()<n;i++){\\n            if(res == s)return true;\\n            res += words[i];\\n        }\\n        return res == s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int n = s.size();\\n        string res;\\n        int m = words.size();\\n        for(int i = 0;i<m && res.size()<n;i++){\\n            if(res == s)return true;\\n            res += words[i];\\n        }\\n        return res == s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390248,
                "title": "c-easy-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string n=\"\";\\n        for(string str:words){\\n            for(char ch:str){\\n                n+=ch;\\n            }\\n            if(n==s){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string n=\"\";\\n        for(string str:words){\\n            for(char ch:str){\\n                n+=ch;\\n            }\\n            if(n==s){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390161,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int count = 0; \\n        char[] chars = s.toCharArray(); \\n        for (String word : words) {\\n            for (char c : word.toCharArray()) {\\n                if (count == chars.length) {\\n                    return false; \\n                }\\n                if (chars[count++] != c) {\\n                    return false; \\n                }\\n            }\\n            if (count == chars.length) {\\n                return true; \\n            }\\n        }\\n        return count == chars.length; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int count = 0; \\n        char[] chars = s.toCharArray(); \\n        for (String word : words) {\\n            for (char c : word.toCharArray()) {\\n                if (count == chars.length) {\\n                    return false; \\n                }\\n                if (chars[count++] != c) {\\n                    return false; \\n                }\\n            }\\n            if (count == chars.length) {\\n                return true; \\n            }\\n        }\\n        return count == chars.length; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039081,
                "title": "python3-code",
                "content": "# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words):\\n        subresult = [\\'\\'.join(words[:i+1]) for i in range(len(words))]\\n        for substr in subresult:\\n            if substr == s: return True\\n        return False\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/69e6c757-a27b-4e78-b050-9d0864b66d3c_1673506636.7428927.png)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words):\\n        subresult = [\\'\\'.join(words[:i+1]) for i in range(len(words))]\\n        for substr in subresult:\\n            if substr == s: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745414,
                "title": "java-solution-using-stringbuilder",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n\\n        for (String w: words){\\n            sb.append(w);\\n            if (s.equals(sb.toString())) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        \\n        StringBuilder sb = new StringBuilder();\\n\\n        for (String w: words){\\n            sb.append(w);\\n            if (s.equals(sb.toString())) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733030,
                "title": "c-2-different-approaches-fast-0ms-clean-code",
                "content": "I was slighlty confused with the problem description. At first I though we need to try all possible combinations to see if we can build the target string ```s```, but it turns out we just need to see if the first ```k``` words in ```words``` concatenated yield the string ```s```.\\n\\n# Approach 1: concatenate (9ms)\\n\\n```cpp\\n    static bool isPrefixString(const string& s, const vector<string>& words) {\\n        string prefix;\\n        prefix.reserve(size(s));\\n        for (const string& word : words) {\\n            if (size(prefix) < size(s)) {\\n                prefix += word;\\n            } else {\\n                break;\\n            }\\n        }\\n        return s == prefix;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the size of the string ```s``` then the\\n  * Time complexity is $$O(n)$$ for copying and then comparing the string, and the\\n  * Space complexity is $$O(n)$$ as we need to extra space for the ```prefix``` string.\\n\\n\\n# Approach 2: compare piecewise (0ms)\\n\\nTo avoid stiching the string together we can just compare them piece by piece.\\n\\n```cpp\\n    static bool isPrefixString(const string& s, const vector<string>& words) {\\n        int pos = 0;\\n        for (int i = 0; pos < size(s) && i < size(words); ++i) {\\n            if (s.compare(pos, size(words[i]), words[i]) != 0) return false;\\n            pos += size(words[i]);\\n        }\\n        return pos == size(s);\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the size of the string ```s``` then the\\n  * Time complexity is $$O(n)$$ as we are comparing up to the length of ```s``` and the\\n  * Space complexity is $$O(1)$$.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an upvote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```s```\n```k```\n```words```\n```s```\n```cpp\\n    static bool isPrefixString(const string& s, const vector<string>& words) {\\n        string prefix;\\n        prefix.reserve(size(s));\\n        for (const string& word : words) {\\n            if (size(prefix) < size(s)) {\\n                prefix += word;\\n            } else {\\n                break;\\n            }\\n        }\\n        return s == prefix;\\n    }\\n```\n```s```\n```prefix```\n```cpp\\n    static bool isPrefixString(const string& s, const vector<string>& words) {\\n        int pos = 0;\\n        for (int i = 0; pos < size(s) && i < size(words); ++i) {\\n            if (s.compare(pos, size(words[i]), words[i]) != 0) return false;\\n            pos += size(words[i]);\\n        }\\n        return pos == size(s);\\n    }\\n```\n```s```\n```s```",
                "codeTag": "Unknown"
            },
            {
                "id": 3130015,
                "title": "j",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String st=\"\";\\n        for(int i=0;i<words.length;i++){\\n            if(s.indexOf(words[i])==-1){\\n                return false;\\n            }\\n            st+=words[i];\\n            if(s.equals(st)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String st=\"\";\\n        for(int i=0;i<words.length;i++){\\n            if(s.indexOf(words[i])==-1){\\n                return false;\\n            }\\n            st+=words[i];\\n            if(s.equals(st)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221696,
                "title": "python-solution-for-beginners-by-beginner",
                "content": "\\nRuntime: 36 ms, faster than 91.08% of Python3 online submissions for Check If String Is a Prefix of Array.\\nMemory Usage: 13.8 MB, less than 97.53% of Python3 online submissions for Check If String Is a Prefix of Array.\\n\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        ans = \\'\\'\\n        for i in words:\\n            ans += i\\n            if ans == s :\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        ans = \\'\\'\\n        for i in words:\\n            ans += i\\n            if ans == s :\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390401,
                "title": "easy-python",
                "content": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        ans=\"\"\\n        for x in words:\\n            ans+=x\\n            if ans==s:\\n                return True\\n        return False\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        ans=\"\"\\n        for x in words:\\n            ans+=x\\n            if ans==s:\\n                return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390221,
                "title": "java-easy-code",
                "content": "```\\nclass Solution {\\n  \\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0;i<words.length;i++){\\n            for(int j = 0;j<words[i].length();j++){\\n                sb.append(words[i].charAt(j));\\n            }\\n             if(s.equals(sb.toString())){\\n            return true;\\n        }\\n        }\\n       \\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  \\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0;i<words.length;i++){\\n            for(int j = 0;j<words[i].length();j++){\\n                sb.append(words[i].charAt(j));\\n            }\\n             if(s.equals(sb.toString())){\\n            return true;\\n        }\\n        }\\n       \\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492602,
                "title": "check-if-string-is-a-prefix-of-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOPTIMIZED APPROACH\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i;\\n        string s1;\\n        for(i=0;i<words.size();i++)\\n        {\\n            s1 += words[i];\\n            if(s1==s)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBRUTE FORCE APPROACH\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i;\\n        string s1;\\n        for(i=0;i<words.size();i++)\\n        {\\n            s1 += words[i];\\n            if(s1==s)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/f815a80b-3468-473c-862a-b3e4e1f73abb_1683366660.2016609.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i;\\n        string s1;\\n        for(i=0;i<words.size();i++)\\n        {\\n            s1 += words[i];\\n            if(s1==s)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i;\\n        string s1;\\n        for(i=0;i<words.size();i++)\\n        {\\n            s1 += words[i];\\n            if(s1==s)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442078,
                "title": "short-and-easy-to-understand-c",
                "content": "`Please Upvote the solution`\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string ans;\\n        for(auto &w : words) {\\n            ans += w;\\n\\t\\t\\tif(ans == s) return true;\\n\\t\\t\\tif(ans.length() >= s.length()) return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string ans;\\n        for(auto &w : words) {\\n            ans += w;\\n\\t\\t\\tif(ans == s) return true;\\n\\t\\t\\tif(ans.length() >= s.length()) return false;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848210,
                "title": "c-simple-code-88",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n       string ns=words[0];\\n        int i=1;\\n        while(ns.length()<s.length() && i<words.size())\\n        {\\n            ns+=words[i];\\n            i++;\\n        }\\n        if(ns==s)\\n        {\\n          return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n       string ns=words[0];\\n        int i=1;\\n        while(ns.length()<s.length() && i<words.size())\\n        {\\n            ns+=words[i];\\n            i++;\\n        }\\n        if(ns==s)\\n        {\\n          return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2447093,
                "title": "javascript-tc-o-n-sc-o-1",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n    let i = 0;\\n    \\n    for (const word of words) {\\n        if (!s.startsWith(word, i)) return false;\\n        i += word.length;\\n        if (i === s.length) return true;\\n    }\\n    \\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n    let i = 0;\\n    \\n    for (const word of words) {\\n        if (!s.startsWith(word, i)) return false;\\n        i += word.length;\\n        if (i === s.length) return true;\\n    }\\n    \\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019399,
                "title": "o-n-with-o-1-space-complexity-solution-two-pointer-approach-with-explanation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i=0,j=0,c=0;\\n        while(i<s.length() && j<words.size())\\n        {\\n            if(s[i]!=words[j][c])\\n                return false;\\n            else\\n            {\\n                c++;\\n                i++;\\n            }\\n            if(c==words[j].length())\\n            {\\n                j++;\\n                c=0;\\n            }\\n        }\\n        if(c==0 && i==s.length())\\n            return true;\\n        else\\n            return false;\\n    }\\n};/*we compare every letter of the strings in the words vector in order and if it doesn\\'t match, we return false.\\n//* c==0 condition :\\n\"a\" [\"aa\",\"aaaa\",\"banana\"]\\na should be a proper full word concentations.\\n//*i==s.length()\\nHence, we need to ensure that the strings are fully matched\\n\"ccccccccc\" [\"c\",\"cc\"]\\nWe need to ensure that the string s is fully iterated. This happens when the word vector is shorter when c is equal to the length of string, one string in word is iterated completelely and now move to another string.*/\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i=0,j=0,c=0;\\n        while(i<s.length() && j<words.size())\\n        {\\n            if(s[i]!=words[j][c])\\n                return false;\\n            else\\n            {\\n                c++;\\n                i++;\\n            }\\n            if(c==words[j].length())\\n            {\\n                j++;\\n                c=0;\\n            }\\n        }\\n        if(c==0 && i==s.length())\\n            return true;\\n        else\\n            return false;\\n    }\\n};/*we compare every letter of the strings in the words vector in order and if it doesn\\'t match, we return false.\\n//* c==0 condition :\\n\"a\" [\"aa\",\"aaaa\",\"banana\"]\\na should be a proper full word concentations.\\n//*i==s.length()\\nHence, we need to ensure that the strings are fully matched\\n\"ccccccccc\" [\"c\",\"cc\"]\\nWe need to ensure that the string s is fully iterated. This happens when the word vector is shorter when c is equal to the length of string, one string in word is iterated completelely and now move to another string.*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012833,
                "title": "easy-java-1ms-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder build = new StringBuilder();\\n        int i = 0;\\n        while(build.length() < s.length() && i < words.length){\\n            build.append(words[i]);\\n            i++;\\n        }\\n        return build.toString().equals(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder build = new StringBuilder();\\n        int i = 0;\\n        while(build.length() < s.length() && i < words.length){\\n            build.append(words[i]);\\n            i++;\\n        }\\n        return build.toString().equals(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770175,
                "title": "javascript-easy-accepted-solution-100-faster-runtime-56-ms",
                "content": "![image](https://assets.leetcode.com/users/images/fb90c4d2-8d24-4d57-952c-af2076d11244_1644827795.4958742.png)\\n\\n```\\nvar isPrefixString = function(s, words) {\\n    let w = \"\";\\n    for (let i = 0; i < words.length; i++) {\\n        w += words[i];\\n        if(s === w){\\n            return true;\\n        }\\n    }\\n    return false;\\n};",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/fb90c4d2-8d24-4d57-952c-af2076d11244_1644827795.4958742.png)\\n\\n```\\nvar isPrefixString = function(s, words) {\\n    let w = \"\";\\n    for (let i = 0; i < words.length; i++) {\\n        w += words[i];\\n        if(s === w){\\n            return true;\\n        }\\n    }\\n    return false;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1766438,
                "title": "go-solution-100-space-and-time",
                "content": "```\\nfunc isPrefixString(s string, words []string) bool {\\n  pos := 0 // holds the position in string s\\n  for i := 0; i < len(words) && pos < len(s); i++ {\\n    // If the next prefix word is bigger than the remaining characters, it is not a prefix\\n    if len(s)-pos < len(words[i]) {\\n      return false\\n    }\\n    for j := 0; j < len(words[i]) && pos < len(s); j++ {\\n      if s[pos] != words[i][j] {\\n        return false\\n      }\\n      pos++\\n    }\\n  }\\n  return pos == len(s)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isPrefixString(s string, words []string) bool {\\n  pos := 0 // holds the position in string s\\n  for i := 0; i < len(words) && pos < len(s); i++ {\\n    // If the next prefix word is bigger than the remaining characters, it is not a prefix\\n    if len(s)-pos < len(words[i]) {\\n      return false\\n    }\\n    for j := 0; j < len(words[i]) && pos < len(s); j++ {\\n      if s[pos] != words[i][j] {\\n        return false\\n      }\\n      pos++\\n    }\\n  }\\n  return pos == len(s)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1401926,
                "title": "java-linear-explained",
                "content": "Keep pointer of where we are in String, check each word and for each word check characters in word and in the string by moving pointers in both. On first mismatch return false\\nCatch:\\n- check if with next word we are not going over the string\\n\\nO(len(s)) time - scan every char in string at max\\nO(1) space - using just few variables to keep state\\n\\n```\\n    public boolean isPrefixString(String s, String[] words) {\\n        int sPointer = 0;\\n        for (String word : words) {\\n            if (s.length() - sPointer < word.length()) {\\n                return false;\\n            }\\n            for (int i = 0; i < word.length(); i++) {\\n                if (s.charAt(sPointer++) != word.charAt(i)) {\\n                    return false;\\n                }\\n            }\\n            if (sPointer >= s.length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public boolean isPrefixString(String s, String[] words) {\\n        int sPointer = 0;\\n        for (String word : words) {\\n            if (s.length() - sPointer < word.length()) {\\n                return false;\\n            }\\n            for (int i = 0; i < word.length(); i++) {\\n                if (s.charAt(sPointer++) != word.charAt(i)) {\\n                    return false;\\n                }\\n            }\\n            if (sPointer >= s.length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392365,
                "title": "java-easy-solution-using-stringbuilder-beats-66",
                "content": "```\\nclass Solution { \\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < words.length; i++) {\\n            sb.append(words[i]);\\n            if (sb.toString().equals(s)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution { \\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < words.length; i++) {\\n            sb.append(words[i]);\\n            if (sb.toString().equals(s)) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1392339,
                "title": "easy-to-understand-c-runtime-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        bool sIsPrefixString = false;\\n        int numberOfWords = words.size();\\n        int sLength = s.length(), sIterator = 0, sRemaining = s.length();\\n        \\n        for (int i = 0; i < numberOfWords; i++)\\n        {\\n            string word = words[i];\\n            int wordSize = word.size();\\n            \\n\\t\\t\\t// first check if word is smaller than remaining string or not\\n            if (wordSize > sRemaining)\\n                return false;\\n            \\n            for (int j = 0; j < wordSize; j++)\\n            {\\n                sRemaining--;\\n                if (s[sIterator++] != word[j])\\n                    return false;\\n            }\\n            \\n\\t\\t\\t// if last word extinguished the string\\n            if (sRemaining == 0)\\n                return true;\\n        }        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        bool sIsPrefixString = false;\\n        int numberOfWords = words.size();\\n        int sLength = s.length(), sIterator = 0, sRemaining = s.length();\\n        \\n        for (int i = 0; i < numberOfWords; i++)\\n        {\\n            string word = words[i];\\n            int wordSize = word.size();\\n            \\n\\t\\t\\t// first check if word is smaller than remaining string or not\\n            if (wordSize > sRemaining)\\n                return false;\\n            \\n            for (int j = 0; j < wordSize; j++)\\n            {\\n                sRemaining--;\\n                if (s[sIterator++] != word[j])\\n                    return false;\\n            }\\n            \\n\\t\\t\\t// if last word extinguished the string\\n            if (sRemaining == 0)\\n                return true;\\n        }        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390370,
                "title": "prefix-string-o-n",
                "content": "```\\n// n = words.length\\n// Time: O(n)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& arr)\\n\\t{\\n        int n = arr.size() ;\\n        vector<string> prefix(n,\"\");\\n        prefix[0]=arr[0];\\n     \\n        for(int i=1;i<n;i++)\\n            prefix[i]=prefix[i-1]+arr[i];\\n        \\n        for(int i=0;i<n;i++) {\\n            if(prefix[i]==s)  return 1 ;\\n        }\\n        return 0 ;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n// n = words.length\\n// Time: O(n)\\n// Space: O(1)\\n\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& arr)\\n\\t{\\n        int n = arr.size() ;\\n        vector<string> prefix(n,\"\");\\n        prefix[0]=arr[0];\\n     \\n        for(int i=1;i<n;i++)\\n            prefix[i]=prefix[i-1]+arr[i];\\n        \\n        for(int i=0;i<n;i++) {\\n            if(prefix[i]==s)  return 1 ;\\n        }\\n        return 0 ;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390285,
                "title": "5-liner-solution-self-explanatory-c",
                "content": "```\\nbool isPrefixString(string s, vector<string>& words) {\\n        string a=\"\";\\n        if(s==\"\")return true;\\n        for(int i=0;i<words.size();i++){\\n            a+=words[i];\\n            if(a==s)return true;\\n            if(a.size()>s.size())return false;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPrefixString(string s, vector<string>& words) {\\n        string a=\"\";\\n        if(s==\"\")return true;\\n        for(int i=0;i<words.size();i++){\\n            a+=words[i];\\n            if(a==s)return true;\\n            if(a.size()>s.size())return false;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390284,
                "title": "simplest-c-solution",
                "content": "```\\nbool isPrefixString(string s, vector<string>& words) {\\n        int n=words.size();\\n        string str=\"\";\\n        for(int i=0;i<n;i++){\\n            str+=words[i];\\n            if(s==str)\\n                return true;\\n        }\\n        return false;\\n    }\\n```\\nTime complexity: O(n)\\nSpace complexity : O(n)",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nbool isPrefixString(string s, vector<string>& words) {\\n        int n=words.size();\\n        string str=\"\";\\n        for(int i=0;i<n;i++){\\n            str+=words[i];\\n            if(s==str)\\n                return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390233,
                "title": "c-1961-check-if-string-is-a-prefix-of-array",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i = 0; \\n        for (auto& word : words) {\\n            if (s.substr(i, word.size()) != word) return false; \\n            i += word.size(); \\n            if (i == s.size()) return true; \\n        }\\n        return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i = 0; \\n        for (auto& word : words) {\\n            if (s.substr(i, word.size()) != word) return false; \\n            i += word.size(); \\n            if (i == s.size()) return true; \\n        }\\n        return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390195,
                "title": "java-o-n-space-o-1",
                "content": "```\\npublic boolean isPrefixString(String s, String[] words) {\\n\\tfor(int i=0, k=0;k<words.length;k++) {\\n\\t\\tfor(int j =0;j<words[k].length();j++,i++)\\n\\t\\t\\tif(i == s.length() || words[k].charAt(j) !=s.charAt(i)) return false;\\n\\t\\tif(i == s.length()) return true;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isPrefixString(String s, String[] words) {\\n\\tfor(int i=0, k=0;k<words.length;k++) {\\n\\t\\tfor(int j =0;j<words[k].length();j++,i++)\\n\\t\\t\\tif(i == s.length() || words[k].charAt(j) !=s.charAt(i)) return false;\\n\\t\\tif(i == s.length()) return true;\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390156,
                "title": "a-few-solutions",
                "content": "Perform a linear scan of each `i`<sup>th</sup> character of the input string `s` while simultaneously traversing each `k`<sup>th</sup> word\\'s `j`<sup>th</sup> chactacter for each `k`<sup>th</sup> word of the input array `A`.  Return `true` if and only if the string `s` was fully traversed at the end of at least `k = 1` words.\\n\\n---\\n   \\n*Kotlin*\\n```\\nclass Solution {\\n    fun isPrefixString(s: String, A: Array<String>): Boolean {\\n        var (i, j, k) = listOf(0, 0, 0)\\n        while (i < s.length && k < A.size && s[i] == A[k][j]) {\\n            ++i; ++j\\n            if (j == A[k].length) {\\n                j = 0; ++k\\n            }\\n        }\\n        return i == s.length && j == 0 && 0 < k\\n    }\\n}\\n```\\n    \\n*Javascript*\\n```\\nlet isPrefixString = (s, A) => {\\n    let [i, j, k] = [0, 0, 0];\\n    while (i < s.length && k < A.length && s[i] == A[k][j]) {\\n        ++i, ++j;\\n        if (j == A[k].length)\\n            j = 0, ++k;\\n    }\\n    return i == s.length && !j && k;\\n};\\n```\\n    \\n*Python3*\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, A: List[str]) -> bool:\\n        i, j, k = 0, 0, 0\\n        while i < len(s) and k < len(A) and s[i] == A[k][j]:\\n            i += 1; j += 1\\n            if j == len(A[k]):\\n                j = 0; k += 1\\n        return i == len(s) and not j and k\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    bool isPrefixString(string s, VS& A) {\\n        auto i = 0,\\n             j = 0,\\n             k = 0;\\n        while (i < s.size() && k < A.size() && s[i] == A[k][j]) {\\n            ++i, ++j;\\n            if (j == A[k].size())\\n                j = 0, ++k;\\n        }\\n        return i == s.size() && !j && k;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun isPrefixString(s: String, A: Array<String>): Boolean {\\n        var (i, j, k) = listOf(0, 0, 0)\\n        while (i < s.length && k < A.size && s[i] == A[k][j]) {\\n            ++i; ++j\\n            if (j == A[k].length) {\\n                j = 0; ++k\\n            }\\n        }\\n        return i == s.length && j == 0 && 0 < k\\n    }\\n}\\n```\n```\\nlet isPrefixString = (s, A) => {\\n    let [i, j, k] = [0, 0, 0];\\n    while (i < s.length && k < A.length && s[i] == A[k][j]) {\\n        ++i, ++j;\\n        if (j == A[k].length)\\n            j = 0, ++k;\\n    }\\n    return i == s.length && !j && k;\\n};\\n```\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, A: List[str]) -> bool:\\n        i, j, k = 0, 0, 0\\n        while i < len(s) and k < len(A) and s[i] == A[k][j]:\\n            i += 1; j += 1\\n            if j == len(A[k]):\\n                j = 0; k += 1\\n        return i == len(s) and not j and k\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    bool isPrefixString(string s, VS& A) {\\n        auto i = 0,\\n             j = 0,\\n             k = 0;\\n        while (i < s.size() && k < A.size() && s[i] == A[k][j]) {\\n            ++i, ++j;\\n            if (j == A[k].size())\\n                j = 0, ++k;\\n        }\\n        return i == s.size() && !j && k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835050,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        \\n        string str = \"\";\\n        for(int i=0; i<words.size(); i++){\\n            str += words[i];\\n            if(str == s){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        \\n        string str = \"\";\\n        for(int i=0; i<words.size(); i++){\\n            str += words[i];\\n            if(str == s){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794132,
                "title": "brute-force-approach-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nADD and CHECK formula\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.) Simply make a empty string named = prefix;\\n2.) simply iterate through the string words and start pushing the strings that you encounter;\\n3.) similarly check whether it is equal to the string (s);\\n4.) If it is equal then return true\\n5.) also check if the length of prefix exceeds the length of the string (s) because if it is then the string is not the prefix,simply return false.\\n\\nHope you Understood!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string prefix  = \"\";\\n        for(int i=0;i<words.size();i++){\\n            prefix += words[i];\\n            if(prefix == s){\\n                return true;\\n            }\\n            else if(prefix.length() > s.length()){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string prefix  = \"\";\\n        for(int i=0;i<words.size();i++){\\n            prefix += words[i];\\n            if(prefix == s){\\n                return true;\\n            }\\n            else if(prefix.length() > s.length()){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504054,
                "title": "javascript-easy-to-understand-simple-solution-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe can iterate the `words` array and start building a string with the words in it in order. Each time we add a new word to our string, we compare it to `s`, and if they\\'re the same, we return true. If, at the end of the iteration, the strings don\\'t match, we return false.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n    let compareStr = \\'\\';\\n\\n    for (let i = 0; i < words.length; i++) {\\n        compareStr = compareStr + words[i];\\n        if (compareStr === s) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n    let compareStr = \\'\\';\\n\\n    for (let i = 0; i < words.length; i++) {\\n        compareStr = compareStr + words[i];\\n        if (compareStr === s) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450420,
                "title": "100-beginner-solution-easy-to-understand",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        add to string t and then check if it matches with String s \\n        then return true and return false after completing \\n        the whole addition of word present in words\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        \\n    StringBuilder t=new StringBuilder();\\n\\n    for(String word: words){\\n         t.append(word);\\n        if(s.equals(t.toString())) return true;\\n           \\n        \\n    }\\n    return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        \\n    StringBuilder t=new StringBuilder();\\n\\n    for(String word: words){\\n         t.append(word);\\n        if(s.equals(t.toString())) return true;\\n           \\n        \\n    }\\n    return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130014,
                "title": "j",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String st=\"\";\\n        for(int i=0;i<words.length;i++){\\n            if(s.indexOf(words[i])==-1){\\n                return false;\\n            }\\n            st+=words[i];\\n            if(s.equals(st)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String st=\"\";\\n        for(int i=0;i<words.length;i++){\\n            if(s.indexOf(words[i])==-1){\\n                return false;\\n            }\\n            st+=words[i];\\n            if(s.equals(st)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056907,
                "title": "1961-java-2-approach",
                "content": "# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Runtime : 1 ms\\n- Beats : 94.20%\\n- Memory : 41.8 MB\\n- Beats : 92.70%\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        for(String s1 : words){\\n            if(s.length() == 0) return true;\\n            if(s.indexOf(s1) == 0) s = s.substring(s1.length());\\n            else return false;\\n        }\\n        return s.length() > 0? false : true;\\n    }\\n}\\n```\\n# Approach 2\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Runtime : 1 ms\\n- Beats : 94.20%\\n- Memory : 42.2 MB\\n- Beats : 78.44%\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String temp = \"\";\\n        for(String s1 : words){\\n            temp += s1;\\n            if(temp.length() == s.length()){\\n                if(temp.equals(s))return true;\\n                return false;\\n            }\\n            else if(temp.length() > s.length()) return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        for(String s1 : words){\\n            if(s.length() == 0) return true;\\n            if(s.indexOf(s1) == 0) s = s.substring(s1.length());\\n            else return false;\\n        }\\n        return s.length() > 0? false : true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String temp = \"\";\\n        for(String s1 : words){\\n            temp += s1;\\n            if(temp.length() == s.length()){\\n                if(temp.equals(s))return true;\\n                return false;\\n            }\\n            else if(temp.length() > s.length()) return false;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979379,
                "title": "check-if-string-is-a-prefix-of-array-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int length = s.length();\\n        int arrLength = words.length;\\n        int index = 0;\\n        for (int i = 0; i < arrLength && index < length; i++) {\\n            String word = words[i];\\n            int wordLength = word.length();\\n            int j = 0;\\n            while (j < wordLength && index < length) {\\n                if (s.charAt(index) == word.charAt(j)) {\\n                    index++;\\n                    j++;\\n                } else\\n                    return false;\\n            }\\n            if (index == length && j < wordLength)\\n                return false;\\n        }\\n        return index == length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int length = s.length();\\n        int arrLength = words.length;\\n        int index = 0;\\n        for (int i = 0; i < arrLength && index < length; i++) {\\n            String word = words[i];\\n            int wordLength = word.length();\\n            int j = 0;\\n            while (j < wordLength && index < length) {\\n                if (s.charAt(index) == word.charAt(j)) {\\n                    index++;\\n                    j++;\\n                } else\\n                    return false;\\n            }\\n            if (index == length && j < wordLength)\\n                return false;\\n        }\\n        return index == length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845747,
                "title": "java-simple-approach-using-stringbuilder",
                "content": "\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder res = new StringBuilder (\"\");\\n        for(String w : words){\\n            res.append (w);\\n            if(s.equals(res.toString())) return true;\\n        }\\n        return false;\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder res = new StringBuilder (\"\");\\n        for(String w : words){\\n            res.append (w);\\n            if(s.equals(res.toString())) return true;\\n        }\\n        return false;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2705482,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) \\n    {\\n       int sidx=0;\\n       for(int i=0;i<words.size();i++)\\n       {\\n          string currstr = words[i];\\n          int temp=0;\\n\\n          while(sidx<s.length() and temp<currstr.length())\\n          {\\n              if(s[sidx]!=currstr[temp])\\n              {\\n                return false;\\n              }\\n              sidx++;\\n              temp++; \\t\\n          }\\t\\n          if(sidx>=s.length() and temp>=currstr.length())\\n          return true;\\n          else if(sidx>=s.length() and temp<currstr.length())\\n          return false;\\n       }\\n       if(sidx >= s.length())\\n       return true;\\n        \\n       return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) \\n    {\\n       int sidx=0;\\n       for(int i=0;i<words.size();i++)\\n       {\\n          string currstr = words[i];\\n          int temp=0;\\n\\n          while(sidx<s.length() and temp<currstr.length())\\n          {\\n              if(s[sidx]!=currstr[temp])\\n              {\\n                return false;\\n              }\\n              sidx++;\\n              temp++; \\t\\n          }\\t\\n          if(sidx>=s.length() and temp>=currstr.length())\\n          return true;\\n          else if(sidx>=s.length() and temp<currstr.length())\\n          return false;\\n       }\\n       if(sidx >= s.length())\\n       return true;\\n        \\n       return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672534,
                "title": "java-stringbuilder-easy",
                "content": "### Please Upvote :D\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < words.length && sb.length() < s.length(); i++) {\\n            sb.append(words[i]);\\n        }\\n        \\n        return s.equals(sb.toString());\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        for (int i = 0; i < words.length && sb.length() < s.length(); i++) {\\n            sb.append(words[i]);\\n        }\\n        \\n        return s.equals(sb.toString());\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618824,
                "title": "c-solution-in-linear-complexity",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string p;\\n        for(int i=0;i<words.size();i++){\\n            p+=words[i];\\n             if(p==s)\\n            return true ;\\n        }\\n        return false;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string p;\\n        for(int i=0;i<words.size();i++){\\n            p+=words[i];\\n             if(p==s)\\n            return true ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2559144,
                "title": "simple-java-string-solution",
                "content": "We need to basically check whether the given string in words array starts with the prefix string or not. If not, we need to keep appending the next strings in words array and check the same condition again.\\n\\n\\nThe edge case would be a prefix string like \"a\" and words array as [\"aa\",\"aaaa\",\"banana\"] where we need to check the prefix string has atleast the length of the words.\\n\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for (String str : words) {\\n            sb.append(str);\\n            if (sb.toString().startsWith(s) && s.length()>=sb.toString().length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for (String str : words) {\\n            sb.append(str);\\n            if (sb.toString().startsWith(s) && s.length()>=sb.toString().length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448622,
                "title": "check-if-string-is-a-prefix-of-array-java-simple",
                "content": "4ms solution\\uD83D\\uDC47\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String res=\"\";\\n        for(int i=0;i<words.length;i++)\\n        {\\n            res=res+words[i];\\n            \\n            if(s.equals(res))\\n                return true;\\n            \\n            else\\n                continue;\\n            \\n        }\\n        \\n        return false;\\n        \\n        \\n        \\n    }\\n}\\n```\\n3 ms Solution\\uD83D\\uDC47\\n\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String res=\"\";\\n        for(int i=0;i<words.length&&!(s.equals(res));i++)\\n        {\\n            res=res+words[i];\\n\\n        }\\n\\n\\n        if(res.length()>s.length() || res.length()<s.length())\\n            return false;\\n\\n        else if(res.length()==s.length())\\n        {\\n            if(s.equals(res)==false)\\n                return false;\\n        }\\n\\n        return true;\\n\\n\\n\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String res=\"\";\\n        for(int i=0;i<words.length;i++)\\n        {\\n            res=res+words[i];\\n            \\n            if(s.equals(res))\\n                return true;\\n            \\n            else\\n                continue;\\n            \\n        }\\n        \\n        return false;\\n        \\n        \\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String res=\"\";\\n        for(int i=0;i<words.length&&!(s.equals(res));i++)\\n        {\\n            res=res+words[i];\\n\\n        }\\n\\n\\n        if(res.length()>s.length() || res.length()<s.length())\\n            return false;\\n\\n        else if(res.length()==s.length())\\n        {\\n            if(s.equals(res)==false)\\n                return false;\\n        }\\n\\n        return true;\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415849,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public bool IsPrefixString(string s, string[] words) \\n    {\\n        for (int i= words.Length-1; i>=0; i--)\\n        {\\n\\t\\t\\tif (s == String.Join(\"\", string.Join(\"\", words.Take(i+1).ToArray())))\\n            {\\n                return true;\\n            }\\n        }\\n\\n        return false;    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsPrefixString(string s, string[] words) \\n    {\\n        for (int i= words.Length-1; i>=0; i--)\\n        {\\n\\t\\t\\tif (s == String.Join(\"\", string.Join(\"\", words.Take(i+1).ToArray())))\\n            {\\n                return true;\\n            }\\n        }\\n\\n        return false;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339750,
                "title": "python-greedy-o-n",
                "content": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        cur_idx = 0\\n        for w in words:\\n            if s.startswith(w, cur_idx):\\n                cur_idx += len(w)\\n            else:\\n                break\\n            if cur_idx == len(s): return True\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        cur_idx = 0\\n        for w in words:\\n            if s.startswith(w, cur_idx):\\n                cur_idx += len(w)\\n            else:\\n                break\\n            if cur_idx == len(s): return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 2328982,
                "title": "check-if-string-is-a-prefix-of-array-with-python",
                "content": "\\tclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        text = \"\"\\n        for i in range(len(words)):\\n            text += words[i]\\n            if text == s:\\n                return True\\n        return False",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        text = \"\"\\n        for i in range(len(words)):\\n            text += words[i]\\n            if text == s:\\n                return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 2324003,
                "title": "kotlin",
                "content": "```\\nfun isPrefixString(s: String, words: Array<String>): Boolean {\\n    words.fold(\"\") { acc, string ->\\n        val sum = acc + string\\n        if (sum == s) return true else sum\\n    }\\n    return false\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfun isPrefixString(s: String, words: Array<String>): Boolean {\\n    words.fold(\"\") { acc, string ->\\n        val sum = acc + string\\n        if (sum == s) return true else sum\\n    }\\n    return false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2253922,
                "title": "c-string-concatenation-3-line-code",
                "content": "![image](https://assets.leetcode.com/users/images/cdc6215d-6f90-41be-b7b9-1d61cb65e1a8_1657266608.746967.png)\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isPrefixString(string s, vector<string>& words) {\\n\\t\\t\\tstring str=\"\";\\n\\t\\t\\tfor(int i=0;i<words.size();i++){\\n\\t\\t\\t\\tstr+=words[i];\\n\\t\\t\\t\\tif(s==str)return true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isPrefixString(string s, vector<string>& words) {\\n\\t\\t\\tstring str=\"\";\\n\\t\\t\\tfor(int i=0;i<words.size();i++){\\n\\t\\t\\t\\tstr+=words[i];\\n\\t\\t\\t\\tif(s==str)return true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2143639,
                "title": "c-easy-traversal",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n       string ans=\"\";\\n        map<string,int>harsh;\\n        harsh[s]++;\\n        for(auto val : words )\\n        {\\n            ans+=val;\\n            if(harsh.find(ans) != harsh.end())\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n       string ans=\"\";\\n        map<string,int>harsh;\\n        harsh[s]++;\\n        for(auto val : words )\\n        {\\n            ans+=val;\\n            if(harsh.find(ans) != harsh.end())\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966796,
                "title": "python-one-line",
                "content": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        return any([s == \\'\\'.join(words[:i]) for i in range(len(words)+1)])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        return any([s == \\'\\'.join(words[:i]) for i in range(len(words)+1)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959466,
                "title": "java-100-pointer-and-indexof",
                "content": "Using String.indexOf\\n\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int index=0;\\n        for(String w:words){\\n            int index2=s.indexOf(w,index);\\n            if(index2!=index){\\n                return false;\\n            }\\n            index+=w.length();\\n            if(index==s.length()){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n\\nUsing pointer\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int index=0;\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(j==words[index].length()){\\n                index++;\\n                j=0;\\n            }\\n            if(index==words.length){\\n                return false;\\n            }\\n            if(s.charAt(i)!=words[index].charAt(j++)){\\n                return false;\\n            }\\n        }\\n        return words[index].length()==j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int index=0;\\n        for(String w:words){\\n            int index2=s.indexOf(w,index);\\n            if(index2!=index){\\n                return false;\\n            }\\n            index+=w.length();\\n            if(index==s.length()){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int index=0;\\n        int j=0;\\n        for(int i=0;i<s.length();i++){\\n            if(j==words[index].length()){\\n                index++;\\n                j=0;\\n            }\\n            if(index==words.length){\\n                return false;\\n            }\\n            if(s.charAt(i)!=words[index].charAt(j++)){\\n                return false;\\n            }\\n        }\\n        return words[index].length()==j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953215,
                "title": "simple-python-solution-faster-than-91-76",
                "content": "```\\ndef isPrefixString(self, s, words):\\n\\ttester = []\\n\\tfor w in words :\\n\\t\\ttester.append(w)\\n\\t\\tif \"\".join(tester) == s :\\n\\t\\t\\treturn True\\n\\treturn False\\n```",
                "solutionTags": [],
                "code": "```\\ndef isPrefixString(self, s, words):\\n\\ttester = []\\n\\tfor w in words :\\n\\t\\ttester.append(w)\\n\\t\\tif \"\".join(tester) == s :\\n\\t\\t\\treturn True\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1931666,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int j=0;\\n        for(int i=0;i<words.length&&j<s.length();i++)\\n        {\\n            if(j+words[i].length()>s.length())\\n                return false;\\n            if(!s.substring(j,j+words[i].length()).equals(words[i]))\\n                return false;\\n            j+=words[i].length();\\n        }\\n        if(j<s.length())\\n            return false;\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int j=0;\\n        for(int i=0;i<words.length&&j<s.length();i++)\\n        {\\n            if(j+words[i].length()>s.length())\\n                return false;\\n            if(!s.substring(j,j+words[i].length()).equals(words[i]))\\n                return false;\\n            j+=words[i].length();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1866923,
                "title": "java-using-stringbuilder",
                "content": "```\\npublic boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb=new StringBuilder();\\n     for(String str:words){\\n         sb.append(str);\\n         if(sb.toString().equals(s))\\n             return true;\\n     }   \\n        return false;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\npublic boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb=new StringBuilder();\\n     for(String str:words){\\n         sb.append(str);\\n         if(sb.toString().equals(s))\\n             return true;\\n     }   \\n        return false;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1827253,
                "title": "easy-c-solution-using-vector",
                "content": "```\\nbool isPrefixString(string s, vector<string>& w) {\\n        vector<string> v;\\n        int k=0,fl=0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            int q=w[i].length();\\n            fl+=w[i].length();\\n            if(k<s.length())\\n            {\\n                string x;\\n                int r=0;\\n                while(k<s.length() && r<q )\\n                {\\n                    x+=s[k];\\n                    k++;\\n                    r++;\\n                }\\n                v.push_back(x);\\n            }\\n        }\\n        if(fl<s.length())\\n            return false;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i]!=w[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool isPrefixString(string s, vector<string>& w) {\\n        vector<string> v;\\n        int k=0,fl=0;\\n        for(int i=0;i<w.size();i++)\\n        {\\n            int q=w[i].length();\\n            fl+=w[i].length();\\n            if(k<s.length())\\n            {\\n                string x;\\n                int r=0;\\n                while(k<s.length() && r<q )\\n                {\\n                    x+=s[k];\\n                    k++;\\n                    r++;\\n                }\\n                v.push_back(x);\\n            }\\n        }\\n        if(fl<s.length())\\n            return false;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i]!=w[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1739796,
                "title": "python-add-up-words-to-s",
                "content": "Add up the word in words till we get s, if we can\\'t get s, return False\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        sentence = \\'\\'\\n        for word in words:\\n            sentence += word\\n            if sentence == s:\\n                return True\\n        return False",
                "solutionTags": [],
                "code": "Add up the word in words till we get s, if we can\\'t get s, return False\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        sentence = \\'\\'\\n        for word in words:\\n            sentence += word\\n            if sentence == s:\\n                return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1647589,
                "title": "java-efficient-soultion",
                "content": "int i=0;\\n        for(String word: words)\\n        {\\n            if(s.startsWith(word,i))\\n                i+=word.length();\\n            else\\n                return false;\\n            if(i==s.length())\\n                return true;\\n        }\\n        return i==s.length();\\n    }\\n}\\n// this is another solution\\n// StringBuffer sb=new StringBuffer();\\n//         for(int i=0;i<words.length;i++)\\n//         {\\n//             sb.append(words[i]);\\n//             if(sb.toString().equals(s))\\n//                 return true;\\n//         }\\n//         return false;",
                "solutionTags": [
                    "Java"
                ],
                "code": "int i=0;\\n        for(String word: words)\\n        {\\n            if(s.startsWith(word,i))\\n                i+=word.length();\\n            else\\n                return false;\\n            if(i==s.length())\\n                return true;\\n        }\\n        return i==s.length();\\n    }\\n}\\n// this is another solution\\n// StringBuffer sb=new StringBuffer();\\n//         for(int i=0;i<words.length;i++)\\n//         {\\n//             sb.append(words[i]);\\n//             if(sb.toString().equals(s))\\n//                 return true;\\n//         }\\n//         return false;",
                "codeTag": "Unknown"
            },
            {
                "id": 1625729,
                "title": "java-100-faster-simple-length-check-with-startswith-string-function",
                "content": "```\\npublic boolean isPrefixString(String s, String[] words) {\\n        int i=0;\\n        for(String word : words){\\n            if(s.startsWith(word,i)){\\n                i+=word.length();\\n            }else{\\n                return false;\\n            }\\n            if(i==s.length()) return true;\\n        }\\n        return i==s.length();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isPrefixString(String s, String[] words) {\\n        int i=0;\\n        for(String word : words){\\n            if(s.startsWith(word,i)){\\n                i+=word.length();\\n            }else{\\n                return false;\\n            }\\n            if(i==s.length()) return true;\\n        }\\n        return i==s.length();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1624335,
                "title": "2-line-0ms-100-faster-than-c-easy-clean-explained",
                "content": "**C++ solutions :**\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& w) {\\n        string str;\\n        for(auto &i:w)\\n        {\\n            str+=i;\\n            if(str==s) return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n**if you like this solutions , please upvote for me\\nany doubt ---> comment \\nThank you .**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& w) {\\n        string str;\\n        for(auto &i:w)\\n        {\\n            str+=i;\\n            if(str==s) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550291,
                "title": "runtime-1-ms-faster-than-96-31-of-java",
                "content": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String s1 = \"\";\\n        for(int i = 0;i<words.length;i++){\\n            s1 += String.valueOf(words[i]);\\n            if(s1.equals(s)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String s1 = \"\";\\n        for(int i = 0;i<words.length;i++){\\n            s1 += String.valueOf(words[i]);\\n            if(s1.equals(s)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520120,
                "title": "c-1-liner-stl-accumulate",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n            if(accumulate(words.begin(),words.begin()+i+1,string(\"\"))==s)return true;\\n        return false;\\n    }\\n};\\n```\\nAccumulate will sum up each element to 3rd parameter. For the case of strings, it will do the concatenation operation.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n            if(accumulate(words.begin(),words.begin()+i+1,string(\"\"))==s)return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472678,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function (s, words) {\\n  const result = [];\\n\\n  for (const word of words) {\\n    result.push(word);\\n    if (result.join(\"\") === s) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function (s, words) {\\n  const result = [];\\n\\n  for (const word of words) {\\n    result.push(word);\\n    if (result.join(\"\") === s) {\\n      return true;\\n    }\\n  }\\n\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461826,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String str = \"\";\\n        \\n        for(int i=0;i<words.length; i++){\\n            str += words[i];\\n            if(str.equals(s))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String str = \"\";\\n        \\n        for(int i=0;i<words.length; i++){\\n            str += words[i];\\n            if(str.equals(s))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447305,
                "title": "c-simple-solution-with-explanation",
                "content": "\"just loop through array and take a empty string,\\nadd words to string if at any point size of our empty string is equal to given string and both are also same then we return TRUE,\\notherwise if at any moment our empty string size is greater than given string we can return immediately FALSE. \"\\n\\t\\n\\there is my code :\\n\\t\\n\\t\\n\\tbool isPrefixString(string s, vector<string>& words) {\\n        \\n        int n = words.size();\\n        string ss=\"\"; // our empty string\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ss+=words[i]; // adding words to string\\n            \\n            if(ss.size() == s.size() and ss == s) return true; // as mentioned above\\n            else if(ss.size() > s.size()) return false; \\n        }\\n        return false;\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "\"just loop through array and take a empty string,\\nadd words to string if at any point size of our empty string is equal to given string and both are also same then we return TRUE,\\notherwise if at any moment our empty string size is greater than given string we can return immediately FALSE. \"\\n\\t\\n\\there is my code :\\n\\t\\n\\t\\n\\tbool isPrefixString(string s, vector<string>& words) {\\n        \\n        int n = words.size();\\n        string ss=\"\"; // our empty string\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ss+=words[i]; // adding words to string\\n            \\n            if(ss.size() == s.size() and ss == s) return true; // as mentioned above\\n            else if(ss.size() > s.size()) return false; \\n        }\\n        return false;\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1445993,
                "title": "fast-concise-scala-solution",
                "content": "String `s` is a prefix string if its length is in the prefix lengths and the first `s.length` characters of the flattened iterator of `words` has the same elements as the characters in `s.iterator`.\\n\\n```Scala\\nobject Solution {\\n    def isPrefixString(s: String, words: Array[String]): Boolean = {\\n        words.scanLeft(0)(_ + _.length).drop(1).contains(s.length) &&\\n            words.iterator.flatMap(_.toIterator).take(s.length).sameElements(s.iterator)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Scala\\nobject Solution {\\n    def isPrefixString(s: String, words: Array[String]): Boolean = {\\n        words.scanLeft(0)(_ + _.length).drop(1).contains(s.length) &&\\n            words.iterator.flatMap(_.toIterator).take(s.length).sameElements(s.iterator)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1439729,
                "title": "himesh",
                "content": "class Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        x = \\'\\'\\n        for i in words :\\n            x += i\\n            if x == s :\\n                return True\\n            if len(x) > len(s) : \\n                return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        x = \\'\\'\\n        for i in words :\\n            x += i\\n            if x == s :\\n                return True\\n            if len(x) > len(s) : \\n                return False",
                "codeTag": "Java"
            },
            {
                "id": 1421624,
                "title": "java-o-n-runtime-o-1-space-using-indexof-with-explanation",
                "content": "```\\n// We keep track of the index of given string as we check if the current word in words matches starting from current index of s\\npublic boolean isPrefixString(String s, String[] words) {\\n\\tint sIndex = 0;\\n\\tfor (int i = 0; i < words.length && sIndex < s.length(); i++) {\\n\\t\\t// indexOf(stringToLookFor, startingIndexToLookFrom), if it doesn\\'t map to the starting point it\\'s not a match\\n\\t\\tif(s.indexOf(words[i], sIndex) != sIndex) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\tsIndex += words[i].length();\\n\\t}    \\n\\n\\t// words might not of had enough words to complete s, \"ilovecoding\", [\"i\",\"love\"]\\n\\t// so check if we ended because sIndex == s.length()\\n\\treturn (sIndex == s.length());\\n}",
                "solutionTags": [],
                "code": "```\\n// We keep track of the index of given string as we check if the current word in words matches starting from current index of s\\npublic boolean isPrefixString(String s, String[] words) {\\n\\tint sIndex = 0;\\n\\tfor (int i = 0; i < words.length && sIndex < s.length(); i++) {\\n\\t\\t// indexOf(stringToLookFor, startingIndexToLookFrom), if it doesn\\'t map to the starting point it\\'s not a match\\n\\t\\tif(s.indexOf(words[i], sIndex) != sIndex) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t\\n\\t\\tsIndex += words[i].length();\\n\\t}    \\n\\n\\t// words might not of had enough words to complete s, \"ilovecoding\", [\"i\",\"love\"]\\n\\t// so check if we ended because sIndex == s.length()\\n\\treturn (sIndex == s.length());\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1416722,
                "title": "runtime-0-ms-faster-than-100-00-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i = 0;\\n        for(auto el : words)\\n        {\\n            if(i == s.size())\\n                break;\\n            if(s.substr(i,el.size()) == el)\\n                i += el.size();\\n            else\\n                return false;\\n            \\n        }\\n        if(i<s.size())\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i = 0;\\n        for(auto el : words)\\n        {\\n            if(i == s.size())\\n                break;\\n            if(s.substr(i,el.size()) == el)\\n                i += el.size();\\n            else\\n                return false;\\n            \\n        }\\n        if(i<s.size())\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403347,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        \\n        x = \\'\\'\\n        for i in words :\\n            x += i\\n            if x == s : return True\\n            if len(x) > len(s) : return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        \\n        x = \\'\\'\\n        for i in words :\\n            x += i\\n            if x == s : return True\\n            if len(x) > len(s) : return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403184,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string ans=\"\";\\n        for(int i=0;i<words.size();i++)\\n        {\\n            ans=ans+words[i];\\n            if(ans.length()!=s.length())\\n            {\\n                continue;\\n            }\\n            else{\\n                break;\\n            }\\n            \\n            \\n        }\\n        if(ans==s)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string ans=\"\";\\n        for(int i=0;i<words.size();i++)\\n        {\\n            ans=ans+words[i];\\n            if(ans.length()!=s.length())\\n            {\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1402845,
                "title": "straightforward-o-n-approach",
                "content": "The idea is simple: Traverse the list and concat to the string `prefix` and check if it is the same as string `s`. If the length of `prefix` is greater than that of `s`, return `False`.\\nTime Complexity: O(n)\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        prefix = \"\"\\n        n = len(s)\\n        for w in words:\\n            prefix+=w\\n            if(prefix==s):\\n                return True\\n            elif(len(prefix)>n):\\n                return False\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        prefix = \"\"\\n        n = len(s)\\n        for w in words:\\n            prefix+=w\\n            if(prefix==s):\\n                return True\\n            elif(len(prefix)>n):\\n                return False\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400451,
                "title": "c-o-n",
                "content": "Runtime: 76 ms, faster than 100.00% of C# online submissions for Check If String Is a Prefix of Array.\\n```\\npublic class Solution {\\n    public bool IsPrefixString(string s, string[] words) {\\n        StringBuilder sb = new StringBuilder();\\n            \\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            sb.Append(words[i]);\\n            if(s==sb.ToString())\\n                return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public bool IsPrefixString(string s, string[] words) {\\n        StringBuilder sb = new StringBuilder();\\n            \\n        for(int i = 0; i < words.Length; i++)\\n        {\\n            sb.Append(words[i]);\\n            if(s==sb.ToString())\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1397819,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public boolean isPrefixString(String s, String[] w) {\\n        int i=0,k=s.length(),l=0;\\n        String p=\"\";\\n        while(l!=k&&i<w.length)\\n        {\\n            l=l+w[i].length();\\n            p=p+w[i];\\n            i++;\\n        }\\n        System.out.println(p);\\n        return p.equals(s) ? true : false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean isPrefixString(String s, String[] w) {\\n        int i=0,k=s.length(),l=0;\\n        String p=\"\";\\n        while(l!=k&&i<w.length)\\n        {\\n            l=l+w[i].length();\\n            p=p+w[i];\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1397000,
                "title": "easy-python-solution-faster-than-98",
                "content": "# Easy Python Solution | Faster than 98%\\n**Runtime: 28 ms, faster than 98% of Python3 online submissions for Check If String Is a Prefix of Array.\\nMemory Usage: 14.2 MB**\\n\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        for word in words:\\n            if s:\\n                if s.startswith(word):\\n                    s = s[len(word):]\\n                else:\\n                    return False\\n\\n        if not s:\\n\\t\\t    # for the case when len(s) > len(len(words[0])......len(words[n-1])\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        for word in words:\\n            if s:\\n                if s.startswith(word):\\n                    s = s[len(word):]\\n                else:\\n                    return False\\n\\n        if not s:\\n\\t\\t    # for the case when len(s) > len(len(words[0])......len(words[n-1])\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395782,
                "title": "java-faster-than-100-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean isPrefixString(String s, String[] words) {\\n\\t\\t\\tint n = s.length(),n1 = words.length;\\n\\t\\t\\tString temp = \"\";\\n\\t\\t\\tfor(int i=0;i<n1;i++){\\n\\t\\t\\t\\ttemp+=words[i];\\n\\t\\t\\t\\tif(temp.length()==n) return s.equals(temp);\\n\\t\\t\\t}\\n\\t\\t\\treturn s.equals(temp);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean isPrefixString(String s, String[] words) {\\n\\t\\t\\tint n = s.length(),n1 = words.length;\\n\\t\\t\\tString temp = \"\";\\n\\t\\t\\tfor(int i=0;i<n1;i++){\\n\\t\\t\\t\\ttemp+=words[i];\\n\\t\\t\\t\\tif(temp.length()==n) return s.equals(temp);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1395527,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        data = \"\"\\n        for i in words:\\n            data += i\\n            if not s.startswith(data):break\\n            if data == s:return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        data = \"\"\\n        for i in words:\\n            data += i\\n            if not s.startswith(data):break\\n            if data == s:return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390693,
                "title": "simple-java-solution",
                "content": "```\\n\\tStringBuilder str = new StringBuilder();\\n        for (int i = 0; i < words.length; i++) {\\n            String temp = str.toString();\\n            str.append(words[i]);\\n            if (str.toString().length() > s.length()) {\\n                if (temp.isEmpty()) {\\n                    temp = str.toString();\\n                }\\n                return s.equals(temp);\\n            }\\n        }\\n        return s.equals(str.toString());\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\tStringBuilder str = new StringBuilder();\\n        for (int i = 0; i < words.length; i++) {\\n            String temp = str.toString();\\n            str.append(words[i]);\\n            if (str.toString().length() > s.length()) {\\n                if (temp.isEmpty()) {\\n                    temp = str.toString();\\n                }\\n                return s.equals(temp);\\n            }\\n        }\\n        return s.equals(str.toString());\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390663,
                "title": "my-javascript-solution-using-indexof-80-ms",
                "content": "```\\nvar isPrefixString = function(s, words) {\\n    for (let i = 0; i < words.length; ++i) {\\n        if (s.indexOf(words[i]) === 0) s = s.substring(words[i].length);\\n        else break;\\n    }\\n    \\n    return s === \"\";\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isPrefixString = function(s, words) {\\n    for (let i = 0; i < words.length; ++i) {\\n        if (s.indexOf(words[i]) === 0) s = s.substring(words[i].length);\\n        else break;\\n    }\\n    \\n    return s === \"\";\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390437,
                "title": "basic-c-string-solution-in-o-n",
                "content": "**Idea** : \\n\\nLogic is simple. We need to check if a string can be made concatenating initial elements of words. \\nThis string formed should be of size equal to size of given string s. And both string should be equal.\\nIf yes then return true otherwise false. \\n\\nBelow code is self-explainatory. In case of any doubt feel free to ask.\\n```\\n    bool isPrefixString(string s, vector<string>& words) {\\n        \\n        int n = s.size(), m = words.size();\\n        string t = \"\";\\n        int i=0;\\n        while(t.size() <= n && i<m)\\n        {\\n            t += words[i++];\\n            if(t == s) return true;\\n        }\\n        return false;\\n    }\\n```\\nIf you understood the solution, please upvote !!!",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n    bool isPrefixString(string s, vector<string>& words) {\\n        \\n        int n = s.size(), m = words.size();\\n        string t = \"\";\\n        int i=0;\\n        while(t.size() <= n && i<m)\\n        {\\n            t += words[i++];\\n            if(t == s) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390380,
                "title": "my-solution",
                "content": "\\t\\tpublic boolean isPrefixString(String s, String[] words) {\\n\\t\\t\\tStringBuffer sb = new StringBuffer(\"\");\\n\\t\\t\\tif(!s.contains(words[0])) return false;\\n\\t\\t\\tfor(int i=0;i<words.length;i++){\\n\\t\\t\\t\\tsb.append(words[i]);\\n\\t\\t\\t\\tif(sb.length()==s.length() && sb.toString().equals(s)){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\t\\tpublic boolean isPrefixString(String s, String[] words) {\\n\\t\\t\\tStringBuffer sb = new StringBuffer(\"\");\\n\\t\\t\\tif(!s.contains(words[0])) return false;\\n\\t\\t\\tfor(int i=0;i<words.length;i++){\\n\\t\\t\\t\\tsb.append(words[i]);\\n\\t\\t\\t\\tif(sb.length()==s.length() && sb.toString().equals(s)){\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1390368,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for(String word : words) {\\n            sb.append(word);\\n            if(sb.toString().equals(s))\\n                return true;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        for(String word : words) {\\n            sb.append(word);\\n            if(sb.toString().equals(s))\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1390362,
                "title": "java-o-n-time",
                "content": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        \\n      String result=\"\";\\n      for(String i:words){\\n      result+=i;\\n      if(s.length()==result.length())\\n      return s.equals(result);\\n      } \\n      return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        \\n      String result=\"\";\\n      for(String i:words){\\n      result+=i;\\n      if(s.length()==result.length())\\n      return s.equals(result);\\n      } \\n      return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390246,
                "title": "check-if-string-is-a-prefix-of-array-weekly-contest-253-editorial-java",
                "content": "\\tclass Solution {\\n\\t\\t//    Weekly Contest 253 Solutions\\n\\n\\t\\t//    Guyz do mention if you\\'ve some better solution approach. Below are the implementation I used during contest\\n\\n\\t\\t//    **********************************************************************************\\n\\t\\t//    Que - 1\\n\\n\\t\\t// I did the brute force approach. I think solution is self explanatory.\\n\\t\\tpublic boolean isPrefixString(String s, String[] words) {\\n\\t\\t\\tStringBuilder strb = new StringBuilder();\\n\\t\\t\\tfor(String st : words) {\\n\\t\\t\\t\\tstrb.append(st);\\n\\t\\t\\t\\tif(strb.toString().equals(s)) return true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\t// In each and every iteration we\\'ll change the maximum element to x-x/2 where x is the maximum element in current iteration.\\n\\t\\t// For getting maximum element in every iteration we\\'ll make use of priority queue    \\n\\t\\t//    **********************************************************************************\\n\\t\\t//    Que-2 Medium\\n\\t\\tpublic int minStoneSum(int[] piles, int k) {\\n\\t\\t\\tPriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n\\t\\t\\tfor(int val : piles) pq.add(val);\\n\\t\\t\\twhile(k-- != 0) {\\n\\t\\t\\t\\tint x = pq.remove();\\n\\t\\t\\t\\tpq.add(x-x/2);\\n\\t\\t\\t}\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\twhile(!pq.isEmpty()) {\\n\\t\\t\\t\\tsum+=pq.remove();\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\n\\t\\t// After removing the balanced part our string comes aut of like (a*[)(b*]). I did some test cases and we can balance string of such types using following number of steps\\n\\t\\t// min steps = (l+2)/4 steps\\n\\t\\t//    **********************************************************************************\\n\\t\\t//    Que-3 Medium\\n\\t\\tpublic int minSwaps(String s) {\\n\\t\\t\\tStack<Character> st = new Stack();\\n\\t\\t\\tfor(char c : s.toCharArray()) {\\n\\t\\t\\t\\tif(c == \\'[\\') st.push(c);\\n\\t\\t\\t\\telse if(c == \\']\\') {\\n\\t\\t\\t\\t\\tif(!st.isEmpty() && st.peek() == \\'[\\') st.pop();\\n\\t\\t\\t\\t\\telse st.push(c);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn (st.size()+2)/4;\\n\\t\\t}\\n\\n\\t\\t// This is a variation of Longest increasing subsequence. At an index i We just need to store the max length of longest increasing subsequence we can create whose last index element will be ith element\\n\\t\\t//    **********************************************************************************\\n\\t\\t//    Que-4\\n\\t\\tpublic static int bs(ArrayList<Integer> list, int val) {\\n\\t\\t\\tint start = 0, end = list.size();\\n\\t\\t\\twhile (start < end) {\\n\\t\\t\\t\\tint mid = start + (end-start)/2;\\n\\t\\t\\t\\tif(list.get(mid) <= val) {\\n\\t\\t\\t\\t\\tstart = mid+1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tend = mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn start;\\n\\t\\t}\\n\\n\\n\\t\\tpublic int[] longestObstacleCourseAtEachPosition(int[] arr) {\\n\\t\\t\\tint n = arr.length;\\n\\t\\t\\tint[] res = new int[arr.length];\\n\\t\\t\\tArrayList<Integer> list = new ArrayList<>();\\n\\t\\t\\tint maxv = 1;\\n\\t\\t\\tfor(int i=0; i<n; i++) {\\n\\t\\t\\t\\tint idx = bs(list, arr[i]);\\n\\t\\t\\t\\tif(idx == list.size()){\\n\\t\\t\\t\\t\\tlist.add(arr[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tlist.set(idx, arr[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres[i] = idx+1;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t\\t//    **********************************************************************************\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t//    Weekly Contest 253 Solutions\\n\\n\\t\\t//    Guyz do mention if you\\'ve some better solution approach. Below are the implementation I used during contest\\n\\n\\t\\t//    **********************************************************************************\\n\\t\\t//    Que - 1\\n\\n\\t\\t// I did the brute force approach. I think solution is self explanatory.\\n\\t\\tpublic boolean isPrefixString(String s, String[] words) {\\n\\t\\t\\tStringBuilder strb = new StringBuilder();\\n\\t\\t\\tfor(String st : words) {\\n\\t\\t\\t\\tstrb.append(st);\\n\\t\\t\\t\\tif(strb.toString().equals(s)) return true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4087936,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for(String word:words){\\n            sb.append(word);\\n            if(s.equals(sb.toString())) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for(String word:words){\\n            sb.append(word);\\n            if(s.equals(sb.toString())) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084777,
                "title": "python3-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        res=\\'\\'\\n        for word in words:\\n            res+=word\\n            if res==s:\\n                return True\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        res=\\'\\'\\n        for word in words:\\n            res+=word\\n            if res==s:\\n                return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078501,
                "title": "ruby-66ms-adding-one-word-at-a-time",
                "content": "```\\ndef is_prefix_string(s, words)\\n  sentence = \"\"\\n  for w in words\\n    sentence << w\\n    return true if s == sentence\\n  end\\n  return false\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef is_prefix_string(s, words)\\n  sentence = \"\"\\n  for w in words\\n    sentence << w\\n    return true if s == sentence\\n  end\\n  return false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4063970,
                "title": "easy-cpp-solution-beats-100-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/87db82a8-3a12-4af0-8b3c-3c06344596b3_1695120265.33186.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int ind = 0, len = s.length();\\n        int r = words.size();\\n        for(int i=0; i<r; i++){\\n            int sz = words[i].length();\\n            if(s.substr(ind, sz) != words[i]) return false;\\n            else ind += sz;\\n            if(ind == len) break;\\n        }\\n        \\n        return ind == len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int ind = 0, len = s.length();\\n        int r = words.size();\\n        for(int i=0; i<r; i++){\\n            int sz = words[i].length();\\n            if(s.substr(ind, sz) != words[i]) return false;\\n            else ind += sz;\\n            if(ind == len) break;\\n        }\\n        \\n        return ind == len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053388,
                "title": "simple-solution",
                "content": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        for word in words:\\n            if not s.startswith(word):\\n                return False\\n            s = s.removeprefix(word)\\n            if not s:\\n                return True         \\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        for word in words:\\n            if not s.startswith(word):\\n                return False\\n            s = s.removeprefix(word)\\n            if not s:\\n                return True         \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046002,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int wordIdx = 0;\\n        int charIdx = 0;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (wordIdx >= words.size())\\n            {\\n                return false;\\n            }\\n            if (s[i] != words[wordIdx][charIdx])\\n            {\\n                return false;\\n            }\\n            charIdx++;\\n            if (charIdx >= words[wordIdx].length())\\n            {\\n                charIdx = 0;\\n                wordIdx++;\\n            }\\n        }\\n        return (charIdx == 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int wordIdx = 0;\\n        int charIdx = 0;\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            if (wordIdx >= words.size())\\n            {\\n                return false;\\n            }\\n            if (s[i] != words[wordIdx][charIdx])\\n            {\\n                return false;\\n            }\\n            charIdx++;\\n            if (charIdx >= words[wordIdx].length())\\n            {\\n                charIdx = 0;\\n                wordIdx++;\\n            }\\n        }\\n        return (charIdx == 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044279,
                "title": "easy-java-solution-foreach-loop",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n     int idx = 0;\\n          for(String x : words){\\n            if(s.length() == idx){\\n                return true;\\n            }\\n            if(s.length() - idx < x.length()){\\n                return false;\\n            }\\n            for(int i=0;i<x.length();i++){\\n              if(s.charAt(idx) != x.charAt(i)){\\n                return false;\\n              }\\n              idx++;\\n            }\\n          }\\n\\n          if(idx < s.length()){\\n            return false;\\n          }\\n  \\n          return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n     int idx = 0;\\n          for(String x : words){\\n            if(s.length() == idx){\\n                return true;\\n            }\\n            if(s.length() - idx < x.length()){\\n                return false;\\n            }\\n            for(int i=0;i<x.length();i++){\\n              if(s.charAt(idx) != x.charAt(i)){\\n                return false;\\n              }\\n              idx++;\\n            }\\n          }\\n\\n          if(idx < s.length()){\\n            return false;\\n          }\\n  \\n          return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018922,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string a = \"\";\\n        for(int i = 0;i < words.size();i++){\\n            a+=words[i];\\n            if(a == s)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string a = \"\";\\n        for(int i = 0;i < words.size();i++){\\n            a+=words[i];\\n            if(a == s)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4007157,
                "title": "simple-java-solution-1-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String s1=\"\";\\n        for(int i=0;i<words.length;i++){\\n            s1+=words[i];\\n            if(s1.equals(s))\\n                return true;\\n        } \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String s1=\"\";\\n        for(int i=0;i<words.length;i++){\\n            s1+=words[i];\\n            if(s1.equals(s))\\n                return true;\\n        } \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002077,
                "title": "beats-100-easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->First we have done the summing of length of words element so that we need to match this at end.\\nThen we combine all words into one and sliced into as length of s to compare.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![beats 100%.jpg](https://assets.leetcode.com/users/images/df114170-4ce3-4b8d-9a4e-21c9e5795827_1693844822.279736.jpeg)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        c=0\\n        arr = [ (c := c+len(i)) for i in words]\\n        n = len(s)\\n        words = \"\".join(i for i in words)[:n]\\n        return s==words and len(s) in arr\\n                \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        c=0\\n        arr = [ (c := c+len(i)) for i in words]\\n        n = len(s)\\n        words = \"\".join(i for i in words)[:n]\\n        return s==words and len(s) in arr\\n                \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998486,
                "title": "java-simple-and-easy-to-understand-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code constructs a string str by concatenating words from the array until str is at least as long as s.\\nThen it checks if the constructed string str is equal to s.\\n\\nExplanation:\\nAppend the String until either of the two conditions are not true:\\n1) If the length of the str becomes greater than the given string s.(if it exceeds the length of given string it can not be equal)\\n2) If we come out of the array of given string words\\n\\nnow, if our string matches the given string then answer will be true otherwise false.\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        // short index =0;\\n        // int i=0;\\n        // while(index<s.length()&&i<words.length)\\n        // {\\n        //     if(words[i]!=s.substring(index,index+words[i].length()))\\n        //     {\\n        //         return false;\\n        //     }\\n        //     index+= words[i].length();\\n        //     i++;\\n        // }\\n        // if(index<s.length())\\n        //     {return false;}\\n        // else\\n        // {return true;}\\n\\n\\n\\n        int i=0;\\n        StringBuilder str = new StringBuilder();\\n        while(str.length()<s.length()&&i<words.length)\\n        {\\n            str = str.append(words[i]);\\n            i++;\\n        }\\n\\n        if(str.toString().equals(s))\\n        return true;\\n\\n        else\\n        return false;\\n        \\n    }\\n}\\n\\n\\n\\n```\\n\\nPlease upvote if you feel the code to be easy. \\nIt means a lot to me...",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        // short index =0;\\n        // int i=0;\\n        // while(index<s.length()&&i<words.length)\\n        // {\\n        //     if(words[i]!=s.substring(index,index+words[i].length()))\\n        //     {\\n        //         return false;\\n        //     }\\n        //     index+= words[i].length();\\n        //     i++;\\n        // }\\n        // if(index<s.length())\\n        //     {return false;}\\n        // else\\n        // {return true;}\\n\\n\\n\\n        int i=0;\\n        StringBuilder str = new StringBuilder();\\n        while(str.length()<s.length()&&i<words.length)\\n        {\\n            str = str.append(words[i]);\\n            i++;\\n        }\\n\\n        if(str.toString().equals(s))\\n        return true;\\n\\n        else\\n        return false;\\n        \\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962547,
                "title": "beats-100-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { \\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string concat;\\n        for(int i=0;i<words.size();i++){\\n            concat += words[i];\\n            if(concat == s){\\n                return true;\\n            }\\n\\n        }\\n        return false;\\n    }\\n}; // please upvote if you like it\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { \\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string concat;\\n        for(int i=0;i<words.size();i++){\\n            concat += words[i];\\n            if(concat == s){\\n                return true;\\n            }\\n\\n        }\\n        return false;\\n    }\\n}; // please upvote if you like it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952006,
                "title": "easy-travers-to-beat-98-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        left_idx=0\\n        right_idx=0\\n        total_l=0\\n        for w in words:\\n            right_idx+=len(w)\\n            total_l+=len(w)\\n            if s[left_idx:right_idx]!=w:\\n                return False\\n            left_idx=right_idx\\n            \\n            if right_idx>=len(s):\\n                break\\n                \\n        if len(s)>total_l:\\n            return False\\n        return True\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        left_idx=0\\n        right_idx=0\\n        total_l=0\\n        for w in words:\\n            right_idx+=len(w)\\n            total_l+=len(w)\\n            if s[left_idx:right_idx]!=w:\\n                return False\\n            left_idx=right_idx\\n            \\n            if right_idx>=len(s):\\n                break\\n                \\n        if len(s)>total_l:\\n            return False\\n        return True\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946469,
                "title": "beats-92-54-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n    let str=\\'\\';\\n    for (let index = 0; index < words.length; index++) {str += words[index]; if (str === s) return true;}\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n    let str=\\'\\';\\n    for (let index = 0; index < words.length; index++) {str += words[index]; if (str === s) return true;}\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3937176,
                "title": "check-if-string-is-a-prefix-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction isPrefixString(s: string, words: string[]): boolean {\\n    let i= 0;\\n    for(const word  of words ){\\n        if(!s.startsWith(word, i)) return false;\\n        i += word.length;\\n        if(i === s.length) return true;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isPrefixString(s: string, words: string[]): boolean {\\n    let i= 0;\\n    for(const word  of words ){\\n        if(!s.startsWith(word, i)) return false;\\n        i += word.length;\\n        if(i === s.length) return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936204,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def isPrefixString(self, s, words):\\n        output = \\'\\'\\n        for i in range(len(words)):\\n            output += words[i]\\n            if output == s:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPrefixString(self, s, words):\\n        output = \\'\\'\\n        for i in range(len(words)):\\n            output += words[i]\\n            if output == s:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923763,
                "title": "easy-solution-c-code-beats-82",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string s1 = \"\";\\n        for(int i=0; i<words.size(); i++){\\n            s1 += words[i];\\n            if(s == s1)return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string s1 = \"\";\\n        for(int i=0; i<words.size(); i++){\\n            s1 += words[i];\\n            if(s == s1)return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922132,
                "title": "beats-95-with-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        w=0\\n        for i in words:\\n            if s[w:]==\\'\\':\\n                return True\\n            if s[w:].startswith(i):\\n                w+=len(i)\\n            else:\\n                return False\\n        if s[w:]:\\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        w=0\\n        for i in words:\\n            if s[w:]==\\'\\':\\n                return True\\n            if s[w:].startswith(i):\\n                w+=len(i)\\n            else:\\n                return False\\n        if s[w:]:\\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919832,
                "title": "easy-solution",
                "content": "\\n```\\nclass Solution(object):\\n    def isPrefixString(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        prefix = \\'\\'\\n        for w in words:\\n            prefix = prefix + w\\n            if prefix == s:\\n                return True\\n            if not s.startswith(prefix):\\n                break  \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPrefixString(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: bool\\n        \"\"\"\\n        prefix = \\'\\'\\n        for w in words:\\n            prefix = prefix + w\\n            if prefix == s:\\n                return True\\n            if not s.startswith(prefix):\\n                break  \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3900589,
                "title": "with-and-without-using-space-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2), O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1), O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int w=0;\\n        for(int i=0; i < words.size(); i++){\\n            for(int j=0; j < words[i].size(); j++){\\n                if(words[i][j]!=s[w++]) return 0;\\n            }\\n            if(w >= s.size()) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str = \"\";\\n        for(int i=0; i < words.size(); i++){\\n            str+=words[i];\\n            if(s==str) return 1;\\n            if(s.size() < str.size()) return 0;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int w=0;\\n        for(int i=0; i < words.size(); i++){\\n            for(int j=0; j < words[i].size(); j++){\\n                if(words[i][j]!=s[w++]) return 0;\\n            }\\n            if(w >= s.size()) return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str = \"\";\\n        for(int i=0; i < words.size(); i++){\\n            str+=words[i];\\n            if(s==str) return 1;\\n            if(s.size() < str.size()) return 0;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890032,
                "title": "c-two-pointers-time-o-n2-space-o-1",
                "content": "```\\npublic class Solution {\\n    public bool IsPrefixString(string s, string[] words) {\\n        int count = 0;\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n          if(words[i].Length > s.Length - count) return false;\\n          for(int j = 0; j < words[i].Length; j++)\\n          {\\n            if(words[i][j] != s[count]) return false;\\n            if(s.Length == ++count) return true;\\n          }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPrefixString(string s, string[] words) {\\n        int count = 0;\\n        for(int i = 0; i < words.Length; i++)\\n        {\\n          if(words[i].Length > s.Length - count) return false;\\n          for(int j = 0; j < words[i].Length; j++)\\n          {\\n            if(words[i][j] != s[count]) return false;\\n            if(s.Length == ++count) return true;\\n          }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889013,
                "title": "java-easy-solution-using-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String s1=\"\";\\n        for(int i=0;i<words.length;i++){\\n            s1+=words[i];\\n            if(s.equals(s1)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String s1=\"\";\\n        for(int i=0;i<words.length;i++){\\n            s1+=words[i];\\n            if(s.equals(s1)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888183,
                "title": "python3-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        \\n        string = \\'\\'\\n        for i in words:\\n            string+=i\\n\\n        if len(s) > len(string):\\n            return False\\n        elif len(s) < len(words[0]):\\n            return False\\n        else:\\n            if len(s) <= len(string):\\n                count = 0\\n                k = 0\\n                while count < len(s):\\n                    count+= len(words[k])\\n                    k+=1\\n                if count != len(s):\\n                    return False\\n                elif s == string[:len(s)]:\\n                    return True\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        \\n        string = \\'\\'\\n        for i in words:\\n            string+=i\\n\\n        if len(s) > len(string):\\n            return False\\n        elif len(s) < len(words[0]):\\n            return False\\n        else:\\n            if len(s) <= len(string):\\n                count = 0\\n                k = 0\\n                while count < len(s):\\n                    count+= len(words[k])\\n                    k+=1\\n                if count != len(s):\\n                    return False\\n                elif s == string[:len(s)]:\\n                    return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886382,
                "title": "jav-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words)\\n\\t\\t \\n\\t\\t {\\n\\t\\t\\t  \\n\\t\\t\\t\\t\\n\\t\\t\\t StringBuilder sb = new StringBuilder(\"\");\\n        for (String str : words) {\\n            sb.append(str);\\n            if (sb.toString().startsWith(s) && s.length()>=sb.toString().length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n\\t\\t\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words)\\n\\t\\t \\n\\t\\t {\\n\\t\\t\\t  \\n\\t\\t\\t\\t\\n\\t\\t\\t StringBuilder sb = new StringBuilder(\"\");\\n        for (String str : words) {\\n            sb.append(str);\\n            if (sb.toString().startsWith(s) && s.length()>=sb.toString().length()) {\\n                return true;\\n            }\\n        }\\n        return false;\\n\\t\\t\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886296,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str = \"\";\\n        for (auto i : words){\\n            str += i;\\n            if (str == s)\\n                return true;\\n        }         \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str = \"\";\\n        for (auto i : words){\\n            str += i;\\n            if (str == s)\\n                return true;\\n        }         \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881325,
                "title": "1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        if(s.length() < words[0].length()){ return false;}\\n        StringBuilder stringBuilder = new StringBuilder();\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            stringBuilder.append(words[i]);\\n            if(stringBuilder.toString().equals(s)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        if(s.length() < words[0].length()){ return false;}\\n        StringBuilder stringBuilder = new StringBuilder();\\n        \\n        for (int i = 0; i < words.length; i++) {\\n            stringBuilder.append(words[i]);\\n            if(stringBuilder.toString().equals(s)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880582,
                "title": "easy-and-simple-java-solution-stringbuilder-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb= new StringBuilder();\\n        for(int i=0;i<words.length;i++){\\n            sb.append(words[i]);\\n            if(sb.toString().equals(s)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb= new StringBuilder();\\n        for(int i=0;i<words.length;i++){\\n            sb.append(words[i]);\\n            if(sb.toString().equals(s)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876309,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) \\n    {\\n        String str=\"\";\\n        for(int i=0;i<words.length;i++)\\n        {\\n            str=str+words[i];\\n            if(str.equals(s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) \\n    {\\n        String str=\"\";\\n        for(int i=0;i<words.length;i++)\\n        {\\n            str=str+words[i];\\n            if(str.equals(s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869735,
                "title": "check-if-string-is-a-prefix-of-array-100-beats-easy-approach-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string s1=\"\",a=\"\";\\n        for(int i=0;i<words.size() && a.size()<s.size();i++){\\n            s1=s1+words[i];\\n            int b=s1.size();\\n            a=s.substr(0,b);\\n            cout<<b<<\":\"<<a.size()<<endl;\\n            if(a.size()!=b || a!=s1){\\n                return 0;\\n            }\\n        }\\n        if(s.size()!=s1.size()){\\n            return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string s1=\"\",a=\"\";\\n        for(int i=0;i<words.size() && a.size()<s.size();i++){\\n            s1=s1+words[i];\\n            int b=s1.size();\\n            a=s.substr(0,b);\\n            cout<<b<<\":\"<<a.size()<<endl;\\n            if(a.size()!=b || a!=s1){\\n                return 0;\\n            }\\n        }\\n        if(s.size()!=s1.size()){\\n            return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3851057,
                "title": "runtime-memory-42ms-16-42mb-beats-93-84-11-27-of-users-with-python3",
                "content": "# Intuition\\n1. Only need the count from `0` to `len(s)` for comparing.\\n# Approach\\n1. Get `s` length.\\n2. Extract and concatenate utils `s_len > 0`.\\n3. Compare `s` to `word_str`.\\n# Complexity\\n- Time complexity: N/A.\\n- Space complexity: N/A.\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        # 12:11.\\n        \\n        s_len = len(s)\\n        word_str = \\'\\'\\n\\n        for i in words:\\n            if s_len > 0:\\n                word_str += i\\n                s_len -= len(i)\\n            else:\\n                break\\n        \\n        if s == word_str:\\n            return True\\n        else:\\n            return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        # 12:11.\\n        \\n        s_len = len(s)\\n        word_str = \\'\\'\\n\\n        for i in words:\\n            if s_len > 0:\\n                word_str += i\\n                s_len -= len(i)\\n            else:\\n                break\\n        \\n        if s == word_str:\\n            return True\\n        else:\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851048,
                "title": "easy-to-under-stand-runtime-97-7-line",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : words) {\\n            sb.append(word);\\n            if (sb.length() == s.length()) break;\\n            else if (sb.length() > s.length()) return false;\\n        }\\n        return sb.toString().equals(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder sb = new StringBuilder();\\n        for (String word : words) {\\n            sb.append(word);\\n            if (sb.length() == s.length()) break;\\n            else if (sb.length() > s.length()) return false;\\n        }\\n        return sb.toString().equals(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841949,
                "title": "java-1ms-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String str = \"\";\\n        int k = s.length();\\n        for(int i=0; i<words.length; i++){\\n            if(str.length() != k){\\n                str += words[i];\\n            }\\n        }\\n        if(str.equals(s)) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String str = \"\";\\n        int k = s.length();\\n        for(int i=0; i<words.length; i++){\\n            if(str.length() != k){\\n                str += words[i];\\n            }\\n        }\\n        if(str.equals(s)) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835140,
                "title": "stringbuilder-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int sLength = s.length();\\n        int wLength = 0;\\n        int count = -1;\\n        StringBuilder sb = new StringBuilder();\\n        while (sLength > wLength && count < words.length -  1){\\n            wLength += words[++count].length();\\n            sb.append(words[count]);\\n        }\\n    return s.contentEquals(sb);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        int sLength = s.length();\\n        int wLength = 0;\\n        int count = -1;\\n        StringBuilder sb = new StringBuilder();\\n        while (sLength > wLength && count < words.length -  1){\\n            wLength += words[++count].length();\\n            sb.append(words[count]);\\n        }\\n    return s.contentEquals(sb);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833976,
                "title": "easy-solution-in-cpp-beats-100",
                "content": "# Intuition\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        /*string str=\"\";\\n        for(int i=0;i<words.size();i++){\\n            str+=words[i];\\n        }\\n        string sub=str.substr(0,s.length());\\n        return sub==s;*/\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++){\\n            str+=words[i];\\n            if(str==s)\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        /*string str=\"\";\\n        for(int i=0;i<words.size();i++){\\n            str+=words[i];\\n        }\\n        string sub=str.substr(0,s.length());\\n        return sub==s;*/\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++){\\n            str+=words[i];\\n            if(str==s)\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824058,
                "title": "build-string-following-each-letter-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsPrefixString(string s, string[] words) {\\n        string w = \"\";\\n\\n            foreach (string word in words)\\n            {\\n                w += word;\\n\\n                if (w == s)\\n                {\\n                    return true;\\n                }\\n\\n                if (w.Length > s.Length)\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPrefixString(string s, string[] words) {\\n        string w = \"\";\\n\\n            foreach (string word in words)\\n            {\\n                w += word;\\n\\n                if (w == s)\\n                {\\n                    return true;\\n                }\\n\\n                if (w.Length > s.Length)\\n                {\\n                    return false;\\n                }\\n            }\\n\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3809449,
                "title": "click-on-this-solution-if-u-r-not-gay",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String str = \"\";\\n\\n        for(int i = 0; i < words.length; i++) {\\n            if(s.indexOf(words[i]) == -1) return false;\\n            str = str + words[i];\\n            if(s.equals(str)) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n\\n\\nUPVOTE IF YOU ARE NOT GAY",
                "solutionTags": [
                    "Java",
                    "String",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        String str = \"\";\\n\\n        for(int i = 0; i < words.length; i++) {\\n            if(s.indexOf(words[i]) == -1) return false;\\n            str = str + words[i];\\n            if(s.equals(str)) return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808181,
                "title": "python-simple-solution-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isPrefixString(self, s: str, words: List[str]) -> bool:\\n    concatenated_word = \\'\\'\\n    for word in words:\\n        concatenated_word += word\\n        if concatenated_word == s:\\n            return True\\n    return concatenated_word == s\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n  def isPrefixString(self, s: str, words: List[str]) -> bool:\\n    concatenated_word = \\'\\'\\n    for word in words:\\n        concatenated_word += word\\n        if concatenated_word == s:\\n            return True\\n    return concatenated_word == s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805837,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        //main string forming\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++)\\n        {\\n            str+=words[i];\\n            if(str==s)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        //main string forming\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++)\\n        {\\n            str+=words[i];\\n            if(str==s)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802806,
                "title": "check-if-string-is-a-prefix-of-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n       String str = new String();\\n       for(int i=0;i<words.length;i++)\\n       {\\n           str=str+words[i];\\n           if(s.equals(str))\\n           return true;\\n       }\\n       return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n       String str = new String();\\n       for(int i=0;i<words.length;i++)\\n       {\\n           str=str+words[i];\\n           if(s.equals(str))\\n           return true;\\n       }\\n       return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796551,
                "title": "easy-brute-force-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nExample:\\n```\\ns = \"xyzabcdef\"\\nwords = {\"xyz\", \"abc\", \"def\"}\\n```\\n\\nTracing the code step-by-step:\\n\\n1. Initialize `comp` to an empty string, `i = 0`, `j = 0`, and `k = 0`.\\n2. Enter the `for` loop with `i = 0` and `k = 0`.\\n3. Set `size = words[0].size() - 1 = 2`.\\n4. Enter the `while` loop with `j = 0`.\\n5. Compare `s[k]` and `words[0][j]`, both are \\'x\\'.\\n6. Increment `k` and `j`.\\n7. Compare `s[k]` and `words[0][j]`, both are \\'y\\'.\\n8. Increment `k` and `j`.\\n9. Compare `s[k]` and `words[0][j]`, both are \\'z\\'.\\n10. Increment `k` and `j`.\\n\\nAt this point, the while loop ends because `j` becomes `3`, which is equal to `size + 1`. The first word \"xyz\" matches the prefix of the string `s`. The updated value of `k` is `3`.\\n\\n11. Continue with the next word.\\n12. Set `size = words[1].size() - 1 = 2`.\\n13. Enter the `while` loop with `j = 0`.\\n14. Compare `s[k]` and `words[1][j]`, `s[k]` is \\'a\\', and `words[1][j]` is \\'a\\'.\\n**...........**\\nThis will continue till either of the string\\'s end.\\n\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string comp = \"\";\\n        int i = 0, j = 0,k = 0; \\n\\n        for(;i < words.size() && k < s.size(); i++){\\n            int size = words[i].size() - 1;\\n            j = 0;\\n            if(s.size() - k < words[i].size())\\n                return false;\\n            while(j <= size){\\n                if(s[k] != words[i][j] ){\\n                    cout<<\"val = \"<<s[k]<<\" == \"<<words[i][j]<<endl;\\n                    return false;\\n                }\\n                k++;\\n                j++;\\n            }\\n        }\\n        if(k < s.size())\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ns = \"xyzabcdef\"\\nwords = {\"xyz\", \"abc\", \"def\"}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string comp = \"\";\\n        int i = 0, j = 0,k = 0; \\n\\n        for(;i < words.size() && k < s.size(); i++){\\n            int size = words[i].size() - 1;\\n            j = 0;\\n            if(s.size() - k < words[i].size())\\n                return false;\\n            while(j <= size){\\n                if(s[k] != words[i][j] ){\\n                    cout<<\"val = \"<<s[k]<<\" == \"<<words[i][j]<<endl;\\n                    return false;\\n                }\\n                k++;\\n                j++;\\n            }\\n        }\\n        if(k < s.size())\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3794443,
                "title": "basic-java-soln-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        if(s.charAt(0)!=words[0].charAt(0)||s.length()<words[0].length())\\n            return false;\\n        StringBuilder str=new StringBuilder();\\n        for(String i:words){\\n            str.append(i);\\n            if(s.indexOf(str.toString())!=0)\\n                return false;\\n            if(s.equals(str.toString()))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        if(s.charAt(0)!=words[0].charAt(0)||s.length()<words[0].length())\\n            return false;\\n        StringBuilder str=new StringBuilder();\\n        for(String i:words){\\n            str.append(i);\\n            if(s.indexOf(str.toString())!=0)\\n                return false;\\n            if(s.equals(str.toString()))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790361,
                "title": "c-beats-100-in-time-space-characterwise-comparision",
                "content": "# Complexity\\n- Time complexity: O(min(n, N))\\nwhere n = length of string s\\nand N = sum of length of all words in the given array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i,j,n, k=0, N=s.length();\\n        for(i=0; i<words.size() && k<N; i++){\\n            n = words[i].length();\\n            for(j=0; j<n && k<N; j++){\\n                if(s[k++] != words[i][j])\\n                    return false;\\n            }\\n            if(j<n)\\n                return false;\\n        }\\n        return k==N;\\n    } \\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i,j,n, k=0, N=s.length();\\n        for(i=0; i<words.size() && k<N; i++){\\n            n = words[i].length();\\n            for(j=0; j<n && k<N; j++){\\n                if(s[k++] != words[i][j])\\n                    return false;\\n            }\\n            if(j<n)\\n                return false;\\n        }\\n        return k==N;\\n    } \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765221,
                "title": "c-linear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& w) {\\n        string s1;\\n        for(int i=0;i<w.size();i++){\\n            s1 += w[i];\\n            if(s1==s)return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& w) {\\n        string s1;\\n        for(int i=0;i<w.size();i++){\\n            s1 += w[i];\\n            if(s1==s)return 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755964,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder prefix = new StringBuilder();\\n\\n        for(String word: words )\\n        {\\n            prefix.append(word);\\n\\n            if(prefix.toString().equals(s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        StringBuilder prefix = new StringBuilder();\\n\\n        for(String word: words )\\n        {\\n            prefix.append(word);\\n\\n            if(prefix.toString().equals(s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750622,
                "title": "java-easy-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n       String arr=\"\";\\n       for(String word:words)\\n       {\\n           arr+=word;\\n           if(s.equals(arr))\\n           {\\n               return true;\\n           }\\n       }\\n       return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n       String arr=\"\";\\n       for(String word:words)\\n       {\\n           arr+=word;\\n           if(s.equals(arr))\\n           {\\n               return true;\\n           }\\n       }\\n       return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748023,
                "title": "java-solution-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        for (int i = 0; i < words.length; i++) {\\n            if (s.length() == 0) return true;\\n            if (s.startsWith(words[i])) {\\n                s = s.substring(words[i].length());\\n            } else {\\n                break;\\n            }\\n        }\\n        if (s.length() != 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        for (int i = 0; i < words.length; i++) {\\n            if (s.length() == 0) return true;\\n            if (s.startsWith(words[i])) {\\n                s = s.substring(words[i].length());\\n            } else {\\n                break;\\n            }\\n        }\\n        if (s.length() != 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741888,
                "title": "python-bruteforce-approach-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        sub_str = \"\"\\n        sum = 0\\n        for i in range(len(words)):\\n            word = words[i]\\n            sub_str += word\\n            sum += len(word)\\n            if sum == len(s):\\n                break\\n        if sub_str == s:\\n            return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        sub_str = \"\"\\n        sum = 0\\n        for i in range(len(words)):\\n            word = words[i]\\n            sub_str += word\\n            sum += len(word)\\n            if sum == len(s):\\n                break\\n        if sub_str == s:\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737663,
                "title": "dead-easy-ts-js-o-n-solution-no-need-for-o-n-2",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- First and foremost, check if the first word in the array is actually a substring of the provided string. If not, return early.\\n- Initialize a variable that holds our comparison word to an empty string\\n- initialize a loop\\n  - Concatenate to our comparison string\\n  - Check if our current comparison string is equal to our provided string\\n  - If true, return true early.\\n\\nThe advantage of this is that we save some **computational power** when we return early, as opposed to `words.join(\\'\\')` which runs through the entire words array as it performs a join operation.\\n>NB: accessing an index in an array is $$O(1)$$\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n\\n# Code\\n```\\nfunction isPrefixString(s: string, words: string[]): boolean {\\n    // check if first word in array is an actual prefix of the word\\n    if(words[0] !== s.substring(0, words[0].length)) {\\n        return false;\\n    }\\n\\n    let conWord = \\'\\'\\n    for(let i=0; i<words.length; i++) {\\n        conWord += words[i];\\n\\n        // check if s is equal to the current concatenated string\\n        if(s === conWord) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction isPrefixString(s: string, words: string[]): boolean {\\n    // check if first word in array is an actual prefix of the word\\n    if(words[0] !== s.substring(0, words[0].length)) {\\n        return false;\\n    }\\n\\n    let conWord = \\'\\'\\n    for(let i=0; i<words.length; i++) {\\n        conWord += words[i];\\n\\n        // check if s is equal to the current concatenated string\\n        if(s === conWord) {\\n            return true;\\n        }\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3730197,
                "title": "simple-c-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code checks if the concatenation of the words in the vector \"words\" forms the given string \"s\" as a prefix.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code iteratively concatenates the strings from the vector \"words\" and checks if the resulting sentence matches the given string \"s\" as a prefix.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n    \\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int count = 0;\\n        string sentence;\\n        for(int i = 0; i < words.size(); i++){\\n            sentence += words[i];\\n            if(sentence == s){\\n                return true;\\n            }\\n        }    \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int count = 0;\\n        string sentence;\\n        for(int i = 0; i < words.size(); i++){\\n            sentence += words[i];\\n            if(sentence == s){\\n                return true;\\n            }\\n        }    \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729977,
                "title": "java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        // \\n        String res = \"\";\\n        for(String word : words){\\n            res += word;\\n            if(s.equals(res)){\\n                return true;\\n            }\\n            if(s.indexOf(res)==-1){\\n                return false;\\n            }\\n        }\\n        return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrefixString(String s, String[] words) {\\n        // \\n        String res = \"\";\\n        for(String word : words){\\n            res += word;\\n            if(s.equals(res)){\\n                return true;\\n            }\\n            if(s.indexOf(res)==-1){\\n                return false;\\n            }\\n        }\\n        return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728097,
                "title": "solution-using-the-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is an Quite easy approach which can be understand by anyone\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        b=len(s)\\n        c=\\'\\'\\n        for x in words:\\n            if len(c)==len(s):\\n                break\\n            else:\\n                c+=x\\n        return c==s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        b=len(s)\\n        c=\\'\\'\\n        for x in words:\\n            if len(c)==len(s):\\n                break\\n            else:\\n                c+=x\\n        return c==s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716840,
                "title": "cpp-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nOPTIMIZED SOLUTION\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i;\\n        string str=\"\";\\n        for(i=0; i<words.size(); i++){\\n            str+=words[i];\\n            if(str==s){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int i;\\n        string str=\"\";\\n        for(i=0; i<words.size(); i++){\\n            str+=words[i];\\n            if(str==s){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698083,
                "title": "c-beginner-friendly-solution-only-3-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++){\\n            str+=words[i];\\n            if(s==str){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++){\\n            str+=words[i];\\n            if(s==str){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696804,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& arr) {\\n        unordered_map<char, bool> m;\\n        for(int i = 0; i < s.length(); i++){\\n            m[s[i]] = true;\\n        }\\n        string ans = \"\";\\n        int n = arr.size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < arr[i].length(); j++){\\n                if(!m[arr[i][j]]) return false;\\n                else ans += arr[i][j];\\n            }\\n            if(s == ans) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& arr) {\\n        unordered_map<char, bool> m;\\n        for(int i = 0; i < s.length(); i++){\\n            m[s[i]] = true;\\n        }\\n        string ans = \"\";\\n        int n = arr.size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < arr[i].length(); j++){\\n                if(!m[arr[i][j]]) return false;\\n                else ans += arr[i][j];\\n            }\\n            if(s == ans) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684736,
                "title": "100-runtime-beats-easiest-solution",
                "content": "\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str = words[0];\\n        if(str==s){\\n            return true;\\n        }\\n       \\n        for(int i=1;i<words.size();i++){\\n            if(str==s){\\n                return true;\\n            }\\n            for(int j=0;j<words[i].length();j++){\\n                str.push_back(words[i][j]);\\n            }\\n        }\\n        if(str==s){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string str = words[0];\\n        if(str==s){\\n            return true;\\n        }\\n       \\n        for(int i=1;i<words.size();i++){\\n            if(str==s){\\n                return true;\\n            }\\n            for(int j=0;j<words[i].length();j++){\\n                str.push_back(words[i][j]);\\n            }\\n        }\\n        if(str==s){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683942,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n  let compStr = \"\";\\n  for(let i=0;i<words.length;i++){\\n    compStr += words[i]\\n    if(compStr===s){\\n      return true\\n    }\\n  }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {boolean}\\n */\\nvar isPrefixString = function(s, words) {\\n  let compStr = \"\";\\n  for(let i=0;i<words.length;i++){\\n    compStr += words[i]\\n    if(compStr===s){\\n      return true\\n    }\\n  }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3678017,
                "title": "0ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int n = words.size(), m = s.length(), k = 0;\\n        if(m < words[0].length()) return false;  \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < words[i].length();){\\n                if(k < m && s[k++]!=words[i][j++]){\\n                    cout << words[i][j] << endl;\\n                    cout << j << \" \" << k << endl;\\n                return false;\\n                } \\n                if(k==m && (j > 0 && j < words[i].length())){\\n                    return false;\\n                } \\n                if(k==m) break;\\n            }\\n        }\\n        if(k < m) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        int n = words.size(), m = s.length(), k = 0;\\n        if(m < words[0].length()) return false;  \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < words[i].length();){\\n                if(k < m && s[k++]!=words[i][j++]){\\n                    cout << words[i][j] << endl;\\n                    cout << j << \" \" << k << endl;\\n                return false;\\n                } \\n                if(k==m && (j > 0 && j < words[i].length())){\\n                    return false;\\n                } \\n                if(k==m) break;\\n            }\\n        }\\n        if(k < m) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3677253,
                "title": "c-easy-solution-runtime-0ms-beats-100",
                "content": "# Please UPVOTE this!\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFind all possible pairs and simultaneously verify that our string is similar to given string or not.\\nIf yes then return true, otherwise return false.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {       \\n        for(int i=0; i<words.size(); i++){\\n            string str=\"\";\\n            for(int j=0; j<=i; j++){\\n                str+=words[j];\\n            }\\n            if(str==s)  return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {       \\n        for(int i=0; i<words.size(); i++){\\n            string str=\"\";\\n            for(int j=0; j<=i; j++){\\n                str+=words[j];\\n            }\\n            if(str==s)  return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665401,
                "title": "python-easy-solution-tracking-current-prefix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        target_char_set = len(s)\\n        current_prefix = \"\"\\n\\n        for word in words:\\n            current_prefix += word\\n            if current_prefix == s:\\n                return True\\n            if len(current_prefix) >= target_char_set:\\n                return False\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrefixString(self, s: str, words: List[str]) -> bool:\\n        target_char_set = len(s)\\n        current_prefix = \"\"\\n\\n        for word in words:\\n            current_prefix += word\\n            if current_prefix == s:\\n                return True\\n            if len(current_prefix) >= target_char_set:\\n                return False\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656588,
                "title": "easy-solution-with-understandable-explanation",
                "content": "# Complexity\\n![image.png](https://assets.leetcode.com/users/images/88dc1249-247b-4340-9d1b-056b8006efca_1687173193.369893.png)\\n\\n# Approach\\nFirst I try by simply join the array and compare it from start to length. Its cleared the initial testcase but failed at this case:\\n\"a\";\\n{\"aa\", \"aaaa\", \"banana\"}\\n\\nthen I understand that have to check it on each append of array\\'s element.\\n\\n# Upvote Plz\\n\\n# Code\\n```\\npublic class Solution {\\n  public bool IsPrefixString(string s, string[] words)\\n    {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i=0; i<words.Count();i++)\\n            {\\n                sb.Append(words[i]);\\n                if (s == sb.ToString())return true;\\n            }\\n            return false;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n  public bool IsPrefixString(string s, string[] words)\\n    {\\n            StringBuilder sb = new StringBuilder();\\n            for (int i=0; i<words.Count();i++)\\n            {\\n                sb.Append(words[i]);\\n                if (s == sb.ToString())return true;\\n            }\\n            return false;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3646126,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string temp;\\n        for(int i=0;i<words.size();i++){\\n            temp+=words[i];\\n            if(temp.length()>s.length()){\\n                return false;\\n            }\\n            else if(temp==s){\\n                return true;\\n            }\\n            else{continue;}\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrefixString(string s, vector<string>& words) {\\n        string temp;\\n        for(int i=0;i<words.size();i++){\\n            temp+=words[i];\\n            if(temp.length()>s.length()){\\n                return false;\\n            }\\n            else if(temp==s){\\n                return true;\\n            }\\n            else{continue;}\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1853624,
                "content": [
                    {
                        "username": "Gangeswaran",
                        "content": "Don\\'t underestimate easy problems, Problem looks easy but missed to read the question properly which caused a bit more time than usual.."
                    },
                    {
                        "username": "anacmartins",
                        "content": "i cannot get why s = \"ccccccccc\" and words = [\"c\",\"cc\"] is false."
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I guess we got confused by termin `prefix`, actually while concatenating through the array at some point concatenated string should be exactly equal to `s` string"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "same here"
                    },
                    {
                        "username": "anacmartins",
                        "content": "is it false because in the end there are some characters left on s with no match in words?"
                    },
                    {
                        "username": "youngaryan",
                        "content": "why it expects these two to return false?\\n {\\n\"fajsldfsa\"\\n[\"faj\",\"s\",\"ldfs\",\"afdfs\",\"jfkdlsj\",\"f\"]\\n}\\n{\\n\"aaa\"\\n[\"aa\",\"aaa\",\"fjaklfj\"]\\n}"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "[@youngaryan](/youngaryan) How i am not able to get it \\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "I approched in a wrong way, i fixed it"
                    }
                ]
            },
            {
                "id": 1862180,
                "content": [
                    {
                        "username": "Gangeswaran",
                        "content": "Don\\'t underestimate easy problems, Problem looks easy but missed to read the question properly which caused a bit more time than usual.."
                    },
                    {
                        "username": "anacmartins",
                        "content": "i cannot get why s = \"ccccccccc\" and words = [\"c\",\"cc\"] is false."
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I guess we got confused by termin `prefix`, actually while concatenating through the array at some point concatenated string should be exactly equal to `s` string"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "same here"
                    },
                    {
                        "username": "anacmartins",
                        "content": "is it false because in the end there are some characters left on s with no match in words?"
                    },
                    {
                        "username": "youngaryan",
                        "content": "why it expects these two to return false?\\n {\\n\"fajsldfsa\"\\n[\"faj\",\"s\",\"ldfs\",\"afdfs\",\"jfkdlsj\",\"f\"]\\n}\\n{\\n\"aaa\"\\n[\"aa\",\"aaa\",\"fjaklfj\"]\\n}"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "[@youngaryan](/youngaryan) How i am not able to get it \\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "I approched in a wrong way, i fixed it"
                    }
                ]
            },
            {
                "id": 2005444,
                "content": [
                    {
                        "username": "Gangeswaran",
                        "content": "Don\\'t underestimate easy problems, Problem looks easy but missed to read the question properly which caused a bit more time than usual.."
                    },
                    {
                        "username": "anacmartins",
                        "content": "i cannot get why s = \"ccccccccc\" and words = [\"c\",\"cc\"] is false."
                    },
                    {
                        "username": "ilyastuit",
                        "content": "I guess we got confused by termin `prefix`, actually while concatenating through the array at some point concatenated string should be exactly equal to `s` string"
                    },
                    {
                        "username": "ilyastuit",
                        "content": "same here"
                    },
                    {
                        "username": "anacmartins",
                        "content": "is it false because in the end there are some characters left on s with no match in words?"
                    },
                    {
                        "username": "youngaryan",
                        "content": "why it expects these two to return false?\\n {\\n\"fajsldfsa\"\\n[\"faj\",\"s\",\"ldfs\",\"afdfs\",\"jfkdlsj\",\"f\"]\\n}\\n{\\n\"aaa\"\\n[\"aa\",\"aaa\",\"fjaklfj\"]\\n}"
                    },
                    {
                        "username": "LakshmanMalviya",
                        "content": "[@youngaryan](/youngaryan) How i am not able to get it \\n"
                    },
                    {
                        "username": "youngaryan",
                        "content": "I approched in a wrong way, i fixed it"
                    }
                ]
            }
        ]
    },
    {
        "title": "Remove Stones to Minimize the Total",
        "question_content": "<p>You are given a <strong>0-indexed</strong> integer array <code>piles</code>, where <code>piles[i]</code> represents the number of stones in the <code>i<sup>th</sup></code> pile, and an integer <code>k</code>. You should apply the following operation <strong>exactly</strong> <code>k</code> times:</p>\n\n<ul>\n\t<li>Choose any <code>piles[i]</code> and <strong>remove</strong> <code>floor(piles[i] / 2)</code> stones from it.</li>\n</ul>\n\n<p><strong>Notice</strong> that you can apply the operation on the <strong>same</strong> pile more than once.</p>\n\n<p>Return <em>the <strong>minimum</strong> possible total number of stones remaining after applying the </em><code>k</code><em> operations</em>.</p>\n\n<p><code>floor(x)</code> is the <b>greatest</b> integer that is <strong>smaller</strong> than or <strong>equal</strong> to <code>x</code> (i.e., rounds <code>x</code> down).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> piles = [5,4,9], k = 2\n<strong>Output:</strong> 12\n<strong>Explanation:</strong>&nbsp;Steps of a possible scenario are:\n- Apply the operation on pile 2. The resulting piles are [5,4,<u>5</u>].\n- Apply the operation on pile 0. The resulting piles are [<u>3</u>,4,5].\nThe total number of stones in [3,4,5] is 12.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> piles = [4,3,6,7], k = 3\n<strong>Output:</strong> 12\n<strong>Explanation:</strong>&nbsp;Steps of a possible scenario are:\n- Apply the operation on pile 2. The resulting piles are [4,3,<u>3</u>,7].\n- Apply the operation on pile 3. The resulting piles are [4,3,3,<u>4</u>].\n- Apply the operation on pile 0. The resulting piles are [<u>2</u>,3,3,4].\nThe total number of stones in [2,3,3,4] is 12.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= piles.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= piles[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1390254,
                "title": "java-c-python-heap-solution-o-klogn",
                "content": "# **Explanation**\\nUse a max heap.\\nEach time pop the max value `a`,\\nremove `a / 2` from the number of stones `res`\\nand push back the ceil half `a - a / 2` to the heap.\\nRepeat this operation `k` times.\\n<br>\\n\\n# **Complexity**\\nTime `O(n + klogn)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\nTime O(nlogn)\\n```java\\n    public int minStoneSum(int[] A, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)->b - a);\\n        int res = 0;\\n        for (int a : A) {\\n            pq.add(a);\\n            res += a;\\n        }\\n        while (k-- > 0) {\\n            int a = pq.poll();\\n            pq.add(a - a / 2);\\n            res -= a / 2;\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int minStoneSum(vector<int>& A, int k) {\\n        priority_queue<int> pq(A.begin(), A.end());\\n        int res = accumulate(A.begin(), A.end(), 0);\\n        while (k--) {\\n            int a = pq.top();\\n            pq.pop();\\n            pq.push(a - a / 2);\\n            res -= a / 2;\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def minStoneSum(self, A, k):\\n        A = [-a for a in A]\\n        heapq.heapify(A)\\n        for i in xrange(k):\\n            heapq.heapreplace(A, A[0] / 2)\\n        return -sum(A)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minStoneSum(int[] A, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)->b - a);\\n        int res = 0;\\n        for (int a : A) {\\n            pq.add(a);\\n            res += a;\\n        }\\n        while (k-- > 0) {\\n            int a = pq.poll();\\n            pq.add(a - a / 2);\\n            res -= a / 2;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int minStoneSum(vector<int>& A, int k) {\\n        priority_queue<int> pq(A.begin(), A.end());\\n        int res = accumulate(A.begin(), A.end(), 0);\\n        while (k--) {\\n            int a = pq.top();\\n            pq.pop();\\n            pq.push(a - a / 2);\\n            res -= a / 2;\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def minStoneSum(self, A, k):\\n        A = [-a for a in A]\\n        heapq.heapify(A)\\n        for i in xrange(k):\\n            heapq.heapreplace(A, A[0] / 2)\\n        return -sum(A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1390459,
                "title": "c-using-priority-queue-easy-to-understand",
                "content": "The idea is to apply the given operation on the largest pile of stones to get the minimum number of stones in the end. To always get the largest element, we use priority queues. \\n```\\n  int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq(piles.begin(),piles.end()); //will copy the vector to the priority queue \\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            int tp=pq.top(); //top element will always be the largest element\\n            pq.pop();\\n            tp-=(tp/2);   \\n            pq.push(tp);\\n        }\\n        while(!pq.empty()){\\n            ans+=pq.top();   //adding the left stones, after k operations\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n```\\nThe time complexity would be:\\n1. Creation of priority queue takes O(n) time.\\n2.  i.)  the for loop is running k times i.e  O(k).\\n     ii.) the insertion and deletion in a priority queue takes O(logn) time.\\n3. Traversing the priority queue to get the answer and deleting the top most element is taking O(nlogn) time.\\n\\nHence the total time complexity is O(n)+O(klogn)+O(nlogn)\\n=> **O((n+k) logn)**\\n\\nSpace Complexity: O(n) because of the priority queue.\\n \\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n  int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq(piles.begin(),piles.end()); //will copy the vector to the priority queue \\n        int ans=0;\\n        for(int i=0;i<k;i++){\\n            int tp=pq.top(); //top element will always be the largest element\\n            pq.pop();\\n            tp-=(tp/2);   \\n            pq.push(tp);\\n        }\\n        while(!pq.empty()){\\n            ans+=pq.top();   //adding the left stones, after k operations\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390207,
                "title": "python3-priority-queue",
                "content": "\\n```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        pq = [-x for x in piles]\\n        heapify(pq)\\n        for _ in range(k): heapreplace(pq, pq[0]//2)\\n        return -sum(pq)\\n```\\n\\nThe solutions for weekly 255 can be found in this [commit](https://github.com/gaosanyong/leetcode/commit/312849ed66e5ad76fa278cbb34dd57772fb3ceeb).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        pq = [-x for x in piles]\\n        heapify(pq)\\n        for _ in range(k): heapreplace(pq, pq[0]//2)\\n        return -sum(pq)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390187,
                "title": "c-using-max-heap-priority-queue",
                "content": "***Why Heap ? Easy TC Explain . Simple and clean YouTube vide0 :***\\nhttps://www.youtube.com/watch?v=uodyPJ8zUVc\\n\\n```\\n/*\\n    You just need to greedily do the operation to largest piles\\n    in order to get the least total\\n    \\n    Heap is the best DS to access the largest value in O(1) time\\n    So use max-heap\\n\\t\\n\\tTime complexity : O((k+n)*log(n))\\n*/\\n\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int sum = accumulate(begin(piles), end(piles), 0);\\n        \\n        priority_queue<int> pq(begin(piles), end(piles)); //O(nlog(n))\\n\\t\\t//But note that there is a way to construct Heap from array in O(n)\\n        \\n        while(!pq.empty() && k--) { //O(klog(n))\\n            int curr = pq.top();\\n            pq.pop();\\n            \\n            sum     -= floor(curr/2);\\n            curr    -= floor(curr/2);\\n            \\n            pq.push(curr);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    You just need to greedily do the operation to largest piles\\n    in order to get the least total\\n    \\n    Heap is the best DS to access the largest value in O(1) time\\n    So use max-heap\\n\\t\\n\\tTime complexity : O((k+n)*log(n))\\n*/\\n\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int sum = accumulate(begin(piles), end(piles), 0);\\n        \\n        priority_queue<int> pq(begin(piles), end(piles)); //O(nlog(n))\\n\\t\\t//But note that there is a way to construct Heap from array in O(n)\\n        \\n        while(!pq.empty() && k--) { //O(klog(n))\\n            int curr = pq.top();\\n            pq.pop();\\n            \\n            sum     -= floor(curr/2);\\n            curr    -= floor(curr/2);\\n            \\n            pq.push(curr);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390178,
                "title": "c-pq-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n        for(auto p : piles) pq.push(p);\\n        while(k--) {\\n            int n = pq.top();\\n            pq.pop();\\n            pq.push(n - n / 2);\\n        }\\n        int sum = 0;\\n        while(pq.size()) {\\n            sum += pq.top(); pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n        for(auto p : piles) pq.push(p);\\n        while(k--) {\\n            int n = pq.top();\\n            pq.pop();\\n            pq.push(n - n / 2);\\n        }\\n        int sum = 0;\\n        while(pq.size()) {\\n            sum += pq.top(); pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390637,
                "title": "priority-queue",
                "content": "On each step we want to remove as many stones as possible, so we pick the largets pile.\\n\\nWe can track piles and get the largest one using max heap.\\n\\n#### Approach 1: Array-based heap\\n**C++**\\n```cpp\\nint minStoneSum(vector<int>& p, int k) {\\n    make_heap(begin(p), end(p));\\n    while (--k >= 0) {\\n        pop_heap(begin(p), end(p));\\n        p.back() -= p.back() / 2;\\n        push_heap(begin(p), end(p));\\n    }\\n    return accumulate(begin(p), end(p), 0);\\n}\\n```\\n\\n#### Approach 2: Priority queue\\n**C++**\\n```cpp\\nint minStoneSum(vector<int>& piles, int k) {\\n    int total = accumulate(begin(piles), end(piles), 0);\\n    priority_queue<int> p(begin(piles), end(piles));\\n    while (--k >= 0) {\\n        auto st = p.top(); p.pop();\\n        total -= st / 2;\\n        p.push((st + 1) / 2);\\n    }\\n    return total;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minStoneSum(vector<int>& p, int k) {\\n    make_heap(begin(p), end(p));\\n    while (--k >= 0) {\\n        pop_heap(begin(p), end(p));\\n        p.back() -= p.back() / 2;\\n        push_heap(begin(p), end(p));\\n    }\\n    return accumulate(begin(p), end(p), 0);\\n}\\n```\n```cpp\\nint minStoneSum(vector<int>& piles, int k) {\\n    int total = accumulate(begin(piles), end(piles), 0);\\n    priority_queue<int> p(begin(piles), end(piles));\\n    while (--k >= 0) {\\n        auto st = p.top(); p.pop();\\n        total -= st / 2;\\n        p.push((st + 1) / 2);\\n    }\\n    return total;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2961074,
                "title": "2-approach-sorting-priority-queue",
                "content": "# Intuition\\n1. Brute Force\\n2. Priority Queue\\n\\n# Approach TLE\\nBRUTE FORCE : find the greatest element and replace it with its floor and again find the greatest element until the count of k become zero.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        sort(piles.begin(),piles.end());\\n        int i=piles.size()-1;\\n                while(k>0)\\n                {\\n                    piles[i]=(piles[i]-piles[i]/2);\\n                     sort(piles.begin(),piles.end());\\n                    k--;\\n                }\\n             return  accumulate(piles.begin(), piles.end(), 0); \\n    }\\n};\\n```\\n# Approach  O((n+k) logn)\\nUsing Priority queue ;\\n1. insert values of piles in priority queue \\n2. reduce the  value of top of the queue by the r.top()-r.top()/2 for k times\\n3. return the sum of the priority queue\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>r;\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            r.push(piles[i]);\\n        }\\n         for(int i=0;i<piles.size();i++)\\n         while(k>0)\\n        {\\n            int le= r.top();\\n            r.pop();\\n            le =le -le/2;\\n            r.push(le);\\n            k--;\\n        }\\n        int sum=0;\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            sum=sum+r.top();\\n            r.pop();\\n        }\\n        return sum;\\n       \\n    }\\n};\\n```\\n\\n# DO NOT FORGET TO UPVOTE IF YOU LIKE THE SOLUTION\\u2B06\\uFE0F",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        sort(piles.begin(),piles.end());\\n        int i=piles.size()-1;\\n                while(k>0)\\n                {\\n                    piles[i]=(piles[i]-piles[i]/2);\\n                     sort(piles.begin(),piles.end());\\n                    k--;\\n                }\\n             return  accumulate(piles.begin(), piles.end(), 0); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>r;\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            r.push(piles[i]);\\n        }\\n         for(int i=0;i<piles.size();i++)\\n         while(k>0)\\n        {\\n            int le= r.top();\\n            r.pop();\\n            le =le -le/2;\\n            r.push(le);\\n            k--;\\n        }\\n        int sum=0;\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            sum=sum+r.top();\\n            r.pop();\\n        }\\n        return sum;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390274,
                "title": "java-max-heap-solution-with-algorithm-and-explanation",
                "content": "*------Please **upvote!** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n**Algorithm:**\\n\\nThink Greedily \\u2013 if we remove stones from the biggest piles first, we will get the optimal result, so the data structure that comes to mind is Max Heap.\\n\\n1.\\tCreate a max heap.\\n2.\\tPush all the piles [i] into the heap.\\n3.\\tIterate until k > 0.\\n4.\\tPop from the heap and decrement the value by floor (val / 2) and push the resultant value back in to the heap.\\n5.\\tFinally, pop all the remaining elements in the heap and total them and return the sum.\\n\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        Queue <Integer> heap = new PriorityQueue (new Comparator <Integer> () {\\n           public int compare (Integer a, Integer b) {\\n               if (a < b)\\n                   return 1;\\n               else if (a > b)\\n                   return -1;\\n               else\\n                   return 0;\\n           } \\n        });\\n        for (int val : piles)\\n            heap.offer (val);\\n        while (k-- > 0) {\\n            int stones = heap.poll ();\\n            stones -= (int) (Math.floor (stones / 2));\\n            heap.offer (stones);\\n        }\\n        int sum = 0;\\n        while (!heap.isEmpty ())\\n            sum += heap.poll ();\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        Queue <Integer> heap = new PriorityQueue (new Comparator <Integer> () {\\n           public int compare (Integer a, Integer b) {\\n               if (a < b)\\n                   return 1;\\n               else if (a > b)\\n                   return -1;\\n               else\\n                   return 0;\\n           } \\n        });\\n        for (int val : piles)\\n            heap.offer (val);\\n        while (k-- > 0) {\\n            int stones = heap.poll ();\\n            stones -= (int) (Math.floor (stones / 2));\\n            heap.offer (stones);\\n        }\\n        int sum = 0;\\n        while (!heap.isEmpty ())\\n            sum += heap.poll ();\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961092,
                "title": "c-heap-priority-queue-intuitive-solution",
                "content": "# Intuition\\nTo get maximum value each time we need to use a priority queue (max-heap).\\n\\n# Approach\\nPut all elements in a priority queue and for k number of times, we take maximum element from the queue and apply operation (floor(piles[i]/2)) then put remaining value(stones) in the queue. At last, we sum-up all the values available in the queue.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) \\n    {\\n        //use max-heap priority queue to get maximum values from piles\\n        priority_queue<int> pq; \\n        for(auto &it:piles) pq.push(it); //put all elements in the priority queue\\n\\n        int n;\\n        while(k-- && !pq.empty()) //apply operation k times\\n        {\\n            n = pq.top(); pq.pop(); //take max element\\n            n = n-n/2; //remove stones\\n            pq.push(n); //put remaining stones\\n        }\\n\\n        int sum=0;\\n        while(!pq.empty()) //count total number of stones\\n        {\\n            sum += pq.top(); pq.pop();\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) \\n    {\\n        //use max-heap priority queue to get maximum values from piles\\n        priority_queue<int> pq; \\n        for(auto &it:piles) pq.push(it); //put all elements in the priority queue\\n\\n        int n;\\n        while(k-- && !pq.empty()) //apply operation k times\\n        {\\n            n = pq.top(); pq.pop(); //take max element\\n            n = n-n/2; //remove stones\\n            pq.push(n); //put remaining stones\\n        }\\n\\n        int sum=0;\\n        while(!pq.empty()) //count total number of stones\\n        {\\n            sum += pq.top(); pq.pop();\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390561,
                "title": "python-3-heap-explanation",
                "content": "### Explanation\\n- Always pick the maximum number to reduce\\n- Use a max-heap to help\\n### Implementation\\n```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        heap = [-p for p in piles]\\n        heapq.heapify(heap)\\n        for _ in range(k):\\n            cur = -heapq.heappop(heap)\\n            heapq.heappush(heap, -(cur-cur//2))\\n        return -sum(heap)            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        heap = [-p for p in piles]\\n        heapq.heapify(heap)\\n        for _ in range(k):\\n            cur = -heapq.heappop(heap)\\n            heapq.heappush(heap, -(cur-cur//2))\\n        return -sum(heap)            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961518,
                "title": "javascript-4-lines-greedy-time-o-n-100-space-o-1-100",
                "content": "# Approach\\n1. Make a `count` array (max size: 10\\u2075), where `count[i]` is the # of piles with `i` stones.\\n2. Iterate through `count` starting from the highest `i`. While a given `count[i] > 0`:\\n    1. If `k > 0`: decrement `k`, decrement `count[i]` & increment `count[ceil(i/2)]`.\\n    2. Else: add `i` to sum & decrement `count[i]`.\\n3. Return sum.\\n\\n# Complexity\\n- Time complexity: O(n), beats 100%\\n- Space complexity: O(1), beats 100%\\n\\n# Code\\n```\\nconst minStoneSum = ( piles, k ) => {\\n    let c = Array(10001).fill(0), s = 0\\n    piles.forEach( i => c[i]++ )\\n    for ( let i = c.length-1; i > 0; i-- )\\n        while ( c[i]-- > 0 )\\n            k-- > 0 ? c[Math.ceil(i/2)]++ : s += i\\n    return s\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nconst minStoneSum = ( piles, k ) => {\\n    let c = Array(10001).fill(0), s = 0\\n    piles.forEach( i => c[i]++ )\\n    for ( let i = c.length-1; i > 0; i-- )\\n        while ( c[i]-- > 0 )\\n            k-- > 0 ? c[Math.ceil(i/2)]++ : s += i\\n    return s\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390166,
                "title": "java-priorityqueue-max-heap-greedy-with-explanation",
                "content": "* To get the minimum sum, we will need to remove highest possible number/2 , And the highest possible number/2 will be of the current highest number.\\n* Thus, this means we will need to calculate max after every update, which can lead to O(n^2) time.\\n* To reduce the time we can use a max-heap data structure, which will give us max in constant time.\\n\\n**Steps:**\\n1. Use the heap.\\n2. Each time pop the max,\\n3. Add back Floor half of it.\\n4. Calculate Sum and return.\\n\\n\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n        for(int i : piles){\\n            pq.add(i);\\n        }\\n        \\n        while(k > 0 && !pq.isEmpty()){\\n            int temp = pq.poll();\\n            temp -= (int)Math.floor(temp/2);\\n            pq.add(temp);\\n            k--;\\n        }\\n        \\n        int sum = 0;\\n        while(!pq.isEmpty())sum += pq.poll();\\n        \\n        return sum;\\n    }\\n}\\n```\\n**Time : O(nlogn)\\nSpace : O(n)**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n        for(int i : piles){\\n            pq.add(i);\\n        }\\n        \\n        while(k > 0 && !pq.isEmpty()){\\n            int temp = pq.poll();\\n            temp -= (int)Math.floor(temp/2);\\n            pq.add(temp);\\n            k--;\\n        }\\n        \\n        int sum = 0;\\n        while(!pq.isEmpty())sum += pq.poll();\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960790,
                "title": "easy-solution-direct-approach-c",
                "content": "# Intuition\\nTo minimize the stones you have to remove the max values you can remove. Taking the floor of bigger values will give you the max number of stones , and to remove the stones k time and always keeping the highest at top we use priority queue.\\n\\n# Approach\\n1. Insert the values in priority queue\\n2. Keep removing stones and taking floor and inserting them back in until you have moves remaining\\n3. Sum up the remaining stones and return the answer.\\n\\n# Complexity\\n- Time complexity:O(KlogN + N)\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq(piles.begin() , piles.end());\\n        while(k > 0){\\n            auto top = pq.top();\\n            pq.pop();\\n            int val = floor(top/2);\\n            top -= val;\\n            pq.push(top);\\n            k--;\\n        }\\n        int ans = 0;\\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq(piles.begin() , piles.end());\\n        while(k > 0){\\n            auto top = pq.top();\\n            pq.pop();\\n            int val = floor(top/2);\\n            top -= val;\\n            pq.push(top);\\n            k--;\\n        }\\n        int ans = 0;\\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390462,
                "title": "c-priority-queue-heap-clear-explanation",
                "content": "**Idea** \\n\\n* Given we need to minimize the total number of stone in piles. Thus at every step we need to pick a maximum pile and reduce it.\\n* Since it is given we need to take maximum from the given piles at each step, first thing that should comes to your mind is can I use a heap for this. Lets give it a try. \\n* Next first push all elements to heap. Now, try taking out the top most element which will also be the maximum element i.e top element of heap\\n* From this maximum pile, we need to remove floor(pile/2). Thus it becomes\\n\\t* *pile -= pile/2* \\n\\t* again if pile is not zero, put that into the heap. Since there may be a case when this reduced pile size can be greater than remaining elements in heap. \\n\\t* continue poping elements k times since need exact k operations.\\n* In the end simple pop remaining elements from heap and add to get minimum required total stones.\\n\\nNote : *In C++ we use priority_queue for max heap. In case you are new to it*\\n\\n**Code:**\\n\\n```\\nint minStoneSum(vector<int>& piles, int k) {\\n        \\n\\tpriority_queue<int, vector<int>> pq;\\n\\t\\n\\tfor(auto& pile : piles) pq.push(pile);\\n\\n\\twhile(pq.size() && k--)\\n\\t{\\n\\t\\tint pile = pq.top(); pq.pop();\\n\\t\\tpile -= pile/2;\\n\\t\\tif(pile) pq.push(pile);\\n\\t}\\n\\n\\tint totalPile = 0;\\n\\twhile(pq.size())\\n\\t{\\n\\t\\ttotalPile += pq.top();\\n\\t\\tpq.pop();\\n\\t}\\n\\treturn totalPile;\\n}\\n```\\n\\nTime : O(k * logN)\\nSpace : O(N) as we put all elements into the heap first.\\n\\nI hope this was clear, and if you understood do upvotes :) !!",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint minStoneSum(vector<int>& piles, int k) {\\n        \\n\\tpriority_queue<int, vector<int>> pq;\\n\\t\\n\\tfor(auto& pile : piles) pq.push(pile);\\n\\n\\twhile(pq.size() && k--)\\n\\t{\\n\\t\\tint pile = pq.top(); pq.pop();\\n\\t\\tpile -= pile/2;\\n\\t\\tif(pile) pq.push(pile);\\n\\t}\\n\\n\\tint totalPile = 0;\\n\\twhile(pq.size())\\n\\t{\\n\\t\\ttotalPile += pq.top();\\n\\t\\tpq.pop();\\n\\t}\\n\\treturn totalPile;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390223,
                "title": "c-sweet-simple-o-k-logn",
                "content": "1. put all in a priority queue\\n2. pick  the max, remove floor of its half, then put it back\\n3. repeat step 2, k times\\n```\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> q;  int x,sum=0;\\n        for(auto a:piles)q.push(a);\\n        while(k--){\\n            x=q.top();q.pop(); //take the  max\\n            x-=floor(x/2);  //remove its half\\n            q.push(x);   //put it back\\n        }\\n        while(!q.empty()){\\n            sum+=q.top();q.pop();    //take the sum\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> q;  int x,sum=0;\\n        for(auto a:piles)q.push(a);\\n        while(k--){\\n            x=q.top();q.pop(); //take the  max\\n            x-=floor(x/2);  //remove its half\\n            q.push(x);   //put it back\\n        }\\n        while(!q.empty()){\\n            sum+=q.top();q.pop();    //take the sum\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2962633,
                "title": "java-heap",
                "content": "# Intuition\\nWe want to continuously take from the biggest number because if `a > b` then `a/2 > b/2`.\\n\\nA `priority queue (heap)` allows us to take the biggest number with `logn` complexity.\\n\\nSo we simply need to do what is asked. Take the biggest number, remove `floor(x/2)` from it and put `x - floor(x/2)` back into the pile, as we can use the same element more than once.\\n\\n\\n\\n# Complexity\\n`O(n + klogn)`\\nO(n) - for heapfying\\nO(klogn) - the main iteration.\\n\\nNote: The way I built the heap here is `nlogn`, but one could heapify an array in O(n) time.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        Queue<Integer> p = new PriorityQueue<>((a, b) -> b-a);\\n        int s = 0; // total sum\\n        int d = 0; // delta removed\\n\\n        for (int x : piles) {\\n            s += x;\\n            p.offer(x);\\n        }\\n        while (k >0) {\\n            int c = p.poll();\\n            int x = c/2;\\n            d += x;\\n            p.offer(c-x);\\n            k--;\\n        }\\n        return s - d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        Queue<Integer> p = new PriorityQueue<>((a, b) -> b-a);\\n        int s = 0; // total sum\\n        int d = 0; // delta removed\\n\\n        for (int x : piles) {\\n            s += x;\\n            p.offer(x);\\n        }\\n        while (k >0) {\\n            int c = p.poll();\\n            int x = c/2;\\n            d += x;\\n            p.offer(c-x);\\n            k--;\\n        }\\n        return s - d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961912,
                "title": "c-max-heap-priority-queue-commented-solution-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) \\n    {\\n        int n = piles.size();\\n        \\n        // it will give max stone value at top of the queue each time\\n        priority_queue<int> pq;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push(piles[i]);\\n        }\\n        \\n        while(!pq.empty() && k)\\n        {\\n            int top = pq.top();\\n            pq.pop();\\n            \\n            pq.push(((top+1)/2));                   // given condition\\n            k--;                                    // decrease the no. of operations after each operation\\n        }\\n        \\n        int cnt=0;\\n        while(!pq.empty())\\n        {\\n            cnt += pq.top();\\n            pq.pop();\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) \\n    {\\n        int n = piles.size();\\n        \\n        // it will give max stone value at top of the queue each time\\n        priority_queue<int> pq;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            pq.push(piles[i]);\\n        }\\n        \\n        while(!pq.empty() && k)\\n        {\\n            int top = pq.top();\\n            pq.pop();\\n            \\n            pq.push(((top+1)/2));                   // given condition\\n            k--;                                    // decrease the no. of operations after each operation\\n        }\\n        \\n        int cnt=0;\\n        while(!pq.empty())\\n        {\\n            cnt += pq.top();\\n            pq.pop();\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961158,
                "title": "priority-queue-easy-to-understand-beginner-s-friendly-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just want to find the maximum element of the piles array k number of times and just replace it with ceil of its half.\\nNote :- ceil means \\n                    if element is even then do element / 2.\\n                    else do (element / 2) + 1.\\nAfter doing this operation we will simply return the sum of all the \\nelements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo getting maximum element each time we will store it in prioriy queue and we know that priority queue by default returns minimum element during poll and peek operation so we reverse its order during the creation of priority queue itself.\\nAfter that we will call poll operation and replace it by ceil(element / 2) k number of times.\\nAfter doing this operation we will simply return the sum of all the elements of our priority queue.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n// during peek and poll operation we get minimum element and to\\n// reverse this we use (x, y) -> Integer.compare(y, x) operation\\n// during creation of our priority queue\\n        PriorityQueue<Integer> q = new PriorityQueue<>((x, y) -> Integer.compare(y, x));\\n\\n// here we add all  the elements of piles to our priority queue\\n// you can also use q.add method instead of q.offer method\\n        for(int i = 0; i < piles.length; ++i){\\n            q.offer(piles[i]);\\n        }\\n// we simply take the maximum elements of priority queue and half it \\n// and store it in the priority queue\\n        while(k-- > 0){\\n            q.offer(q.peek() - q.poll() / 2);\\n        }\\n        int ans = 0;     // used to store the result\\n// finding the sum of all the elements of queue after performing the \\n// operation k number of times\\n        while(! q.isEmpty()){\\n            ans += q.poll();\\n        }\\n        return ans;\\n    }\\n}\\n// This code is contributed by Sunil Kumar\\n// Please upvote if you like the answer \\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n// during peek and poll operation we get minimum element and to\\n// reverse this we use (x, y) -> Integer.compare(y, x) operation\\n// during creation of our priority queue\\n        PriorityQueue<Integer> q = new PriorityQueue<>((x, y) -> Integer.compare(y, x));\\n\\n// here we add all  the elements of piles to our priority queue\\n// you can also use q.add method instead of q.offer method\\n        for(int i = 0; i < piles.length; ++i){\\n            q.offer(piles[i]);\\n        }\\n// we simply take the maximum elements of priority queue and half it \\n// and store it in the priority queue\\n        while(k-- > 0){\\n            q.offer(q.peek() - q.poll() / 2);\\n        }\\n        int ans = 0;     // used to store the result\\n// finding the sum of all the elements of queue after performing the \\n// operation k number of times\\n        while(! q.isEmpty()){\\n            ans += q.poll();\\n        }\\n        return ans;\\n    }\\n}\\n// This code is contributed by Sunil Kumar\\n// Please upvote if you like the answer \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960412,
                "title": "daily-leetcoding-challenge-december-day-28",
                "content": "This problem is the Daily LeetCoding Challenge for December, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Greedy + Max Heap\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1404214,
                "title": "javascript-max-heap-solution-heapify-with-detailed-explanation",
                "content": "TLDR:\\nUse a max heap, pop up max pile, discard half, put the rest back into the heap. Keep track of the sum using a global variable through out the whole process. \\n\\nINTUITION: \\nWe need to return the **minimum possible total number of stones** remaining after applying the k operations. \\nThis result can be calculated by reducing the **max** number of stones with each operation. \\nIt\\'s a **picking the leargest element for k times** problem.\\nTIME COMPLEXITY:\\nO(n + klog(n)) \\n//n is the number of piles.\\n\\nO(n): The time complexity of  turning an array into a heap is O(n). (It is usualy called heapify)\\nO(klog(n)): the time complexity of poping an element is log(n). The operation repeated for k times. So the big O is O(k*long(n))\\n\\nSPACE COMPLEXITY:\\nO(n) /\\n/n is the number of piles. The size of the max heap is the space complexity of the whole problem.\\n\\nDATA STRUCTURE PICKING:\\nSince the remaining stone will be added back to the stone piles, **HEAP** is the best data structure. It\\'s because heap maintains an order after each push/pop operation. \\n(If the remaining stone are discarded, a sorted array will be sufficient, and this would be an easy level problem)\\n **MAX HEAP** is used becuase we always want to find the biggest pile.\\n\\nCODE WALK THROUGH:\\n1. Since JS does not have heap, we need to implemented a Heap class, which accepts a comparator. \\uFF08This is moved below the main function to improve reading experience\\uFF09\\n2. In the main function, keep a global variable sum.\\n3. This problem is a **picking the leargest element for k times** problem, so we need a **max heap** . The top element will be the current max in a max heap: stones.\\n4. initialize a max heap by passing a comparator.\\n5. Trun the stone array into a stones heap using the heapify method\\n6. Calculate sum\\n7. Start the operation for `k` times. \\n\\tEach time, get the current max pile. \\n\\tRmove half stones of the pile from `sum`. \\uFF08Math.floor is used according to the porblem description\\uFF09\\n    Put the remainig stone (the new pile) back to the `stones` heap\\n8. return sum\\n\\t\\n\\n\\n\\n\\n```\\n\\n/**\\n main function\\n */\\n\\nvar minStoneSum = function(piles, k) {\\n    let sum = 0;\\n\\t// init a max heap\\n    const stones = new Heap((a, b) => {\\n        return a < b ? 1 : a > b ? -1 : 0;\\n    })\\n    // trun the piles from an array into a heap\\n    stones.heapify(piles);\\n    //calculate sum\\n    for (let pile of piles) {\\n        sum += pile;\\n    }\\n\\t//k times operation\\n    for(let i = 0; i < k; i++) {        \\n\\t\\t// get max, discard half, and put the rest back\\n        let curMax = stones.pop();\\n        sum -= Math.floor(curMax/2);\\n        stones.push(Math.ceil(curMax/2));\\n    }\\n    // answer\\n    return sum;\\n};\\n\\n\\n/**\\n start of the Heap class\\n JS does not have heap, so we have to write it by ourselves\\n */\\n\\nclass Heap {\\n    constructor(compare) {\\n        this.heap = [];\\n        this.compare = compare;\\n        this.size = this.heap.length;\\n    }\\n\\theapify(array) {\\n        this.heap = array;\\n        // bottom up\\n        for(let i = Math.floor(this.heap.length / 2); i >= 0; i--){\\n            this._siftdown(i);\\n        }\\n    }\\n    push(item) {\\n        this.heap.push(item);\\n        this._siftup(this.heap.length - 1);\\n    }\\n    \\n    pop() {\\n        if (this.heap.length === 0) {\\n            return undefined;\\n        }\\n        this._swap(0, this.heap.length - 1);\\n        let item = this.heap.pop();\\n        if (this.heap.length >= 1) {\\n            this._siftdown(0);\\n        }\\n        return item;\\n    }\\n    top() {\\n        return this.heap[0]\\n    }\\n    \\n    _swap(index1, index2) {\\n        [this.heap[index1], this.heap[index2]] = [this.heap[index2], this.heap[index1]];\\n    }\\n    \\n    _siftup(index) {\\n        while (index > 0) {\\n            let parentIdx = Math.floor((index - 1) / 2);\\n            if (this.compare(this.heap[parentIdx], this.heap[index]) === 1) {\\n                this._swap(parentIdx, index);\\n                index = parentIdx;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    _siftdown(index) {\\n        while (true) {\\n            let left = index * 2 + 1;\\n            let right = index * 2 + 2;           \\n            let minIndex = index;\\n            \\n            if (left < this.heap.length && this.compare(this.heap[index], this.heap[left]) === 1) {\\n                minIndex = left;\\n            }\\n            \\n            if (right < this.heap.length && this.compare(this.heap[minIndex], this.heap[right]) === 1) {\\n                minIndex = right;\\n            }\\n            \\n            if (minIndex === index) {\\n                break;\\n            }\\n            \\n            this._swap(index, minIndex);\\n            index = minIndex;\\n        }\\n    }\\n}\\n\\n/**\\n end of the Heap class\\n */\\n \\n",
                "solutionTags": [],
                "code": "TLDR:\\nUse a max heap, pop up max pile, discard half, put the rest back into the heap. Keep track of the sum using a global variable through out the whole process. \\n\\nINTUITION: \\nWe need to return the **minimum possible total number of stones** remaining after applying the k operations. \\nThis result can be calculated by reducing the **max** number of stones with each operation. \\nIt\\'s a **picking the leargest element for k times** problem.\\nTIME COMPLEXITY:\\nO(n + klog(n)) \\n//n is the number of piles.\\n\\nO(n): The time complexity of  turning an array into a heap is O(n). (It is usualy called heapify)\\nO(klog(n)): the time complexity of poping an element is log(n). The operation repeated for k times. So the big O is O(k*long(n))\\n\\nSPACE COMPLEXITY:\\nO(n) /\\n/n is the number of piles. The size of the max heap is the space complexity of the whole problem.\\n\\nDATA STRUCTURE PICKING:\\nSince the remaining stone will be added back to the stone piles, **HEAP** is the best data structure. It\\'s because heap maintains an order after each push/pop operation. \\n(If the remaining stone are discarded, a sorted array will be sufficient, and this would be an easy level problem)\\n **MAX HEAP** is used becuase we always want to find the biggest pile.\\n\\nCODE WALK THROUGH:\\n1. Since JS does not have heap, we need to implemented a Heap class, which accepts a comparator. \\uFF08This is moved below the main function to improve reading experience\\uFF09\\n2. In the main function, keep a global variable sum.\\n3. This problem is a **picking the leargest element for k times** problem, so we need a **max heap** . The top element will be the current max in a max heap: stones.\\n4. initialize a max heap by passing a comparator.\\n5. Trun the stone array into a stones heap using the heapify method\\n6. Calculate sum\\n7. Start the operation for `k` times. \\n\\tEach time, get the current max pile. \\n\\tRmove half stones of the pile from `sum`. \\uFF08Math.floor is used according to the porblem description\\uFF09\\n    Put the remainig stone (the new pile) back to the `stones` heap\\n8. return sum\\n\\t\\n\\n\\n\\n\\n```\\n\\n/**\\n main function\\n */\\n\\nvar minStoneSum = function(piles, k) {\\n    let sum = 0;\\n\\t// init a max heap\\n    const stones = new Heap((a, b) => {\\n        return a < b ? 1 : a > b ? -1 : 0;\\n    })\\n    // trun the piles from an array into a heap\\n    stones.heapify(piles);\\n    //calculate sum\\n    for (let pile of piles) {\\n        sum += pile;\\n    }\\n\\t//k times operation\\n    for(let i = 0; i < k; i++) {        \\n\\t\\t// get max, discard half, and put the rest back\\n        let curMax = stones.pop();\\n        sum -= Math.floor(curMax/2);\\n        stones.push(Math.ceil(curMax/2));\\n    }\\n    // answer\\n    return sum;\\n};\\n\\n\\n/**\\n start of the Heap class\\n JS does not have heap, so we have to write it by ourselves\\n */\\n\\nclass Heap {\\n    constructor(compare) {\\n        this.heap = [];\\n        this.compare = compare;\\n        this.size = this.heap.length;\\n    }\\n\\theapify(array) {\\n        this.heap = array;\\n        // bottom up\\n        for(let i = Math.floor(this.heap.length / 2); i >= 0; i--){\\n            this._siftdown(i);\\n        }\\n    }\\n    push(item) {\\n        this.heap.push(item);\\n        this._siftup(this.heap.length - 1);\\n    }\\n    \\n    pop() {\\n        if (this.heap.length === 0) {\\n            return undefined;\\n        }\\n        this._swap(0, this.heap.length - 1);\\n        let item = this.heap.pop();\\n        if (this.heap.length >= 1) {\\n            this._siftdown(0);\\n        }\\n        return item;\\n    }\\n    top() {\\n        return this.heap[0]\\n    }\\n    \\n    _swap(index1, index2) {\\n        [this.heap[index1], this.heap[index2]] = [this.heap[index2], this.heap[index1]];\\n    }\\n    \\n    _siftup(index) {\\n        while (index > 0) {\\n            let parentIdx = Math.floor((index - 1) / 2);\\n            if (this.compare(this.heap[parentIdx], this.heap[index]) === 1) {\\n                this._swap(parentIdx, index);\\n                index = parentIdx;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    _siftdown(index) {\\n        while (true) {\\n            let left = index * 2 + 1;\\n            let right = index * 2 + 2;           \\n            let minIndex = index;\\n            \\n            if (left < this.heap.length && this.compare(this.heap[index], this.heap[left]) === 1) {\\n                minIndex = left;\\n            }\\n            \\n            if (right < this.heap.length && this.compare(this.heap[minIndex], this.heap[right]) === 1) {\\n                minIndex = right;\\n            }\\n            \\n            if (minIndex === index) {\\n                break;\\n            }\\n            \\n            this._swap(index, minIndex);\\n            index = minIndex;\\n        }\\n    }\\n}\\n\\n/**\\n end of the Heap class\\n */\\n \\n",
                "codeTag": "Java"
            },
            {
                "id": 1390349,
                "title": "javascript-greedy-with-max-pq-heap",
                "content": "3772ms\\nidea: greedy, each time operate the max item and put back.\\n```\\nconst minStoneSum = (a, k) => {\\n    let pq = new MaxPriorityQueue({priority: x => x});\\n    for (const e of a) pq.enqueue(e);\\n    while(k--) {\\n        let cur = pq.dequeue().element;\\n        let remove = parseInt(cur / 2);\\n        pq.enqueue(cur - remove);\\n    }\\n    let aa = pq.toArray();\\n    let res = 0;\\n    for (const e of aa) {\\n        res += e.element;\\n    }\\n    return res;\\n};\\n```\\nversion 2: 2971ms\\n```\\nconst minStoneSum = (a, k) => {\\n    let pq = new MaxPriorityQueue({priority: x => x});\\n    for (const e of a) pq.enqueue(e);\\n    while(k--) {\\n        let cur = pq.dequeue().element;\\n        let remove = parseInt(cur / 2);\\n        pq.enqueue(cur - remove);\\n    }\\n    let res = 0;\\n    while(pq.size()) res += pq.dequeue().element; // difference, parse pq directly\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nconst minStoneSum = (a, k) => {\\n    let pq = new MaxPriorityQueue({priority: x => x});\\n    for (const e of a) pq.enqueue(e);\\n    while(k--) {\\n        let cur = pq.dequeue().element;\\n        let remove = parseInt(cur / 2);\\n        pq.enqueue(cur - remove);\\n    }\\n    let aa = pq.toArray();\\n    let res = 0;\\n    for (const e of aa) {\\n        res += e.element;\\n    }\\n    return res;\\n};\\n```\n```\\nconst minStoneSum = (a, k) => {\\n    let pq = new MaxPriorityQueue({priority: x => x});\\n    for (const e of a) pq.enqueue(e);\\n    while(k--) {\\n        let cur = pq.dequeue().element;\\n        let remove = parseInt(cur / 2);\\n        pq.enqueue(cur - remove);\\n    }\\n    let res = 0;\\n    while(pq.size()) res += pq.dequeue().element; // difference, parse pq directly\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390241,
                "title": "java-easy-using-priority-queue",
                "content": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> pq\\n            = new PriorityQueue<Integer>(\\n                Collections.reverseOrder());\\n        int sum  = 0;\\n        for(int i = 0;i<piles.length;i++){\\n            pq.add(piles[i]);\\n            sum+=piles[i];\\n        }\\n        \\n        for(int i = 0;i<k;i++){\\n            int a = pq.remove();\\n            sum-=a;\\n            if(a%2==0){\\n                a = a/2;\\n            }\\n            else{\\n                a = (a+1)/2;\\n            }\\n            sum+=a;\\n            pq.add(a);\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> pq\\n            = new PriorityQueue<Integer>(\\n                Collections.reverseOrder());\\n        int sum  = 0;\\n        for(int i = 0;i<piles.length;i++){\\n            pq.add(piles[i]);\\n            sum+=piles[i];\\n        }\\n        \\n        for(int i = 0;i<k;i++){\\n            int a = pq.remove();\\n            sum-=a;\\n            if(a%2==0){\\n                a = a/2;\\n            }\\n            else{\\n                a = (a+1)/2;\\n            }\\n            sum+=a;\\n            pq.add(a);\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963840,
                "title": "without-using-queue-100-fast-java",
                "content": "# 100 % Faster \\n```\\nclass Solution {\\n    public static int minStoneSum(int[] piles, int k) {\\n        int[] arr = new int[10001];\\n        int max = -1;\\n        for(int i : piles){\\n            arr[i]++;\\n            max = Math.max(max , i);\\n        }\\n        for(int i=max; i>0 && k>0; i--){\\n            while(arr[i]>0 && k>0){\\n                arr[i]--;\\n                arr[(i+1)/2]++;\\n                k--;\\n            }\\n        }\\n        int answer = 0;\\n        for(int i=max; i>0; i--){\\n            answer += arr[i]*i;\\n        }\\n        return answer;\\n    }\\n}\\n```\\n# Using Heap (Priority Queue)\\n```\\nclass Solution {\\n    public static int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int sum = 0;\\n        for(int p: piles){\\n            pq.add(p);\\n            sum += p;\\n        }\\n        while(k-->0){\\n            int num = pq.poll();\\n            pq.add(num - num / 2);\\n            sum -= num/2;\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minStoneSum(int[] piles, int k) {\\n        int[] arr = new int[10001];\\n        int max = -1;\\n        for(int i : piles){\\n            arr[i]++;\\n            max = Math.max(max , i);\\n        }\\n        for(int i=max; i>0 && k>0; i--){\\n            while(arr[i]>0 && k>0){\\n                arr[i]--;\\n                arr[(i+1)/2]++;\\n                k--;\\n            }\\n        }\\n        int answer = 0;\\n        for(int i=max; i>0; i--){\\n            answer += arr[i]*i;\\n        }\\n        return answer;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public static int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int sum = 0;\\n        for(int p: piles){\\n            pq.add(p);\\n            sum += p;\\n        }\\n        while(k-->0){\\n            int num = pq.poll();\\n            pq.add(num - num / 2);\\n            sum -= num/2;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962937,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> q = new PriorityQueue<>((a, b) -> (b - a));\\n        for (int p : piles) {\\n            q.offer(p);\\n        }\\n        while (k-- > 0) {\\n            int p = q.poll();\\n            q.offer((p + 1) >> 1);\\n        }\\n        int ans = 0;\\n        while (!q.isEmpty()) {\\n            ans += q.poll();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> q = new PriorityQueue<>((a, b) -> (b - a));\\n        for (int p : piles) {\\n            q.offer(p);\\n        }\\n        while (k-- > 0) {\\n            int p = q.poll();\\n            q.offer((p + 1) >> 1);\\n        }\\n        int ans = 0;\\n        while (!q.isEmpty()) {\\n            ans += q.poll();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962171,
                "title": "python-o-n-beat-100-bucket-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question stated that `piles[i] <= 10,000`. \\nSo using **bucket sort** will be faster than using a normal sort.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a bucket which represent 0 ~ 10000\\n2. Assign`piles[i]`into the bucket, which`bucket[i]`represent how many `pile i`is left.\\n\\n\\n---\\n3. Run a for-loop of `reversed(bucket)`, i.e. access the largest number first.\\n4. If we have removed stones, we need to re-assign the stone in the bucket.\\n`bucket[i-temp] += 1`\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n 1 loop for create bucket, another loop for removing stones\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nCreate a bucket\\n\\n# Code\\n```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        bucket = [0 for _ in range(10001)]\\n        ans = sum(piles)\\n        for i in piles:\\n            bucket[i] += 1\\n        for i in range(10000, -1, -1):\\n            while bucket[i] > 0 and k > 0:\\n                k -= 1  \\n                bucket[i] -= 1\\n                temp = i // 2\\n                ans -= temp\\n                bucket[i-temp] += 1\\n            if k == 0: \\n                return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        bucket = [0 for _ in range(10001)]\\n        ans = sum(piles)\\n        for i in piles:\\n            bucket[i] += 1\\n        for i in range(10000, -1, -1):\\n            while bucket[i] > 0 and k > 0:\\n                k -= 1  \\n                bucket[i] -= 1\\n                temp = i // 2\\n                ans -= temp\\n                bucket[i-temp] += 1\\n            if k == 0: \\n                return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961818,
                "title": "c-best-solution-100-100-hard-way",
                "content": "Approach\\n<!-- Describe your approach to solving the problem. -->\\n### Store count of piles in a array\\n### traverse from back and you will never miss the largest at any point.\\n Complexity\\n## Time complexity:O(n+k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n## Space complexity: O(1): using 10001*4\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int arr[10001]={0};\\n        for(auto &it :piles){\\n            arr[it]++;\\n        }\\n        int s=0;\\n        for(int i=10000;i>0;i--){\\n            while(arr[i]-->0){\\n                if(k-->0){\\n                int p=i-(int)floor(i/2);\\n                arr[p]++;\\n                }\\n                else\\n                s+=i;\\n            }\\n        }\\nreturn s;\\n    }\\n};\\n// const minStoneSum = ( piles, k ) => {\\n//     let c = Array(10001).fill(0), s = 0\\n//     piles.forEach( i => c[i]++ )\\n//     for ( let i = c.length-1; i > 0; i-- )\\n//         while ( c[i]-- > 0 )\\n//             k-- > 0 ? c[Math.ceil(i/2)]++ : s += i\\n//     return s\\n// }\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Array",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int arr[10001]={0};\\n        for(auto &it :piles){\\n            arr[it]++;\\n        }\\n        int s=0;\\n        for(int i=10000;i>0;i--){\\n            while(arr[i]-->0){\\n                if(k-->0){\\n                int p=i-(int)floor(i/2);\\n                arr[p]++;\\n                }\\n                else\\n                s+=i;\\n            }\\n        }\\nreturn s;\\n    }\\n};\\n// const minStoneSum = ( piles, k ) => {\\n//     let c = Array(10001).fill(0), s = 0\\n//     piles.forEach( i => c[i]++ )\\n//     for ( let i = c.length-1; i > 0; i-- )\\n//         while ( c[i]-- > 0 )\\n//             k-- > 0 ? c[Math.ceil(i/2)]++ : s += i\\n//     return s\\n// }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392285,
                "title": "easy-java-solution-with-easy-explanation",
                "content": "**Java Heap Solution**\\n**Every time we pop a element from heap it will be a max element let\\'s say \\'a\\' we would make it \\'a / 2\\' and push the rest element that is \\'a - a / 2\\'**\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        if(piles == null || piles.length == 0){ //Trivial case if the piles array is null\\n            return 0;\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder()); //Making a max heap that would store the max element always at the top\\n        for(int num : piles){ //Adding every element of the piles array to the heap\\n            pq.add(num);\\n        }\\n        while(k-- > 0){ //Making the top element of the heap = heap / 2 and subtracting it from the top element we got.\\n            int newElement = pq.remove();\\n            newElement = newElement - (int)Math.floor(newElement / 2);\\n            pq.add(newElement);\\n        }\\n        int ans = 0;\\n        while(!pq.isEmpty()){ //Adding every element of the resultant heap\\n            ans += pq.remove();\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**TC = O(n + klogn) **\\n**SC = O(n)**\\n\\n**Please upvote if you like the answer ans explanation (:**",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        if(piles == null || piles.length == 0){ //Trivial case if the piles array is null\\n            return 0;\\n        }\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder()); //Making a max heap that would store the max element always at the top\\n        for(int num : piles){ //Adding every element of the piles array to the heap\\n            pq.add(num);\\n        }\\n        while(k-- > 0){ //Making the top element of the heap = heap / 2 and subtracting it from the top element we got.\\n            int newElement = pq.remove();\\n            newElement = newElement - (int)Math.floor(newElement / 2);\\n            pq.add(newElement);\\n        }\\n        int ans = 0;\\n        while(!pq.isEmpty()){ //Adding every element of the resultant heap\\n            ans += pq.remove();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390268,
                "title": "c-max-heap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<piles.size();i++){\\n            pq.push(piles[i]);\\n        }\\n        \\n        for(int i=0;i<k;i++){\\n            int ele=pq.top();\\n            pq.pop();\\n            \\n            int val=(ele/2)+(ele%2!=0);\\n            // cout << val << \" \";\\n            pq.push(val);\\n        }\\n        \\n        int sum=0;\\n        while(pq.size()>0){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<piles.size();i++){\\n            pq.push(piles[i]);\\n        }\\n        \\n        for(int i=0;i<k;i++){\\n            int ele=pq.top();\\n            pq.pop();\\n            \\n            int val=(ele/2)+(ele%2!=0);\\n            // cout << val << \" \";\\n            pq.push(val);\\n        }\\n        \\n        int sum=0;\\n        while(pq.size()>0){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1390243,
                "title": "javascript-max-heap-o-nlogn",
                "content": "```\\n/**\\n * @param {number[]} piles\\n * @param {number} k\\n * @return {number}\\n */\\nvar minStoneSum = function(piles, k) {\\n    const heap = new Heap(piles);\\n    \\n    let i = 0;\\n    while(i< k){\\n\\t\\n\\t\\t//TAKE THE TOP MAX VALUE TO REDUCE\\n        let top = heap.dequeue();\\n        let updated = top - (~~(top/2));\\n\\t\\t\\n\\t\\t//IF AFTER  UPDATION VALUE IS NOT 0 THEN INSERT AGAIN\\n        if(updated){\\n            heap.enqueue(updated);\\n        }\\n        i++;\\n    }\\n    return  heap.getTree().reduce((acc,v)=> acc+v,0);\\n    \\n};\\n\\n\\nclass Heap{\\n    constructor(list = []){\\n        this.tree = [null];\\n        this.list = list;\\n        this.build();\\n    }\\n    \\n    build(){\\n        for(let priority of this.list)\\n            this.enqueue(priority);\\n    }\\n    \\n    swap(pos1, pos2){\\n        [this.tree[pos1], this.tree[pos2]] = [this.tree[pos2],this.tree[pos1]]\\n    }\\n    \\n    enqueue(priority){\\n        this.tree[this.tree.length] = priority;\\n        let i = this.tree.length - 1, parent = ~~(i/2);\\n        while(i > 1){\\n            if(this.tree[parent] < this.tree[i])\\n                this.swap(parent,i);\\n            i = parent;\\n            parent = ~~(i/2);\\n        }\\n    }\\n    \\n    dequeue(){\\n     let size = this.tree.length - 1, pos = 1;\\n    if(!size) return;\\n\\n\\n    let last = this.tree.pop(), deleted = this.tree[pos];\\n\\n\\n    if(!deleted && last) return last;\\n\\n    this.tree[pos] = last;\\n    this.heapify(pos);\\n    return deleted;\\n    }\\n    \\n    heapify(pos){\\n    \\n        if(pos > this.tree.length) return;\\n        let leftPos = 2*pos, rightPos = 2*pos +1;\\n        \\n        let left = this.tree[leftPos] ? this.tree[leftPos] : -Infinity;\\n        let right = this.tree[rightPos] ? this.tree[rightPos] : -Infinity, minVal = null, minIndex = null;\\n        \\n        if(left > right){\\n            minVal = left;\\n            minIndex = leftPos;\\n        }else{\\n            minVal = right;\\n            minIndex = rightPos\\n        }\\n        if(this.tree[pos] < minVal){\\n            this.swap(pos,minIndex);\\n            this.heapify(minIndex);\\n        }\\n        \\n    }\\n    \\n    getTree(){\\n        return this.tree.slice(1);\\n    }\\n    \\n    getSize(){\\n        return this.tree.length - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} piles\\n * @param {number} k\\n * @return {number}\\n */\\nvar minStoneSum = function(piles, k) {\\n    const heap = new Heap(piles);\\n    \\n    let i = 0;\\n    while(i< k){\\n\\t\\n\\t\\t//TAKE THE TOP MAX VALUE TO REDUCE\\n        let top = heap.dequeue();\\n        let updated = top - (~~(top/2));\\n\\t\\t\\n\\t\\t//IF AFTER  UPDATION VALUE IS NOT 0 THEN INSERT AGAIN\\n        if(updated){\\n            heap.enqueue(updated);\\n        }\\n        i++;\\n    }\\n    return  heap.getTree().reduce((acc,v)=> acc+v,0);\\n    \\n};\\n\\n\\nclass Heap{\\n    constructor(list = []){\\n        this.tree = [null];\\n        this.list = list;\\n        this.build();\\n    }\\n    \\n    build(){\\n        for(let priority of this.list)\\n            this.enqueue(priority);\\n    }\\n    \\n    swap(pos1, pos2){\\n        [this.tree[pos1], this.tree[pos2]] = [this.tree[pos2],this.tree[pos1]]\\n    }\\n    \\n    enqueue(priority){\\n        this.tree[this.tree.length] = priority;\\n        let i = this.tree.length - 1, parent = ~~(i/2);\\n        while(i > 1){\\n            if(this.tree[parent] < this.tree[i])\\n                this.swap(parent,i);\\n            i = parent;\\n            parent = ~~(i/2);\\n        }\\n    }\\n    \\n    dequeue(){\\n     let size = this.tree.length - 1, pos = 1;\\n    if(!size) return;\\n\\n\\n    let last = this.tree.pop(), deleted = this.tree[pos];\\n\\n\\n    if(!deleted && last) return last;\\n\\n    this.tree[pos] = last;\\n    this.heapify(pos);\\n    return deleted;\\n    }\\n    \\n    heapify(pos){\\n    \\n        if(pos > this.tree.length) return;\\n        let leftPos = 2*pos, rightPos = 2*pos +1;\\n        \\n        let left = this.tree[leftPos] ? this.tree[leftPos] : -Infinity;\\n        let right = this.tree[rightPos] ? this.tree[rightPos] : -Infinity, minVal = null, minIndex = null;\\n        \\n        if(left > right){\\n            minVal = left;\\n            minIndex = leftPos;\\n        }else{\\n            minVal = right;\\n            minIndex = rightPos\\n        }\\n        if(this.tree[pos] < minVal){\\n            this.swap(pos,minIndex);\\n            this.heapify(minIndex);\\n        }\\n        \\n    }\\n    \\n    getTree(){\\n        return this.tree.slice(1);\\n    }\\n    \\n    getSize(){\\n        return this.tree.length - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390160,
                "title": "heap-based-solution",
                "content": "```\\nclass Solution {\\n   \\n    public  int minStoneSum(int[] piles, int k)\\n    {\\n    Queue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n     int sum=0;\\n     for(int x = 0; x < piles.length; x++){\\n        pq.add(piles[x]);\\n        sum+=piles[x];\\n     }\\n\\n     for(int i=0;i<k;i++){\\n        int mv = pq.poll();\\n\\n        sum = sum - mv;\\n        int ix = mv % 2 == 0 ? mv / 2 : (mv / 2) + 1;\\n        sum+=ix;\\n        pq.add(ix);\\n     }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   \\n    public  int minStoneSum(int[] piles, int k)\\n    {\\n    Queue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n     int sum=0;\\n     for(int x = 0; x < piles.length; x++){\\n        pq.add(piles[x]);\\n        sum+=piles[x];\\n     }\\n\\n     for(int i=0;i<k;i++){\\n        int mv = pq.poll();\\n\\n        sum = sum - mv;\\n        int ix = mv % 2 == 0 ? mv / 2 : (mv / 2) + 1;\\n        sum+=ix;\\n        pq.add(ix);\\n     }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963180,
                "title": "python3-1354-ms-faster-than-100-00-of-python3-clean-and-easy-to-understand",
                "content": "```\\ndef minStoneSum(self, piles: List[int], k: int) -> int:\\n\\t\\tbucket = [0 for _ in range(10001)]\\n        ans = sum(piles)\\n        for i in piles:\\n            bucket[i] += 1\\n        for i in range(10000, -1, -1):\\n            while bucket[i] > 0 and k > 0:\\n                k -= 1  \\n                bucket[i] -= 1\\n                temp = i // 2\\n                ans -= temp\\n                bucket[i-temp] += 1\\n            if k == 0: \\n                return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef minStoneSum(self, piles: List[int], k: int) -> int:\\n\\t\\tbucket = [0 for _ in range(10001)]\\n        ans = sum(piles)\\n        for i in piles:\\n            bucket[i] += 1\\n        for i in range(10000, -1, -1):\\n            while bucket[i] > 0 and k > 0:\\n                k -= 1  \\n                bucket[i] -= 1\\n                temp = i // 2\\n                ans -= temp\\n                bucket[i-temp] += 1\\n            if k == 0: \\n                return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2962228,
                "title": "javascript-simple-solution-comments",
                "content": "# Approach\\nTo solve this problem, I divided it into three steps: Sorting the piles array descending, remove `floor(piles[i] / 2)` stones **k-times** and return sum of the remaining stones.\\n\\n## 1. Sort pile\\nTo know which pile is the biggest (at index 0) we have to sort the input piles array descending. For this I simply used the already defined sort function of JavaScript:\\n\\n`nums.sort((a, b) => b - a); // Sort nums array descending`\\n\\nThe input array `nums = [5, 4, 9]` will be `[9, 5, 4]`.\\n\\n## 2. Remove stones k-times\\n\\n1. Create a touched arr to store already touched piles\\n2. Loop k-times\\n3. Declare pile variable\\n4. Find biggest pile: Check if touched arr is empty OR amount of stones of first touched pile is smaller than pile at index 0 of piles array\\n    TRUE: shift pile from piles array\\n    FALSE: shift pile from touched array\\n5. Substract/remove `floor(piles[i] / 2)` stones from biggest pile\\n6. Push pile to touched array\\n\\n## 3. Return sum of remaining stones\\nTo get the sum concat both arrays (piles & touched) and create sum by using the already defined reduce function from JavaScript.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} piles\\n * @param {number} k\\n * @return {number}\\n */\\nvar minStoneSum = function(piles, k) {\\n    piles.sort((a, b) => b - a); // Sort piles to have biggest numbers of stones at index 0\\n    const touched = []; // Initialize touched arr\\n    while(k--) { // Operate k-times till 0\\n        let pile; // Declare pile variable\\n        if (touched.length === 0 || touched[0] < piles[0]) { // Check if length of touched arr is 0 or touched at 0 is smaller than piles at 0\\n            pile = piles.shift(); // Shift pile from piles arr\\n        } else {\\n            pile = touched.shift(); // Shift pile from touched arr\\n        }\\n        pile -= Math.floor(pile / 2); // Substract/remove floor(piles[i] / 2) stones from biggest pile\\n        touched.push(pile); // Push tile to touched arr\\n    }\\n    return piles.concat(touched).reduce((a, b) => a + b, 0); // Return total amount (sum) of piles\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} piles\\n * @param {number} k\\n * @return {number}\\n */\\nvar minStoneSum = function(piles, k) {\\n    piles.sort((a, b) => b - a); // Sort piles to have biggest numbers of stones at index 0\\n    const touched = []; // Initialize touched arr\\n    while(k--) { // Operate k-times till 0\\n        let pile; // Declare pile variable\\n        if (touched.length === 0 || touched[0] < piles[0]) { // Check if length of touched arr is 0 or touched at 0 is smaller than piles at 0\\n            pile = piles.shift(); // Shift pile from piles arr\\n        } else {\\n            pile = touched.shift(); // Shift pile from touched arr\\n        }\\n        pile -= Math.floor(pile / 2); // Substract/remove floor(piles[i] / 2) stones from biggest pile\\n        touched.push(pile); // Push tile to touched arr\\n    }\\n    return piles.concat(touched).reduce((a, b) => a + b, 0); // Return total amount (sum) of piles\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2961191,
                "title": "c-simple-greedy-approach-using-max-heap",
                "content": "\\n\\n# Approach\\n<!-- Simple greedy approach-->\\n\\n# Complexity\\n- Time complexity: O(nlogn)  inserting n elements in priority queue\\n- Space complexity: 0(n) priority queue\\n<!-- 0(n) priority queue -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> q; //max heap for fetching max element\\n        for(int i=0;i<piles.size();i++){\\n            q.push(piles[i]);\\n        }\\n\\n        //performing operation on max element to get lowest sum\\n\\n        while(k--){\\n            int d=q.top();\\n            q.pop();\\n            d=d-floor(d/2);\\n            q.push(d);\\n        }\\n        int sum=0;\\n        while(!q.empty()){\\n            sum+=q.top();\\n            q.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> q; //max heap for fetching max element\\n        for(int i=0;i<piles.size();i++){\\n            q.push(piles[i]);\\n        }\\n\\n        //performing operation on max element to get lowest sum\\n\\n        while(k--){\\n            int d=q.top();\\n            q.pop();\\n            d=d-floor(d/2);\\n            q.push(d);\\n        }\\n        int sum=0;\\n        while(!q.empty()){\\n            sum+=q.top();\\n            q.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960860,
                "title": "simplest-java-solution-100-using-max-heap",
                "content": "**JAVA MAX HEAP SOLUTION**\\n# Code\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer>pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i=0;i<piles.length;i++){\\n            pq.offer(piles[i]);\\n        }\\n        while(k>0){\\n            int x=pq.poll();\\n            pq.offer((x+1)/2);\\n            k--;\\n        }\\n        int sum=0;\\n        while(!pq.isEmpty()){\\n            sum+=pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer>pq=new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i=0;i<piles.length;i++){\\n            pq.offer(piles[i]);\\n        }\\n        while(k>0){\\n            int x=pq.poll();\\n            pq.offer((x+1)/2);\\n            k--;\\n        }\\n        int sum=0;\\n        while(!pq.isEmpty()){\\n            sum+=pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960500,
                "title": "python-priority-queue-beats-90",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a max heap to retrieve the max element every time. We will then run k operations until we have our minimum sum. We must push a negative value because heapq in python is default to minheap.\\n# Code\\n```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        max_heap = []\\n\\n        for pile in piles:\\n            heapq.heappush(max_heap, -pile)\\n\\n        while k != 0:\\n            stone = heapq.heappop(max_heap)\\n            stone = math.ceil(stone * -1 / 2)\\n            heapq.heappush(max_heap, -stone)\\n            k -= 1\\n\\n        return -sum(max_heap)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        max_heap = []\\n\\n        for pile in piles:\\n            heapq.heappush(max_heap, -pile)\\n\\n        while k != 0:\\n            stone = heapq.heappop(max_heap)\\n            stone = math.ceil(stone * -1 / 2)\\n            heapq.heappush(max_heap, -stone)\\n            k -= 1\\n\\n        return -sum(max_heap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632239,
                "title": "c-priority-queue",
                "content": "```\\npublic class Solution\\n{\\n    public int MinStoneSum(int[] piles, int k)\\n    {\\n        int sum = piles.Sum();\\n        PriorityQueue<int,int> pq = new PriorityQueue<int,int>();\\n        for (int i = 0; i < piles.Length; i ++)\\n        {\\n            pq.Enqueue(piles[i],0-piles[i]);\\n        }\\n        for (int i = 0; i < k; i ++)\\n        {\\n            int sub = pq.Peek() / 2;\\n            sum -= sub;\\n            int addBack = pq.Dequeue();\\n            pq.Enqueue(addBack - sub, 0 - (addBack - sub));\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinStoneSum(int[] piles, int k)\\n    {\\n        int sum = piles.Sum();\\n        PriorityQueue<int,int> pq = new PriorityQueue<int,int>();\\n        for (int i = 0; i < piles.Length; i ++)\\n        {\\n            pq.Enqueue(piles[i],0-piles[i]);\\n        }\\n        for (int i = 0; i < k; i ++)\\n        {\\n            int sub = pq.Peek() / 2;\\n            sum -= sub;\\n            int addBack = pq.Dequeue();\\n            pq.Enqueue(addBack - sub, 0 - (addBack - sub));\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393464,
                "title": "c-simple-and-easy-solution-with-explanation-faster-than-100",
                "content": "**Idea:**\\nFirst, we insert all piles into a priority queue, so that we can get the largest pile easily.\\nThen we do k iterations, in each iteration we take the largest pile and remove floor(pile / 2) stones from it.\\nWe push back into the queue the remainder of the pile.\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n        int sum = 0, curr;\\n        \\n        for (auto pile : piles) {\\n            pq.push(pile);\\n            sum += pile;\\n        }\\n        \\n        while (k--) {\\n            curr = pq.top();\\n            pq.pop();\\n            sum -= curr/2;\\n            pq.push(curr - curr/2);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n        int sum = 0, curr;\\n        \\n        for (auto pile : piles) {\\n            pq.push(pile);\\n            sum += pile;\\n        }\\n        \\n        while (k--) {\\n            curr = pq.top();\\n            pq.pop();\\n            sum -= curr/2;\\n            pq.push(curr - curr/2);\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390393,
                "title": "easy-stl-map-solution-time-of-different-approaches",
                "content": "\\n**Priority queue** solution gives AC,\\n**Map** solution gives AC.\\nBut solution using **make_heap** gives a TLE\\n\\nThe time should not be this much bottleneck that a similar approach will not get accepted.\\n\\n## This is an easy map solution:\\n- keep count of each element in map\\n- an STL map is always sorted so the greatest element will always be the last element\\n- remove or reduce count of that element and add the reduced stones in the map as new element\\n- Do this k number of times and at last find the sum of remaining stones\\n\\n## Code\\n```cpp\\n    int minStoneSum(vector<int>& piles, int k) {\\n        map<int, int> mp;\\n        int temp;\\n        for(int i: piles) ++mp[i];\\n        for(int i=0; i<k; ++i){\\n            temp = (*(mp.rbegin())).first;\\n            if(mp[temp]==1) mp.erase(temp);\\n            else --mp[temp];\\n            ++mp[temp-floor(1.0*temp/2)];\\n        }\\n        \\n        int ans=0;\\n        for(auto i: mp){\\n            ans+=(i.second*i.first);\\n        }\\n        return ans;\\n    }\\n```\\n\\n## Give an upvote if you like it \\uD83D\\uDE1C\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int minStoneSum(vector<int>& piles, int k) {\\n        map<int, int> mp;\\n        int temp;\\n        for(int i: piles) ++mp[i];\\n        for(int i=0; i<k; ++i){\\n            temp = (*(mp.rbegin())).first;\\n            if(mp[temp]==1) mp.erase(temp);\\n            else --mp[temp];\\n            ++mp[temp-floor(1.0*temp/2)];\\n        }\\n        \\n        int ans=0;\\n        for(auto i: mp){\\n            ans+=(i.second*i.first);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390269,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n        int n = piles.size();\\n        for(int i = 0;i<n;i++){\\n            pq.push(piles[i]);\\n        }\\n        int ans = 0;\\n        while(k>0 && !pq.empty()){\\n            int temp = pq.top();\\n            pq.pop();\\n            pq.push(floor((temp+1)/2));\\n            k--;\\n        }\\n        \\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n        int n = piles.size();\\n        for(int i = 0;i<n;i++){\\n            pq.push(piles[i]);\\n        }\\n        int ans = 0;\\n        while(k>0 && !pq.empty()){\\n            int temp = pq.top();\\n            pq.pop();\\n            pq.push(floor((temp+1)/2));\\n            k--;\\n        }\\n        \\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964274,
                "title": "simple-priority-queue-implementation-c-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\nfirst of all push all the elements of vector piles to the priority queue --->as we know top most element of priority queue is largest among all element present in priority queue\\n\\nNow, take top  of queue and pop ---->divide top of queue by 2 and store ceil value and push it back to the queue\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n+klog(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<piles.size();i++)\\n        pq.push(piles[i]);\\n        for(int i=0;i<k;i++){\\n            int t=pq.top();\\n            pq.pop();\\n            t=(t+1)/2;\\n            pq.push(t);\\n        }\\n        int ans=0;\\n        while(!pq.empty()){\\n            ans+=(pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<piles.size();i++)\\n        pq.push(piles[i]);\\n        for(int i=0;i<k;i++){\\n            int t=pq.top();\\n            pq.pop();\\n            t=(t+1)/2;\\n            pq.push(t);\\n        }\\n        int ans=0;\\n        while(!pq.empty()){\\n            ans+=(pq.top());\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963992,
                "title": "python-90-unusual-use-dict-and-iterate-from-max-stones",
                "content": "# Summary \\nThe solution is fast due to the use of a dictionary that uses hashing and due to the fact that we do not move the piles in any way (we just change the number of piles in the dict). But we use a lot of memory for this.\\n\\n\\n\\u2764\\uFE0F **Please upvote if you liked this unusual approach**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n*Same comments in the code*\\n\\n1) Make a dictionary where the element\\'s key - `piles[i]` and value - number of piles\\n2) Find **max** stones in piles\\n3) Iterate from **max** to **0**\\n    1) Find pile with this number of stones\\n    2) Remove stones (while there are the piles and k is not 0) and move new piles (changing the number of piles in the dict)\\n    3) Break if `k==0`\\n4) Count the amount\\n\\n\\n# Complexity\\n- Time complexity: $$O(max(stonesInPiles))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n+k)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        # 1) Make a dictionary where \\n        # the element\\'s key - `piles[i]` and value - number of piles\\n        dictPiles = {}\\n        for p in piles:\\n            if p in dictPiles:\\n                dictPiles[p] += 1\\n            else:\\n                dictPiles[p] = 1\\n        \\n        # 2) Find max stones in piles\\n        maxp = max(piles)        \\n\\n        # 3) Iterate from max to 0\\n        for stones in range(maxp,0,-1):\\n            # 3.a) Find pile with this number of stones\\n            if stones in dictPiles:\\n                # 3.b) Remove stones (while there are the piles \\n                # and k is not 0) and move new piles (changing \\n                # the number of piles in the dict)\\n                while dictPiles[stones] and k:\\n                    dictPiles[stones] -= 1\\n                    # move the pile after deletion\\n                    t = stones - (stones // 2)\\n                    if t in dictPiles:\\n                        dictPiles[t] += 1\\n                    else:\\n                        dictPiles[t] = 1\\n                    k -= 1\\n\\n            # 3.c) Break if k==0\\n            if not k:\\n                break\\n        \\n        # 4) Count the amount\\n        sumS = 0\\n        for k,v in dictPiles.items():\\n            sumS += k*v\\n\\n        return sumS\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Iterator",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        # 1) Make a dictionary where \\n        # the element\\'s key - `piles[i]` and value - number of piles\\n        dictPiles = {}\\n        for p in piles:\\n            if p in dictPiles:\\n                dictPiles[p] += 1\\n            else:\\n                dictPiles[p] = 1\\n        \\n        # 2) Find max stones in piles\\n        maxp = max(piles)        \\n\\n        # 3) Iterate from max to 0\\n        for stones in range(maxp,0,-1):\\n            # 3.a) Find pile with this number of stones\\n            if stones in dictPiles:\\n                # 3.b) Remove stones (while there are the piles \\n                # and k is not 0) and move new piles (changing \\n                # the number of piles in the dict)\\n                while dictPiles[stones] and k:\\n                    dictPiles[stones] -= 1\\n                    # move the pile after deletion\\n                    t = stones - (stones // 2)\\n                    if t in dictPiles:\\n                        dictPiles[t] += 1\\n                    else:\\n                        dictPiles[t] = 1\\n                    k -= 1\\n\\n            # 3.c) Break if k==0\\n            if not k:\\n                break\\n        \\n        # 4) Count the amount\\n        sumS = 0\\n        for k,v in dictPiles.items():\\n            sumS += k*v\\n\\n        return sumS\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963569,
                "title": "using-inbuilt-maxpriorityqueue-js",
                "content": "This is typical Max Heap problem. Idea is to find the biggest pile, remove floor(pile / 2), find the next maximum, apply the same operations k times. \\n\\nLeetCode provides the JavaScript environment with 2 packages from NPM to assist with data structures, datastructures-js/priority-queue and datastructures-js/queue.\\n\\ncredits/inspiration: https://leetcode.com/problems/find-median-from-data-stream/discuss/1566734/javascript-using-datastrucutres-jspriority-queue-min-and-max\\n\\nThanks to https://leetcode.com/auphynne @auphynne\\n\\n```\\n/**\\n * @param {number[]} piles\\n * @param {number} k\\n * @return {number}\\n */\\nvar minStoneSum = function(piles, k) {\\n    const max = new MaxPriorityQueue();\\n\\n    for(let i = 0; i < piles.length; i++) {\\n        max.enqueue(piles[i]);\\n    }\\n    \\n    while(k > 0) {\\n        k--;\\n        let maxPile = max.dequeue().element;        \\n        maxPile -= Math.floor(maxPile / 2);\\n        \\n        max.enqueue(maxPile);\\n    }\\n\\n    let sum = 0;\\n    while(max.size() > 0) {\\n        sum += max.dequeue().element;\\n    }\\n    \\n    return sum;\\n};\\n\\n \\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[]} piles\\n * @param {number} k\\n * @return {number}\\n */\\nvar minStoneSum = function(piles, k) {\\n    const max = new MaxPriorityQueue();\\n\\n    for(let i = 0; i < piles.length; i++) {\\n        max.enqueue(piles[i]);\\n    }\\n    \\n    while(k > 0) {\\n        k--;\\n        let maxPile = max.dequeue().element;        \\n        maxPile -= Math.floor(maxPile / 2);\\n        \\n        max.enqueue(maxPile);\\n    }\\n\\n    let sum = 0;\\n    while(max.size() > 0) {\\n        sum += max.dequeue().element;\\n    }\\n    \\n    return sum;\\n};\\n\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2961976,
                "title": "max-heap-solution",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        maxHeap = []\\n        \\n        for i in range(len(piles)):\\n            heapq.heappush(maxHeap, -piles[i])\\n\\n        i = k\\n        while i > 0:\\n            temp = heapq.heappop(maxHeap)\\n            j = temp//2\\n            heapq.heappush(maxHeap,j)\\n            i -= 1\\n            \\n        return -sum(maxHeap)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        maxHeap = []\\n        \\n        for i in range(len(piles)):\\n            heapq.heappush(maxHeap, -piles[i])\\n\\n        i = k\\n        while i > 0:\\n            temp = heapq.heappop(maxHeap)\\n            j = temp//2\\n            heapq.heappush(maxHeap,j)\\n            i -= 1\\n            \\n        return -sum(maxHeap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961581,
                "title": "python-easy-solution-with-very-clear-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. heapify the array\\n2. pop the top element, reduce it by half and push it back\\n3. repeat k times\\n4. return the sum of the array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n1. convert the array to a min heap by changing the sign os piles[i]\\n2. so that we can pop the largest element is -ve and push it back after reducing it by half\\n![telegram-cloud-photo-size-5-6152244432376803648-y.jpg](https://assets.leetcode.com/users/images/2b6f5764-3842-47fc-80c6-49a71ee49921_1672207066.1175997.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n+ klogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(log n)$$\\n# Code\\n\\n```python []\\nclass Solution:\\n    def minStoneSum(self, piles, k: int):\\n\\n\\n        min_heap = []\\n        for pile in piles:\\n            heapq.heappush(min_heap, -pile)\\n\\n        while k:\\n            k -= 1\\n\\n            # pop the largest element and change its sign\\n            largest = -heapq.heappop(min_heap)\\n            # reduce it by half and push it back\\n            heapq.heappush(min_heap, -largest // 2)\\n\\n        return sum(-x for x in min_heap)\\n```\\n\\n**UPVOTE if you like \\uD83D\\uDE03 , If you have any question, feel free to ask.**\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def minStoneSum(self, piles, k: int):\\n\\n\\n        min_heap = []\\n        for pile in piles:\\n            heapq.heappush(min_heap, -pile)\\n\\n        while k:\\n            k -= 1\\n\\n            # pop the largest element and change its sign\\n            largest = -heapq.heappop(min_heap)\\n            # reduce it by half and push it back\\n            heapq.heappush(min_heap, -largest // 2)\\n\\n        return sum(-x for x in min_heap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961263,
                "title": "explained-greedy-solution-priority-queue-c",
                "content": "# Approach\\n```\\n1)traverse throught Max-Heap till k>0 and \\nkeep pushing new value of the max element found in the prio.Queue\\nwhich is pq.top()-pq.top()/2.\\nhere probabilty that we may write pq.top()/2 only but \\npoint to note here is we are taking floor of pq.top()/2 \\nhence pq.top()/2 != pq.top()-pq.top()/2. \\nAfter this just iterate throught pq \\nand calculate sum.\\n```\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq(begin(piles), end(piles));\\n\\n        while(k--){\\n            int temp= pq.top()- pq.top()/2;\\n\\n            pq.pop();\\n            pq.push(temp);\\n\\n        }\\n\\n        int ans=0;\\n        while(pq.size()){\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n# Upvote if helpful.",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n1)traverse throught Max-Heap till k>0 and \\nkeep pushing new value of the max element found in the prio.Queue\\nwhich is pq.top()-pq.top()/2.\\nhere probabilty that we may write pq.top()/2 only but \\npoint to note here is we are taking floor of pq.top()/2 \\nhence pq.top()/2 != pq.top()-pq.top()/2. \\nAfter this just iterate throught pq \\nand calculate sum.\\n```\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq(begin(piles), end(piles));\\n\\n        while(k--){\\n            int temp= pq.top()- pq.top()/2;\\n\\n            pq.pop();\\n            pq.push(temp);\\n\\n        }\\n\\n        int ans=0;\\n        while(pq.size()){\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960954,
                "title": "c-499ms-priority-queue-short-sweet-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrioirty Queue\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinStoneSum(int[] piles, int k) {\\n        var pq = new PriorityQueue<int, int>(piles.Select(x => (x, -x)));\\n        for(int i = 0; i < k; i++){\\n            int pile = pq.Dequeue();\\n            pile -= pile / 2;\\n            pq.Enqueue(pile, -pile);\\n        }\\n        return pq.UnorderedItems.Sum(x => x.Element);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinStoneSum(int[] piles, int k) {\\n        var pq = new PriorityQueue<int, int>(piles.Select(x => (x, -x)));\\n        for(int i = 0; i < k; i++){\\n            int pile = pq.Dequeue();\\n            pile -= pile / 2;\\n            pq.Enqueue(pile, -pile);\\n        }\\n        return pq.UnorderedItems.Sum(x => x.Element);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960623,
                "title": "js-clean-fast-maxpriorityqueue-comments",
                "content": "# Approach\\nSimply enqueue all piles, and cut each top element in half, while\\nwe reduce the sum by the amount lost.\\nWould end up with a clean code, please upvote if you found this helpful.\\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\nDequeue and enqueue are Log N\\n\\n\\n# Code\\n```\\nvar minStoneSum = function (ps, k, sum = 0) {\\n  const q = new MaxPriorityQueue();\\n//Enqueue each elements, as well as calculate the sum\\n  ps.forEach((p) => {\\n    q.enqueue(p);\\n    sum += p;\\n  });\\n\\n// Dequeue top element and cut in half, for k times.\\n// Have sum reduced by the amount lost.\\n// Don\\'t forget enqueue the cutted stone back to heap :)\\n  for (let i = 0; i < k; i++) {\\n    let el = q.dequeue().element,\\n      stoEl = Math.ceil(el / 2);\\n    sum -= el - stoEl;\\n    q.enqueue(stoEl);\\n  }\\n\\n  return sum;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minStoneSum = function (ps, k, sum = 0) {\\n  const q = new MaxPriorityQueue();\\n//Enqueue each elements, as well as calculate the sum\\n  ps.forEach((p) => {\\n    q.enqueue(p);\\n    sum += p;\\n  });\\n\\n// Dequeue top element and cut in half, for k times.\\n// Have sum reduced by the amount lost.\\n// Don\\'t forget enqueue the cutted stone back to heap :)\\n  for (let i = 0; i < k; i++) {\\n    let el = q.dequeue().element,\\n      stoEl = Math.ceil(el / 2);\\n    sum -= el - stoEl;\\n    q.enqueue(stoEl);\\n  }\\n\\n  return sum;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2118659,
                "title": "c-simple-solution-using-maxheap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        vector<int> ans;\\n        priority_queue<int> maxh;\\n        for(auto i:piles)\\n            maxh.push(i);\\n        for(int i=0;i<k;i++){\\n            int a = maxh.top();\\n            a -= floor(a/2);\\n            maxh.pop();\\n            maxh.push(a);\\n        }\\n        while(!maxh.empty()){\\n            ans.push_back(maxh.top());\\n            maxh.pop();\\n        }\\n        int sum=0;\\n        for(auto i:ans)\\n            sum = sum + i;\\n        return sum;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        vector<int> ans;\\n        priority_queue<int> maxh;\\n        for(auto i:piles)\\n            maxh.push(i);\\n        for(int i=0;i<k;i++){\\n            int a = maxh.top();\\n            a -= floor(a/2);\\n            maxh.pop();\\n            maxh.push(a);\\n        }\\n        while(!maxh.empty()){\\n            ans.push_back(maxh.top());\\n            maxh.pop();\\n        }\\n        int sum=0;\\n        for(auto i:ans)\\n            sum = sum + i;\\n        return sum;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976074,
                "title": "swift-array-heap-implementation",
                "content": "```swift\\n// purpose-built array heap (mostly typical implementaion with some tweaks specific to the problem)\\nstruct PileHeap {\\n    private var values: [Int]\\n    \\n    init(_ piles: [Int]) {\\n        self.values = [Int]()\\n        self.values.reserveCapacity(piles.count)\\n\\n        for (index, value) in piles.enumerated() {\\n            self.values.append(value)\\n            \\n            self.siftUp(index, value)\\n        }\\n    }\\n    \\n    mutating public func halveMaxPile() {\\n        if let value = self.values.first {\\n            let newValue = value - (value / 2)\\n            self.values[self.values.startIndex] = newValue\\n            \\n            self.siftDown(self.values.startIndex, newValue)\\n        }\\n    }\\n    \\n    @inline(__always) var stones: [Int] {\\n        get {\\n            self.values\\n        }\\n    }\\n    \\n    mutating private func siftUp(_ index: Int, _ value: Int) {\\n        let parentIndexOrNil = self.getParentIndex(index)\\n        guard let parentIndex = parentIndexOrNil else {\\n            return\\n        }\\n        \\n        let parentValue = self.values[parentIndex]\\n        \\n        if parentValue < value {\\n            self.values.swapAt(parentIndex, index)\\n\\n            self.siftUp(parentIndex, value)\\n        }\\n    }\\n\\n    mutating private func siftDown(_ index: Int, _ value: Int) {\\n        let leftChildIndex = self.getLeftChildIndex(index)\\n        let rightChildIndex = self.getRightChildIndex(index)\\n        \\n        if let leftChildIndex = leftChildIndex, let rightChildIndex = rightChildIndex {\\n            let leftChildValue = self.values[leftChildIndex]\\n            let rightChildValue = self.values[rightChildIndex]\\n            \\n            let maxChildValue = leftChildValue < rightChildValue ? rightChildValue : leftChildValue\\n            let maxChilldIndex = leftChildValue < rightChildValue ? rightChildIndex : leftChildIndex\\n            \\n            if value < maxChildValue {\\n                self.values.swapAt(index, maxChilldIndex)\\n                self.siftDown(maxChilldIndex, value)\\n            }\\n        } else if let leftChildIndex = leftChildIndex {\\n            let leftChildValue = self.values[leftChildIndex]\\n            if value < leftChildValue {\\n                self.values.swapAt(index, leftChildIndex)\\n                \\n                self.siftDown(leftChildIndex, value)\\n            }\\n        }\\n    }\\n\\n    @inline(__always) private func getParentIndex(_ index: Int) -> Int? {\\n        let mightBeIndex = (index - 1) / 2\\n        \\n        return self.values.startIndex < index && self.isValidIndex(mightBeIndex) ? mightBeIndex : nil\\n    }\\n    \\n    @inline(__always) private func getLeftChildIndex(_ index: Int) -> Int? {\\n        let mightBeIndex = 2 * index + 1\\n        \\n        return self.isValidIndex(mightBeIndex) ? mightBeIndex : nil\\n    }\\n    \\n    @inline(__always) private func getRightChildIndex(_ index: Int) -> Int? {\\n        let mightBeIndex = 2 * index + 2\\n        \\n        return self.isValidIndex(mightBeIndex) ? mightBeIndex : nil\\n    }\\n\\n    @inline(__always) func isValidIndex(_ index: Int) -> Bool {\\n        self.values.startIndex <= index && index < self.values.endIndex\\n    }\\n}\\n\\n// EZ solution though\\n\\nstruct Solution {\\n    @inline(__always) func minStoneSum(_ piles: [Int], _ k: Int) -> Int {\\n        var piles = PileHeap(piles)\\n        \\n        for _ in 0 ..< k {\\n            piles.halveMaxPile()\\n        }\\n        \\n        return piles.stones.reduce(0, +)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\n// purpose-built array heap (mostly typical implementaion with some tweaks specific to the problem)\\nstruct PileHeap {\\n    private var values: [Int]\\n    \\n    init(_ piles: [Int]) {\\n        self.values = [Int]()\\n        self.values.reserveCapacity(piles.count)\\n\\n        for (index, value) in piles.enumerated() {\\n            self.values.append(value)\\n            \\n            self.siftUp(index, value)\\n        }\\n    }\\n    \\n    mutating public func halveMaxPile() {\\n        if let value = self.values.first {\\n            let newValue = value - (value / 2)\\n            self.values[self.values.startIndex] = newValue\\n            \\n            self.siftDown(self.values.startIndex, newValue)\\n        }\\n    }\\n    \\n    @inline(__always) var stones: [Int] {\\n        get {\\n            self.values\\n        }\\n    }\\n    \\n    mutating private func siftUp(_ index: Int, _ value: Int) {\\n        let parentIndexOrNil = self.getParentIndex(index)\\n        guard let parentIndex = parentIndexOrNil else {\\n            return\\n        }\\n        \\n        let parentValue = self.values[parentIndex]\\n        \\n        if parentValue < value {\\n            self.values.swapAt(parentIndex, index)\\n\\n            self.siftUp(parentIndex, value)\\n        }\\n    }\\n\\n    mutating private func siftDown(_ index: Int, _ value: Int) {\\n        let leftChildIndex = self.getLeftChildIndex(index)\\n        let rightChildIndex = self.getRightChildIndex(index)\\n        \\n        if let leftChildIndex = leftChildIndex, let rightChildIndex = rightChildIndex {\\n            let leftChildValue = self.values[leftChildIndex]\\n            let rightChildValue = self.values[rightChildIndex]\\n            \\n            let maxChildValue = leftChildValue < rightChildValue ? rightChildValue : leftChildValue\\n            let maxChilldIndex = leftChildValue < rightChildValue ? rightChildIndex : leftChildIndex\\n            \\n            if value < maxChildValue {\\n                self.values.swapAt(index, maxChilldIndex)\\n                self.siftDown(maxChilldIndex, value)\\n            }\\n        } else if let leftChildIndex = leftChildIndex {\\n            let leftChildValue = self.values[leftChildIndex]\\n            if value < leftChildValue {\\n                self.values.swapAt(index, leftChildIndex)\\n                \\n                self.siftDown(leftChildIndex, value)\\n            }\\n        }\\n    }\\n\\n    @inline(__always) private func getParentIndex(_ index: Int) -> Int? {\\n        let mightBeIndex = (index - 1) / 2\\n        \\n        return self.values.startIndex < index && self.isValidIndex(mightBeIndex) ? mightBeIndex : nil\\n    }\\n    \\n    @inline(__always) private func getLeftChildIndex(_ index: Int) -> Int? {\\n        let mightBeIndex = 2 * index + 1\\n        \\n        return self.isValidIndex(mightBeIndex) ? mightBeIndex : nil\\n    }\\n    \\n    @inline(__always) private func getRightChildIndex(_ index: Int) -> Int? {\\n        let mightBeIndex = 2 * index + 2\\n        \\n        return self.isValidIndex(mightBeIndex) ? mightBeIndex : nil\\n    }\\n\\n    @inline(__always) func isValidIndex(_ index: Int) -> Bool {\\n        self.values.startIndex <= index && index < self.values.endIndex\\n    }\\n}\\n\\n// EZ solution though\\n\\nstruct Solution {\\n    @inline(__always) func minStoneSum(_ piles: [Int], _ k: Int) -> Int {\\n        var piles = PileHeap(piles)\\n        \\n        for _ in 0 ..< k {\\n            piles.halveMaxPile()\\n        }\\n        \\n        return piles.stones.reduce(0, +)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390341,
                "title": "c-pq-based",
                "content": "**Explanation**\\n\\nUse a max heap.\\nEach time pop the max value a,\\nremove a / 2 from the number of stones res\\nand push back the ceil half a - a / 2 to the heap.\\nRepeat this operation k times.\\n\\n\\n**Complexity**\\n\\nTime O(nlogn)\\nSpace O(n)\\n\\n**If you know about which DS used to  fetch max and min element in the array in log(n) time then go ahead !!**\\n*then this is easy one for you otherwise not :)\\nme still having two WA in this xD*\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& arr ,int k)\\n    {\\n       int n=arr.size();\\n        int sum =0 ;\\n        priority_queue<int> maxh ;\\n        for(int i=0;i<n;i++)   maxh.push(arr[i]);\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n           int x= maxh.top(); maxh.pop();\\n           x -= x/2 ;\\n           maxh.push(x);\\n        }\\n        while(maxh.size()>0)\\n        {\\n            sum +=maxh.top();\\n             maxh.pop();\\n        }\\n        return sum ;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& arr ,int k)\\n    {\\n       int n=arr.size();\\n        int sum =0 ;\\n        priority_queue<int> maxh ;\\n        for(int i=0;i<n;i++)   maxh.push(arr[i]);\\n        \\n        for(int i=0;i<k;i++)\\n        {\\n           int x= maxh.top(); maxh.pop();\\n           x -= x/2 ;\\n           maxh.push(x);\\n        }\\n        while(maxh.size()>0)\\n        {\\n            sum +=maxh.top();\\n             maxh.pop();\\n        }\\n        return sum ;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390338,
                "title": "c-priority-queue-greedy-easy-to-understand-commented-and-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        int ans=0,cnt_one=0;\\n        priority_queue<int> a;\\n        for(auto x:p){a.push(x);}\\n        while(k>0&&!a.empty()){\\n            int x=a.top();\\n            x-=x/2;\\n            a.pop();\\n            if(x>1){// if x>1 then only push it to prioriy queue \\n            a.push(x);\\n            }else{cnt_one++;}// else if x==1 then floor value of x/2 would be 0 hence it the element will never become less than 1 so count the extra ones\\n            k--;\\n        }\\n        ans=0;\\n        while(!a.empty()){ans+=a.top();a.pop();}\\n        return ans+cnt_one;// return sum of elements and extra ones\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        int ans=0,cnt_one=0;\\n        priority_queue<int> a;\\n        for(auto x:p){a.push(x);}\\n        while(k>0&&!a.empty()){\\n            int x=a.top();\\n            x-=x/2;\\n            a.pop();\\n            if(x>1){// if x>1 then only push it to prioriy queue \\n            a.push(x);\\n            }else{cnt_one++;}// else if x==1 then floor value of x/2 would be 0 hence it the element will never become less than 1 so count the extra ones\\n            k--;\\n        }\\n        ans=0;\\n        while(!a.empty()){ans+=a.top();a.pop();}\\n        return ans+cnt_one;// return sum of elements and extra ones\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390222,
                "title": "java-heap-solution",
                "content": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> b - a);\\n        int sum = 0;\\n        for (int p : piles) {\\n            sum += p;\\n            heap.offer(p);\\n        }\\n        for (int i = 0; i < k; i++) {\\n            int top = heap.poll(); \\n            sum -= top; \\n            top = top % 2 == 0 ? top / 2 : (top + 1) / 2; \\n            sum += top;\\n            heap.offer(top);\\n        }\\n        return sum; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> b - a);\\n        int sum = 0;\\n        for (int p : piles) {\\n            sum += p;\\n            heap.offer(p);\\n        }\\n        for (int i = 0; i < k; i++) {\\n            int top = heap.poll(); \\n            sum -= top; \\n            top = top % 2 == 0 ? top / 2 : (top + 1) / 2; \\n            sum += top;\\n            heap.offer(top);\\n        }\\n        return sum; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390191,
                "title": "java-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue(Collections.reverseOrder());//add all elements in descending order\\n        for(int i:piles){\\n            pq.add(i);\\n        }\\n        while(!pq.isEmpty() && k-->0){\\n            int x=pq.poll();\\n            int a=x-(int)Math.floor(x/2);// divide the element and add again to queue\\n            pq.add(a);\\n        }\\n        int sum=0;\\n        while(!pq.isEmpty()){\\n            sum+=pq.poll();//sum the total answer\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue(Collections.reverseOrder());//add all elements in descending order\\n        for(int i:piles){\\n            pq.add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2964605,
                "title": "ruby-go-k-times-pop-and-push-in-binary-heap",
                "content": "## Leetcode: 1962. Remove Stones to Minimize the Total.\\n\\n**Ruby/Go: K times pop and push in Binary Heap.**\\n\\nTime: O(KLog(N)); Memory: O(N);\\n\\n- https://en.wikipedia.org/wiki/Binary_heap\\n\\n1. Get total sum of piles.\\n2. Generate heap of piles.\\n3. `k` times loop.\\n4. Get biggets pile, take half, push rest into the heap.\\n5. Return difference between total and taken.\\n\\nRuby code:\\n```Ruby\\n# Leetcode: 1962. Remove Stones to Minimize the Total.\\n# https://leetcode.com/problems/remove-stones-to-minimize-the-total/\\n# = = = = = = = = = = = = = =\\n# Correct.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# At the Leetcode libraries works too long.\\n# But the algorithm is correct.\\n# @param {Integer[]} piles\\n# @param {Integer} k\\n# @return {Integer}\\ndef min_stone_sum(piles, k)\\n  # https://www.rubydoc.info/github/kanwei/algorithms/Containers/MaxHeap\\n  maxheap = MaxHeap.new(piles)\\n  total = piles.sum\\n  total_take = 0\\n  k.times do\\n    tmp = maxheap.pop\\n    take = tmp/2\\n    tmp -= take\\n    total_take += take\\n    maxheap.push(tmp)\\n  end\\n  return total - total_take\\nend\\n```\\nGo code:\\n```Go\\n// Leetcode: 1962. Remove Stones to Minimize the Total.\\n// https://leetcode.com/problems/remove-stones-to-minimize-the-total/\\n// = = = = = = = = = = = = = =\\n// Accepted.\\n// Thanks God, Jesus Christ!\\n// = = = = = = = = = = = = = =\\n// Runtime: 451 ms, faster than 69.23% of Go online submissions for Remove Stones to Minimize the Total.\\n// Memory Usage: 8.7 MB, less than 100.00% of Go online submissions for Remove Stones to Minimize the Total.\\n// 2022.12.28 Daily Challenge.\\n\\n// https://pkg.go.dev/container/heap\\n// https://leetcode.com/problems/last-stone-weight/discuss/549801/golang-using-containerheap\\n// https://stackoverflow.com/questions/18041334/convert-interface-to-int\\nimport \"container/heap\"\\nimport \"fmt\"\\nvar p = fmt.Println\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int  { return len(h)}\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] > h[j] } // Reversed!\\nfunc (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i]}\\nfunc (h  * IntHeap) Push(x interface{}){\\n  *h = append(*h, x.(int))\\n}\\nfunc (h  * IntHeap) Pop() interface{} {\\n  old := *h\\n  n := len(old)\\n  x := old[n-1]\\n  *h = old[0:n-1]\\n  return x\\n}\\n\\n\\nfunc minStoneSum(piles []int, k int) int {\\n  pls := IntHeap(piles)\\n  heap.Init(&pls)\\n  total := 0 \\n  taken := 0\\n  for _, v := range piles {\\n    total += v\\n  }\\n  for i:=0 ; i < k; i += 1{\\n    big := heap.Pop(&pls).(int)\\n    get := (big/2)\\n    put := big - get\\n    taken += get\\n    heap.Push(&pls,put)\\n  }\\n  return total - taken\\n}\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```Ruby\\n# Leetcode: 1962. Remove Stones to Minimize the Total.\\n# https://leetcode.com/problems/remove-stones-to-minimize-the-total/\\n# = = = = = = = = = = = = = =\\n# Correct.\\n# Thanks God, Jesus Christ!\\n# = = = = = = = = = = = = = =\\n# At the Leetcode libraries works too long.\\n# But the algorithm is correct.\\n# @param {Integer[]} piles\\n# @param {Integer} k\\n# @return {Integer}\\ndef min_stone_sum(piles, k)\\n  # https://www.rubydoc.info/github/kanwei/algorithms/Containers/MaxHeap\\n  maxheap = MaxHeap.new(piles)\\n  total = piles.sum\\n  total_take = 0\\n  k.times do\\n    tmp = maxheap.pop\\n    take = tmp/2\\n    tmp -= take\\n    total_take += take\\n    maxheap.push(tmp)\\n  end\\n  return total - total_take\\nend\\n```\n```Go\\n// Leetcode: 1962. Remove Stones to Minimize the Total.\\n// https://leetcode.com/problems/remove-stones-to-minimize-the-total/\\n// = = = = = = = = = = = = = =\\n// Accepted.\\n// Thanks God, Jesus Christ!\\n// = = = = = = = = = = = = = =\\n// Runtime: 451 ms, faster than 69.23% of Go online submissions for Remove Stones to Minimize the Total.\\n// Memory Usage: 8.7 MB, less than 100.00% of Go online submissions for Remove Stones to Minimize the Total.\\n// 2022.12.28 Daily Challenge.\\n\\n// https://pkg.go.dev/container/heap\\n// https://leetcode.com/problems/last-stone-weight/discuss/549801/golang-using-containerheap\\n// https://stackoverflow.com/questions/18041334/convert-interface-to-int\\nimport \"container/heap\"\\nimport \"fmt\"\\nvar p = fmt.Println\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int  { return len(h)}\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] > h[j] } // Reversed!\\nfunc (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i]}\\nfunc (h  * IntHeap) Push(x interface{}){\\n  *h = append(*h, x.(int))\\n}\\nfunc (h  * IntHeap) Pop() interface{} {\\n  old := *h\\n  n := len(old)\\n  x := old[n-1]\\n  *h = old[0:n-1]\\n  return x\\n}\\n\\n\\nfunc minStoneSum(piles []int, k int) int {\\n  pls := IntHeap(piles)\\n  heap.Init(&pls)\\n  total := 0 \\n  taken := 0\\n  for _, v := range piles {\\n    total += v\\n  }\\n  for i:=0 ; i < k; i += 1{\\n    big := heap.Pop(&pls).(int)\\n    get := (big/2)\\n    put := big - get\\n    taken += get\\n    heap.Push(&pls,put)\\n  }\\n  return total - taken\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2964275,
                "title": "typescript-priority-queue-100-faster",
                "content": "# Code\\n```\\nfunction minStoneSum(piles: number[], k: number): number {\\n    const maxPriorityQ = new MaxPriorityQueue();\\n    let sum = 0;\\n\\n    for (let i = 0, n = piles.length; i < n; i++) {\\n        maxPriorityQ.enqueue(piles[i]);\\n        sum += piles[i];\\n    }\\n\\n    while (k--) {\\n        let { element: last } = maxPriorityQ.dequeue();\\n        sum -= last;\\n        last -= Math.floor(last / 2);\\n        sum += last;\\n        maxPriorityQ.enqueue(last);\\n    }\\n\\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunction minStoneSum(piles: number[], k: number): number {\\n    const maxPriorityQ = new MaxPriorityQueue();\\n    let sum = 0;\\n\\n    for (let i = 0, n = piles.length; i < n; i++) {\\n        maxPriorityQ.enqueue(piles[i]);\\n        sum += piles[i];\\n    }\\n\\n    while (k--) {\\n        let { element: last } = maxPriorityQ.dequeue();\\n        sum -= last;\\n        last -= Math.floor(last / 2);\\n        sum += last;\\n        maxPriorityQ.enqueue(last);\\n    }\\n\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2963968,
                "title": "priority-queue-solution-remove-stones",
                "content": "# Intuition\\n\\n\\n# Approach\\nPriority Queue Simple Solution\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n\\n        PriorityQueue<Integer>a1= new PriorityQueue<>(Collections.reverseOrder());\\n        int sum=0;\\n\\n        for(int i: piles)\\n        {\\n            a1.add(i);\\n            sum+=i;\\n\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            int val=a1.poll();\\n            int res= val/2;\\n            sum=sum-res;\\n            a1.offer(val-res);\\n        }\\n        return sum;\\n\\n\\n\\n                \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n\\n        PriorityQueue<Integer>a1= new PriorityQueue<>(Collections.reverseOrder());\\n        int sum=0;\\n\\n        for(int i: piles)\\n        {\\n            a1.add(i);\\n            sum+=i;\\n\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            int val=a1.poll();\\n            int res= val/2;\\n            sum=sum-res;\\n            a1.offer(val-res);\\n        }\\n        return sum;\\n\\n\\n\\n                \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963136,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> q;\\n        for(auto x: piles) q.push(x);\\n        while(k--) {\\n            int u = q.top();\\n            q.pop();\\n            int x = round(1.0 * u / 2);\\n            q.push(x);\\n        }\\n        int ans = 0;\\n        while(!q.empty()) {\\n            ans += q.top();\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> q;\\n        for(auto x: piles) q.push(x);\\n        while(k--) {\\n            int u = q.top();\\n            q.pop();\\n            int x = round(1.0 * u / 2);\\n            q.push(x);\\n        }\\n        int ans = 0;\\n        while(!q.empty()) {\\n            ans += q.top();\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962186,
                "title": "easy-java-priorityqueue-soln",
                "content": "**Explanation**\\nUse a max heap.\\nEach time pop the max value a,\\nremove a / 2 from the number of stones res\\nand push back the ceil half a - a / 2 to the heap.\\nRepeat this operation k times.\\n\\n\\n**Complexity**\\nTime O(n + klogn)\\nSpace O(n)\\n\\n# Code\\n```\\nclass Solution {\\n        public int minStoneSum(int[] A, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)->b - a);\\n        int res = 0;\\n        for (int a : A) {\\n            pq.add(a);\\n            res += a;\\n        }\\n        while (k-- > 0) {\\n            int a = pq.poll();\\n            pq.add(a - a / 2);\\n            res -= a / 2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n        public int minStoneSum(int[] A, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)->b - a);\\n        int res = 0;\\n        for (int a : A) {\\n            pq.add(a);\\n            res += a;\\n        }\\n        while (k-- > 0) {\\n            int a = pq.poll();\\n            pq.add(a - a / 2);\\n            res -= a / 2;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962058,
                "title": "python3-in-built-max-heap-most-people-don-t-know",
                "content": "There exist in-built max heap functionality in python.\\nMost people don\\'t know about it, and in all the posts I have seen them implementing by using min heap and negating the elements.\\nSometimes it creates confusion.\\nSo, why not use in-built max heap.\\nHere is the implementation.\\n\\n```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        heapq._heapify_max(piles)\\n        for _ in range(k):\\n            heapq._heapreplace_max(piles, (piles[0]+1)//2)\\n        return sum(piles)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        heapq._heapify_max(piles)\\n        for _ in range(k):\\n            heapq._heapreplace_max(piles, (piles[0]+1)//2)\\n        return sum(piles)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961980,
                "title": "easy-c-solution-using-priority-queue-stl",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int n = piles.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++){\\n            pq.push(piles[i]);\\n        }\\n        \\n        int temp = 0;\\n        int temp2 = 0;\\n        while(k--){\\n            temp = pq.top();\\n            pq.pop();\\n            temp2 = temp/2 + temp%2;\\n            pq.push(temp2);\\n        }\\n        \\n        int stonesSum=0;\\n        while(!pq.empty()){\\n            stonesSum+=pq.top();\\n            pq.pop();\\n        }\\n        return stonesSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int n = piles.size();\\n        priority_queue<int> pq;\\n        for(int i=0;i<n;i++){\\n            pq.push(piles[i]);\\n        }\\n        \\n        int temp = 0;\\n        int temp2 = 0;\\n        while(k--){\\n            temp = pq.top();\\n            pq.pop();\\n            temp2 = temp/2 + temp%2;\\n            pq.push(temp2);\\n        }\\n        \\n        int stonesSum=0;\\n        while(!pq.empty()){\\n            stonesSum+=pq.top();\\n            pq.pop();\\n        }\\n        return stonesSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961806,
                "title": "new-approach-without-using-heap-priority-queue",
                "content": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) \\n    {\\n        int count[]=new int[100001];\\n        int ans=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            count[piles[i]]++;\\n        }\\n        for(int i=count.length-1;i>1;i--)\\n        {\\n            if(k==0)\\n                break;\\n            if(count[i]!=0)\\n            {\\n                if(count[i]>k)\\n                {\\n                   \\n                    int val=(int)Math.ceil(1.0*i/2);\\n                    count[val]+=k;\\n                    count[i]=count[i]-k;\\n                    k=0;\\n                }\\n                else\\n                {\\n                    // System.out.println(i);\\n                  int val=(int)Math.ceil(1.0*i/2);\\n                    // System.out.println(val);\\n                  count[val]+=(count[i]);\\n                  k=k-count[i];\\n                    count[i]=0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<=100000;i++)\\n        {\\n            if(count[i]!=0)\\n            {\\n                ans+=(count[i]*i);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) \\n    {\\n        int count[]=new int[100001];\\n        int ans=0;\\n        for(int i=0;i<piles.length;i++)\\n        {\\n            count[piles[i]]++;\\n        }\\n        for(int i=count.length-1;i>1;i--)\\n        {\\n            if(k==0)\\n                break;\\n            if(count[i]!=0)\\n            {\\n                if(count[i]>k)\\n                {\\n                   \\n                    int val=(int)Math.ceil(1.0*i/2);\\n                    count[val]+=k;\\n                    count[i]=count[i]-k;\\n                    k=0;\\n                }\\n                else\\n                {\\n                    // System.out.println(i);\\n                  int val=(int)Math.ceil(1.0*i/2);\\n                    // System.out.println(val);\\n                  count[val]+=(count[i]);\\n                  k=k-count[i];\\n                    count[i]=0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<=100000;i++)\\n        {\\n            if(count[i]!=0)\\n            {\\n                ans+=(count[i]*i);\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961752,
                "title": "c-easy-priority-queue",
                "content": "# Intuition\\nGetting largest number from vector and performing operation on it until k.\\n\\n# Approach\\nUsing priority queue and ceil function\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq(piles.begin(),piles.end());\\n        while(k>0)\\n        {\\n            double x=pq.top();\\n            pq.pop();\\n            pq.push(ceil(x/2));\\n            k--;\\n        }\\n        int sum=0;\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq(piles.begin(),piles.end());\\n        while(k>0)\\n        {\\n            double x=pq.top();\\n            pq.pop();\\n            pq.push(ceil(x/2));\\n            k--;\\n        }\\n        int sum=0;\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961613,
                "title": "c-priority-queue-max-heap-easy-to-understand",
                "content": "```\\n/*\\t\\n    if you know how to use priority queue then while reading this \\n    question you can easily say that this is just a greedy based \\n    question in which we have to take maximum element on every \\n    iteration till k operation\\n\\n    Time complexity of this solution will be O((k+n)*log(n))\\n\\n\\n*/\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        \\n        // getting all elements of vector piles into priority queue which has operation of O(nlog(n));\\n        priority_queue<int> pq(piles.begin(), piles.end()); \\n       \\n        // getting sum of all elements of piles vector\\n        \\n       int sum = accumulate(piles.begin(), piles.end(), 0);\\n        \\n        \\n        // iterating till k-- and checking if priority queue is empty or not\\n        \\n        while(!pq.empty() and k--) { \\n            \\n            int curr = pq.top();\\n            \\n            pq.pop();\\n            \\n            sum     -= floor(curr/2);\\n            curr    -= floor(curr/2);\\n            \\n            pq.push(curr);\\n        }\\n        \\n        return sum;\\n        \\n    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/*\\t\\n    if you know how to use priority queue then while reading this \\n    question you can easily say that this is just a greedy based \\n    question in which we have to take maximum element on every \\n    iteration till k operation\\n\\n    Time complexity of this solution will be O((k+n)*log(n))\\n\\n\\n*/\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        \\n        // getting all elements of vector piles into priority queue which has operation of O(nlog(n));\\n        priority_queue<int> pq(piles.begin(), piles.end()); \\n       \\n        // getting sum of all elements of piles vector\\n        \\n       int sum = accumulate(piles.begin(), piles.end(), 0);\\n        \\n        \\n        // iterating till k-- and checking if priority queue is empty or not\\n        \\n        while(!pq.empty() and k--) { \\n            \\n            int curr = pq.top();\\n            \\n            pq.pop();\\n            \\n            sum     -= floor(curr/2);\\n            curr    -= floor(curr/2);\\n            \\n            pq.push(curr);\\n        }\\n        \\n        return sum;\\n        \\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961564,
                "title": "c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k",
                "content": "# Code\\n```\\n// Using Priority Queue - TC = O(klogn) && SC = O(n)\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int ans = accumulate(piles.begin(), piles.end(), 0);\\n        multiset<int> Set(piles.begin(), piles.end());\\n        while(!Set.empty() && k-- > 0) {\\n            auto iter = Set.end();\\n            --iter;\\n            if(*iter == 1) break;\\n            ans -= *iter / 2;\\n            Set.insert(*iter - *iter / 2); \\n            Set.erase(iter);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Using Buckets - TC = O(n + k) && SC = O(1)\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int freq[10001] = {0};\\n        int ans = 0;\\n        for(int pile: piles) {\\n            ans += pile;\\n            freq[pile]++;\\n        }\\n        for(int i = 10000; i > 1 && k > 0; i--) {\\n            if(freq[i] > 0) {\\n                int canTake = min(freq[i], k);\\n                k -= canTake;\\n                freq[i] -= canTake;\\n                freq[i - i / 2] += canTake;\\n                ans -= canTake * (i / 2);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Using Priority Queue - TC = O(klogn) && SC = O(n)\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int ans = accumulate(piles.begin(), piles.end(), 0);\\n        multiset<int> Set(piles.begin(), piles.end());\\n        while(!Set.empty() && k-- > 0) {\\n            auto iter = Set.end();\\n            --iter;\\n            if(*iter == 1) break;\\n            ans -= *iter / 2;\\n            Set.insert(*iter - *iter / 2); \\n            Set.erase(iter);\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Using Buckets - TC = O(n + k) && SC = O(1)\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int freq[10001] = {0};\\n        int ans = 0;\\n        for(int pile: piles) {\\n            ans += pile;\\n            freq[pile]++;\\n        }\\n        for(int i = 10000; i > 1 && k > 0; i--) {\\n            if(freq[i] > 0) {\\n                int canTake = min(freq[i], k);\\n                k -= canTake;\\n                freq[i] -= canTake;\\n                freq[i - i / 2] += canTake;\\n                ans -= canTake * (i / 2);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961541,
                "title": "beats-95-explanation-codedominar-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        # Create a heap from the elements of piles, with the\\n        # element values negated to make the heap a min-heap\\n        heap = [-x for x in piles]\\n        heapify(heap)  # O(n)\\n\\n        # Run the loop k times\\n        while k:\\n            # Remove the minimum element from the heap\\n            top = heappop(heap)  # O(log(n))\\n\\n            # Add (floor(abs(top) / 2)) to top\\n            top += (floor(abs(top) / 2))\\n\\n            # Insert the modified element back into the heap\\n            heappush(heap, top)  # O(log(n))\\n            k -= 1\\n\\n        # Return the sum of the elements in the heap, with the\\n        # element values negated to restore their original values\\n        return abs(sum(heap))\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        # Create a heap from the elements of piles, with the\\n        # element values negated to make the heap a min-heap\\n        heap = [-x for x in piles]\\n        heapify(heap)  # O(n)\\n\\n        # Run the loop k times\\n        while k:\\n            # Remove the minimum element from the heap\\n            top = heappop(heap)  # O(log(n))\\n\\n            # Add (floor(abs(top) / 2)) to top\\n            top += (floor(abs(top) / 2))\\n\\n            # Insert the modified element back into the heap\\n            heappush(heap, top)  # O(log(n))\\n            k -= 1\\n\\n        # Return the sum of the elements in the heap, with the\\n        # element values negated to restore their original values\\n        return abs(sum(heap))\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961502,
                "title": "c-priority-queue-83-time-55-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& v, int k) {\\n      priority_queue<int> pq;\\n      for(auto &i: v) pq.push(i);\\n      while(k--){\\n        auto top = pq.top();\\n        if(top == 1) break;\\n        pq.pop();\\n        top = (top + 1) / 2;\\n        pq.push(top);\\n      }\\n      int ans = 0;\\n      while(!pq.empty()){\\n        ans += pq.top();\\n        pq.pop();\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& v, int k) {\\n      priority_queue<int> pq;\\n      for(auto &i: v) pq.push(i);\\n      while(k--){\\n        auto top = pq.top();\\n        if(top == 1) break;\\n        pq.pop();\\n        top = (top + 1) / 2;\\n        pq.push(top);\\n      }\\n      int ans = 0;\\n      while(!pq.empty()){\\n        ans += pq.top();\\n        pq.pop();\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961400,
                "title": "java-easy-way-briefly-explained-beats-100-only-using-loops-and-array",
                "content": "\\n**DO UPVOTE IF YOU WANT MORE SUCH CONTENTS**\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nConstant \\n\\n# Code\\n```\\n//So our approach should be something in which we can update in the same array. As we can observe here that the maximum integers in the piles are those where we need to apply the operations to get the minimum values. We can only apply operations for K times and on each element we can apply operations as many as we want.\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n      \\n         while(k > 0){ //until k > 0 we are gonna apply the operations on the maximum integers inside the piles array. Why we apply on maximum ? because if we need minimum sum of the array we need to decrease the values of the maximum value elements inside the array . that\\'s why we are targeting the maximum value integers inside the piles array\\n             Arrays.sort(piles); //Sort the array so that all the higher value elements comes at the end of the array\\n             for(int i =  piles.length - 1 ; i >= piles.length / 2 ; i--){\\nNow observe here one thing , we get maximum values only after the half of the array if the array is already sorted. Like if u have the array like [4,5,7,8]. and we need to apply 2 operations here then our target area should be after arr.length / 2. I hope u understand the loop now\\n                  if(k==0){\\n                     break; //this is the breakpoint \\n                 }\\n                 float value = piles[i]/2f; // get the values after applying operations on the maximum value elements of piles. We store it in piles . I will tell u why below.\\n                 piles[i] = (int)Math.ceil(value); // Math.ceil() function always rounds up and returns the smaller integer greater than or equal to a given number.\\n                 k--; //decrement the k . Now here k might reach zero as well because its decrementing so we need a breakpoint to break the loop.\\n             }\\n         }\\n         int sum = 0;\\n         for(int val : piles){\\n             sum += val;  // Please dont tell me u dont have idea what is this.\\n         } \\n       return sum; //your ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//So our approach should be something in which we can update in the same array. As we can observe here that the maximum integers in the piles are those where we need to apply the operations to get the minimum values. We can only apply operations for K times and on each element we can apply operations as many as we want.\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n      \\n         while(k > 0){ //until k > 0 we are gonna apply the operations on the maximum integers inside the piles array. Why we apply on maximum ? because if we need minimum sum of the array we need to decrease the values of the maximum value elements inside the array . that\\'s why we are targeting the maximum value integers inside the piles array\\n             Arrays.sort(piles); //Sort the array so that all the higher value elements comes at the end of the array\\n             for(int i =  piles.length - 1 ; i >= piles.length / 2 ; i--){\\nNow observe here one thing , we get maximum values only after the half of the array if the array is already sorted. Like if u have the array like [4,5,7,8]. and we need to apply 2 operations here then our target area should be after arr.length / 2. I hope u understand the loop now\\n                  if(k==0){\\n                     break; //this is the breakpoint \\n                 }\\n                 float value = piles[i]/2f; // get the values after applying operations on the maximum value elements of piles. We store it in piles . I will tell u why below.\\n                 piles[i] = (int)Math.ceil(value); // Math.ceil() function always rounds up and returns the smaller integer greater than or equal to a given number.\\n                 k--; //decrement the k . Now here k might reach zero as well because its decrementing so we need a breakpoint to break the loop.\\n             }\\n         }\\n         int sum = 0;\\n         for(int val : piles){\\n             sum += val;  // Please dont tell me u dont have idea what is this.\\n         } \\n       return sum; //your ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961351,
                "title": "python-o-n-max-w-o-heap",
                "content": "# Intuition\\n\\nSince the piles are relatively small, there are more efficient ways to maintain a priority queue.\\n\\n# Approach\\n\\nUse a frequency table to handle duplicate pile sizes: `cnt[size]` is the number of piles with given `size`. \\n\\nAfter building the table, loop from largest to smallest pile size and batch process all piles of this size. Namely, if there are `cnt[pile]` piles of the current size and some `operations` remaining, then we perform a batch of `min(cnt[pile], operations)` operations. \\n\\nNotice how batch processing removes $$k$$ from the complexity entirely.\\n\\n# Complexity\\n\\n- Time complexity: $$O(n + \\\\max)$$. $$O(n)$$ to build the frequency table, $$O(\\\\max)$$ to process it.\\n\\n- Space complexity: $$O(\\\\max)$$ to store the frequency table.\\n\\n# Code\\n\\n```python\\nclass Solution:\\n    def minStoneSum(self, piles: list[int], operations: int) -> int:\\n        max_pile = max(piles)\\n\\n        cnt = [0] * (max_pile + 1)\\n        for pile in piles:\\n            cnt[pile] += 1\\n\\n        for pile in range(max_pile, 0, -1):\\n            take = min(cnt[pile], operations)\\n            cnt[pile] -= take\\n            cnt[pile - pile // 2] += take\\n\\n            operations -= take\\n            if not operations:\\n                break\\n\\n        return sum(pile * cnt[pile] for pile in range(max_pile + 1))\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```python\\nclass Solution:\\n    def minStoneSum(self, piles: list[int], operations: int) -> int:\\n        max_pile = max(piles)\\n\\n        cnt = [0] * (max_pile + 1)\\n        for pile in piles:\\n            cnt[pile] += 1\\n\\n        for pile in range(max_pile, 0, -1):\\n            take = min(cnt[pile], operations)\\n            cnt[pile] -= take\\n            cnt[pile - pile // 2] += take\\n\\n            operations -= take\\n            if not operations:\\n                break\\n\\n        return sum(pile * cnt[pile] for pile in range(max_pile + 1))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961250,
                "title": "simple-solution-100-space-99-48-time-efficiency",
                "content": "# Intuition\\n(x - (floor(x)/2)) == ceil(x)/2 == (x+1)/2 == (x+1) >> 1\\n\\n\\n# Approach\\n1. Sort the vector\\n2. Start dividing, setting piles[i] = ceil(piles[i] / 2) until first value lower than ceil(piles[max] / 2) is found. Then, re-sort the list.\\n3. Repeat until k is 0. \\n4. After k reaches 0, you can just read directly from the vector to a result variable (linear of N time complexity) to find the result.\\n\\nCompile time could possibly be helped by initializing const qualified iterators for piles.begin() and piles.end(), but effect I\\'d imagine would be minimal.\\nYou could also sort in descending order if you wanted, but I found ascending order more intuitive;\\nThe ternary check on index==0 occurs to prevent out of bounds errors.\\n\\n# Complexity\\n- Time complexity:\\n$$O(K*N*lnN)$$\\nI believe that\\'s worst case: it\\'s hard for me to say with testcases being asymptotic in different ways.\\nMost cases will have the vector sorted a number of times dependent K, otherwise it would be $$ O(K+NlnN)$$ for a constant number of sorts\\n\\n\\n- Space complexity:\\n$$O(lnN)$$\\nThis approach only uses the initial array, primitive types, and std::sort. Near constant, but due to be quicksort, asymptotic case is O(lnN)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        const int max = piles.size() - 1;\\n        int index = max, out = 0;\\n        std::sort(piles.begin(), piles.end());\\n        piles[index]++; piles[index]>>=1;\\n        while (--k) {\\n            if (piles[(index == 0) ? 0 : --index] < piles[max]) {\\n                index = max;\\n                std::sort(piles.begin(), piles.end());\\n            }\\n            piles[index]++; piles[index]>>=1;\\n        }\\n        for (const auto& r : piles) {\\n            out += r;\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        const int max = piles.size() - 1;\\n        int index = max, out = 0;\\n        std::sort(piles.begin(), piles.end());\\n        piles[index]++; piles[index]>>=1;\\n        while (--k) {\\n            if (piles[(index == 0) ? 0 : --index] < piles[max]) {\\n                index = max;\\n                std::sort(piles.begin(), piles.end());\\n            }\\n            piles[index]++; piles[index]>>=1;\\n        }\\n        for (const auto& r : piles) {\\n            out += r;\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961138,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n    int sum=0;\\n     PriorityQueue<Integer> pq=new PriorityQueue<Integer>((a,b)->b-a);  \\n     for(int i=0;i<piles.length;i++){\\n     pq.add(piles[i]);\\n     } \\n     int t=0;\\n     while(t<k){\\n        int c=pq.poll();\\n        int r=Math.floorDiv(c,2);\\n        pq.offer(c-r);\\n        t++;\\n     }\\n     while(!pq.isEmpty()){\\n         sum+=pq.poll();\\n     }\\n     return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n    int sum=0;\\n     PriorityQueue<Integer> pq=new PriorityQueue<Integer>((a,b)->b-a);  \\n     for(int i=0;i<piles.length;i++){\\n     pq.add(piles[i]);\\n     } \\n     int t=0;\\n     while(t<k){\\n        int c=pq.poll();\\n        int r=Math.floorDiv(c,2);\\n        pq.offer(c-r);\\n        t++;\\n     }\\n     while(!pq.isEmpty()){\\n         sum+=pq.poll();\\n     }\\n     return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961055,
                "title": "multiset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        multiset<int>st;\\n        int n=piles.size(),ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            st.insert(piles[i]);\\n            ans+=piles[i];\\n        }\\n        while(k--)\\n        {\\n            if(st.size())\\n            {\\n                auto it=st.end();\\n                if(it!=st.begin())\\n                {\\n                    it--;\\n                }\\n                int num=*it;\\n                ans-=(num/2);\\n                st.erase(st.find(num));\\n                st.insert(num-num/2);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        multiset<int>st;\\n        int n=piles.size(),ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            st.insert(piles[i]);\\n            ans+=piles[i];\\n        }\\n        while(k--)\\n        {\\n            if(st.size())\\n            {\\n                auto it=st.end();\\n                if(it!=st.begin())\\n                {\\n                    it--;\\n                }\\n                int num=*it;\\n                ans-=(num/2);\\n                st.erase(st.find(num));\\n                st.insert(num-num/2);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961036,
                "title": "c-priority-queue-100-fast-easy-understanding-simple-solution",
                "content": "# Intuition\\nPriorty Queue can be solved in O(N) time complexity.\\n\\n# Approach\\npriority queue gives max value at each time,which can be made half K times.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> q;\\n        int n=piles.size();\\n        for(int i=0;i<n;i++){\\n            q.push(piles[i]);\\n        }\\n        for(int i=0;i<k;i++){\\n            int x=q.top(); q.pop();\\n            (x%2==0)? x=x/2:x=x/2+1; //x is the greatest integer that is smaller than or equal to x/2 (i.e., rounds x down).\\n            q.push(x);\\n            if(q.top()==1)  //To decrease time complexity.\\n            break;\\n        }\\n        int sum=0;\\n        while(!q.empty()){\\n            sum+=q.top(); q.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> q;\\n        int n=piles.size();\\n        for(int i=0;i<n;i++){\\n            q.push(piles[i]);\\n        }\\n        for(int i=0;i<k;i++){\\n            int x=q.top(); q.pop();\\n            (x%2==0)? x=x/2:x=x/2+1; //x is the greatest integer that is smaller than or equal to x/2 (i.e., rounds x down).\\n            q.push(x);\\n            if(q.top()==1)  //To decrease time complexity.\\n            break;\\n        }\\n        int sum=0;\\n        while(!q.empty()){\\n            sum+=q.top(); q.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961032,
                "title": "c-max-heap-two-solutions",
                "content": "\\n\\n# Complexity:\\n- Time complexity: O(nlogn)<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1: \\n```\\nclass Solution\\n{\\npublic:\\n    int minStoneSum(vector<int> &piles, int k)\\n    {\\n        int n = piles.size();\\n        priority_queue<int> q;\\n        int ans = 0;\\n\\n        for (auto i : piles)\\n        {\\n            ans += i;\\n            q.push(i);\\n        }\\n\\n        while (k--)\\n        {\\n            int temp = q.top();\\n            q.pop();\\n\\n            q.push(temp - temp / 2);\\n            ans -= temp / 2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n# Complexity:\\n- Time complexity: O(nlogn)<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 2: \\n```\\nclass Solution\\n{\\npublic:\\n    int minStoneSum(vector<int> &piles, int k)\\n    {\\n        int n = piles.size();\\n        priority_queue<int> q;\\n        int ans = 0;\\n\\n        for (auto i : piles)\\n            q.push(i);\\n\\n        while (!q.empty() and k > 0)\\n        {\\n            int temp = q.top();\\n            q.pop();\\n\\n            q.push(temp - temp / 2);\\n            k--;\\n        }\\n\\n        while (!q.empty())\\n        {\\n            ans += q.top();\\n            q.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minStoneSum(vector<int> &piles, int k)\\n    {\\n        int n = piles.size();\\n        priority_queue<int> q;\\n        int ans = 0;\\n\\n        for (auto i : piles)\\n        {\\n            ans += i;\\n            q.push(i);\\n        }\\n\\n        while (k--)\\n        {\\n            int temp = q.top();\\n            q.pop();\\n\\n            q.push(temp - temp / 2);\\n            ans -= temp / 2;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    int minStoneSum(vector<int> &piles, int k)\\n    {\\n        int n = piles.size();\\n        priority_queue<int> q;\\n        int ans = 0;\\n\\n        for (auto i : piles)\\n            q.push(i);\\n\\n        while (!q.empty() and k > 0)\\n        {\\n            int temp = q.top();\\n            q.pop();\\n\\n            q.push(temp - temp / 2);\\n            k--;\\n        }\\n\\n        while (!q.empty())\\n        {\\n            ans += q.top();\\n            q.pop();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960976,
                "title": "pseudo-polynomial-time-algorithm-beats-99",
                "content": "Time complexity $$O(n+m)$$, where $$m$$ is the max number in the input.\\n\\nThe pseudo polynomial algorithm solution runs faster for the given input constraints than the heap approach with TC $$O(n+k\\\\cdot log(n))$$. We can\\'t directly compare the TCs without knowing the inputs.\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& v, int k) {\\n        vector<int> c(10001, 0);\\n        for (auto &a:v) { c[a]++; }\\n\\n        int s = accumulate(begin(v), end(v), 0);\\n\\n        for (int i = 10000; i > 1; --i) {\\n            int r = min(k, c[i]);\\n\\n            k -= r;\\n            c[i] -= r;\\n            c[i - i/2] += r;\\n\\n            s -= r*(i/2);\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& v, int k) {\\n        vector<int> c(10001, 0);\\n        for (auto &a:v) { c[a]++; }\\n\\n        int s = accumulate(begin(v), end(v), 0);\\n\\n        for (int i = 10000; i > 1; --i) {\\n            int r = min(k, c[i]);\\n\\n            k -= r;\\n            c[i] -= r;\\n            c[i - i/2] += r;\\n\\n            s -= r*(i/2);\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960922,
                "title": "beat-100-112-ms-1st-arryay-hash-using-array-2-sol-priorityqueue",
                "content": "\\n\\n# Approach\\nUse array and start from max to apply k operation.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1e4)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        ios_base::sync_with_stdio(0);\\n        /* //Method 1\\n        priority_queue<int> pq(piles.begin(),piles.end());\\n        while (k-- > 0){\\n            int t = pq.top();\\n            pq.pop();\\n            pq.push(t-t/2);\\n        }\\n\\n        int sum=0;\\n        while (pq.size()) sum += pq.top(),pq.pop();\\n\\n        return sum;\\n        */\\n        //Method 2\\n        int num[10001] = {0};\\n        for (auto e: piles)num[e]++;\\n\\n        for (int i=10000; i >=0 && k; i--){\\n            if(!num[i])continue;\\n            int count = min(k, num[i]);\\n            k = k-count;\\n            num[i] -= count;\\n            num[i-i/2] += count;\\n        }\\n\\n        int sum=0;\\n        for (int i=10000; i >0 ; i--){\\n            if (num[i]) sum += i*num[i];\\n        }\\n        \\n        return sum;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        ios_base::sync_with_stdio(0);\\n        /* //Method 1\\n        priority_queue<int> pq(piles.begin(),piles.end());\\n        while (k-- > 0){\\n            int t = pq.top();\\n            pq.pop();\\n            pq.push(t-t/2);\\n        }\\n\\n        int sum=0;\\n        while (pq.size()) sum += pq.top(),pq.pop();\\n\\n        return sum;\\n        */\\n        //Method 2\\n        int num[10001] = {0};\\n        for (auto e: piles)num[e]++;\\n\\n        for (int i=10000; i >=0 && k; i--){\\n            if(!num[i])continue;\\n            int count = min(k, num[i]);\\n            k = k-count;\\n            num[i] -= count;\\n            num[i-i/2] += count;\\n        }\\n\\n        int sum=0;\\n        for (int i=10000; i >0 ; i--){\\n            if (num[i]) sum += i*num[i];\\n        }\\n        \\n        return sum;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960871,
                "title": "c-priority-q-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to apply the given operation on the largest pile of stones to get the minimum number of stones in the end. To always get the largest element, we use priority queues.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O((N+K)logN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int n=piles.size(),remainingStone=0;\\n        priority_queue<int>pq;\\n        for(auto a:piles)pq.push(a);\\n        while(k--){\\n            int stone=pq.top();\\n            pq.pop();\\n            pq.push((stone+1)/2);\\n        }\\n\\n        while(!pq.empty()){remainingStone+=pq.top();pq.pop();}\\n        return remainingStone;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int n=piles.size(),remainingStone=0;\\n        priority_queue<int>pq;\\n        for(auto a:piles)pq.push(a);\\n        while(k--){\\n            int stone=pq.top();\\n            pq.pop();\\n            pq.push((stone+1)/2);\\n        }\\n\\n        while(!pq.empty()){remainingStone+=pq.top();pq.pop();}\\n        return remainingStone;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960772,
                "title": "c-begineer-friendly-easy-understanding-heap-video-solution",
                "content": "# Intuition && Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n **C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=YQMVcJdsuDU/\\n <!-- your approach to solving the problem. --> -->\\n\\n# Complexity\\n- Time complexity:\\n- (n+k)log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq(piles.begin(),piles.end());\\n        for(int i=0;i<k;i++){\\n            int temp = pq.top();\\n            pq.pop();\\n            pq.push(temp-(temp/2));\\n        }\\n\\n        int ans=0;\\n        while(!pq.empty()){\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq(piles.begin(),piles.end());\\n        for(int i=0;i<k;i++){\\n            int temp = pq.top();\\n            pq.pop();\\n            pq.push(temp-(temp/2));\\n        }\\n\\n        int ans=0;\\n        while(!pq.empty()){\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960760,
                "title": "python-hash-table-beats-100",
                "content": "# Description\\nHere\\'s something a bit different from the typical heap solution.\\n\\nObserve that the *entries* in the input actually have an upper bound that is *below* the maximum input length, which makes hash table an efficient choice of data structure. The keys are integers, so we can use an array as the hash table, which also lets us find the largest pile in constant time - as long as we remember to remove the empty piles from the top.\\n\\n# Complexity\\n- Time complexity: O(n + k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(max(piles))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n\\n        # Construct frequency table\\n        count = [0 for x in range(max(piles)+1)]\\n        for x in piles: count[x] += 1\\n\\n        # Perform pile-halving\\n        for _ in range(k):\\n            count[-1] -= 1\\n            count[len(count) // 2] += 1\\n\\n            # Remove empty piles from top, to ensure top pile has any stones\\n            while count[-1] == 0: count.pop()\\n        \\n        # Count remainder\\n        return sum(i * count[i] for i in range(len(count)))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n\\n        # Construct frequency table\\n        count = [0 for x in range(max(piles)+1)]\\n        for x in piles: count[x] += 1\\n\\n        # Perform pile-halving\\n        for _ in range(k):\\n            count[-1] -= 1\\n            count[len(count) // 2] += 1\\n\\n            # Remove empty piles from top, to ensure top pile has any stones\\n            while count[-1] == 0: count.pop()\\n        \\n        # Count remainder\\n        return sum(i * count[i] for i in range(len(count)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960671,
                "title": "java-go-kotlin-beat-99-100-straightforward-solution-by-simply-using-array",
                "content": "# Intuition\\r\\nSince the constraint for `piles[i]` is between 1 and 10000. We can build an array with 10001 elements without burden. By labeling the index of this array as the `key` and each number within this array as the `value`, it can serve as a tree map, a more efficient one. Hence, we no longer need a heap to solve the problem in this case.\\r\\n\\r\\n# Approach\\r\\nHere are only a few points that need to care about.\\r\\n1. Build an array with 10001 elements.\\r\\n2. Find the biggest number in the piles, this is the edge of your array.\\r\\n3. Start from the biggest number, operating the array for k times.\\r\\n4. Last, sum up the array.\\r\\n# Complexity\\r\\n- Time complexity: $$O(n)$$\\r\\n\\r\\n- Space complexity: $$O(n)$$\\r\\n\\r\\n# Java Code\\r\\n```\\r\\nclass Solution {\\r\\n    public int minStoneSum(int[] piles, int k) {\\r\\n        int n = piles.length;\\r\\n        int[] mapping = new int[10001];\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            mapping[piles[i]]++;\\r\\n        }\\r\\n\\r\\n        int currNum = 0;\\r\\n        // find the edge of mapping\\r\\n        for (int i = 10000; i > 0; i--) {\\r\\n            if (mapping[i] != 0) {\\r\\n                currNum = i;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (int i = 0; i < k; i++) {\\r\\n            while (mapping[currNum] == 0) {\\r\\n                currNum--;\\r\\n            }\\r\\n            mapping[currNum]--;\\r\\n            switch (currNum % 2) {\\r\\n                case 0:\\r\\n                    mapping[currNum / 2]++;\\r\\n                    break;\\r\\n                case 1:\\r\\n                    mapping[currNum / 2 + 1]++;\\r\\n                    break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int ans = 0;\\r\\n        for (int i = 0; i <= currNum; i++) {\\r\\n            if (mapping[i] > 0) {\\r\\n                ans += (i * mapping[i]);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return ans;\\r\\n    }\\r\\n}\\r\\n```\\r\\n\\r\\n# Go code\\r\\n```\\r\\nfunc minStoneSum(piles []int, k int) int {\\r\\n    var n int = len(piles)\\r\\n\\tvar mapping = make([]int, 10001)\\r\\n\\r\\n\\tfor i := 0; i < n; i++ {\\r\\n\\t\\tmapping[piles[i]]++\\r\\n\\t}\\r\\n\\r\\n\\t// Find the edge of mapping\\r\\n\\tvar currNum int = 0\\r\\n\\tfor i := 10000; i > 0; i-- {\\r\\n\\t\\tif mapping[i] > 0 {\\r\\n\\t\\t\\tcurrNum = i\\r\\n\\t\\t\\tbreak\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// start operating for k times\\r\\n\\tfor i := 0; i < k; i++ {\\r\\n\\t\\tfor mapping[currNum] == 0 {\\r\\n\\t\\t\\tcurrNum--\\r\\n\\t\\t}\\r\\n\\t\\tmapping[currNum]--\\r\\n\\t\\tswitch(currNum%2) {\\r\\n\\t\\tcase 0:\\r\\n\\t\\t\\tmapping[currNum/2]++\\r\\n\\t\\tcase 1:\\r\\n\\t\\t\\tmapping[currNum/2+1]++\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// start summing up\\r\\n\\tvar ans int = 0\\r\\n\\tfor i := 0; i <= currNum; i++ {\\r\\n\\t\\tif mapping[i] > 0 {\\r\\n\\t\\t\\tans += i*mapping[i]\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\treturn ans\\r\\n}\\r\\n```\\r\\n\\r\\n# Kotlin code\\r\\n```\\r\\nclass Solution {\\r\\n    fun minStoneSum(piles: IntArray, k: Int): Int {\\r\\n        var n: Int = piles.size\\r\\n        val mapping: IntArray = IntArray(10001){0}\\r\\n        for(i in 0 until n) {\\r\\n            mapping[piles[i]]++\\r\\n        }\\r\\n\\r\\n        var currNum: Int = 0\\r\\n        for(i in 10000 downTo 1) {\\r\\n            if(mapping[i] != 0) {\\r\\n                currNum = i\\r\\n                break\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for(i in 0 until k) {\\r\\n            while(mapping[currNum] == 0) {\\r\\n                currNum--\\r\\n            }\\r\\n            mapping[currNum]--\\r\\n            when(currNum % 2) {\\r\\n                0 -> mapping[currNum / 2]++\\r\\n                1 -> mapping[currNum / 2 + 1]++\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Summing up\\r\\n        var ans: Int = 0\\r\\n        for(i in 0 until currNum+1) {\\r\\n            if(mapping[i] > 0) {\\r\\n                ans += (i * mapping[i])\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return ans\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "Java",
                    "Go",
                    "Kotlin"
                ],
                "code": "```\\r\\nclass Solution {\\r\\n    public int minStoneSum(int[] piles, int k) {\\r\\n        int n = piles.length;\\r\\n        int[] mapping = new int[10001];\\r\\n        for (int i = 0; i < n; i++) {\\r\\n            mapping[piles[i]]++;\\r\\n        }\\r\\n\\r\\n        int currNum = 0;\\r\\n        // find the edge of mapping\\r\\n        for (int i = 10000; i > 0; i--) {\\r\\n            if (mapping[i] != 0) {\\r\\n                currNum = i;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for (int i = 0; i < k; i++) {\\r\\n            while (mapping[currNum] == 0) {\\r\\n                currNum--;\\r\\n            }\\r\\n            mapping[currNum]--;\\r\\n            switch (currNum % 2) {\\r\\n                case 0:\\r\\n                    mapping[currNum / 2]++;\\r\\n                    break;\\r\\n                case 1:\\r\\n                    mapping[currNum / 2 + 1]++;\\r\\n                    break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        int ans = 0;\\r\\n        for (int i = 0; i <= currNum; i++) {\\r\\n            if (mapping[i] > 0) {\\r\\n                ans += (i * mapping[i]);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return ans;\\r\\n    }\\r\\n}\\r\\n```\n```\\r\\nfunc minStoneSum(piles []int, k int) int {\\r\\n    var n int = len(piles)\\r\\n\\tvar mapping = make([]int, 10001)\\r\\n\\r\\n\\tfor i := 0; i < n; i++ {\\r\\n\\t\\tmapping[piles[i]]++\\r\\n\\t}\\r\\n\\r\\n\\t// Find the edge of mapping\\r\\n\\tvar currNum int = 0\\r\\n\\tfor i := 10000; i > 0; i-- {\\r\\n\\t\\tif mapping[i] > 0 {\\r\\n\\t\\t\\tcurrNum = i\\r\\n\\t\\t\\tbreak\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// start operating for k times\\r\\n\\tfor i := 0; i < k; i++ {\\r\\n\\t\\tfor mapping[currNum] == 0 {\\r\\n\\t\\t\\tcurrNum--\\r\\n\\t\\t}\\r\\n\\t\\tmapping[currNum]--\\r\\n\\t\\tswitch(currNum%2) {\\r\\n\\t\\tcase 0:\\r\\n\\t\\t\\tmapping[currNum/2]++\\r\\n\\t\\tcase 1:\\r\\n\\t\\t\\tmapping[currNum/2+1]++\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// start summing up\\r\\n\\tvar ans int = 0\\r\\n\\tfor i := 0; i <= currNum; i++ {\\r\\n\\t\\tif mapping[i] > 0 {\\r\\n\\t\\t\\tans += i*mapping[i]\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\r\\n\\treturn ans\\r\\n}\\r\\n```\n```\\r\\nclass Solution {\\r\\n    fun minStoneSum(piles: IntArray, k: Int): Int {\\r\\n        var n: Int = piles.size\\r\\n        val mapping: IntArray = IntArray(10001){0}\\r\\n        for(i in 0 until n) {\\r\\n            mapping[piles[i]]++\\r\\n        }\\r\\n\\r\\n        var currNum: Int = 0\\r\\n        for(i in 10000 downTo 1) {\\r\\n            if(mapping[i] != 0) {\\r\\n                currNum = i\\r\\n                break\\r\\n            }\\r\\n        }\\r\\n\\r\\n        for(i in 0 until k) {\\r\\n            while(mapping[currNum] == 0) {\\r\\n                currNum--\\r\\n            }\\r\\n            mapping[currNum]--\\r\\n            when(currNum % 2) {\\r\\n                0 -> mapping[currNum / 2]++\\r\\n                1 -> mapping[currNum / 2 + 1]++\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Summing up\\r\\n        var ans: Int = 0\\r\\n        for(i in 0 until currNum+1) {\\r\\n            if(mapping[i] > 0) {\\r\\n                ans += (i * mapping[i])\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return ans\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960642,
                "title": "simple-java-code-java-priorityqueue-max-heap-greedy-approach-with-easier-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLook for maximum element i.e., **\"x\"** in our case and replace it with **floor(x/2)** for **\\'k\\'** iteratios and then *return the sum of elements in the datastructure* that you\\'ve used.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have organised our data into **PriorityQueue** to implement *maxHeap* to get the maximum element and each time maximum element in the heap i.e., **\"x\"** is replaced with **floor(x/2**) for **\\'k\\'** iterations and later we *pop out all elements from queue* and *add it to resulting sum* which is the required output.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nif *n>=k* **O(n*log(n))** else **O(k*log(n))**\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)**\\n# Code\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) \\n    {\\n        int sum=0;\\n        /* Priority Queue with Comparator Collections.reverseOrder() or we can use (a,b)->b-a) to implement maxHeap terminology*/\\n        \\n        Queue<Integer> maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        \\n        /* add all elements of int[] array to prioirty Queue by converting it into Integer     \\n        array using Streams instead of Arrays.stream() you can also use IntStream.of()*/\\n        maxHeap.addAll(Arrays.asList(Arrays.stream(piles).boxed().toArray(Integer[]::new)));\\n       \\n        while(k>0)\\n        {\\n            /* you can also use add() method here, maxHeap.poll() removes the maximum element \\'x\\' from queue and offer() replaces it with floor(x/2) */\\n            maxHeap.offer((int)Math.round(maxHeap.poll()/2.0));\\n            k--;\\n        }\\n\\n        /* removing elements from the Queue and adding them to the resultant sum. */\\n        while(!maxHeap.isEmpty())\\n        {\\n            sum+=maxHeap.poll();\\n        } \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) \\n    {\\n        int sum=0;\\n        /* Priority Queue with Comparator Collections.reverseOrder() or we can use (a,b)->b-a) to implement maxHeap terminology*/\\n        \\n        Queue<Integer> maxHeap = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        \\n        /* add all elements of int[] array to prioirty Queue by converting it into Integer     \\n        array using Streams instead of Arrays.stream() you can also use IntStream.of()*/\\n        maxHeap.addAll(Arrays.asList(Arrays.stream(piles).boxed().toArray(Integer[]::new)));\\n       \\n        while(k>0)\\n        {\\n            /* you can also use add() method here, maxHeap.poll() removes the maximum element \\'x\\' from queue and offer() replaces it with floor(x/2) */\\n            maxHeap.offer((int)Math.round(maxHeap.poll()/2.0));\\n            k--;\\n        }\\n\\n        /* removing elements from the Queue and adding them to the resultant sum. */\\n        while(!maxHeap.isEmpty())\\n        {\\n            sum+=maxHeap.poll();\\n        } \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960569,
                "title": "concise-binaryheap-imperative-functional-style-solutions-in-rust",
                "content": "# Intuition\\nEach time we should take a pile with maximum amount of stones and remove stones from there.\\n\\n# Approach\\nWe\\'ll use binary heap to maintain pile order while removing stones.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n + k*log(n))$$ as it takes $$O(n)$$ time to build heap and then we have $$k$$ iterations to remove stones each consuming $$log(n)$$ time. Finaly we compute sum of remaining stones over all piles that again has $$O(n)$$ complexity.\\n\\n- Space complexity:\\n$$O(1)$$ as we don\\'t use extra space because the `BinaryHeap::from` method consumes input `piles` vector and builds heap in-place with no extra allocations.\\n\\n# Imperative Style Code\\n```\\nuse std::collections::BinaryHeap;\\nimpl Solution {\\n    pub fn min_stone_sum(piles: Vec<i32>, k: i32) -> i32 {\\n        let mut heap = BinaryHeap::from(piles);\\n        for _ in 0..k {\\n            let pile = heap.pop().expect(\"Heap is never empty.\");\\n            heap.push(pile - (pile >> 1));\\n        }\\n        heap.iter().sum()\\n    }\\n}\\n```\\n\\n# Functional Style Code\\n```\\nuse std::collections::BinaryHeap;\\nimpl Solution {\\n    pub fn min_stone_sum(piles: Vec<i32>, k: i32) -> i32 {\\n        (0..k).fold(BinaryHeap::from(piles), |mut heap, _| heap.pop().map(|pile| { heap.push(pile - (pile >> 1)); heap }).expect(\"Heap is never empty.\")).iter().sum()\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\nimpl Solution {\\n    pub fn min_stone_sum(piles: Vec<i32>, k: i32) -> i32 {\\n        let mut heap = BinaryHeap::from(piles);\\n        for _ in 0..k {\\n            let pile = heap.pop().expect(\"Heap is never empty.\");\\n            heap.push(pile - (pile >> 1));\\n        }\\n        heap.iter().sum()\\n    }\\n}\\n```\n```\\nuse std::collections::BinaryHeap;\\nimpl Solution {\\n    pub fn min_stone_sum(piles: Vec<i32>, k: i32) -> i32 {\\n        (0..k).fold(BinaryHeap::from(piles), |mut heap, _| heap.pop().map(|pile| { heap.push(pile - (pile >> 1)); heap }).expect(\"Heap is never empty.\")).iter().sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2960488,
                "title": "javascript-solution-using-built-in-priority-queue",
                "content": "Based on https://leetcode.com/problems/remove-stones-to-minimize-the-total/discuss/1390254/JavaC%2B%2BPython-Heap-Solution-O(klogn)\\n\\n1. Create a new ```MaxPriorityQueue```, count all the ```stones``` in ```piles``` while ```enqueue```-ing them.\\n2. Loop ```k``` times, each time removing ```Math.floor(pile / 2)``` from ```stones``` while ```dequeue```-ing, subtracting, and ```enqueue```-ing each ```pile```.\\n3. Return ```stones```, submit code, and wait 1770ms for it to run.\\n\\n```\\n/**\\n * @param {number[]} piles\\n * @param {number} k\\n * @return {number}\\n */\\nvar minStoneSum = function(piles, k) {\\n    const pq = new MaxPriorityQueue()\\n    let stones = 0\\n    piles.forEach(pile => {\\n        pq.enqueue(pile)\\n        stones += pile\\n    })\\n    while(k--) {\\n        let pile = pq.dequeue().element\\n        stones -= Math.floor(pile / 2)\\n        pq.enqueue(pile - Math.floor(pile / 2))\\n    }\\n    return stones\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```MaxPriorityQueue```\n```stones```\n```piles```\n```enqueue```\n```k```\n```Math.floor(pile / 2)```\n```stones```\n```dequeue```\n```enqueue```\n```pile```\n```stones```\n```\\n/**\\n * @param {number[]} piles\\n * @param {number} k\\n * @return {number}\\n */\\nvar minStoneSum = function(piles, k) {\\n    const pq = new MaxPriorityQueue()\\n    let stones = 0\\n    piles.forEach(pile => {\\n        pq.enqueue(pile)\\n        stones += pile\\n    })\\n    while(k--) {\\n        let pile = pq.dequeue().element\\n        stones -= Math.floor(pile / 2)\\n        pq.enqueue(pile - Math.floor(pile / 2))\\n    }\\n    return stones\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2914675,
                "title": "max-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport math\\nfrom heapq import heappush,heappop\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        heap=[]\\n        for i in range(len(piles)):\\n            heappush(heap,-piles[i])\\n        while(k>0):\\n            a=heappop(heap)\\n            c=-a-math.floor(-a/2)\\n            heappush(heap,-c)\\n            k-=1\\n        su=0\\n        while(heap):\\n            su+=-heappop(heap)\\n        return(su)\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport math\\nfrom heapq import heappush,heappop\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        heap=[]\\n        for i in range(len(piles)):\\n            heappush(heap,-piles[i])\\n        while(k>0):\\n            a=heappop(heap)\\n            c=-a-math.floor(-a/2)\\n            heappush(heap,-c)\\n            k-=1\\n        su=0\\n        while(heap):\\n            su+=-heappop(heap)\\n        return(su)\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795049,
                "title": "javascript-solution-using-heap-data-structure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Heap data structure\\n\\n# Complexity\\n- Time complexity: O(k log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} piles\\n * @param {number} k\\n * @return {number}\\n */\\nvar minStoneSum = function(piles, k) {\\n    class MaxHeap{\\n        constructor(){\\n            this.arr=[]\\n        }\\n        parent = (i)=> Math.floor((i-1)/2)\\n        leftChild = i => 2*i+1\\n        rightChild = i => 2*i+2\\n\\n        swap = (i,j)=>{\\n            let temp=this.arr[i]\\n            this.arr[i] = this.arr[j]\\n            this.arr[j] = temp\\n        }\\n\\n        // siftUp - to bubble up the largest number. Compares with parent and swap\\n        siftUp = (i)=>{\\n            let parentIndex = this.parent(i)\\n\\n            if(i>0 && this.arr[i]>this.arr[parentIndex]){\\n                this.swap(i,parentIndex)\\n                this.siftUp(parentIndex)\\n            }\\n        }\\n\\n        // siftDown - to bring down smaller number. Compares with left and right children and swap\\n        siftDown = (i)=>{\\n            let left = this.leftChild(i)\\n            let right = this.rightChild(i)\\n            let maxIndex = i\\n\\n            if(left<this.arr.length && this.arr[left]>this.arr[maxIndex])\\n                maxIndex = left\\n\\n            if(right<this.arr.length && this.arr[right]>this.arr[maxIndex])\\n                maxIndex = right\\n\\n            if(i!==maxIndex){\\n                this.swap(i,maxIndex)\\n                this.siftDown(maxIndex)\\n            }\\n        }\\n\\n        add = (x)=>{\\n            this.arr.push(x)\\n            this.siftUp(this.arr.length-1)\\n        }\\n\\n        delete = (i)=>{           \\n            if(this.arr.length===1) this.arr.pop()\\n            else{\\n                this.arr[i] = this.arr.pop()            \\n                this.siftDown(i)\\n            }\\n        }\\n\\n        extractMax = ()=>{\\n            let max = this.arr[0]\\n            this.delete(0)\\n            return max\\n        }\\n    }\\n\\n    let heap = new MaxHeap()\\n\\n    // Insert array elements to heap => O(n)\\n    for(let i=0;i<piles.length;i++){\\n        heap.add(piles[i])\\n    }\\n\\n    // O(k log(n))\\n    for(let i=0;i<k;i++){\\n        let max = heap.extractMax()     // Extract largest element from top of heap => O(1)\\n        heap.add(max-Math.floor(max/2)) // Insert new element to heap => O(log n)\\n    }\\n\\n    return heap.arr.reduce((p,c)=>p+c)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} piles\\n * @param {number} k\\n * @return {number}\\n */\\nvar minStoneSum = function(piles, k) {\\n    class MaxHeap{\\n        constructor(){\\n            this.arr=[]\\n        }\\n        parent = (i)=> Math.floor((i-1)/2)\\n        leftChild = i => 2*i+1\\n        rightChild = i => 2*i+2\\n\\n        swap = (i,j)=>{\\n            let temp=this.arr[i]\\n            this.arr[i] = this.arr[j]\\n            this.arr[j] = temp\\n        }\\n\\n        // siftUp - to bubble up the largest number. Compares with parent and swap\\n        siftUp = (i)=>{\\n            let parentIndex = this.parent(i)\\n\\n            if(i>0 && this.arr[i]>this.arr[parentIndex]){\\n                this.swap(i,parentIndex)\\n                this.siftUp(parentIndex)\\n            }\\n        }\\n\\n        // siftDown - to bring down smaller number. Compares with left and right children and swap\\n        siftDown = (i)=>{\\n            let left = this.leftChild(i)\\n            let right = this.rightChild(i)\\n            let maxIndex = i\\n\\n            if(left<this.arr.length && this.arr[left]>this.arr[maxIndex])\\n                maxIndex = left\\n\\n            if(right<this.arr.length && this.arr[right]>this.arr[maxIndex])\\n                maxIndex = right\\n\\n            if(i!==maxIndex){\\n                this.swap(i,maxIndex)\\n                this.siftDown(maxIndex)\\n            }\\n        }\\n\\n        add = (x)=>{\\n            this.arr.push(x)\\n            this.siftUp(this.arr.length-1)\\n        }\\n\\n        delete = (i)=>{           \\n            if(this.arr.length===1) this.arr.pop()\\n            else{\\n                this.arr[i] = this.arr.pop()            \\n                this.siftDown(i)\\n            }\\n        }\\n\\n        extractMax = ()=>{\\n            let max = this.arr[0]\\n            this.delete(0)\\n            return max\\n        }\\n    }\\n\\n    let heap = new MaxHeap()\\n\\n    // Insert array elements to heap => O(n)\\n    for(let i=0;i<piles.length;i++){\\n        heap.add(piles[i])\\n    }\\n\\n    // O(k log(n))\\n    for(let i=0;i<k;i++){\\n        let max = heap.extractMax()     // Extract largest element from top of heap => O(1)\\n        heap.add(max-Math.floor(max/2)) // Insert new element to heap => O(log n)\\n    }\\n\\n    return heap.arr.reduce((p,c)=>p+c)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792451,
                "title": "simple-heap-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int minStoneSum(vector<int> &piles, int k)\\n        {\\n            priority_queue<int> heap;\\n            for (int i = 0; i < piles.size(); i++)\\n                heap.push(piles[i]);\\n            int stone = 0;\\n            while (heap.size() and k)\\n            {\\n                int z = heap.top();\\n                heap.pop();\\n                z = ceil(z / 2.0);\\n                if (z > 0)\\n                    heap.push(z);\\n                k -= 1;\\n            }\\n            while (heap.size())\\n            {\\n                stone += heap.top();\\n                heap.pop();\\n            }\\n            return stone;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int minStoneSum(vector<int> &piles, int k)\\n        {\\n            priority_queue<int> heap;\\n            for (int i = 0; i < piles.size(); i++)\\n                heap.push(piles[i]);\\n            int stone = 0;\\n            while (heap.size() and k)\\n            {\\n                int z = heap.top();\\n                heap.pop();\\n                z = ceil(z / 2.0);\\n                if (z > 0)\\n                    heap.push(z);\\n                k -= 1;\\n            }\\n            while (heap.size())\\n            {\\n                stone += heap.top();\\n                heap.pop();\\n            }\\n            return stone;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2232128,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& arr, int k) {\\n        priority_queue<int>pq(arr.begin(),arr.end());\\n        while(k--){\\n            int t=pq.top();\\n            pq.pop();\\n            pq.push(t-t/2);\\n        }\\n       long long int sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& arr, int k) {\\n        priority_queue<int>pq(arr.begin(),arr.end());\\n        while(k--){\\n            int t=pq.top();\\n            pq.pop();\\n            pq.push(t-t/2);\\n        }\\n       long long int sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135729,
                "title": "without-using-priority-queue-380-ms-faster-than-99-36-of-c-online-submissions",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        while(k>0)\\n        {\\n            sort(piles.begin(),piles.end(),greater<int>());\\n            int temp = piles[0]-piles[0]/2;\\n            for(int i=0;i<piles.size();i++)\\n            {\\n                if(k==0)\\n                    break;\\n                if(temp<=piles[i])\\n                {\\n                    piles[i] = piles[i]-piles[i]/2;\\n                    k--;\\n                }\\n                else if(temp>piles[i])\\n                    break;\\n            }    \\n        }\\n        int sum =0;\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            sum += piles[i];\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        while(k>0)\\n        {\\n            sort(piles.begin(),piles.end(),greater<int>());\\n            int temp = piles[0]-piles[0]/2;\\n            for(int i=0;i<piles.size();i++)\\n            {\\n                if(k==0)\\n                    break;\\n                if(temp<=piles[i])\\n                {\\n                    piles[i] = piles[i]-piles[i]/2;\\n                    k--;\\n                }\\n                else if(temp>piles[i])\\n                    break;\\n            }    \\n        }\\n        int sum =0;\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            sum += piles[i];\\n        }\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114333,
                "title": "explained-easy-python-solution-using-max-heap",
                "content": "# [Explained] Easy Python Solution Using Max Heap\\n\\n```\\nimport heapq\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        \"\"\"\\n\\t\\tTo use Max Heap, we need to convert all values to -ve  integers\\n\\t\\t\"\"\"\\n\\t\\tfor i in range(len(piles)):\\n            piles[i]= -1 * piles[i]\\n        \\n\\t\\t\"\"\"\\n\\t\\tCreating heap of the given list\\n\\t\\t\"\"\"\\n        heapq.heapify(piles)\\n        \\n\\t\\t\"\"\"\\n\\t\\twhile k > 0, applying the provided operation\\n\\t\\tto the maximum value\\n\\t\\t\"\"\"\\n        while k:\\n            a = heapq.heappop(piles)\\n            a = a//2\\n            heapq.heappush(piles, a)\\n            k -= 1\\n        \\n\\t\\t\"\"\"\\n\\t\\tThe elements in the list are updated,\\n\\t\\tnow the contain the minimum possible sum\\n\\t\\t\"\"\"\\n        return abs(sum(piles))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        \"\"\"\\n\\t\\tTo use Max Heap, we need to convert all values to -ve  integers\\n\\t\\t\"\"\"\\n\\t\\tfor i in range(len(piles)):\\n            piles[i]= -1 * piles[i]\\n        \\n\\t\\t\"\"\"\\n\\t\\tCreating heap of the given list\\n\\t\\t\"\"\"\\n        heapq.heapify(piles)\\n        \\n\\t\\t\"\"\"\\n\\t\\twhile k > 0, applying the provided operation\\n\\t\\tto the maximum value\\n\\t\\t\"\"\"\\n        while k:\\n            a = heapq.heappop(piles)\\n            a = a//2\\n            heapq.heappush(piles, a)\\n            k -= 1\\n        \\n\\t\\t\"\"\"\\n\\t\\tThe elements in the list are updated,\\n\\t\\tnow the contain the minimum possible sum\\n\\t\\t\"\"\"\\n        return abs(sum(piles))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035017,
                "title": "heap-solution-java",
                "content": "```\\nclass Solution {\\n    public int minStoneSum(int[] arr, int k) {\\n        \\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a,b)->b-a);\\n        // creating max Heap\\n        // adding all array Elements\\n        for(int i = 0;i<arr.length;i++){\\n            maxHeap.add(arr[i]);\\n        }\\n        // applying floor on max k times\\n        while(k>0){\\n            k--;\\n            int x = maxHeap.poll();\\n            if(x % 2 == 0)\\n                x = x/2;\\n            else\\n                x = x/2+1;\\n            maxHeap.add(x);\\n        }\\n        int ans = 0; \\n        while(!maxHeap.isEmpty()){\\n            ans+=maxHeap.poll();\\n          } \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] arr, int k) {\\n        \\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a,b)->b-a);\\n        // creating max Heap\\n        // adding all array Elements\\n        for(int i = 0;i<arr.length;i++){\\n            maxHeap.add(arr[i]);\\n        }\\n        // applying floor on max k times\\n        while(k>0){\\n            k--;\\n            int x = maxHeap.poll();\\n            if(x % 2 == 0)\\n                x = x/2;\\n            else\\n                x = x/2+1;\\n            maxHeap.add(x);\\n        }\\n        int ans = 0; \\n        while(!maxHeap.isEmpty()){\\n            ans+=maxHeap.poll();\\n          } \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1999030,
                "title": "linear-time-solution-without-priority-queue",
                "content": "I haven\\'t found any linear solutions in discuss so here is one. The main idea is the same as in count sort. Since max(piles) <= 10^4 we can use array `count` to iterate from the biggest to the smallest element of piles in linear time.\\nIn fact this is almost the same solution as the one with Priority Queue. The only difference is how do we keep sorted order.\\n```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        idx = max(piles)\\n        count = [0] * (idx + 1)\\n        for x in piles:\\n            count[x] += 1\\n        while k > 0 and idx >= 0:\\n            if not count[idx]:\\n                idx -= 1\\n            num = min(count[idx], k)\\n            count[idx] -= num\\n            count[(idx + 1) // 2] += num\\n            k -= num\\n        return sum((i * x for i, x in enumerate(count)))\\n\\n```\\nHere we use only O(max(piles)) space for storing `count` and O(len(piles) + max(piles)) time to iterate.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        idx = max(piles)\\n        count = [0] * (idx + 1)\\n        for x in piles:\\n            count[x] += 1\\n        while k > 0 and idx >= 0:\\n            if not count[idx]:\\n                idx -= 1\\n            num = min(count[idx], k)\\n            count[idx] -= num\\n            count[(idx + 1) // 2] += num\\n            k -= num\\n        return sum((i * x for i, x in enumerate(count)))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407710,
                "title": "c-solution-max-heap",
                "content": "Standard max heap problem. Choose the pile with the maximum length and remove. the floor(no. of stones / 2) from it and push the pile with the remaining amount of stones.\\nDo this opration k times\\n\\t\\n\\tint minStoneSum(vector<int>& piles, int k) {\\n        int n = piles.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        \\n        priority_queue<int> pq(piles.begin(), piles.end());\\n        int ans = 0;\\n        \\n        while(k--){\\n            int curr = pq.top();\\n            pq.pop();\\n            \\n\\t\\t\\t//if curr is odd the remaining piles will be curr - floor(curr/2) => curr/2 + 1\\n            if(curr % 2){\\n                pq.push(curr/2 + 1);\\n            }\\n            else{\\n                pq.push(curr/2);\\n            }\\n        }\\n        \\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Standard max heap problem. Choose the pile with the maximum length and remove. the floor(no. of stones / 2) from it and push the pile with the remaining amount of stones.\\nDo this opration k times\\n\\t\\n\\tint minStoneSum(vector<int>& piles, int k) {\\n        int n = piles.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        \\n        priority_queue<int> pq(piles.begin(), piles.end());\\n        int ans = 0;\\n        \\n        while(k--){\\n            int curr = pq.top();\\n            pq.pop();\\n            \\n\\t\\t\\t//if curr is odd the remaining piles will be curr - floor(curr/2) => curr/2 + 1\\n            if(curr % 2){\\n                pq.push(curr/2 + 1);\\n            }\\n            else{\\n                pq.push(curr/2);\\n            }\\n        }\\n        \\n        while(!pq.empty()){\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1407164,
                "title": "easy-java-heap",
                "content": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        \\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i=0;i<piles.length;i++){\\n            pq.add(piles[i]);\\n        }\\n              \\n        for(int i=0;i<k;i++){\\n            int temp=pq.poll();\\n            int res=temp-(temp/2);\\n            pq.add(res);\\n        }\\n        \\n        int result=0;\\n        for(int i=0;i<piles.length;i++){\\n            result+=pq.poll();\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        \\n        PriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        for(int i=0;i<piles.length;i++){\\n            pq.add(piles[i]);\\n        }\\n              \\n        for(int i=0;i<k;i++){\\n            int temp=pq.poll();\\n            int res=temp-(temp/2);\\n            pq.add(res);\\n        }\\n        \\n        int result=0;\\n        for(int i=0;i<piles.length;i++){\\n            result+=pq.poll();\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397430,
                "title": "golang-max-heap-solution",
                "content": "```\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tx := old[len(old) - 1]\\n\\t*h = old[0 : len(old) - 1]\\n\\treturn x\\n}\\n\\nfunc minStoneSum(piles []int, k int) int {\\n    h := &IntHeap{}\\n    heap.Init(h)\\n    sum := 0\\n    \\n    for _, pile := range piles {\\n        heap.Push(h, pile)\\n        sum += pile\\n    }\\n    \\n    for i := 0; i < k; i++ {\\n        temp := heap.Pop(h).(int)\\n        sum -= (temp / 2)\\n        heap.Push(h, temp - (temp / 2))\\n    }\\n    \\n    return sum\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntype IntHeap []int\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] > h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tx := old[len(old) - 1]\\n\\t*h = old[0 : len(old) - 1]\\n\\treturn x\\n}\\n\\nfunc minStoneSum(piles []int, k int) int {\\n    h := &IntHeap{}\\n    heap.Init(h)\\n    sum := 0\\n    \\n    for _, pile := range piles {\\n        heap.Push(h, pile)\\n        sum += pile\\n    }\\n    \\n    for i := 0; i < k; i++ {\\n        temp := heap.Pop(h).(int)\\n        sum -= (temp / 2)\\n        heap.Push(h, temp - (temp / 2))\\n    }\\n    \\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1394732,
                "title": "java-max-heap-solution-o-nlogn",
                "content": "### Explanation\\n\\n- Because we have to find the **minimum** stones after removal, we have to remove the **maximum** stones, so we have to keep track of the largest piles to apply the operation by using `max-heap`.\\n- After we pop out the largest pile, we apply the operation and put them back to the `max-heap`.\\n\\n### Implementation\\n\\n```java\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a,b) -> b.compareTo(a));\\n        int total = 0;\\n        for (int i = 0; i < piles.length; i++) {\\n            queue.add(piles[i]);\\n            total += piles[i];\\n        }\\n        \\n        int remove = 0;\\n        for (int i = 0; i < k; i++) {\\n            int tmp = queue.remove();\\n            int remain = (tmp % 2 == 0) ? tmp / 2 : (tmp + 1) / 2;\\n            remove += tmp - remain;\\n            queue.add(remain);\\n        }\\n        \\n        return total - remove;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a,b) -> b.compareTo(a));\\n        int total = 0;\\n        for (int i = 0; i < piles.length; i++) {\\n            queue.add(piles[i]);\\n            total += piles[i];\\n        }\\n        \\n        int remove = 0;\\n        for (int i = 0; i < k; i++) {\\n            int tmp = queue.remove();\\n            int remain = (tmp % 2 == 0) ? tmp / 2 : (tmp + 1) / 2;\\n            remove += tmp - remain;\\n            queue.add(remain);\\n        }\\n        \\n        return total - remove;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393504,
                "title": "c-priority-queue-solution-with-explanation-o-klogn",
                "content": "In the ```kth``` operation, we remove ```floor(piles[i]/2)``` stones (choosing ```ith``` pile), so stones left ```piles[i] - floor(piles[i]/2)```.\\nTo get minimum element after ```k``` operations, we can maximize the removal of stones at every operation.\\nThis can be maximised if we choose a file with maximum stones at that time.\\nThis can be done using priority queue/ max heap.\\n\\nSteps\\n1. Push all the elements of array to a priority queue. ```O(n)```\\n2. Repeat following steps k times.\\n3. Extract the topmost element from pq (which is maximum element in piles at this point).\\n4. Remove stones from this and push it back to the pq. ```O(klogn)```\\n\\nComplexity\\nTime ```O(n + klogn)```\\nSpace ```O(n)```\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int n=piles.size();\\n        priority_queue<int> pq;\\n        for(int i=0; i<n; i++)\\n            pq.push(piles[i]);\\n        while(k--)\\n        {\\n            int x=pq.top();\\n            pq.pop();\\n            pq.push(x-floor(x/2));\\n        }\\n        \\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```kth```\n```floor(piles[i]/2)```\n```ith```\n```piles[i] - floor(piles[i]/2)```\n```k```\n```O(n)```\n```O(klogn)```\n```O(n + klogn)```\n```O(n)```\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int n=piles.size();\\n        priority_queue<int> pq;\\n        for(int i=0; i<n; i++)\\n            pq.push(piles[i]);\\n        while(k--)\\n        {\\n            int x=pq.top();\\n            pq.pop();\\n            pq.push(x-floor(x/2));\\n        }\\n        \\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392345,
                "title": "easy-to-understand-c-heap-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int numberOfPiles = piles.size();\\n        \\n        make_heap (piles.begin(), piles.end());\\n        \\n        for (int i = 0; i < k; i++)\\n        {\\n            int maxPile = piles.front();\\n            \\n\\t\\t\\t// remove max pile\\n            pop_heap (piles.begin(), piles.end());\\n            piles.pop_back();\\n            \\n\\t\\t\\t// reinsert with adjustments\\n            piles.push_back (maxPile - floor (maxPile / 2));\\n            push_heap (piles.begin(), piles.end());\\n        }\\n        \\n\\t\\t// calculate and return sum\\n        int sumOfPiles = 0;\\n        for (int i = 0; i < numberOfPiles; i++)\\n        {\\n            sumOfPiles += piles[i];\\n        }\\n        \\n        return sumOfPiles;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int numberOfPiles = piles.size();\\n        \\n        make_heap (piles.begin(), piles.end());\\n        \\n        for (int i = 0; i < k; i++)\\n        {\\n            int maxPile = piles.front();\\n            \\n\\t\\t\\t// remove max pile\\n            pop_heap (piles.begin(), piles.end());\\n            piles.pop_back();\\n            \\n\\t\\t\\t// reinsert with adjustments\\n            piles.push_back (maxPile - floor (maxPile / 2));\\n            push_heap (piles.begin(), piles.end());\\n        }\\n        \\n\\t\\t// calculate and return sum\\n        int sumOfPiles = 0;\\n        for (int i = 0; i < numberOfPiles; i++)\\n        {\\n            sumOfPiles += piles[i];\\n        }\\n        \\n        return sumOfPiles;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391155,
                "title": "c-priority-queue-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq(piles.begin(), piles.end());\\n        \\n        while(k--) {\\n            int temp = pq.top(); pq.pop();\\n            temp -= (temp/2);\\n            pq.push(temp);\\n        }\\n        \\n        int ans = 0;\\n        while(!pq.empty()) {\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq(piles.begin(), piles.end());\\n        \\n        while(k--) {\\n            int temp = pq.top(); pq.pop();\\n            temp -= (temp/2);\\n            pq.push(temp);\\n        }\\n        \\n        int ans = 0;\\n        while(!pq.empty()) {\\n            ans += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390870,
                "title": "java-fast-solution-using-a-frequency-array-20ms",
                "content": "This is pretty much the same principle as most of the other Heap/Priority Queue solutions, but sacrifices memory for a significantly faster runtime, usually on order of 10 to 20x.\\n\\nWe first loop through to check how many times each value occurs in `piles`. Then we go through the values we\\'ve found, from largest to smallest, and reduce them to `val = val - floor(val / 2)`, which is the same as `val = (val + 1) / 2` since we\\'re dealing with integers.\\n\\n```\\nprivate int MAX_VAL = (int) 1e5;\\n    \\npublic int minStoneSum(int[] piles, int k) {\\n    int[] count = new int[MAX_VAL + 1];\\n    \\n    int sum = 0;\\n    for(int pile : piles) {\\n        count[pile]++;\\n        sum += pile;\\n    }\\n        \\n    for(int val = MAX_VAL; val > 0 && k > 0; val--) {\\n        while(count[val]-- > 0 && k-- > 0) {\\n            int nextVal = (val + 1) / 2;\\n            count[nextVal]++;\\n            sum -= val / 2;\\n        }\\n    }\\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate int MAX_VAL = (int) 1e5;\\n    \\npublic int minStoneSum(int[] piles, int k) {\\n    int[] count = new int[MAX_VAL + 1];\\n    \\n    int sum = 0;\\n    for(int pile : piles) {\\n        count[pile]++;\\n        sum += pile;\\n    }\\n        \\n    for(int val = MAX_VAL; val > 0 && k > 0; val--) {\\n        while(count[val]-- > 0 && k-- > 0) {\\n            int nextVal = (val + 1) / 2;\\n            count[nextVal]++;\\n            sum -= val / 2;\\n        }\\n    }\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390708,
                "title": "javascript-maxpriorityqueue-solution",
                "content": "```\\nvar minStoneSum = function(piles, k) {\\n    let sum = 0;\\n    let element;\\n    let half;\\n    const pq = new MaxPriorityQueue({ priority: (bid) => bid });\\n    \\n    for (let i = 0; i < piles.length; ++i) {\\n        sum += piles[i];\\n        pq.enqueue(piles[i]);\\n    }\\n    \\n    for (let i = 0; i < k; ++i) {\\n        element = pq.dequeue().element;\\n        half = Math.floor(element / 2);\\n        sum -= half;\\n        pq.enqueue(element - half);\\n    }\\n    \\n    return sum;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minStoneSum = function(piles, k) {\\n    let sum = 0;\\n    let element;\\n    let half;\\n    const pq = new MaxPriorityQueue({ priority: (bid) => bid });\\n    \\n    for (let i = 0; i < piles.length; ++i) {\\n        sum += piles[i];\\n        pq.enqueue(piles[i]);\\n    }\\n    \\n    for (let i = 0; i < k; ++i) {\\n        element = pq.dequeue().element;\\n        half = Math.floor(element / 2);\\n        sum -= half;\\n        pq.enqueue(element - half);\\n    }\\n    \\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1390428,
                "title": "c-maxheap",
                "content": "Runtime: 1113 ms\\nMemory Usage: 47.2 MB\\n\\n```\\npublic class Solution {\\n    public int MinStoneSum(int[] piles, int k) {\\n        MaxHeap heap = new MaxHeap();\\n        long sum = 0;\\n        for(int i=0; i< piles.Length; i++) { heap.Add(piles[i]); sum += piles[i]; }\\n        \\n        int max;\\n        int floor;\\n      \\n        for(int i=0; i<k; i++)\\n        {\\n            max = heap.GetMax();\\n            floor = max/2;\\n            heap.Add(max - floor);\\n            sum -= floor;\\n        }\\n       \\n        return (int)sum; \\n    }\\n    \\n    \\n    private class MaxHeap\\n    {\\n        List<int> data = new List<int>();\\n        int end = 0;\\n        \\n        public int getParent(int i) { return (i-1)/2; }\\n        public int getLeftChild(int i) { return 2*i+1; }\\n        public int getRightChild(int i) { return 2*i+2; }\\n        \\n        public int GetIndex(int i)\\n        {\\n            return data[i];\\n        }\\n        public int GetMax()\\n        {\\n            if (end == 0) { return 0; }\\n            \\n            int result = data[0];\\n            end--;\\n            data[0] = data[end];            \\n            MoveDown(0);\\n            return result;\\n        }\\n        \\n        private void MoveDown(int index)\\n        {            \\n            int left = getLeftChild(index);\\n            int right =  getRightChild(index);\\n            \\n            int largest = index;\\n            if (left < end && data[index] < data[left]) { largest = left; }\\n            if (right < end && data[largest] < data[right]) { largest = right; }\\n            \\n            if (index != largest)\\n            {\\n                int val = data[index];\\n                data[index] = data[largest];\\n                data[largest] = val;\\n                MoveDown(largest);\\n            }\\n        }\\n        \\n        public void Add(int val)\\n        {\\n            if (end < data.Count) { data[end] = val; } else { data.Add(val); }\\n            end++;            \\n            MoveUp(end-1);\\n        }\\n        \\n        private void MoveUp(int index)\\n        {\\n            if (index == 0) { return; }\\n            int parent =  getParent(index);\\n            \\n            if (data[parent] < data[index])\\n            {\\n                int val = data[parent];\\n                data[parent] = data[index];\\n                data[index] = val; \\n                MoveUp(parent);\\n            }\\n        }        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinStoneSum(int[] piles, int k) {\\n        MaxHeap heap = new MaxHeap();\\n        long sum = 0;\\n        for(int i=0; i< piles.Length; i++) { heap.Add(piles[i]); sum += piles[i]; }\\n        \\n        int max;\\n        int floor;\\n      \\n        for(int i=0; i<k; i++)\\n        {\\n            max = heap.GetMax();\\n            floor = max/2;\\n            heap.Add(max - floor);\\n            sum -= floor;\\n        }\\n       \\n        return (int)sum; \\n    }\\n    \\n    \\n    private class MaxHeap\\n    {\\n        List<int> data = new List<int>();\\n        int end = 0;\\n        \\n        public int getParent(int i) { return (i-1)/2; }\\n        public int getLeftChild(int i) { return 2*i+1; }\\n        public int getRightChild(int i) { return 2*i+2; }\\n        \\n        public int GetIndex(int i)\\n        {\\n            return data[i];\\n        }\\n        public int GetMax()\\n        {\\n            if (end == 0) { return 0; }\\n            \\n            int result = data[0];\\n            end--;\\n            data[0] = data[end];            \\n            MoveDown(0);\\n            return result;\\n        }\\n        \\n        private void MoveDown(int index)\\n        {            \\n            int left = getLeftChild(index);\\n            int right =  getRightChild(index);\\n            \\n            int largest = index;\\n            if (left < end && data[index] < data[left]) { largest = left; }\\n            if (right < end && data[largest] < data[right]) { largest = right; }\\n            \\n            if (index != largest)\\n            {\\n                int val = data[index];\\n                data[index] = data[largest];\\n                data[largest] = val;\\n                MoveDown(largest);\\n            }\\n        }\\n        \\n        public void Add(int val)\\n        {\\n            if (end < data.Count) { data[end] = val; } else { data.Add(val); }\\n            end++;            \\n            MoveUp(end-1);\\n        }\\n        \\n        private void MoveUp(int index)\\n        {\\n            if (index == 0) { return; }\\n            int parent =  getParent(index);\\n            \\n            if (data[parent] < data[index])\\n            {\\n                int val = data[parent];\\n                data[parent] = data[index];\\n                data[index] = val; \\n                MoveUp(parent);\\n            }\\n        }        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390384,
                "title": "easy-python",
                "content": "```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        piles = [-1*x for x in piles]\\n        heapq.heapify(piles)\\n        for i in range(k):\\n            k=heapq.heappop(piles)*(-1) + 1\\n            k>>=1\\n            heapq.heappush(piles,-k)\\n        return -1*sum(piles)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        piles = [-1*x for x in piles]\\n        heapq.heapify(piles)\\n        for i in range(k):\\n            k=heapq.heappop(piles)*(-1) + 1\\n            k>>=1\\n            heapq.heappush(piles,-k)\\n        return -1*sum(piles)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390358,
                "title": "max-heap-beats-100-submissions-with-thought-process-time-o-n-klogn",
                "content": "\\n```\\nimport heapq\\nclass Solution:\\n    def minArraySum(self, nums: List[int], k: int) -> int:\\n        nums = [-num for num in nums]\\n        heapify(nums)\\n        while k:\\n            k -= 1\\n            heappush(nums, -((-heappop(nums) + 1) // 2))\\n        return -sum(nums)\\n```\\n\\nConvert nums array from +ve elements to -ve elements. This is important as we want to create max heap which is only be achieved if we convert +ve elements to -ve one.\\n\\nHeapify nums, so now our array is sorted with max element first to min element last.\\nCalling heappop() will pop a smallest element from heap. In our case, it will pop max element.\\n\\nDecrease current element with n/2 (in code it\\'s n//2 to get floor value) and pop it back to the heap.\\nCalculate sum of elements and multiply it with -1. (Remember we multiplied our array with -1 earlier, to balence out, now we multiply with -1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minArraySum(self, nums: List[int], k: int) -> int:\\n        nums = [-num for num in nums]\\n        heapify(nums)\\n        while k:\\n            k -= 1\\n            heappush(nums, -((-heappop(nums) + 1) // 2))\\n        return -sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390242,
                "title": "python3-heap-simple-concise-solution",
                "content": "The intuition is to find the max of the array in minimum complexity and replace it with` piles[i]`  minus `floor(piles[i] / 2)`\\n\\n**Implementation:**\\n1. Using the heap data structure in python i.e.heapq to find the max element\\n2. Since we can\\'t make max heap I have inserted negative of the numbers in heap.\\n3. Then we are just left with popping the min element and push `floor(piles[i] / 2)`\\n```\\nimport heapq\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n#         update with negation of all the numbers\\n        for i in range(len(piles)):\\n            piles[i]=-piles[i]\\n#         create min heap\\n        heapq.heapify(piles) \\n        for i in range(k):\\n#             pop the least element\\n            tmp=heapq.heappop(piles)\\n#     push the piles[0]-floor(piles[i] / 2)\\n            heapq.heappush(piles,tmp+(-1*tmp//2))\\n        return -1*sum(piles)\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n#         update with negation of all the numbers\\n        for i in range(len(piles)):\\n            piles[i]=-piles[i]\\n#         create min heap\\n        heapq.heapify(piles) \\n        for i in range(k):\\n#             pop the least element\\n            tmp=heapq.heappop(piles)\\n#     push the piles[0]-floor(piles[i] / 2)\\n            heapq.heappush(piles,tmp+(-1*tmp//2))\\n        return -1*sum(piles)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390217,
                "title": "simple-python-solution-with-heapq",
                "content": "Here you go:\\n\\n```python\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        piles = [-pile for pile in piles]\\n        heapq.heapify(piles)\\n        \\n        while k:\\n            pile = heapq.heappop(piles)\\n            pile = pile // 2\\n            heapq.heappush(piles, pile)\\n            k-= 1\\n        \\n        return -sum(piles)\\n```",
                "solutionTags": [],
                "code": "```python\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        piles = [-pile for pile in piles]\\n        heapq.heapify(piles)\\n        \\n        while k:\\n            pile = heapq.heappop(piles)\\n            pile = pile // 2\\n            heapq.heappush(piles, pile)\\n            k-= 1\\n        \\n        return -sum(piles)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1390197,
                "title": "c-easy-solution-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n\\n        priority_queue<int> pq(piles.begin(),piles.end());\\n        for(int i=0;i<k;i++)\\n        {\\n            int t=pq.top();\\n            pq.pop();\\n            t=t-(t/2);\\n            pq.push(t);\\n        }\\n        int sum=0;\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n\\n        priority_queue<int> pq(piles.begin(),piles.end());\\n        for(int i=0;i<k;i++)\\n        {\\n            int t=pq.top();\\n            pq.pop();\\n            t=t-(t/2);\\n            pq.push(t);\\n        }\\n        int sum=0;\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390164,
                "title": "a-few-solutions",
                "content": "Use a priority queue `q` to continually extract maximums in logarithmic time.  Then return the accumulated sum of the `q` after `k` iterations.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minStoneSum(A: IntArray, k_: Int): Int {\\n        var k = k_\\n        var q = PriorityQueue{ a: Int, b: Int -> b - a }\\n        for (x in A)\\n            q.add(x)\\n        while (0 < k--) {\\n            var x = q.poll()\\n            q.add(x - x / 2)\\n        }\\n        return q.sum()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.max) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.max) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nlet minStoneSum = (A, k) => {\\n    let q = [];\\n    for (let x of A)\\n        heappush(q, x);\\n    while (k--) {\\n        let x = heappop(q)\\n        heappush(q, x - Math.floor(x / 2));\\n    }\\n    return _.sum(q);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minStoneSum(self, A: List[int], k: int) -> int:\\n        q = []\\n        for x in A:\\n            heappush(q, -x)\\n        while k:\\n            x = heappop(q)\\n            heappush(q, x + (-x // 2))\\n            k -= 1\\n        return -sum(q)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Queue = priority_queue<int, VI, less<int>>;\\n    int minStoneSum(VI& A, int k, Queue q = {}) {\\n        for (auto x: A)\\n            q.push(x);\\n        while (k--) {\\n            auto x = q.top(); q.pop();\\n            q.push(x - x / 2);\\n        }\\n        auto t = 0;\\n        while (q.size())\\n            t += q.top(), q.pop();\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minStoneSum(A: IntArray, k_: Int): Int {\\n        var k = k_\\n        var q = PriorityQueue{ a: Int, b: Int -> b - a }\\n        for (x in A)\\n            q.add(x)\\n        while (0 < k--) {\\n            var x = q.poll()\\n            q.add(x - x / 2)\\n        }\\n        return q.sum()\\n    }\\n}\\n```\n```\\nlet key = x => Array.isArray(x) ? x[0] : x;\\nlet heappush = (A, x, f = Math.max) => {\\n    let P = i => Math.floor((i - 1) / 2);  // parent\\n    A.push(x);\\n    let N = A.length,\\n        i = N - 1;\\n    while (0 < i && key(A[i]) == f(key(A[i]), key(A[P(i)]))) {\\n        [A[i], A[P(i)]] = [A[P(i)], A[i]];\\n        i = P(i);\\n    }\\n};\\nlet heappop = (A, f = Math.max) => {\\n    let L = i => 2 * i + 1,  // children\\n        R = i => 2 * i + 2;\\n    let N = A.length,\\n        i = 0;\\n    let top = A[0];\\n    [A[0], A[N - 1]] = [A[N - 1], A[0]], A.pop(), --N;\\n    let ok;\\n    do {\\n        ok = true;\\n        let left = f == Math.min ? Infinity : -Infinity,\\n            right = left;\\n        if (L(i) < N && key(A[i]) != f(key(A[i]), key(A[L(i)]))) ok = false, left  = key(A[L(i)]);\\n        if (R(i) < N && key(A[i]) != f(key(A[i]), key(A[R(i)]))) ok = false, right = key(A[R(i)]);\\n        if (!ok) {\\n            let j = left == f(left, right) ? L(i) : R(i);\\n            [A[i], A[j]] = [A[j], A[i]];\\n            i = j;\\n        }\\n    } while (!ok);\\n    return top;\\n};\\nlet minStoneSum = (A, k) => {\\n    let q = [];\\n    for (let x of A)\\n        heappush(q, x);\\n    while (k--) {\\n        let x = heappop(q)\\n        heappush(q, x - Math.floor(x / 2));\\n    }\\n    return _.sum(q);\\n};\\n```\n```\\nclass Solution:\\n    def minStoneSum(self, A: List[int], k: int) -> int:\\n        q = []\\n        for x in A:\\n            heappush(q, -x)\\n        while k:\\n            x = heappop(q)\\n            heappush(q, x + (-x // 2))\\n            k -= 1\\n        return -sum(q)\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Queue = priority_queue<int, VI, less<int>>;\\n    int minStoneSum(VI& A, int k, Queue q = {}) {\\n        for (auto x: A)\\n            q.push(x);\\n        while (k--) {\\n            auto x = q.top(); q.pop();\\n            q.push(x - x / 2);\\n        }\\n        auto t = 0;\\n        while (q.size())\\n            t += q.top(), q.pop();\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050477,
                "title": "priority-queue-solution-fully-explained",
                "content": "Create a max heap (priority_queue) pq from the input piles vector. This heap will store the pile sizes in descending order, meaning the largest pile will be at the top.\\n\\nInitialize a long long variable sum to 0. We use long long to prevent potential integer overflow when summing the pile sizes.\\n\\nEnter a loop that runs for k iterations to simulate applying the operation k times:\\n\\nGet the largest pile size from the top of the heap using pq.top() and store it in a.\\nRemove the largest pile from the heap using pq.pop().\\nApply the operation by reducing the pile size by half: a - a / 2.\\nPush the new pile size back into the heap using pq.push(a - a / 2).\\nWhile performing these steps, keep accumulating the pile sizes in the sum variable.\\n\\nAfter the loop, the pq heap contains the updated pile sizes, and sum holds the sum of all the pile sizes.\\n\\nReturn the value of sum, which represents the minimum possible total number of stones remaining after applying the operation k times.\\n\\nThis code correctly implements the problem statement by applying the operation to the largest pile in each iteration, and it ensures that the sum variable can handle large values to prevent integer overflow.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq(piles.begin(),piles.end());\\n        long long sum=0;\\n        while(k--)\\n        {\\n         int a= pq.top();\\n         pq.pop(),pq.push(a-a/2);\\n        }\\n        while(pq.size())\\n        sum+=pq.top(),pq.pop();\\n        return sum; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq(piles.begin(),piles.end());\\n        long long sum=0;\\n        while(k--)\\n        {\\n         int a= pq.top();\\n         pq.pop(),pq.push(a-a/2);\\n        }\\n        while(pq.size())\\n        sum+=pq.top(),pq.pop();\\n        return sum; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753935,
                "title": "easy-c-solution-greedy-maxheap",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> maxheap;\\n        int s=0;\\n        for(int i =0;i<piles.size();i++){\\n            maxheap.push(piles[i]);\\n        }\\n        while(k--){\\n            int ele=maxheap.top();\\n            maxheap.pop();\\n            ele=ele-floor(ele/2);\\n            maxheap.push(ele);\\n        }\\n        while(!maxheap.empty()){\\n            s+=maxheap.top();\\n            maxheap.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> maxheap;\\n        int s=0;\\n        for(int i =0;i<piles.size();i++){\\n            maxheap.push(piles[i]);\\n        }\\n        while(k--){\\n            int ele=maxheap.top();\\n            maxheap.pop();\\n            ele=ele-floor(ele/2);\\n            maxheap.push(ele);\\n        }\\n        while(!maxheap.empty()){\\n            s+=maxheap.top();\\n            maxheap.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464954,
                "title": "easy-python-solution-using-maxheap",
                "content": "# Intuition\\nEach operation involves selecting a pile of stones with the maximum number of stones, removing half of the stones, and putting the remaining stones back into the pile. The code then returns the maximum number of stones that can be left in the piles after all operations are performed.\\n\\n# Approach\\nThe code first creates a list of negative integers representing the piles, and uses the heapq module to turn it into a max heap. It then repeatedly pops the maximum element from the heap, halves it, and puts it back into the heap until the desired number of operations have been performed. Finally, it calculates the sum of the remaining elements in the heap, converts it back to a positive value, and returns it as the result.\\n\\n# Complexity\\n- Time complexity:\\nO(k log n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n\\n        maxPiles = [-i for i in piles]\\n        heapq.heapify(maxPiles)\\n        for i in range(k):\\n            temp = -heapq.heappop(maxPiles)\\n            val = temp // 2\\n            heapq.heappush(maxPiles, -(temp - val))\\n        return -sum(maxPiles)\\n        \\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n\\n        maxPiles = [-i for i in piles]\\n        heapq.heapify(maxPiles)\\n        for i in range(k):\\n            temp = -heapq.heappop(maxPiles)\\n            val = temp // 2\\n            heapq.heappush(maxPiles, -(temp - val))\\n        return -sum(maxPiles)\\n        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145584,
                "title": "beats-96-simple-c-max-heap-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n//idea is every time we remove half from maximum piles then pushing left again to max heap \\n    int minStoneSum(vector<int>& piles, int k) {\\n        int sum=accumulate(piles.begin(),piles.end(),0);\\n        priority_queue<int>q;\\n        for(int i=0;i<piles.size();i++){\\n            q.push(piles[i]);\\n        }\\n        while(k){\\n            auto t=q.top();\\n            sum-=t/2;\\n            t=(t-(t/2));\\n            q.push(t);\\n            q.pop();\\n            k--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//idea is every time we remove half from maximum piles then pushing left again to max heap \\n    int minStoneSum(vector<int>& piles, int k) {\\n        int sum=accumulate(piles.begin(),piles.end(),0);\\n        priority_queue<int>q;\\n        for(int i=0;i<piles.size();i++){\\n            q.push(piles[i]);\\n        }\\n        while(k){\\n            auto t=q.top();\\n            sum-=t/2;\\n            t=(t-(t/2));\\n            q.push(t);\\n            q.pop();\\n            k--;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981541,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is kind of greedy if we have to minimize number of stones, we can remove max number of stones from the pile containing max number of stones as we can remove piles[i]/2 number of stone in every iteration.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPriority queue is the best data structure to use in this kind of situation as the array keeps changing, otherwise we have to sort or traverse the array every time to find the pile with max number of stones in it.\\n\\n# Complexity\\n- Time complexity: O(KlongN) [N is size of array]\\n\\n- Space complexity: O(N) as we are storing the whole array is priority queue.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n        for(int p: piles){\\n            pq.push(p);\\n        }\\n        while(k--){\\n            int x = pq.top();\\n            pq.pop();\\n            pq.push(x - x/2);\\n        }\\n        int res =0;\\n        while(!pq.empty()){\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n        for(int p: piles){\\n            pq.push(p);\\n        }\\n        while(k--){\\n            int x = pq.top();\\n            pq.pop();\\n            pq.push(x - x/2);\\n        }\\n        int res =0;\\n        while(!pq.empty()){\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976915,
                "title": "c-simplest-code-easy-logic-98-faster",
                "content": "# Intuition\\nSimple Code Using Priority Queues .\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(k*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n        int sum=0;\\n        for(auto i:piles)\\n        pq.push(i);\\n\\n        while(k--){\\n            int mx=pq.top();\\n            pq.pop();\\n            mx-=floor(mx/2);\\n            pq.push(mx);\\n        }\\n        while(!pq.empty())\\n         {\\n            sum+=pq.top();\\n            pq.pop();\\n         }\\n         \\n         return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n        int sum=0;\\n        for(auto i:piles)\\n        pq.push(i);\\n\\n        while(k--){\\n            int mx=pq.top();\\n            pq.pop();\\n            mx-=floor(mx/2);\\n            pq.push(mx);\\n        }\\n        while(!pq.empty())\\n         {\\n            sum+=pq.top();\\n            pq.pop();\\n         }\\n         \\n         return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965661,
                "title": "priority-queue",
                "content": "# Approach:\\n###### Every time choose the maximum element from the array and remove floor(elememnt/2) part from that element and we can perform this operation k times. So, for this we will use maxheap.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minStoneSum(vector<int> &piles, int k)\\n    {\\n        priority_queue<int> heap(piles.begin(), piles.end());\\n        while (k != 0)\\n        {\\n            int curr = heap.top();\\n            heap.pop();\\n            int remove = floor(curr / 2);\\n            heap.push(curr - remove);\\n            k--;\\n        }\\n        int sum = 0;\\n        while (!heap.empty())\\n        {\\n            sum += heap.top();\\n            heap.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minStoneSum(vector<int> &piles, int k)\\n    {\\n        priority_queue<int> heap(piles.begin(), piles.end());\\n        while (k != 0)\\n        {\\n            int curr = heap.top();\\n            heap.pop();\\n            int remove = floor(curr / 2);\\n            heap.push(curr - remove);\\n            k--;\\n        }\\n        int sum = 0;\\n        while (!heap.empty())\\n        {\\n            sum += heap.top();\\n            heap.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964939,
                "title": "counting-solution-with-time-o-n-max-piles-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe easiest and most obvious and general way to solve it is to use heap. But in constaints we see that maximal value of piles is less than $$10^4$$ and we can use counting. For counting we can use an array or a HashMap.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s allocate an array for keeping count of piles with that count of stones. To fill it we need iterate through an array of piles and increment count of piles for each pile size we are encountering. Also, it can be good to precalculate sum of stones in advance.\\nAfter that just iterate starting from the biggest size till the size of 1, removing min(k, cnt) piles for that size and increasing by that value for pile of size (current_size - current_size / 2). Also we can adjust sum of left stones accordingly.\\nJust look at the code, it\\'s much simpler than the explanation.\\n\\n# Complexity\\n- Time complexity: O(n + max(piles))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(max(piles))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        int[] vals = new int[10001];\\n        int sum = 0;\\n        for (int val : piles) {\\n            vals[val]++;\\n            sum += val;\\n        }\\n\\n        for (int i = vals.length - 1; i > 1 && k > 0; i--) {\\n            int cnt = vals[i];\\n            if (cnt == 0)\\n                continue;\\n            \\n            int min = Math.min(k, cnt);\\n            int div = i / 2;\\n\\n            vals[i] -= min;\\n            vals[i - div] += min;\\n            sum -= min * div;\\n            k -= min;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        int[] vals = new int[10001];\\n        int sum = 0;\\n        for (int val : piles) {\\n            vals[val]++;\\n            sum += val;\\n        }\\n\\n        for (int i = vals.length - 1; i > 1 && k > 0; i--) {\\n            int cnt = vals[i];\\n            if (cnt == 0)\\n                continue;\\n            \\n            int min = Math.min(k, cnt);\\n            int div = i / 2;\\n\\n            vals[i] -= min;\\n            vals[i - div] += min;\\n            sum -= min * div;\\n            k -= min;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964903,
                "title": "maxheap-implementation",
                "content": "**Just a code submission\\n\\n# Code\\n```\\n/**\\n * @param {number[]} piles\\n * @param {number} k\\n * @return {number}\\n */\\nvar minStoneSum = function(piles, k) {\\n    \\n    const max = new MaxHeap(piles)\\n\\n    while (k > 0) {\\n        const remove = max.remove()\\n        const divide = Math.floor(remove / 2)\\n        max.insert(remove - divide)\\n        k--\\n    }\\n\\n    return piles.reduce((a, b) => a + b)\\n}\\n\\nclass MaxHeap {\\n    constructor(array) {\\n        this.heap = this.buildHeap(array)\\n    }\\n\\t\\n    buildHeap(array) {\\n        const firstParentIdx = Math.floor((array.length - 2) / 2)\\n        for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\\n            this.siftDown(currentIdx, array.length - 1, array)\\n        }\\n        return array\\n    }\\n\\n    siftDown(currentIdx, endIdx, heap) {\\n        let childOneIdx = currentIdx * 2 + 1\\n\\n        while (childOneIdx <= endIdx) {\\n            const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1\\n\\n            let idxToSwap\\n\\n            if (childTwoIdx !== -1 && heap[childTwoIdx] > heap[childOneIdx]) {\\n                idxToSwap = childTwoIdx\\n            } else {\\n                idxToSwap = childOneIdx\\n            }\\n\\n            if (heap[idxToSwap] > heap[currentIdx]) {\\n                this.swap(currentIdx, idxToSwap, heap)\\n\\n                currentIdx = idxToSwap\\n                childOneIdx = currentIdx * 2 + 1\\n            } else {\\n                return\\n            }\\n        }\\n    }\\n\\n    siftUp(currentIdx, heap) {\\n        let parentIdx = Math.floor((currentIdx - 1) / 2)\\n\\n        while (currentIdx > 0 && heap[currentIdx] > heap[parentIdx]) {\\n            this.swap(currentIdx, parentIdx, heap)\\n            currentIdx = parentIdx\\n            parentIdx = Math.floor((currentIdx - 1) / 2)\\n        }\\n    }\\n\\n    peek() {\\n        return this.heap[0]\\n    }\\n\\n    remove() {\\n        this.swap(0, this.heap.length - 1, this.heap)\\n        const valueToRemove = this.heap.pop()\\n\\n        this.siftDown(0, this.heap.length - 1, this.heap)\\n        return valueToRemove\\n    }\\n\\n    insert(value) {\\n        this.heap.push(value)\\n        this.siftUp(this.heap.length - 1, this.heap)\\n    }\\n\\t\\n    swap(i, j, heap) {\\n        const temp = heap[j]\\n        heap[j] = heap[i]\\n        heap[i] = temp\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} piles\\n * @param {number} k\\n * @return {number}\\n */\\nvar minStoneSum = function(piles, k) {\\n    \\n    const max = new MaxHeap(piles)\\n\\n    while (k > 0) {\\n        const remove = max.remove()\\n        const divide = Math.floor(remove / 2)\\n        max.insert(remove - divide)\\n        k--\\n    }\\n\\n    return piles.reduce((a, b) => a + b)\\n}\\n\\nclass MaxHeap {\\n    constructor(array) {\\n        this.heap = this.buildHeap(array)\\n    }\\n\\t\\n    buildHeap(array) {\\n        const firstParentIdx = Math.floor((array.length - 2) / 2)\\n        for (let currentIdx = firstParentIdx; currentIdx >= 0; currentIdx--) {\\n            this.siftDown(currentIdx, array.length - 1, array)\\n        }\\n        return array\\n    }\\n\\n    siftDown(currentIdx, endIdx, heap) {\\n        let childOneIdx = currentIdx * 2 + 1\\n\\n        while (childOneIdx <= endIdx) {\\n            const childTwoIdx = currentIdx * 2 + 2 <= endIdx ? currentIdx * 2 + 2 : -1\\n\\n            let idxToSwap\\n\\n            if (childTwoIdx !== -1 && heap[childTwoIdx] > heap[childOneIdx]) {\\n                idxToSwap = childTwoIdx\\n            } else {\\n                idxToSwap = childOneIdx\\n            }\\n\\n            if (heap[idxToSwap] > heap[currentIdx]) {\\n                this.swap(currentIdx, idxToSwap, heap)\\n\\n                currentIdx = idxToSwap\\n                childOneIdx = currentIdx * 2 + 1\\n            } else {\\n                return\\n            }\\n        }\\n    }\\n\\n    siftUp(currentIdx, heap) {\\n        let parentIdx = Math.floor((currentIdx - 1) / 2)\\n\\n        while (currentIdx > 0 && heap[currentIdx] > heap[parentIdx]) {\\n            this.swap(currentIdx, parentIdx, heap)\\n            currentIdx = parentIdx\\n            parentIdx = Math.floor((currentIdx - 1) / 2)\\n        }\\n    }\\n\\n    peek() {\\n        return this.heap[0]\\n    }\\n\\n    remove() {\\n        this.swap(0, this.heap.length - 1, this.heap)\\n        const valueToRemove = this.heap.pop()\\n\\n        this.siftDown(0, this.heap.length - 1, this.heap)\\n        return valueToRemove\\n    }\\n\\n    insert(value) {\\n        this.heap.push(value)\\n        this.siftUp(this.heap.length - 1, this.heap)\\n    }\\n\\t\\n    swap(i, j, heap) {\\n        const temp = heap[j]\\n        heap[j] = heap[i]\\n        heap[i] = temp\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964807,
                "title": "java-simple-solution-using-max-heap",
                "content": "# Intuition\\nSince we have to minimize the sum of array thus by using greedy approach we just want to divide number which is the largest. \\nI first thought of using Arrays.sort but as we can see that array index could be used again so we need to add that element .\\nWhen ever we need a largest or smallest element everytime we would use Priority Queue.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is Simple we just insert every element in the maxHeap(Priority Queue) and then pop the element as pop of max Heap gives max value we get the number to be reduced. We store the amount we reduced and add the remaining to heap.\\nWe already calculated the sum at start.\\nAt end we return the changes we created and the sum before.\\nThis is the required sum after the above optimal choices.\\n\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int minStoneSum(int[] p, int k)\\n    {\\n        //Arrays.sort(piles, Collections.reverseOrder());\\n         // Arrays.sort(piles);\\n          int sum = 0;\\n        for(int i = 0;i<p.length;i++)\\n        sum+=p[i];\\n        int change = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0;i<p.length;i++)\\n        {\\n            pq.offer(p[i]);\\n        }\\n        for(int i = 0;i<k;i++)\\n        {\\n            int z = pq.poll();\\n            if(z==0)\\n            break;\\n            change += (int)Math.floor(z/2);\\n            System.out.println(change+\" \"+z);\\n            int yy = z-(int ) Math.floor(z/2);\\n            if(yy == 1)\\n            break;\\n            pq.add(yy);\\n        }\\n        return sum - change;\\n\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int minStoneSum(int[] p, int k)\\n    {\\n        //Arrays.sort(piles, Collections.reverseOrder());\\n         // Arrays.sort(piles);\\n          int sum = 0;\\n        for(int i = 0;i<p.length;i++)\\n        sum+=p[i];\\n        int change = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int i = 0;i<p.length;i++)\\n        {\\n            pq.offer(p[i]);\\n        }\\n        for(int i = 0;i<k;i++)\\n        {\\n            int z = pq.poll();\\n            if(z==0)\\n            break;\\n            change += (int)Math.floor(z/2);\\n            System.out.println(change+\" \"+z);\\n            int yy = z-(int ) Math.floor(z/2);\\n            if(yy == 1)\\n            break;\\n            pq.add(yy);\\n        }\\n        return sum - change;\\n\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964238,
                "title": "beats-95",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> klogn\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int pr,cur;\\n        int sum=accumulate(piles.begin(),piles.end(),0);\\n        //priority queue\\n        priority_queue<int>heap(piles.begin(),piles.end());\\n        for(int i=0;i<k;i++){\\n            cur=heap.top();\\n            heap.pop();\\n            pr=cur/2;\\n            sum=sum-pr;\\n            cur=cur-pr;\\n            heap.push(cur);\\n\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int pr,cur;\\n        int sum=accumulate(piles.begin(),piles.end(),0);\\n        //priority queue\\n        priority_queue<int>heap(piles.begin(),piles.end());\\n        for(int i=0;i<k;i++){\\n            cur=heap.top();\\n            heap.pop();\\n            pr=cur/2;\\n            sum=sum-pr;\\n            cur=cur-pr;\\n            heap.push(cur);\\n\\n        }\\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964187,
                "title": "presenting-the-intuitive-proof-of-correctness-whats-your-comment",
                "content": "HEY.. I JUST TRIED TO PROOF IT , I MEAN IDK IF IT IS CORRECT OR NOT, BUT IT GIVES A STRONG INTUITIVE PROOF!\\n\\n\\nlets say i have n piles , each having si stones\\n\\np1,p2,p3.......pn\\n\\nsuppose i\\'ve to perform k steps right\\nand say pi has highest number of stones (si)\\nnow why should i pick this pile?\\n\\nlets talk if i don\\'t touch this pile in any of k steps.\\n\\nsuppose total removal of stones we get is - r \\n\\nnow we can surely say that had i selected this pile ,\\nmy r would have been  greater? right [ coz in particular step , this pile yields maximum removal ]\\nso it means\\nin k steps, i have to select this pile atleast once, as not picking it at all doesnt yield maximum answer.\\nso we pick it.\\nnow we update our array .\\n\\n\\nedit:\\nanother question is?\\nwhy do selecting order not matter?\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "HEY.. I JUST TRIED TO PROOF IT , I MEAN IDK IF IT IS CORRECT OR NOT, BUT IT GIVES A STRONG INTUITIVE PROOF!\\n\\n\\nlets say i have n piles , each having si stones\\n\\np1,p2,p3.......pn\\n\\nsuppose i\\'ve to perform k steps right\\nand say pi has highest number of stones (si)\\nnow why should i pick this pile?\\n\\nlets talk if i don\\'t touch this pile in any of k steps.\\n\\nsuppose total removal of stones we get is - r \\n\\nnow we can surely say that had i selected this pile ,\\nmy r would have been  greater? right [ coz in particular step , this pile yields maximum removal ]\\nso it means\\nin k steps, i have to select this pile atleast once, as not picking it at all doesnt yield maximum answer.\\nso we pick it.\\nnow we update our array .\\n\\n\\nedit:\\nanother question is?\\nwhy do selecting order not matter?\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2964159,
                "title": "java-solution-using-pq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(k.log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        int ans = 0;\\n        PriorityQueue<Integer> que= new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for (int i : piles) {\\n            ans += i;\\n            que.add(i);\\n        }\\n        while(k > 0) { \\n            int ele = que.poll();\\n            int rem = (int)Math.floor(ele / 2);\\n            que.add(ele - rem);\\n            ans -= rem;\\n            --k;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        int ans = 0;\\n        PriorityQueue<Integer> que= new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for (int i : piles) {\\n            ans += i;\\n            que.add(i);\\n        }\\n        while(k > 0) { \\n            int ele = que.poll();\\n            int rem = (int)Math.floor(ele / 2);\\n            que.add(ele - rem);\\n            ans -= rem;\\n            --k;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964145,
                "title": "max-heap-2-ways-3-lines-easy-faster",
                "content": "# UPVOTE PLS\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n public int minStoneSum(int[] piles, int k) {\\n        var q = new PriorityQueue<>(Comparator.reverseOrder());\\n        Arrays.stream(piles).forEach(q::offer);\\n        IntStream.range(0, k).forEach(i -> q.offer(q.peek() - (q.poll() / 2)));\\n        return q.stream().mapToInt(i -> i).sum();\\n    }\\n\\n\\n    public int minStoneSum(int[] p, int k) {\\n        int a=0;\\n        var max=new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int v:p) max.offer(v);\\n        while(!max.isEmpty() && k>0){\\n            int d=max.poll();\\n            d-=(d/2);\\n            max.offer(d);\\n            k--;\\n        }\\n        while(!max.isEmpty()) a+=max.poll();\\n        return a;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n public int minStoneSum(int[] piles, int k) {\\n        var q = new PriorityQueue<>(Comparator.reverseOrder());\\n        Arrays.stream(piles).forEach(q::offer);\\n        IntStream.range(0, k).forEach(i -> q.offer(q.peek() - (q.poll() / 2)));\\n        return q.stream().mapToInt(i -> i).sum();\\n    }\\n\\n\\n    public int minStoneSum(int[] p, int k) {\\n        int a=0;\\n        var max=new PriorityQueue<Integer>(Collections.reverseOrder());\\n        for(int v:p) max.offer(v);\\n        while(!max.isEmpty() && k>0){\\n            int d=max.poll();\\n            d-=(d/2);\\n            max.offer(d);\\n            k--;\\n        }\\n        while(!max.isEmpty()) a+=max.poll();\\n        return a;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2964128,
                "title": "accepted-priority-queue-85-bits-easy-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        int sum = 0;\\n        PriorityQueue<Integer> queue = new PriorityQueue(Collections.reverseOrder());\\n        for(int i : piles) queue.add(i);\\n\\n        while(!queue.isEmpty() && k-->0){\\n            int x = queue.poll();\\n            int a = x - (int)Math.floor(x/2);\\n            queue.add(a);\\n        }\\n        while(!queue.isEmpty()) sum += queue.poll();\\n\\n        return sum; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        int sum = 0;\\n        PriorityQueue<Integer> queue = new PriorityQueue(Collections.reverseOrder());\\n        for(int i : piles) queue.add(i);\\n\\n        while(!queue.isEmpty() && k-->0){\\n            int x = queue.poll();\\n            int a = x - (int)Math.floor(x/2);\\n            queue.add(a);\\n        }\\n        while(!queue.isEmpty()) sum += queue.poll();\\n\\n        return sum; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964062,
                "title": "99-fast-cpp-easy-code-ds",
                "content": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& a, int k) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<a.size();i++)\\n            pq.push(a[i]);\\n        \\n        while(k--)\\n        {\\n            int x=pq.top();\\n            pq.pop();\\n            x=x-(x/2);\\n            pq.push(x);\\n            \\n        }\\n        int sum=0;\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& a, int k) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<a.size();i++)\\n            pq.push(a[i]);\\n        \\n        while(k--)\\n        {\\n            int x=pq.top();\\n            pq.pop();\\n            x=x-(x/2);\\n            pq.push(x);\\n            \\n        }\\n        int sum=0;\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2964026,
                "title": "c-priority-queue-easy-explanation-with-figure",
                "content": "# Intuition\\nTo make the smallest possible sum, we need to subtract biggest element each time for k times. and to find biggest each time, use max heap(priority queue).\\n\\n# Approach\\nFirst Insert all elements of piles in priority queue and for k times, pop and insert (element-element/2) in the same queue, you\\'ll end up with smallest possible sum for k operations, for better explanation see below.\\n\\n![Screenshot (153).png](https://assets.leetcode.com/users/images/abb25442-d822-4c53-9405-b289aacb66e5_1672247469.7695584.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq(piles.begin(), piles.end());\\n        while(k--){\\n            int t = pq.top();\\n            pq.pop();\\n            t = t-t/2;\\n            pq.push(t);\\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq(piles.begin(), piles.end());\\n        while(k--){\\n            int t = pq.top();\\n            pq.pop();\\n            t = t-t/2;\\n            pq.push(t);\\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963790,
                "title": "python-heap-priority-queue-simple-explained-beats-90",
                "content": "# Intuition\\nThe first thought is that we can simply sort the list. However because we need to readd elements that are reduced and still need them to be in order we can use a heap/priority queue. This will ensure that our list is sorted at all times. By default a heap will pop minimum values first, to convert this to a max heap we can negate each number \\n```\\nmaxHeap = [-x for x in piles]\\nheapify(maxHeap)\\n```\\n\\nBe careful when working with floor division on negatives. \\n\\n```\\n3.5 // 2 = 1\\n-3.5 // 2 = -2\\n```\\n\\nFloor operations round towards negative infinity, rather than towards 0. To get around this we can instead use typecasting.\\n\\n```\\nint(-3.5 / 2) = - 1 \\n```\\n\\nNow we have a priority list which will always give us the \"largest\" (in reality most-negative) number. From here we can simply perform the required operation k times.\\n\\n# Code\\n```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        maxHeap = [-x for x in piles]\\n        heapify(maxHeap)\\n\\n        for i in range(k):\\n            val = heappop(maxHeap)\\n            heappush(maxHeap, val - int(val / 2))\\n        return -1 * sum(maxHeap)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nmaxHeap = [-x for x in piles]\\nheapify(maxHeap)\\n```\n```\\n3.5 // 2 = 1\\n-3.5 // 2 = -2\\n```\n```\\nint(-3.5 / 2) = - 1 \\n```\n```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        maxHeap = [-x for x in piles]\\n        heapify(maxHeap)\\n\\n        for i in range(k):\\n            val = heappop(maxHeap)\\n            heappush(maxHeap, val - int(val / 2))\\n        return -1 * sum(maxHeap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963611,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n       \\n\\n       int count=0;\\n       int mini=INT_MAX;\\n       priority_queue<int> p;\\n        int sum=0;\\n              for (auto x : piles)\\n                   {\\n                       sum =sum + x;\\n                       p.push(x);\\n                   }\\n     int n=piles.size();\\n       while (count< k){\\n\\n            int r=p.top();\\n            p.pop();\\n            int a=ceil(r/2.0);\\n            p.push(a);\\n            sum = sum - r + a;\\n            mini=min(mini,sum);\\n            count++;\\n\\n       }\\n       return mini; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n       \\n\\n       int count=0;\\n       int mini=INT_MAX;\\n       priority_queue<int> p;\\n        int sum=0;\\n              for (auto x : piles)\\n                   {\\n                       sum =sum + x;\\n                       p.push(x);\\n                   }\\n     int n=piles.size();\\n       while (count< k){\\n\\n            int r=p.top();\\n            p.pop();\\n            int a=ceil(r/2.0);\\n            p.push(a);\\n            sum = sum - r + a;\\n            mini=min(mini,sum);\\n            count++;\\n\\n       }\\n       return mini; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963588,
                "title": "simple-c-solution-using-count-array",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        const int s = 1e4+1;\\n        int stones[s];\\n        fill(stones, stones + s, 0);\\n        long sum = 0;\\n        for(auto i: piles){stones[i]++;sum += i;}\\n\\n        for(int i = s - 1;i > 0 && k;i--){\\n            while(stones[i] && k){\\n                stones[i]--;k--;\\n                sum -= (i/2);\\n                stones[i - (i/2)]++;\\n            }\\n        }\\n\\n        return sum;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        const int s = 1e4+1;\\n        int stones[s];\\n        fill(stones, stones + s, 0);\\n        long sum = 0;\\n        for(auto i: piles){stones[i]++;sum += i;}\\n\\n        for(int i = s - 1;i > 0 && k;i--){\\n            while(stones[i] && k){\\n                stones[i]--;k--;\\n                sum -= (i/2);\\n                stones[i - (i/2)]++;\\n            }\\n        }\\n\\n        return sum;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963275,
                "title": "my-optimised-solution-with-o-n-and-o-n-in-c",
                "content": "#\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLooking the problem focus is on how we can get the greater elmement\\nagain and again after the flooring,\\nSo the maxheap here works.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n       priority_queue<int>q;\\n       for(int i=0;i<piles.size();i++){\\n           q.push(piles[i]);\\n       }\\n\\n     for(int i=0;i<k;i++){\\n         int topElem=(q.top()+1)/2;\\n         q.pop();\\n         q.push(topElem);\\n     }\\n       int ans=0;\\n       for(int i=0;i<piles.size();i++){\\n           ans=ans+q.top();\\n           q.pop();\\n       }\\n\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n       priority_queue<int>q;\\n       for(int i=0;i<piles.size();i++){\\n           q.push(piles[i]);\\n       }\\n\\n     for(int i=0;i<k;i++){\\n         int topElem=(q.top()+1)/2;\\n         q.pop();\\n         q.push(topElem);\\n     }\\n       int ans=0;\\n       for(int i=0;i<piles.size();i++){\\n           ans=ans+q.top();\\n           q.pop();\\n       }\\n\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963260,
                "title": "sorted-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $piles\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function minStoneSum($piles, $k) {\\n        $countPiles = count($piles);\\n        sort($piles);\\n        $i = 0;\\n        while($k > 0) {\\n            $piles[$countPiles- 1 - $i] -= floor($piles[$countPiles-1 - $i] / 2);\\n            $i++;\\n\\n            if ($piles[$countPiles-1 - $i] < $piles[$countPiles-1]) {\\n                sort($piles);\\n                $i = 0;\\n            }\\n            \\n            $k--;\\n        }\\n\\n        return array_sum($piles);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $piles\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function minStoneSum($piles, $k) {\\n        $countPiles = count($piles);\\n        sort($piles);\\n        $i = 0;\\n        while($k > 0) {\\n            $piles[$countPiles- 1 - $i] -= floor($piles[$countPiles-1 - $i] / 2);\\n            $i++;\\n\\n            if ($piles[$countPiles-1 - $i] < $piles[$countPiles-1]) {\\n                sort($piles);\\n                $i = 0;\\n            }\\n            \\n            $k--;\\n        }\\n\\n        return array_sum($piles);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963169,
                "title": "o-n-k-time-complaxity-c-simple-solution",
                "content": "# Intuition\\nYou must have gone through official solution. So intution here is to select the maximum size pile in each step so that remaining number of stones can be minimised\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- - As at each iteration data is changing so one way to solve this problem is to use max-heap data structure. In each step, remove eliment from top and push the ```half of the eliment``` again in the max-heap. at last, return the sum of all the heap elements.\\n  - Time complaxity of this approach is ```O(n+k.log(n))```\\n\\n- Second approach is to use a hash table to optimise time complaxity. As size of each pile is in the range of ```1 to 10,000```. So we can create a vector ```numStones``` of size ```10001```, where each index stores the number of piles having stones equal to that```index```. For example ```numStones[250]``` represents the number of piles which have ```250``` stones.\\nNow at each step we will search the index starting from the end of the vector ```numStones``` which have non zero value. We will reduce the number of piles by 1, having stones equal to that index and increment the number of piles by 1, having stones equal to ```floor(index/2)```. We will repeat this process k times.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n```O(n+k)```. It is clear that both the while loop will run maximum ```(n+k)``` times.\\n\\n- Space complexity:\\n```O(1```). as we are using fixed size vector ```numStones```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        vector<int> numStones(10001,0);\\n        for(int i = 0; i < piles.size(); i++){\\n            numStones[piles[i]]++;\\n        }\\n\\n        int ind = 10000;\\n        while(k--){\\n            while(numStones[ind] == 0){\\n                ind--;\\n            }\\n            numStones[ind]--;\\n            numStones[(ind+1)/2]++;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < 10001; i++){\\n            ans += i*numStones[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```half of the eliment```\n```O(n+k.log(n))```\n```1 to 10,000```\n```numStones```\n```10001```\n```index```\n```numStones[250]```\n```250```\n```numStones```\n```floor(index/2)```\n```O(n+k)```\n```(n+k)```\n```O(1```\n```numStones```\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        vector<int> numStones(10001,0);\\n        for(int i = 0; i < piles.size(); i++){\\n            numStones[piles[i]]++;\\n        }\\n\\n        int ind = 10000;\\n        while(k--){\\n            while(numStones[ind] == 0){\\n                ind--;\\n            }\\n            numStones[ind]--;\\n            numStones[(ind+1)/2]++;\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < 10001; i++){\\n            ans += i*numStones[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963165,
                "title": "c-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq;\\n        for(int x:piles){\\n            pq.push(x);\\n        }\\n        while(k--){\\n            int t=pq.top();pq.pop();\\n            if(t%2==0){\\n                t/=2;\\n            }else{\\n                t/=2;\\n                t++;\\n            }\\n            pq.push(t);\\n        }\\n        int ans=0;\\n        while(!pq.empty()){\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq;\\n        for(int x:piles){\\n            pq.push(x);\\n        }\\n        while(k--){\\n            int t=pq.top();pq.pop();\\n            if(t%2==0){\\n                t/=2;\\n            }else{\\n                t/=2;\\n                t++;\\n            }\\n            pq.push(t);\\n        }\\n        int ans=0;\\n        while(!pq.empty()){\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963050,
                "title": "max-heap-with-intuition-and-approach-with-picture-explanation-ceil-not-floor",
                "content": "# Approach\\n- We have been given a pile of stones and from these we have to remove \\nceil(piles[i]/2) stones\\n- we can perform above operattion of removing stone on the same pile more than once\\n- k -> it is the no of times you have to perform above operation\\n- And we need to return minimum no of stones left after performing k operations\\n---\\n1. Make a max heap of the given list of piles\\n2. as you know we can only make min heap in python ,so multiple the with elements with \"-\" , heapify your heap your max will be ready ...!!!\\n3. for atmost k times\\n4. we pop the top element perform operation i.e., ceil(piles[i]/2) \\n5. and check whether it is greater than 0 or not if so then we\\'ll again push that element back into the heap after performing step 2\\n6. from above steps we are done with one operation , so decrease the k by 1\\n7. now return the sum of elements of max_heap and multiply it with \"-\"\\n8. you\\'ll get your minimum no of stones\\n\\n# Dry Run\\n![tempImageMTAzUU.jpg](https://assets.leetcode.com/users/images/f322cfd7-e5e7-4087-867d-6e6bd09653ef_1672234644.025839.jpeg)\\n\\n\\n\\n\\n# Code\\n```\\n#Test cases are given according to ceil not floor\\n#so while solving the question you should consider ceil value of operation instead of floor value\\n\\nimport math\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        #first of all make a max heap of piles\\n        max_heap=[-x for x in piles]\\n        #heapify it\\n        heapq.heapify(max_heap)\\n        for i in range(k):\\n            #pop the element from max heap\\n            first_pile= -heapq.heappop(max_heap)\\n            #then perform the operation as stated in the ques\\n            first_pile= math.ceil(first_pile/2)\\n            #then if it is greater than 0 push it back to the max heap\\n            if first_pile > 0:\\n                heapq.heappush(max_heap,-first_pile)\\n            #decrease the no of operation i.e., k    \\n            k-=1\\n            #finally return the sum of elements of max heap and don\\'t forget to multiply the ans with \"-\"..lol..!!\\n        return (-(sum(max_heap)))\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#Test cases are given according to ceil not floor\\n#so while solving the question you should consider ceil value of operation instead of floor value\\n\\nimport math\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        #first of all make a max heap of piles\\n        max_heap=[-x for x in piles]\\n        #heapify it\\n        heapq.heapify(max_heap)\\n        for i in range(k):\\n            #pop the element from max heap\\n            first_pile= -heapq.heappop(max_heap)\\n            #then perform the operation as stated in the ques\\n            first_pile= math.ceil(first_pile/2)\\n            #then if it is greater than 0 push it back to the max heap\\n            if first_pile > 0:\\n                heapq.heappush(max_heap,-first_pile)\\n            #decrease the no of operation i.e., k    \\n            k-=1\\n            #finally return the sum of elements of max heap and don\\'t forget to multiply the ans with \"-\"..lol..!!\\n        return (-(sum(max_heap)))\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962881,
                "title": "ruby-solution-without-heap-t-442-ms-beats-100-m-235-9-mb-beats-100",
                "content": "# Approach\\nLet me explain the approach with an example; \\n`piles = [19, 7, 4, 8,16,20,6,3]` \\n`key = 10`\\n\\nFirstly, all piles are grouped by their binary logarithm(log2).\\n\\n![image.png](https://assets.leetcode.com/users/images/36acf952-f629-4196-93bd-b08a44d48b63_1672231186.8723443.png)\\n\\nThen, all values of key `5` can be sent to values of `4` by dividing 2 without sorting because we need only 3 operations and 10 operations is possible.\\n\\n![image.png](https://assets.leetcode.com/users/images/a3ce08df-0d85-431c-a64d-5f684f3babfa_1672232224.5514014.png)\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/d3d8b6cd-985b-44b8-be0e-f2b0acb6da14_1672231497.8373713.png)\\n\\n\\nAgain, it is possible to repeat the same procedure by selecting the hightest key and its values.\\n\\n![image.png](https://assets.leetcode.com/users/images/50080ca3-3d25-440c-b0c6-999061df834a_1672232298.4810324.png)\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/0c88b038-7dc3-4f9c-910a-755b05d5a3e6_1672231568.8799877.png)\\n\\nNow, the size of the values of the highest key(`3`) is greater than the possible operations(k). So, its values should be sorted.\\n\\n![image.png](https://assets.leetcode.com/users/images/afefbb1a-c15e-431a-ab12-8f4768331cdc_1672231678.9723933.png)\\n\\nThen, only the last `k` elements can be updated.\\n\\n![image.png](https://assets.leetcode.com/users/images/4e8cbe35-1571-43a2-a5c8-b97dfd58f9ee_1672232350.1923862.png)\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/405e8266-dec8-41df-b576-106a00888456_1672231769.643331.png)\\n\\nLastly, the sum of all values should be returned.\\n\\nNote: the key `0` is the last possible key, so if there is a negative key, the size of `piles` can be returned, because all values will be 1, and their sum will be equal to the size of `piles`.\\n\\nNote2: I have used `excalidraw.com` to draw if you wonder.\\n\\n\\n# Code\\n```ruby []\\n# @param {Integer[]} piles\\n# @param {Integer} k\\n# @return {Integer}\\ndef min_stone_sum(piles, k)\\n  group_piles = piles.group_by {|num| Math.log2(num).ceil} \\n\\n  max_key = group_piles.keys.max\\n  until (k - group_piles[max_key].size) < 0\\n    k -= group_piles[max_key].size\\n    \\n    group_piles[max_key - 1] = [] if group_piles[max_key - 1].nil?\\n    group_piles[max_key - 1].concat(\\n      group_piles.delete(max_key).map! do |num|\\n        (num / 2.0).ceil\\n      end\\n    )\\n    \\n    max_key = group_piles.keys.max\\n    return piles.size if max_key.negative?\\n  end\\n  \\n  if k > 0\\n    group_piles[max_key - 1] = [] if group_piles[max_key - 1].nil?\\n    group_piles[max_key - 1].concat(\\n      group_piles[max_key].sort!.pop(k).map! do |num|\\n        (num / 2.0).ceil\\n      end\\n    )\\n  end\\n\\n  group_piles.values.map(&:sum).sum\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby []\\n# @param {Integer[]} piles\\n# @param {Integer} k\\n# @return {Integer}\\ndef min_stone_sum(piles, k)\\n  group_piles = piles.group_by {|num| Math.log2(num).ceil} \\n\\n  max_key = group_piles.keys.max\\n  until (k - group_piles[max_key].size) < 0\\n    k -= group_piles[max_key].size\\n    \\n    group_piles[max_key - 1] = [] if group_piles[max_key - 1].nil?\\n    group_piles[max_key - 1].concat(\\n      group_piles.delete(max_key).map! do |num|\\n        (num / 2.0).ceil\\n      end\\n    )\\n    \\n    max_key = group_piles.keys.max\\n    return piles.size if max_key.negative?\\n  end\\n  \\n  if k > 0\\n    group_piles[max_key - 1] = [] if group_piles[max_key - 1].nil?\\n    group_piles[max_key - 1].concat(\\n      group_piles[max_key].sort!.pop(k).map! do |num|\\n        (num / 2.0).ceil\\n      end\\n    )\\n  end\\n\\n  group_piles.values.map(&:sum).sum\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2962781,
                "title": "python3-1400-ms-100-faster-code-o-max-n-ln-n-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all, sort given array in non-decreasing order. Time complexity $$O(n * ln(n))$$. \\nThen we do the following steps:\\n- we find the maximum value between the last element in the array and the first element in the queue\\n- pop this element\\n- add element // to queue\\n\\nTime complexity of this is $$O(k)$$\\n\\nAnd total time complexity is $$O(max(n*ln(n), k))$$\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(max(n*ln(n), k))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        piles.sort()\\n        q = deque()\\n\\n        for i in range(k):\\n            p1 = 0\\n            p2 = 0\\n            if piles:\\n                p1 = piles[-1]\\n            if q:\\n                p2 = q[0]\\n            if p1 > p2:\\n                p = piles.pop()\\n            else:\\n                p = q.popleft()\\n            q.append(math.ceil(p / 2))\\n\\n        return sum(piles) + sum(q)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        piles.sort()\\n        q = deque()\\n\\n        for i in range(k):\\n            p1 = 0\\n            p2 = 0\\n            if piles:\\n                p1 = piles[-1]\\n            if q:\\n                p2 = q[0]\\n            if p1 > p2:\\n                p = piles.pop()\\n            else:\\n                p = q.popleft()\\n            q.append(math.ceil(p / 2))\\n\\n        return sum(piles) + sum(q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962692,
                "title": "cpp-solution-using-max-heap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n\\n     priority_queue<int> pq(piles.begin(),piles.end());\\n\\n     for(int i=0; i<k; i++){\\n         int temp=pq.top();\\n         pq.pop();\\n         temp-=temp/2;\\n         pq.push(temp);\\n     }\\n    \\n    int ans=0;\\n    while(!pq.empty()){\\n        int t=pq.top();\\n        pq.pop();\\n        ans+=t;\\n    }\\n\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n\\n     priority_queue<int> pq(piles.begin(),piles.end());\\n\\n     for(int i=0; i<k; i++){\\n         int temp=pq.top();\\n         pq.pop();\\n         temp-=temp/2;\\n         pq.push(temp);\\n     }\\n    \\n    int ans=0;\\n    while(!pq.empty()){\\n        int t=pq.top();\\n        pq.pop();\\n        ans+=t;\\n    }\\n\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962689,
                "title": "best-solution-in-c-maxheap",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int sum=0;\\n        priority_queue<int> pq;\\n        for(auto it:piles)\\n            pq.push(it);\\n        for(int i=0;i<k;i++){\\n            int ele=pq.top();\\n            pq.pop();\\n            pq.push(ele-floor(ele/2));\\n        }\\n        while(pq.size()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int sum=0;\\n        priority_queue<int> pq;\\n        for(auto it:piles)\\n            pq.push(it);\\n        for(int i=0;i<k;i++){\\n            int ele=pq.top();\\n            pq.pop();\\n            pq.push(ele-floor(ele/2));\\n        }\\n        while(pq.size()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962513,
                "title": "c-solution-priority-queue-easy",
                "content": "# Intuition\\nTake the Largest element and perform operations on that.\\n\\n# Approach\\n    1. Insert each element in heap\\n    2. for k times:\\n        pick maximum element\\n        pop it from heap\\n        push the element/2 value in heap\\n    3. calculate sum of the elements in heap and return\\n\\n# Complexity\\n- Time complexity:\\n   ```O(nlog(n)) + O(klog(k))```\\n\\n- Space complexity:\\n  ```O(n)```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        \\n        priority_queue<int> hp;\\n        int sum = 0;\\n        for(int i: piles) hp.push(i);\\n\\n        while(k > 0){\\n\\n            int cur  = hp.top();\\n            hp.pop();\\n\\n            hp.push(ceil(cur/2.0));\\n\\n            k--;\\n        }\\n\\n        while(!hp.empty()) {\\n            sum += hp.top();\\n            hp.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```\\nUpvote if you like the solution :)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```O(nlog(n)) + O(klog(k))```\n```O(n)```\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        \\n        priority_queue<int> hp;\\n        int sum = 0;\\n        for(int i: piles) hp.push(i);\\n\\n        while(k > 0){\\n\\n            int cur  = hp.top();\\n            hp.pop();\\n\\n            hp.push(ceil(cur/2.0));\\n\\n            k--;\\n        }\\n\\n        while(!hp.empty()) {\\n            sum += hp.top();\\n            hp.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962431,
                "title": "c-solution-with-explanation-and-comments",
                "content": "# Approach\\n\\nWe have to take the largest number each time and delete half(floor value) from this.\\n          \\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt any given step, which number should we choose? We want to minimize the total number of stones remaining, which means we want to maximize the number of stones we remove at each step, so we should choose greedily choose the largest number at every step.\\n\\nEvery time we complete an operation, the data changes and we need to find the maximum number again. The best data structure for this would be a heap, as it allows us to update the data and always retrieve the maximum value in O(logn) time, compared to O(n) if we just used an array.\\n\\n# ALGORITHM\\n 1. Initialize a max heap from piles.\\n\\n2. Perform the following k times:\\n\\n- Pop the maximum element from the heap, call it curr.\\n- Calculate how many stones remove should be removed from curr after performing the operation. It is the floor of curr / 2.\\n- Push curr - remove onto the heap.\\n3. Return the sum of the elements in the heap.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O((n+k) logn)\\n\\n     Creation of priority queue takes O(n) time.\\ni.) for loop is running k times i.e O(k).\\nii.) the insertion and deletion in a priority queue takes O(logn) time.\\niii.) Traversing the priority queue to get the answer and deleting the top most element is taking O(nlogn) time.\\n\\nHence the total time complexity is O(n)+O(klogn)+O(nlogn)\\n=> O((n+k) logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)  -*heap length, which is all the extra space we use.*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        //use max-heap priority queue to get maximum values from piles\\n        //will copy the vector to the priority queue\\n        priority_queue<int>heap(piles.begin(),piles.end());\\n        \\n        //accumulate is stl for finding the sum of the array.\\n        int totalsum = accumulate(piles.begin(),piles.end(),0);\\n        \\n        //apply operation k times\\n        for(int i=0;i<k;i++){\\n            //top element will always be the largest element\\n            int curr = heap.top();\\n            heap.pop();\\n            int remove = curr/2;\\n            totalsum -= remove; // remove stones\\n            heap.push(curr - remove); // put remaining stones\\n        }\\n        return totalsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        //use max-heap priority queue to get maximum values from piles\\n        //will copy the vector to the priority queue\\n        priority_queue<int>heap(piles.begin(),piles.end());\\n        \\n        //accumulate is stl for finding the sum of the array.\\n        int totalsum = accumulate(piles.begin(),piles.end(),0);\\n        \\n        //apply operation k times\\n        for(int i=0;i<k;i++){\\n            //top element will always be the largest element\\n            int curr = heap.top();\\n            heap.pop();\\n            int remove = curr/2;\\n            totalsum -= remove; // remove stones\\n            heap.push(curr - remove); // put remaining stones\\n        }\\n        return totalsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962399,
                "title": "c-priority-queue-easy-to-understand-t-s-764-ms-103-8-mb",
                "content": "**Approach:**\\n* Create a priority queue and initialize it with the elements of the piles array. This will allow us to easily find the pile with the most stones at any given time.\\n\\n* For k times, do the following:\\n1. Pop the top element from the priority queue (the pile with the most stones).\\n2. Divide the number of stones in the pile by 2 and round up to the nearest integer.\\n3. Push the resulting number back into the priority queue.\\n\\n\\n* Then return the sum of all the number of stones in priority queue. \\n\\n*Time Complexity* - O((n+k) logn)\\n*Space Complexity* - O(n)\\n\\n**Please consider upvoting ,If you found this solution helpful.**\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int ans=0;\\n        priority_queue<int> pq(piles.begin(),piles.end());\\n        \\n        while(k--){\\n            pq.push(ceil(pq.top()/2.0));\\n            pq.pop();\\n        }\\n        \\n        for(int i=0;i<piles.size();i++){\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int ans=0;\\n        priority_queue<int> pq(piles.begin(),piles.end());\\n        \\n        while(k--){\\n            pq.push(ceil(pq.top()/2.0));\\n            pq.pop();\\n        }\\n        \\n        for(int i=0;i<piles.size();i++){\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962383,
                "title": "python-heap-solution-easy-to-understand",
                "content": "\\n# Code\\n```\\nfrom heapq import heapify, heapreplace\\n\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        piles = [-p for p in piles]\\n        heapify(piles)\\n        for _ in range(k):\\n            heapreplace(piles, piles[0]//2)\\n\\n        return -sum(piles)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heapify, heapreplace\\n\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        piles = [-p for p in piles]\\n        heapify(piles)\\n        for _ in range(k):\\n            heapreplace(piles, piles[0]//2)\\n\\n        return -sum(piles)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962283,
                "title": "simple-c-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)+O(k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq;\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            pq.push(piles[i]);\\n        }\\n        while(k--)\\n        {\\n            int k=pq.top();\\n            pq.pop();\\n            pq.push((k+1)/2);\\n        }\\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq;\\n        for(int i=0;i<piles.size();i++)\\n        {\\n            pq.push(piles[i]);\\n        }\\n        while(k--)\\n        {\\n            int k=pq.top();\\n            pq.pop();\\n            pq.push((k+1)/2);\\n        }\\n        int ans=0;\\n        while(!pq.empty())\\n        {\\n            ans+=pq.top();\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962236,
                "title": "easy-tulki-pudi-solution",
                "content": "# Complexity\\n- Time complexity: $$O(KlogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n        int res=0;\\n        for(int pile: piles) {\\n            pq.add(pile);\\n            res+=pile;\\n        }\\n        while(k-->0){\\n            int val = pq.poll();\\n            int remove = val/2;\\n            res-=remove;\\n            pq.add(val-remove);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b)->b-a);\\n        int res=0;\\n        for(int pile: piles) {\\n            pq.add(pile);\\n            res+=pile;\\n        }\\n        while(k-->0){\\n            int val = pq.poll();\\n            int remove = val/2;\\n            res-=remove;\\n            pq.add(val-remove);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962165,
                "title": "c-priority-queue-map-faster-than-95",
                "content": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\\n\\n---\\n# Priority Queue\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n\\n        int totalStones = 0;\\n        for(auto i : piles){\\n            pq.push(i);\\n            totalStones += i;\\n        }\\n\\n        for(int i = 0; i<k && !pq.empty(); i++){\\n            int x = pq.top();\\n            pq.pop();\\n            \\n            totalStones -= x/2;\\n            pq.push(x-x/2);\\n        }\\n\\n        return totalStones;\\n    }\\n};\\n```\\n\\n\\n---\\n\\n\\n# Map\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        map<int, int> mp;\\n\\n        int totalStones = 0;\\n        for(auto i : piles){\\n            mp[i]++;\\n            totalStones += i;\\n        }\\n\\n        auto itr = mp.rbegin();\\n        for(int i = 0; i<k && itr != mp.rend(); i++){\\n            int x = itr->first;\\n            mp[x]--;\\n            mp[x-x/2]++;\\n            totalStones -= x/2;\\n            if(itr->second == 0)\\n                itr++;\\n        }\\n\\n        return totalStones;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int> pq;\\n\\n        int totalStones = 0;\\n        for(auto i : piles){\\n            pq.push(i);\\n            totalStones += i;\\n        }\\n\\n        for(int i = 0; i<k && !pq.empty(); i++){\\n            int x = pq.top();\\n            pq.pop();\\n            \\n            totalStones -= x/2;\\n            pq.push(x-x/2);\\n        }\\n\\n        return totalStones;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        map<int, int> mp;\\n\\n        int totalStones = 0;\\n        for(auto i : piles){\\n            mp[i]++;\\n            totalStones += i;\\n        }\\n\\n        auto itr = mp.rbegin();\\n        for(int i = 0; i<k && itr != mp.rend(); i++){\\n            int x = itr->first;\\n            mp[x]--;\\n            mp[x-x/2]++;\\n            totalStones -= x/2;\\n            if(itr->second == 0)\\n                itr++;\\n        }\\n\\n        return totalStones;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962117,
                "title": "using-min-max-heap-time-o-n-log-k-space-o-k",
                "content": "# Approach\\n1. use min heap to keep top k elements. Time: O(n*log(k)), Space: O(k)\\n2. keep adding piles to result while maintaing above heap\\n3. copy min heap to max heap. Time: O(k*log(k)), Space: O(k)\\n4. for every k poll max element say max from max heap\\n5. remove max/2 piles and add it back to max heap, also subtract removed piles from result. Time: O(k*log(k))\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(k) + k*log(k) + k*log(k)) -> O((n+2k)*log(k))\\n\\n- Space complexity:\\nO(k+k) -> O(2k)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>(k + 1, (a,b)->a-b);\\n        int result = 0;\\n        for (int pile : piles) {\\n            minHeap.add(pile);\\n            result += pile;\\n            if (minHeap.size() > k) \\n                minHeap.poll();\\n        }\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(k, (a,b)->b-a);\\n        while (!minHeap.isEmpty()) \\n            maxHeap.add(minHeap.poll());\\n\\n        for (int i=0; i<k; i++) {\\n            int pile = maxHeap.poll();\\n            int removedStones = pile/2;\\n            pile = pile - removedStones;\\n            result -= removedStones;\\n            maxHeap.add(pile);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] piles, int k) {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>(k + 1, (a,b)->a-b);\\n        int result = 0;\\n        for (int pile : piles) {\\n            minHeap.add(pile);\\n            result += pile;\\n            if (minHeap.size() > k) \\n                minHeap.poll();\\n        }\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(k, (a,b)->b-a);\\n        while (!minHeap.isEmpty()) \\n            maxHeap.add(minHeap.poll());\\n\\n        for (int i=0; i<k; i++) {\\n            int pile = maxHeap.poll();\\n            int removedStones = pile/2;\\n            pile = pile - removedStones;\\n            result -= removedStones;\\n            maxHeap.add(pile);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962076,
                "title": "easy-to-underestant-solution-in-c-nlog-k-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEasy to underestant Solution in C++/ Nlog(K) Time complexity\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. push all values in max-heap for priority queue \\n2. then pick the top element which is maximum of all element in a priority queue\\n3. divide the element by 2 and pop the original element and push the remaining element\\n4. and do this process for k times\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nNlog(K).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        priority_queue<int> g;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            g.push(p[i]);\\n        }\\n        while(k--)\\n        {\\n            int t=g.top();\\n            g.pop();\\n            g.push(t-t/2);\\n        }\\n        int sum=0;\\n        while(!g.empty())\\n        {\\n            sum+=g.top();\\n            g.pop();\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        priority_queue<int> g;\\n        for(int i=0;i<p.size();i++)\\n        {\\n            g.push(p[i]);\\n        }\\n        while(k--)\\n        {\\n            int t=g.top();\\n            g.pop();\\n            g.push(t-t/2);\\n        }\\n        int sum=0;\\n        while(!g.empty())\\n        {\\n            sum+=g.top();\\n            g.pop();\\n        }\\n        return sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962074,
                "title": "python3-sortedcontainers-sortedlist",
                "content": "https://leetcode.com/submissions/detail/866817274/\\nRuntime: 3083 ms  \\nMemory Usage: 29 MB  \\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        l = SortedList()\\n        l.update(piles)\\n        remained = sum(piles)\\n        for _ in range(k):\\n            p = l.pop(-1)\\n            r = p//2\\n            if r==0: break\\n            remained -= r\\n            l.add(p-r)\\n        return remained\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        l = SortedList()\\n        l.update(piles)\\n        remained = sum(piles)\\n        for _ in range(k):\\n            p = l.pop(-1)\\n            r = p//2\\n            if r==0: break\\n            remained -= r\\n            l.add(p-r)\\n        return remained\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962072,
                "title": "python-max-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNeed to greedily figureout the maximum element of the pile.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a max heap to store the piles. Pop the heap, modify the pile and then push it back in the heap.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n + klog(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ can be $$O(1)$$ if heap is created via the input list.\\n\\n# Code\\n```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        max_heap = []\\n        for pile in piles:\\n            heapq.heappush(max_heap, -pile)\\n\\n        for _ in range(k):\\n            pile = heapq.heappop(max_heap)\\n            pile = math.ceil(-pile/2)\\n            heapq.heappush(max_heap, -pile)\\n        \\n        return -sum(max_heap)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        max_heap = []\\n        for pile in piles:\\n            heapq.heappush(max_heap, -pile)\\n\\n        for _ in range(k):\\n            pile = heapq.heappop(max_heap)\\n            pile = math.ceil(-pile/2)\\n            heapq.heappush(max_heap, -pile)\\n        \\n        return -sum(max_heap)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962059,
                "title": "c-max-heap-with-comments-and-easy-approach",
                "content": "```\\nThe problem given is to find the minimum possible\\n            sum after performing K number of operations on a particular\\n            element given in the array\\n            \\n            the operation - remove floor(a[i]/2) from any given a[i]\\n            \\n            By observation we can say\\n                - To get minimum sum we need to reduce the maximum element\\n                - To get max element in every iteration\\n                - We can use some data structure to get max element in every \\n                  iteration hence we get an idea of using max heap\\n            \\n            We can do at max K operations so we iterate for K times and\\n            in every iteration take top element (max element) and reduce it\\n            by element/2 and repush into the queue\\n            \\n            After K iteration return sum of all elements of the priority queue thus\\n            we would get the minimum sum\\n            \\n            Time Complexity : O(n) for creating priority queue\\n                              O(k) for running upto K iterations, \\n                                   insertion and deletion in pq takes O(logn) time\\n                                  \\n                                   So, traversing and deleting simultaneously takes\\n                                   O(nlogn)\\n                           \\n                                   total = O((n + k)\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\n-------------------------------------------------------------------------------------------------------------------------\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\n    int minStoneSum(vector<int>& piles, int k) {\\n \\n        priority_queue<int> pq;\\n        int sum = 0;\\n        for(auto i : piles){\\n            pq.push(i);\\n        }\\n        for(int i = 0; i < k; i++){\\n            int maxElement = pq.top();\\n            pq.pop();\\n            maxElement -= floor(maxElement/2);\\n            pq.push(maxElement);\\n        }\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nThe problem given is to find the minimum possible\\n            sum after performing K number of operations on a particular\\n            element given in the array\\n            \\n            the operation - remove floor(a[i]/2) from any given a[i]\\n            \\n            By observation we can say\\n                - To get minimum sum we need to reduce the maximum element\\n                - To get max element in every iteration\\n                - We can use some data structure to get max element in every \\n                  iteration hence we get an idea of using max heap\\n            \\n            We can do at max K operations so we iterate for K times and\\n            in every iteration take top element (max element) and reduce it\\n            by element/2 and repush into the queue\\n            \\n            After K iteration return sum of all elements of the priority queue thus\\n            we would get the minimum sum\\n            \\n            Time Complexity : O(n) for creating priority queue\\n                              O(k) for running upto K iterations, \\n                                   insertion and deletion in pq takes O(logn) time\\n                                  \\n                                   So, traversing and deleting simultaneously takes\\n                                   O(nlogn)\\n                           \\n                                   total = O((n + k)\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\n-------------------------------------------------------------------------------------------------------------------------\\t\\t\\t\\t\\t\\t\\t\\t   \\n\\n    int minStoneSum(vector<int>& piles, int k) {\\n \\n        priority_queue<int> pq;\\n        int sum = 0;\\n        for(auto i : piles){\\n            pq.push(i);\\n        }\\n        for(int i = 0; i < k; i++){\\n            int maxElement = pq.top();\\n            pq.pop();\\n            maxElement -= floor(maxElement/2);\\n            pq.push(maxElement);\\n        }\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2962045,
                "title": "python3-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn each iteration, we need to \\n1. pop the maximum elements in piles\\n2. do the operation \\n3. put the new element back to piles\\n\\nWe could simply implement it by sort piles, get the maximum, do the operation and put it back. However, it exceeds time limit. \\n\\nIntuitively, we think of using heap. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPython has ready to use heap API, [heapq](https://docs.python.org/3/library/heapq.html). However, it is a min heap which pops the minimum item while we need a max heap which pops the maximum item. \\n\\nA easy way to change a min heap to a max heap is to convert all elements to negative. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        negativePiles = [-p for p in piles]\\n        total = sum(piles)\\n        heapq.heapify(negativePiles)\\n        for _ in range(k):\\n            maxi = heapq.heappop(negativePiles)\\n            decrement = math.floor(-maxi / 2)\\n            total -= decrement\\n            heapq.heappush(negativePiles, maxi + decrement)\\n            \\n        return total\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        negativePiles = [-p for p in piles]\\n        total = sum(piles)\\n        heapq.heapify(negativePiles)\\n        for _ in range(k):\\n            maxi = heapq.heappop(negativePiles)\\n            decrement = math.floor(-maxi / 2)\\n            total -= decrement\\n            heapq.heappush(negativePiles, maxi + decrement)\\n            \\n        return total\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961992,
                "title": "easy-python-solution-using-min-heap",
                "content": "# Intuition\\nwe need to reduce the maximum element in array so we need to keep track of max elememt :) so heap comes in our way.\\n\\n# Approach\\nI used heapq to heapify the given array by multiplying each value by -1 to get a max heap :)\\n\\n# Complexity\\n- Time complexity: O(n + log(n))\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        \\n        total = sum(piles)\\n\\n        piles = [-i for i in piles]\\n\\n        heapq.heapify(piles)\\n\\n        while k > 0:\\n            temp = heapq.heappop(piles)*-1\\n\\n            total -= temp//2\\n            temp -= temp//2\\n            heapq.heappush(piles, temp*-1)\\n\\n            k -= 1\\n        return total\\n            \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        \\n        total = sum(piles)\\n\\n        piles = [-i for i in piles]\\n\\n        heapq.heapify(piles)\\n\\n        while k > 0:\\n            temp = heapq.heappop(piles)*-1\\n\\n            total -= temp//2\\n            temp -= temp//2\\n            heapq.heappush(piles, temp*-1)\\n\\n            k -= 1\\n        return total\\n            \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2961955,
                "title": "2-solutions-priorityqueue-treemap-97-beats-java",
                "content": "\\n\\n# Code (Using TreeMap)\\n```\\nclass Solution {\\n    public int minStoneSum(int[] p, int k) {\\n        TreeMap<Integer,Integer> tm=new TreeMap<>();\\n        int out=0;\\n        for(int i:p)\\n            tm.put(i,tm.getOrDefault(i,0)+1);\\n\\n        while(k--!=0){\\n            int t=tm.lastKey();\\n            if(tm.get(t)==1)\\n                tm.remove(t);\\n            else\\n                tm.replace(t,tm.get(t)-1);    \\n            tm.put(t-t/2,tm.getOrDefault(t-t/2,0)+1);\\n        }\\n        \\n        for(Map.Entry<Integer,Integer> m:tm.entrySet())\\n            out+=(m.getKey()*m.getValue());\\n\\n   \\n        \\n             \\n        return out;        \\n    }\\n}\\n```\\n\\n# Code (Using PriorityQueue)\\n```\\nclass Solution {\\n    public int minStoneSum(int[] p, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((x,y)->y-x);\\n        int out=0;\\n        for(int i:p){\\n            pq.add(i);\\n            out+=i;\\n        }\\n            \\n\\n        while(k--!=0){\\n            int t=pq.peek();\\n            out-=t/2;\\n            pq.remove(t);\\n            pq.add(t-t/2);\\n        }\\n        \\n\\n        return out;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minStoneSum(int[] p, int k) {\\n        TreeMap<Integer,Integer> tm=new TreeMap<>();\\n        int out=0;\\n        for(int i:p)\\n            tm.put(i,tm.getOrDefault(i,0)+1);\\n\\n        while(k--!=0){\\n            int t=tm.lastKey();\\n            if(tm.get(t)==1)\\n                tm.remove(t);\\n            else\\n                tm.replace(t,tm.get(t)-1);    \\n            tm.put(t-t/2,tm.getOrDefault(t-t/2,0)+1);\\n        }\\n        \\n        for(Map.Entry<Integer,Integer> m:tm.entrySet())\\n            out+=(m.getKey()*m.getValue());\\n\\n   \\n        \\n             \\n        return out;        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minStoneSum(int[] p, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((x,y)->y-x);\\n        int out=0;\\n        for(int i:p){\\n            pq.add(i);\\n            out+=i;\\n        }\\n            \\n\\n        while(k--!=0){\\n            int t=pq.peek();\\n            out-=t/2;\\n            pq.remove(t);\\n            pq.add(t-t/2);\\n        }\\n        \\n\\n        return out;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576925,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1730868,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1730944,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1730845,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1731169,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1731121,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1731000,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1731517,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1731336,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1717098,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1576925,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1730868,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1730944,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1730845,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1731169,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1731121,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1731000,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1731517,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1731336,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1717098,
                "content": [
                    {
                        "username": "thealexs",
                        "content": "The problem description is wrong.  They say \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\", but I could only get this to work by rounding x up."
                    },
                    {
                        "username": "alreadyselfish",
                        "content": "The description does not ask you to convert ele to its floor but rather to `remove x rocks from one pile where x = floor of ele`. This means the pile automatically has ceil of ele number of rocks left. Y\\'all need to read the question more carefully LOL.\\n"
                    },
                    {
                        "username": "TuringJest",
                        "content": "[@David Alexander](/thealexs) Floor is correct but if you use a `min heap` e.g. in Python and turn it into a `max heap` by multiplying with `-1` you might also have to invert `floor` to `ceil`. \n```\n            max = heappop(heap)\n            heappush(heap, max-math.ceil(max/2))\n```\n\ne.g. here floor(-9/2) will give -5 but with ceil it will be -4, which is the correct way.  "
                    },
                    {
                        "username": "syedeitzaz",
                        "content": "yes ceil() will work"
                    },
                    {
                        "username": "Chetan_Depanagoudra",
                        "content": "seriously this sentence \"floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).\" it took so long for me to understand, thanks [@Ayush Raj](/Parzival1509) and [@Codis Ira](/codis) for making it cristal clear,"
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "sir the description is correct may be you got confused in replacing it with x-floor(x/2) and description says floor is smaller than or equal to x which correct\\n"
                    },
                    {
                        "username": "nishant7372",
                        "content": "The description is correct. My code is working fine with piles[i]-=Math.floor(piles[i]/2);"
                    },
                    {
                        "username": "Parzival1509",
                        "content": "The description is correct. Try reading the question again. You need to remove floor(x) stones from the piles."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "You need to remove i.e. piles[i] = piles[i] - floor(piles[i]/2), not replace it"
                    },
                    {
                        "username": "codis",
                        "content": "You subtract the floor from the pile, not take the floor of the pile. For example if there are 9 in the largest pile and the floor of 9/2 = 4 the pile doesn\\'t become 4, it becomes 9 - 4 = 5."
                    },
                    {
                        "username": "_stalkmenow",
                        "content": "You should remove floor(x) entries from that pile and not replace the pile count with floor(x). If you do this it will work."
                    },
                    {
                        "username": "jshalaby",
                        "content": "Thats ceiling, not floor."
                    },
                    {
                        "username": "mukul_2020bcse077",
                        "content": "no well we have to remove and replace that with (x- floor(x/2)) "
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "And that\\'s removing, not keeping"
                    },
                    {
                        "username": "drewbie",
                        "content": "[@xenia_wan](/xenia_wan) Oh.... that makes this make more sense now. Still kind of meh."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Remember that we\\'re **removing** the floor from the pile, not **keeping** it."
                    },
                    {
                        "username": "dumb_me",
                        "content": "Its floor value which we are removing \\n9 - floor(9) - 4\\n9 - 4 = 5\\nso 5 will be in our pile."
                    },
                    {
                        "username": "tjstinso",
                        "content": "Ended up here from some daily challenge thing. This was pretty clearly a heap problem, but are there any interesting non-heap solutions?"
                    },
                    {
                        "username": "romerlrl",
                        "content": "https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2964740/python-solution-non-heap-solution-beats-100-runtime/"
                    },
                    {
                        "username": "raghupalash",
                        "content": "[@Crishpy_Coffee](/Crishpy_Coffee) Priority Queue is an abstract datastructure that is best implemented using a heap. So I think that\\'s the same implementation as a heap..."
                    },
                    {
                        "username": "tmtappr",
                        "content": "You can use [counting sort](https://en.wikipedia.org/wiki/Counting_sort), which could lead to a $$O(n + k)$$ solution. It could also be called a \"frequency array\". Sorry I can't link to solutions from the discussion thread, and the wikipedia article on it doesn't make it clear how to apply it to this problem. You can find better articles on it that could make it clearer."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "you can use priority queue solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& p, int k) {\\n        \\n        priority_queue<int> q;\\n        for(auto i:p){\\n            q.push(i);\\n        }\\n        for(int i=0; i<k; i++){\\n            int num = q.top();\\n            int half = num/2;\\n            q.pop();\\n            q.push(num-half);\\n        }\\n\\n        int sum=0;\\n\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "superstar_2000",
                        "content": "[@Delusional2911](/Delusional2911) The solution is not correct as you are sorting the array in descending order but you actually need a heap or maybe some other ds that gives you maxElement in the array each time (greedy) you iterate.\\n\\nex -> If your sorted array is [20,4,3,2] , k = 3\\nYou will get output as -> 20 - floor(20 / 2) -> 20 - 10 -> 10 => k = 2 now\\nSo you are no going to nextElement in the array i.e 4 which is wrong\\nyou should again check the 1st element as its the greatest element.So essentially\\nyou need max element at each stage so that you can divide it by 2 and get minValue optimally.Hope it makes sense. Let me know if you still have doubts. Happy Coding :)"
                    },
                    {
                        "username": "pikachuu",
                        "content": "Hint: Use buckets (or frequency array)\n\nhttps://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961564/c-2-approach-priority-queue-tc-o-klogn-and-buckets-tc-o-n-k/?orderBy=most_votes"
                    },
                    {
                        "username": "0xatul",
                        "content": "[@VictorKoch](/VictorKoch) lol\\n"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@Delusional2911](/Delusional2911) dude for 100,10,4 and k=2 this will take out 55 stones, but it should take out 75."
                    },
                    {
                        "username": "minkowskiq",
                        "content": "You can have a pseudo polynomial algorithm solution with TC $$O(n+m)$$, where $$m$$ is the max number in the input. For the given input constraints it runs faster than the heap approach with TC $$O(n+k\\cdot log(n))$$. We can't directly compare the TCs without knowing the input.\n[My pseudo-polynomial time solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2960976)"
                    },
                    {
                        "username": "VictorKoch",
                        "content": "Just tried to implements something interesting, but ended up reinventing a heap."
                    },
                    {
                        "username": "jkulanko",
                        "content": "You can actually have a O(N) algorithm if you utilize the fact that we can only have at most 10000 entries."
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode needs to check its difficulty level again. It should be marked as easy "
                    },
                    {
                        "username": "native_element",
                        "content": "it is little hard for guessing heap problem"
                    },
                    {
                        "username": "piocarz",
                        "content": "On the interview, they wouldn\\'t let you use modules ;) "
                    },
                    {
                        "username": "B18DCCN424",
                        "content": "depending on the language. I think so"
                    },
                    {
                        "username": "le-incroyable1-dev",
                        "content": "I guess they also include the type of data structure used, so probably they rank it medium because priority queue was used. Otherwise its really simple took 2 minutes to code."
                    },
                    {
                        "username": "Umair9912",
                        "content": "Easy at max"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "So many comments about taking the ceil ! It is clearly mentioned in the question that you have to **remove** and not just do floor(piles[i]/2) !! \\n\\nI also didn\\'t read the question thoroughly first , but when the test cases failed I saw this line - \\n\\n*Choose any piles[i] and **remove** floor(piles[i] / 2) stones from it.*"
                    },
                    {
                        "username": "VarunbhaiNurav",
                        "content": "Simple problem to understand Priority Queue."
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "PRO TIP: Read the question carefully before jumping to conclusions."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Hahaha, that\\'s correct, I was really confused as to why there\\'s a disparity between my floor function and theirs, but then I read the question correctly."
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "No need to use floor just dividing by 2 works.\n`piles[i] - piles[i]/2 == piles[i] - floor(piles[i]/2)`"
                    },
                    {
                        "username": "drdamanraaj",
                        "content": "floor division is the default behavior in most, except python in which / gives float and // does floor.\\ndescription could change to remove only complete stones or no fractions, but more people would be confused imo"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "Example 2:\\npiles = [4,3,6,7], k = 3\\n- Apply the operation on pile 2. The resulting piles are [4,3,3,7].\\n\\nShouldn\\'t this be pile 3, because 7 is the highest? with result 7 - (7/2)  = 3.5 (floor = 3) added:\\n[6, 4, 4, 3]"
                    },
                    {
                        "username": "oore95",
                        "content": "Think it was mainly a trick by them changing the order they remove the stones from to deter you from seeing that the point of the problem is take stops from the greatest pile at each time. They just changed the order they did it in and said it\\'s \"one possible scenario\" which isn\\'t false"
                    },
                    {
                        "username": "trimarknguyen",
                        "content": "You\\'ll end up removing 3 stones from either of them, so whether you remove it from pile 2 or 3 doesn\\'t matter."
                    },
                    {
                        "username": "everydayspecial",
                        "content": "I think they are just applying the operation in an arbitrary order. With 3 operations you would apply them on piles 3, 2 and 1. However, you could apply these operations in any order you would like (3-2-1, 1-2-3, 2-1-3, etc.) and still arrive at a final sum of 12."
                    }
                ]
            },
            {
                "id": 1731338,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Use Max-heap to apply operation[`pile-=Math.floor(pile/2);`](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961876/java-solution-max-heap-priority-queue-concise-code/)on the pile containing the maximum number of stones."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "The part \"perform same operation on same pile multiple times\" is important and is the hint towards the approach."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people wanting a hint on python\\'s `heapq` (built to be a **min-heap** instead of a max-heap), try thinking about how can the max number be seen as the \"min\", maybe make it negative?\\n\\nps. Don\\'t try to use heap.sort(reverse=True) or heapq.nlargest(1, heap), because I did and both exceeded the time limit!"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@chetana_23](/chetana_23) i also wanted a max heap implemenation of heap in python, and tried _max but idk didn\\'t feel right, handling min heap with negative values is okaish u get used to it\\n\\n"
                    },
                    {
                        "username": "chetana_23",
                        "content": "i tried the heapq._heapify_max() and i got time limit exceeded too. "
                    },
                    {
                        "username": "NotAestheticallyHannah",
                        "content": "bro\\nin example 2 \\napparently floor (7/2) = 4?????????\\nwell according to my maths floor (3.5) = 3\\n"
                    },
                    {
                        "username": "urmichm",
                        "content": "I confused there for a moment too, lol.  But, we *remove* floor(7/2), so\\n7 - floor(7/2) = \\n7 - floor(3.5) = \\n7 - 3 = 4 "
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "you\\'re supposed to remove floor(piles[i]/2). On removing floor(7/2) i.e. 3, 7 becomes (7-3) = 4."
                    },
                    {
                        "username": "jarrod83miller",
                        "content": "How amazing is it that the most repeated comment here is \"Read the question carefully, LOL\", and the majority of people commenting seem not to be reading the questions posted here. How about we try to answer questions respectfully and not turn this into a \"Look how great I am at leetcode\" glamour session. Let\\'s give that a try.."
                    },
                    {
                        "username": "heg816",
                        "content": "I would reccomend adding a note clarifying that the value is set to `ceil(piles[i] / 2)` since many people seem to be confused on whether the value is reduced to or reduced by `floor(piles[i] / 2)`. The description is correct; however, it is more confusing than it needs to be.\\nI think this could be fixed by adding to the end of the dotted statement, \" leaving `ceil(piles[i] / 2)`.\" and possibly defining `ceil(x)` at the end next to the `floor(x)` definition."
                    },
                    {
                        "username": "piocarz",
                        "content": "In Python there is cool property while using floor division on negative numbers:\n\n`-1//2 == -1`\n`-3//2 == -2`\n\nExactly what we need in this problem.\n...\nSo, spoiler alert, if you are using heap, you must convert them to negatives (biggest number becomes smallest number -> top of the min heap)\n\n`\nfor _ in range(k): heappush(pile,heappop(pile)//2)\n`\n\nIt makes code so much nicer.\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank for tip, but we are unable to break loop in the case of e.g., piles=[1,2,3], k=100000."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Agreed. And you can even call `heapreplace()` instead of a combining `heappush()` and `heappop()`. That\\'s shorter to write, and it can be a tiny bit more efficient."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought I would never need to use priority queue and then I saw this problem."
                    },
                    {
                        "username": "htzhang2",
                        "content": "Two possible solutions:\\n\\n1. Find largest element from piles, cut largest element in half. Overall time complexity is k*n\\n2. Use priority queue to dequeue largest element, then enqueue again. Overall time complexity is n + k*lg(n) + k*lg(n) "
                    },
                    {
                        "username": "itsankitakm",
                        "content": "Using single loop still time limit exceeded why??\\n  \\n  int minStoneSum(vector<int>& piles, int k) {\\n        int c=0;\\n        for(int i=0; i<k; i++){\\n            sort(piles.begin(), piles.end(),greater<int>());\\n            piles[0]= piles[0]- floor(piles[0]/2);\\n        }\\n        c= accumulate(piles.begin(),piles.end(),0);\\n        return c;\\n    }"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ankit Kumar Mishra](/itsankitakm)\\nI only sort one first time, O(nlog(n)), then pop() map, but it did not pass 52th test of 57. Then I try to use heap and priority queue, it works! heapify is O(log(n)). And you should consider the special case like:\\npiles[1], piles[1,2,3], etc., and k=10000,\\nPut a condition check maximum of pile is equale to 1 ? then return len(piles), no need to check the left."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Because you perform sorting in each iteration"
                    }
                ]
            },
            {
                "id": 1730928,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Use Max-heap to apply operation[`pile-=Math.floor(pile/2);`](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961876/java-solution-max-heap-priority-queue-concise-code/)on the pile containing the maximum number of stones."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "The part \"perform same operation on same pile multiple times\" is important and is the hint towards the approach."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people wanting a hint on python\\'s `heapq` (built to be a **min-heap** instead of a max-heap), try thinking about how can the max number be seen as the \"min\", maybe make it negative?\\n\\nps. Don\\'t try to use heap.sort(reverse=True) or heapq.nlargest(1, heap), because I did and both exceeded the time limit!"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@chetana_23](/chetana_23) i also wanted a max heap implemenation of heap in python, and tried _max but idk didn\\'t feel right, handling min heap with negative values is okaish u get used to it\\n\\n"
                    },
                    {
                        "username": "chetana_23",
                        "content": "i tried the heapq._heapify_max() and i got time limit exceeded too. "
                    },
                    {
                        "username": "NotAestheticallyHannah",
                        "content": "bro\\nin example 2 \\napparently floor (7/2) = 4?????????\\nwell according to my maths floor (3.5) = 3\\n"
                    },
                    {
                        "username": "urmichm",
                        "content": "I confused there for a moment too, lol.  But, we *remove* floor(7/2), so\\n7 - floor(7/2) = \\n7 - floor(3.5) = \\n7 - 3 = 4 "
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "you\\'re supposed to remove floor(piles[i]/2). On removing floor(7/2) i.e. 3, 7 becomes (7-3) = 4."
                    },
                    {
                        "username": "jarrod83miller",
                        "content": "How amazing is it that the most repeated comment here is \"Read the question carefully, LOL\", and the majority of people commenting seem not to be reading the questions posted here. How about we try to answer questions respectfully and not turn this into a \"Look how great I am at leetcode\" glamour session. Let\\'s give that a try.."
                    },
                    {
                        "username": "heg816",
                        "content": "I would reccomend adding a note clarifying that the value is set to `ceil(piles[i] / 2)` since many people seem to be confused on whether the value is reduced to or reduced by `floor(piles[i] / 2)`. The description is correct; however, it is more confusing than it needs to be.\\nI think this could be fixed by adding to the end of the dotted statement, \" leaving `ceil(piles[i] / 2)`.\" and possibly defining `ceil(x)` at the end next to the `floor(x)` definition."
                    },
                    {
                        "username": "piocarz",
                        "content": "In Python there is cool property while using floor division on negative numbers:\n\n`-1//2 == -1`\n`-3//2 == -2`\n\nExactly what we need in this problem.\n...\nSo, spoiler alert, if you are using heap, you must convert them to negatives (biggest number becomes smallest number -> top of the min heap)\n\n`\nfor _ in range(k): heappush(pile,heappop(pile)//2)\n`\n\nIt makes code so much nicer.\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank for tip, but we are unable to break loop in the case of e.g., piles=[1,2,3], k=100000."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Agreed. And you can even call `heapreplace()` instead of a combining `heappush()` and `heappop()`. That\\'s shorter to write, and it can be a tiny bit more efficient."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought I would never need to use priority queue and then I saw this problem."
                    },
                    {
                        "username": "htzhang2",
                        "content": "Two possible solutions:\\n\\n1. Find largest element from piles, cut largest element in half. Overall time complexity is k*n\\n2. Use priority queue to dequeue largest element, then enqueue again. Overall time complexity is n + k*lg(n) + k*lg(n) "
                    },
                    {
                        "username": "itsankitakm",
                        "content": "Using single loop still time limit exceeded why??\\n  \\n  int minStoneSum(vector<int>& piles, int k) {\\n        int c=0;\\n        for(int i=0; i<k; i++){\\n            sort(piles.begin(), piles.end(),greater<int>());\\n            piles[0]= piles[0]- floor(piles[0]/2);\\n        }\\n        c= accumulate(piles.begin(),piles.end(),0);\\n        return c;\\n    }"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ankit Kumar Mishra](/itsankitakm)\\nI only sort one first time, O(nlog(n)), then pop() map, but it did not pass 52th test of 57. Then I try to use heap and priority queue, it works! heapify is O(log(n)). And you should consider the special case like:\\npiles[1], piles[1,2,3], etc., and k=10000,\\nPut a condition check maximum of pile is equale to 1 ? then return len(piles), no need to check the left."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Because you perform sorting in each iteration"
                    }
                ]
            },
            {
                "id": 1730893,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Use Max-heap to apply operation[`pile-=Math.floor(pile/2);`](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961876/java-solution-max-heap-priority-queue-concise-code/)on the pile containing the maximum number of stones."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "The part \"perform same operation on same pile multiple times\" is important and is the hint towards the approach."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people wanting a hint on python\\'s `heapq` (built to be a **min-heap** instead of a max-heap), try thinking about how can the max number be seen as the \"min\", maybe make it negative?\\n\\nps. Don\\'t try to use heap.sort(reverse=True) or heapq.nlargest(1, heap), because I did and both exceeded the time limit!"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@chetana_23](/chetana_23) i also wanted a max heap implemenation of heap in python, and tried _max but idk didn\\'t feel right, handling min heap with negative values is okaish u get used to it\\n\\n"
                    },
                    {
                        "username": "chetana_23",
                        "content": "i tried the heapq._heapify_max() and i got time limit exceeded too. "
                    },
                    {
                        "username": "NotAestheticallyHannah",
                        "content": "bro\\nin example 2 \\napparently floor (7/2) = 4?????????\\nwell according to my maths floor (3.5) = 3\\n"
                    },
                    {
                        "username": "urmichm",
                        "content": "I confused there for a moment too, lol.  But, we *remove* floor(7/2), so\\n7 - floor(7/2) = \\n7 - floor(3.5) = \\n7 - 3 = 4 "
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "you\\'re supposed to remove floor(piles[i]/2). On removing floor(7/2) i.e. 3, 7 becomes (7-3) = 4."
                    },
                    {
                        "username": "jarrod83miller",
                        "content": "How amazing is it that the most repeated comment here is \"Read the question carefully, LOL\", and the majority of people commenting seem not to be reading the questions posted here. How about we try to answer questions respectfully and not turn this into a \"Look how great I am at leetcode\" glamour session. Let\\'s give that a try.."
                    },
                    {
                        "username": "heg816",
                        "content": "I would reccomend adding a note clarifying that the value is set to `ceil(piles[i] / 2)` since many people seem to be confused on whether the value is reduced to or reduced by `floor(piles[i] / 2)`. The description is correct; however, it is more confusing than it needs to be.\\nI think this could be fixed by adding to the end of the dotted statement, \" leaving `ceil(piles[i] / 2)`.\" and possibly defining `ceil(x)` at the end next to the `floor(x)` definition."
                    },
                    {
                        "username": "piocarz",
                        "content": "In Python there is cool property while using floor division on negative numbers:\n\n`-1//2 == -1`\n`-3//2 == -2`\n\nExactly what we need in this problem.\n...\nSo, spoiler alert, if you are using heap, you must convert them to negatives (biggest number becomes smallest number -> top of the min heap)\n\n`\nfor _ in range(k): heappush(pile,heappop(pile)//2)\n`\n\nIt makes code so much nicer.\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank for tip, but we are unable to break loop in the case of e.g., piles=[1,2,3], k=100000."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Agreed. And you can even call `heapreplace()` instead of a combining `heappush()` and `heappop()`. That\\'s shorter to write, and it can be a tiny bit more efficient."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought I would never need to use priority queue and then I saw this problem."
                    },
                    {
                        "username": "htzhang2",
                        "content": "Two possible solutions:\\n\\n1. Find largest element from piles, cut largest element in half. Overall time complexity is k*n\\n2. Use priority queue to dequeue largest element, then enqueue again. Overall time complexity is n + k*lg(n) + k*lg(n) "
                    },
                    {
                        "username": "itsankitakm",
                        "content": "Using single loop still time limit exceeded why??\\n  \\n  int minStoneSum(vector<int>& piles, int k) {\\n        int c=0;\\n        for(int i=0; i<k; i++){\\n            sort(piles.begin(), piles.end(),greater<int>());\\n            piles[0]= piles[0]- floor(piles[0]/2);\\n        }\\n        c= accumulate(piles.begin(),piles.end(),0);\\n        return c;\\n    }"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ankit Kumar Mishra](/itsankitakm)\\nI only sort one first time, O(nlog(n)), then pop() map, but it did not pass 52th test of 57. Then I try to use heap and priority queue, it works! heapify is O(log(n)). And you should consider the special case like:\\npiles[1], piles[1,2,3], etc., and k=10000,\\nPut a condition check maximum of pile is equale to 1 ? then return len(piles), no need to check the left."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Because you perform sorting in each iteration"
                    }
                ]
            },
            {
                "id": 1730872,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Use Max-heap to apply operation[`pile-=Math.floor(pile/2);`](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961876/java-solution-max-heap-priority-queue-concise-code/)on the pile containing the maximum number of stones."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "The part \"perform same operation on same pile multiple times\" is important and is the hint towards the approach."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people wanting a hint on python\\'s `heapq` (built to be a **min-heap** instead of a max-heap), try thinking about how can the max number be seen as the \"min\", maybe make it negative?\\n\\nps. Don\\'t try to use heap.sort(reverse=True) or heapq.nlargest(1, heap), because I did and both exceeded the time limit!"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@chetana_23](/chetana_23) i also wanted a max heap implemenation of heap in python, and tried _max but idk didn\\'t feel right, handling min heap with negative values is okaish u get used to it\\n\\n"
                    },
                    {
                        "username": "chetana_23",
                        "content": "i tried the heapq._heapify_max() and i got time limit exceeded too. "
                    },
                    {
                        "username": "NotAestheticallyHannah",
                        "content": "bro\\nin example 2 \\napparently floor (7/2) = 4?????????\\nwell according to my maths floor (3.5) = 3\\n"
                    },
                    {
                        "username": "urmichm",
                        "content": "I confused there for a moment too, lol.  But, we *remove* floor(7/2), so\\n7 - floor(7/2) = \\n7 - floor(3.5) = \\n7 - 3 = 4 "
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "you\\'re supposed to remove floor(piles[i]/2). On removing floor(7/2) i.e. 3, 7 becomes (7-3) = 4."
                    },
                    {
                        "username": "jarrod83miller",
                        "content": "How amazing is it that the most repeated comment here is \"Read the question carefully, LOL\", and the majority of people commenting seem not to be reading the questions posted here. How about we try to answer questions respectfully and not turn this into a \"Look how great I am at leetcode\" glamour session. Let\\'s give that a try.."
                    },
                    {
                        "username": "heg816",
                        "content": "I would reccomend adding a note clarifying that the value is set to `ceil(piles[i] / 2)` since many people seem to be confused on whether the value is reduced to or reduced by `floor(piles[i] / 2)`. The description is correct; however, it is more confusing than it needs to be.\\nI think this could be fixed by adding to the end of the dotted statement, \" leaving `ceil(piles[i] / 2)`.\" and possibly defining `ceil(x)` at the end next to the `floor(x)` definition."
                    },
                    {
                        "username": "piocarz",
                        "content": "In Python there is cool property while using floor division on negative numbers:\n\n`-1//2 == -1`\n`-3//2 == -2`\n\nExactly what we need in this problem.\n...\nSo, spoiler alert, if you are using heap, you must convert them to negatives (biggest number becomes smallest number -> top of the min heap)\n\n`\nfor _ in range(k): heappush(pile,heappop(pile)//2)\n`\n\nIt makes code so much nicer.\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank for tip, but we are unable to break loop in the case of e.g., piles=[1,2,3], k=100000."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Agreed. And you can even call `heapreplace()` instead of a combining `heappush()` and `heappop()`. That\\'s shorter to write, and it can be a tiny bit more efficient."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought I would never need to use priority queue and then I saw this problem."
                    },
                    {
                        "username": "htzhang2",
                        "content": "Two possible solutions:\\n\\n1. Find largest element from piles, cut largest element in half. Overall time complexity is k*n\\n2. Use priority queue to dequeue largest element, then enqueue again. Overall time complexity is n + k*lg(n) + k*lg(n) "
                    },
                    {
                        "username": "itsankitakm",
                        "content": "Using single loop still time limit exceeded why??\\n  \\n  int minStoneSum(vector<int>& piles, int k) {\\n        int c=0;\\n        for(int i=0; i<k; i++){\\n            sort(piles.begin(), piles.end(),greater<int>());\\n            piles[0]= piles[0]- floor(piles[0]/2);\\n        }\\n        c= accumulate(piles.begin(),piles.end(),0);\\n        return c;\\n    }"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ankit Kumar Mishra](/itsankitakm)\\nI only sort one first time, O(nlog(n)), then pop() map, but it did not pass 52th test of 57. Then I try to use heap and priority queue, it works! heapify is O(log(n)). And you should consider the special case like:\\npiles[1], piles[1,2,3], etc., and k=10000,\\nPut a condition check maximum of pile is equale to 1 ? then return len(piles), no need to check the left."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Because you perform sorting in each iteration"
                    }
                ]
            },
            {
                "id": 1732200,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Use Max-heap to apply operation[`pile-=Math.floor(pile/2);`](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961876/java-solution-max-heap-priority-queue-concise-code/)on the pile containing the maximum number of stones."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "The part \"perform same operation on same pile multiple times\" is important and is the hint towards the approach."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people wanting a hint on python\\'s `heapq` (built to be a **min-heap** instead of a max-heap), try thinking about how can the max number be seen as the \"min\", maybe make it negative?\\n\\nps. Don\\'t try to use heap.sort(reverse=True) or heapq.nlargest(1, heap), because I did and both exceeded the time limit!"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@chetana_23](/chetana_23) i also wanted a max heap implemenation of heap in python, and tried _max but idk didn\\'t feel right, handling min heap with negative values is okaish u get used to it\\n\\n"
                    },
                    {
                        "username": "chetana_23",
                        "content": "i tried the heapq._heapify_max() and i got time limit exceeded too. "
                    },
                    {
                        "username": "NotAestheticallyHannah",
                        "content": "bro\\nin example 2 \\napparently floor (7/2) = 4?????????\\nwell according to my maths floor (3.5) = 3\\n"
                    },
                    {
                        "username": "urmichm",
                        "content": "I confused there for a moment too, lol.  But, we *remove* floor(7/2), so\\n7 - floor(7/2) = \\n7 - floor(3.5) = \\n7 - 3 = 4 "
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "you\\'re supposed to remove floor(piles[i]/2). On removing floor(7/2) i.e. 3, 7 becomes (7-3) = 4."
                    },
                    {
                        "username": "jarrod83miller",
                        "content": "How amazing is it that the most repeated comment here is \"Read the question carefully, LOL\", and the majority of people commenting seem not to be reading the questions posted here. How about we try to answer questions respectfully and not turn this into a \"Look how great I am at leetcode\" glamour session. Let\\'s give that a try.."
                    },
                    {
                        "username": "heg816",
                        "content": "I would reccomend adding a note clarifying that the value is set to `ceil(piles[i] / 2)` since many people seem to be confused on whether the value is reduced to or reduced by `floor(piles[i] / 2)`. The description is correct; however, it is more confusing than it needs to be.\\nI think this could be fixed by adding to the end of the dotted statement, \" leaving `ceil(piles[i] / 2)`.\" and possibly defining `ceil(x)` at the end next to the `floor(x)` definition."
                    },
                    {
                        "username": "piocarz",
                        "content": "In Python there is cool property while using floor division on negative numbers:\n\n`-1//2 == -1`\n`-3//2 == -2`\n\nExactly what we need in this problem.\n...\nSo, spoiler alert, if you are using heap, you must convert them to negatives (biggest number becomes smallest number -> top of the min heap)\n\n`\nfor _ in range(k): heappush(pile,heappop(pile)//2)\n`\n\nIt makes code so much nicer.\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank for tip, but we are unable to break loop in the case of e.g., piles=[1,2,3], k=100000."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Agreed. And you can even call `heapreplace()` instead of a combining `heappush()` and `heappop()`. That\\'s shorter to write, and it can be a tiny bit more efficient."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought I would never need to use priority queue and then I saw this problem."
                    },
                    {
                        "username": "htzhang2",
                        "content": "Two possible solutions:\\n\\n1. Find largest element from piles, cut largest element in half. Overall time complexity is k*n\\n2. Use priority queue to dequeue largest element, then enqueue again. Overall time complexity is n + k*lg(n) + k*lg(n) "
                    },
                    {
                        "username": "itsankitakm",
                        "content": "Using single loop still time limit exceeded why??\\n  \\n  int minStoneSum(vector<int>& piles, int k) {\\n        int c=0;\\n        for(int i=0; i<k; i++){\\n            sort(piles.begin(), piles.end(),greater<int>());\\n            piles[0]= piles[0]- floor(piles[0]/2);\\n        }\\n        c= accumulate(piles.begin(),piles.end(),0);\\n        return c;\\n    }"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ankit Kumar Mishra](/itsankitakm)\\nI only sort one first time, O(nlog(n)), then pop() map, but it did not pass 52th test of 57. Then I try to use heap and priority queue, it works! heapify is O(log(n)). And you should consider the special case like:\\npiles[1], piles[1,2,3], etc., and k=10000,\\nPut a condition check maximum of pile is equale to 1 ? then return len(piles), no need to check the left."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Because you perform sorting in each iteration"
                    }
                ]
            },
            {
                "id": 1732143,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Use Max-heap to apply operation[`pile-=Math.floor(pile/2);`](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961876/java-solution-max-heap-priority-queue-concise-code/)on the pile containing the maximum number of stones."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "The part \"perform same operation on same pile multiple times\" is important and is the hint towards the approach."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people wanting a hint on python\\'s `heapq` (built to be a **min-heap** instead of a max-heap), try thinking about how can the max number be seen as the \"min\", maybe make it negative?\\n\\nps. Don\\'t try to use heap.sort(reverse=True) or heapq.nlargest(1, heap), because I did and both exceeded the time limit!"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@chetana_23](/chetana_23) i also wanted a max heap implemenation of heap in python, and tried _max but idk didn\\'t feel right, handling min heap with negative values is okaish u get used to it\\n\\n"
                    },
                    {
                        "username": "chetana_23",
                        "content": "i tried the heapq._heapify_max() and i got time limit exceeded too. "
                    },
                    {
                        "username": "NotAestheticallyHannah",
                        "content": "bro\\nin example 2 \\napparently floor (7/2) = 4?????????\\nwell according to my maths floor (3.5) = 3\\n"
                    },
                    {
                        "username": "urmichm",
                        "content": "I confused there for a moment too, lol.  But, we *remove* floor(7/2), so\\n7 - floor(7/2) = \\n7 - floor(3.5) = \\n7 - 3 = 4 "
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "you\\'re supposed to remove floor(piles[i]/2). On removing floor(7/2) i.e. 3, 7 becomes (7-3) = 4."
                    },
                    {
                        "username": "jarrod83miller",
                        "content": "How amazing is it that the most repeated comment here is \"Read the question carefully, LOL\", and the majority of people commenting seem not to be reading the questions posted here. How about we try to answer questions respectfully and not turn this into a \"Look how great I am at leetcode\" glamour session. Let\\'s give that a try.."
                    },
                    {
                        "username": "heg816",
                        "content": "I would reccomend adding a note clarifying that the value is set to `ceil(piles[i] / 2)` since many people seem to be confused on whether the value is reduced to or reduced by `floor(piles[i] / 2)`. The description is correct; however, it is more confusing than it needs to be.\\nI think this could be fixed by adding to the end of the dotted statement, \" leaving `ceil(piles[i] / 2)`.\" and possibly defining `ceil(x)` at the end next to the `floor(x)` definition."
                    },
                    {
                        "username": "piocarz",
                        "content": "In Python there is cool property while using floor division on negative numbers:\n\n`-1//2 == -1`\n`-3//2 == -2`\n\nExactly what we need in this problem.\n...\nSo, spoiler alert, if you are using heap, you must convert them to negatives (biggest number becomes smallest number -> top of the min heap)\n\n`\nfor _ in range(k): heappush(pile,heappop(pile)//2)\n`\n\nIt makes code so much nicer.\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank for tip, but we are unable to break loop in the case of e.g., piles=[1,2,3], k=100000."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Agreed. And you can even call `heapreplace()` instead of a combining `heappush()` and `heappop()`. That\\'s shorter to write, and it can be a tiny bit more efficient."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought I would never need to use priority queue and then I saw this problem."
                    },
                    {
                        "username": "htzhang2",
                        "content": "Two possible solutions:\\n\\n1. Find largest element from piles, cut largest element in half. Overall time complexity is k*n\\n2. Use priority queue to dequeue largest element, then enqueue again. Overall time complexity is n + k*lg(n) + k*lg(n) "
                    },
                    {
                        "username": "itsankitakm",
                        "content": "Using single loop still time limit exceeded why??\\n  \\n  int minStoneSum(vector<int>& piles, int k) {\\n        int c=0;\\n        for(int i=0; i<k; i++){\\n            sort(piles.begin(), piles.end(),greater<int>());\\n            piles[0]= piles[0]- floor(piles[0]/2);\\n        }\\n        c= accumulate(piles.begin(),piles.end(),0);\\n        return c;\\n    }"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ankit Kumar Mishra](/itsankitakm)\\nI only sort one first time, O(nlog(n)), then pop() map, but it did not pass 52th test of 57. Then I try to use heap and priority queue, it works! heapify is O(log(n)). And you should consider the special case like:\\npiles[1], piles[1,2,3], etc., and k=10000,\\nPut a condition check maximum of pile is equale to 1 ? then return len(piles), no need to check the left."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Because you perform sorting in each iteration"
                    }
                ]
            },
            {
                "id": 1731414,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Use Max-heap to apply operation[`pile-=Math.floor(pile/2);`](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961876/java-solution-max-heap-priority-queue-concise-code/)on the pile containing the maximum number of stones."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "The part \"perform same operation on same pile multiple times\" is important and is the hint towards the approach."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people wanting a hint on python\\'s `heapq` (built to be a **min-heap** instead of a max-heap), try thinking about how can the max number be seen as the \"min\", maybe make it negative?\\n\\nps. Don\\'t try to use heap.sort(reverse=True) or heapq.nlargest(1, heap), because I did and both exceeded the time limit!"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@chetana_23](/chetana_23) i also wanted a max heap implemenation of heap in python, and tried _max but idk didn\\'t feel right, handling min heap with negative values is okaish u get used to it\\n\\n"
                    },
                    {
                        "username": "chetana_23",
                        "content": "i tried the heapq._heapify_max() and i got time limit exceeded too. "
                    },
                    {
                        "username": "NotAestheticallyHannah",
                        "content": "bro\\nin example 2 \\napparently floor (7/2) = 4?????????\\nwell according to my maths floor (3.5) = 3\\n"
                    },
                    {
                        "username": "urmichm",
                        "content": "I confused there for a moment too, lol.  But, we *remove* floor(7/2), so\\n7 - floor(7/2) = \\n7 - floor(3.5) = \\n7 - 3 = 4 "
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "you\\'re supposed to remove floor(piles[i]/2). On removing floor(7/2) i.e. 3, 7 becomes (7-3) = 4."
                    },
                    {
                        "username": "jarrod83miller",
                        "content": "How amazing is it that the most repeated comment here is \"Read the question carefully, LOL\", and the majority of people commenting seem not to be reading the questions posted here. How about we try to answer questions respectfully and not turn this into a \"Look how great I am at leetcode\" glamour session. Let\\'s give that a try.."
                    },
                    {
                        "username": "heg816",
                        "content": "I would reccomend adding a note clarifying that the value is set to `ceil(piles[i] / 2)` since many people seem to be confused on whether the value is reduced to or reduced by `floor(piles[i] / 2)`. The description is correct; however, it is more confusing than it needs to be.\\nI think this could be fixed by adding to the end of the dotted statement, \" leaving `ceil(piles[i] / 2)`.\" and possibly defining `ceil(x)` at the end next to the `floor(x)` definition."
                    },
                    {
                        "username": "piocarz",
                        "content": "In Python there is cool property while using floor division on negative numbers:\n\n`-1//2 == -1`\n`-3//2 == -2`\n\nExactly what we need in this problem.\n...\nSo, spoiler alert, if you are using heap, you must convert them to negatives (biggest number becomes smallest number -> top of the min heap)\n\n`\nfor _ in range(k): heappush(pile,heappop(pile)//2)\n`\n\nIt makes code so much nicer.\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank for tip, but we are unable to break loop in the case of e.g., piles=[1,2,3], k=100000."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Agreed. And you can even call `heapreplace()` instead of a combining `heappush()` and `heappop()`. That\\'s shorter to write, and it can be a tiny bit more efficient."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought I would never need to use priority queue and then I saw this problem."
                    },
                    {
                        "username": "htzhang2",
                        "content": "Two possible solutions:\\n\\n1. Find largest element from piles, cut largest element in half. Overall time complexity is k*n\\n2. Use priority queue to dequeue largest element, then enqueue again. Overall time complexity is n + k*lg(n) + k*lg(n) "
                    },
                    {
                        "username": "itsankitakm",
                        "content": "Using single loop still time limit exceeded why??\\n  \\n  int minStoneSum(vector<int>& piles, int k) {\\n        int c=0;\\n        for(int i=0; i<k; i++){\\n            sort(piles.begin(), piles.end(),greater<int>());\\n            piles[0]= piles[0]- floor(piles[0]/2);\\n        }\\n        c= accumulate(piles.begin(),piles.end(),0);\\n        return c;\\n    }"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ankit Kumar Mishra](/itsankitakm)\\nI only sort one first time, O(nlog(n)), then pop() map, but it did not pass 52th test of 57. Then I try to use heap and priority queue, it works! heapify is O(log(n)). And you should consider the special case like:\\npiles[1], piles[1,2,3], etc., and k=10000,\\nPut a condition check maximum of pile is equale to 1 ? then return len(piles), no need to check the left."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Because you perform sorting in each iteration"
                    }
                ]
            },
            {
                "id": 1730982,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Use Max-heap to apply operation[`pile-=Math.floor(pile/2);`](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961876/java-solution-max-heap-priority-queue-concise-code/)on the pile containing the maximum number of stones."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "The part \"perform same operation on same pile multiple times\" is important and is the hint towards the approach."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people wanting a hint on python\\'s `heapq` (built to be a **min-heap** instead of a max-heap), try thinking about how can the max number be seen as the \"min\", maybe make it negative?\\n\\nps. Don\\'t try to use heap.sort(reverse=True) or heapq.nlargest(1, heap), because I did and both exceeded the time limit!"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@chetana_23](/chetana_23) i also wanted a max heap implemenation of heap in python, and tried _max but idk didn\\'t feel right, handling min heap with negative values is okaish u get used to it\\n\\n"
                    },
                    {
                        "username": "chetana_23",
                        "content": "i tried the heapq._heapify_max() and i got time limit exceeded too. "
                    },
                    {
                        "username": "NotAestheticallyHannah",
                        "content": "bro\\nin example 2 \\napparently floor (7/2) = 4?????????\\nwell according to my maths floor (3.5) = 3\\n"
                    },
                    {
                        "username": "urmichm",
                        "content": "I confused there for a moment too, lol.  But, we *remove* floor(7/2), so\\n7 - floor(7/2) = \\n7 - floor(3.5) = \\n7 - 3 = 4 "
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "you\\'re supposed to remove floor(piles[i]/2). On removing floor(7/2) i.e. 3, 7 becomes (7-3) = 4."
                    },
                    {
                        "username": "jarrod83miller",
                        "content": "How amazing is it that the most repeated comment here is \"Read the question carefully, LOL\", and the majority of people commenting seem not to be reading the questions posted here. How about we try to answer questions respectfully and not turn this into a \"Look how great I am at leetcode\" glamour session. Let\\'s give that a try.."
                    },
                    {
                        "username": "heg816",
                        "content": "I would reccomend adding a note clarifying that the value is set to `ceil(piles[i] / 2)` since many people seem to be confused on whether the value is reduced to or reduced by `floor(piles[i] / 2)`. The description is correct; however, it is more confusing than it needs to be.\\nI think this could be fixed by adding to the end of the dotted statement, \" leaving `ceil(piles[i] / 2)`.\" and possibly defining `ceil(x)` at the end next to the `floor(x)` definition."
                    },
                    {
                        "username": "piocarz",
                        "content": "In Python there is cool property while using floor division on negative numbers:\n\n`-1//2 == -1`\n`-3//2 == -2`\n\nExactly what we need in this problem.\n...\nSo, spoiler alert, if you are using heap, you must convert them to negatives (biggest number becomes smallest number -> top of the min heap)\n\n`\nfor _ in range(k): heappush(pile,heappop(pile)//2)\n`\n\nIt makes code so much nicer.\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank for tip, but we are unable to break loop in the case of e.g., piles=[1,2,3], k=100000."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Agreed. And you can even call `heapreplace()` instead of a combining `heappush()` and `heappop()`. That\\'s shorter to write, and it can be a tiny bit more efficient."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought I would never need to use priority queue and then I saw this problem."
                    },
                    {
                        "username": "htzhang2",
                        "content": "Two possible solutions:\\n\\n1. Find largest element from piles, cut largest element in half. Overall time complexity is k*n\\n2. Use priority queue to dequeue largest element, then enqueue again. Overall time complexity is n + k*lg(n) + k*lg(n) "
                    },
                    {
                        "username": "itsankitakm",
                        "content": "Using single loop still time limit exceeded why??\\n  \\n  int minStoneSum(vector<int>& piles, int k) {\\n        int c=0;\\n        for(int i=0; i<k; i++){\\n            sort(piles.begin(), piles.end(),greater<int>());\\n            piles[0]= piles[0]- floor(piles[0]/2);\\n        }\\n        c= accumulate(piles.begin(),piles.end(),0);\\n        return c;\\n    }"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ankit Kumar Mishra](/itsankitakm)\\nI only sort one first time, O(nlog(n)), then pop() map, but it did not pass 52th test of 57. Then I try to use heap and priority queue, it works! heapify is O(log(n)). And you should consider the special case like:\\npiles[1], piles[1,2,3], etc., and k=10000,\\nPut a condition check maximum of pile is equale to 1 ? then return len(piles), no need to check the left."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Because you perform sorting in each iteration"
                    }
                ]
            },
            {
                "id": 1732239,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Use Max-heap to apply operation[`pile-=Math.floor(pile/2);`](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961876/java-solution-max-heap-priority-queue-concise-code/)on the pile containing the maximum number of stones."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "The part \"perform same operation on same pile multiple times\" is important and is the hint towards the approach."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people wanting a hint on python\\'s `heapq` (built to be a **min-heap** instead of a max-heap), try thinking about how can the max number be seen as the \"min\", maybe make it negative?\\n\\nps. Don\\'t try to use heap.sort(reverse=True) or heapq.nlargest(1, heap), because I did and both exceeded the time limit!"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@chetana_23](/chetana_23) i also wanted a max heap implemenation of heap in python, and tried _max but idk didn\\'t feel right, handling min heap with negative values is okaish u get used to it\\n\\n"
                    },
                    {
                        "username": "chetana_23",
                        "content": "i tried the heapq._heapify_max() and i got time limit exceeded too. "
                    },
                    {
                        "username": "NotAestheticallyHannah",
                        "content": "bro\\nin example 2 \\napparently floor (7/2) = 4?????????\\nwell according to my maths floor (3.5) = 3\\n"
                    },
                    {
                        "username": "urmichm",
                        "content": "I confused there for a moment too, lol.  But, we *remove* floor(7/2), so\\n7 - floor(7/2) = \\n7 - floor(3.5) = \\n7 - 3 = 4 "
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "you\\'re supposed to remove floor(piles[i]/2). On removing floor(7/2) i.e. 3, 7 becomes (7-3) = 4."
                    },
                    {
                        "username": "jarrod83miller",
                        "content": "How amazing is it that the most repeated comment here is \"Read the question carefully, LOL\", and the majority of people commenting seem not to be reading the questions posted here. How about we try to answer questions respectfully and not turn this into a \"Look how great I am at leetcode\" glamour session. Let\\'s give that a try.."
                    },
                    {
                        "username": "heg816",
                        "content": "I would reccomend adding a note clarifying that the value is set to `ceil(piles[i] / 2)` since many people seem to be confused on whether the value is reduced to or reduced by `floor(piles[i] / 2)`. The description is correct; however, it is more confusing than it needs to be.\\nI think this could be fixed by adding to the end of the dotted statement, \" leaving `ceil(piles[i] / 2)`.\" and possibly defining `ceil(x)` at the end next to the `floor(x)` definition."
                    },
                    {
                        "username": "piocarz",
                        "content": "In Python there is cool property while using floor division on negative numbers:\n\n`-1//2 == -1`\n`-3//2 == -2`\n\nExactly what we need in this problem.\n...\nSo, spoiler alert, if you are using heap, you must convert them to negatives (biggest number becomes smallest number -> top of the min heap)\n\n`\nfor _ in range(k): heappush(pile,heappop(pile)//2)\n`\n\nIt makes code so much nicer.\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank for tip, but we are unable to break loop in the case of e.g., piles=[1,2,3], k=100000."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Agreed. And you can even call `heapreplace()` instead of a combining `heappush()` and `heappop()`. That\\'s shorter to write, and it can be a tiny bit more efficient."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought I would never need to use priority queue and then I saw this problem."
                    },
                    {
                        "username": "htzhang2",
                        "content": "Two possible solutions:\\n\\n1. Find largest element from piles, cut largest element in half. Overall time complexity is k*n\\n2. Use priority queue to dequeue largest element, then enqueue again. Overall time complexity is n + k*lg(n) + k*lg(n) "
                    },
                    {
                        "username": "itsankitakm",
                        "content": "Using single loop still time limit exceeded why??\\n  \\n  int minStoneSum(vector<int>& piles, int k) {\\n        int c=0;\\n        for(int i=0; i<k; i++){\\n            sort(piles.begin(), piles.end(),greater<int>());\\n            piles[0]= piles[0]- floor(piles[0]/2);\\n        }\\n        c= accumulate(piles.begin(),piles.end(),0);\\n        return c;\\n    }"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ankit Kumar Mishra](/itsankitakm)\\nI only sort one first time, O(nlog(n)), then pop() map, but it did not pass 52th test of 57. Then I try to use heap and priority queue, it works! heapify is O(log(n)). And you should consider the special case like:\\npiles[1], piles[1,2,3], etc., and k=10000,\\nPut a condition check maximum of pile is equale to 1 ? then return len(piles), no need to check the left."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Because you perform sorting in each iteration"
                    }
                ]
            },
            {
                "id": 1732101,
                "content": [
                    {
                        "username": "nishant7372",
                        "content": "Use Max-heap to apply operation[`pile-=Math.floor(pile/2);`](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961876/java-solution-max-heap-priority-queue-concise-code/)on the pile containing the maximum number of stones."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "The part \"perform same operation on same pile multiple times\" is important and is the hint towards the approach."
                    },
                    {
                        "username": "xeniawann",
                        "content": "For people wanting a hint on python\\'s `heapq` (built to be a **min-heap** instead of a max-heap), try thinking about how can the max number be seen as the \"min\", maybe make it negative?\\n\\nps. Don\\'t try to use heap.sort(reverse=True) or heapq.nlargest(1, heap), because I did and both exceeded the time limit!"
                    },
                    {
                        "username": "aditya_42",
                        "content": "[@chetana_23](/chetana_23) i also wanted a max heap implemenation of heap in python, and tried _max but idk didn\\'t feel right, handling min heap with negative values is okaish u get used to it\\n\\n"
                    },
                    {
                        "username": "chetana_23",
                        "content": "i tried the heapq._heapify_max() and i got time limit exceeded too. "
                    },
                    {
                        "username": "NotAestheticallyHannah",
                        "content": "bro\\nin example 2 \\napparently floor (7/2) = 4?????????\\nwell according to my maths floor (3.5) = 3\\n"
                    },
                    {
                        "username": "urmichm",
                        "content": "I confused there for a moment too, lol.  But, we *remove* floor(7/2), so\\n7 - floor(7/2) = \\n7 - floor(3.5) = \\n7 - 3 = 4 "
                    },
                    {
                        "username": "hawtsauce-iwnl",
                        "content": "you\\'re supposed to remove floor(piles[i]/2). On removing floor(7/2) i.e. 3, 7 becomes (7-3) = 4."
                    },
                    {
                        "username": "jarrod83miller",
                        "content": "How amazing is it that the most repeated comment here is \"Read the question carefully, LOL\", and the majority of people commenting seem not to be reading the questions posted here. How about we try to answer questions respectfully and not turn this into a \"Look how great I am at leetcode\" glamour session. Let\\'s give that a try.."
                    },
                    {
                        "username": "heg816",
                        "content": "I would reccomend adding a note clarifying that the value is set to `ceil(piles[i] / 2)` since many people seem to be confused on whether the value is reduced to or reduced by `floor(piles[i] / 2)`. The description is correct; however, it is more confusing than it needs to be.\\nI think this could be fixed by adding to the end of the dotted statement, \" leaving `ceil(piles[i] / 2)`.\" and possibly defining `ceil(x)` at the end next to the `floor(x)` definition."
                    },
                    {
                        "username": "piocarz",
                        "content": "In Python there is cool property while using floor division on negative numbers:\n\n`-1//2 == -1`\n`-3//2 == -2`\n\nExactly what we need in this problem.\n...\nSo, spoiler alert, if you are using heap, you must convert them to negatives (biggest number becomes smallest number -> top of the min heap)\n\n`\nfor _ in range(k): heappush(pile,heappop(pile)//2)\n`\n\nIt makes code so much nicer.\n"
                    },
                    {
                        "username": "Yongbi",
                        "content": "Thank for tip, but we are unable to break loop in the case of e.g., piles=[1,2,3], k=100000."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Agreed. And you can even call `heapreplace()` instead of a combining `heappush()` and `heappop()`. That\\'s shorter to write, and it can be a tiny bit more efficient."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "I thought I would never need to use priority queue and then I saw this problem."
                    },
                    {
                        "username": "htzhang2",
                        "content": "Two possible solutions:\\n\\n1. Find largest element from piles, cut largest element in half. Overall time complexity is k*n\\n2. Use priority queue to dequeue largest element, then enqueue again. Overall time complexity is n + k*lg(n) + k*lg(n) "
                    },
                    {
                        "username": "itsankitakm",
                        "content": "Using single loop still time limit exceeded why??\\n  \\n  int minStoneSum(vector<int>& piles, int k) {\\n        int c=0;\\n        for(int i=0; i<k; i++){\\n            sort(piles.begin(), piles.end(),greater<int>());\\n            piles[0]= piles[0]- floor(piles[0]/2);\\n        }\\n        c= accumulate(piles.begin(),piles.end(),0);\\n        return c;\\n    }"
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ankit Kumar Mishra](/itsankitakm)\\nI only sort one first time, O(nlog(n)), then pop() map, but it did not pass 52th test of 57. Then I try to use heap and priority queue, it works! heapify is O(log(n)). And you should consider the special case like:\\npiles[1], piles[1,2,3], etc., and k=10000,\\nPut a condition check maximum of pile is equale to 1 ? then return len(piles), no need to check the left."
                    },
                    {
                        "username": "belinskyi",
                        "content": "Because you perform sorting in each iteration"
                    }
                ]
            },
            {
                "id": 1732042,
                "content": [
                    {
                        "username": "RoeiRaz",
                        "content": "There is a mistake in the problem description. The tests show that each element is rounded up and not down after each step."
                    },
                    {
                        "username": "Ashu_rast09",
                        "content": "How can I solve my Time Exceeding warning, guys. If anyone can help me in it, it would be a great help."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ashutosh Rastogi](/Ashu_rast09) Just use the heap and priority queue, built-in module, or you can write a maximum sort function based heap-priorityqueue."
                    },
                    {
                        "username": "ganesh347",
                        "content": "What is the problrm in this code?\\n     void setZeroes(vector<vector<int>>& matrix) {\\n        if(matrix.empty()) return;\\n        int rows = matrix.size(), cols = matrix[0].size(), col0 = 1;\\n        int row[rows] =1, col[cols] =1;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                if (matrix[i][j]==0){\\n                    row[i] = col[j] = 0;\\n                }\\n            }\\n        }\\n    } "
                    },
                    {
                        "username": "Yongbi",
                        "content": "???"
                    },
                    {
                        "username": "abhisheklaptop1",
                        "content": "class Solution {\\npublic:\\n    public:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq;\\n        for(int i = 0;i < piles.size();i++){\\n            pq.push(piles[i]);\\n        }\\n        while(k > 0){\\n            int temp = pq.top();\\n            pq.pop();\\n            if(temp % 2 != 0){\\n                temp++;\\n            }\\n            temp /= 2;\\n            pq.push(temp);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "hossam0soliuman",
                        "content": "class Solution {\n\n    /**\n     * @param Integer[] $piles\n     * @param Integer $k\n     * @return Integer\n     */\n    function minStoneSum($piles, $k) {\n        $sum=0;\n        rsort($piles,0);\n        while($k--)\n        {       \n            $f=floor($piles[0]/2);       \n            $piles[0]-=$f;\n            rsort($piles);\n        }\n        foreach($piles as $p)\n        {\n            $sum+=$p;\n        }\n        return $sum;\n\n    \n    }\n}\ntime limit executed ... why!?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Repeatedly sorting the `$piles` takes too much time. You will need to find a faster approach. Take a look at the section \"Related Topics\" for an idea."
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "class Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int total_stones=accumulate(piles.begin(), piles.end(), 0);\\n        sort(piles.begin(), piles.end());\\n        int removed=0,idx=piles.size()-1;\\n        while(k--){\\n            removed=removed+(piles[idx]/2);\\n            if(piles[idx]%2==1){\\n                piles[idx]=(piles[idx]/2)+1;\\n            }\\n            else{\\n            piles[idx]=piles[idx]/2;\\n            }\\n            sort(piles.begin(), piles.end());\\n            \\n        }\\n        return total_stones-removed;\\n    }\\n};\\n\\nthe time complexity of the above code is k log(n), then why it is giving TLE"
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "[@siebenschlaefer](/siebenschlaefer) ok"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There is a `sort()` inside the `while`loop so the runtime complexity of this solution is in O(k n log n). That\\'s not fast enough. For an idea of a faster approach take a look at the section \"Related Topics\" in the description. "
                    },
                    {
                        "username": "ManvendraSingh24",
                        "content": "i think there is mistake in discription.\\nits ceil value not floor."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The description is corrent. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "soumyadeep_pradhan",
                        "content": "I have used sort function [`sort(piles.begin(),piles.end(),greater<int>());`] inside the loop and divide the biggest element in every iteration. But I am getting Time Limit Exceeded for very large input (38/59 testcases passed). should i remove sort funtion?\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "If you resort you array after each `operation` then it is a reason of `Time Limit Exceeded` as each sort takes O(nlogn) time and in case of many operations it take huge time(k * n*log(n))"
                    },
                    {
                        "username": "debashd1991",
                        "content": "Description is wrong, It should be ceil instead of floor"
                    },
                    {
                        "username": "debashd1991",
                        "content": "[@siebenschlaefer](/siebenschlaefer) I noticed it after i solved it "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "I came to the discussion because I thought it was keeping the ceiling or rounding them up only to discover that we are removing the floor(x) as others have said below. If everyone is getting confused by this then maybe its worth revising the description of this problem..."
                    },
                    {
                        "username": "yassinemejri5",
                        "content": "No revision needed. The description is correct. People should learn to read the question carefully. Even if you got confused, the examples should clarify everything."
                    }
                ]
            },
            {
                "id": 1731917,
                "content": [
                    {
                        "username": "RoeiRaz",
                        "content": "There is a mistake in the problem description. The tests show that each element is rounded up and not down after each step."
                    },
                    {
                        "username": "Ashu_rast09",
                        "content": "How can I solve my Time Exceeding warning, guys. If anyone can help me in it, it would be a great help."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ashutosh Rastogi](/Ashu_rast09) Just use the heap and priority queue, built-in module, or you can write a maximum sort function based heap-priorityqueue."
                    },
                    {
                        "username": "ganesh347",
                        "content": "What is the problrm in this code?\\n     void setZeroes(vector<vector<int>>& matrix) {\\n        if(matrix.empty()) return;\\n        int rows = matrix.size(), cols = matrix[0].size(), col0 = 1;\\n        int row[rows] =1, col[cols] =1;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                if (matrix[i][j]==0){\\n                    row[i] = col[j] = 0;\\n                }\\n            }\\n        }\\n    } "
                    },
                    {
                        "username": "Yongbi",
                        "content": "???"
                    },
                    {
                        "username": "abhisheklaptop1",
                        "content": "class Solution {\\npublic:\\n    public:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq;\\n        for(int i = 0;i < piles.size();i++){\\n            pq.push(piles[i]);\\n        }\\n        while(k > 0){\\n            int temp = pq.top();\\n            pq.pop();\\n            if(temp % 2 != 0){\\n                temp++;\\n            }\\n            temp /= 2;\\n            pq.push(temp);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "hossam0soliuman",
                        "content": "class Solution {\n\n    /**\n     * @param Integer[] $piles\n     * @param Integer $k\n     * @return Integer\n     */\n    function minStoneSum($piles, $k) {\n        $sum=0;\n        rsort($piles,0);\n        while($k--)\n        {       \n            $f=floor($piles[0]/2);       \n            $piles[0]-=$f;\n            rsort($piles);\n        }\n        foreach($piles as $p)\n        {\n            $sum+=$p;\n        }\n        return $sum;\n\n    \n    }\n}\ntime limit executed ... why!?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Repeatedly sorting the `$piles` takes too much time. You will need to find a faster approach. Take a look at the section \"Related Topics\" for an idea."
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "class Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int total_stones=accumulate(piles.begin(), piles.end(), 0);\\n        sort(piles.begin(), piles.end());\\n        int removed=0,idx=piles.size()-1;\\n        while(k--){\\n            removed=removed+(piles[idx]/2);\\n            if(piles[idx]%2==1){\\n                piles[idx]=(piles[idx]/2)+1;\\n            }\\n            else{\\n            piles[idx]=piles[idx]/2;\\n            }\\n            sort(piles.begin(), piles.end());\\n            \\n        }\\n        return total_stones-removed;\\n    }\\n};\\n\\nthe time complexity of the above code is k log(n), then why it is giving TLE"
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "[@siebenschlaefer](/siebenschlaefer) ok"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There is a `sort()` inside the `while`loop so the runtime complexity of this solution is in O(k n log n). That\\'s not fast enough. For an idea of a faster approach take a look at the section \"Related Topics\" in the description. "
                    },
                    {
                        "username": "ManvendraSingh24",
                        "content": "i think there is mistake in discription.\\nits ceil value not floor."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The description is corrent. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "soumyadeep_pradhan",
                        "content": "I have used sort function [`sort(piles.begin(),piles.end(),greater<int>());`] inside the loop and divide the biggest element in every iteration. But I am getting Time Limit Exceeded for very large input (38/59 testcases passed). should i remove sort funtion?\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "If you resort you array after each `operation` then it is a reason of `Time Limit Exceeded` as each sort takes O(nlogn) time and in case of many operations it take huge time(k * n*log(n))"
                    },
                    {
                        "username": "debashd1991",
                        "content": "Description is wrong, It should be ceil instead of floor"
                    },
                    {
                        "username": "debashd1991",
                        "content": "[@siebenschlaefer](/siebenschlaefer) I noticed it after i solved it "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "I came to the discussion because I thought it was keeping the ceiling or rounding them up only to discover that we are removing the floor(x) as others have said below. If everyone is getting confused by this then maybe its worth revising the description of this problem..."
                    },
                    {
                        "username": "yassinemejri5",
                        "content": "No revision needed. The description is correct. People should learn to read the question carefully. Even if you got confused, the examples should clarify everything."
                    }
                ]
            },
            {
                "id": 1731866,
                "content": [
                    {
                        "username": "RoeiRaz",
                        "content": "There is a mistake in the problem description. The tests show that each element is rounded up and not down after each step."
                    },
                    {
                        "username": "Ashu_rast09",
                        "content": "How can I solve my Time Exceeding warning, guys. If anyone can help me in it, it would be a great help."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ashutosh Rastogi](/Ashu_rast09) Just use the heap and priority queue, built-in module, or you can write a maximum sort function based heap-priorityqueue."
                    },
                    {
                        "username": "ganesh347",
                        "content": "What is the problrm in this code?\\n     void setZeroes(vector<vector<int>>& matrix) {\\n        if(matrix.empty()) return;\\n        int rows = matrix.size(), cols = matrix[0].size(), col0 = 1;\\n        int row[rows] =1, col[cols] =1;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                if (matrix[i][j]==0){\\n                    row[i] = col[j] = 0;\\n                }\\n            }\\n        }\\n    } "
                    },
                    {
                        "username": "Yongbi",
                        "content": "???"
                    },
                    {
                        "username": "abhisheklaptop1",
                        "content": "class Solution {\\npublic:\\n    public:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq;\\n        for(int i = 0;i < piles.size();i++){\\n            pq.push(piles[i]);\\n        }\\n        while(k > 0){\\n            int temp = pq.top();\\n            pq.pop();\\n            if(temp % 2 != 0){\\n                temp++;\\n            }\\n            temp /= 2;\\n            pq.push(temp);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "hossam0soliuman",
                        "content": "class Solution {\n\n    /**\n     * @param Integer[] $piles\n     * @param Integer $k\n     * @return Integer\n     */\n    function minStoneSum($piles, $k) {\n        $sum=0;\n        rsort($piles,0);\n        while($k--)\n        {       \n            $f=floor($piles[0]/2);       \n            $piles[0]-=$f;\n            rsort($piles);\n        }\n        foreach($piles as $p)\n        {\n            $sum+=$p;\n        }\n        return $sum;\n\n    \n    }\n}\ntime limit executed ... why!?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Repeatedly sorting the `$piles` takes too much time. You will need to find a faster approach. Take a look at the section \"Related Topics\" for an idea."
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "class Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int total_stones=accumulate(piles.begin(), piles.end(), 0);\\n        sort(piles.begin(), piles.end());\\n        int removed=0,idx=piles.size()-1;\\n        while(k--){\\n            removed=removed+(piles[idx]/2);\\n            if(piles[idx]%2==1){\\n                piles[idx]=(piles[idx]/2)+1;\\n            }\\n            else{\\n            piles[idx]=piles[idx]/2;\\n            }\\n            sort(piles.begin(), piles.end());\\n            \\n        }\\n        return total_stones-removed;\\n    }\\n};\\n\\nthe time complexity of the above code is k log(n), then why it is giving TLE"
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "[@siebenschlaefer](/siebenschlaefer) ok"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There is a `sort()` inside the `while`loop so the runtime complexity of this solution is in O(k n log n). That\\'s not fast enough. For an idea of a faster approach take a look at the section \"Related Topics\" in the description. "
                    },
                    {
                        "username": "ManvendraSingh24",
                        "content": "i think there is mistake in discription.\\nits ceil value not floor."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The description is corrent. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "soumyadeep_pradhan",
                        "content": "I have used sort function [`sort(piles.begin(),piles.end(),greater<int>());`] inside the loop and divide the biggest element in every iteration. But I am getting Time Limit Exceeded for very large input (38/59 testcases passed). should i remove sort funtion?\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "If you resort you array after each `operation` then it is a reason of `Time Limit Exceeded` as each sort takes O(nlogn) time and in case of many operations it take huge time(k * n*log(n))"
                    },
                    {
                        "username": "debashd1991",
                        "content": "Description is wrong, It should be ceil instead of floor"
                    },
                    {
                        "username": "debashd1991",
                        "content": "[@siebenschlaefer](/siebenschlaefer) I noticed it after i solved it "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "I came to the discussion because I thought it was keeping the ceiling or rounding them up only to discover that we are removing the floor(x) as others have said below. If everyone is getting confused by this then maybe its worth revising the description of this problem..."
                    },
                    {
                        "username": "yassinemejri5",
                        "content": "No revision needed. The description is correct. People should learn to read the question carefully. Even if you got confused, the examples should clarify everything."
                    }
                ]
            },
            {
                "id": 1731842,
                "content": [
                    {
                        "username": "RoeiRaz",
                        "content": "There is a mistake in the problem description. The tests show that each element is rounded up and not down after each step."
                    },
                    {
                        "username": "Ashu_rast09",
                        "content": "How can I solve my Time Exceeding warning, guys. If anyone can help me in it, it would be a great help."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ashutosh Rastogi](/Ashu_rast09) Just use the heap and priority queue, built-in module, or you can write a maximum sort function based heap-priorityqueue."
                    },
                    {
                        "username": "ganesh347",
                        "content": "What is the problrm in this code?\\n     void setZeroes(vector<vector<int>>& matrix) {\\n        if(matrix.empty()) return;\\n        int rows = matrix.size(), cols = matrix[0].size(), col0 = 1;\\n        int row[rows] =1, col[cols] =1;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                if (matrix[i][j]==0){\\n                    row[i] = col[j] = 0;\\n                }\\n            }\\n        }\\n    } "
                    },
                    {
                        "username": "Yongbi",
                        "content": "???"
                    },
                    {
                        "username": "abhisheklaptop1",
                        "content": "class Solution {\\npublic:\\n    public:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq;\\n        for(int i = 0;i < piles.size();i++){\\n            pq.push(piles[i]);\\n        }\\n        while(k > 0){\\n            int temp = pq.top();\\n            pq.pop();\\n            if(temp % 2 != 0){\\n                temp++;\\n            }\\n            temp /= 2;\\n            pq.push(temp);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "hossam0soliuman",
                        "content": "class Solution {\n\n    /**\n     * @param Integer[] $piles\n     * @param Integer $k\n     * @return Integer\n     */\n    function minStoneSum($piles, $k) {\n        $sum=0;\n        rsort($piles,0);\n        while($k--)\n        {       \n            $f=floor($piles[0]/2);       \n            $piles[0]-=$f;\n            rsort($piles);\n        }\n        foreach($piles as $p)\n        {\n            $sum+=$p;\n        }\n        return $sum;\n\n    \n    }\n}\ntime limit executed ... why!?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Repeatedly sorting the `$piles` takes too much time. You will need to find a faster approach. Take a look at the section \"Related Topics\" for an idea."
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "class Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int total_stones=accumulate(piles.begin(), piles.end(), 0);\\n        sort(piles.begin(), piles.end());\\n        int removed=0,idx=piles.size()-1;\\n        while(k--){\\n            removed=removed+(piles[idx]/2);\\n            if(piles[idx]%2==1){\\n                piles[idx]=(piles[idx]/2)+1;\\n            }\\n            else{\\n            piles[idx]=piles[idx]/2;\\n            }\\n            sort(piles.begin(), piles.end());\\n            \\n        }\\n        return total_stones-removed;\\n    }\\n};\\n\\nthe time complexity of the above code is k log(n), then why it is giving TLE"
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "[@siebenschlaefer](/siebenschlaefer) ok"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There is a `sort()` inside the `while`loop so the runtime complexity of this solution is in O(k n log n). That\\'s not fast enough. For an idea of a faster approach take a look at the section \"Related Topics\" in the description. "
                    },
                    {
                        "username": "ManvendraSingh24",
                        "content": "i think there is mistake in discription.\\nits ceil value not floor."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The description is corrent. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "soumyadeep_pradhan",
                        "content": "I have used sort function [`sort(piles.begin(),piles.end(),greater<int>());`] inside the loop and divide the biggest element in every iteration. But I am getting Time Limit Exceeded for very large input (38/59 testcases passed). should i remove sort funtion?\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "If you resort you array after each `operation` then it is a reason of `Time Limit Exceeded` as each sort takes O(nlogn) time and in case of many operations it take huge time(k * n*log(n))"
                    },
                    {
                        "username": "debashd1991",
                        "content": "Description is wrong, It should be ceil instead of floor"
                    },
                    {
                        "username": "debashd1991",
                        "content": "[@siebenschlaefer](/siebenschlaefer) I noticed it after i solved it "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "I came to the discussion because I thought it was keeping the ceiling or rounding them up only to discover that we are removing the floor(x) as others have said below. If everyone is getting confused by this then maybe its worth revising the description of this problem..."
                    },
                    {
                        "username": "yassinemejri5",
                        "content": "No revision needed. The description is correct. People should learn to read the question carefully. Even if you got confused, the examples should clarify everything."
                    }
                ]
            },
            {
                "id": 1731808,
                "content": [
                    {
                        "username": "RoeiRaz",
                        "content": "There is a mistake in the problem description. The tests show that each element is rounded up and not down after each step."
                    },
                    {
                        "username": "Ashu_rast09",
                        "content": "How can I solve my Time Exceeding warning, guys. If anyone can help me in it, it would be a great help."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ashutosh Rastogi](/Ashu_rast09) Just use the heap and priority queue, built-in module, or you can write a maximum sort function based heap-priorityqueue."
                    },
                    {
                        "username": "ganesh347",
                        "content": "What is the problrm in this code?\\n     void setZeroes(vector<vector<int>>& matrix) {\\n        if(matrix.empty()) return;\\n        int rows = matrix.size(), cols = matrix[0].size(), col0 = 1;\\n        int row[rows] =1, col[cols] =1;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                if (matrix[i][j]==0){\\n                    row[i] = col[j] = 0;\\n                }\\n            }\\n        }\\n    } "
                    },
                    {
                        "username": "Yongbi",
                        "content": "???"
                    },
                    {
                        "username": "abhisheklaptop1",
                        "content": "class Solution {\\npublic:\\n    public:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq;\\n        for(int i = 0;i < piles.size();i++){\\n            pq.push(piles[i]);\\n        }\\n        while(k > 0){\\n            int temp = pq.top();\\n            pq.pop();\\n            if(temp % 2 != 0){\\n                temp++;\\n            }\\n            temp /= 2;\\n            pq.push(temp);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "hossam0soliuman",
                        "content": "class Solution {\n\n    /**\n     * @param Integer[] $piles\n     * @param Integer $k\n     * @return Integer\n     */\n    function minStoneSum($piles, $k) {\n        $sum=0;\n        rsort($piles,0);\n        while($k--)\n        {       \n            $f=floor($piles[0]/2);       \n            $piles[0]-=$f;\n            rsort($piles);\n        }\n        foreach($piles as $p)\n        {\n            $sum+=$p;\n        }\n        return $sum;\n\n    \n    }\n}\ntime limit executed ... why!?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Repeatedly sorting the `$piles` takes too much time. You will need to find a faster approach. Take a look at the section \"Related Topics\" for an idea."
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "class Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int total_stones=accumulate(piles.begin(), piles.end(), 0);\\n        sort(piles.begin(), piles.end());\\n        int removed=0,idx=piles.size()-1;\\n        while(k--){\\n            removed=removed+(piles[idx]/2);\\n            if(piles[idx]%2==1){\\n                piles[idx]=(piles[idx]/2)+1;\\n            }\\n            else{\\n            piles[idx]=piles[idx]/2;\\n            }\\n            sort(piles.begin(), piles.end());\\n            \\n        }\\n        return total_stones-removed;\\n    }\\n};\\n\\nthe time complexity of the above code is k log(n), then why it is giving TLE"
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "[@siebenschlaefer](/siebenschlaefer) ok"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There is a `sort()` inside the `while`loop so the runtime complexity of this solution is in O(k n log n). That\\'s not fast enough. For an idea of a faster approach take a look at the section \"Related Topics\" in the description. "
                    },
                    {
                        "username": "ManvendraSingh24",
                        "content": "i think there is mistake in discription.\\nits ceil value not floor."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The description is corrent. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "soumyadeep_pradhan",
                        "content": "I have used sort function [`sort(piles.begin(),piles.end(),greater<int>());`] inside the loop and divide the biggest element in every iteration. But I am getting Time Limit Exceeded for very large input (38/59 testcases passed). should i remove sort funtion?\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "If you resort you array after each `operation` then it is a reason of `Time Limit Exceeded` as each sort takes O(nlogn) time and in case of many operations it take huge time(k * n*log(n))"
                    },
                    {
                        "username": "debashd1991",
                        "content": "Description is wrong, It should be ceil instead of floor"
                    },
                    {
                        "username": "debashd1991",
                        "content": "[@siebenschlaefer](/siebenschlaefer) I noticed it after i solved it "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "I came to the discussion because I thought it was keeping the ceiling or rounding them up only to discover that we are removing the floor(x) as others have said below. If everyone is getting confused by this then maybe its worth revising the description of this problem..."
                    },
                    {
                        "username": "yassinemejri5",
                        "content": "No revision needed. The description is correct. People should learn to read the question carefully. Even if you got confused, the examples should clarify everything."
                    }
                ]
            },
            {
                "id": 1731783,
                "content": [
                    {
                        "username": "RoeiRaz",
                        "content": "There is a mistake in the problem description. The tests show that each element is rounded up and not down after each step."
                    },
                    {
                        "username": "Ashu_rast09",
                        "content": "How can I solve my Time Exceeding warning, guys. If anyone can help me in it, it would be a great help."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ashutosh Rastogi](/Ashu_rast09) Just use the heap and priority queue, built-in module, or you can write a maximum sort function based heap-priorityqueue."
                    },
                    {
                        "username": "ganesh347",
                        "content": "What is the problrm in this code?\\n     void setZeroes(vector<vector<int>>& matrix) {\\n        if(matrix.empty()) return;\\n        int rows = matrix.size(), cols = matrix[0].size(), col0 = 1;\\n        int row[rows] =1, col[cols] =1;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                if (matrix[i][j]==0){\\n                    row[i] = col[j] = 0;\\n                }\\n            }\\n        }\\n    } "
                    },
                    {
                        "username": "Yongbi",
                        "content": "???"
                    },
                    {
                        "username": "abhisheklaptop1",
                        "content": "class Solution {\\npublic:\\n    public:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq;\\n        for(int i = 0;i < piles.size();i++){\\n            pq.push(piles[i]);\\n        }\\n        while(k > 0){\\n            int temp = pq.top();\\n            pq.pop();\\n            if(temp % 2 != 0){\\n                temp++;\\n            }\\n            temp /= 2;\\n            pq.push(temp);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "hossam0soliuman",
                        "content": "class Solution {\n\n    /**\n     * @param Integer[] $piles\n     * @param Integer $k\n     * @return Integer\n     */\n    function minStoneSum($piles, $k) {\n        $sum=0;\n        rsort($piles,0);\n        while($k--)\n        {       \n            $f=floor($piles[0]/2);       \n            $piles[0]-=$f;\n            rsort($piles);\n        }\n        foreach($piles as $p)\n        {\n            $sum+=$p;\n        }\n        return $sum;\n\n    \n    }\n}\ntime limit executed ... why!?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Repeatedly sorting the `$piles` takes too much time. You will need to find a faster approach. Take a look at the section \"Related Topics\" for an idea."
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "class Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int total_stones=accumulate(piles.begin(), piles.end(), 0);\\n        sort(piles.begin(), piles.end());\\n        int removed=0,idx=piles.size()-1;\\n        while(k--){\\n            removed=removed+(piles[idx]/2);\\n            if(piles[idx]%2==1){\\n                piles[idx]=(piles[idx]/2)+1;\\n            }\\n            else{\\n            piles[idx]=piles[idx]/2;\\n            }\\n            sort(piles.begin(), piles.end());\\n            \\n        }\\n        return total_stones-removed;\\n    }\\n};\\n\\nthe time complexity of the above code is k log(n), then why it is giving TLE"
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "[@siebenschlaefer](/siebenschlaefer) ok"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There is a `sort()` inside the `while`loop so the runtime complexity of this solution is in O(k n log n). That\\'s not fast enough. For an idea of a faster approach take a look at the section \"Related Topics\" in the description. "
                    },
                    {
                        "username": "ManvendraSingh24",
                        "content": "i think there is mistake in discription.\\nits ceil value not floor."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The description is corrent. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "soumyadeep_pradhan",
                        "content": "I have used sort function [`sort(piles.begin(),piles.end(),greater<int>());`] inside the loop and divide the biggest element in every iteration. But I am getting Time Limit Exceeded for very large input (38/59 testcases passed). should i remove sort funtion?\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "If you resort you array after each `operation` then it is a reason of `Time Limit Exceeded` as each sort takes O(nlogn) time and in case of many operations it take huge time(k * n*log(n))"
                    },
                    {
                        "username": "debashd1991",
                        "content": "Description is wrong, It should be ceil instead of floor"
                    },
                    {
                        "username": "debashd1991",
                        "content": "[@siebenschlaefer](/siebenschlaefer) I noticed it after i solved it "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "I came to the discussion because I thought it was keeping the ceiling or rounding them up only to discover that we are removing the floor(x) as others have said below. If everyone is getting confused by this then maybe its worth revising the description of this problem..."
                    },
                    {
                        "username": "yassinemejri5",
                        "content": "No revision needed. The description is correct. People should learn to read the question carefully. Even if you got confused, the examples should clarify everything."
                    }
                ]
            },
            {
                "id": 1731685,
                "content": [
                    {
                        "username": "RoeiRaz",
                        "content": "There is a mistake in the problem description. The tests show that each element is rounded up and not down after each step."
                    },
                    {
                        "username": "Ashu_rast09",
                        "content": "How can I solve my Time Exceeding warning, guys. If anyone can help me in it, it would be a great help."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ashutosh Rastogi](/Ashu_rast09) Just use the heap and priority queue, built-in module, or you can write a maximum sort function based heap-priorityqueue."
                    },
                    {
                        "username": "ganesh347",
                        "content": "What is the problrm in this code?\\n     void setZeroes(vector<vector<int>>& matrix) {\\n        if(matrix.empty()) return;\\n        int rows = matrix.size(), cols = matrix[0].size(), col0 = 1;\\n        int row[rows] =1, col[cols] =1;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                if (matrix[i][j]==0){\\n                    row[i] = col[j] = 0;\\n                }\\n            }\\n        }\\n    } "
                    },
                    {
                        "username": "Yongbi",
                        "content": "???"
                    },
                    {
                        "username": "abhisheklaptop1",
                        "content": "class Solution {\\npublic:\\n    public:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq;\\n        for(int i = 0;i < piles.size();i++){\\n            pq.push(piles[i]);\\n        }\\n        while(k > 0){\\n            int temp = pq.top();\\n            pq.pop();\\n            if(temp % 2 != 0){\\n                temp++;\\n            }\\n            temp /= 2;\\n            pq.push(temp);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "hossam0soliuman",
                        "content": "class Solution {\n\n    /**\n     * @param Integer[] $piles\n     * @param Integer $k\n     * @return Integer\n     */\n    function minStoneSum($piles, $k) {\n        $sum=0;\n        rsort($piles,0);\n        while($k--)\n        {       \n            $f=floor($piles[0]/2);       \n            $piles[0]-=$f;\n            rsort($piles);\n        }\n        foreach($piles as $p)\n        {\n            $sum+=$p;\n        }\n        return $sum;\n\n    \n    }\n}\ntime limit executed ... why!?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Repeatedly sorting the `$piles` takes too much time. You will need to find a faster approach. Take a look at the section \"Related Topics\" for an idea."
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "class Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int total_stones=accumulate(piles.begin(), piles.end(), 0);\\n        sort(piles.begin(), piles.end());\\n        int removed=0,idx=piles.size()-1;\\n        while(k--){\\n            removed=removed+(piles[idx]/2);\\n            if(piles[idx]%2==1){\\n                piles[idx]=(piles[idx]/2)+1;\\n            }\\n            else{\\n            piles[idx]=piles[idx]/2;\\n            }\\n            sort(piles.begin(), piles.end());\\n            \\n        }\\n        return total_stones-removed;\\n    }\\n};\\n\\nthe time complexity of the above code is k log(n), then why it is giving TLE"
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "[@siebenschlaefer](/siebenschlaefer) ok"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There is a `sort()` inside the `while`loop so the runtime complexity of this solution is in O(k n log n). That\\'s not fast enough. For an idea of a faster approach take a look at the section \"Related Topics\" in the description. "
                    },
                    {
                        "username": "ManvendraSingh24",
                        "content": "i think there is mistake in discription.\\nits ceil value not floor."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The description is corrent. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "soumyadeep_pradhan",
                        "content": "I have used sort function [`sort(piles.begin(),piles.end(),greater<int>());`] inside the loop and divide the biggest element in every iteration. But I am getting Time Limit Exceeded for very large input (38/59 testcases passed). should i remove sort funtion?\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "If you resort you array after each `operation` then it is a reason of `Time Limit Exceeded` as each sort takes O(nlogn) time and in case of many operations it take huge time(k * n*log(n))"
                    },
                    {
                        "username": "debashd1991",
                        "content": "Description is wrong, It should be ceil instead of floor"
                    },
                    {
                        "username": "debashd1991",
                        "content": "[@siebenschlaefer](/siebenschlaefer) I noticed it after i solved it "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "I came to the discussion because I thought it was keeping the ceiling or rounding them up only to discover that we are removing the floor(x) as others have said below. If everyone is getting confused by this then maybe its worth revising the description of this problem..."
                    },
                    {
                        "username": "yassinemejri5",
                        "content": "No revision needed. The description is correct. People should learn to read the question carefully. Even if you got confused, the examples should clarify everything."
                    }
                ]
            },
            {
                "id": 1731653,
                "content": [
                    {
                        "username": "RoeiRaz",
                        "content": "There is a mistake in the problem description. The tests show that each element is rounded up and not down after each step."
                    },
                    {
                        "username": "Ashu_rast09",
                        "content": "How can I solve my Time Exceeding warning, guys. If anyone can help me in it, it would be a great help."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ashutosh Rastogi](/Ashu_rast09) Just use the heap and priority queue, built-in module, or you can write a maximum sort function based heap-priorityqueue."
                    },
                    {
                        "username": "ganesh347",
                        "content": "What is the problrm in this code?\\n     void setZeroes(vector<vector<int>>& matrix) {\\n        if(matrix.empty()) return;\\n        int rows = matrix.size(), cols = matrix[0].size(), col0 = 1;\\n        int row[rows] =1, col[cols] =1;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                if (matrix[i][j]==0){\\n                    row[i] = col[j] = 0;\\n                }\\n            }\\n        }\\n    } "
                    },
                    {
                        "username": "Yongbi",
                        "content": "???"
                    },
                    {
                        "username": "abhisheklaptop1",
                        "content": "class Solution {\\npublic:\\n    public:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq;\\n        for(int i = 0;i < piles.size();i++){\\n            pq.push(piles[i]);\\n        }\\n        while(k > 0){\\n            int temp = pq.top();\\n            pq.pop();\\n            if(temp % 2 != 0){\\n                temp++;\\n            }\\n            temp /= 2;\\n            pq.push(temp);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "hossam0soliuman",
                        "content": "class Solution {\n\n    /**\n     * @param Integer[] $piles\n     * @param Integer $k\n     * @return Integer\n     */\n    function minStoneSum($piles, $k) {\n        $sum=0;\n        rsort($piles,0);\n        while($k--)\n        {       \n            $f=floor($piles[0]/2);       \n            $piles[0]-=$f;\n            rsort($piles);\n        }\n        foreach($piles as $p)\n        {\n            $sum+=$p;\n        }\n        return $sum;\n\n    \n    }\n}\ntime limit executed ... why!?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Repeatedly sorting the `$piles` takes too much time. You will need to find a faster approach. Take a look at the section \"Related Topics\" for an idea."
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "class Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int total_stones=accumulate(piles.begin(), piles.end(), 0);\\n        sort(piles.begin(), piles.end());\\n        int removed=0,idx=piles.size()-1;\\n        while(k--){\\n            removed=removed+(piles[idx]/2);\\n            if(piles[idx]%2==1){\\n                piles[idx]=(piles[idx]/2)+1;\\n            }\\n            else{\\n            piles[idx]=piles[idx]/2;\\n            }\\n            sort(piles.begin(), piles.end());\\n            \\n        }\\n        return total_stones-removed;\\n    }\\n};\\n\\nthe time complexity of the above code is k log(n), then why it is giving TLE"
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "[@siebenschlaefer](/siebenschlaefer) ok"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There is a `sort()` inside the `while`loop so the runtime complexity of this solution is in O(k n log n). That\\'s not fast enough. For an idea of a faster approach take a look at the section \"Related Topics\" in the description. "
                    },
                    {
                        "username": "ManvendraSingh24",
                        "content": "i think there is mistake in discription.\\nits ceil value not floor."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The description is corrent. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "soumyadeep_pradhan",
                        "content": "I have used sort function [`sort(piles.begin(),piles.end(),greater<int>());`] inside the loop and divide the biggest element in every iteration. But I am getting Time Limit Exceeded for very large input (38/59 testcases passed). should i remove sort funtion?\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "If you resort you array after each `operation` then it is a reason of `Time Limit Exceeded` as each sort takes O(nlogn) time and in case of many operations it take huge time(k * n*log(n))"
                    },
                    {
                        "username": "debashd1991",
                        "content": "Description is wrong, It should be ceil instead of floor"
                    },
                    {
                        "username": "debashd1991",
                        "content": "[@siebenschlaefer](/siebenschlaefer) I noticed it after i solved it "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "I came to the discussion because I thought it was keeping the ceiling or rounding them up only to discover that we are removing the floor(x) as others have said below. If everyone is getting confused by this then maybe its worth revising the description of this problem..."
                    },
                    {
                        "username": "yassinemejri5",
                        "content": "No revision needed. The description is correct. People should learn to read the question carefully. Even if you got confused, the examples should clarify everything."
                    }
                ]
            },
            {
                "id": 1731559,
                "content": [
                    {
                        "username": "RoeiRaz",
                        "content": "There is a mistake in the problem description. The tests show that each element is rounded up and not down after each step."
                    },
                    {
                        "username": "Ashu_rast09",
                        "content": "How can I solve my Time Exceeding warning, guys. If anyone can help me in it, it would be a great help."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ashutosh Rastogi](/Ashu_rast09) Just use the heap and priority queue, built-in module, or you can write a maximum sort function based heap-priorityqueue."
                    },
                    {
                        "username": "ganesh347",
                        "content": "What is the problrm in this code?\\n     void setZeroes(vector<vector<int>>& matrix) {\\n        if(matrix.empty()) return;\\n        int rows = matrix.size(), cols = matrix[0].size(), col0 = 1;\\n        int row[rows] =1, col[cols] =1;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                if (matrix[i][j]==0){\\n                    row[i] = col[j] = 0;\\n                }\\n            }\\n        }\\n    } "
                    },
                    {
                        "username": "Yongbi",
                        "content": "???"
                    },
                    {
                        "username": "abhisheklaptop1",
                        "content": "class Solution {\\npublic:\\n    public:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq;\\n        for(int i = 0;i < piles.size();i++){\\n            pq.push(piles[i]);\\n        }\\n        while(k > 0){\\n            int temp = pq.top();\\n            pq.pop();\\n            if(temp % 2 != 0){\\n                temp++;\\n            }\\n            temp /= 2;\\n            pq.push(temp);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "hossam0soliuman",
                        "content": "class Solution {\n\n    /**\n     * @param Integer[] $piles\n     * @param Integer $k\n     * @return Integer\n     */\n    function minStoneSum($piles, $k) {\n        $sum=0;\n        rsort($piles,0);\n        while($k--)\n        {       \n            $f=floor($piles[0]/2);       \n            $piles[0]-=$f;\n            rsort($piles);\n        }\n        foreach($piles as $p)\n        {\n            $sum+=$p;\n        }\n        return $sum;\n\n    \n    }\n}\ntime limit executed ... why!?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Repeatedly sorting the `$piles` takes too much time. You will need to find a faster approach. Take a look at the section \"Related Topics\" for an idea."
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "class Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int total_stones=accumulate(piles.begin(), piles.end(), 0);\\n        sort(piles.begin(), piles.end());\\n        int removed=0,idx=piles.size()-1;\\n        while(k--){\\n            removed=removed+(piles[idx]/2);\\n            if(piles[idx]%2==1){\\n                piles[idx]=(piles[idx]/2)+1;\\n            }\\n            else{\\n            piles[idx]=piles[idx]/2;\\n            }\\n            sort(piles.begin(), piles.end());\\n            \\n        }\\n        return total_stones-removed;\\n    }\\n};\\n\\nthe time complexity of the above code is k log(n), then why it is giving TLE"
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "[@siebenschlaefer](/siebenschlaefer) ok"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There is a `sort()` inside the `while`loop so the runtime complexity of this solution is in O(k n log n). That\\'s not fast enough. For an idea of a faster approach take a look at the section \"Related Topics\" in the description. "
                    },
                    {
                        "username": "ManvendraSingh24",
                        "content": "i think there is mistake in discription.\\nits ceil value not floor."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The description is corrent. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "soumyadeep_pradhan",
                        "content": "I have used sort function [`sort(piles.begin(),piles.end(),greater<int>());`] inside the loop and divide the biggest element in every iteration. But I am getting Time Limit Exceeded for very large input (38/59 testcases passed). should i remove sort funtion?\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "If you resort you array after each `operation` then it is a reason of `Time Limit Exceeded` as each sort takes O(nlogn) time and in case of many operations it take huge time(k * n*log(n))"
                    },
                    {
                        "username": "debashd1991",
                        "content": "Description is wrong, It should be ceil instead of floor"
                    },
                    {
                        "username": "debashd1991",
                        "content": "[@siebenschlaefer](/siebenschlaefer) I noticed it after i solved it "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "I came to the discussion because I thought it was keeping the ceiling or rounding them up only to discover that we are removing the floor(x) as others have said below. If everyone is getting confused by this then maybe its worth revising the description of this problem..."
                    },
                    {
                        "username": "yassinemejri5",
                        "content": "No revision needed. The description is correct. People should learn to read the question carefully. Even if you got confused, the examples should clarify everything."
                    }
                ]
            },
            {
                "id": 1731480,
                "content": [
                    {
                        "username": "RoeiRaz",
                        "content": "There is a mistake in the problem description. The tests show that each element is rounded up and not down after each step."
                    },
                    {
                        "username": "Ashu_rast09",
                        "content": "How can I solve my Time Exceeding warning, guys. If anyone can help me in it, it would be a great help."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@Ashutosh Rastogi](/Ashu_rast09) Just use the heap and priority queue, built-in module, or you can write a maximum sort function based heap-priorityqueue."
                    },
                    {
                        "username": "ganesh347",
                        "content": "What is the problrm in this code?\\n     void setZeroes(vector<vector<int>>& matrix) {\\n        if(matrix.empty()) return;\\n        int rows = matrix.size(), cols = matrix[0].size(), col0 = 1;\\n        int row[rows] =1, col[cols] =1;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 1; j < n; j++){\\n                if (matrix[i][j]==0){\\n                    row[i] = col[j] = 0;\\n                }\\n            }\\n        }\\n    } "
                    },
                    {
                        "username": "Yongbi",
                        "content": "???"
                    },
                    {
                        "username": "abhisheklaptop1",
                        "content": "class Solution {\\npublic:\\n    public:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        priority_queue<int>pq;\\n        for(int i = 0;i < piles.size();i++){\\n            pq.push(piles[i]);\\n        }\\n        while(k > 0){\\n            int temp = pq.top();\\n            pq.pop();\\n            if(temp % 2 != 0){\\n                temp++;\\n            }\\n            temp /= 2;\\n            pq.push(temp);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};"
                    },
                    {
                        "username": "hossam0soliuman",
                        "content": "class Solution {\n\n    /**\n     * @param Integer[] $piles\n     * @param Integer $k\n     * @return Integer\n     */\n    function minStoneSum($piles, $k) {\n        $sum=0;\n        rsort($piles,0);\n        while($k--)\n        {       \n            $f=floor($piles[0]/2);       \n            $piles[0]-=$f;\n            rsort($piles);\n        }\n        foreach($piles as $p)\n        {\n            $sum+=$p;\n        }\n        return $sum;\n\n    \n    }\n}\ntime limit executed ... why!?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Repeatedly sorting the `$piles` takes too much time. You will need to find a faster approach. Take a look at the section \"Related Topics\" for an idea."
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "class Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        int total_stones=accumulate(piles.begin(), piles.end(), 0);\\n        sort(piles.begin(), piles.end());\\n        int removed=0,idx=piles.size()-1;\\n        while(k--){\\n            removed=removed+(piles[idx]/2);\\n            if(piles[idx]%2==1){\\n                piles[idx]=(piles[idx]/2)+1;\\n            }\\n            else{\\n            piles[idx]=piles[idx]/2;\\n            }\\n            sort(piles.begin(), piles.end());\\n            \\n        }\\n        return total_stones-removed;\\n    }\\n};\\n\\nthe time complexity of the above code is k log(n), then why it is giving TLE"
                    },
                    {
                        "username": "thisisgaurav",
                        "content": "[@siebenschlaefer](/siebenschlaefer) ok"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "There is a `sort()` inside the `while`loop so the runtime complexity of this solution is in O(k n log n). That\\'s not fast enough. For an idea of a faster approach take a look at the section \"Related Topics\" in the description. "
                    },
                    {
                        "username": "ManvendraSingh24",
                        "content": "i think there is mistake in discription.\\nits ceil value not floor."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The description is corrent. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "soumyadeep_pradhan",
                        "content": "I have used sort function [`sort(piles.begin(),piles.end(),greater<int>());`] inside the loop and divide the biggest element in every iteration. But I am getting Time Limit Exceeded for very large input (38/59 testcases passed). should i remove sort funtion?\n"
                    },
                    {
                        "username": "belinskyi",
                        "content": "If you resort you array after each `operation` then it is a reason of `Time Limit Exceeded` as each sort takes O(nlogn) time and in case of many operations it take huge time(k * n*log(n))"
                    },
                    {
                        "username": "debashd1991",
                        "content": "Description is wrong, It should be ceil instead of floor"
                    },
                    {
                        "username": "debashd1991",
                        "content": "[@siebenschlaefer](/siebenschlaefer) I noticed it after i solved it "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We have to *remove* the floor, not keep it."
                    },
                    {
                        "username": "austinsparky1",
                        "content": "I came to the discussion because I thought it was keeping the ceiling or rounding them up only to discover that we are removing the floor(x) as others have said below. If everyone is getting confused by this then maybe its worth revising the description of this problem..."
                    },
                    {
                        "username": "yassinemejri5",
                        "content": "No revision needed. The description is correct. People should learn to read the question carefully. Even if you got confused, the examples should clarify everything."
                    }
                ]
            },
            {
                "id": 1731455,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "Heapq module in Python.\nSharing youtube short video on Heap queue algorithm in Python\nhttps://www.youtube.com/watch?v=58cYFs_W2_s&ab_channel=Amulya%27sAcademy\n"
                    },
                    {
                        "username": "SouravKr_1908",
                        "content": "Can anyone help me to optimize this solution, as I have passed 45/59 test cases it is saying time limit exceed. And I don't want to use heap concept. \n\nclass Solution(object):\n    def minStoneSum(self, piles, k):\n        \"\"\"\n        :type piles: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        for _ in range(k):\n            x=max(piles)\n            i=piles.index(x)\n            piles[i]=piles[i]-int(floor(piles[i]/2))\n\n        return sum(piles)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Calling `max(piles)` repeatedly takes too much time.  \\nWhy don\\'t you want to use a heap/priority queue? Sure, you could try to find alternative approaches like implementing a balanced binary search tree where you repeatedly remove the max element and insert a new one with the reduced size but that will be much more complicated.  \\nThis is one of the problems with only one simple and efficient solution, and that solution involves a heap/priority queue. Don\\'t fight it, embrace it!"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s definitely an easy task, not medium."
                    },
                    {
                        "username": "the_dark_knight_rises",
                        "content": "Is the floor definition correct here? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. The definition itself is correct and also how it should be applied in this problem. Remember: We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Somedays Medium is hard , and other day it\\'s easy. "
                    },
                    {
                        "username": "sameer0013",
                        "content": "There is a mistake in question it\\'s CEIL not FLOOR"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Below code is also run for all testcase which is provided by leetcode and successfully submitted.\nbut for this test case\npiles = [1,2,9,76]  and k =2 , it is failed.\nkindly add this testcase .\n\ncode-\nclass Solution {\n    public int minStoneSum(int[] piles, int k) { \n        int n = piles.length;\n        while (k > 0) {\n            Arrays.sort(piles);\n            for (int i=n-1; i>=n/2; i--) {\n                int remove = (int)Math.floor(piles[i]/2);\n                piles[i] -= remove;\n                k--;\n                if (k == 0) \n                break;\n            }\n        }\n        int ans = 0;\n        for (int w :piles) \n        ans += w;\n        return ans;\n    }\n}\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The inner `for` loop reduces the size of *all* piles in the range `[n - 1, n / 2]`, but it should reduce the size of the greatest pile each time.  \\nIn your example it should reduce `76` to `38`, and then `38`  to `19`."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "Should be marked as an Easy question"
                    },
                    {
                        "username": "himanshupat95",
                        "content": "Description is incorrect. Operation is : \\n ```ceil (piles[i] / 2)```"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "that\\'s not floor(piles[i] / 2), \\nbased on the result, it should be ceil()\\nPlease update the problems carefully. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We\\'re *removing* the floor."
                    }
                ]
            },
            {
                "id": 1731424,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "Heapq module in Python.\nSharing youtube short video on Heap queue algorithm in Python\nhttps://www.youtube.com/watch?v=58cYFs_W2_s&ab_channel=Amulya%27sAcademy\n"
                    },
                    {
                        "username": "SouravKr_1908",
                        "content": "Can anyone help me to optimize this solution, as I have passed 45/59 test cases it is saying time limit exceed. And I don't want to use heap concept. \n\nclass Solution(object):\n    def minStoneSum(self, piles, k):\n        \"\"\"\n        :type piles: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        for _ in range(k):\n            x=max(piles)\n            i=piles.index(x)\n            piles[i]=piles[i]-int(floor(piles[i]/2))\n\n        return sum(piles)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Calling `max(piles)` repeatedly takes too much time.  \\nWhy don\\'t you want to use a heap/priority queue? Sure, you could try to find alternative approaches like implementing a balanced binary search tree where you repeatedly remove the max element and insert a new one with the reduced size but that will be much more complicated.  \\nThis is one of the problems with only one simple and efficient solution, and that solution involves a heap/priority queue. Don\\'t fight it, embrace it!"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s definitely an easy task, not medium."
                    },
                    {
                        "username": "the_dark_knight_rises",
                        "content": "Is the floor definition correct here? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. The definition itself is correct and also how it should be applied in this problem. Remember: We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Somedays Medium is hard , and other day it\\'s easy. "
                    },
                    {
                        "username": "sameer0013",
                        "content": "There is a mistake in question it\\'s CEIL not FLOOR"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Below code is also run for all testcase which is provided by leetcode and successfully submitted.\nbut for this test case\npiles = [1,2,9,76]  and k =2 , it is failed.\nkindly add this testcase .\n\ncode-\nclass Solution {\n    public int minStoneSum(int[] piles, int k) { \n        int n = piles.length;\n        while (k > 0) {\n            Arrays.sort(piles);\n            for (int i=n-1; i>=n/2; i--) {\n                int remove = (int)Math.floor(piles[i]/2);\n                piles[i] -= remove;\n                k--;\n                if (k == 0) \n                break;\n            }\n        }\n        int ans = 0;\n        for (int w :piles) \n        ans += w;\n        return ans;\n    }\n}\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The inner `for` loop reduces the size of *all* piles in the range `[n - 1, n / 2]`, but it should reduce the size of the greatest pile each time.  \\nIn your example it should reduce `76` to `38`, and then `38`  to `19`."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "Should be marked as an Easy question"
                    },
                    {
                        "username": "himanshupat95",
                        "content": "Description is incorrect. Operation is : \\n ```ceil (piles[i] / 2)```"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "that\\'s not floor(piles[i] / 2), \\nbased on the result, it should be ceil()\\nPlease update the problems carefully. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We\\'re *removing* the floor."
                    }
                ]
            },
            {
                "id": 1731416,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "Heapq module in Python.\nSharing youtube short video on Heap queue algorithm in Python\nhttps://www.youtube.com/watch?v=58cYFs_W2_s&ab_channel=Amulya%27sAcademy\n"
                    },
                    {
                        "username": "SouravKr_1908",
                        "content": "Can anyone help me to optimize this solution, as I have passed 45/59 test cases it is saying time limit exceed. And I don't want to use heap concept. \n\nclass Solution(object):\n    def minStoneSum(self, piles, k):\n        \"\"\"\n        :type piles: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        for _ in range(k):\n            x=max(piles)\n            i=piles.index(x)\n            piles[i]=piles[i]-int(floor(piles[i]/2))\n\n        return sum(piles)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Calling `max(piles)` repeatedly takes too much time.  \\nWhy don\\'t you want to use a heap/priority queue? Sure, you could try to find alternative approaches like implementing a balanced binary search tree where you repeatedly remove the max element and insert a new one with the reduced size but that will be much more complicated.  \\nThis is one of the problems with only one simple and efficient solution, and that solution involves a heap/priority queue. Don\\'t fight it, embrace it!"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s definitely an easy task, not medium."
                    },
                    {
                        "username": "the_dark_knight_rises",
                        "content": "Is the floor definition correct here? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. The definition itself is correct and also how it should be applied in this problem. Remember: We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Somedays Medium is hard , and other day it\\'s easy. "
                    },
                    {
                        "username": "sameer0013",
                        "content": "There is a mistake in question it\\'s CEIL not FLOOR"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Below code is also run for all testcase which is provided by leetcode and successfully submitted.\nbut for this test case\npiles = [1,2,9,76]  and k =2 , it is failed.\nkindly add this testcase .\n\ncode-\nclass Solution {\n    public int minStoneSum(int[] piles, int k) { \n        int n = piles.length;\n        while (k > 0) {\n            Arrays.sort(piles);\n            for (int i=n-1; i>=n/2; i--) {\n                int remove = (int)Math.floor(piles[i]/2);\n                piles[i] -= remove;\n                k--;\n                if (k == 0) \n                break;\n            }\n        }\n        int ans = 0;\n        for (int w :piles) \n        ans += w;\n        return ans;\n    }\n}\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The inner `for` loop reduces the size of *all* piles in the range `[n - 1, n / 2]`, but it should reduce the size of the greatest pile each time.  \\nIn your example it should reduce `76` to `38`, and then `38`  to `19`."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "Should be marked as an Easy question"
                    },
                    {
                        "username": "himanshupat95",
                        "content": "Description is incorrect. Operation is : \\n ```ceil (piles[i] / 2)```"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "that\\'s not floor(piles[i] / 2), \\nbased on the result, it should be ceil()\\nPlease update the problems carefully. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We\\'re *removing* the floor."
                    }
                ]
            },
            {
                "id": 1731385,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "Heapq module in Python.\nSharing youtube short video on Heap queue algorithm in Python\nhttps://www.youtube.com/watch?v=58cYFs_W2_s&ab_channel=Amulya%27sAcademy\n"
                    },
                    {
                        "username": "SouravKr_1908",
                        "content": "Can anyone help me to optimize this solution, as I have passed 45/59 test cases it is saying time limit exceed. And I don't want to use heap concept. \n\nclass Solution(object):\n    def minStoneSum(self, piles, k):\n        \"\"\"\n        :type piles: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        for _ in range(k):\n            x=max(piles)\n            i=piles.index(x)\n            piles[i]=piles[i]-int(floor(piles[i]/2))\n\n        return sum(piles)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Calling `max(piles)` repeatedly takes too much time.  \\nWhy don\\'t you want to use a heap/priority queue? Sure, you could try to find alternative approaches like implementing a balanced binary search tree where you repeatedly remove the max element and insert a new one with the reduced size but that will be much more complicated.  \\nThis is one of the problems with only one simple and efficient solution, and that solution involves a heap/priority queue. Don\\'t fight it, embrace it!"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s definitely an easy task, not medium."
                    },
                    {
                        "username": "the_dark_knight_rises",
                        "content": "Is the floor definition correct here? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. The definition itself is correct and also how it should be applied in this problem. Remember: We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Somedays Medium is hard , and other day it\\'s easy. "
                    },
                    {
                        "username": "sameer0013",
                        "content": "There is a mistake in question it\\'s CEIL not FLOOR"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Below code is also run for all testcase which is provided by leetcode and successfully submitted.\nbut for this test case\npiles = [1,2,9,76]  and k =2 , it is failed.\nkindly add this testcase .\n\ncode-\nclass Solution {\n    public int minStoneSum(int[] piles, int k) { \n        int n = piles.length;\n        while (k > 0) {\n            Arrays.sort(piles);\n            for (int i=n-1; i>=n/2; i--) {\n                int remove = (int)Math.floor(piles[i]/2);\n                piles[i] -= remove;\n                k--;\n                if (k == 0) \n                break;\n            }\n        }\n        int ans = 0;\n        for (int w :piles) \n        ans += w;\n        return ans;\n    }\n}\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The inner `for` loop reduces the size of *all* piles in the range `[n - 1, n / 2]`, but it should reduce the size of the greatest pile each time.  \\nIn your example it should reduce `76` to `38`, and then `38`  to `19`."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "Should be marked as an Easy question"
                    },
                    {
                        "username": "himanshupat95",
                        "content": "Description is incorrect. Operation is : \\n ```ceil (piles[i] / 2)```"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "that\\'s not floor(piles[i] / 2), \\nbased on the result, it should be ceil()\\nPlease update the problems carefully. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We\\'re *removing* the floor."
                    }
                ]
            },
            {
                "id": 1731357,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "Heapq module in Python.\nSharing youtube short video on Heap queue algorithm in Python\nhttps://www.youtube.com/watch?v=58cYFs_W2_s&ab_channel=Amulya%27sAcademy\n"
                    },
                    {
                        "username": "SouravKr_1908",
                        "content": "Can anyone help me to optimize this solution, as I have passed 45/59 test cases it is saying time limit exceed. And I don't want to use heap concept. \n\nclass Solution(object):\n    def minStoneSum(self, piles, k):\n        \"\"\"\n        :type piles: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        for _ in range(k):\n            x=max(piles)\n            i=piles.index(x)\n            piles[i]=piles[i]-int(floor(piles[i]/2))\n\n        return sum(piles)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Calling `max(piles)` repeatedly takes too much time.  \\nWhy don\\'t you want to use a heap/priority queue? Sure, you could try to find alternative approaches like implementing a balanced binary search tree where you repeatedly remove the max element and insert a new one with the reduced size but that will be much more complicated.  \\nThis is one of the problems with only one simple and efficient solution, and that solution involves a heap/priority queue. Don\\'t fight it, embrace it!"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s definitely an easy task, not medium."
                    },
                    {
                        "username": "the_dark_knight_rises",
                        "content": "Is the floor definition correct here? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. The definition itself is correct and also how it should be applied in this problem. Remember: We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Somedays Medium is hard , and other day it\\'s easy. "
                    },
                    {
                        "username": "sameer0013",
                        "content": "There is a mistake in question it\\'s CEIL not FLOOR"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Below code is also run for all testcase which is provided by leetcode and successfully submitted.\nbut for this test case\npiles = [1,2,9,76]  and k =2 , it is failed.\nkindly add this testcase .\n\ncode-\nclass Solution {\n    public int minStoneSum(int[] piles, int k) { \n        int n = piles.length;\n        while (k > 0) {\n            Arrays.sort(piles);\n            for (int i=n-1; i>=n/2; i--) {\n                int remove = (int)Math.floor(piles[i]/2);\n                piles[i] -= remove;\n                k--;\n                if (k == 0) \n                break;\n            }\n        }\n        int ans = 0;\n        for (int w :piles) \n        ans += w;\n        return ans;\n    }\n}\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The inner `for` loop reduces the size of *all* piles in the range `[n - 1, n / 2]`, but it should reduce the size of the greatest pile each time.  \\nIn your example it should reduce `76` to `38`, and then `38`  to `19`."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "Should be marked as an Easy question"
                    },
                    {
                        "username": "himanshupat95",
                        "content": "Description is incorrect. Operation is : \\n ```ceil (piles[i] / 2)```"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "that\\'s not floor(piles[i] / 2), \\nbased on the result, it should be ceil()\\nPlease update the problems carefully. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We\\'re *removing* the floor."
                    }
                ]
            },
            {
                "id": 1731337,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "Heapq module in Python.\nSharing youtube short video on Heap queue algorithm in Python\nhttps://www.youtube.com/watch?v=58cYFs_W2_s&ab_channel=Amulya%27sAcademy\n"
                    },
                    {
                        "username": "SouravKr_1908",
                        "content": "Can anyone help me to optimize this solution, as I have passed 45/59 test cases it is saying time limit exceed. And I don't want to use heap concept. \n\nclass Solution(object):\n    def minStoneSum(self, piles, k):\n        \"\"\"\n        :type piles: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        for _ in range(k):\n            x=max(piles)\n            i=piles.index(x)\n            piles[i]=piles[i]-int(floor(piles[i]/2))\n\n        return sum(piles)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Calling `max(piles)` repeatedly takes too much time.  \\nWhy don\\'t you want to use a heap/priority queue? Sure, you could try to find alternative approaches like implementing a balanced binary search tree where you repeatedly remove the max element and insert a new one with the reduced size but that will be much more complicated.  \\nThis is one of the problems with only one simple and efficient solution, and that solution involves a heap/priority queue. Don\\'t fight it, embrace it!"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s definitely an easy task, not medium."
                    },
                    {
                        "username": "the_dark_knight_rises",
                        "content": "Is the floor definition correct here? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. The definition itself is correct and also how it should be applied in this problem. Remember: We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Somedays Medium is hard , and other day it\\'s easy. "
                    },
                    {
                        "username": "sameer0013",
                        "content": "There is a mistake in question it\\'s CEIL not FLOOR"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Below code is also run for all testcase which is provided by leetcode and successfully submitted.\nbut for this test case\npiles = [1,2,9,76]  and k =2 , it is failed.\nkindly add this testcase .\n\ncode-\nclass Solution {\n    public int minStoneSum(int[] piles, int k) { \n        int n = piles.length;\n        while (k > 0) {\n            Arrays.sort(piles);\n            for (int i=n-1; i>=n/2; i--) {\n                int remove = (int)Math.floor(piles[i]/2);\n                piles[i] -= remove;\n                k--;\n                if (k == 0) \n                break;\n            }\n        }\n        int ans = 0;\n        for (int w :piles) \n        ans += w;\n        return ans;\n    }\n}\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The inner `for` loop reduces the size of *all* piles in the range `[n - 1, n / 2]`, but it should reduce the size of the greatest pile each time.  \\nIn your example it should reduce `76` to `38`, and then `38`  to `19`."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "Should be marked as an Easy question"
                    },
                    {
                        "username": "himanshupat95",
                        "content": "Description is incorrect. Operation is : \\n ```ceil (piles[i] / 2)```"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "that\\'s not floor(piles[i] / 2), \\nbased on the result, it should be ceil()\\nPlease update the problems carefully. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We\\'re *removing* the floor."
                    }
                ]
            },
            {
                "id": 1731299,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "Heapq module in Python.\nSharing youtube short video on Heap queue algorithm in Python\nhttps://www.youtube.com/watch?v=58cYFs_W2_s&ab_channel=Amulya%27sAcademy\n"
                    },
                    {
                        "username": "SouravKr_1908",
                        "content": "Can anyone help me to optimize this solution, as I have passed 45/59 test cases it is saying time limit exceed. And I don't want to use heap concept. \n\nclass Solution(object):\n    def minStoneSum(self, piles, k):\n        \"\"\"\n        :type piles: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        for _ in range(k):\n            x=max(piles)\n            i=piles.index(x)\n            piles[i]=piles[i]-int(floor(piles[i]/2))\n\n        return sum(piles)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Calling `max(piles)` repeatedly takes too much time.  \\nWhy don\\'t you want to use a heap/priority queue? Sure, you could try to find alternative approaches like implementing a balanced binary search tree where you repeatedly remove the max element and insert a new one with the reduced size but that will be much more complicated.  \\nThis is one of the problems with only one simple and efficient solution, and that solution involves a heap/priority queue. Don\\'t fight it, embrace it!"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s definitely an easy task, not medium."
                    },
                    {
                        "username": "the_dark_knight_rises",
                        "content": "Is the floor definition correct here? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. The definition itself is correct and also how it should be applied in this problem. Remember: We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Somedays Medium is hard , and other day it\\'s easy. "
                    },
                    {
                        "username": "sameer0013",
                        "content": "There is a mistake in question it\\'s CEIL not FLOOR"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Below code is also run for all testcase which is provided by leetcode and successfully submitted.\nbut for this test case\npiles = [1,2,9,76]  and k =2 , it is failed.\nkindly add this testcase .\n\ncode-\nclass Solution {\n    public int minStoneSum(int[] piles, int k) { \n        int n = piles.length;\n        while (k > 0) {\n            Arrays.sort(piles);\n            for (int i=n-1; i>=n/2; i--) {\n                int remove = (int)Math.floor(piles[i]/2);\n                piles[i] -= remove;\n                k--;\n                if (k == 0) \n                break;\n            }\n        }\n        int ans = 0;\n        for (int w :piles) \n        ans += w;\n        return ans;\n    }\n}\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The inner `for` loop reduces the size of *all* piles in the range `[n - 1, n / 2]`, but it should reduce the size of the greatest pile each time.  \\nIn your example it should reduce `76` to `38`, and then `38`  to `19`."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "Should be marked as an Easy question"
                    },
                    {
                        "username": "himanshupat95",
                        "content": "Description is incorrect. Operation is : \\n ```ceil (piles[i] / 2)```"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "that\\'s not floor(piles[i] / 2), \\nbased on the result, it should be ceil()\\nPlease update the problems carefully. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We\\'re *removing* the floor."
                    }
                ]
            },
            {
                "id": 1731266,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "Heapq module in Python.\nSharing youtube short video on Heap queue algorithm in Python\nhttps://www.youtube.com/watch?v=58cYFs_W2_s&ab_channel=Amulya%27sAcademy\n"
                    },
                    {
                        "username": "SouravKr_1908",
                        "content": "Can anyone help me to optimize this solution, as I have passed 45/59 test cases it is saying time limit exceed. And I don't want to use heap concept. \n\nclass Solution(object):\n    def minStoneSum(self, piles, k):\n        \"\"\"\n        :type piles: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        for _ in range(k):\n            x=max(piles)\n            i=piles.index(x)\n            piles[i]=piles[i]-int(floor(piles[i]/2))\n\n        return sum(piles)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Calling `max(piles)` repeatedly takes too much time.  \\nWhy don\\'t you want to use a heap/priority queue? Sure, you could try to find alternative approaches like implementing a balanced binary search tree where you repeatedly remove the max element and insert a new one with the reduced size but that will be much more complicated.  \\nThis is one of the problems with only one simple and efficient solution, and that solution involves a heap/priority queue. Don\\'t fight it, embrace it!"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s definitely an easy task, not medium."
                    },
                    {
                        "username": "the_dark_knight_rises",
                        "content": "Is the floor definition correct here? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. The definition itself is correct and also how it should be applied in this problem. Remember: We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Somedays Medium is hard , and other day it\\'s easy. "
                    },
                    {
                        "username": "sameer0013",
                        "content": "There is a mistake in question it\\'s CEIL not FLOOR"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Below code is also run for all testcase which is provided by leetcode and successfully submitted.\nbut for this test case\npiles = [1,2,9,76]  and k =2 , it is failed.\nkindly add this testcase .\n\ncode-\nclass Solution {\n    public int minStoneSum(int[] piles, int k) { \n        int n = piles.length;\n        while (k > 0) {\n            Arrays.sort(piles);\n            for (int i=n-1; i>=n/2; i--) {\n                int remove = (int)Math.floor(piles[i]/2);\n                piles[i] -= remove;\n                k--;\n                if (k == 0) \n                break;\n            }\n        }\n        int ans = 0;\n        for (int w :piles) \n        ans += w;\n        return ans;\n    }\n}\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The inner `for` loop reduces the size of *all* piles in the range `[n - 1, n / 2]`, but it should reduce the size of the greatest pile each time.  \\nIn your example it should reduce `76` to `38`, and then `38`  to `19`."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "Should be marked as an Easy question"
                    },
                    {
                        "username": "himanshupat95",
                        "content": "Description is incorrect. Operation is : \\n ```ceil (piles[i] / 2)```"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "that\\'s not floor(piles[i] / 2), \\nbased on the result, it should be ceil()\\nPlease update the problems carefully. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We\\'re *removing* the floor."
                    }
                ]
            },
            {
                "id": 1731261,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "Heapq module in Python.\nSharing youtube short video on Heap queue algorithm in Python\nhttps://www.youtube.com/watch?v=58cYFs_W2_s&ab_channel=Amulya%27sAcademy\n"
                    },
                    {
                        "username": "SouravKr_1908",
                        "content": "Can anyone help me to optimize this solution, as I have passed 45/59 test cases it is saying time limit exceed. And I don't want to use heap concept. \n\nclass Solution(object):\n    def minStoneSum(self, piles, k):\n        \"\"\"\n        :type piles: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        for _ in range(k):\n            x=max(piles)\n            i=piles.index(x)\n            piles[i]=piles[i]-int(floor(piles[i]/2))\n\n        return sum(piles)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Calling `max(piles)` repeatedly takes too much time.  \\nWhy don\\'t you want to use a heap/priority queue? Sure, you could try to find alternative approaches like implementing a balanced binary search tree where you repeatedly remove the max element and insert a new one with the reduced size but that will be much more complicated.  \\nThis is one of the problems with only one simple and efficient solution, and that solution involves a heap/priority queue. Don\\'t fight it, embrace it!"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s definitely an easy task, not medium."
                    },
                    {
                        "username": "the_dark_knight_rises",
                        "content": "Is the floor definition correct here? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. The definition itself is correct and also how it should be applied in this problem. Remember: We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Somedays Medium is hard , and other day it\\'s easy. "
                    },
                    {
                        "username": "sameer0013",
                        "content": "There is a mistake in question it\\'s CEIL not FLOOR"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Below code is also run for all testcase which is provided by leetcode and successfully submitted.\nbut for this test case\npiles = [1,2,9,76]  and k =2 , it is failed.\nkindly add this testcase .\n\ncode-\nclass Solution {\n    public int minStoneSum(int[] piles, int k) { \n        int n = piles.length;\n        while (k > 0) {\n            Arrays.sort(piles);\n            for (int i=n-1; i>=n/2; i--) {\n                int remove = (int)Math.floor(piles[i]/2);\n                piles[i] -= remove;\n                k--;\n                if (k == 0) \n                break;\n            }\n        }\n        int ans = 0;\n        for (int w :piles) \n        ans += w;\n        return ans;\n    }\n}\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The inner `for` loop reduces the size of *all* piles in the range `[n - 1, n / 2]`, but it should reduce the size of the greatest pile each time.  \\nIn your example it should reduce `76` to `38`, and then `38`  to `19`."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "Should be marked as an Easy question"
                    },
                    {
                        "username": "himanshupat95",
                        "content": "Description is incorrect. Operation is : \\n ```ceil (piles[i] / 2)```"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "that\\'s not floor(piles[i] / 2), \\nbased on the result, it should be ceil()\\nPlease update the problems carefully. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We\\'re *removing* the floor."
                    }
                ]
            },
            {
                "id": 1731247,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "Heapq module in Python.\nSharing youtube short video on Heap queue algorithm in Python\nhttps://www.youtube.com/watch?v=58cYFs_W2_s&ab_channel=Amulya%27sAcademy\n"
                    },
                    {
                        "username": "SouravKr_1908",
                        "content": "Can anyone help me to optimize this solution, as I have passed 45/59 test cases it is saying time limit exceed. And I don't want to use heap concept. \n\nclass Solution(object):\n    def minStoneSum(self, piles, k):\n        \"\"\"\n        :type piles: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        for _ in range(k):\n            x=max(piles)\n            i=piles.index(x)\n            piles[i]=piles[i]-int(floor(piles[i]/2))\n\n        return sum(piles)"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Calling `max(piles)` repeatedly takes too much time.  \\nWhy don\\'t you want to use a heap/priority queue? Sure, you could try to find alternative approaches like implementing a balanced binary search tree where you repeatedly remove the max element and insert a new one with the reduced size but that will be much more complicated.  \\nThis is one of the problems with only one simple and efficient solution, and that solution involves a heap/priority queue. Don\\'t fight it, embrace it!"
                    },
                    {
                        "username": "belinskyi",
                        "content": "It\\'s definitely an easy task, not medium."
                    },
                    {
                        "username": "the_dark_knight_rises",
                        "content": "Is the floor definition correct here? "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Yes. The definition itself is correct and also how it should be applied in this problem. Remember: We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Celestial_Coder",
                        "content": "Somedays Medium is hard , and other day it\\'s easy. "
                    },
                    {
                        "username": "sameer0013",
                        "content": "There is a mistake in question it\\'s CEIL not FLOOR"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "Sarthak_Singh_",
                        "content": "Below code is also run for all testcase which is provided by leetcode and successfully submitted.\nbut for this test case\npiles = [1,2,9,76]  and k =2 , it is failed.\nkindly add this testcase .\n\ncode-\nclass Solution {\n    public int minStoneSum(int[] piles, int k) { \n        int n = piles.length;\n        while (k > 0) {\n            Arrays.sort(piles);\n            for (int i=n-1; i>=n/2; i--) {\n                int remove = (int)Math.floor(piles[i]/2);\n                piles[i] -= remove;\n                k--;\n                if (k == 0) \n                break;\n            }\n        }\n        int ans = 0;\n        for (int w :piles) \n        ans += w;\n        return ans;\n    }\n}\n\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "The inner `for` loop reduces the size of *all* piles in the range `[n - 1, n / 2]`, but it should reduce the size of the greatest pile each time.  \\nIn your example it should reduce `76` to `38`, and then `38`  to `19`."
                    },
                    {
                        "username": "some_dude_2020",
                        "content": "Should be marked as an Easy question"
                    },
                    {
                        "username": "himanshupat95",
                        "content": "Description is incorrect. Operation is : \\n ```ceil (piles[i] / 2)```"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Remember that we\\'re removing the floor from the pile, not keeping it"
                    },
                    {
                        "username": "jd_mahmud",
                        "content": "that\\'s not floor(piles[i] / 2), \\nbased on the result, it should be ceil()\\nPlease update the problems carefully. "
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Please re-read the description. We\\'re *removing* the floor."
                    }
                ]
            },
            {
                "id": 1731232,
                "content": [
                    {
                        "username": "Sashwat_",
                        "content": "Anyone done brute force approach... Mu is showing error I can\\'t figure out what is error.\\n\\n\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        while(k--){\\n            int max = INT_MIN;\\n            for(auto i:piles){\\n                int index;\\n                if(piles[i] > max){\\n                    max = piles[i];\\n                    index = i;\\n                    piles[index] = piles[index] - piles[index]/2;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i:piles){\\n            ans+=piles[i];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The two `for` loops are \"range-based `for` loops\" (`for i: piles`). In each iteration `i` is not the index but the value of the current element. Therefore `piles[i]` might access the `std::vector` out of bounds.\\n- The inner `if` is meant to determines the greatest pile, right? But everytime it finds a larger pile it reduces its size, even if there are larger piles to the right. That reduction (`piles[index] = ...`) should be moved out of the `for` loop.\\n- The two nested loops iterate over the `piles` many (`k`) times, in each iteration of the outer `while` loop the inner `for` loop searches for the largest pile. That will probably be too slow, you will have to find a faster approach. Take a look at the \"Related Topics\" in the description for an idea."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "i actually already resolved this, but just by using `javascript`, I used BS for inserting the deducted value back to the array to mimic Heap op, but got TLE, yet same code with C++, it\\'s more efficient, guess just bad luck for using the wrong dev language, hmm...."
                    },
                    {
                        "username": "adirawat",
                        "content": "should be marked easy!!!"
                    },
                    {
                        "username": "debadri16",
                        "content": " The problem description should be updated from **floor** to **ceil**."
                    },
                    {
                        "username": "brv22",
                        "content": "You have to remove floor(piles[i]/2). Not just change piles[i]."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Dude..didn\\'t expect this sort of error from leetcode."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If you mean floor vs. ceil: Please re-read the description. We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Mohit1976",
                        "content": "Hey ! can anyone help me , i have done code part perfectly fine .\\nit\\'s working in my system but, definitely taking time and after 4 5 seconds its showing correct ans.\\nhere in leetCode it is showing Time Limit Exceeded....\\nWhat is problem here ?\\n"
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "Try to optimize your code.\\nlength of piles can be maximum 10^5 that\\'s mean that your maximum time complexity can be nlogn. "
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "# ***Hint:*** Take half of the largest element in the vector. \nExample:  \n##       piles: [1,2,3,4,5] , k = 2\n* Largest: 5 -> Take Half -> [1,2,3,4,3]\n* Largest 4 -> Take Half -> [1,2,3,2,3]\n"
                    },
                    {
                        "username": "madhur4127",
                        "content": "I manage to achieve 112ms using C++. Did anyone manage to get lower than that?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "That\\'s fast! How much memory percentile?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "People working with C++ can use the `make_heap` utility to easily implement a heap.\\nReference : [std::make_heap](https://cplusplus.com/reference/algorithm/make_heap/)\\nMy [Solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961156/99-5-time-o-1-space-max-heap-based-solution/) (Try solving yourself first :) "
                    },
                    {
                        "username": "ankitkumar2580123",
                        "content": "anybody help me to solve the problem using array?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You might get better/faster help if you show what you\\'ve tried and/or if you describe a concrete problem. Otherwise people will have to guess where you\\'re stuck."
                    }
                ]
            },
            {
                "id": 1731225,
                "content": [
                    {
                        "username": "Sashwat_",
                        "content": "Anyone done brute force approach... Mu is showing error I can\\'t figure out what is error.\\n\\n\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        while(k--){\\n            int max = INT_MIN;\\n            for(auto i:piles){\\n                int index;\\n                if(piles[i] > max){\\n                    max = piles[i];\\n                    index = i;\\n                    piles[index] = piles[index] - piles[index]/2;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i:piles){\\n            ans+=piles[i];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The two `for` loops are \"range-based `for` loops\" (`for i: piles`). In each iteration `i` is not the index but the value of the current element. Therefore `piles[i]` might access the `std::vector` out of bounds.\\n- The inner `if` is meant to determines the greatest pile, right? But everytime it finds a larger pile it reduces its size, even if there are larger piles to the right. That reduction (`piles[index] = ...`) should be moved out of the `for` loop.\\n- The two nested loops iterate over the `piles` many (`k`) times, in each iteration of the outer `while` loop the inner `for` loop searches for the largest pile. That will probably be too slow, you will have to find a faster approach. Take a look at the \"Related Topics\" in the description for an idea."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "i actually already resolved this, but just by using `javascript`, I used BS for inserting the deducted value back to the array to mimic Heap op, but got TLE, yet same code with C++, it\\'s more efficient, guess just bad luck for using the wrong dev language, hmm...."
                    },
                    {
                        "username": "adirawat",
                        "content": "should be marked easy!!!"
                    },
                    {
                        "username": "debadri16",
                        "content": " The problem description should be updated from **floor** to **ceil**."
                    },
                    {
                        "username": "brv22",
                        "content": "You have to remove floor(piles[i]/2). Not just change piles[i]."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Dude..didn\\'t expect this sort of error from leetcode."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If you mean floor vs. ceil: Please re-read the description. We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Mohit1976",
                        "content": "Hey ! can anyone help me , i have done code part perfectly fine .\\nit\\'s working in my system but, definitely taking time and after 4 5 seconds its showing correct ans.\\nhere in leetCode it is showing Time Limit Exceeded....\\nWhat is problem here ?\\n"
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "Try to optimize your code.\\nlength of piles can be maximum 10^5 that\\'s mean that your maximum time complexity can be nlogn. "
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "# ***Hint:*** Take half of the largest element in the vector. \nExample:  \n##       piles: [1,2,3,4,5] , k = 2\n* Largest: 5 -> Take Half -> [1,2,3,4,3]\n* Largest 4 -> Take Half -> [1,2,3,2,3]\n"
                    },
                    {
                        "username": "madhur4127",
                        "content": "I manage to achieve 112ms using C++. Did anyone manage to get lower than that?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "That\\'s fast! How much memory percentile?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "People working with C++ can use the `make_heap` utility to easily implement a heap.\\nReference : [std::make_heap](https://cplusplus.com/reference/algorithm/make_heap/)\\nMy [Solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961156/99-5-time-o-1-space-max-heap-based-solution/) (Try solving yourself first :) "
                    },
                    {
                        "username": "ankitkumar2580123",
                        "content": "anybody help me to solve the problem using array?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You might get better/faster help if you show what you\\'ve tried and/or if you describe a concrete problem. Otherwise people will have to guess where you\\'re stuck."
                    }
                ]
            },
            {
                "id": 1731215,
                "content": [
                    {
                        "username": "Sashwat_",
                        "content": "Anyone done brute force approach... Mu is showing error I can\\'t figure out what is error.\\n\\n\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        while(k--){\\n            int max = INT_MIN;\\n            for(auto i:piles){\\n                int index;\\n                if(piles[i] > max){\\n                    max = piles[i];\\n                    index = i;\\n                    piles[index] = piles[index] - piles[index]/2;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i:piles){\\n            ans+=piles[i];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The two `for` loops are \"range-based `for` loops\" (`for i: piles`). In each iteration `i` is not the index but the value of the current element. Therefore `piles[i]` might access the `std::vector` out of bounds.\\n- The inner `if` is meant to determines the greatest pile, right? But everytime it finds a larger pile it reduces its size, even if there are larger piles to the right. That reduction (`piles[index] = ...`) should be moved out of the `for` loop.\\n- The two nested loops iterate over the `piles` many (`k`) times, in each iteration of the outer `while` loop the inner `for` loop searches for the largest pile. That will probably be too slow, you will have to find a faster approach. Take a look at the \"Related Topics\" in the description for an idea."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "i actually already resolved this, but just by using `javascript`, I used BS for inserting the deducted value back to the array to mimic Heap op, but got TLE, yet same code with C++, it\\'s more efficient, guess just bad luck for using the wrong dev language, hmm...."
                    },
                    {
                        "username": "adirawat",
                        "content": "should be marked easy!!!"
                    },
                    {
                        "username": "debadri16",
                        "content": " The problem description should be updated from **floor** to **ceil**."
                    },
                    {
                        "username": "brv22",
                        "content": "You have to remove floor(piles[i]/2). Not just change piles[i]."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Dude..didn\\'t expect this sort of error from leetcode."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If you mean floor vs. ceil: Please re-read the description. We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Mohit1976",
                        "content": "Hey ! can anyone help me , i have done code part perfectly fine .\\nit\\'s working in my system but, definitely taking time and after 4 5 seconds its showing correct ans.\\nhere in leetCode it is showing Time Limit Exceeded....\\nWhat is problem here ?\\n"
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "Try to optimize your code.\\nlength of piles can be maximum 10^5 that\\'s mean that your maximum time complexity can be nlogn. "
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "# ***Hint:*** Take half of the largest element in the vector. \nExample:  \n##       piles: [1,2,3,4,5] , k = 2\n* Largest: 5 -> Take Half -> [1,2,3,4,3]\n* Largest 4 -> Take Half -> [1,2,3,2,3]\n"
                    },
                    {
                        "username": "madhur4127",
                        "content": "I manage to achieve 112ms using C++. Did anyone manage to get lower than that?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "That\\'s fast! How much memory percentile?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "People working with C++ can use the `make_heap` utility to easily implement a heap.\\nReference : [std::make_heap](https://cplusplus.com/reference/algorithm/make_heap/)\\nMy [Solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961156/99-5-time-o-1-space-max-heap-based-solution/) (Try solving yourself first :) "
                    },
                    {
                        "username": "ankitkumar2580123",
                        "content": "anybody help me to solve the problem using array?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You might get better/faster help if you show what you\\'ve tried and/or if you describe a concrete problem. Otherwise people will have to guess where you\\'re stuck."
                    }
                ]
            },
            {
                "id": 1731116,
                "content": [
                    {
                        "username": "Sashwat_",
                        "content": "Anyone done brute force approach... Mu is showing error I can\\'t figure out what is error.\\n\\n\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        while(k--){\\n            int max = INT_MIN;\\n            for(auto i:piles){\\n                int index;\\n                if(piles[i] > max){\\n                    max = piles[i];\\n                    index = i;\\n                    piles[index] = piles[index] - piles[index]/2;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i:piles){\\n            ans+=piles[i];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The two `for` loops are \"range-based `for` loops\" (`for i: piles`). In each iteration `i` is not the index but the value of the current element. Therefore `piles[i]` might access the `std::vector` out of bounds.\\n- The inner `if` is meant to determines the greatest pile, right? But everytime it finds a larger pile it reduces its size, even if there are larger piles to the right. That reduction (`piles[index] = ...`) should be moved out of the `for` loop.\\n- The two nested loops iterate over the `piles` many (`k`) times, in each iteration of the outer `while` loop the inner `for` loop searches for the largest pile. That will probably be too slow, you will have to find a faster approach. Take a look at the \"Related Topics\" in the description for an idea."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "i actually already resolved this, but just by using `javascript`, I used BS for inserting the deducted value back to the array to mimic Heap op, but got TLE, yet same code with C++, it\\'s more efficient, guess just bad luck for using the wrong dev language, hmm...."
                    },
                    {
                        "username": "adirawat",
                        "content": "should be marked easy!!!"
                    },
                    {
                        "username": "debadri16",
                        "content": " The problem description should be updated from **floor** to **ceil**."
                    },
                    {
                        "username": "brv22",
                        "content": "You have to remove floor(piles[i]/2). Not just change piles[i]."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Dude..didn\\'t expect this sort of error from leetcode."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If you mean floor vs. ceil: Please re-read the description. We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Mohit1976",
                        "content": "Hey ! can anyone help me , i have done code part perfectly fine .\\nit\\'s working in my system but, definitely taking time and after 4 5 seconds its showing correct ans.\\nhere in leetCode it is showing Time Limit Exceeded....\\nWhat is problem here ?\\n"
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "Try to optimize your code.\\nlength of piles can be maximum 10^5 that\\'s mean that your maximum time complexity can be nlogn. "
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "# ***Hint:*** Take half of the largest element in the vector. \nExample:  \n##       piles: [1,2,3,4,5] , k = 2\n* Largest: 5 -> Take Half -> [1,2,3,4,3]\n* Largest 4 -> Take Half -> [1,2,3,2,3]\n"
                    },
                    {
                        "username": "madhur4127",
                        "content": "I manage to achieve 112ms using C++. Did anyone manage to get lower than that?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "That\\'s fast! How much memory percentile?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "People working with C++ can use the `make_heap` utility to easily implement a heap.\\nReference : [std::make_heap](https://cplusplus.com/reference/algorithm/make_heap/)\\nMy [Solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961156/99-5-time-o-1-space-max-heap-based-solution/) (Try solving yourself first :) "
                    },
                    {
                        "username": "ankitkumar2580123",
                        "content": "anybody help me to solve the problem using array?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You might get better/faster help if you show what you\\'ve tried and/or if you describe a concrete problem. Otherwise people will have to guess where you\\'re stuck."
                    }
                ]
            },
            {
                "id": 1731115,
                "content": [
                    {
                        "username": "Sashwat_",
                        "content": "Anyone done brute force approach... Mu is showing error I can\\'t figure out what is error.\\n\\n\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        while(k--){\\n            int max = INT_MIN;\\n            for(auto i:piles){\\n                int index;\\n                if(piles[i] > max){\\n                    max = piles[i];\\n                    index = i;\\n                    piles[index] = piles[index] - piles[index]/2;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i:piles){\\n            ans+=piles[i];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The two `for` loops are \"range-based `for` loops\" (`for i: piles`). In each iteration `i` is not the index but the value of the current element. Therefore `piles[i]` might access the `std::vector` out of bounds.\\n- The inner `if` is meant to determines the greatest pile, right? But everytime it finds a larger pile it reduces its size, even if there are larger piles to the right. That reduction (`piles[index] = ...`) should be moved out of the `for` loop.\\n- The two nested loops iterate over the `piles` many (`k`) times, in each iteration of the outer `while` loop the inner `for` loop searches for the largest pile. That will probably be too slow, you will have to find a faster approach. Take a look at the \"Related Topics\" in the description for an idea."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "i actually already resolved this, but just by using `javascript`, I used BS for inserting the deducted value back to the array to mimic Heap op, but got TLE, yet same code with C++, it\\'s more efficient, guess just bad luck for using the wrong dev language, hmm...."
                    },
                    {
                        "username": "adirawat",
                        "content": "should be marked easy!!!"
                    },
                    {
                        "username": "debadri16",
                        "content": " The problem description should be updated from **floor** to **ceil**."
                    },
                    {
                        "username": "brv22",
                        "content": "You have to remove floor(piles[i]/2). Not just change piles[i]."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Dude..didn\\'t expect this sort of error from leetcode."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If you mean floor vs. ceil: Please re-read the description. We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Mohit1976",
                        "content": "Hey ! can anyone help me , i have done code part perfectly fine .\\nit\\'s working in my system but, definitely taking time and after 4 5 seconds its showing correct ans.\\nhere in leetCode it is showing Time Limit Exceeded....\\nWhat is problem here ?\\n"
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "Try to optimize your code.\\nlength of piles can be maximum 10^5 that\\'s mean that your maximum time complexity can be nlogn. "
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "# ***Hint:*** Take half of the largest element in the vector. \nExample:  \n##       piles: [1,2,3,4,5] , k = 2\n* Largest: 5 -> Take Half -> [1,2,3,4,3]\n* Largest 4 -> Take Half -> [1,2,3,2,3]\n"
                    },
                    {
                        "username": "madhur4127",
                        "content": "I manage to achieve 112ms using C++. Did anyone manage to get lower than that?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "That\\'s fast! How much memory percentile?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "People working with C++ can use the `make_heap` utility to easily implement a heap.\\nReference : [std::make_heap](https://cplusplus.com/reference/algorithm/make_heap/)\\nMy [Solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961156/99-5-time-o-1-space-max-heap-based-solution/) (Try solving yourself first :) "
                    },
                    {
                        "username": "ankitkumar2580123",
                        "content": "anybody help me to solve the problem using array?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You might get better/faster help if you show what you\\'ve tried and/or if you describe a concrete problem. Otherwise people will have to guess where you\\'re stuck."
                    }
                ]
            },
            {
                "id": 1731105,
                "content": [
                    {
                        "username": "Sashwat_",
                        "content": "Anyone done brute force approach... Mu is showing error I can\\'t figure out what is error.\\n\\n\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        while(k--){\\n            int max = INT_MIN;\\n            for(auto i:piles){\\n                int index;\\n                if(piles[i] > max){\\n                    max = piles[i];\\n                    index = i;\\n                    piles[index] = piles[index] - piles[index]/2;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i:piles){\\n            ans+=piles[i];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The two `for` loops are \"range-based `for` loops\" (`for i: piles`). In each iteration `i` is not the index but the value of the current element. Therefore `piles[i]` might access the `std::vector` out of bounds.\\n- The inner `if` is meant to determines the greatest pile, right? But everytime it finds a larger pile it reduces its size, even if there are larger piles to the right. That reduction (`piles[index] = ...`) should be moved out of the `for` loop.\\n- The two nested loops iterate over the `piles` many (`k`) times, in each iteration of the outer `while` loop the inner `for` loop searches for the largest pile. That will probably be too slow, you will have to find a faster approach. Take a look at the \"Related Topics\" in the description for an idea."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "i actually already resolved this, but just by using `javascript`, I used BS for inserting the deducted value back to the array to mimic Heap op, but got TLE, yet same code with C++, it\\'s more efficient, guess just bad luck for using the wrong dev language, hmm...."
                    },
                    {
                        "username": "adirawat",
                        "content": "should be marked easy!!!"
                    },
                    {
                        "username": "debadri16",
                        "content": " The problem description should be updated from **floor** to **ceil**."
                    },
                    {
                        "username": "brv22",
                        "content": "You have to remove floor(piles[i]/2). Not just change piles[i]."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Dude..didn\\'t expect this sort of error from leetcode."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If you mean floor vs. ceil: Please re-read the description. We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Mohit1976",
                        "content": "Hey ! can anyone help me , i have done code part perfectly fine .\\nit\\'s working in my system but, definitely taking time and after 4 5 seconds its showing correct ans.\\nhere in leetCode it is showing Time Limit Exceeded....\\nWhat is problem here ?\\n"
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "Try to optimize your code.\\nlength of piles can be maximum 10^5 that\\'s mean that your maximum time complexity can be nlogn. "
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "# ***Hint:*** Take half of the largest element in the vector. \nExample:  \n##       piles: [1,2,3,4,5] , k = 2\n* Largest: 5 -> Take Half -> [1,2,3,4,3]\n* Largest 4 -> Take Half -> [1,2,3,2,3]\n"
                    },
                    {
                        "username": "madhur4127",
                        "content": "I manage to achieve 112ms using C++. Did anyone manage to get lower than that?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "That\\'s fast! How much memory percentile?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "People working with C++ can use the `make_heap` utility to easily implement a heap.\\nReference : [std::make_heap](https://cplusplus.com/reference/algorithm/make_heap/)\\nMy [Solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961156/99-5-time-o-1-space-max-heap-based-solution/) (Try solving yourself first :) "
                    },
                    {
                        "username": "ankitkumar2580123",
                        "content": "anybody help me to solve the problem using array?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You might get better/faster help if you show what you\\'ve tried and/or if you describe a concrete problem. Otherwise people will have to guess where you\\'re stuck."
                    }
                ]
            },
            {
                "id": 1731103,
                "content": [
                    {
                        "username": "Sashwat_",
                        "content": "Anyone done brute force approach... Mu is showing error I can\\'t figure out what is error.\\n\\n\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        while(k--){\\n            int max = INT_MIN;\\n            for(auto i:piles){\\n                int index;\\n                if(piles[i] > max){\\n                    max = piles[i];\\n                    index = i;\\n                    piles[index] = piles[index] - piles[index]/2;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i:piles){\\n            ans+=piles[i];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The two `for` loops are \"range-based `for` loops\" (`for i: piles`). In each iteration `i` is not the index but the value of the current element. Therefore `piles[i]` might access the `std::vector` out of bounds.\\n- The inner `if` is meant to determines the greatest pile, right? But everytime it finds a larger pile it reduces its size, even if there are larger piles to the right. That reduction (`piles[index] = ...`) should be moved out of the `for` loop.\\n- The two nested loops iterate over the `piles` many (`k`) times, in each iteration of the outer `while` loop the inner `for` loop searches for the largest pile. That will probably be too slow, you will have to find a faster approach. Take a look at the \"Related Topics\" in the description for an idea."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "i actually already resolved this, but just by using `javascript`, I used BS for inserting the deducted value back to the array to mimic Heap op, but got TLE, yet same code with C++, it\\'s more efficient, guess just bad luck for using the wrong dev language, hmm...."
                    },
                    {
                        "username": "adirawat",
                        "content": "should be marked easy!!!"
                    },
                    {
                        "username": "debadri16",
                        "content": " The problem description should be updated from **floor** to **ceil**."
                    },
                    {
                        "username": "brv22",
                        "content": "You have to remove floor(piles[i]/2). Not just change piles[i]."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Dude..didn\\'t expect this sort of error from leetcode."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If you mean floor vs. ceil: Please re-read the description. We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Mohit1976",
                        "content": "Hey ! can anyone help me , i have done code part perfectly fine .\\nit\\'s working in my system but, definitely taking time and after 4 5 seconds its showing correct ans.\\nhere in leetCode it is showing Time Limit Exceeded....\\nWhat is problem here ?\\n"
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "Try to optimize your code.\\nlength of piles can be maximum 10^5 that\\'s mean that your maximum time complexity can be nlogn. "
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "# ***Hint:*** Take half of the largest element in the vector. \nExample:  \n##       piles: [1,2,3,4,5] , k = 2\n* Largest: 5 -> Take Half -> [1,2,3,4,3]\n* Largest 4 -> Take Half -> [1,2,3,2,3]\n"
                    },
                    {
                        "username": "madhur4127",
                        "content": "I manage to achieve 112ms using C++. Did anyone manage to get lower than that?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "That\\'s fast! How much memory percentile?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "People working with C++ can use the `make_heap` utility to easily implement a heap.\\nReference : [std::make_heap](https://cplusplus.com/reference/algorithm/make_heap/)\\nMy [Solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961156/99-5-time-o-1-space-max-heap-based-solution/) (Try solving yourself first :) "
                    },
                    {
                        "username": "ankitkumar2580123",
                        "content": "anybody help me to solve the problem using array?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You might get better/faster help if you show what you\\'ve tried and/or if you describe a concrete problem. Otherwise people will have to guess where you\\'re stuck."
                    }
                ]
            },
            {
                "id": 1731100,
                "content": [
                    {
                        "username": "Sashwat_",
                        "content": "Anyone done brute force approach... Mu is showing error I can\\'t figure out what is error.\\n\\n\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        while(k--){\\n            int max = INT_MIN;\\n            for(auto i:piles){\\n                int index;\\n                if(piles[i] > max){\\n                    max = piles[i];\\n                    index = i;\\n                    piles[index] = piles[index] - piles[index]/2;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i:piles){\\n            ans+=piles[i];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The two `for` loops are \"range-based `for` loops\" (`for i: piles`). In each iteration `i` is not the index but the value of the current element. Therefore `piles[i]` might access the `std::vector` out of bounds.\\n- The inner `if` is meant to determines the greatest pile, right? But everytime it finds a larger pile it reduces its size, even if there are larger piles to the right. That reduction (`piles[index] = ...`) should be moved out of the `for` loop.\\n- The two nested loops iterate over the `piles` many (`k`) times, in each iteration of the outer `while` loop the inner `for` loop searches for the largest pile. That will probably be too slow, you will have to find a faster approach. Take a look at the \"Related Topics\" in the description for an idea."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "i actually already resolved this, but just by using `javascript`, I used BS for inserting the deducted value back to the array to mimic Heap op, but got TLE, yet same code with C++, it\\'s more efficient, guess just bad luck for using the wrong dev language, hmm...."
                    },
                    {
                        "username": "adirawat",
                        "content": "should be marked easy!!!"
                    },
                    {
                        "username": "debadri16",
                        "content": " The problem description should be updated from **floor** to **ceil**."
                    },
                    {
                        "username": "brv22",
                        "content": "You have to remove floor(piles[i]/2). Not just change piles[i]."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Dude..didn\\'t expect this sort of error from leetcode."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If you mean floor vs. ceil: Please re-read the description. We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Mohit1976",
                        "content": "Hey ! can anyone help me , i have done code part perfectly fine .\\nit\\'s working in my system but, definitely taking time and after 4 5 seconds its showing correct ans.\\nhere in leetCode it is showing Time Limit Exceeded....\\nWhat is problem here ?\\n"
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "Try to optimize your code.\\nlength of piles can be maximum 10^5 that\\'s mean that your maximum time complexity can be nlogn. "
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "# ***Hint:*** Take half of the largest element in the vector. \nExample:  \n##       piles: [1,2,3,4,5] , k = 2\n* Largest: 5 -> Take Half -> [1,2,3,4,3]\n* Largest 4 -> Take Half -> [1,2,3,2,3]\n"
                    },
                    {
                        "username": "madhur4127",
                        "content": "I manage to achieve 112ms using C++. Did anyone manage to get lower than that?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "That\\'s fast! How much memory percentile?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "People working with C++ can use the `make_heap` utility to easily implement a heap.\\nReference : [std::make_heap](https://cplusplus.com/reference/algorithm/make_heap/)\\nMy [Solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961156/99-5-time-o-1-space-max-heap-based-solution/) (Try solving yourself first :) "
                    },
                    {
                        "username": "ankitkumar2580123",
                        "content": "anybody help me to solve the problem using array?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You might get better/faster help if you show what you\\'ve tried and/or if you describe a concrete problem. Otherwise people will have to guess where you\\'re stuck."
                    }
                ]
            },
            {
                "id": 1731065,
                "content": [
                    {
                        "username": "Sashwat_",
                        "content": "Anyone done brute force approach... Mu is showing error I can\\'t figure out what is error.\\n\\n\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        while(k--){\\n            int max = INT_MIN;\\n            for(auto i:piles){\\n                int index;\\n                if(piles[i] > max){\\n                    max = piles[i];\\n                    index = i;\\n                    piles[index] = piles[index] - piles[index]/2;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i:piles){\\n            ans+=piles[i];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The two `for` loops are \"range-based `for` loops\" (`for i: piles`). In each iteration `i` is not the index but the value of the current element. Therefore `piles[i]` might access the `std::vector` out of bounds.\\n- The inner `if` is meant to determines the greatest pile, right? But everytime it finds a larger pile it reduces its size, even if there are larger piles to the right. That reduction (`piles[index] = ...`) should be moved out of the `for` loop.\\n- The two nested loops iterate over the `piles` many (`k`) times, in each iteration of the outer `while` loop the inner `for` loop searches for the largest pile. That will probably be too slow, you will have to find a faster approach. Take a look at the \"Related Topics\" in the description for an idea."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "i actually already resolved this, but just by using `javascript`, I used BS for inserting the deducted value back to the array to mimic Heap op, but got TLE, yet same code with C++, it\\'s more efficient, guess just bad luck for using the wrong dev language, hmm...."
                    },
                    {
                        "username": "adirawat",
                        "content": "should be marked easy!!!"
                    },
                    {
                        "username": "debadri16",
                        "content": " The problem description should be updated from **floor** to **ceil**."
                    },
                    {
                        "username": "brv22",
                        "content": "You have to remove floor(piles[i]/2). Not just change piles[i]."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Dude..didn\\'t expect this sort of error from leetcode."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If you mean floor vs. ceil: Please re-read the description. We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Mohit1976",
                        "content": "Hey ! can anyone help me , i have done code part perfectly fine .\\nit\\'s working in my system but, definitely taking time and after 4 5 seconds its showing correct ans.\\nhere in leetCode it is showing Time Limit Exceeded....\\nWhat is problem here ?\\n"
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "Try to optimize your code.\\nlength of piles can be maximum 10^5 that\\'s mean that your maximum time complexity can be nlogn. "
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "# ***Hint:*** Take half of the largest element in the vector. \nExample:  \n##       piles: [1,2,3,4,5] , k = 2\n* Largest: 5 -> Take Half -> [1,2,3,4,3]\n* Largest 4 -> Take Half -> [1,2,3,2,3]\n"
                    },
                    {
                        "username": "madhur4127",
                        "content": "I manage to achieve 112ms using C++. Did anyone manage to get lower than that?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "That\\'s fast! How much memory percentile?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "People working with C++ can use the `make_heap` utility to easily implement a heap.\\nReference : [std::make_heap](https://cplusplus.com/reference/algorithm/make_heap/)\\nMy [Solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961156/99-5-time-o-1-space-max-heap-based-solution/) (Try solving yourself first :) "
                    },
                    {
                        "username": "ankitkumar2580123",
                        "content": "anybody help me to solve the problem using array?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You might get better/faster help if you show what you\\'ve tried and/or if you describe a concrete problem. Otherwise people will have to guess where you\\'re stuck."
                    }
                ]
            },
            {
                "id": 1731048,
                "content": [
                    {
                        "username": "Sashwat_",
                        "content": "Anyone done brute force approach... Mu is showing error I can\\'t figure out what is error.\\n\\n\\nclass Solution {\\npublic:\\n    int minStoneSum(vector<int>& piles, int k) {\\n        while(k--){\\n            int max = INT_MIN;\\n            for(auto i:piles){\\n                int index;\\n                if(piles[i] > max){\\n                    max = piles[i];\\n                    index = i;\\n                    piles[index] = piles[index] - piles[index]/2;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(auto i:piles){\\n            ans+=piles[i];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "- The two `for` loops are \"range-based `for` loops\" (`for i: piles`). In each iteration `i` is not the index but the value of the current element. Therefore `piles[i]` might access the `std::vector` out of bounds.\\n- The inner `if` is meant to determines the greatest pile, right? But everytime it finds a larger pile it reduces its size, even if there are larger piles to the right. That reduction (`piles[index] = ...`) should be moved out of the `for` loop.\\n- The two nested loops iterate over the `piles` many (`k`) times, in each iteration of the outer `while` loop the inner `for` loop searches for the largest pile. That will probably be too slow, you will have to find a faster approach. Take a look at the \"Related Topics\" in the description for an idea."
                    },
                    {
                        "username": "leetcodeJayJay",
                        "content": "i actually already resolved this, but just by using `javascript`, I used BS for inserting the deducted value back to the array to mimic Heap op, but got TLE, yet same code with C++, it\\'s more efficient, guess just bad luck for using the wrong dev language, hmm...."
                    },
                    {
                        "username": "adirawat",
                        "content": "should be marked easy!!!"
                    },
                    {
                        "username": "debadri16",
                        "content": " The problem description should be updated from **floor** to **ceil**."
                    },
                    {
                        "username": "brv22",
                        "content": "You have to remove floor(piles[i]/2). Not just change piles[i]."
                    },
                    {
                        "username": "imprayas12",
                        "content": "Dude..didn\\'t expect this sort of error from leetcode."
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "If you mean floor vs. ceil: Please re-read the description. We should *remove* the floor, not keep it."
                    },
                    {
                        "username": "Mohit1976",
                        "content": "Hey ! can anyone help me , i have done code part perfectly fine .\\nit\\'s working in my system but, definitely taking time and after 4 5 seconds its showing correct ans.\\nhere in leetCode it is showing Time Limit Exceeded....\\nWhat is problem here ?\\n"
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "Try to optimize your code.\\nlength of piles can be maximum 10^5 that\\'s mean that your maximum time complexity can be nlogn. "
                    },
                    {
                        "username": "harsitagarwalla1",
                        "content": "# ***Hint:*** Take half of the largest element in the vector. \nExample:  \n##       piles: [1,2,3,4,5] , k = 2\n* Largest: 5 -> Take Half -> [1,2,3,4,3]\n* Largest 4 -> Take Half -> [1,2,3,2,3]\n"
                    },
                    {
                        "username": "madhur4127",
                        "content": "I manage to achieve 112ms using C++. Did anyone manage to get lower than that?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "That\\'s fast! How much memory percentile?"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "People working with C++ can use the `make_heap` utility to easily implement a heap.\\nReference : [std::make_heap](https://cplusplus.com/reference/algorithm/make_heap/)\\nMy [Solution](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961156/99-5-time-o-1-space-max-heap-based-solution/) (Try solving yourself first :) "
                    },
                    {
                        "username": "ankitkumar2580123",
                        "content": "anybody help me to solve the problem using array?"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "You might get better/faster help if you show what you\\'ve tried and/or if you describe a concrete problem. Otherwise people will have to guess where you\\'re stuck."
                    }
                ]
            }
        ]
    }
]