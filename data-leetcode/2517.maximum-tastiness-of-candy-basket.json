[
    {
        "title": "Maximum Tastiness of Candy Basket",
        "question_content": "You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k.\nThe store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket.\nReturn the maximum tastiness of a candy basket.\n&nbsp;\nExample 1:\n\nInput: price = [13,5,1,8,21,2], k = 3\nOutput: 8\nExplanation: Choose the candies with the prices [13,5,21].\nThe tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.\nIt can be proven that 8 is the maximum tastiness that can be achieved.\n\nExample 2:\n\nInput: price = [1,3,1], k = 2\nOutput: 2\nExplanation: Choose the candies with the prices [1,3].\nThe tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.\nIt can be proven that 2 is the maximum tastiness that can be achieved.\n\nExample 3:\n\nInput: price = [7,7,7,7], k = 2\nOutput: 0\nExplanation: Choosing any two distinct candies from the candies we have will result in a tastiness of 0.\n\n&nbsp;\nConstraints:\n\n\t2 <= k <= price.length <= 105\n\t1 <= price[i] <= 109",
        "solutions": [
            {
                "id": 2947983,
                "title": "c-java-python-binary-search-and-sorting",
                "content": "\\n\\n# Intuition\\nWe can use binary search to search the minimum difference. Since range is `0 - 10^9`, Time complexity will be `n * log(10 ^ 9) = 10 ^ 5 * 30`. This should be within constraints.\\n\\n# Approach\\n* Sort `prices`\\n* Run a binary search in the range `0 to 10 ^ 9`\\n* The check function iterates over the array `prices` and checks if the given value `x` can be the minimum difference for any subsequence of the array prices\\n\\n# Complexity\\n- Time complexity: O(nlog(10^9))\\n\\n- Space complexity: O(sort)\\n\\n# Code\\n**Python3**:\\n```\\ndef maximumTastiness(self, price: List[int], k: int) -> int:\\n    price.sort()\\n    def check(x):\\n        last, count, i = price[0], 1, 1\\n        while count < k and i < len(price):\\n            if price[i] - last >= x:\\n                last, count = price[i], count + 1\\n            i += 1\\n        return count == k\\n    lo, hi = 0, 10 ** 9\\n    while lo < hi:\\n        mid = (lo + hi) // 2\\n        if check(mid): lo = mid + 1\\n        else: hi = mid\\n    return lo - 1\\n```\\n\\n**C++**:\\n```\\nint maximumTastiness(vector<int>& price, int k) {\\n    sort(price.begin(), price.end());\\n    int lo = 0, hi = 1e9;\\n    while (lo < hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if (check(mid, price, k)) lo = mid + 1;\\n        else hi = mid;\\n    }\\n    return lo - 1;\\n}\\nbool check(int x, vector<int>& price, int k) {\\n    int last = price[0], count = 1, i = 1;\\n    while (count < k && i < price.size()) {\\n        if (price[i] - last >= x)\\n            last = price[i], count++;\\n        i++;\\n    }\\n    return count == k;\\n}\\n```\\n\\n**Java**:\\n```\\npublic int maximumTastiness(int[] price, int k) {\\n    Arrays.sort(price);\\n    int lo = 0, hi = 1000_000_000;\\n    while (lo < hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if (check(mid, price, k)) lo = mid + 1;\\n        else hi = mid;\\n    }\\n    return lo - 1;\\n}\\nboolean check(int x, int[] price, int k) {\\n    int last = price[0], count = 1, i = 1;\\n    while (count < k && i < price.length) {\\n        if (price[i] - last >= x) {\\n            last = price[i]; count++;\\n        }\\n        i++;\\n    }\\n    return count == k;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ndef maximumTastiness(self, price: List[int], k: int) -> int:\\n    price.sort()\\n    def check(x):\\n        last, count, i = price[0], 1, 1\\n        while count < k and i < len(price):\\n            if price[i] - last >= x:\\n                last, count = price[i], count + 1\\n            i += 1\\n        return count == k\\n    lo, hi = 0, 10 ** 9\\n    while lo < hi:\\n        mid = (lo + hi) // 2\\n        if check(mid): lo = mid + 1\\n        else: hi = mid\\n    return lo - 1\\n```\n```\\nint maximumTastiness(vector<int>& price, int k) {\\n    sort(price.begin(), price.end());\\n    int lo = 0, hi = 1e9;\\n    while (lo < hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if (check(mid, price, k)) lo = mid + 1;\\n        else hi = mid;\\n    }\\n    return lo - 1;\\n}\\nbool check(int x, vector<int>& price, int k) {\\n    int last = price[0], count = 1, i = 1;\\n    while (count < k && i < price.size()) {\\n        if (price[i] - last >= x)\\n            last = price[i], count++;\\n        i++;\\n    }\\n    return count == k;\\n}\\n```\n```\\npublic int maximumTastiness(int[] price, int k) {\\n    Arrays.sort(price);\\n    int lo = 0, hi = 1000_000_000;\\n    while (lo < hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if (check(mid, price, k)) lo = mid + 1;\\n        else hi = mid;\\n    }\\n    return lo - 1;\\n}\\nboolean check(int x, int[] price, int k) {\\n    int last = price[0], count = 1, i = 1;\\n    while (count < k && i < price.length) {\\n        if (price[i] - last >= x) {\\n            last = price[i]; count++;\\n        }\\n        i++;\\n    }\\n    return count == k;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2948107,
                "title": "binary-search",
                "content": "If we sort the array, we can check if it\\'s possible to pick `k` candies with a given tastiness in O(n).\\n\\nThus, we can binary-search for the largest tastiness, resulting in O(n log m) solution.\\n\\n**C++**\\n```cpp\\nint maximumTastiness(vector<int>& price, int k) {\\n    sort(begin(price), end(price));\\n    int l = 0, r = price.back() - price.front();\\n    while(l - r) {\\n        int m = (l + r + 1) / 2, cnt = 1;\\n        for (int i = 1, j = 0; i < price.size(); ++i)\\n            if (price[i] - price[j] >= m) {\\n                ++cnt;\\n                j = i;\\n            }\\n        if (cnt >= k)\\n            l = m;\\n        else\\n            r = m - 1;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint maximumTastiness(vector<int>& price, int k) {\\n    sort(begin(price), end(price));\\n    int l = 0, r = price.back() - price.front();\\n    while(l - r) {\\n        int m = (l + r + 1) / 2, cnt = 1;\\n        for (int i = 1, j = 0; i < price.size(); ++i)\\n            if (price[i] - price[j] >= m) {\\n                ++cnt;\\n                j = i;\\n            }\\n        if (cnt >= k)\\n            l = m;\\n        else\\n            r = m - 1;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2947986,
                "title": "c-easy-binary-search",
                "content": "```\\nclass Solution\\n{\\npublic:\\n\\n    bool isValid(int minDiff, vector<int>& price, int k) {\\n        int n = price.size();\\n        int cnt = 1;\\n\\n        int prev = price[0];\\n\\n        for(int i = 1; i < n; i++) {\\n            if(price[i] - prev >= minDiff) {\\n                cnt++;\\n                prev = price[i];\\n            }\\n        }\\n\\n        if(cnt >= k) return true;\\n\\n        return false;\\n\\n    }\\n    int maximumTastiness(vector<int> &price, int k) {\\n        sort(price.begin(), price.end());\\n        int n = price.size();\\n\\n        int st = 0;\\n        int en = price[n - 1] - price[0];\\n\\n        int ans = -1;\\n\\n        while(st <= en) {\\n            int mid = st + (en - st) / 2;\\n\\n            if(isValid(mid, price, k)) ans = mid, st = mid + 1;\\n            else en = mid - 1; \\n        }\\n\\n        return ans;\\n    }\\n};\\n// upvote if you like the solution\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\n    bool isValid(int minDiff, vector<int>& price, int k) {\\n        int n = price.size();\\n        int cnt = 1;\\n\\n        int prev = price[0];\\n\\n        for(int i = 1; i < n; i++) {\\n            if(price[i] - prev >= minDiff) {\\n                cnt++;\\n                prev = price[i];\\n            }\\n        }\\n\\n        if(cnt >= k) return true;\\n\\n        return false;\\n\\n    }\\n    int maximumTastiness(vector<int> &price, int k) {\\n        sort(price.begin(), price.end());\\n        int n = price.size();\\n\\n        int st = 0;\\n        int en = price[n - 1] - price[0];\\n\\n        int ans = -1;\\n\\n        while(st <= en) {\\n            int mid = st + (en - st) / 2;\\n\\n            if(isValid(mid, price, k)) ans = mid, st = mid + 1;\\n            else en = mid - 1; \\n        }\\n\\n        return ans;\\n    }\\n};\\n// upvote if you like the solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950185,
                "title": "java-binary-search-explained",
                "content": "# Intuition\\nThe difficult and interesting part of this question is to figure out that we can turn this optimization problem into a decision problem.\\n\\nIf we choose an arbitrary value `x` the decision is whether this number can satify the problem condition. We need to figure out if `x` can be the minimum difference of `k` chosen candies.\\n\\nIf `x = 5` satisfies the condition, then we also know for fact that `x = 4` will work, because smaller difference is also contained within the bigger diference. This turns our search space into a monotonic one. Because whenever we find a number `x` that doesn\\'t satify the condition anymore, all greater values won\\'t work too. The search space will look like this: `[T, T, T, F, F]`, where T stands for true (satisfying the condition) and F stands for false.\\n\\nGiven that intuition, we can perform a binary search to find the best `x`.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int n = price.length;\\n        int lo = 0;\\n        int hi =  price[n-1] - price[0];\\n\\n        while (lo < hi) {\\n            int mid = 1 + lo + (hi - lo) / 2; // + 1 to push mid to the right because the monotonicity is [T, T, T, F, F] and we want the middle to be chosen right this way we cut hi down\\n            if(searchFunction(mid, price, k)) {\\n                lo = mid;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n\\n    private boolean searchFunction(int target, int[] price, int k) {\\n        int prev = price[0];\\n        int c = 1;\\n        for(int i = 1; i < price.length; i++) {\\n            if(price[i] - prev >= target) {\\n                c++;\\n                prev = price[i];\\n            }\\n            if(c == k) return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int n = price.length;\\n        int lo = 0;\\n        int hi =  price[n-1] - price[0];\\n\\n        while (lo < hi) {\\n            int mid = 1 + lo + (hi - lo) / 2; // + 1 to push mid to the right because the monotonicity is [T, T, T, F, F] and we want the middle to be chosen right this way we cut hi down\\n            if(searchFunction(mid, price, k)) {\\n                lo = mid;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n\\n    private boolean searchFunction(int target, int[] price, int k) {\\n        int prev = price[0];\\n        int c = 1;\\n        for(int i = 1; i < price.length; i++) {\\n            if(price[i] - prev >= target) {\\n                c++;\\n                prev = price[i];\\n            }\\n            if(c == k) return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948406,
                "title": "c-aggresive-cows-exact-same-code-bs-on-ans",
                "content": "# Intuition\\nAggresive Cows \\n(Exact same code)\\n# Approach\\nBinary Search on Answer\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool isPossible(vector<int> &p, int minDist, int k)\\n    {\\n        int take = 1; \\n        int lastCowPosition = p[0];\\n        for (int i = 1; i < p.size(); i++)\\n        {\\n            if (p[i] - lastCowPosition >= minDist)\\n            {\\n                take++;\\n                lastCowPosition = p[i];\\n                if (take >= k)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int maximumTastiness(vector<int> &p, int k)\\n    {\\n        int n = p.size();\\n        sort(p.begin(), p.end());\\n        int l = 1, h = p[n - 1] - p[0];\\n        int ans = 0;\\n        while (l <= h)\\n        {\\n            int m = (l + h) / 2;\\n            if (isPossible(p, m, k))\\n            {\\n                ans = m;\\n                l = m + 1;\\n            }\\n            else\\n                h = m - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThanks!",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool isPossible(vector<int> &p, int minDist, int k)\\n    {\\n        int take = 1; \\n        int lastCowPosition = p[0];\\n        for (int i = 1; i < p.size(); i++)\\n        {\\n            if (p[i] - lastCowPosition >= minDist)\\n            {\\n                take++;\\n                lastCowPosition = p[i];\\n                if (take >= k)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int maximumTastiness(vector<int> &p, int k)\\n    {\\n        int n = p.size();\\n        sort(p.begin(), p.end());\\n        int l = 1, h = p[n - 1] - p[0];\\n        int ans = 0;\\n        while (l <= h)\\n        {\\n            int m = (l + h) / 2;\\n            if (isPossible(p, m, k))\\n            {\\n                ans = m;\\n                l = m + 1;\\n            }\\n            else\\n                h = m - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949714,
                "title": "i-tried-to-explain-the-solution-its-binary-search-but-why-we-think-of-binary-search-explained",
                "content": "**DO UPVOTE FOR MORE SUCH CONTENTS**\\n\\n# Complexity\\n- Time complexity:\\n**O(nLogn)**\\n\\n- Space complexity:\\n**No extra space taken so constant**\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int maxGap = price[price.length - 1] - price[0]; //array is sorted this will give the maximum difference b/w max and min value\\n        int minGap = 0; //obviously minimum gap between the highest and lowerst is 0\\n        int ans = 0;\\n        while(minGap<= maxGap){\\n            int midGap = minGap + (maxGap - minGap) / 2; // get the mid gap in the price \\n            if(help(price , midGap , k)){ // use a helper function which returns true of false . I will explain below why we use that here\\n                ans = midGap; // when ans = midGap , it means ans having the minimum gap because thats only returned from the helper function. Now check for others \\n                minGap = midGap + 1;\\n            }else {\\n                maxGap = midGap - 1; //ans doesnt have the minimum gap so check left of the array becasue there only less value price.\\n            }\\n\\n        }\\n        return ans; // return the ans\\n    }\\n    boolean help(int[] price , int gapPrice , int k ){  // so basic idea of using this helper function to decide when we are getting the minimum gap between two prices inside the array.\\n        int count = 1;  // this if for counting . Starts from 1 becasue price[0] is the minimum and we are starting from i = 1.\\n        int lastMin = price[0];\\n\\n        for(int i = 1 ; i < price.length ; i++){\\n            if(price[i] - lastMin >= gapPrice){ // now count for gaps greater than our mid gap \\n                count++;\\n                lastMin = price[i];\\n            }\\n        }\\n        return count >= k; // if count exeeds the k then its true otherwise false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int maxGap = price[price.length - 1] - price[0]; //array is sorted this will give the maximum difference b/w max and min value\\n        int minGap = 0; //obviously minimum gap between the highest and lowerst is 0\\n        int ans = 0;\\n        while(minGap<= maxGap){\\n            int midGap = minGap + (maxGap - minGap) / 2; // get the mid gap in the price \\n            if(help(price , midGap , k)){ // use a helper function which returns true of false . I will explain below why we use that here\\n                ans = midGap; // when ans = midGap , it means ans having the minimum gap because thats only returned from the helper function. Now check for others \\n                minGap = midGap + 1;\\n            }else {\\n                maxGap = midGap - 1; //ans doesnt have the minimum gap so check left of the array becasue there only less value price.\\n            }\\n\\n        }\\n        return ans; // return the ans\\n    }\\n    boolean help(int[] price , int gapPrice , int k ){  // so basic idea of using this helper function to decide when we are getting the minimum gap between two prices inside the array.\\n        int count = 1;  // this if for counting . Starts from 1 becasue price[0] is the minimum and we are starting from i = 1.\\n        int lastMin = price[0];\\n\\n        for(int i = 1 ; i < price.length ; i++){\\n            if(price[i] - lastMin >= gapPrice){ // now count for gaps greater than our mid gap \\n                count++;\\n                lastMin = price[i];\\n            }\\n        }\\n        return count >= k; // if count exeeds the k then its true otherwise false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533887,
                "title": "java-easy-binary-search-on-answers",
                "content": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int low=0;\\n        int high=price[price.length-1];\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isValid(mid,price,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean isValid(int target,int[] price,int k){\\n        int prev=price[0];\\n        int cnt=1;\\n        for(int i=1;i<price.length;i++){\\n            if(price[i]-prev>=target){\\n                cnt++;\\n                prev=price[i];\\n            }\\n        }\\n        if(cnt>=k)\\n            return true;\\n        return false;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/d4f9a7fb-3057-4de1-872d-efc73ab9b224_1684313355.557726.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int low=0;\\n        int high=price[price.length-1];\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isValid(mid,price,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean isValid(int target,int[] price,int k){\\n        int prev=price[0];\\n        int cnt=1;\\n        for(int i=1;i<price.length;i++){\\n            if(price[i]-prev>=target){\\n                cnt++;\\n                prev=price[i];\\n            }\\n        }\\n        if(cnt>=k)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948016,
                "title": "binary-search-nlogn-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: N*log(N)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] arr, int k) {\\n        Arrays.sort(arr);\\n        \\n        int n = arr.length;\\n        int s = 0;  // minimum possible is 0\\n        int e = arr[n-1]-arr[0];  // maximum it can be (max-min of array)\\n        \\n        while(e-s>1){\\n            int m = (s+e)/2;  // calculating mid\\n            if(check(arr,k,m)){ \\n                // we can have more elements than k with mid (in terms of absolute difference)\\n                s = m;\\n            }\\n            else{\\n                // not possible to have k elements with mid\\n                e = m-1;\\n            }\\n        }\\n\\n        // returning answer (first we will check greater because we need maximum)\\n        if(check(arr,k,e)) return e;\\n        return s;\\n    }\\n    \\n    public boolean check(int[] arr,int k,int m){\\n        if(arr[arr.length-1]-arr[0]<m) return false;\\n\\n        int cnt = 1;\\n        int pre = arr[0];\\n        // starting from 0th index we will go to next element which is greater than arr[0]+m ... and will increase count.\\n// doing that till we reach to the end.\\n\\n        for(int i = 1;i<arr.length;i++){\\n            // here pre store prev element which we have used.\\n            if(arr[i]-pre>=m){\\n                pre = arr[i];\\n                cnt++;\\n            }\\n        }        \\n\\n        //checking if we have more than k elements or not.\\n        return cnt>=k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] arr, int k) {\\n        Arrays.sort(arr);\\n        \\n        int n = arr.length;\\n        int s = 0;  // minimum possible is 0\\n        int e = arr[n-1]-arr[0];  // maximum it can be (max-min of array)\\n        \\n        while(e-s>1){\\n            int m = (s+e)/2;  // calculating mid\\n            if(check(arr,k,m)){ \\n                // we can have more elements than k with mid (in terms of absolute difference)\\n                s = m;\\n            }\\n            else{\\n                // not possible to have k elements with mid\\n                e = m-1;\\n            }\\n        }\\n\\n        // returning answer (first we will check greater because we need maximum)\\n        if(check(arr,k,e)) return e;\\n        return s;\\n    }\\n    \\n    public boolean check(int[] arr,int k,int m){\\n        if(arr[arr.length-1]-arr[0]<m) return false;\\n\\n        int cnt = 1;\\n        int pre = arr[0];\\n        // starting from 0th index we will go to next element which is greater than arr[0]+m ... and will increase count.\\n// doing that till we reach to the end.\\n\\n        for(int i = 1;i<arr.length;i++){\\n            // here pre store prev element which we have used.\\n            if(arr[i]-pre>=m){\\n                pre = arr[i];\\n                cnt++;\\n            }\\n        }        \\n\\n        //checking if we have more than k elements or not.\\n        return cnt>=k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948042,
                "title": "python3-sorting-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        if k == 0:\\n            return 0\\n        price.sort()\\n        def isValid(num):\\n            n = len(price)\\n            cnt = 1\\n            diff = price[0] + num\\n            for i in range(1,n):\\n                if price[i] >= diff:\\n                    diff = price[i] + num\\n                    cnt += 1\\n                else:\\n                    continue\\n            return cnt\\n        low,high = 0,max(price) - min(price)\\n        ans = -1\\n        while low <= high:\\n            mid = (low + high) >> 1\\n            if isValid(mid) >= k:\\n                ans = mid\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        if k == 0:\\n            return 0\\n        price.sort()\\n        def isValid(num):\\n            n = len(price)\\n            cnt = 1\\n            diff = price[0] + num\\n            for i in range(1,n):\\n                if price[i] >= diff:\\n                    diff = price[i] + num\\n                    cnt += 1\\n                else:\\n                    continue\\n            return cnt\\n        low,high = 0,max(price) - min(price)\\n        ans = -1\\n        while low <= high:\\n            mid = (low + high) >> 1\\n            if isValid(mid) >= k:\\n                ans = mid\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949144,
                "title": "cpp-bs-space-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search on answer and check for the maximum possible answer which satisfies the condition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: `O(klog(n)*log(1e9))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool helper(vector<int> &v, int k, int m) {\\n        int val = v[0],idx = 0;\\n        for(int i=0;i<k-1;i++) {\\n            auto it = lower_bound(v.begin()+idx,v.end(),val + m);\\n            if(it == v.end()) return false;\\n            idx = it - v.begin();\\n            val = *it;\\n        }\\n        return true;\\n    }\\n    int maximumTastiness(vector<int>& v, int k) {\\n        sort(v.begin(),v.end());\\n        int l = 1,r = 1e9 , ans = 0;\\n        while(r >= l) {\\n            int m = (l + r)/2;\\n            if(helper(v,k,m)) {\\n                ans = m;\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool helper(vector<int> &v, int k, int m) {\\n        int val = v[0],idx = 0;\\n        for(int i=0;i<k-1;i++) {\\n            auto it = lower_bound(v.begin()+idx,v.end(),val + m);\\n            if(it == v.end()) return false;\\n            idx = it - v.begin();\\n            val = *it;\\n        }\\n        return true;\\n    }\\n    int maximumTastiness(vector<int>& v, int k) {\\n        sort(v.begin(),v.end());\\n        int l = 1,r = 1e9 , ans = 0;\\n        while(r >= l) {\\n            int m = (l + r)/2;\\n            if(helper(v,k,m)) {\\n                ans = m;\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324639,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        long long i=0,j=price[price.size()-1]-price[0];\\n        long long ans=0;\\n        while(i<=j){\\n            long long mid=(i+j)/2;\\n            long long t=1;\\n            long long la=price[0];\\n            for(int i=1;i<price.size();i++){\\n                if(price[i]-la>=mid){\\n                    la=price[i];\\n                    t++;\\n                }\\n            }\\n            if(t>=k){\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else j=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/c47464e6-6f0d-4dfa-81e3-f3969444689e_1679405588.5155592.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        long long i=0,j=price[price.size()-1]-price[0];\\n        long long ans=0;\\n        while(i<=j){\\n            long long mid=(i+j)/2;\\n            long long t=1;\\n            long long la=price[0];\\n            for(int i=1;i<price.size();i++){\\n                if(price[i]-la>=mid){\\n                    la=price[i];\\n                    t++;\\n                }\\n            }\\n            if(t>=k){\\n                ans=mid;\\n                i=mid+1;\\n            }\\n            else j=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265582,
                "title": "binary-search-easy-c-solution",
                "content": "``` \\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        vector<int>diff;\\n        diff.resize(price.size());\\n        for(int i=price.size()-1;i>0;i--){\\n            diff.push_back(price[i]-price[i-1]);\\n        }\\n        int start=0,end=price.back()-price[0];\\n        while(start<=end){\\n            int mid=start + (end-start)/2;\\n            int curr=0,nums=0;\\n            for(auto &i:diff){\\n                curr+=i;\\n                if(curr>=mid){\\n                    curr=0;\\n                    nums++;\\n                }\\n            }\\n            if(nums>=k-1)\\n                start=mid+1;\\n            else\\n                end=mid-1;\\n        }\\n        return end;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        vector<int>diff;\\n        diff.resize(price.size());\\n        for(int i=price.size()-1;i>0;i--){\\n            diff.push_back(price[i]-price[i-1]);\\n        }\\n        int start=0,end=price.back()-price[0];\\n        while(start<=end){\\n            int mid=start + (end-start)/2;\\n            int curr=0,nums=0;\\n            for(auto &i:diff){\\n                curr+=i;\\n                if(curr>=mid){\\n                    curr=0;\\n                    nums++;\\n                }\\n            }\\n            if(nums>=k-1)\\n                start=mid+1;\\n            else\\n                end=mid-1;\\n        }\\n        return end;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948043,
                "title": "another-aggressive-cows-inspired-problem",
                "content": "```\\nbool ispossible(int n, int k, vector<int> &stalls, int dist) {\\n\\n        int coord = stalls[0];\\n\\n        int cnt = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (stalls[i] - coord >= dist) {\\n                cnt++;\\n                coord = stalls[i];\\n            }\\n\\n            if (cnt == k) return true;\\n        }\\n        return false;\\n    }\\n\\n    int maxi(vector<int>& s, int k) {\\n        int n=s.size();\\n        sort(s.begin(),s.end());\\n        int low=1;\\n        int high=s[n-1]-s[0];\\n\\n        while(low<=high)\\n        {\\n            int mid=(low+high)>>1;\\n            if(ispossible(n,k,s,mid)) low=mid+1;\\n            else high=mid-1;\\n        }\\n        return high;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        return maxi(price, k);  \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool ispossible(int n, int k, vector<int> &stalls, int dist) {\\n\\n        int coord = stalls[0];\\n\\n        int cnt = 1;\\n\\n        for (int i = 1; i < n; i++) {\\n            if (stalls[i] - coord >= dist) {\\n                cnt++;\\n                coord = stalls[i];\\n            }\\n\\n            if (cnt == k) return true;\\n        }\\n        return false;\\n    }\\n\\n    int maxi(vector<int>& s, int k) {\\n        int n=s.size();\\n        sort(s.begin(),s.end());\\n        int low=1;\\n        int high=s[n-1]-s[0];\\n\\n        while(low<=high)\\n        {\\n            int mid=(low+high)>>1;\\n            if(ispossible(n,k,s,mid)) low=mid+1;\\n            else high=mid-1;\\n        }\\n        return high;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        return maxi(price, k);  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3654385,
                "title": "binary-search-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& v, int k) {\\n        sort(v.begin(),v.end());\\n        int n = v.size();\\n        int mn = 0, mx = v[n-1],mid,i,j,x,ans;\\n        while(mn <= mx){\\n            mid = (mx-mn)/2+mn;\\n            i = 0, j = 0, x = 1;\\n            for(i = 0; i < n; i++){\\n                if(v[i]-v[j]>=mid){\\n                    x++;\\n                    j = i;\\n                }\\n            }\\n            if(x>=k){\\n                ans = mid;\\n                mn = mid+1;\\n            }else{\\n                mx = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& v, int k) {\\n        sort(v.begin(),v.end());\\n        int n = v.size();\\n        int mn = 0, mx = v[n-1],mid,i,j,x,ans;\\n        while(mn <= mx){\\n            mid = (mx-mn)/2+mn;\\n            i = 0, j = 0, x = 1;\\n            for(i = 0; i < n; i++){\\n                if(v[i]-v[j]>=mid){\\n                    x++;\\n                    j = i;\\n                }\\n            }\\n            if(x>=k){\\n                ans = mid;\\n                mn = mid+1;\\n            }else{\\n                mx = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568104,
                "title": "python-binary-search-on-answers-o-nlogn-nlogm",
                "content": "# Intuition\\nIf we sort an array it becomes clear that the first $$n-1$$ minimal differences lie between neighbors (there is a less difference with neighbor than with an element next to neighbor). We can use that observation to built some backet of candies. How to decide which candies we need to put in backet? What if we somehow get the target tastiness and then we can make a backet with candies that have tastiness not less than target.\\n\\nGiven an array `price = [1,3,1]`. Consider a few edge cases:\\n- We want to find backet with maximum possible tastiness, **which is 2 because max difference is always between min and max price**. We take 2 candies with prices 1 and 3. The difference between their prices is 2.\\n- We want to find basket with minimum possible tastiness, **which is 0 because candies have same price**. We take 2 candies with price 1, difference - 0.\\n\\nIt looks like we have some boundaries and now we can apply binary search on answers here to check different found backets with specified tastiness. If we do not find enough candies in our backet we need to loosen the condition and try to choose candies with a smaller difference. Otherwise, we need to make the condition stricter and try to choose candies with a bigger difference.\\n\\n# Approach\\n1. Sort array of prices\\n2. Run binary search on possible answers, in the range from `0` to `max possible difference`\\n    - `0`, bacause it is possible to have 2 equal price in array (diff = 0)\\n    - `max possible difference`, which is `max_price - min_price`\\n3. On each iteration: \\n    1. check with how many candies can we make a backet so that the tastiness is at least the specified (our mid calculated for binary search)\\n    1. compare size of built backet with `k`. If we can reach required number of candies then move left boundary to the right (make the condition more strict). Otherwise, move right boundary to the left (make the condition more weak).\\n\\n# Complexity\\n- Time complexity:\\n$$O(NlogN + NlogM)$$, where $$N$$ - number of candies, $$M$$ - maximum possible difference between any 2 candies.\\n\\n- Space complexity:\\n$$O(logN)$$, where $$N$$ - number of candies. Because of sorting, if we assume that sort is quicksort algorithm.\\n\\n# Code\\n```\\nclass Solution:\\n    # Binary search by range of tastiness (range of possible differences)\\n    # Time: O(NlogN + NlogM), where N - number of candies, M - maximum possible difference between any 2 candies\\n    # Space: O(logn), for sorting if we assume sort is quicksort algorithm\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        \\n        def find_at_least_tastiness_backet(min_tastiness):\\n            # goal: find backet with tastiness >= min_tastiness\\n\\n            # place 1st candy to basket\\n            # we always place candy w/ min price coz it give us bigger differences\\n            last = price[0]\\n            cnt = 1\\n\\n            # try to find next candy w/ difference between pair >= min_tastiness\\n            for i in range(1, len(price)):\\n                if price[i] - last >= min_tastiness: # found next candy for backet\\n                    cnt += 1 # place candy to backet\\n                    # doesn\\'t make any sense to check [:i] candies\\n                    # coz it will give us smaller diff between \\n                    # current and max found price (=last)\\n                    # so we continue to search diff starting from last found candy\\n                    last = price[i]\\n            return cnt\\n\\n        left = 0 # min possible difference (when 2 nums are equal)\\n        right = price[-1] - price[0] # max possble difference\\n        ans = 0\\n        while left <= right:\\n            mid = left + (right - left) // 2 # potential target tastiness\\n            if find_at_least_tastiness_backet(mid) >= k:\\n                left = mid + 1  # we found more candies than needed, let\\'s try increase our found result, increase target tastiness of backet (assuming to find reach with less candies)\\n                ans = mid\\n            else:\\n                right  = mid - 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    # Binary search by range of tastiness (range of possible differences)\\n    # Time: O(NlogN + NlogM), where N - number of candies, M - maximum possible difference between any 2 candies\\n    # Space: O(logn), for sorting if we assume sort is quicksort algorithm\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        \\n        def find_at_least_tastiness_backet(min_tastiness):\\n            # goal: find backet with tastiness >= min_tastiness\\n\\n            # place 1st candy to basket\\n            # we always place candy w/ min price coz it give us bigger differences\\n            last = price[0]\\n            cnt = 1\\n\\n            # try to find next candy w/ difference between pair >= min_tastiness\\n            for i in range(1, len(price)):\\n                if price[i] - last >= min_tastiness: # found next candy for backet\\n                    cnt += 1 # place candy to backet\\n                    # doesn\\'t make any sense to check [:i] candies\\n                    # coz it will give us smaller diff between \\n                    # current and max found price (=last)\\n                    # so we continue to search diff starting from last found candy\\n                    last = price[i]\\n            return cnt\\n\\n        left = 0 # min possible difference (when 2 nums are equal)\\n        right = price[-1] - price[0] # max possble difference\\n        ans = 0\\n        while left <= right:\\n            mid = left + (right - left) // 2 # potential target tastiness\\n            if find_at_least_tastiness_backet(mid) >= k:\\n                left = mid + 1  # we found more candies than needed, let\\'s try increase our found result, increase target tastiness of backet (assuming to find reach with less candies)\\n                ans = mid\\n            else:\\n                right  = mid - 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412068,
                "title": "95-faster-c-short-sweet-easy-to-understand-binary-search",
                "content": "````\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& v, int k) {\\n        int n = v.size();\\n        sort(v.begin(),v.end());\\n        int mn = 0, mx = v[n-1],mid,ans,tmp,x,i;\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;//if mid is ans than calculate no of candy will be shall\\n            tmp = 1;\\n            x = v[0];\\n            for(i = 0; i < n; i++){\\n                if(v[i]-x>=mid){\\n                    tmp++;\\n                    x = v[i];\\n                }\\n            }\\n\\t\\t\\t//tmp equal to no of candy which is sell\\n            if(tmp==k){//tmp == k than try to maximize our ans\\n                ans = mid;\\n                mn = mid+1;\\n            }else if(tmp>k){//tmp > k than try to maximize our ans\\n                ans = mid;\\n                mn = mid+1;\\n            }else{//minimize ans\\n                mx = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& v, int k) {\\n        int n = v.size();\\n        sort(v.begin(),v.end());\\n        int mn = 0, mx = v[n-1],mid,ans,tmp,x,i;\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;//if mid is ans than calculate no of candy will be shall\\n            tmp = 1;\\n            x = v[0];\\n            for(i = 0; i < n; i++){\\n                if(v[i]-x>=mid){\\n                    tmp++;\\n                    x = v[i];\\n                }\\n            }\\n\\t\\t\\t//tmp equal to no of candy which is sell\\n            if(tmp==k){//tmp == k than try to maximize our ans\\n                ans = mid;\\n                mn = mid+1;\\n            }else if(tmp>k){//tmp > k than try to maximize our ans\\n                ans = mid;\\n                mn = mid+1;\\n            }else{//minimize ans\\n                mx = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952456,
                "title": "java-solution-binary-search-and-greedy-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe challenging part is how to select candies and how to calculate the smallest absolute difference of the prices of any two candies in basket.\\n\\nIf doing brute force, the combinations that need to calculate is n!/(k!*(n - k)!), which grows exponentially, and is obviously not an effectively solution.\\n\\nThen we can use greedy algorithm to select candies and also calculate the \"tastiness\".\\n\\nBecause we need to calculate difference between different candies, and **sorted price has adjacent difference that contributes to the smallest difference among all combinations of pairs, then sort the price array!**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst sort the array of price. Then differences between adjacent elements contribute to \"the smallest absolute difference between any two candies in the basket\". **Any difference between one current candy and any previous non-adjacent candy is larger than adjacent difference (of current candy).**\\n\\nSo that we start from minimum price and iterate all other prices until the difference is larger than targetTastiness, then we start the same process again. If there are k pairs, we found one good tastiness value, otherwise, this tastiness value is too large, and we need to decrease its value.\\n\\nNow we can do binary search to find what is the maximum tastiness.\\n\\n# Complexity\\nLet length of price be n and maximum of price be maxPrice.\\nBinary search has log(maxPrice) operations and each binary operation must iterate all n prices. \\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*log(maxPrice)).\\n\\nWe only use constant auxiliary space.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1).\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        int n = price.length;\\n        Arrays.sort(price);\\n        int left = 0;\\n        int right = 1000000000;\\n        while (left < right - 1) {\\n            int mid = left + (right - left) / 2;\\n            if (tasty(price, mid, k)) {\\n                left = mid;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        if (tasty(price, right, k)) {\\n            return right;\\n        }\\n        return left;\\n    }\\n    private boolean tasty(int[] price, int target, int k) {\\n        int prev = price[0];\\n        int count = 1;\\n        int index = 1;\\n        while (count < k && index < price.length) {\\n            if (price[index] - prev >= target) {\\n                prev = price[index];\\n                count++;\\n            }\\n            index++;\\n        }\\n        return count == k;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        int n = price.length;\\n        Arrays.sort(price);\\n        int left = 0;\\n        int right = 1000000000;\\n        while (left < right - 1) {\\n            int mid = left + (right - left) / 2;\\n            if (tasty(price, mid, k)) {\\n                left = mid;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        if (tasty(price, right, k)) {\\n            return right;\\n        }\\n        return left;\\n    }\\n    private boolean tasty(int[] price, int target, int k) {\\n        int prev = price[0];\\n        int count = 1;\\n        int index = 1;\\n        while (count < k && index < price.length) {\\n            if (price[index] - prev >= target) {\\n                prev = price[index];\\n                count++;\\n            }\\n            index++;\\n        }\\n        return count == k;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948829,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> v, int m, int k)\\n    {\\n        int c=1;\\n        int p=v[0];\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(v[i]-p >=m)\\n            {\\n                c++;\\n                p=v[i];\\n            }\\n            if(c==k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& stalls, int k) {\\n        int n=stalls.size();\\n        sort(stalls.begin(), stalls.end());\\n        int l=0;\\n        int h=stalls[n-1]-stalls[0];\\n        while(l<=h)\\n        {\\n            int m=(l+h)/2;\\n            if(check(stalls, m, k))\\n                l=m+1;\\n            else\\n                h=m-1;\\n        }\\n        return h;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> v, int m, int k)\\n    {\\n        int c=1;\\n        int p=v[0];\\n        for(int i=1;i<v.size();i++)\\n        {\\n            if(v[i]-p >=m)\\n            {\\n                c++;\\n                p=v[i];\\n            }\\n            if(c==k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& stalls, int k) {\\n        int n=stalls.size();\\n        sort(stalls.begin(), stalls.end());\\n        int l=0;\\n        int h=stalls[n-1]-stalls[0];\\n        while(l<=h)\\n        {\\n            int m=(l+h)/2;\\n            if(check(stalls, m, k))\\n                l=m+1;\\n            else\\n                h=m-1;\\n        }\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948038,
                "title": "binary-search-nlogn-c",
                "content": "```cpp\\n#define ll long long\\nclass Solution {\\npublic:\\n    static bool f(vector<int>&v,ll int want,ll int k)\\n    {\\n        ll int have=0,var=1,prev=v[0];\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i]-prev>=want)\\n            {\\n                var++;\\n                prev=v[i];\\n            }\\n        }\\n        return var>=k;\\n    }\\n    int maximumTastiness(vector<int>& v, int k) {\\n        sort(v.begin(),v.end());\\n        ll int l=0,r=1e9,ans=0;\\n        while(l<=r)\\n        {\\n            ll int mid=(l+r)/2;\\n            if(f(v,mid,k))\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```cpp\\n#define ll long long\\nclass Solution {\\npublic:\\n    static bool f(vector<int>&v,ll int want,ll int k)\\n    {\\n        ll int have=0,var=1,prev=v[0];\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(v[i]-prev>=want)\\n            {\\n                var++;\\n                prev=v[i];\\n            }\\n        }\\n        return var>=k;\\n    }\\n    int maximumTastiness(vector<int>& v, int k) {\\n        sort(v.begin(),v.end());\\n        ll int l=0,r=1e9,ans=0;\\n        while(l<=r)\\n        {\\n            ll int mid=(l+r)/2;\\n            if(f(v,mid,k))\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894032,
                "title": "100-beats-binary-search-greedy-well-explained",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have been given some candies and we have to find the maximum tastiness of some group of tastes.\\n*(Given)-Taste is the minimum difference in the group of any k candies.*\\nTo form k groups of n given candies is a very time taking task. So we guess an answer. How?\\nFirstly, let\\'s focus on finding the maximum taste. Assume you have been already given the tastes and you have to **SEARCH** the maximum among all.\\n**BINARY SEARCH** can do that efficiently.\\nSo we take a lower limit (lowest maximum tastiness) and a higher limit( highest maximum tastiness ). Find the mid( Assumed maximum tastiness), and check if or not there exist k candies such that they have a minimum differece which equals our assumed maximum taste. But How?\\nThink greedily we have to find k numbers whose absolute difference is greater or equal to our assumed answer. We can traverse through the array setting price[0] as our initial candy, and start finding for k-1 differences among the candies. \\nIf such group exists, that **MIGHT BE THE ANSWER** , as initially we assumed it, the real answer may be greater than this assumed one, so store this answer if it returns true and set the lower bound next to the assumed one.\\nBut if no such group exists, set the higher bound to mid.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool findCandies(int taste, vector<int>& price, int k){\\n        int prevCandy=price[0];\\n        for(int i=1;i<price.size();i++){\\n            if(!k)  return 1;\\n            if(abs(prevCandy-price[i])>=taste)   prevCandy=price[i],k--;\\n        }\\n        return  k<=0;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        sort(price.begin(),price.end());\\n        int l=0,h=price[price.size()-1],ans=0;\\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n            if(findCandies(mid,price,k-1)){\\n                ans=max(ans,mid);\\n                l=mid+1;\\n            }\\n            else    h=mid;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease consider upvoting, if you liked the post.\\u270C\\uFE0F",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool findCandies(int taste, vector<int>& price, int k){\\n        int prevCandy=price[0];\\n        for(int i=1;i<price.size();i++){\\n            if(!k)  return 1;\\n            if(abs(prevCandy-price[i])>=taste)   prevCandy=price[i],k--;\\n        }\\n        return  k<=0;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        ios::sync_with_stdio(0);cin.tie(NULL);cout.tie(NULL);\\n        sort(price.begin(),price.end());\\n        int l=0,h=price[price.size()-1],ans=0;\\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n            if(findCandies(mid,price,k-1)){\\n                ans=max(ans,mid);\\n                l=mid+1;\\n            }\\n            else    h=mid;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3685957,
                "title": "binary-search-c-easy",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApply Binary Search on answer and sort the cost array to check is there any subset of size k with minimum difference x.\\n\\n# Complexity\\n- Time complexity:O(N*Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> arr,int dif,int k)\\n    {\\n        int count = 1,first = arr[0];\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n           if(arr[i]-first >=dif)\\n           {\\n               count++;\\n               first = arr[i];\\n           }\\n        }\\n        return count>=k;\\n    }\\n    int maximumTastiness(vector<int>& arr, int k) {\\n\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        int left = 0,right = arr[n-1]-arr[0],ans = 0;\\n        if(k==1) return arr[n-1];\\n\\n        while(left<=right)\\n        {\\n            int mid = (left+right)/2;\\n            if(check(arr,mid,k))\\n            {\\n                ans = mid;\\n                left = mid+1;\\n            }\\n            else\\n             right = mid-1;\\n        }\\n        return ans;  \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/dcd20185-f629-436d-80c4-5f768b3ff4da_1687798106.1518133.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> arr,int dif,int k)\\n    {\\n        int count = 1,first = arr[0];\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n           if(arr[i]-first >=dif)\\n           {\\n               count++;\\n               first = arr[i];\\n           }\\n        }\\n        return count>=k;\\n    }\\n    int maximumTastiness(vector<int>& arr, int k) {\\n\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        int left = 0,right = arr[n-1]-arr[0],ans = 0;\\n        if(k==1) return arr[n-1];\\n\\n        while(left<=right)\\n        {\\n            int mid = (left+right)/2;\\n            if(check(arr,mid,k))\\n            {\\n                ans = mid;\\n                left = mid+1;\\n            }\\n            else\\n             right = mid-1;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685956,
                "title": "binary-search-c-easy",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApply Binary Search on answer and sort the cost array to check is there any subset of size k with minimum difference x.\\n\\n# Complexity\\n- Time complexity:O(N*Log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> arr,int dif,int k)\\n    {\\n        int count = 1,first = arr[0];\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n           if(arr[i]-first >=dif)\\n           {\\n               count++;\\n               first = arr[i];\\n           }\\n        }\\n        return count>=k;\\n    }\\n    int maximumTastiness(vector<int>& arr, int k) {\\n\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        int left = 0,right = arr[n-1]-arr[0],ans = 0;\\n        if(k==1) return arr[n-1];\\n\\n        while(left<=right)\\n        {\\n            int mid = (left+right)/2;\\n            if(check(arr,mid,k))\\n            {\\n                ans = mid;\\n                left = mid+1;\\n            }\\n            else\\n             right = mid-1;\\n        }\\n        return ans;  \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/dcd20185-f629-436d-80c4-5f768b3ff4da_1687798106.1518133.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> arr,int dif,int k)\\n    {\\n        int count = 1,first = arr[0];\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n           if(arr[i]-first >=dif)\\n           {\\n               count++;\\n               first = arr[i];\\n           }\\n        }\\n        return count>=k;\\n    }\\n    int maximumTastiness(vector<int>& arr, int k) {\\n\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        int left = 0,right = arr[n-1]-arr[0],ans = 0;\\n        if(k==1) return arr[n-1];\\n\\n        while(left<=right)\\n        {\\n            int mid = (left+right)/2;\\n            if(check(arr,mid,k))\\n            {\\n                ans = mid;\\n                left = mid+1;\\n            }\\n            else\\n             right = mid-1;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343051,
                "title": "java-beats-100-using-binary-search-and-sortings",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n       Arrays.sort(price);\\n        int low = 0, high = Integer.MAX_VALUE, mid;\\n\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (isPossible(price, k, mid)) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    boolean isPossible(int[] price, int k, int x) {\\n        int last = price[0], count = 1, i = 1;\\n        while ( i < price.length) {\\n            if (price[i] - last >= x) {\\n                last = price[i]; count++;\\n            }\\n            i++;\\n            if(count>=k) {\\n                return true;\\n            }\\n        }\\n        return count >= k;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n       Arrays.sort(price);\\n        int low = 0, high = Integer.MAX_VALUE, mid;\\n\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (isPossible(price, k, mid)) {\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    boolean isPossible(int[] price, int k, int x) {\\n        int last = price[0], count = 1, i = 1;\\n        while ( i < price.length) {\\n            if (price[i] - last >= x) {\\n                last = price[i]; count++;\\n            }\\n            i++;\\n            if(count>=k) {\\n                return true;\\n            }\\n        }\\n        return count >= k;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963914,
                "title": "binary-search-on-answer-concept",
                "content": "We have always heard that whenever we see a sorted array we should think of binary search but what if i say you can still go for binary search if the array is not sorted. so the thing is when the array is sorted we check our value with the mid and then compare it with mid and then decide which part to select and which part to reject.\\n\\nThis question is similar to the famous problem aggresive cows.\\n\\nQuestion\\n\\nGiven an array of length \\u2018N\\u2019, where each element denotes the position of a stall. Now you have \\u2018N\\u2019 stalls and an integer \\u2018K\\u2019 which denotes the number of cows that are aggressive. To prevent the cows from hurting each other, you need to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. Return the largest minimum distance.\\n\\n\\nLogic:\\n\\n\\nWe need to define a isPossible() function that checks if a distance x is possible between each of the cows. We can use a greedy approach here by placing cows at the leftmost possible stalls such that they are at least x distance away from the last-placed cow.\\nWe need to sort the given array/list so once we have our sorted array to do the greedy task then we can apply the Binary Search algorithm on the sorted input, and use our function isPossible( ) to find the largest distance possible.\\n\\n\\nNote : we have to first sort the array.\\n\\nBlock 1:-\\n Here we have to check  all the values of the difference which are possible , so that we can get the largest min possible differene .\\nThe range of difference bw the position  of cows will be [1 , max_diff].\\nwhere max diff is :-\\nmax_diff = max_val in array - min_val in  array.\\n\\nBut we can not check for every possible difference. as it would be of complexity n^2. so instead we check only for some valide values .The values can be selected  via binary search . And as we have to get the max value , we try to maximize till the base condition  of the search is not reached .\\n \\n\\nBlock 2:-\\nThis block is used to check the if the given difference is possible/ valid or not .and return true or false to the called function .\\nThe updation of the value of difference go on simultaneously.\\n\\n\\ncode\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& stalls, int k) {\\n        \\n        int n = stalls.size();\\n          sort(stalls.begin(), stalls.end());\\n\\n        \\n\\n        int start = 0;\\n\\n        int end = 1e9;\\n\\n        \\n\\n        int ans = -1;\\n\\n        \\n\\n        int mid = start +(end - start)/2;\\n\\n        \\n\\n        while(start <= end){\\n\\n            if(isPossible(n, k, stalls , mid)){\\n\\n                ans = mid;\\n\\n                start = mid +1;\\n\\n            }\\n\\n            else{\\n\\n                end = mid - 1;\\n\\n            }\\n\\n            \\n\\n            mid = start +(end - start)/2;\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n   \\n\\n    bool isPossible(int n, int k , vector<int>& stalls, int mid){\\n\\n        \\n\\n        int cowCount = 1;\\n\\n        int lastPos = stalls[0];\\n\\n        \\n\\n        for(int i=0; i<n; i++){\\n\\n            \\n\\n            if(stalls[i] - lastPos >= mid){\\n\\n                cowCount ++;\\n\\n                \\n\\n                if(cowCount == k){\\n\\n                    return true;\\n\\n                }\\n\\n                \\n\\n                lastPos = stalls[i];\\n\\n            }\\n\\n        }\\n\\n        return false;\\n\\n    }\\n\\n \\n\\n    \\n\\n};\\n```\\n\\nCheck function\\nStep 1: put a cow in the 1st stall and set counter to 1.\\nStep 2: then run a loop from 1 to less than n.\\ninside the loop\\n  Step 3: if the distance between I\\u2019th stall and the previous taken stall is >= X \\n  Step 4: take the stall and increase the counter.\\n  Step 5: if counter == k return true\\nloop end\\nStep 6: return false.\\n\\n\\nIn the solve function \\nStep 1: Sort the stalls.\\nStep 2: Set high = distance between 1st stall and the last stall.\\nStep 3: Run a loop while low <= high\\ninside the loop\\n Step 4: Set mid = (high+low)/2;\\n Step 5: check if we can keep the cows at a minimum distance of mid or not. If yes, update the low  = mid+1\\n Step 6: update high  = mid-1;\\nloop end\\nreturn high\\n\\n\\nComplexity\\n\\nTime Complexity:\\nAs we are doing binary search over the answer, and the range of answer is 1 to 10^9 , so it takes O(log2(10^9)) ~ O(30). For each mid we are traversing the full stalls vector of size N, so it takes O(N) time. So the time complexity is O(30*N).\\n\\nSpace Complexity:\\n\\nAs we are not using any extra space so the space complexity is O(1).",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& stalls, int k) {\\n        \\n        int n = stalls.size();\\n          sort(stalls.begin(), stalls.end());\\n\\n        \\n\\n        int start = 0;\\n\\n        int end = 1e9;\\n\\n        \\n\\n        int ans = -1;\\n\\n        \\n\\n        int mid = start +(end - start)/2;\\n\\n        \\n\\n        while(start <= end){\\n\\n            if(isPossible(n, k, stalls , mid)){\\n\\n                ans = mid;\\n\\n                start = mid +1;\\n\\n            }\\n\\n            else{\\n\\n                end = mid - 1;\\n\\n            }\\n\\n            \\n\\n            mid = start +(end - start)/2;\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n   \\n\\n    bool isPossible(int n, int k , vector<int>& stalls, int mid){\\n\\n        \\n\\n        int cowCount = 1;\\n\\n        int lastPos = stalls[0];\\n\\n        \\n\\n        for(int i=0; i<n; i++){\\n\\n            \\n\\n            if(stalls[i] - lastPos >= mid){\\n\\n                cowCount ++;\\n\\n                \\n\\n                if(cowCount == k){\\n\\n                    return true;\\n\\n                }\\n\\n                \\n\\n                lastPos = stalls[i];\\n\\n            }\\n\\n        }\\n\\n        return false;\\n\\n    }\\n\\n \\n\\n    \\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959650,
                "title": "c-most-easy-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int> &price,int k)\\n    {\\n        int s=0;\\n        int len=1;\\n        for(int k=1;k<price.size();k++)\\n        {\\n            if(price[k]-price[s]>=mid)//if differences between consecutive values greater than\\n            {                         //equal to mid then incrementing length and if length>=k then value possibe\\n                s=k;\\n                len++;\\n            }\\n        }\\n      return len>=k;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        int n=price.size();\\n        int s=0,e=price[n-1]-price[0];//s->min difference(if all array elements same)\\n        //e->max difference\\n        int ans=0;\\n        while(s<=e)//binary search\\n        {\\n           int mid=s+(e-s)/2;\\n           if(check(mid,price,k))\\n           {\\n               ans=mid;\\n               s=mid+1;\\n              \\n           }\\n            else\\n                e=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int> &price,int k)\\n    {\\n        int s=0;\\n        int len=1;\\n        for(int k=1;k<price.size();k++)\\n        {\\n            if(price[k]-price[s]>=mid)//if differences between consecutive values greater than\\n            {                         //equal to mid then incrementing length and if length>=k then value possibe\\n                s=k;\\n                len++;\\n            }\\n        }\\n      return len>=k;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        int n=price.size();\\n        int s=0,e=price[n-1]-price[0];//s->min difference(if all array elements same)\\n        //e->max difference\\n        int ans=0;\\n        while(s<=e)//binary search\\n        {\\n           int mid=s+(e-s)/2;\\n           if(check(mid,price,k))\\n           {\\n               ans=mid;\\n               s=mid+1;\\n              \\n           }\\n            else\\n                e=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949378,
                "title": "aggresive-cows-binary-search",
                "content": "# Intuition\\naggresive cows approach \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nwe have to do only binary search with keeping count that the cows can be placed at these different positions or not.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n> \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool sol(vector<int> p , int n ,  int c,int m){\\n    int ce=p[0],cnt=1;\\n    for(int i=1;i<n;i++){\\n        if(p[i]-ce>=m){\\n            cnt++;\\n            ce=p[i];\\n        }\\n    }\\n    if(cnt>=c){\\n        return true;\\n    } else \\n        return false;\\n}\\n    int maximumTastiness(vector<int>& p, int c) {\\n        int n=p.size();\\n       sort(p.begin(),p.end());\\n    int l=1,h=p[n-1]-p[0];\\n    while(l<=h){\\n       int m=(l+h)/2;\\n        if(sol(p,n,c,m)){\\n            l=m+1;\\n        } else {\\n            h=m-1;\\n        }\\n    }\\n    return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool sol(vector<int> p , int n ,  int c,int m){\\n    int ce=p[0],cnt=1;\\n    for(int i=1;i<n;i++){\\n        if(p[i]-ce>=m){\\n            cnt++;\\n            ce=p[i];\\n        }\\n    }\\n    if(cnt>=c){\\n        return true;\\n    } else \\n        return false;\\n}\\n    int maximumTastiness(vector<int>& p, int c) {\\n        int n=p.size();\\n       sort(p.begin(),p.end());\\n    int l=1,h=p[n-1]-p[0];\\n    while(l<=h){\\n       int m=(l+h)/2;\\n        if(sol(p,n,c,m)){\\n            l=m+1;\\n        } else {\\n            h=m-1;\\n        }\\n    }\\n    return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949119,
                "title": "c-solution-why-binary-search-explanation",
                "content": "# Intuition\\nA very important realiztion that I had seeing the solution to this problem is whenever you are asked questions regarding maximizing or minimizing the difference between any 2 elements of the matrix the ideal approach is to $${{Binary\\\\ Search}}$$. At first glance a lot of approaches might pop in your mind, such as sort the list and run a 2 pointer kind of method, but that wouldn\\'t yield the right result. \\nRather if you read the question properly, it is written there is a max difference which is possible, which clearly seems like that the difference is something that we can binary search on, since binary search requires one to have a certain value that is monotonically either increasing or decreasing and the value of maximum difference is monotonically decreasing, why ? because as we keep on increasing the maximum difference our answer keeps on getting shorter and shorter.\\nOkay, so now we have got what to binary search on, but the question remains how to binary search?\\n\\n# Approach\\nThe idea is actually pretty neat : \\n 1) Sort the Input Array\\n 2) write the boiler place binary search code (lo = 0, hi = 1e9) and initialize the `mid = lo + (hi - lo)/2`. Also put ```cnt = 0 ```.\\n 3) do a looping by starting with the first element (always include it in the answer). Put ``` previousChosen = arr[0] ```.\\n 4) either check if for the next element $$a[i]\\\\ -\\\\ previousChosen \\\\ >=\\\\ mid$$. If so include it in the last and do ``` preivousChosen = a[i] ``` and increment a count pointer else continue.\\n 5) at last check if `cnt >=k` , put `ans = mid` and `hi = mid + 1`, else `lo = mid  - 1`\\n\\nPicture for ease of understanding\\n![image.png](https://assets.leetcode.com/users/images/dd4bc84a-17eb-44d3-8a0f-b5b0f142209e_1671958683.2176964.png)\\n\\n$${{green\\\\ variable\\\\ represents\\\\ the\\\\ cnt\\\\ and\\\\ red\\\\ shows\\\\ the\\\\ direction.}}$$\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlgn)$$\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int n = price.size();\\n        sort(begin(price), end(price));\\n        int lo = 0, hi = 1e9;\\n        int ans = 0;\\n        while(lo<=hi){\\n            int mid = lo +  (hi - lo)/2;\\n            int i = 0;\\n            int last = price[0];\\n            i = 1;\\n            int cnt = 1;\\n            for( ; i<n; i++){\\n                if(price[i] - last < mid){\\n                    // do nothing.\\n                }else{\\n                    ++cnt;\\n                    last = price[i];\\n                }\\n            }\\n            if(cnt >= k){\\n                ans = mid;\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1 ;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```cnt = 0 ```\n``` previousChosen = arr[0] ```\n``` preivousChosen = a[i] ```\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int n = price.size();\\n        sort(begin(price), end(price));\\n        int lo = 0, hi = 1e9;\\n        int ans = 0;\\n        while(lo<=hi){\\n            int mid = lo +  (hi - lo)/2;\\n            int i = 0;\\n            int last = price[0];\\n            i = 1;\\n            int cnt = 1;\\n            for( ; i<n; i++){\\n                if(price[i] - last < mid){\\n                    // do nothing.\\n                }else{\\n                    ++cnt;\\n                    last = price[i];\\n                }\\n            }\\n            if(cnt >= k){\\n                ans = mid;\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1 ;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948859,
                "title": "binary-search-o-nlogn-cpp-easy",
                "content": "# Topic\\nbinary search on answer \\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int K,n;\\n    vector<int>A;\\n\\n    bool ok(int m){\\n        ll c=0,nxt=0;\\n        for(int i=0;i<n;i++){\\n            if(A[i]>=nxt){\\n                c++;\\n                nxt=A[i]+m;\\n            }\\n        }\\n        return c>=K;\\n    }\\n\\n    int maximumTastiness(vector<int>& a, int k) {\\n        sort(a.begin(),a.end());\\n        A=a;K=k;n=a.size();\\n        ll l=0,r=1;\\n        while(ok(r))r=r<<1;\\n        while(r-l>1){\\n            ll mid=(l+r)>>1;\\n            if(ok(mid))l=mid;\\n            else r=mid;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int K,n;\\n    vector<int>A;\\n\\n    bool ok(int m){\\n        ll c=0,nxt=0;\\n        for(int i=0;i<n;i++){\\n            if(A[i]>=nxt){\\n                c++;\\n                nxt=A[i]+m;\\n            }\\n        }\\n        return c>=K;\\n    }\\n\\n    int maximumTastiness(vector<int>& a, int k) {\\n        sort(a.begin(),a.end());\\n        A=a;K=k;n=a.size();\\n        ll l=0,r=1;\\n        while(ok(r))r=r<<1;\\n        while(r-l>1){\\n            ll mid=(l+r)>>1;\\n            if(ok(mid))l=mid;\\n            else r=mid;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948679,
                "title": "binary-search",
                "content": "# Intuition\\nIf max or min is asked in any question. Think if it can be solve by binary search or DP.\\n\\nIn Binary Search,\\nsuppose we need to find max possible value. Then try to think if we have a value, can we find out that value is possible or not.\\nThen try to generate that values in binary search order and check if the value is possible or not.\\nIn this question that value is price difference.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort the array.\\nApply binary search on price difference with upper limit should be (max_price - min_price) and lower limit should be 0.\\nThen for each possible difference check if we can select k numbers from the sorted array with the required difference.Bi\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int n = price.length;\\n        \\n        int high = price[n - 1] - price[0];\\n        int low = 0;\\n        int ans = 0;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(isPos(price, k, n, mid)) {\\n                ans = mid;\\n                low = mid + 1;\\n            }else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean isPos(int[] price, int k, int n, int mid) {\\n        int prev = price[0];\\n        k--;\\n        for(int i = 1; i < n; i++) {\\n            if(k == 0) break;\\n            if(price[i] - prev >= mid) {\\n                prev = price[i];\\n                k--;\\n            }\\n        }\\n        return k == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int n = price.length;\\n        \\n        int high = price[n - 1] - price[0];\\n        int low = 0;\\n        int ans = 0;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(isPos(price, k, n, mid)) {\\n                ans = mid;\\n                low = mid + 1;\\n            }else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean isPos(int[] price, int k, int n, int mid) {\\n        int prev = price[0];\\n        k--;\\n        for(int i = 1; i < n; i++) {\\n            if(k == 0) break;\\n            if(price[i] - prev >= mid) {\\n                prev = price[i];\\n                k--;\\n            }\\n        }\\n        return k == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948315,
                "title": "java-100-faster-solution-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int l = price.length;\\n        int right = price[l-1]-price[0];\\n        int left = 0;\\n        int ans = 0;\\n        while(left<=right){\\n            int mid = left+(right-left)/2;\\n            if(pos(mid,price,k)){\\n                ans = mid;\\n                left = mid+1;\\n            }\\n            else right = mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean pos(int gap, int[] price , int k){\\n        int count = 1;\\n        int last = price[0];\\n        int l = price.length;\\n        for(int ind = 1; ind<l ; ind++){\\n            if(price[ind]-last>=gap){\\n                count++;\\n                last = price[ind];\\n            }\\n        }\\n        return count>=k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int l = price.length;\\n        int right = price[l-1]-price[0];\\n        int left = 0;\\n        int ans = 0;\\n        while(left<=right){\\n            int mid = left+(right-left)/2;\\n            if(pos(mid,price,k)){\\n                ans = mid;\\n                left = mid+1;\\n            }\\n            else right = mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean pos(int gap, int[] price , int k){\\n        int count = 1;\\n        int last = price[0];\\n        int l = price.length;\\n        for(int ind = 1; ind<l ; ind++){\\n            if(price[ind]-last>=gap){\\n                count++;\\n                last = price[ind];\\n            }\\n        }\\n        return count>=k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948287,
                "title": "binary-search-the-solution-time-complexity-o-nlogn",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe just need binary search on whether the number we chose could be the possible answer. If it is a possible answer, then we search whether a bigger number could be a possible answer.\\nIn CheckifPossible function, we are just finding the maximum numbers whose difference is greater than mid. If the total numbers are greater than k, then its a possible solution. Hence, we return true.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NLogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool CheckIfPossible(int mid, vector<int>&price, int k){\\n        int n = price.size();\\n        int cnt = 1;\\n        int last = price[0];\\n        for(int i = 1; i < n; i++){\\n            if(price[i] - last >= mid){\\n                cnt++;\\n                last = price[i];\\n            }\\n        }\\n        return cnt >= k;\\n    }\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int n = price.size();\\n        int low = 0;\\n        int high = price.back();\\n        int ans = -1;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(CheckIfPossible(mid, price, k)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool CheckIfPossible(int mid, vector<int>&price, int k){\\n        int n = price.size();\\n        int cnt = 1;\\n        int last = price[0];\\n        for(int i = 1; i < n; i++){\\n            if(price[i] - last >= mid){\\n                cnt++;\\n                last = price[i];\\n            }\\n        }\\n        return cnt >= k;\\n    }\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int n = price.size();\\n        int low = 0;\\n        int high = price.back();\\n        int ans = -1;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(CheckIfPossible(mid, price, k)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407455,
                "title": "binary-search-on-ans-easy-c-solution-easy-to-undersatnd",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    bool f(ll m,vector<int>& nums,int k)\\n    {\\n        int c =1;\\n        ll pre = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if((nums[i]-pre)>=m)\\n            {\\n               c++;\\n               pre = nums[i];    \\n            }\\n        }\\n        return c>=k;\\n    }\\n    int maximumTastiness(vector<int>& nums, int k) {\\n      sort(begin(nums),end(nums));\\n        ll l = 0,h = nums[nums.size()-1]-nums[0],ans=0;\\n        while(l<=h)\\n        {\\n            ll m = (l+h)/2;\\n            if(f(m,nums,k))\\n            {\\n                ans = m;\\n                l = m+1;\\n            }\\n            else\\n            h = m-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    bool f(ll m,vector<int>& nums,int k)\\n    {\\n        int c =1;\\n        ll pre = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if((nums[i]-pre)>=m)\\n            {\\n               c++;\\n               pre = nums[i];    \\n            }\\n        }\\n        return c>=k;\\n    }\\n    int maximumTastiness(vector<int>& nums, int k) {\\n      sort(begin(nums),end(nums));\\n        ll l = 0,h = nums[nums.size()-1]-nums[0],ans=0;\\n        while(l<=h)\\n        {\\n            ll m = (l+h)/2;\\n            if(f(m,nums,k))\\n            {\\n                ans = m;\\n                l = m+1;\\n            }\\n            else\\n            h = m-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100686,
                "title": "python-binary-search-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        n=len(price)\\n        price.sort()\\n        \\n        def check(x):\\n            count=1\\n            prev=price[0]\\n\\n            for i in range(1,n):\\n                if  price[i]-prev>=x:\\n                    count+=1\\n                    prev=price[i]\\n            return count>=k\\n\\n        \\n        low=0\\n        high=max(price)-min(price)\\n        ans=-1\\n        \\n        while low<=high:\\n            mid=(low+high)//2\\n            if check(mid)==True:\\n                low=mid+1\\n                ans=mid\\n            else:\\n                high=mid-1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        n=len(price)\\n        price.sort()\\n        \\n        def check(x):\\n            count=1\\n            prev=price[0]\\n\\n            for i in range(1,n):\\n                if  price[i]-prev>=x:\\n                    count+=1\\n                    prev=price[i]\\n            return count>=k\\n\\n        \\n        low=0\\n        high=max(price)-min(price)\\n        ans=-1\\n        \\n        while low<=high:\\n            mid=(low+high)//2\\n            if check(mid)==True:\\n                low=mid+1\\n                ans=mid\\n            else:\\n                high=mid-1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063926,
                "title": "unique-way-to-solve-this-problem-easy-c-implementation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool help(int mid,int k,vector<int>& price,int n)\\n    {\\n       \\n        int st=0;\\n        k-=1;\\n        while(k>0 && st<n)\\n        {\\n            \\n            int l=lower_bound(price.begin(),price.end(),price[st]+mid)-price.begin();\\n            if(l<n)\\n            {\\n                k-=1;\\n                st=l;\\n\\n            }\\n            else\\n            return false;\\n        }\\n\\n        if(k==0)\\n        return true;\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int n=price.size();\\n        sort(price.begin(),price.end());\\n        int end=price[n-1]-price[0];\\n        int start=0;\\n        int ans=0;\\n        while(start<=end)\\n        {\\n            int mid=(start+end)/2;\\n            bool is=help(mid,k,price,n);\\n           \\n            if(is)\\n            {\\n              ans=mid;\\n              start=mid+1;\\n            }\\n            else\\n            end=mid-1;\\n        }\\n     \\n        if(ans==0)\\n        return 0;\\n        vector<int> v;\\n        v.push_back(price[0]);\\n        k-=1;\\n        int j=0;\\n        while(k>0)\\n        {\\n            int ind=lower_bound(price.begin(),price.end(),v[j]+ans)-price.begin();\\n            v.push_back(price[ind]);\\n            k--;\\n            j++;\\n        }\\n        int f_ans=INT_MAX;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            f_ans=min(f_ans,v[i+1]-v[i]);\\n        }\\n        return f_ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool help(int mid,int k,vector<int>& price,int n)\\n    {\\n       \\n        int st=0;\\n        k-=1;\\n        while(k>0 && st<n)\\n        {\\n            \\n            int l=lower_bound(price.begin(),price.end(),price[st]+mid)-price.begin();\\n            if(l<n)\\n            {\\n                k-=1;\\n                st=l;\\n\\n            }\\n            else\\n            return false;\\n        }\\n\\n        if(k==0)\\n        return true;\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int n=price.size();\\n        sort(price.begin(),price.end());\\n        int end=price[n-1]-price[0];\\n        int start=0;\\n        int ans=0;\\n        while(start<=end)\\n        {\\n            int mid=(start+end)/2;\\n            bool is=help(mid,k,price,n);\\n           \\n            if(is)\\n            {\\n              ans=mid;\\n              start=mid+1;\\n            }\\n            else\\n            end=mid-1;\\n        }\\n     \\n        if(ans==0)\\n        return 0;\\n        vector<int> v;\\n        v.push_back(price[0]);\\n        k-=1;\\n        int j=0;\\n        while(k>0)\\n        {\\n            int ind=lower_bound(price.begin(),price.end(),v[j]+ans)-price.begin();\\n            v.push_back(price[ind]);\\n            k--;\\n            j++;\\n        }\\n        int f_ans=INT_MAX;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            f_ans=min(f_ans,v[i+1]-v[i]);\\n        }\\n        return f_ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050376,
                "title": "use-binary-search-on-tastiness-0-max-price-min-price",
                "content": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        \"\"\"\\n        minimum tastiness = 0\\n        maximum tastiness = maximum price - minimum price\\n        binary search on [minimum tastiness, maximum tastiness]\\n        \"\"\"\\n        price.sort()\\n        min_tastiness, max_tastiness = 0, price[-1] - price[0]\\n\\n        def is_possible_to_create_basket(taste):\\n            chosen, last_chosen = 1, price[0]\\n            for p in price[1:]:\\n                if chosen == k:\\n                    return True\\n                if p - last_chosen >= taste:\\n                    chosen+=1\\n                    last_chosen = p\\n            if chosen == k:\\n                return True\\n            return False\\n\\n\\n        def binary_search(low, high):\\n            if low > high:\\n                return high\\n            mid = (low + high) // 2\\n            if is_possible_to_create_basket(mid):\\n                return binary_search(mid+1, high)\\n            else:\\n                return binary_search(low, mid-1)\\n\\n        return binary_search(min_tastiness, max_tastiness)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        \"\"\"\\n        minimum tastiness = 0\\n        maximum tastiness = maximum price - minimum price\\n        binary search on [minimum tastiness, maximum tastiness]\\n        \"\"\"\\n        price.sort()\\n        min_tastiness, max_tastiness = 0, price[-1] - price[0]\\n\\n        def is_possible_to_create_basket(taste):\\n            chosen, last_chosen = 1, price[0]\\n            for p in price[1:]:\\n                if chosen == k:\\n                    return True\\n                if p - last_chosen >= taste:\\n                    chosen+=1\\n                    last_chosen = p\\n            if chosen == k:\\n                return True\\n            return False\\n\\n\\n        def binary_search(low, high):\\n            if low > high:\\n                return high\\n            mid = (low + high) // 2\\n            if is_possible_to_create_basket(mid):\\n                return binary_search(mid+1, high)\\n            else:\\n                return binary_search(low, mid-1)\\n\\n        return binary_search(min_tastiness, max_tastiness)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037231,
                "title": "c-rust-sort-modified-binary-search-o-nlonm-80-faster",
                "content": "**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        auto check = [&](int target, int count = 1) {\\n            for (int i = 1, j = 0; i < price.size(); i++) \\n                if (price[i] - price[j] >= target) j = i, count++;\\n            return count >= k;\\n        };\\n        auto left = 0, right = (int) price.back() - price.front() + 1;\\n        while (left < right) {\\n            auto mid = left + (right - left) / 2;\\n            if (check(mid)) left = mid + 1; else right = mid;\\n        }\\n        return left - 1;\\n    }\\n};\\n```\\n\\n**Rust**\\n```rust\\nimpl Solution {\\n    pub fn maximum_tastiness(price: Vec<i32>, k: i32) -> i32 {\\n        let mut price = price.clone();\\n        price.sort();\\n\\n        let check = |target: i32| {\\n            let (mut count, mut j) = (1, 0);\\n            for i in 1..price.len() {\\n                if price[i] - price[j] >= target {\\n                    j = i;\\n                    count += 1;\\n                }\\n            }\\n            count >= k\\n        };\\n        \\n        let (mut left, mut right) = (0, price.last().unwrap() - price.first().unwrap() + 1);\\n        while left < right {\\n            let mid = left + (right - left) / 2;\\n            if check(mid) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        left - 1\\n    }\\n}\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        auto check = [&](int target, int count = 1) {\\n            for (int i = 1, j = 0; i < price.size(); i++) \\n                if (price[i] - price[j] >= target) j = i, count++;\\n            return count >= k;\\n        };\\n        auto left = 0, right = (int) price.back() - price.front() + 1;\\n        while (left < right) {\\n            auto mid = left + (right - left) / 2;\\n            if (check(mid)) left = mid + 1; else right = mid;\\n        }\\n        return left - 1;\\n    }\\n};\\n```\n```rust\\nimpl Solution {\\n    pub fn maximum_tastiness(price: Vec<i32>, k: i32) -> i32 {\\n        let mut price = price.clone();\\n        price.sort();\\n\\n        let check = |target: i32| {\\n            let (mut count, mut j) = (1, 0);\\n            for i in 1..price.len() {\\n                if price[i] - price[j] >= target {\\n                    j = i;\\n                    count += 1;\\n                }\\n            }\\n            count >= k\\n        };\\n        \\n        let (mut left, mut right) = (0, price.last().unwrap() - price.first().unwrap() + 1);\\n        while left < right {\\n            let mid = left + (right - left) / 2;\\n            if check(mid) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        left - 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996430,
                "title": "2-line-python3-solution",
                "content": "# Intuition\\nUse reduce() with initial values to check the bisect answer.\\n\\n# Code (2-line)\\n```\\nimport bisect\\nfrom functools import reduce\\n\\nclass Solution:\\n    def maximumTastiness(self, p: List[int], k: int) -> int:\\n        p.sort()\\n        return bisect.bisect_left(range(p[-1]), 1, key = lambda m: reduce(lambda r, x: r if (x < r[0] + m) else (x, r[1] + 1), p, (p[0], 1))[1] < k) - 1\\n```\\n\\n# Code (readable)\\n```\\nimport bisect\\n\\nclass Solution:\\n    def maximumTastiness(self, p: List[int], k: int) -> int:\\n        p.sort()\\n        # This ok function can be replaced with a reduce function call:\\n        # ok = lambda m: reduce(lambda r, x: r if (x < r[0] + m) else (x, r[1] + 1), p, (p[0], 1))[1] < k\\n        def ok(m):\\n            r = (p[0], 1)\\n            for x in p[1:]:\\n                if x >= r[0] + m:\\n                    r = (x, r[1] + 1)\\n            return r[1] < k\\n        return bisect.bisect_left(range(p[-1]), 1, key = ok) - 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nimport bisect\\nfrom functools import reduce\\n\\nclass Solution:\\n    def maximumTastiness(self, p: List[int], k: int) -> int:\\n        p.sort()\\n        return bisect.bisect_left(range(p[-1]), 1, key = lambda m: reduce(lambda r, x: r if (x < r[0] + m) else (x, r[1] + 1), p, (p[0], 1))[1] < k) - 1\\n```\n```\\nimport bisect\\n\\nclass Solution:\\n    def maximumTastiness(self, p: List[int], k: int) -> int:\\n        p.sort()\\n        # This ok function can be replaced with a reduce function call:\\n        # ok = lambda m: reduce(lambda r, x: r if (x < r[0] + m) else (x, r[1] + 1), p, (p[0], 1))[1] < k\\n        def ok(m):\\n            r = (p[0], 1)\\n            for x in p[1:]:\\n                if x >= r[0] + m:\\n                    r = (x, r[1] + 1)\\n            return r[1] < k\\n        return bisect.bisect_left(range(p[-1]), 1, key = ok) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2959426,
                "title": "binary-search-greedy-c",
                "content": "```\\nclass Solution {\\n    bool good(int x, vector<int> &price, int k) {\\n        int cnt = 1, last = price[0];\\n        for(int i=1; i<price.size(); i++) {\\n            if(price[i] - last >= x) cnt++, last = price[i];\\n        }\\n        return cnt < k ? false : true;\\n    }\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int s = 0, e = 1e9, ans = INT_MIN;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, price, k)) ans = max(ans, m), s = m + 1;\\n            else e = m - 1; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    bool good(int x, vector<int> &price, int k) {\\n        int cnt = 1, last = price[0];\\n        for(int i=1; i<price.size(); i++) {\\n            if(price[i] - last >= x) cnt++, last = price[i];\\n        }\\n        return cnt < k ? false : true;\\n    }\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int s = 0, e = 1e9, ans = INT_MIN;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(good(m, price, k)) ans = max(ans, m), s = m + 1;\\n            else e = m - 1; \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953541,
                "title": "bs-java-aggressive-cow-approach-book-allocation-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Aggressive cow Approach,Book Allocation Approach**\\n**Try to Maximize the minimum possible distance(MID) between two cows or two digits.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse binary search to find the MID which is a **largest minimum distance** between two cows or two digits.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn) n= Maximum digit of prices\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n**1.Binary Search**\\n```\\nclass Solution {\\n\\n    public int maximumTastiness(int[] price, int k) {\\n        int n = price.length;\\n        Arrays.sort(price);\\n        int s = 0;\\n        int e = price[n-1];\\n        int ans=-1;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(isPossible(mid,price,k)){\\n                ans = mid;\\n                s=mid+1;\\n            }else{\\n                e=mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public boolean isPossible(int mid, int[] price, int k){\\n        int lastPos = price[0];\\n        int count=1;\\n\\n        for(int i=1;i<price.length;i++){\\n            if(price[i]-lastPos>=mid){\\n                count++;\\n                lastPos=price[i];\\n\\n                if(count==k) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n**2.Recursive Approach(TLE)**\\n```\\n   public int maximumTastiness(int[] price, int k) {\\n        return helper(price,k,0,new ArrayList<>());\\n    }\\n    \\n    public int helper(int[] price, int k, int index, List<Integer> lt){\\n        if(k==0){\\n            int size = lt.size();\\n            int min = Integer.MAX_VALUE;\\n            for(int i=0;i<size;i++){\\n                for(int j=i+1;j<size;j++){\\n                    min = Math.min(min,Math.abs(lt.get(i)-lt.get(j)));\\n                }\\n            }\\n            \\n            return min==Integer.MAX_VALUE?0:min;\\n        }\\n        if(index>=price.length) return 0;\\n        int ans=0;\\n        for(int i=index;i<price.length;i++){\\n            lt.add(price[i]);\\n            ans = Math.max(ans,helper(price,k-1,i+1,lt));\\n            lt.remove(lt.size()-1);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maximumTastiness(int[] price, int k) {\\n        int n = price.length;\\n        Arrays.sort(price);\\n        int s = 0;\\n        int e = price[n-1];\\n        int ans=-1;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(isPossible(mid,price,k)){\\n                ans = mid;\\n                s=mid+1;\\n            }else{\\n                e=mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public boolean isPossible(int mid, int[] price, int k){\\n        int lastPos = price[0];\\n        int count=1;\\n\\n        for(int i=1;i<price.length;i++){\\n            if(price[i]-lastPos>=mid){\\n                count++;\\n                lastPos=price[i];\\n\\n                if(count==k) return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```\n```\\n   public int maximumTastiness(int[] price, int k) {\\n        return helper(price,k,0,new ArrayList<>());\\n    }\\n    \\n    public int helper(int[] price, int k, int index, List<Integer> lt){\\n        if(k==0){\\n            int size = lt.size();\\n            int min = Integer.MAX_VALUE;\\n            for(int i=0;i<size;i++){\\n                for(int j=i+1;j<size;j++){\\n                    min = Math.min(min,Math.abs(lt.get(i)-lt.get(j)));\\n                }\\n            }\\n            \\n            return min==Integer.MAX_VALUE?0:min;\\n        }\\n        if(index>=price.length) return 0;\\n        int ans=0;\\n        for(int i=index;i<price.length;i++){\\n            lt.add(price[i]);\\n            ans = Math.max(ans,helper(price,k-1,i+1,lt));\\n            lt.remove(lt.size()-1);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952721,
                "title": "swift-solution-using-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    func maximumTastiness(_ price: [Int], _ k: Int) -> Int {\\n        guard !price.isEmpty, price.count >= k else {\\n            return 0\\n        }\\n        \\n        let price = price.sorted()\\n        var left = 0\\n        var right = price[price.count - 1] - price[0]\\n        \\n        while left < right {\\n            let m = (right + left + 1) / 2\\n            var count = 1\\n            var last = price[0]\\n            \\n            for i in 1..<price.count {\\n                if price[i] - last >= m {\\n                    count += 1\\n                    last = price[i]\\n                }\\n            }\\n            \\n            if count >= k {\\n                left = m\\n            } else {\\n                right = m - 1\\n            }\\n        }\\n        \\n        return left\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumTastiness(_ price: [Int], _ k: Int) -> Int {\\n        guard !price.isEmpty, price.count >= k else {\\n            return 0\\n        }\\n        \\n        let price = price.sorted()\\n        var left = 0\\n        var right = price[price.count - 1] - price[0]\\n        \\n        while left < right {\\n            let m = (right + left + 1) / 2\\n            var count = 1\\n            var last = price[0]\\n            \\n            for i in 1..<price.count {\\n                if price[i] - last >= m {\\n                    count += 1\\n                    last = price[i]\\n                }\\n            }\\n            \\n            if count >= k {\\n                left = m\\n            } else {\\n                right = m - 1\\n            }\\n        }\\n        \\n        return left\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949993,
                "title": "c-fastest-binary-search",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe maximum tastiness value is always between max [ price[i] ]-min  [ price[i] ]. This intitution leads us to binary search between 0 to max [ price[i] ] - min [ price[i] ].\\n\\n# Alogorithm\\n- sort the price array.\\n- binary search between 0 to prices [n-1] - price [0].\\n- if there exist a middle elements that the diff with prev and next element is mid than add the element with solution.\\n- otherwise change the start and end value accordingly.\\n\\nbelow is the implementation of this problem.\\nplease UPVOTE if you find the solution helpful.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool is_valid(int minDiff, vector<int>& price, int k){\\n        int prev = price[0];\\n        int n = price.size();\\n        int cnt = 1;\\n        for(int i = 1; i < n; i++){\\n            if(price[i] - prev >= minDiff) {\\n                cnt++;\\n                prev = price[i];\\n            }\\n        }\\n        \\n        if(cnt >= k) return true;\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int n = price.size();\\n        int st = 0;\\n        int ans = -1;\\n        int en = price[n-1]-price[0];\\n        while(st <= en){\\n            int mid = st + (en-st)/2;\\n            if(is_valid(mid, price, k)){\\n                ans = mid;\\n                st = mid+1;\\n            }\\n            else en = mid - 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_valid(int minDiff, vector<int>& price, int k){\\n        int prev = price[0];\\n        int n = price.size();\\n        int cnt = 1;\\n        for(int i = 1; i < n; i++){\\n            if(price[i] - prev >= minDiff) {\\n                cnt++;\\n                prev = price[i];\\n            }\\n        }\\n        \\n        if(cnt >= k) return true;\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int n = price.size();\\n        int st = 0;\\n        int ans = -1;\\n        int en = price[n-1]-price[0];\\n        while(st <= en){\\n            int mid = st + (en-st)/2;\\n            if(is_valid(mid, price, k)){\\n                ans = mid;\\n                st = mid+1;\\n            }\\n            else en = mid - 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948986,
                "title": "c-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntitution is clear, we will look for each value from low to high to check that till which largest value it satisfies our condition and that will be our answer. And since it will be in sorted order we can apply binary search...\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int maximumTastiness(vector<int> &price, int k)\\n    {\\n        sort(price.begin(), price.end());\\n        int n = price.size();\\n        // minimum value can be zero while maximum can be (maxPrice - minPrice)..\\n        long long left = 0, right = price[n - 1] - price[0], result = 0;\\n        while (left <= right)\\n        {\\n            long long mid = (left + right) / 2;\\n            int temp = 0;\\n            int i = 0;\\n\\n            // To check whether this mid can be our answer...\\n            while (i < n)\\n            {\\n                int idx = lower_bound(price.begin(), price.end(), price[i] + mid) - price.begin();\\n                i = idx;\\n                temp++;\\n                if (temp >= k)\\n                    break;\\n            }\\n            // If this mid can be our answer,check for higher value and mark left as mid + 1 otherwise mark right as mid -1..\\n            if (temp >= k)\\n            {\\n                left = mid + 1;\\n                result = max(result, mid);\\n            }\\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n        int res = result;\\n        return res;\\n    }\\n};\\n```\\nPlease Upvote If helpful...",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maximumTastiness(vector<int> &price, int k)\\n    {\\n        sort(price.begin(), price.end());\\n        int n = price.size();\\n        // minimum value can be zero while maximum can be (maxPrice - minPrice)..\\n        long long left = 0, right = price[n - 1] - price[0], result = 0;\\n        while (left <= right)\\n        {\\n            long long mid = (left + right) / 2;\\n            int temp = 0;\\n            int i = 0;\\n\\n            // To check whether this mid can be our answer...\\n            while (i < n)\\n            {\\n                int idx = lower_bound(price.begin(), price.end(), price[i] + mid) - price.begin();\\n                i = idx;\\n                temp++;\\n                if (temp >= k)\\n                    break;\\n            }\\n            // If this mid can be our answer,check for higher value and mark left as mid + 1 otherwise mark right as mid -1..\\n            if (temp >= k)\\n            {\\n                left = mid + 1;\\n                result = max(result, mid);\\n            }\\n            else\\n            {\\n                right = mid - 1;\\n            }\\n        }\\n        int res = result;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948203,
                "title": "easy-binary-search",
                "content": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\ntypedef pair<int, int> pi;\\n#define forn(i, n) for(int i = 0;i < n;i++)\\n#define forn2(i, s, e) for(int i = s;i < e;i++)\\n#define pb push_back\\ntypedef vector<int> vi;\\ntypedef vector<vector<int>> vvi;\\ntypedef vector<ll> vl;\\ntypedef pair<double, double> pd;\\ntypedef vector<vector<ll>> vvl;\\ntypedef vector<bool> vb;\\ntypedef vector<string> vs;\\ntypedef pair<int, pi>ppi;\\nint mod = 1e9 + 7;\\ntemplate<typename T>\\n \\nvoid printvec(T& data){\\n    forn(i, data.size()){\\n        cout << data[i] << \" \";\\n    }\\n    cout << endl;\\n}\\n\\nint n, k;\\nvi arr;\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    bool check(int mid){\\n        int cnt = 1;\\n        int prev = arr[0];\\n        forn2(i, 1, n){\\n            if(arr[i] - prev >= mid){\\n                cnt++;\\n                prev = arr[i];\\n            }\\n        }\\n        return cnt >= k;\\n    }\\n    \\n    int maximumTastiness(vector<int>& price, int k_) {\\n        n = price.size();\\n        k = k_;\\n        arr = price;\\n        sort(arr.begin(), arr.end());\\n        int low = 0;\\n        int high = INT_MAX;\\n        int output = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(check(mid)){\\n                output = mid;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\ntypedef pair<int, int> pi;\\n#define forn(i, n) for(int i = 0;i < n;i++)\\n#define forn2(i, s, e) for(int i = s;i < e;i++)\\n#define pb push_back\\ntypedef vector<int> vi;\\ntypedef vector<vector<int>> vvi;\\ntypedef vector<ll> vl;\\ntypedef pair<double, double> pd;\\ntypedef vector<vector<ll>> vvl;\\ntypedef vector<bool> vb;\\ntypedef vector<string> vs;\\ntypedef pair<int, pi>ppi;\\nint mod = 1e9 + 7;\\ntemplate<typename T>\\n \\nvoid printvec(T& data){\\n    forn(i, data.size()){\\n        cout << data[i] << \" \";\\n    }\\n    cout << endl;\\n}\\n\\nint n, k;\\nvi arr;\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    bool check(int mid){\\n        int cnt = 1;\\n        int prev = arr[0];\\n        forn2(i, 1, n){\\n            if(arr[i] - prev >= mid){\\n                cnt++;\\n                prev = arr[i];\\n            }\\n        }\\n        return cnt >= k;\\n    }\\n    \\n    int maximumTastiness(vector<int>& price, int k_) {\\n        n = price.size();\\n        k = k_;\\n        arr = price;\\n        sort(arr.begin(), arr.end());\\n        int low = 0;\\n        int high = INT_MAX;\\n        int output = 0;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2;\\n            if(check(mid)){\\n                output = mid;\\n                low = mid+1;\\n            }\\n            else high = mid-1;\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2948181,
                "title": "with-powerful-ultimate-binary-search-template",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can sort prices and find biggest tastiness (max difference) with binary search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse Ultimate BS Template to find max difference which can be exist for k amount of elements https://leetcode.com/tag/binary-search/discuss/786126/Python-Powerful-Ultimate-Binary-Search-Template.-Solved-many-problems\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} price\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximumTastiness = function(price, k) {\\n    const N = price.length\\n    price.sort((a,b) => a - b)\\n    let left = 0\\n    let right = price.at(-1)-price[0] + 1 \\n    while(left < right) {\\n        const mid = Math.floor(left + (right-left)/2)\\n        if(!condition(mid)) {\\n            right = mid\\n        } else {\\n            left = mid +1\\n        }\\n    }\\n    return left -1 \\n    \\n    function condition(mid) {\\n        let first = price[0]\\n        let count = 1\\n        for(let i = 1; i <N; i++) {\\n            if(price[i]-first>=mid) {\\n                count++\\n                first = price[i]\\n            }\\n            if(count===k) return true\\n        }\\n        return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} price\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximumTastiness = function(price, k) {\\n    const N = price.length\\n    price.sort((a,b) => a - b)\\n    let left = 0\\n    let right = price.at(-1)-price[0] + 1 \\n    while(left < right) {\\n        const mid = Math.floor(left + (right-left)/2)\\n        if(!condition(mid)) {\\n            right = mid\\n        } else {\\n            left = mid +1\\n        }\\n    }\\n    return left -1 \\n    \\n    function condition(mid) {\\n        let first = price[0]\\n        let count = 1\\n        for(let i = 1; i <N; i++) {\\n            if(price[i]-first>=mid) {\\n                count++\\n                first = price[i]\\n            }\\n            if(count===k) return true\\n        }\\n        return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2948060,
                "title": "c-binary-search-similar-to-aggressive-cows-problem",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    bool solve(vector<int>&price,int n,int k,int mid)\\n    {\\n        int coor=price[0],cnt=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]-coor>=mid)\\n         {\\n            cnt++;\\n            coor=price[i];\\n         }\\n         if(cnt==k)\\n         return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n         sort(price.begin(),price.end());\\n        int n=price.size();\\n        int low=1,high=price[n-1]-price[0],ans;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(solve(price,n,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            high=mid-1;\\n        }\\n        if(ans<0)\\n            return 0;\\n        else\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool solve(vector<int>&price,int n,int k,int mid)\\n    {\\n        int coor=price[0],cnt=1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(price[i]-coor>=mid)\\n         {\\n            cnt++;\\n            coor=price[i];\\n         }\\n         if(cnt==k)\\n         return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n         sort(price.begin(),price.end());\\n        int n=price.size();\\n        int low=1,high=price[n-1]-price[0],ans;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            if(solve(price,n,k,mid))\\n            {\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n            high=mid-1;\\n        }\\n        if(ans<0)\\n            return 0;\\n        else\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948006,
                "title": "binary-search-the-answer",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        n = len(price)\\n        if n == 1:\\n            return 0\\n        price.sort()\\n        def possible(price, n, gap):\\n            i = 0\\n            rem = k - 1\\n            for j in range(n):\\n                if price[j] - price[i] >= gap:\\n                    rem -= 1\\n                    i = j\\n            return rem <= 0\\n        beg = 0\\n        end = price[-1] - price[0]\\n        res = 0\\n        while beg <= end:\\n            mid = (beg + end) // 2\\n            if possible(price, n, mid):\\n                res = mid\\n                beg = mid + 1\\n            else:\\n                end = mid - 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        n = len(price)\\n        if n == 1:\\n            return 0\\n        price.sort()\\n        def possible(price, n, gap):\\n            i = 0\\n            rem = k - 1\\n            for j in range(n):\\n                if price[j] - price[i] >= gap:\\n                    rem -= 1\\n                    i = j\\n            return rem <= 0\\n        beg = 0\\n        end = price[-1] - price[0]\\n        res = 0\\n        while beg <= end:\\n            mid = (beg + end) // 2\\n            if possible(price, n, mid):\\n                res = mid\\n                beg = mid + 1\\n            else:\\n                end = mid - 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947990,
                "title": "easy-binary-search-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    bool check(int mid,vector<int>& price,int k){\\n        int count=1;\\n        int prev=price[0];\\n        for(int i=1;i<n;i++){\\n            if(price[i]-prev<mid) continue;\\n            count++;\\n            prev=price[i];\\n        }\\n        \\n        if(count<k) return false;\\n        return true;\\n    }\\n    \\n    int maximumTastiness(vector<int>& price, int k) {\\n        n=price.size();\\n        sort(price.begin(),price.end());\\n        int start=0,end=price.back();\\n        while(start<end){\\n            int mid=(start+end+1)>>1;\\n            if(check(mid,price,k)) start=mid;\\n            else end=mid-1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    bool check(int mid,vector<int>& price,int k){\\n        int count=1;\\n        int prev=price[0];\\n        for(int i=1;i<n;i++){\\n            if(price[i]-prev<mid) continue;\\n            count++;\\n            prev=price[i];\\n        }\\n        \\n        if(count<k) return false;\\n        return true;\\n    }\\n    \\n    int maximumTastiness(vector<int>& price, int k) {\\n        n=price.size();\\n        sort(price.begin(),price.end());\\n        int start=0,end=price.back();\\n        while(start<end){\\n            int mid=(start+end+1)>>1;\\n            if(check(mid,price,k)) start=mid;\\n            else end=mid-1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086396,
                "title": "easy-intutive-elegant-beats-96-with-example-problems",
                "content": "Same as https://practice.geeksforgeeks.org/problems/aggressive-cows/0\\nand https://leetcode.com/problems/magnetic-force-between-two-balls/description/\\nThis is a type of pattern called min of max or max of min . Explained very well by Striver on Youtube and seems important since it is difficult to come up by yourself in an interview if you have never done such Question before. Please check this playlist for better explanation: https://youtube.com/playlist?list=PLgUwDviBIf0pMFMWuuvDNMAkoQFi-h0ZF&si=nUQ3U3KitGs-KktS\\n# Complexity\\n- Time complexity:O(NLogN) + O(NLog(K)) where K is the last basket in sorted order\\n\\n- Space complexity: O(N) because of python Sort Function . Otherwise we are not using any extra space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTastiness(self, nums: List[int], k: int) -> int:\\n        N=len((nums))\\n        nums.sort()\\n        def canWePlace(dist):\\n            cnt,prev=1,nums[0]\\n            for i in range(1,N):\\n                if nums[i]-prev>=dist:\\n                    cnt+=1\\n                    prev=nums[i]\\n                if cnt>=k:\\n                    return True\\n            return False\\n        low=1\\n        high=(nums[N-1]-nums[0])//(k-1)\\n        while low<=high:\\n            mid=(low+high)//2\\n            if canWePlace(mid):\\n                low=mid+1\\n            else:\\n                high=mid-1\\n        return high\\n\\n```\\n![giphy (1).gif](https://assets.leetcode.com/users/images/3b28e611-7776-4852-bc3d-18d2d126059a_1695594800.5439696.gif)\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, nums: List[int], k: int) -> int:\\n        N=len((nums))\\n        nums.sort()\\n        def canWePlace(dist):\\n            cnt,prev=1,nums[0]\\n            for i in range(1,N):\\n                if nums[i]-prev>=dist:\\n                    cnt+=1\\n                    prev=nums[i]\\n                if cnt>=k:\\n                    return True\\n            return False\\n        low=1\\n        high=(nums[N-1]-nums[0])//(k-1)\\n        while low<=high:\\n            mid=(low+high)//2\\n            if canWePlace(mid):\\n                low=mid+1\\n            else:\\n                high=mid-1\\n        return high\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081041,
                "title": "binary-search-on-answer-explained",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(max-min))$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n  bool isPossible(vector<int>& price, int k, int mini)\\n  {\\n    int cnt = 1, prev = 0;\\n    for(int i=1; i<price.size(); i++)\\n    {\\n      if(price[i] - price[prev] >= mini) //take difference of current and previously taken element\\n      {\\n        cnt++;    //add this element in basket\\n        prev = i;\\n      }\\n    }\\n  return cnt >= k; //check if we can have at least \\'k\\' elements in our basket or not\\n  }\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n      sort(price.begin(),price.end()); //sort the price vector\\n      int low = 0, high = price[price.size()-1] - price[0];\\n      while(low <= high)\\n      {\\n        int mid = low + (high-low)/2;\\n\\n        //if \\'mid\\' is a possible value of tastiness\\n        if(isPossible(price,k,mid))\\n         low = mid + 1; //then, check for a higher value\\n        else\\n         high = mid - 1; //otherwise, check for a lower value\\n      }\\n    return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  bool isPossible(vector<int>& price, int k, int mini)\\n  {\\n    int cnt = 1, prev = 0;\\n    for(int i=1; i<price.size(); i++)\\n    {\\n      if(price[i] - price[prev] >= mini) //take difference of current and previously taken element\\n      {\\n        cnt++;    //add this element in basket\\n        prev = i;\\n      }\\n    }\\n  return cnt >= k; //check if we can have at least \\'k\\' elements in our basket or not\\n  }\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n      sort(price.begin(),price.end()); //sort the price vector\\n      int low = 0, high = price[price.size()-1] - price[0];\\n      while(low <= high)\\n      {\\n        int mid = low + (high-low)/2;\\n\\n        //if \\'mid\\' is a possible value of tastiness\\n        if(isPossible(price,k,mid))\\n         low = mid + 1; //then, check for a higher value\\n        else\\n         high = mid - 1; //otherwise, check for a lower value\\n      }\\n    return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059407,
                "title": "binary-search-on-price-easy-implementation-intuitive-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need the max value of tastiness so making the search space from 0 to 10^9 + 7 we can search the max tastiness by applying binary search on this range.\\n\\nWe will direct our search by checking for the mid value of tastiness, whether we can get atleast k candies. If yes then we will keep moving forward by setting the lower value of range to mid+1 otherwise we will set the higher value of range to mid-1.\\n\\n\\n# Complexity\\n- Time complexity:(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool chk(int mid, vector<int>& price, int k){  // function on the basis of which we are supposed to direct out search space.\\n        int cnt = 1; // initial count of candies\\n        int val = price[0];\\n        for(int i = 1; i < price.size(); i++){\\n            if(price[i] - val >= mid){\\n                cnt++;\\n                val = price[i];\\n            }\\n            if(cnt == k)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int n = price.size();\\n\\n        sort(price.begin(), price.end());\\n\\n        int s = 0, e = 1e9 + 7;\\n        int ans;\\n        while(s <= e){\\n            int mid = (s + e)/2;\\n\\n            if(chk(mid, price, k)){\\n                s = mid + 1;\\n                ans = mid;\\n            }\\n            else\\n                e = mid - 1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool chk(int mid, vector<int>& price, int k){  // function on the basis of which we are supposed to direct out search space.\\n        int cnt = 1; // initial count of candies\\n        int val = price[0];\\n        for(int i = 1; i < price.size(); i++){\\n            if(price[i] - val >= mid){\\n                cnt++;\\n                val = price[i];\\n            }\\n            if(cnt == k)\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int n = price.size();\\n\\n        sort(price.begin(), price.end());\\n\\n        int s = 0, e = 1e9 + 7;\\n        int ans;\\n        while(s <= e){\\n            int mid = (s + e)/2;\\n\\n            if(chk(mid, price, k)){\\n                s = mid + 1;\\n                ans = mid;\\n            }\\n            else\\n                e = mid - 1;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058558,
                "title": "easy-and-short-cpp-solution-using-binary-search-for-beginner",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int mid, vector<int> &arr, int k){\\n        int i=0, j=0, n=arr.size(), res=0;\\n        while(j<n){\\n            if(arr[j]-arr[i]>=mid){\\n                res++;\\n                i=j;\\n                j++;\\n                continue;\\n            }\\n            j++;\\n        }\\n        if(res+1>=k)   return true;\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int l=0,h=1e9+2, ans=0;\\n        sort(price.begin(), price.end());\\n        while(h>=l){\\n            int mid=(l+h)/2;\\n            if(check(mid, price, k)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int mid, vector<int> &arr, int k){\\n        int i=0, j=0, n=arr.size(), res=0;\\n        while(j<n){\\n            if(arr[j]-arr[i]>=mid){\\n                res++;\\n                i=j;\\n                j++;\\n                continue;\\n            }\\n            j++;\\n        }\\n        if(res+1>=k)   return true;\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int l=0,h=1e9+2, ans=0;\\n        sort(price.begin(), price.end());\\n        while(h>=l){\\n            int mid=(l+h)/2;\\n            if(check(mid, price, k)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034433,
                "title": "python-easy-solution-sorting-bin-search-o-n-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1) Sort prices array\\n2) Using bin_search find max diff: achievable(diff, price) >= k \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSorting + binary search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        \\n        # how many items from price satisfies: min_diff(item_1...item_n) <= diff\\n        def achievable(diff: int, price: list): \\n            target = price[0] + diff\\n            cnt = 1\\n            for i in range(1, len(price)):  \\n                if price[i] >= target: \\n                    cnt += 1\\n                    target = price[i] + diff\\n            return cnt\\n\\n        # bin_search for maximum tastiness of a candy basket\\n        l, r = 0, price[-1]\\n        while l < r: \\n            m = (l + r + 1) // 2\\n            if achievable(diff = m, price = price) < k: \\n                r = m - 1\\n            else: \\n                l = m\\n        return l \\n            \\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        \\n        # how many items from price satisfies: min_diff(item_1...item_n) <= diff\\n        def achievable(diff: int, price: list): \\n            target = price[0] + diff\\n            cnt = 1\\n            for i in range(1, len(price)):  \\n                if price[i] >= target: \\n                    cnt += 1\\n                    target = price[i] + diff\\n            return cnt\\n\\n        # bin_search for maximum tastiness of a candy basket\\n        l, r = 0, price[-1]\\n        while l < r: \\n            m = (l + r + 1) // 2\\n            if achievable(diff = m, price = price) < k: \\n                r = m - 1\\n            else: \\n                l = m\\n        return l \\n            \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033136,
                "title": "a-clear-and-intuitive-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis solution follows tojuna\\'s top-voted Python solution, but I think it\\'s a lot clearer with the varnames and comments. Basically, the binary search happens over the question: \"Can we have a higher minimum difference than this?\"\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start at the standard binsearch range of zero to maximum-possible.\\n- Pick a midpoint that acts as a target tastiness.\\n- Look at whether this (or higher than this) tastiness is feasible through the **\"feasibility function\"**.\\n- If it is, aim higher. If it isn\\'t, aim lower, again in classical binsearch fashion.\\n- Finally, return one less than the low bound, since the last successful run was at midpoint \"lowest_target_tastiness\" and we incremented that by one.\\n### The feasibility function\\n- Start by selecting the cheapest candy.\\n- Now, look at candy-dates (no, I\\'m not sorry) that have the minimum needed difference (which is target_difference). Note that this can be strictly higher, or equal, but never lower, since the feasibility function tells us the feasibility of going higher than we currently are.\\n- If you find a candy-date, put it in the most_recently_picked_candy slot, and increase the number of candies in your basket by one.\\n- If you don\\'t, increase the iterator to look for the next candy which is monotonically non-decreasing (fancy term for \"it can either be as expensive as the one we just looked at, or more expensive\").\\n- Return true if we meet the candy-date quota, meaning we can go higher/we\\'ve managed to get this high.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n)\\nSearch is O(n log n) which shadows the binsearch which is O(log n)\\n\\n- Space complexity:\\n- O(1) since these are pure constant numbers we\\'re messing with, not a larger array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        # Order the array so that chocolates are arranged from cheapest to most expensive\\n        price.sort()\\n\\n        lowest_target_tastiness = 0\\n        highest_target_tastiness = 10**9\\n        \\n        while lowest_target_tastiness < highest_target_tastiness:\\n        \\n            target_tastiness = (lowest_target_tastiness+highest_target_tastiness)//2\\n        \\n            # If the target tastiness (or larger) is achievable, aim higher!\\n            if self.achievable(target_tastiness,price,k):\\n                lowest_target_tastiness = target_tastiness+1\\n            \\n            # If not, aim lower!\\n            else:\\n                highest_target_tastiness = target_tastiness\\n        \\n        # Since the algorithm terminates when the lowest is greater than/equal to highest,\\n        # the last best tastiness that was achieved was just before lowest was incremented,\\n        # meaning it was lowest-1.\\n        return lowest_target_tastiness-1\\n    \\n\\n    def achievable(self,target_difference,price_array,basket_size):\\n        # Achievability is decided by whether we could fill up a basket\\n        # with candies such that the least difference in price was at \\n        # least the target.\\n\\n        # Pick up the cheapest candy\\n        most_recently_picked_candy = price_array[0]\\n        iterator = 1\\n        candies_in_basket = 1\\n\\n        # Now look at proceeding candies, as long as you don\\'t run out of candies\\n        # to assess or basket space.\\n        while iterator<len(price_array) and candies_in_basket<basket_size:\\n            next_candidate_candy = price_array[iterator] # Hmm... Candy-date, then? \\n                                                         # I\\'ll show myself out.\\n\\n            # If the price difference between the candidate candy and the most recently picked\\n            # one is larger than or equal to the target difference, we can pick this candidate\\n            # candy.\\n            if next_candidate_candy-most_recently_picked_candy >= target_difference:\\n                most_recently_picked_candy = next_candidate_candy\\n                candies_in_basket+=1\\n            \\n            # Either way, we move ahead, since the array is monotonically increasing\\n            # and thus, the next feasible candidate after a selected one can only\\n            # be a found going to the right.\\n            iterator+=1\\n\\n        # If we managed to fill the basket, something larger than this difference\\n        # or equal to it was possible, meaning we can look higher.\\n        if candies_in_basket == basket_size:\\n            return True\\n        # If not, we need to look lower.\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        # Order the array so that chocolates are arranged from cheapest to most expensive\\n        price.sort()\\n\\n        lowest_target_tastiness = 0\\n        highest_target_tastiness = 10**9\\n        \\n        while lowest_target_tastiness < highest_target_tastiness:\\n        \\n            target_tastiness = (lowest_target_tastiness+highest_target_tastiness)//2\\n        \\n            # If the target tastiness (or larger) is achievable, aim higher!\\n            if self.achievable(target_tastiness,price,k):\\n                lowest_target_tastiness = target_tastiness+1\\n            \\n            # If not, aim lower!\\n            else:\\n                highest_target_tastiness = target_tastiness\\n        \\n        # Since the algorithm terminates when the lowest is greater than/equal to highest,\\n        # the last best tastiness that was achieved was just before lowest was incremented,\\n        # meaning it was lowest-1.\\n        return lowest_target_tastiness-1\\n    \\n\\n    def achievable(self,target_difference,price_array,basket_size):\\n        # Achievability is decided by whether we could fill up a basket\\n        # with candies such that the least difference in price was at \\n        # least the target.\\n\\n        # Pick up the cheapest candy\\n        most_recently_picked_candy = price_array[0]\\n        iterator = 1\\n        candies_in_basket = 1\\n\\n        # Now look at proceeding candies, as long as you don\\'t run out of candies\\n        # to assess or basket space.\\n        while iterator<len(price_array) and candies_in_basket<basket_size:\\n            next_candidate_candy = price_array[iterator] # Hmm... Candy-date, then? \\n                                                         # I\\'ll show myself out.\\n\\n            # If the price difference between the candidate candy and the most recently picked\\n            # one is larger than or equal to the target difference, we can pick this candidate\\n            # candy.\\n            if next_candidate_candy-most_recently_picked_candy >= target_difference:\\n                most_recently_picked_candy = next_candidate_candy\\n                candies_in_basket+=1\\n            \\n            # Either way, we move ahead, since the array is monotonically increasing\\n            # and thus, the next feasible candidate after a selected one can only\\n            # be a found going to the right.\\n            iterator+=1\\n\\n        # If we managed to fill the basket, something larger than this difference\\n        # or equal to it was possible, meaning we can look higher.\\n        if candies_in_basket == basket_size:\\n            return True\\n        # If not, we need to look lower.\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962667,
                "title": "same-template-bs-on-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nsee whenever you encounter minimize the maximum or maximize the minimum thing\\nlike in this question u need to maximize the minimum absolute difference\\n\\nfor reference check aggressive cows question ,\\nhttps://leetcode.com/problems/koko-eating-bananas/\\nbook allocation problem\\nhttps://leetcode.com/problems/split-array-largest-sum/\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to check if it\\'s possible to achieve a valid solution with given minDiff\\n    bool isValid(int minDiff, vector<int>& price, int k) {\\n        int n = price.size();\\n        int cnt = 1;  // Counter for the number of intervals with minDiff\\n\\n        int prev = price[0];  // Initialize previous price with the first element\\n\\n        for (int i = 1; i < n; i++) {\\n            if (price[i] - prev >= minDiff) {\\n                cnt++;          // Increment the counter if the current interval satisfies the condition\\n                prev = price[i];  // Update previous price to the current price\\n            }\\n        }\\n\\n        if (cnt >= k) return true;  // If we can form \\'k\\' valid intervals, return true\\n\\n        return false;  // Otherwise, return false\\n    }\\n\\n    // Function to find the maximum tastiness\\n    int maximumTastiness(vector<int> &price, int k) {\\n        sort(price.begin(), price.end());  // Sort the price array in ascending order\\n        int n = price.size();  // Number of elements in the price array\\n\\n        int st = 0;  // Start of the binary search range\\n        int en = price[n - 1] - price[0];  // End of the binary search range\\n\\n        int ans = -1;  // Initialize the answer to -1\\n\\n        // Binary search loop\\n        while (st <= en) {\\n            int mid = st + (en - st) / 2;  // Calculate the middle value\\n\\n            // Check if it\\'s possible to achieve a valid solution with minDiff = mid\\n            if (isValid(mid, price, k)) {\\n                ans = mid;     // Update the answer to the current minDiff\\n                st = mid + 1;  // Move the start to mid + 1 to search for a larger minDiff\\n            } else {\\n                en = mid - 1;  // Move the end to mid - 1 to search for a smaller minDiff\\n            }\\n        }\\n\\n        return ans;  // Return the maximum tastiness (answer)\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to check if it\\'s possible to achieve a valid solution with given minDiff\\n    bool isValid(int minDiff, vector<int>& price, int k) {\\n        int n = price.size();\\n        int cnt = 1;  // Counter for the number of intervals with minDiff\\n\\n        int prev = price[0];  // Initialize previous price with the first element\\n\\n        for (int i = 1; i < n; i++) {\\n            if (price[i] - prev >= minDiff) {\\n                cnt++;          // Increment the counter if the current interval satisfies the condition\\n                prev = price[i];  // Update previous price to the current price\\n            }\\n        }\\n\\n        if (cnt >= k) return true;  // If we can form \\'k\\' valid intervals, return true\\n\\n        return false;  // Otherwise, return false\\n    }\\n\\n    // Function to find the maximum tastiness\\n    int maximumTastiness(vector<int> &price, int k) {\\n        sort(price.begin(), price.end());  // Sort the price array in ascending order\\n        int n = price.size();  // Number of elements in the price array\\n\\n        int st = 0;  // Start of the binary search range\\n        int en = price[n - 1] - price[0];  // End of the binary search range\\n\\n        int ans = -1;  // Initialize the answer to -1\\n\\n        // Binary search loop\\n        while (st <= en) {\\n            int mid = st + (en - st) / 2;  // Calculate the middle value\\n\\n            // Check if it\\'s possible to achieve a valid solution with minDiff = mid\\n            if (isValid(mid, price, k)) {\\n                ans = mid;     // Update the answer to the current minDiff\\n                st = mid + 1;  // Move the start to mid + 1 to search for a larger minDiff\\n            } else {\\n                en = mid - 1;  // Move the end to mid - 1 to search for a smaller minDiff\\n            }\\n        }\\n\\n        return ans;  // Return the maximum tastiness (answer)\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941046,
                "title": "easy-solution-using-bs-and-sorting",
                "content": "# Intuition\\nThe problem asks us to find the maximum tastiness of a candy basket. The tastiness of a candy basket is defined as the smallest absolute difference of the prices of any two candies in the basket. We are given an array of positive integers representing the prices of candies and a positive integer k which represents the number of distinct candies that can be included in the basket. \\n\\nTo solve this problem, we can use a binary search approach to find the maximum tastiness value. We\\'ll sort the array of candy prices and then use binary search to find the maximum tastiness that can be achieved while ensuring that the basket contains at least k distinct candies.\\n\\n# Approach\\n1. We start by sorting the input array of candy prices in ascending order.\\n2. We use binary search to find the maximum tastiness value. We maintain a `low` and `high` variable that represent the possible range of tastiness values.\\n3. In each iteration of the binary search, we calculate the `mid` value between `low` and `high`. We then check if it\\'s possible to achieve a tastiness of at least `mid` by ensuring that there are at least k distinct candies in the basket.\\n4. To check if it\\'s possible to achieve a tastiness of at least `mid`, we iterate through the sorted candy prices array and count how many distinct candies can be included in the basket while maintaining a minimum absolute difference of `mid` between any two candies.\\n5. If it\\'s possible to achieve a tastiness of at least `mid`, we update the `ans` variable to `mid` and move `low` to `mid + 1`.\\n6. If it\\'s not possible to achieve a tastiness of at least `mid`, we update `high` to `mid - 1`.\\n7. We continue the binary search until `low` becomes greater than `high`, at which point we return the final `ans` value as the maximum tastiness.\\n\\n# Complexity\\n- Time complexity: The sorting step takes O(n log n) time, and the binary search takes O(log range) time, where range is the difference between the maximum and minimum values in the array. Overall, the time complexity is O(n log n + log range).\\n- Space complexity: We are using a constant amount of extra space for variables. Thus, the space complexity is O(1).\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    bool possible(vector<int>&v,int dis,int k){\\n        int cnt=1;\\n        int inn=v[0];\\n        for(int i=1;i<v.size();i++){\\n            if(v[i]-inn>=dis){\\n                cnt++;\\n                inn=v[i];\\n                if(cnt>=k) return true;\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    int maximumTastiness(vector<int>& a, int k) {\\n        sort(a.begin(),a.end());\\n        int low=0,high=a[a.size()-1],ans=0;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(possible(a,mid,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThis solution efficiently solves the problem by employing a binary search strategy to find the maximum tastiness value while ensuring that the basket contains at least k distinct candies.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool possible(vector<int>&v,int dis,int k){\\n        int cnt=1;\\n        int inn=v[0];\\n        for(int i=1;i<v.size();i++){\\n            if(v[i]-inn>=dis){\\n                cnt++;\\n                inn=v[i];\\n                if(cnt>=k) return true;\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n    \\n    int maximumTastiness(vector<int>& a, int k) {\\n        sort(a.begin(),a.end());\\n        int low=0,high=a[a.size()-1],ans=0;\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(possible(a,mid,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else high=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928304,
                "title": "intuition-java",
                "content": "# Intuition\\nProblem statement asks to pick **K** candies out of **N** candies such that the minimum difference between the candies is maximized.\\nWhat if the value of **K** is 2. Then the difference will be the **max** - **min** elements . This is the max value that we can get for an input. And what about the minimum value **0** if all are same right. Hence, our ans will lie between **0<= ans <= (max - min)**. \\nNow lets suppose for a case we choose **K** candies out of **N** candies and we are not able to get min difference of  value **x**. What does that means ? . This means that no matter what value of **K** we choose we will never be able to get minimum difference < **x**. No need to search there. However if we are able to get a min difference of **x** there might be a chance that we might get a min difference > **x**. What is this? Search space reduction i.e **Binary Search**\\n\\n# Approach\\nNow the next part is how to check if in a given array we can choose K such pairs such that they have min difference of atleast X. \\nOne way would be to choose all pairs and then find their diff and count. \\nTime complexity will be O(N^2)\\nCan we improve ?\\nOne thing to observe is that for an element at index i in a sorted array the min difference it can have is with the elements at index i-1 and i + 1.\\nSo we can sort the array and check the difference between consecutive elements. if difference is >= k that will be counted as pair else not. \\n\\nApproach \\n1. Sort input array \\n2. Apply binary search on ans search space \\n3. for each possible ans check if we can make K pairs out of it\\n4. Return ans\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) Sort + n*O(max - min)\\n\\n- Space complexity:\\nconstant O(1)\\n# **Please upvote if you like **\\n# Code\\n```\\nclass Solution {\\n    public boolean isPossible(int []prices, int diff, int k){\\n        int countPairs = 1;\\n        int min= prices[0];\\n        int length = prices.length;\\n        for(int index = 1; index < length; index++){\\n            if((prices[index] - min) >= diff){\\n                countPairs++;\\n                min = prices[index];\\n            }\\n        }\\n        return (countPairs >= k);\\n    }\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int length = price.length;\\n        int maxDiff = price[length-1] - price[0];\\n        int minDiff = 0;\\n        int midDiff = 0;\\n        int ans = -1;\\n        while(minDiff <= maxDiff){\\n            midDiff = minDiff + (maxDiff - minDiff)/2;\\n            if(isPossible(price, midDiff, k)){\\n                ans = midDiff;\\n                minDiff = midDiff+1;\\n            }else{\\n                maxDiff = midDiff - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPossible(int []prices, int diff, int k){\\n        int countPairs = 1;\\n        int min= prices[0];\\n        int length = prices.length;\\n        for(int index = 1; index < length; index++){\\n            if((prices[index] - min) >= diff){\\n                countPairs++;\\n                min = prices[index];\\n            }\\n        }\\n        return (countPairs >= k);\\n    }\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int length = price.length;\\n        int maxDiff = price[length-1] - price[0];\\n        int minDiff = 0;\\n        int midDiff = 0;\\n        int ans = -1;\\n        while(minDiff <= maxDiff){\\n            midDiff = minDiff + (maxDiff - minDiff)/2;\\n            if(isPossible(price, midDiff, k)){\\n                ans = midDiff;\\n                minDiff = midDiff+1;\\n            }else{\\n                maxDiff = midDiff - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922569,
                "title": "binary-search-on-concept-minimum-of-max",
                "content": "# Approach\\n  Binary Search.\\n\\n# Complexity\\n- Time complexity:\\n  O(nlogn)+O(logn*n) => O(2logn)\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean minDifference(int []price,int diff,int k){\\n        int last=price[0],cntCandy=1;\\n        for(int i=1;i<price.length;i++){\\n            if((price[i]-last)>=diff){\\n                cntCandy++;\\n                last=price[i];\\n            }\\n            if(cntCandy==k) return true;\\n        }\\n        return false;\\n    }\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int n = price.length;\\n        int start=1,end=price[n-1]-price[0],mid=0; // end = max-min\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(minDifference(price,mid,k)) start=mid+1;\\n            else end=mid-1;\\n        }\\n        return end;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean minDifference(int []price,int diff,int k){\\n        int last=price[0],cntCandy=1;\\n        for(int i=1;i<price.length;i++){\\n            if((price[i]-last)>=diff){\\n                cntCandy++;\\n                last=price[i];\\n            }\\n            if(cntCandy==k) return true;\\n        }\\n        return false;\\n    }\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int n = price.length;\\n        int start=1,end=price[n-1]-price[0],mid=0; // end = max-min\\n        while(start<=end){\\n            mid=(start+end)/2;\\n            if(minDifference(price,mid,k)) start=mid+1;\\n            else end=mid-1;\\n        }\\n        return end;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918959,
                "title": "solution-to-maximum-tastiness-of-candy-basket",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    // Helper Method\\n    // Returns true or false based on if the threshold value or greater than threshold value can be equal to\\n    // the minimum of the absolute differences of k pairs in price array\\n    // Basically find a subsequence from price array where the difference is greater than equal to threshold.\\n    bool isValid(vector<int> &price, int threshold, int k) {\\n        int count = 1, i = 1, last = 0;\\n        while (count < k && i < price.size()) {\\n            if (price[i] - price[last] >= threshold) {\\n                last = i;\\n                count++;\\n            }\\n            i++;\\n        }\\n\\n        return count == k;\\n    }\\n\\n    // Method that returns the maximum value of the smallest absolute difference of the prices of any two candies in\\n    // the basket with k candies.\\n    int maximumTastiness(vector<int> &price, int k) {\\n        // Sort the array in ascending order\\n        sort(price.begin(), price.end());\\n\\n        // Result variable\\n        int result = INT_MIN;\\n\\n        // Implement a Binary Search\\n        int left = 0;\\n        int right = price.back() - price[0];\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (isValid(price, mid, k)) {\\n                result = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper Method\\n    // Returns true or false based on if the threshold value or greater than threshold value can be equal to\\n    // the minimum of the absolute differences of k pairs in price array\\n    // Basically find a subsequence from price array where the difference is greater than equal to threshold.\\n    bool isValid(vector<int> &price, int threshold, int k) {\\n        int count = 1, i = 1, last = 0;\\n        while (count < k && i < price.size()) {\\n            if (price[i] - price[last] >= threshold) {\\n                last = i;\\n                count++;\\n            }\\n            i++;\\n        }\\n\\n        return count == k;\\n    }\\n\\n    // Method that returns the maximum value of the smallest absolute difference of the prices of any two candies in\\n    // the basket with k candies.\\n    int maximumTastiness(vector<int> &price, int k) {\\n        // Sort the array in ascending order\\n        sort(price.begin(), price.end());\\n\\n        // Result variable\\n        int result = INT_MIN;\\n\\n        // Implement a Binary Search\\n        int left = 0;\\n        int right = price.back() - price[0];\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (isValid(price, mid, k)) {\\n                result = mid;\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901142,
                "title": "binary-search-on-solution-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number of candies, given the tastiness, can be calculated in linear time and is monotonic. So we can binary search on the solution space.\\n\\n# Complexity\\n- Time complexity: $O(N*log(Nk))$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn maximum_tastiness(mut price: Vec<i32>, k: i32) -> i32 {\\n        price.sort_unstable();\\n\\n        let count_candies = |min_diff| {\\n            let mut count = 1;\\n            let mut diff = 0;\\n            for i in 1..price.len() {\\n                diff += price[i] - price[i - 1];\\n                if diff >= min_diff {\\n                    diff = 0;\\n                    count += 1;\\n                }\\n            }\\n            count\\n        };\\n\\n        let mut lo = 0;\\n        let mut hi = *price.last().unwrap() - *price.first().unwrap();\\n        while lo < hi {\\n            let mid = lo + (hi - lo + 1) / 2;\\n            if count_candies(mid) >= k { lo = mid }\\n            else { hi = mid - 1 }\\n        }\\n        lo\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn maximum_tastiness(mut price: Vec<i32>, k: i32) -> i32 {\\n        price.sort_unstable();\\n\\n        let count_candies = |min_diff| {\\n            let mut count = 1;\\n            let mut diff = 0;\\n            for i in 1..price.len() {\\n                diff += price[i] - price[i - 1];\\n                if diff >= min_diff {\\n                    diff = 0;\\n                    count += 1;\\n                }\\n            }\\n            count\\n        };\\n\\n        let mut lo = 0;\\n        let mut hi = *price.last().unwrap() - *price.first().unwrap();\\n        while lo < hi {\\n            let mid = lo + (hi - lo + 1) / 2;\\n            if count_candies(mid) >= k { lo = mid }\\n            else { hi = mid - 1 }\\n        }\\n        lo\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3890992,
                "title": "simple-binary-search-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n  Question type like  maximize the minimum  or  minimize the maximum \\n Always try to apply  Binary + Greedy  approch  (which is called  binary search on ans)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(Nlog(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        int n=price.size();\\n        int s=0,e=price[n-1]-price[0];\\n        while(s<e)\\n        {\\n            int mid=(s+e+1)/2;\\n\\n            auto check=[&](){\\n                int c=1,val=price[0];\\n                for(int i=1;i<n && c<k;i++)\\n                {\\n                    if(price[i]-val>=mid)\\n                    {\\n                        c++;val=price[i];\\n                    }\\n                }\\n                return c>=k;\\n            };\\n            if(check())\\n            s=mid;\\n            else\\n            e=mid-1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        int n=price.size();\\n        int s=0,e=price[n-1]-price[0];\\n        while(s<e)\\n        {\\n            int mid=(s+e+1)/2;\\n\\n            auto check=[&](){\\n                int c=1,val=price[0];\\n                for(int i=1;i<n && c<k;i++)\\n                {\\n                    if(price[i]-val>=mid)\\n                    {\\n                        c++;val=price[i];\\n                    }\\n                }\\n                return c>=k;\\n            };\\n            if(check())\\n            s=mid;\\n            else\\n            e=mid-1;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839590,
                "title": "beats-percent-sorting-with-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumTastiness(self, price, k):\\n        \"\"\"\\n        :type price: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        price.sort()\\n\\n        def check_valid(diff):\\n            diff1 = price[0] + diff\\n            cnt = 1\\n            for num in price:\\n                if num >= diff1:\\n                        cnt+=1\\n                        diff1 = num+diff\\n            return cnt\\n\\n\\n\\n        l = 0\\n        r = max(price)-min(price)\\n\\n        while l<=r:\\n            mid = (l+r)//2\\n\\n            if check_valid(mid) >=k:\\n                ans = mid\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n    \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumTastiness(self, price, k):\\n        \"\"\"\\n        :type price: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        price.sort()\\n\\n        def check_valid(diff):\\n            diff1 = price[0] + diff\\n            cnt = 1\\n            for num in price:\\n                if num >= diff1:\\n                        cnt+=1\\n                        diff1 = num+diff\\n            return cnt\\n\\n\\n\\n        l = 0\\n        r = max(price)-min(price)\\n\\n        while l<=r:\\n            mid = (l+r)//2\\n\\n            if check_valid(mid) >=k:\\n                ans = mid\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830898,
                "title": "python-3-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogk)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        if k == 0:\\n            return 0\\n            \\n        price.sort()\\n        left = 0\\n        right = price[-1] - price[0]\\n        ans = -1\\n        while left <= right:\\n            mid = (right + left) // 2\\n            if self.feasible(price, mid, k):\\n                left = mid + 1\\n                ans = mid\\n            else:\\n                right = mid - 1\\n        \\n        return ans\\n    \\n    def feasible(self, price, tastydiff, k):\\n        count = 1\\n        diff = price[0] + tastydiff\\n        for i in range(1, len(price)):\\n            if price[i] >= diff:\\n                diff = price[i] + tastydiff\\n                count += 1\\n            \\n        return count >= k\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        if k == 0:\\n            return 0\\n            \\n        price.sort()\\n        left = 0\\n        right = price[-1] - price[0]\\n        ans = -1\\n        while left <= right:\\n            mid = (right + left) // 2\\n            if self.feasible(price, mid, k):\\n                left = mid + 1\\n                ans = mid\\n            else:\\n                right = mid - 1\\n        \\n        return ans\\n    \\n    def feasible(self, price, tastydiff, k):\\n        count = 1\\n        diff = price[0] + tastydiff\\n        for i in range(1, len(price)):\\n            if price[i] >= diff:\\n                diff = price[i] + tastydiff\\n                count += 1\\n            \\n        return count >= k\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829741,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int> arr,int diff,int k)\\n    {\\n        int count = 1,first = arr[0];\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n           if(arr[i]-first >=diff)\\n           {\\n               count++;\\n               first = arr[i];\\n           }\\n        }\\n        return count>=k;\\n    }\\n    int maximumTastiness(vector<int>& arr, int k) {\\n\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        int left = 0,right = arr[n-1]-arr[0],ans = 0;\\n        if(k==1) return arr[n-1];\\n\\n        while(left<=right)\\n        {\\n            int mid = (left+right)/2;\\n            if(check(arr,mid,k))\\n            {\\n                ans = mid;\\n                left = mid+1;\\n            }\\n            else\\n             right = mid-1;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> arr,int diff,int k)\\n    {\\n        int count = 1,first = arr[0];\\n        for(int i = 0;i<arr.size();i++)\\n        {\\n           if(arr[i]-first >=diff)\\n           {\\n               count++;\\n               first = arr[i];\\n           }\\n        }\\n        return count>=k;\\n    }\\n    int maximumTastiness(vector<int>& arr, int k) {\\n\\n        sort(arr.begin(),arr.end());\\n        int n = arr.size();\\n        int left = 0,right = arr[n-1]-arr[0],ans = 0;\\n        if(k==1) return arr[n-1];\\n\\n        while(left<=right)\\n        {\\n            int mid = (left+right)/2;\\n            if(check(arr,mid,k))\\n            {\\n                ans = mid;\\n                left = mid+1;\\n            }\\n            else\\n             right = mid-1;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825857,
                "title": "js-binary-search-solution-beats-100-on-time",
                "content": "# Intuition\\nfrom the constraints we can see that we should use binary search, since the price[i] can be up to a billion. As the search function we can just g through the array collecting candies when the difference is larger or equal to k.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n log n) log n for the binary search, n for collecting the candies\\nalso sorting is n log n.\\n- Space complexity:\\nO(1), we don\\'t use any extra storage other than a couple of variables\\n# Code\\n```\\n/**\\n * @param {number[]} price\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximumTastiness = function(price, k) {\\n    price.sort((a,b) => a-b)\\n    const getCandies = (mid) => {\\n        let lastValue = price[0]\\n        let collected = 1\\n        for(let i = 1; i < price.length; i++) {\\n            if (price[i] - lastValue >= mid) {\\n                lastValue = price[i]\\n                collected++\\n            }\\n            if (collected >= k) return true\\n        }\\n        return false\\n    }\\n    let left = 0;\\n    let right = 10 ** 9\\n    let mid = Math.floor((left + right) / 2)\\n    while (left <= right) {\\n        if (getCandies(mid)) left = mid + 1\\n        else right = mid - 1\\n        mid = Math.floor((left + right) / 2)\\n    }\\n    return mid\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} price\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximumTastiness = function(price, k) {\\n    price.sort((a,b) => a-b)\\n    const getCandies = (mid) => {\\n        let lastValue = price[0]\\n        let collected = 1\\n        for(let i = 1; i < price.length; i++) {\\n            if (price[i] - lastValue >= mid) {\\n                lastValue = price[i]\\n                collected++\\n            }\\n            if (collected >= k) return true\\n        }\\n        return false\\n    }\\n    let left = 0;\\n    let right = 10 ** 9\\n    let mid = Math.floor((left + right) / 2)\\n    while (left <= right) {\\n        if (getCandies(mid)) left = mid + 1\\n        else right = mid - 1\\n        mid = Math.floor((left + right) / 2)\\n    }\\n    return mid\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3811175,
                "title": "simple-solution-using-binary-search-in-c",
                "content": "# Approach\\nsorting + BinarySearch\\n-> binary search on the answer.\\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumTastiness(int[] price, int k) {\\n       // return 0;\\n        Array.Sort(price);\\n        int ans = 0;\\n        int start = 0;\\n        int end = (int)1e9;\\n        while(start <= end){\\n\\n            int mid = (start + end) / 2;\\n            int pick = 1;\\n            int curr = price[0];\\n            for(int i=1;i<price.Length;i++){\\n                //pick k elements\\n                if(Math.Abs(curr - price[i]) >= mid){\\n                    pick++;\\n                    curr = price[i];\\n                }\\n            }\\n            if(pick >= k){\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid - 1;\\n            }\\n        }\\n     \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumTastiness(int[] price, int k) {\\n       // return 0;\\n        Array.Sort(price);\\n        int ans = 0;\\n        int start = 0;\\n        int end = (int)1e9;\\n        while(start <= end){\\n\\n            int mid = (start + end) / 2;\\n            int pick = 1;\\n            int curr = price[0];\\n            for(int i=1;i<price.Length;i++){\\n                //pick k elements\\n                if(Math.Abs(curr - price[i]) >= mid){\\n                    pick++;\\n                    curr = price[i];\\n                }\\n            }\\n            if(pick >= k){\\n                ans = mid;\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid - 1;\\n            }\\n        }\\n     \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800527,
                "title": "best-cpp-solution-try-it-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool helper(vector<int>& price , int k , int diff)\\n{\\n    int n = price.size();\\n    int first = price[0];\\n    int count = 1;\\n    for(int i=0; i<n; i++)\\n    {\\n        if((price[i]-first)>=diff)\\n        {\\n            count += 1;\\n            first = price[i];\\n        }\\n    }\\n    if(count>=k)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }\\n}\\n    int maximumTastiness(vector<int>& price, int k) \\n    {\\n        int n = price.size();\\n        int ans = 0;\\n        sort(price.begin() , price.end());\\n        int s = 0;\\n        int e = price[n-1]-price[0];\\n        while(s<=e)\\n        {\\n            int mid = s + (e-s)/2;\\n            if(helper(price , k , mid))\\n            {\\n                ans = mid;\\n                s = mid + 1;\\n            }\\n            else\\n            {\\n                e = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool helper(vector<int>& price , int k , int diff)\\n{\\n    int n = price.size();\\n    int first = price[0];\\n    int count = 1;\\n    for(int i=0; i<n; i++)\\n    {\\n        if((price[i]-first)>=diff)\\n        {\\n            count += 1;\\n            first = price[i];\\n        }\\n    }\\n    if(count>=k)\\n    {\\n        return true;\\n    }\\n    else\\n    {\\n        return false;\\n    }\\n}\\n    int maximumTastiness(vector<int>& price, int k) \\n    {\\n        int n = price.size();\\n        int ans = 0;\\n        sort(price.begin() , price.end());\\n        int s = 0;\\n        int e = price[n-1]-price[0];\\n        while(s<=e)\\n        {\\n            int mid = s + (e-s)/2;\\n            if(helper(price , k , mid))\\n            {\\n                ans = mid;\\n                s = mid + 1;\\n            }\\n            else\\n            {\\n                e = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793777,
                "title": "simple-binary-search",
                "content": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        \\n        price.sort()\\n        s,e,ans=0,price[-1]-price[0],0\\n        while s<=e:\\n            mid=(s+e)//2\\n            last,cnt=price[0],1\\n            for i in range(1,len(price)):\\n                if price[i]-last>=mid:\\n                    cnt+=1\\n                    last=price[i]\\n            if cnt>=k:\\n                ans=max(mid,ans)\\n                s=mid+1\\n            else:\\n                e=mid-1\\n        return ans \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        \\n        price.sort()\\n        s,e,ans=0,price[-1]-price[0],0\\n        while s<=e:\\n            mid=(s+e)//2\\n            last,cnt=price[0],1\\n            for i in range(1,len(price)):\\n                if price[i]-last>=mid:\\n                    cnt+=1\\n                    last=price[i]\\n            if cnt>=k:\\n                ans=max(mid,ans)\\n                s=mid+1\\n            else:\\n                e=mid-1\\n        return ans \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777751,
                "title": "apply-binary-search-to-find-tastiness-from-0-min-to-price-last-price-first-max-after-sorting",
                "content": "# Intuition\\n    Similar approach to Aggresive Cows\\n\\n    https://takeuforward.org/data-structure/aggressive-cows-detailed-solution/\\n    \\n    https://www.spoj.com/problems/AGGRCOW/\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn + (max - min)*logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkTastiness(vector<int>& price, int k, int t){\\n        int cnt = 1;\\n        int ptr = price[0];\\n        for(int i = 1; i < price.size(); i++){\\n            if(price[i] - ptr >= t){\\n                cnt++;\\n                ptr = price[i];\\n            }\\n        } \\n        if(cnt >= k){\\n            return true;\\n        }\\n        return false;\\n    } \\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int n = price.size();\\n        int low = 0;\\n        int high = price[n - 1] - price[0];\\n        int mid;\\n        int ans;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            if(checkTastiness(price, k, mid)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTastiness(vector<int>& price, int k, int t){\\n        int cnt = 1;\\n        int ptr = price[0];\\n        for(int i = 1; i < price.size(); i++){\\n            if(price[i] - ptr >= t){\\n                cnt++;\\n                ptr = price[i];\\n            }\\n        } \\n        if(cnt >= k){\\n            return true;\\n        }\\n        return false;\\n    } \\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int n = price.size();\\n        int low = 0;\\n        int high = price[n - 1] - price[0];\\n        int mid;\\n        int ans;\\n        while(low <= high){\\n            mid = low + (high - low)/2;\\n            if(checkTastiness(price, k, mid)){\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769465,
                "title": "binary-search-by-value",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mlog(N)), m is the length of array, N is 10 ** 9\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        def isFind(x):\\n            prev, count, i = price[0], 1, 1\\n            while i < n:\\n                if price[i] - prev >= x:\\n                    prev, count = price[i], count + 1\\n                i += 1\\n                if count >= k:\\n                    return True\\n            return False\\n        \\n        price.sort()\\n        n = len(price)\\n        l, r = 1, 10 ** 9\\n        while l <= r:\\n            m = l + (r - l) // 2\\n            if isFind(m):\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return r\\n        \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        def isFind(x):\\n            prev, count, i = price[0], 1, 1\\n            while i < n:\\n                if price[i] - prev >= x:\\n                    prev, count = price[i], count + 1\\n                i += 1\\n                if count >= k:\\n                    return True\\n            return False\\n        \\n        price.sort()\\n        n = len(price)\\n        l, r = 1, 10 ** 9\\n        while l <= r:\\n            m = l + (r - l) // 2\\n            if isFind(m):\\n                l = m + 1\\n            else:\\n                r = m - 1\\n        return r\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767542,
                "title": "simple-binary-search-method-in-python-that-beats-100-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        r = price[-1] - price[0]\\n        l = 0\\n        n = len(price)\\n\\n        while l <= r:\\n            mid = (l+r) // 2\\n            t_num = 1\\n            cur_v = price[0]\\n            for i in range(1, n):\\n                if price[i] >= cur_v + mid:\\n                    cur_v = price[i]\\n                    t_num += 1\\n                    if t_num >= k:\\n                        break\\n            if t_num >= k:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n            \\n        return r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        r = price[-1] - price[0]\\n        l = 0\\n        n = len(price)\\n\\n        while l <= r:\\n            mid = (l+r) // 2\\n            t_num = 1\\n            cur_v = price[0]\\n            for i in range(1, n):\\n                if price[i] >= cur_v + mid:\\n                    cur_v = price[i]\\n                    t_num += 1\\n                    if t_num >= k:\\n                        break\\n            if t_num >= k:\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n            \\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763386,
                "title": "easy-to-get-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int low=0;\\n        int high=price[price.length-1];\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isValid(mid,price,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean isValid(int target,int[] price,int k){\\n        int prev=price[0];\\n        int cnt=1;\\n        for(int i=1;i<price.length;i++){\\n            if(price[i]-prev>=target){\\n                cnt++;\\n                prev=price[i];\\n            }\\n        }\\n        if(cnt>=k)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int low=0;\\n        int high=price[price.length-1];\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isValid(mid,price,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean isValid(int target,int[] price,int k){\\n        int prev=price[0];\\n        int cnt=1;\\n        for(int i=1;i<price.length;i++){\\n            if(price[i]-prev>=target){\\n                cnt++;\\n                prev=price[i];\\n            }\\n        }\\n        if(cnt>=k)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761213,
                "title": "c-solution-using-binary-search-w-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        //sort prices from low to high\\n        sort(price.begin(), price.end());\\n        \\n        //set the initial values\\n        //max_taste could at MOST be the difference between the biggest and smallest price\\n        //min_taste could at the LEAST be 0\\n        //optimal_taste is currently 0 as we cannot assume that a difference > 0 exists\\n        int max_taste = price[price.size()-1] - price[0];\\n        int min_taste = 0;\\n        int optimal_taste = 0;\\n\\n        while (min_taste <= max_taste) {\\n            // Calculate the middle value between the current min and max\\n            int current_mid_taste = min_taste + (max_taste - min_taste) / 2;\\n\\n            // Check if the taste given at the middle taste level can be achieved by k or more values\\n            if (taste_helper(price, k, current_mid_taste)) {\\n                //if yes, reset our optimal taste to the current value set the minimum taste to the middle taste + 1\\n                optimal_taste = current_mid_taste;\\n                min_taste = current_mid_taste + 1;\\n            } else {\\n                //When unattainable decrease the maximum possible taste to less than the middle value\\n                max_taste = current_mid_taste - 1;\\n            }\\n        }\\n        /* The value of optimal taste will, at the end of the loop be equal to the max possible \\n        \\'taste\\' of a candy basket selected with k items as it will be the value of optimal taste \\n        will be equal to the largest possible difference achieveable by the minimum of the differences\\n        between k \\'candies\\' */\\n        return optimal_taste;\\n    }\\n\\n    bool taste_helper(vector<int>& price, int k, int current_middle_taste) {\\n        //Get the price of the smallest candy\\n        int number_candies = 1;\\n        int price_at_beginning = price[0];\\n\\n        //Figure out how many candies could form a set with a minimmum taste of the\\n        //current middle taste\\n        for (int i = 1; i < price.size(); i++) {\\n            if ((price[i] - price_at_beginning) >= current_middle_taste) {\\n                number_candies ++;\\n                price_at_beginning = price[i];\\n            }\\n        }\\n        //Return the boolean representing whether it was possible to make a set\\n        //valued at middle tastieness with at least K candies\\n        return number_candies >= k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        //sort prices from low to high\\n        sort(price.begin(), price.end());\\n        \\n        //set the initial values\\n        //max_taste could at MOST be the difference between the biggest and smallest price\\n        //min_taste could at the LEAST be 0\\n        //optimal_taste is currently 0 as we cannot assume that a difference > 0 exists\\n        int max_taste = price[price.size()-1] - price[0];\\n        int min_taste = 0;\\n        int optimal_taste = 0;\\n\\n        while (min_taste <= max_taste) {\\n            // Calculate the middle value between the current min and max\\n            int current_mid_taste = min_taste + (max_taste - min_taste) / 2;\\n\\n            // Check if the taste given at the middle taste level can be achieved by k or more values\\n            if (taste_helper(price, k, current_mid_taste)) {\\n                //if yes, reset our optimal taste to the current value set the minimum taste to the middle taste + 1\\n                optimal_taste = current_mid_taste;\\n                min_taste = current_mid_taste + 1;\\n            } else {\\n                //When unattainable decrease the maximum possible taste to less than the middle value\\n                max_taste = current_mid_taste - 1;\\n            }\\n        }\\n        /* The value of optimal taste will, at the end of the loop be equal to the max possible \\n        \\'taste\\' of a candy basket selected with k items as it will be the value of optimal taste \\n        will be equal to the largest possible difference achieveable by the minimum of the differences\\n        between k \\'candies\\' */\\n        return optimal_taste;\\n    }\\n\\n    bool taste_helper(vector<int>& price, int k, int current_middle_taste) {\\n        //Get the price of the smallest candy\\n        int number_candies = 1;\\n        int price_at_beginning = price[0];\\n\\n        //Figure out how many candies could form a set with a minimmum taste of the\\n        //current middle taste\\n        for (int i = 1; i < price.size(); i++) {\\n            if ((price[i] - price_at_beginning) >= current_middle_taste) {\\n                number_candies ++;\\n                price_at_beginning = price[i];\\n            }\\n        }\\n        //Return the boolean representing whether it was possible to make a set\\n        //valued at middle tastieness with at least K candies\\n        return number_candies >= k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760090,
                "title": "golang-binary-search-solution",
                "content": "# Code\\n```go\\nfunc maximumTastiness(price []int, k int) int {\\n    priceMap := make(map[int]struct{}, len(price))\\n    for _, p := range price {\\n        priceMap[p] = struct{}{}\\n    }\\n    price = make([]int, 0, len(priceMap))\\n    for k := range priceMap {\\n        price = append(price, k)\\n    }\\n    sort.Ints(price)\\n\\n    if len(price) < k {\\n        // duplicate exists\\n        return 0\\n    }\\n\\n    // binary-search\\n    l, r := 1, price[len(price)-1]-price[0]\\n    for l <= r {\\n        m := (l+r)>>1\\n        if isOK(price, k, m) {\\n            l = m+1\\n        } else {\\n            r = m-1\\n        }\\n    }\\n    return l-1\\n}\\n\\nfunc isOK(price []int, k int, diff int) bool {\\n    last := price[0]\\n    k--\\n    for i := 1; i < len(price); i++ {\\n        if price[i] - last >= diff {\\n            k--\\n            if k == 0 {\\n                return true\\n            }\\n            last = price[i]\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```go\\nfunc maximumTastiness(price []int, k int) int {\\n    priceMap := make(map[int]struct{}, len(price))\\n    for _, p := range price {\\n        priceMap[p] = struct{}{}\\n    }\\n    price = make([]int, 0, len(priceMap))\\n    for k := range priceMap {\\n        price = append(price, k)\\n    }\\n    sort.Ints(price)\\n\\n    if len(price) < k {\\n        // duplicate exists\\n        return 0\\n    }\\n\\n    // binary-search\\n    l, r := 1, price[len(price)-1]-price[0]\\n    for l <= r {\\n        m := (l+r)>>1\\n        if isOK(price, k, m) {\\n            l = m+1\\n        } else {\\n            r = m-1\\n        }\\n    }\\n    return l-1\\n}\\n\\nfunc isOK(price []int, k int, diff int) bool {\\n    last := price[0]\\n    k--\\n    for i := 1; i < len(price); i++ {\\n        if price[i] - last >= diff {\\n            k--\\n            if k == 0 {\\n                return true\\n            }\\n            last = price[i]\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3756865,
                "title": "c-binary-search-beats-95",
                "content": "\\n# Approach\\nTask is simillar to one well-known russian problem - \"\\u041A\\u043E\\u0440\\u043E\\u0432\\u044B \\u0432 \\u0441\\u0442\\u043E\\u0439\\u043B\\u0430\" or \"Agressive Cows\", so I will write a solution for it.\\n\\nObviously that most optimal is to take first element as left bound and than using binary search we will find maximum distance between each cow. As right bound we will use LAST_ELEMENT - FIRST_ELEMENT + 1\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& a, int k, int d) {\\n        int now = 1;\\n        int last = a[0];\\n        for (int i: a) {\\n            if (i - last >= d) {\\n                now++;\\n                last = i;\\n            }\\n        }\\n        return now >= k;\\n    }\\n\\n    int maximumTastiness(vector<int>& a, int k) {\\n        sort(a.begin(), a.end());\\n        int l = 0, r = a.back() - a[0] + 1;\\n        while (l + 1 < r) {\\n            int m = (l + r) >> 1;\\n            if (check(a, k, m)) l = m;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& a, int k, int d) {\\n        int now = 1;\\n        int last = a[0];\\n        for (int i: a) {\\n            if (i - last >= d) {\\n                now++;\\n                last = i;\\n            }\\n        }\\n        return now >= k;\\n    }\\n\\n    int maximumTastiness(vector<int>& a, int k) {\\n        sort(a.begin(), a.end());\\n        int l = 0, r = a.back() - a[0] + 1;\\n        while (l + 1 < r) {\\n            int m = (l + r) >> 1;\\n            if (check(a, k, m)) l = m;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733751,
                "title": "a-hopefully-easy-to-understand-python-solution-with-ta-da-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFirst of all, let\\'s notice that the possible range of values for this `price` list `[0, max(price) - min(price)]`. \\n\\nGiven that we sort the value first to further apply binary search, we can think of this range as `[0, price[-1] - price[0]]`.\\n\\nWe can now use binary search to check whether we can have `k` elements in a sublist for the given `price` list. \\n\\nThe rest is pure implementation - we need to be careful and not make any off-by-one errors and we\\'re good to go. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- **Time complexity**: $O(N\\\\log{N})$\\nThe dominating source of complexity is quite expectedly the sorting. \\nRandom trivia: Python uses TimSort but that is unfortunately still no faster than $O(N\\\\cdot\\\\log{N})$\\n\\n- **Space complexity**: $O(1)$\\nWe only use a constant number of variables to solve the problem. The size of the input list doesn\\'t matter so we happily get $O(1)$ space complexity. \\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n\\n        ans = -float(\"inf\")\\n        l, r = 0, price[-1] - price[0]\\n\\n        while l <= r: \\n            mid = (l + r) // 2\\n            if self.isPossible(price, k, mid):\\n                ans = max(ans, mid)\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return ans\\n    \\n\\n    def isPossible(self, price, k, x):\\n        curr = price[0]\\n        count = 1\\n\\n        for i in range(1, len(price)):\\n            if price[i] - curr >= x:\\n                count+=1\\n                curr = price[i]\\n\\n        return count >= k\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n\\n        ans = -float(\"inf\")\\n        l, r = 0, price[-1] - price[0]\\n\\n        while l <= r: \\n            mid = (l + r) // 2\\n            if self.isPossible(price, k, mid):\\n                ans = max(ans, mid)\\n                l = mid + 1\\n            else:\\n                r = mid - 1\\n        return ans\\n    \\n\\n    def isPossible(self, price, k, x):\\n        curr = price[0]\\n        count = 1\\n\\n        for i in range(1, len(price)):\\n            if price[i] - curr >= x:\\n                count+=1\\n                curr = price[i]\\n\\n        return count >= k\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733247,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    private boolean valid(int []price, int x, int k){\\n        int prev = price[0], count = 1;\\n        for(int i=1;i<price.length;i++){\\n            if(price[i]-prev >= x){\\n                count++;\\n                prev = price[i];\\n            }\\n        }\\n        return count >= k;\\n    }\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int n = price.length, s = 0, e = price[n-1]-price[s], res = 0;\\n        if(k == 2) return price[n-1]-price[s];\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(valid(price, mid, k)){\\n                res = mid;\\n                s = mid+1;\\n            }\\n            else e = mid-1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    private boolean valid(int []price, int x, int k){\\n        int prev = price[0], count = 1;\\n        for(int i=1;i<price.length;i++){\\n            if(price[i]-prev >= x){\\n                count++;\\n                prev = price[i];\\n            }\\n        }\\n        return count >= k;\\n    }\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int n = price.length, s = 0, e = price[n-1]-price[s], res = 0;\\n        if(k == 2) return price[n-1]-price[s];\\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(valid(price, mid, k)){\\n                res = mid;\\n                s = mid+1;\\n            }\\n            else e = mid-1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726241,
                "title": "simple-binary-search-sorting",
                "content": "# Complexity\\n- Time complexity:\\nO(n log n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool isCheck(vector<int> &price, int mid, int k){\\n    int prev = price[0], count = 0;\\n\\n    for(int i=1 ;i<price.size() ;i++){\\n        if(price[i]-prev>=mid){\\n            prev = price[i];\\n            count++;\\n        }\\n    }\\n    count++;\\n    return count>=k;\\n}\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int n = price.size();\\n        sort(price.begin(), price.end());\\n\\n        int s = 0, e = price[n-1]-price[0];\\n        if(k==2)\\n        return e;\\n\\n        int mid = s+(e-s)/2, ans = s;\\n        while(s<=e){\\n\\n            if(isCheck(price, mid, k)){\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else\\n            e = mid-1;\\n            mid = s+(e-s)/2;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool isCheck(vector<int> &price, int mid, int k){\\n    int prev = price[0], count = 0;\\n\\n    for(int i=1 ;i<price.size() ;i++){\\n        if(price[i]-prev>=mid){\\n            prev = price[i];\\n            count++;\\n        }\\n    }\\n    count++;\\n    return count>=k;\\n}\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int n = price.size();\\n        sort(price.begin(), price.end());\\n\\n        int s = 0, e = price[n-1]-price[0];\\n        if(k==2)\\n        return e;\\n\\n        int mid = s+(e-s)/2, ans = s;\\n        while(s<=e){\\n\\n            if(isCheck(price, mid, k)){\\n                ans = mid;\\n                s = mid+1;\\n            }\\n            else\\n            e = mid-1;\\n            mid = s+(e-s)/2;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713206,
                "title": "beats-100-binary-search-on-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isok(vector<int>& price , int mid , int k){\\n        int cnt = 1 ;\\n        int start = price[0];\\n        for(auto i : price){\\n            if(abs(start - i) >= mid){\\n                cnt++;\\n                start = i;\\n            }\\n        }\\n        if(cnt >= k)return true ;\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        ios_base::sync_with_stdio(false);\\n        sort(price.begin() , price.end());\\n        int s = 0 ;\\n        int e = *max_element(price.begin() , price.end());\\n        int ans = 0;\\n        while(s <= e){\\n            int mid = s + (e-s)/2 ;\\n            if(isok(price , mid , k)){\\n              ans = mid ;\\n              s = mid + 1; \\n            }\\n            else{\\n              e = mid - 1 ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isok(vector<int>& price , int mid , int k){\\n        int cnt = 1 ;\\n        int start = price[0];\\n        for(auto i : price){\\n            if(abs(start - i) >= mid){\\n                cnt++;\\n                start = i;\\n            }\\n        }\\n        if(cnt >= k)return true ;\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        ios_base::sync_with_stdio(false);\\n        sort(price.begin() , price.end());\\n        int s = 0 ;\\n        int e = *max_element(price.begin() , price.end());\\n        int ans = 0;\\n        while(s <= e){\\n            int mid = s + (e-s)/2 ;\\n            if(isok(price , mid , k)){\\n              ans = mid ;\\n              s = mid + 1; \\n            }\\n            else{\\n              e = mid - 1 ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687340,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int low=0;\\n        int high=price[price.length-1];\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isValid(mid,price,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean isValid(int target,int[] price,int k){\\n        int prev=price[0];\\n        int cnt=1;\\n        for(int i=1;i<price.length;i++){\\n            if(price[i]-prev>=target){\\n                cnt++;\\n                prev=price[i];\\n            }\\n        }\\n        if(cnt>=k)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int low=0;\\n        int high=price[price.length-1];\\n        int ans=-1;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(isValid(mid,price,k)){\\n                ans=mid;\\n                low=mid+1;\\n            }\\n            else\\n                high=mid-1;\\n        }\\n        return ans;\\n    }\\n    public boolean isValid(int target,int[] price,int k){\\n        int prev=price[0];\\n        int cnt=1;\\n        for(int i=1;i<price.length;i++){\\n            if(price[i]-prev>=target){\\n                cnt++;\\n                prev=price[i];\\n            }\\n        }\\n        if(cnt>=k)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656389,
                "title": "very-simple-technique-using-predicate-function",
                "content": "# Intuition\\nThis problem is same as Agressive Cows. If you have not seen that please go and try it then solve this question.You can see the tutorial of agressive cows on \"LUV CP\" youtube channel.\\n\\n# Approach\\nSimple binary search to find the last integer that can satisfy the given equation.\\n\\n\\n# Complexity\\n- Time complexity : O(nlogn)\\n\\n\\n- Space complexity : O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isTasty(int mini, vector<int> &price, int candies){\\n        int lastcandy = -1;\\n        for(int i = 0; i<price.size(); i++){\\n            if(lastcandy == -1 || price[i] - lastcandy >= mini){\\n                lastcandy = price[i];\\n                candies--;\\n            }\\n            if(candies == 0) break;\\n        }\\n        if(candies == 0) return true;\\n        return false;\\n\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int lo = 0, hi = 1e9+10;\\n        int ans = 0;\\n        sort(price.begin(), price.end());\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(isTasty(mid, price, k)){\\n                ans = max(ans, mid);\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isTasty(int mini, vector<int> &price, int candies){\\n        int lastcandy = -1;\\n        for(int i = 0; i<price.size(); i++){\\n            if(lastcandy == -1 || price[i] - lastcandy >= mini){\\n                lastcandy = price[i];\\n                candies--;\\n            }\\n            if(candies == 0) break;\\n        }\\n        if(candies == 0) return true;\\n        return false;\\n\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int lo = 0, hi = 1e9+10;\\n        int ans = 0;\\n        sort(price.begin(), price.end());\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(isTasty(mid, price, k)){\\n                ans = max(ans, mid);\\n                lo = mid+1;\\n            }\\n            else{\\n                hi = mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640902,
                "title": "binary-search-sort",
                "content": "\\nwe can sort the price array to check if we can pick k candies for a given tastiness. maximum diff for the whole array after sorting would be x=price[n-1]-price[0].\\nnow we use binary search to search over the range (0, x). we check if its possible to get a subsequnce of size k with difference of every 2 elements is equal to middle of our search range.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int diff, int k, vector<int>&price, int n){\\n        int cnt=1;\\n        int prev=price[0];\\n        int i=1;\\n        while(i<n){\\n            if(price[i]-prev >= diff){\\n                cnt++;\\n                prev=price[i];\\n            }\\n            i++;\\n        }\\n        return cnt>=k;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int ans=0;\\n        int n=price.size();\\n        if(n<k) return 0;\\n        sort(price.begin(),price.end());\\n        int l=0, r=price[n-1]-price[0];\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(check(mid,k,price,n)){\\n                l=mid+1;\\n                ans=mid;\\n            }else r=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int diff, int k, vector<int>&price, int n){\\n        int cnt=1;\\n        int prev=price[0];\\n        int i=1;\\n        while(i<n){\\n            if(price[i]-prev >= diff){\\n                cnt++;\\n                prev=price[i];\\n            }\\n            i++;\\n        }\\n        return cnt>=k;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int ans=0;\\n        int n=price.size();\\n        if(n<k) return 0;\\n        sort(price.begin(),price.end());\\n        int l=0, r=price[n-1]-price[0];\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(check(mid,k,price,n)){\\n                l=mid+1;\\n                ans=mid;\\n            }else r=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548869,
                "title": "very-easy-method-binary-search-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo use binary search.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimilar question is aggressive cows. Our search space for binary search is minimum difference between two candies and maximum difference between two candies. We\\'ll sort the price array as to get the smallest absolute difference. Binary search will give us an expected tastiness and we\\'ll check whether our all k candy basket get filled out by this expected tastiness. If this happens we store that expected tastiness and move our start iterator to expected tastiness plus 1 value. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& arr, int k, int mid )\\n    {\\n        int basket_Count = 1;\\n        int price = arr[0];\\n        for(int i=1; i<arr.size(); i++)\\n        {\\n            if(arr[i] - price >=  mid )\\n            {\\n                basket_Count++;\\n\\n                if( basket_Count == k )\\n                return true;\\n\\n\\n                price = arr[i];\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int largest(vector<int>& p)\\n    {\\n        int maxi = INT_MIN;\\n        for(int i=0; i<p.size(); i++)\\n        {\\n            if(p[i] > maxi)\\n            {\\n                maxi = p[i];\\n            }\\n        }\\n        return maxi;\\n    }\\n\\n    int smallest(vector<int>& p)\\n    {\\n        int mini = INT_MAX;\\n        for(int i=0; i<p.size(); i++)\\n        {\\n            if(p[i] < mini)\\n            {\\n                mini = p[i];\\n            }\\n        }\\n        return mini;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(begin(price), end(price));\\n        int n = price.size();\\n\\n        int s = 0;\\n        int e = price[n-1] - price[0];\\n        int mid =  s + ( e - s )/2;\\n        int res = 0;\\n        while( s <= e )\\n        {\\n            int ans = check(price, k, mid);\\n\\n            if( ans == 1 )\\n            {\\n                res = mid;\\n                s = mid + 1;\\n            }\\n            else\\n            {\\n                e = mid - 1;\\n            }\\n\\n            mid =  s + ( e - s )/2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& arr, int k, int mid )\\n    {\\n        int basket_Count = 1;\\n        int price = arr[0];\\n        for(int i=1; i<arr.size(); i++)\\n        {\\n            if(arr[i] - price >=  mid )\\n            {\\n                basket_Count++;\\n\\n                if( basket_Count == k )\\n                return true;\\n\\n\\n                price = arr[i];\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int largest(vector<int>& p)\\n    {\\n        int maxi = INT_MIN;\\n        for(int i=0; i<p.size(); i++)\\n        {\\n            if(p[i] > maxi)\\n            {\\n                maxi = p[i];\\n            }\\n        }\\n        return maxi;\\n    }\\n\\n    int smallest(vector<int>& p)\\n    {\\n        int mini = INT_MAX;\\n        for(int i=0; i<p.size(); i++)\\n        {\\n            if(p[i] < mini)\\n            {\\n                mini = p[i];\\n            }\\n        }\\n        return mini;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(begin(price), end(price));\\n        int n = price.size();\\n\\n        int s = 0;\\n        int e = price[n-1] - price[0];\\n        int mid =  s + ( e - s )/2;\\n        int res = 0;\\n        while( s <= e )\\n        {\\n            int ans = check(price, k, mid);\\n\\n            if( ans == 1 )\\n            {\\n                res = mid;\\n                s = mid + 1;\\n            }\\n            else\\n            {\\n                e = mid - 1;\\n            }\\n\\n            mid =  s + ( e - s )/2;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525249,
                "title": "solution-with-explanation",
                "content": "\\n# Algorithm:\\n\\n1. Sort the input array price in non-decreasing order.\\n1. Initialize two pointers, left and right. left is initialized to 0 and right is initialized to the difference between the maximum and minimum elements of price.\\n1. While left is less than or equal to right:\\na. Compute the middle element mid of left and right.\\nb. Check if there exists a basket of size k with a minimum absolute difference of mid by calling the CountBaskets method (explained below). If there exists such a basket, then this is best answer so far so see if we can better it by setting left to mid + 1. Otherwise, set right to mid - 1.\\nReturn right (best result).\\n\\n1. The CountBaskets method takes three arguments: the sorted input array price, the integer k, and the minimum absolute difference minDiff that we are trying to find a basket for absolute difference as mid. This method uses two pointers, i and j, to define a sliding window of size k. i is initialized to 0, j is initialized to 1, and count is initialized to 1 (since we already have one candy in the basket). We scan through the sorted price array using the pointer j. We increment j until the difference between price[j] and price[i] is at least minDiff, at which point we increment the counter count and move i to j. If we are unable to find atleast k candies with a minimum absolute difference of at least minDiff, we return false. Otherwise, we return true.\\n\\n# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumTastiness(int[] price, int k) {\\n        Array.Sort(price); \\n        int left = 0, right = price[price.Length - 1] - price[0];\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (CountBaskets(price, k, mid)) {\\n               left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return right;\\n    }\\n\\n    private bool CountBaskets(int[] price, int k, int minDiff) {\\n        int i = 0, j = 1, count = 1;\\n        while (j < price.Length && count < k) {\\n            if (price[j] - price[i] >= minDiff) {\\n                count++;\\n                i = j;\\n            }\\n            j++;\\n        }\\n        return count >= k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumTastiness(int[] price, int k) {\\n        Array.Sort(price); \\n        int left = 0, right = price[price.Length - 1] - price[0];\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (CountBaskets(price, k, mid)) {\\n               left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return right;\\n    }\\n\\n    private bool CountBaskets(int[] price, int k, int minDiff) {\\n        int i = 0, j = 1, count = 1;\\n        while (j < price.Length && count < k) {\\n            if (price[j] - price[i] >= minDiff) {\\n                count++;\\n                i = j;\\n            }\\n            j++;\\n        }\\n        return count >= k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500656,
                "title": "2517-maximum-tastiness-of-candy-basket-java",
                "content": "```\\nclass Solution {\\n    \\n    public int maximumTastiness(int[] price, int k) {\\n        int n=price.length;\\n        Arrays.sort(price);\\n        int l=1,r=price[n-1],ans=0;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2,cnt=1,last=price[0];\\n            for(int i=1;i<n;i++)\\n            {\\n                if(price[i]-last>=mid)\\n                {\\n                    cnt++;\\n                    last=price[i];\\n                }\\n            }\\n            if(cnt>=k)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n                r=mid-1;\\n        }\\n            return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int maximumTastiness(int[] price, int k) {\\n        int n=price.length;\\n        Arrays.sort(price);\\n        int l=1,r=price[n-1],ans=0;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2,cnt=1,last=price[0];\\n            for(int i=1;i<n;i++)\\n            {\\n                if(price[i]-last>=mid)\\n                {\\n                    cnt++;\\n                    last=price[i];\\n                }\\n            }\\n            if(cnt>=k)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n                r=mid-1;\\n        }\\n            return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488383,
                "title": "c-binary-search-solution-with-some-personal-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis isn\\'t my original solution. I just had a hard time understanding the concept of this problem, even after reading other people\\'s solutions, so I tried to write down how I figured it out through annotation. Hope this helps!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- binary search for the correct gap (from 0 ~ maxGAP)\\n- check if current gap can be the minimun gap in the k subset \\n\\n# Complexity\\n- Time complexity: O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: No extra space taken\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool checksubset(vector<int>& price, int k, int checkGAP){\\n        \\n        int count = 1; //checkGAP counts as one element in the k elements subset, therefore count starts with 1\\n        int temp_min = price[0];\\n\\n        for(int i = 1; i < price.size(); i++){\\n\\n            if(price[i] - temp_min >= checkGAP){ //if find any GAP larger than checkGAP, count++\\n                \\n                count++;\\n                temp_min = price[i]; \\n                //ex. checkGAP = 5, price[0] = 1, price[i] = 7, 7-1 > 5\\n                //you have to find x - 7 > 5, otherwise 5 won\\'t be the min GAP in this subset\\n\\n            }\\n\\n        }\\n\\n        if(count >= k){  //if there\\'re more than k-1 GAP greater than midGAP (midGAP can be the min in the k subset)\\n            return true;\\n        }else{\\n            return false;\\n        }\\n\\n    }\\n    \\n    int maximumTastiness(vector<int>& price, int k) {\\n\\n        sort(price.begin(), price.end());       //sort the array to get the max and min\\n        \\n        int maxGAP = price[price.size() - 1] - price[0];\\n        int minGAP = 0, midGAP = 0;\\n\\n        int ans = 0;\\n\\n        while(minGAP <= maxGAP){                //binary search for the correct GAP (from 0 ~ maxGAP)\\n\\n            midGAP = (minGAP + maxGAP + 1) / 2;\\n            \\n            if(checksubset(price, k, midGAP)){  //if there\\'re more than k-1 GAP greater than mid GAP (midGAP can be the min in the k subset)\\n                ans = midGAP;                   //midGAP could be the ans, therefore temporary modify ans\\n                minGAP = midGAP + 1;            //go on search for greater midGAP \\n            }else{\\n                maxGAP = midGAP - 1;            //midGAP can\\'t be the min GAP in any k subset, search for smaller midGAP\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool checksubset(vector<int>& price, int k, int checkGAP){\\n        \\n        int count = 1; //checkGAP counts as one element in the k elements subset, therefore count starts with 1\\n        int temp_min = price[0];\\n\\n        for(int i = 1; i < price.size(); i++){\\n\\n            if(price[i] - temp_min >= checkGAP){ //if find any GAP larger than checkGAP, count++\\n                \\n                count++;\\n                temp_min = price[i]; \\n                //ex. checkGAP = 5, price[0] = 1, price[i] = 7, 7-1 > 5\\n                //you have to find x - 7 > 5, otherwise 5 won\\'t be the min GAP in this subset\\n\\n            }\\n\\n        }\\n\\n        if(count >= k){  //if there\\'re more than k-1 GAP greater than midGAP (midGAP can be the min in the k subset)\\n            return true;\\n        }else{\\n            return false;\\n        }\\n\\n    }\\n    \\n    int maximumTastiness(vector<int>& price, int k) {\\n\\n        sort(price.begin(), price.end());       //sort the array to get the max and min\\n        \\n        int maxGAP = price[price.size() - 1] - price[0];\\n        int minGAP = 0, midGAP = 0;\\n\\n        int ans = 0;\\n\\n        while(minGAP <= maxGAP){                //binary search for the correct GAP (from 0 ~ maxGAP)\\n\\n            midGAP = (minGAP + maxGAP + 1) / 2;\\n            \\n            if(checksubset(price, k, midGAP)){  //if there\\'re more than k-1 GAP greater than mid GAP (midGAP can be the min in the k subset)\\n                ans = midGAP;                   //midGAP could be the ans, therefore temporary modify ans\\n                minGAP = midGAP + 1;            //go on search for greater midGAP \\n            }else{\\n                maxGAP = midGAP - 1;            //midGAP can\\'t be the min GAP in any k subset, search for smaller midGAP\\n            }\\n\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464651,
                "title": "python-binary-search-with-explanation",
                "content": "# Intuition\\n1. We will search for maximum tastiness. If we do linear search then, in the given example, for tastiness of 1, we can pick 6 candies, for 2 , we can pick 4 and so on\\n2. If we sort and do an optimal search using binary search. \\n3. For each tastiness found using binary search we validate if we can pick k candies for that tastiness. If we can pick more then k, means we can still increase tastiness.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n     \\n        ans,low, high = -1,0,max(price)-min(price) #max tastiness will be within the range of l\\n\\n        while low<=high:\\n            mid=(low+high)//2\\n            i=1\\n            candies=1\\n            j=0\\n            while i < len(price):\\n                if price[i]-price[j] >= mid:\\n                  \\n                    candies+=1\\n                    j=i\\n                i+=1\\n            if candies >= k: #if candies for selected tastiness are >= k candies, there is a possibility of getting maximum towards right\\n                ans=mid\\n                low=mid+1\\n            else:\\n                high=mid-1 #if candies for selected tastiness are < k candies, reduce tastiness by moving left to meet requirement of k candies\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n     \\n        ans,low, high = -1,0,max(price)-min(price) #max tastiness will be within the range of l\\n\\n        while low<=high:\\n            mid=(low+high)//2\\n            i=1\\n            candies=1\\n            j=0\\n            while i < len(price):\\n                if price[i]-price[j] >= mid:\\n                  \\n                    candies+=1\\n                    j=i\\n                i+=1\\n            if candies >= k: #if candies for selected tastiness are >= k candies, there is a possibility of getting maximum towards right\\n                ans=mid\\n                low=mid+1\\n            else:\\n                high=mid-1 #if candies for selected tastiness are < k candies, reduce tastiness by moving left to meet requirement of k candies\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441558,
                "title": "beats-96-binary-search",
                "content": "# Code\\n```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        def taste(v):\\n            count = 1\\n            prev = price[0]\\n            for p in price:\\n                if p - prev >= v:\\n                    count += 1\\n                    prev = p\\n            return count >= k\\n\\n        left, right = 0, price[-1] - price[0]\\n        while left < right:\\n            mid = (left + right + 1) // 2\\n            if taste(mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n        return left\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        def taste(v):\\n            count = 1\\n            prev = price[0]\\n            for p in price:\\n                if p - prev >= v:\\n                    count += 1\\n                    prev = p\\n            return count >= k\\n\\n        left, right = 0, price[-1] - price[0]\\n        while left < right:\\n            mid = (left + right + 1) // 2\\n            if taste(mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437559,
                "title": "binary-search-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool res(int mid,vector<int>& price, int k){\\n        int prev=price[0];\\n        int c=1;\\n        for(int i=1;i<price.size();i++){\\n            if(price[i]-prev>=mid){\\n                c++;\\n                prev=price[i];\\n            }     \\n        }\\n        return c>=k;\\n        \\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n       // 1 2 5 8 13  21\\n        int ans;\\n        int l=0,h=price[price.size()-1];\\n        while(h>=l){\\n            int mid=(l+h)/2;\\n            if(res(mid,price,k)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool res(int mid,vector<int>& price, int k){\\n        int prev=price[0];\\n        int c=1;\\n        for(int i=1;i<price.size();i++){\\n            if(price[i]-prev>=mid){\\n                c++;\\n                prev=price[i];\\n            }     \\n        }\\n        return c>=k;\\n        \\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n       // 1 2 5 8 13  21\\n        int ans;\\n        int l=0,h=price[price.size()-1];\\n        while(h>=l){\\n            int mid=(l+h)/2;\\n            if(res(mid,price,k)){\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436075,
                "title": "java-with-detail-explnations-binary-search",
                "content": "# Intuition\\nThe first thought to me is using brute force, find any k numbers and find min, then compare, but definitely very inefficient and will get TLE. \\nThen I realize instead of finding the solution comparing the prices, it would be much easier to validate if a given tastiness number is valid with the sorted price array. \\nTo validate: \\n1. Sort the array, \\n2. Maintain the count of differences satisfy the condition. \\n3. Using lastSmall to track the price we used, in case the consecutive price does not satisfy, and update lastSmall if the condition meets. \\n\\nThen the rest is purely binary search. \\n\\n# Point to note\\n* Can simplify the maxDiff by using (maxPrice-minPrice)/(k-1), that is the largest maxDiff possible. \\n* The count we want to retrieve is (k-1)\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price); \\n        int minDiff = 0, maxDiff = price[price.length-1] - price[0];\\n        maxDiff = maxDiff / (k - 1); // largest possible maxDiff\\n\\n        while (minDiff <= maxDiff) {\\n            int mid = (minDiff + maxDiff) / 2;\\n\\n            if (isValid(price, mid, k)) {\\n                minDiff = mid+1;\\n            } else {\\n                maxDiff = mid-1;\\n            }\\n        }\\n        return maxDiff;\\n    }\\n\\n    private boolean isValid(int[] price, int incremental, int k) {\\n        // all the lastSmall are in the target solution\\n        int count = 0, lastSmall = price[0];\\n\\n        for (int i = 1; i < price.length; i++) {\\n            if (price[i] - lastSmall >= incremental) {\\n                count++;\\n                lastSmall = price[i];\\n            }\\n            if (count >= k-1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price); \\n        int minDiff = 0, maxDiff = price[price.length-1] - price[0];\\n        maxDiff = maxDiff / (k - 1); // largest possible maxDiff\\n\\n        while (minDiff <= maxDiff) {\\n            int mid = (minDiff + maxDiff) / 2;\\n\\n            if (isValid(price, mid, k)) {\\n                minDiff = mid+1;\\n            } else {\\n                maxDiff = mid-1;\\n            }\\n        }\\n        return maxDiff;\\n    }\\n\\n    private boolean isValid(int[] price, int incremental, int k) {\\n        // all the lastSmall are in the target solution\\n        int count = 0, lastSmall = price[0];\\n\\n        for (int i = 1; i < price.length; i++) {\\n            if (price[i] - lastSmall >= incremental) {\\n                count++;\\n                lastSmall = price[i];\\n            }\\n            if (count >= k-1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395950,
                "title": "easy-java-solution-using-binary-search",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int n= price.length;\\n        int left= price[1]-price[0];\\n        int right= price[n-1]-price[0];\\n\\n        for(int i=0; i<n-1; i++){\\n            left= Math.min(price[i+1]-price[i], left);\\n        }\\n\\n        int maxTastiness= Integer.MIN_VALUE;\\n\\n        while(left <= right){\\n            int mid= (left+right)/2;\\n\\n            boolean possible= check(price, mid, k);\\n            if(possible){\\n                maxTastiness= mid;\\n                left= mid+1;\\n            }\\n            else{\\n                right= mid-1;\\n            }\\n        }\\n\\n        return maxTastiness;\\n    }\\n\\n    public boolean check(int[] price, int minDiff, int k){\\n        int n= price.length;\\n        int prevCandyPrice= Integer.MAX_VALUE;\\n\\n        for(int i=0; i<n; i++){\\n            if( Math.abs(prevCandyPrice-price[i]) >= minDiff ){\\n                prevCandyPrice= price[i];\\n                k--;\\n            }\\n\\n            if(k == 0){\\n                return true;\\n            }\\n        }\\n\\n        if(k == 0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n```\\n![please-upvote.jpg](https://assets.leetcode.com/users/images/e054ff71-8fe9-4c4f-9616-99afdc5c47fa_1681015021.4527566.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int n= price.length;\\n        int left= price[1]-price[0];\\n        int right= price[n-1]-price[0];\\n\\n        for(int i=0; i<n-1; i++){\\n            left= Math.min(price[i+1]-price[i], left);\\n        }\\n\\n        int maxTastiness= Integer.MIN_VALUE;\\n\\n        while(left <= right){\\n            int mid= (left+right)/2;\\n\\n            boolean possible= check(price, mid, k);\\n            if(possible){\\n                maxTastiness= mid;\\n                left= mid+1;\\n            }\\n            else{\\n                right= mid-1;\\n            }\\n        }\\n\\n        return maxTastiness;\\n    }\\n\\n    public boolean check(int[] price, int minDiff, int k){\\n        int n= price.length;\\n        int prevCandyPrice= Integer.MAX_VALUE;\\n\\n        for(int i=0; i<n; i++){\\n            if( Math.abs(prevCandyPrice-price[i]) >= minDiff ){\\n                prevCandyPrice= price[i];\\n                k--;\\n            }\\n\\n            if(k == 0){\\n                return true;\\n            }\\n        }\\n\\n        if(k == 0){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381287,
                "title": "maximum-tastiness-of-candy-basket-java",
                "content": "```\\nclass Solution {\\n    //TreeSet<Integer> set;\\n    int start =1, end = (int) 10e9, res =0;\\n    public int maximumTastiness(int[] nums, int k) {\\n        \\n        //set= new TreeSet<>();\\n        Arrays.sort(nums);\\n        \\n        /*for (int num: nums)\\n        {\\n            set.add(num);\\n        }*/\\n    \\n        while (start <= end)\\n        {\\n            int mid = (start) + (end - start)/2;\\n            \\n            if (isPossibleOptimised(mid, nums, k))\\n            {\\n                res = mid;\\n                start = mid+1;\\n            }else\\n            {\\n                end = mid-1;\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean isPossibleOptimised(int maxVal, int []nums, int k)\\n    {\\n        int size = 1;\\n        int prev = nums[0];\\n        Integer ceiling = null;\\n\\n        for (int i=1; i<nums.length; i++)\\n        {\\n            if ((nums[i] - prev) >= maxVal)\\n            {\\n                prev = nums[i];\\n\\n                size +=1;\\n            }\\n            \\n            if (size >= k) return true;\\n            \\n        }            \\n\\n        return false;\\n    }\\n    \\n    /*private boolean isPossibleSlow(int maxVal, int []nums, int k)\\n    {\\n        int size = 1;\\n        int curr = set.first();\\n        Integer ceiling = null;\\n\\n        while ((ceiling = (set.ceiling(curr + maxVal))) != null)\\n        {\\n            if (size >= k) return true;\\n\\n            if (ceiling == null) break;\\n\\n            curr = ceiling;\\n\\n            size +=1;\\n        }            \\n\\n        if (size >= k) return true;\\n\\n        return false;\\n    }*/\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    //TreeSet<Integer> set;\\n    int start =1, end = (int) 10e9, res =0;\\n    public int maximumTastiness(int[] nums, int k) {\\n        \\n        //set= new TreeSet<>();\\n        Arrays.sort(nums);\\n        \\n        /*for (int num: nums)\\n        {\\n            set.add(num);\\n        }*/\\n    \\n        while (start <= end)\\n        {\\n            int mid = (start) + (end - start)/2;\\n            \\n            if (isPossibleOptimised(mid, nums, k))\\n            {\\n                res = mid;\\n                start = mid+1;\\n            }else\\n            {\\n                end = mid-1;\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n    private boolean isPossibleOptimised(int maxVal, int []nums, int k)\\n    {\\n        int size = 1;\\n        int prev = nums[0];\\n        Integer ceiling = null;\\n\\n        for (int i=1; i<nums.length; i++)\\n        {\\n            if ((nums[i] - prev) >= maxVal)\\n            {\\n                prev = nums[i];\\n\\n                size +=1;\\n            }\\n            \\n            if (size >= k) return true;\\n            \\n        }            \\n\\n        return false;\\n    }\\n    \\n    /*private boolean isPossibleSlow(int maxVal, int []nums, int k)\\n    {\\n        int size = 1;\\n        int curr = set.first();\\n        Integer ceiling = null;\\n\\n        while ((ceiling = (set.ceiling(curr + maxVal))) != null)\\n        {\\n            if (size >= k) return true;\\n\\n            if (ceiling == null) break;\\n\\n            curr = ceiling;\\n\\n            size +=1;\\n        }            \\n\\n        if (size >= k) return true;\\n\\n        return false;\\n    }*/\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380034,
                "title": "java-binary-search-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int l = 0, r = (int)10e10,ans = 0;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            if(check(price, k , mid)){\\n                ans = mid;\\n                l = mid + 1;\\n            }else r = mid - 1;\\n        }\\n        return ans;\\n    }\\n\\n    public boolean check(int [] price,int k,int x){\\n        int count = 1;\\n        int curr = price[0];\\n        for(int i =1;i<price.length;i++){\\n            if(price[i] - curr>=x){\\n                count++;\\n                curr = price[i];\\n            }\\n        }\\n\\n        return count>=k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int l = 0, r = (int)10e10,ans = 0;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            if(check(price, k , mid)){\\n                ans = mid;\\n                l = mid + 1;\\n            }else r = mid - 1;\\n        }\\n        return ans;\\n    }\\n\\n    public boolean check(int [] price,int k,int x){\\n        int count = 1;\\n        int curr = price[0];\\n        for(int i =1;i<price.length;i++){\\n            if(price[i] - curr>=x){\\n                count++;\\n                curr = price[i];\\n            }\\n        }\\n\\n        return count>=k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379152,
                "title": "c-binary-search-o-nlongn",
                "content": "```\\nclass Solution {\\npublic:\\n    bool ispossible(vector<int>&prices,int num,int k){\\n        \\n        long long count=1;\\n        int prevpos=prices[0];\\n        for(int i=0;i<prices.size();i++){\\n            \\n            if(prices[i]-prevpos>=num){\\n                count++;\\n                prevpos=prices[i];\\n                if(count==k){\\n                    break;\\n                }\\n            }\\n        }\\n        if(count<k){\\n            return false;\\n        }\\n        return true;\\n    }\\n    int maximumTastiness(vector<int>& prices, int k) {\\n        \\n        sort(prices.begin(),prices.end());\\n        long long end=prices[prices.size()-1]-prices[0];\\n        int n=prices.size();\\n        long long start=1e9;\\n        for(int i=0;i<n-1;i++){\\n            \\n            int diff=prices[i+1]-prices[i];\\n            if(diff<start){\\n                start=diff;\\n            }\\n        }\\n        long long ans=-1;\\n        while(start<=end){\\n            \\n            long long mid=(start+end)/2;\\n            if(ispossible(prices,mid,k)){\\n                ans=mid;\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "Binary Search",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    bool ispossible(vector<int>&prices,int num,int k){\\n        \\n        long long count=1;\\n        int prevpos=prices[0];\\n        for(int i=0;i<prices.size();i++){\\n            \\n            if(prices[i]-prevpos>=num){\\n                count++;\\n                prevpos=prices[i];\\n                if(count==k){\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3367200,
                "title": "c-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int> &price, int mid, int k)\\n    {\\n        int basket_cnt = 1; \\n        int last = price[0];  \\n        for(int i = 1 ; i < int(price.size()); ++i){\\n            int diff = price[i] - last; \\n            if(diff >= mid){\\n                basket_cnt+=1; \\n                last = price[i]; \\n            }\\n        }\\n        if(basket_cnt >= k ) return true; \\n        return false; \\n    }\\n    \\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end()); \\n        int n = int(price.size()); \\n        int low = 0; \\n        int ans = 0; \\n        int high = price[n-1] - price[0]; \\n        while(low <= high){\\n            int mid = (low + high) / 2; \\n            bool can = check(price, mid , k); \\n            if(can){\\n                low = mid + 1 ;\\n                ans = mid;  \\n            }\\n            else{\\n                high = mid - 1; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int> &price, int mid, int k)\\n    {\\n        int basket_cnt = 1; \\n        int last = price[0];  \\n        for(int i = 1 ; i < int(price.size()); ++i){\\n            int diff = price[i] - last; \\n            if(diff >= mid){\\n                basket_cnt+=1; \\n                last = price[i]; \\n            }\\n        }\\n        if(basket_cnt >= k ) return true; \\n        return false; \\n    }\\n    \\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end()); \\n        int n = int(price.size()); \\n        int low = 0; \\n        int ans = 0; \\n        int high = price[n-1] - price[0]; \\n        while(low <= high){\\n            int mid = (low + high) / 2; \\n            bool can = check(price, mid , k); \\n            if(can){\\n                low = mid + 1 ;\\n                ans = mid;  \\n            }\\n            else{\\n                high = mid - 1; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359618,
                "title": "java-binary-search-think-like-greedy-therefore-to-pick-smallest-element-in-every-combo-and-the",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthink like Greedy ,therefore  to Pick smallest element in every combo and then choose the difference(m) using binary search , and then choose the other elements (k-1) havng difference m.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n\\n        int l=0,r=price[price.length-1];\\n         int ans=0;\\n        while(l<r){\\n          int m = l + (r-l)/2;\\n\\n          int d=1;\\n          int t= price[0];\\n           for(int i=1;i<price.length;i++){\\n                 if(price[i]-t >= m){\\n                     t=price[i];d++;\\n                 }\\n                 if(d==k)break;\\n           }\\n\\n           if(d < k){\\n               r=m;\\n           }else{\\n               l=m+1;ans=m;\\n           }\\n          \\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n\\n        int l=0,r=price[price.length-1];\\n         int ans=0;\\n        while(l<r){\\n          int m = l + (r-l)/2;\\n\\n          int d=1;\\n          int t= price[0];\\n           for(int i=1;i<price.length;i++){\\n                 if(price[i]-t >= m){\\n                     t=price[i];d++;\\n                 }\\n                 if(d==k)break;\\n           }\\n\\n           if(d < k){\\n               r=m;\\n           }else{\\n               l=m+1;ans=m;\\n           }\\n          \\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358728,
                "title": "python3-simplest-solution-beats-90-users-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        def canSellKCandies(tastiness):\\n            prevCandy,candyCount=price[0],1\\n            for i in range(1,len(price)):\\n                if price[i]-prevCandy>=tastiness:\\n                    prevCandy=price[i]\\n                    candyCount+=1\\n                if candyCount==k:\\n                    return True\\n            return False\\n        res,l,r=-1,0,price[-1]\\n        while l<=r:\\n            mid=(l+r)>>1\\n            if canSellKCandies(mid):\\n                res=mid\\n                l=mid+1\\n            else:\\n                r=mid-1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        def canSellKCandies(tastiness):\\n            prevCandy,candyCount=price[0],1\\n            for i in range(1,len(price)):\\n                if price[i]-prevCandy>=tastiness:\\n                    prevCandy=price[i]\\n                    candyCount+=1\\n                if candyCount==k:\\n                    return True\\n            return False\\n        res,l,r=-1,0,price[-1]\\n        while l<=r:\\n            mid=(l+r)>>1\\n            if canSellKCandies(mid):\\n                res=mid\\n                l=mid+1\\n            else:\\n                r=mid-1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349555,
                "title": "binary-search-o-nlog-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        return Solve(price,k);\\n    }\\n    bool check(int ans,vector<int>& price,int k) {\\n    int i = 1;\\n    int cnt = k-1,prev=price[0],cur;\\n    while (cnt&&i<price.size())\\n    {\\n        cur = price[i];\\n        if (cur - prev >= ans)cnt--, prev = cur;\\n        i++;\\n    }\\n    return cnt ? 0 : 1;\\n}\\nint Solve(vector<int>& price,int k) {\\n    int s = 0, e = 1e9, mid,ans=0;\\n    while (s <= e) {\\n        mid = (s + e) / 2;\\n        if (check(mid,price,k))ans = mid, s = mid + 1;\\n        else e = mid - 1;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        return Solve(price,k);\\n    }\\n    bool check(int ans,vector<int>& price,int k) {\\n    int i = 1;\\n    int cnt = k-1,prev=price[0],cur;\\n    while (cnt&&i<price.size())\\n    {\\n        cur = price[i];\\n        if (cur - prev >= ans)cnt--, prev = cur;\\n        i++;\\n    }\\n    return cnt ? 0 : 1;\\n}\\nint Solve(vector<int>& price,int k) {\\n    int s = 0, e = 1e9, mid,ans=0;\\n    while (s <= e) {\\n        mid = (s + e) / 2;\\n        if (check(mid,price,k))ans = mid, s = mid + 1;\\n        else e = mid - 1;\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317505,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(begin(price), end(price));\\n        int l = 0, r = price.back() - price.front();\\n        while(l - r) {\\n            int m = (l + r + 1) / 2, cnt = 1;\\n            for (int i = 1, j = 0; i < price.size(); ++i)\\n                if (price[i] - price[j] >= m) {\\n                    ++cnt;\\n                    j = i;\\n                }\\n            if (cnt >= k)\\n                l = m;\\n            else\\n                r = m - 1;\\n    }\\n    return l;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(begin(price), end(price));\\n        int l = 0, r = price.back() - price.front();\\n        while(l - r) {\\n            int m = (l + r + 1) / 2, cnt = 1;\\n            for (int i = 1, j = 0; i < price.size(); ++i)\\n                if (price[i] - price[j] >= m) {\\n                    ++cnt;\\n                    j = i;\\n                }\\n            if (cnt >= k)\\n                l = m;\\n            else\\n                r = m - 1;\\n    }\\n    return l;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312634,
                "title": "aggressive-cows-striver-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     bool ispossibletoplace (vector<int>& price , int k , int space)\\n     {\\n           int need = price[0];\\n          int count =1;\\n          for(int i=1; i < price.size();i++)\\n          {\\n              if(price[i]-need>=space)\\n              {\\n                   count++;\\n                   need=price[i];\\n                  if(count==k)\\n              {\\n                   return true;\\n              }\\n              }\\n           \\n          }\\n          return false;\\n         \\n     }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        \\n         int n = price.size();\\n         sort(price.begin(),price.end());\\n    int ans =0;\\n         int low=1;\\n         int high= price[n-1]-price[0];\\n        while(high>=low)\\n        {\\n             int mid = (high+low)/2;\\n            if(ispossibletoplace(price,k,mid))\\n            {\\n                 ans =mid;\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     bool ispossibletoplace (vector<int>& price , int k , int space)\\n     {\\n           int need = price[0];\\n          int count =1;\\n          for(int i=1; i < price.size();i++)\\n          {\\n              if(price[i]-need>=space)\\n              {\\n                   count++;\\n                   need=price[i];\\n                  if(count==k)\\n              {\\n                   return true;\\n              }\\n              }\\n           \\n          }\\n          return false;\\n         \\n     }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        \\n         int n = price.size();\\n         sort(price.begin(),price.end());\\n    int ans =0;\\n         int low=1;\\n         int high= price[n-1]-price[0];\\n        while(high>=low)\\n        {\\n             int mid = (high+low)/2;\\n            if(ispossibletoplace(price,k,mid))\\n            {\\n                 ans =mid;\\n                 low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306826,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func maximumTastiness(_ price: [Int], _ k: Int) -> Int {\\n        \\n        let prc = price.sorted()\\n\\n        func ok(_ s: Int) -> Bool {\\n\\n            var l = prc[0]\\n            var i = 1\\n            var c = 1\\n\\n            while c < k, i < price.count {\\n\\n                if prc[i] - l >= s {\\n                    c += 1\\n                    l = prc[i]\\n                }\\n\\n                i += 1\\n            }\\n\\n            return c == k\\n        }\\n\\n        var l = 0\\n        var r = prc.last! - prc.first!\\n\\n        while l < r {\\n            let m = (l + r) / 2\\n\\n            if ok(m) { l = m + 1 }\\n            else { r = m - 1 }\\n        }\\n\\n        return ok(l) ? l : (l - 1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maximumTastiness(_ price: [Int], _ k: Int) -> Int {\\n        \\n        let prc = price.sorted()\\n\\n        func ok(_ s: Int) -> Bool {\\n\\n            var l = prc[0]\\n            var i = 1\\n            var c = 1\\n\\n            while c < k, i < price.count {\\n\\n                if prc[i] - l >= s {\\n                    c += 1\\n                    l = prc[i]\\n                }\\n\\n                i += 1\\n            }\\n\\n            return c == k\\n        }\\n\\n        var l = 0\\n        var r = prc.last! - prc.first!\\n\\n        while l < r {\\n            let m = (l + r) / 2\\n\\n            if ok(m) { l = m + 1 }\\n            else { r = m - 1 }\\n        }\\n\\n        return ok(l) ? l : (l - 1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284889,
                "title": "binary-search-on-ans-cpp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool isPossible(vector<int>&price,int mid ,int k){\\n    int count =1;\\n    int curr = price[0];\\n    for(int i =1;i<price.size();i++){\\n        \\n        if(price[i] - curr >= mid){\\n            count++;\\n            curr = price[i];\\n        }\\n    }\\n    return count >= k;\\n}\\n    int maximumTastiness(vector<int>& price, int k) {\\n      \\n      int low =0;\\n      int n= price.size();\\n      sort(price.begin(),price.end());\\n      int high = price[n-1] - price[0]; \\n       \\n       int ans = -1;\\n\\n       while(low <= high ){\\n           int mid = low + (high - low)/2;\\n\\n           if(isPossible(price,mid,k)){\\n            ans = mid;\\n            low = mid +1;\\n           }\\n\\n           else{\\n               high = mid -1;\\n           }\\n       }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool isPossible(vector<int>&price,int mid ,int k){\\n    int count =1;\\n    int curr = price[0];\\n    for(int i =1;i<price.size();i++){\\n        \\n        if(price[i] - curr >= mid){\\n            count++;\\n            curr = price[i];\\n        }\\n    }\\n    return count >= k;\\n}\\n    int maximumTastiness(vector<int>& price, int k) {\\n      \\n      int low =0;\\n      int n= price.size();\\n      sort(price.begin(),price.end());\\n      int high = price[n-1] - price[0]; \\n       \\n       int ans = -1;\\n\\n       while(low <= high ){\\n           int mid = low + (high - low)/2;\\n\\n           if(isPossible(price,mid,k)){\\n            ans = mid;\\n            low = mid +1;\\n           }\\n\\n           else{\\n               high = mid -1;\\n           }\\n       }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283816,
                "title": "easy-c-solution-using-binary-saerch",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int> &nums,int mid,int k)\\n    {\\n        int cnt=1;\\n        int candy_pos=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]-candy_pos>=mid)\\n            {\\n                candy_pos=nums[i];\\n                cnt++;\\n            }\\n            if(cnt==k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int left=1;\\n        int right=INT_MAX;\\n        sort(price.begin(),price.end());\\n        int ans;\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n            if(isPossible(price,mid,k))\\n            {\\n                ans=mid;\\n                left=mid+1;\\n            }\\n            else\\n                right=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int> &nums,int mid,int k)\\n    {\\n        int cnt=1;\\n        int candy_pos=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]-candy_pos>=mid)\\n            {\\n                candy_pos=nums[i];\\n                cnt++;\\n            }\\n            if(cnt==k)\\n                return true;\\n        }\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int left=1;\\n        int right=INT_MAX;\\n        sort(price.begin(),price.end());\\n        int ans;\\n        while(left<=right)\\n        {\\n            int mid=left+(right-left)/2;\\n            if(isPossible(price,mid,k))\\n            {\\n                ans=mid;\\n                left=mid+1;\\n            }\\n            else\\n                right=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278111,
                "title": "c-binary-search-beat-99-3",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int l = 0, r = 1+price.back() - price.front();\\n        while(l+1<r){\\n            auto mid = (l+r)/2;\\n            able(price, k, mid) ? l = mid : r = mid;\\n        }\\n        return l;\\n    }\\n\\n    bool able(vector<int>& v, int k, int dis){\\n        int count = 1, cur = v[0];\\n        for(auto x:v){\\n            if(x-cur>=dis){\\n                count++;\\n                cur = x;\\n            }\\n            if(count>=k) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int l = 0, r = 1+price.back() - price.front();\\n        while(l+1<r){\\n            auto mid = (l+r)/2;\\n            able(price, k, mid) ? l = mid : r = mid;\\n        }\\n        return l;\\n    }\\n\\n    bool able(vector<int>& v, int k, int dis){\\n        int count = 1, cur = v[0];\\n        for(auto x:v){\\n            if(x-cur>=dis){\\n                count++;\\n                cur = x;\\n            }\\n            if(count>=k) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277973,
                "title": "right-binary-search",
                "content": "\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n```\\nclass Solution {\\n    func maximumTastiness(_ price: [Int], _ k: Int) -> Int {\\n        return rightBS(price.sorted(), k)\\n    }\\n\\n    func rightBS(_ price: [Int], _ k: Int) -> Int {\\n        var (l, r) = (0, price.last! - price[0])\\n        while l < r {\\n            let mid = (l+r+1)/2\\n            check(mid, price, k) ? (l = mid) : (r = mid - 1)\\n        }\\n        return l\\n    }\\n\\n    func check(_ tastiness: Int, _ price: [Int], _ k: Int) -> Bool {\\n        var count = 0\\n        var prev = price[0]\\n        for i in 1..<price.count {\\n            if price[i] - prev >= tastiness {\\n                count += (count != 0) ? 1 : 2\\n                prev = price[i]\\n            } \\n        }\\n        return count >= k\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    func maximumTastiness(_ price: [Int], _ k: Int) -> Int {\\n        return rightBS(price.sorted(), k)\\n    }\\n\\n    func rightBS(_ price: [Int], _ k: Int) -> Int {\\n        var (l, r) = (0, price.last! - price[0])\\n        while l < r {\\n            let mid = (l+r+1)/2\\n            check(mid, price, k) ? (l = mid) : (r = mid - 1)\\n        }\\n        return l\\n    }\\n\\n    func check(_ tastiness: Int, _ price: [Int], _ k: Int) -> Bool {\\n        var count = 0\\n        var prev = price[0]\\n        for i in 1..<price.count {\\n            if price[i] - prev >= tastiness {\\n                count += (count != 0) ? 1 : 2\\n                prev = price[i]\\n            } \\n        }\\n        return count >= k\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277195,
                "title": "c-simple-solution-using-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int n=price.size();\\n        sort(price.begin(),price.end());\\n        int l=0,u=price[n-1]-price[0];\\n        int res;\\n        while(l<=u)\\n        {\\n            int mid=(l+u)/2;\\n            int count=1;\\n            int j=0;\\n            for(int i=1;i<n;i++)\\n            {\\n                if(price[i]-price[j]>=mid)\\n                {\\n                    count++;\\n                    j=i;\\n                }\\n            }\\n            if(count>=k)\\n            {\\n                res=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                u=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int n=price.size();\\n        sort(price.begin(),price.end());\\n        int l=0,u=price[n-1]-price[0];\\n        int res;\\n        while(l<=u)\\n        {\\n            int mid=(l+u)/2;\\n            int count=1;\\n            int j=0;\\n            for(int i=1;i<n;i++)\\n            {\\n                if(price[i]-price[j]>=mid)\\n                {\\n                    count++;\\n                    j=i;\\n                }\\n            }\\n            if(count>=k)\\n            {\\n                res=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                u=mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274380,
                "title": "high-low-game",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* To find out whether tastiness n is OK, we start from the min price, find the first price with taste previousPrice + n, and iterate k - 1 times.\\n* Then we play high-low game trying to find max possible tastiness using binary search\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Sort prices, so we can find the first value with cost previousPrice + tastiness\\n* then play high-low game\\n* min is always 1\\n* and max is the diff between the highest and lowest item in an array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(p) * k), where p is the length of the price array, and k is the input arg\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int low = 1;\\n        int high = price[price.length - 1] - price[0];\\n        while (low <= high) {\\n            int middle = low + (high -low) / 2;\\n            if (canTaste(price, k, middle)) {\\n                low = middle + 1;\\n            } else {\\n                high = middle - 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    private boolean canTaste(int[] price, int k, int minDistance) {\\n        int num = price[0];\\n        k--;\\n        int priceIndex = 1;\\n        while (k > 0) {\\n            if (priceIndex >= price.length) {\\n                return false;\\n            }\\n            if (price[priceIndex] >= num + minDistance) {\\n                k--;\\n                num = price[priceIndex];\\n            }\\n            priceIndex++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int low = 1;\\n        int high = price[price.length - 1] - price[0];\\n        while (low <= high) {\\n            int middle = low + (high -low) / 2;\\n            if (canTaste(price, k, middle)) {\\n                low = middle + 1;\\n            } else {\\n                high = middle - 1;\\n            }\\n        }\\n        return high;\\n    }\\n\\n    private boolean canTaste(int[] price, int k, int minDistance) {\\n        int num = price[0];\\n        k--;\\n        int priceIndex = 1;\\n        while (k > 0) {\\n            if (priceIndex >= price.length) {\\n                return false;\\n            }\\n            if (price[priceIndex] >= num + minDistance) {\\n                k--;\\n                num = price[priceIndex];\\n            }\\n            priceIndex++;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267945,
                "title": "same-as-aggressive-cows",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool possible(int mid,vector<int>&price,int k){\\n    int cnt=1;\\n    int last=price[0];\\n    for(int i=1;i<price.size();i++){\\n        if(price[i]-last>=mid){\\n            cnt++;\\n            last=price[i];\\n\\n        }\\n    }\\n    if(cnt>=k)return true;\\n    return false;\\n}\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        int low=1;\\n        int high=price[price.size()-1]-price[0];\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(possible(mid,price,k)){\\n                \\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }return high;\\n    }\\n};\\n```\\n**Please, UPVOTE**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool possible(int mid,vector<int>&price,int k){\\n    int cnt=1;\\n    int last=price[0];\\n    for(int i=1;i<price.size();i++){\\n        if(price[i]-last>=mid){\\n            cnt++;\\n            last=price[i];\\n\\n        }\\n    }\\n    if(cnt>=k)return true;\\n    return false;\\n}\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        int low=1;\\n        int high=price[price.size()-1]-price[0];\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(possible(mid,price,k)){\\n                \\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251393,
                "title": "bs",
                "content": "**Linearithmic time / Sorting + range binary search**\\n**time: `O(N log N)` + `O(N log R)`; space: `O(1)`**\\n\\n![image](https://assets.leetcode.com/users/images/9758b227-dcac-4191-a1f8-1a933fce561b_1677850096.8756588.png)\\n\\nCalculating `n(x)` uses greedy strategy:\\n\\n![image](https://assets.leetcode.com/users/images/37e5710f-105a-478b-95dd-bdbb8bd8aefe_1677852998.7529147.png)\\n\\n```\\nint maximumTastiness(vector<int>& p, int K)\\n{\\n\\tp.push_back(-1000000000);\\n\\tsort(begin(p), end(p));\\n\\tint l{};\\n\\tfor(int h{p.back()+1}; l+1<h; )\\n\\t{\\n\\t\\tint n{}, m{(l+h)/2};\\n\\t\\tfor(int i{1}, x{}; i<size(p); ++i)\\n\\t\\t\\tif((x+=p[i]-p[i-1])>=m) ++n, x=0;\\n\\t\\t(n<K ? h : l) = m;\\n\\t}\\n\\treturn l;\\n}\\n```\\n\\nThis problem is literally the same as [1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/3251398/ok).\\n\\n**Similar problems:** \\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/discuss/2053517/bs?currentPage=1&orderBy=most_relevant&query=android)\\n[1891. Cutting Ribbons](https://leetcode.com/problems/cutting-ribbons/discuss/2963593/bs)\\n[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/discuss/2127417/binary-search)\\n[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/discuss/1676227/binary-search)\\n[1300. Sum of Mutated Array Closest to Target](https://leetcode.com/problems/sum-of-mutated-array-closest-to-target/discuss/2969866/bs)\\n[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/discuss/3251398/ok)\\n[2517. Maximum Tastiness of Candy Basket](https://leetcode.com/problems/maximum-tastiness-of-candy-basket/discuss/3251393/ok)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/discuss/3253585/bs)\\n[1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/discuss/3254564/bs)\\n[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/discuss/3807049/bs)\\n[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/discuss/3808940/bs)\\n[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/discuss/3945204/range-bs)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximumTastiness(vector<int>& p, int K)\\n{\\n\\tp.push_back(-1000000000);\\n\\tsort(begin(p), end(p));\\n\\tint l{};\\n\\tfor(int h{p.back()+1}; l+1<h; )\\n\\t{\\n\\t\\tint n{}, m{(l+h)/2};\\n\\t\\tfor(int i{1}, x{}; i<size(p); ++i)\\n\\t\\t\\tif((x+=p[i]-p[i-1])>=m) ++n, x=0;\\n\\t\\t(n<K ? h : l) = m;\\n\\t}\\n\\treturn l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3250748,
                "title": "sorting-and-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int low = 1;\\n        int high = price[price.length-1]-price[0];\\n        int ans = 0;\\n        while(low<=high) {\\n            int mid = low + (high-low)/2;\\n            int mark = price[0]; \\n            int count = 1;\\n            for(int i=1;i<price.length;i++) {\\n                if(price[i]>=mark+mid) {\\n                    mark = price[i];\\n                    count++;\\n                }\\n            }\\n            if(count>=k) {\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else {\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n        int low = 1;\\n        int high = price[price.length-1]-price[0];\\n        int ans = 0;\\n        while(low<=high) {\\n            int mid = low + (high-low)/2;\\n            int mark = price[0]; \\n            int count = 1;\\n            for(int i=1;i<price.length;i++) {\\n                if(price[i]>=mark+mid) {\\n                    mark = price[i];\\n                    count++;\\n                }\\n            }\\n            if(count>=k) {\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else {\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238786,
                "title": "binary-search-easy-python-solution-beginner-friendly",
                "content": "### do a binary search to check the maximum absolute difference\\n### be confident ,i am a  beginner ,if i can do it you can easily do it, HAPPY CODING\\n### min difference can be 0\\n### max difference can be highest element -lowest element in the array\\n#### for every mid check if it can be possible to find a candy set with mid absolute difference\\n```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        l,r=0,price[-1]-price[0]\\n        ans=-math.inf\\n        \\n        def valid(val):\\n            candy_count=1\\n            prev=price[0]\\n            \\n            for i in range(1,len(price)):\\n                if price[i]-prev>=val:\\n                    candy_count+=1\\n                    prev=price[i]\\n            return candy_count>=k\\n        \\n        while l<=r:\\n            mid=l+(r-l)//2\\n            \\n            if valid(mid):\\n                ans=max(mid,ans)\\n                l=mid+1\\n            else:\\n                r=mid-1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        l,r=0,price[-1]-price[0]\\n        ans=-math.inf\\n        \\n        def valid(val):\\n            candy_count=1\\n            prev=price[0]\\n            \\n            for i in range(1,len(price)):\\n                if price[i]-prev>=val:\\n                    candy_count+=1\\n                    prev=price[i]\\n            return candy_count>=k\\n        \\n        while l<=r:\\n            mid=l+(r-l)//2\\n            \\n            if valid(mid):\\n                ans=max(mid,ans)\\n                l=mid+1\\n            else:\\n                r=mid-1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203557,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumTastiness(int[] price, int k) {\\n        Array.Sort(price);\\n        int ans = 0, low = 0, high = int.MaxValue;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(IsPossible(price, k, mid)) {\\n                ans = Math.Max(ans, mid);\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private bool IsPossible(int[] price, int k, int diff) {\\n        var num = price[price.Length - 1] - diff;\\n        for(int i = price.Length - 2; i >= 0; i--) {\\n            if(price[i] <= num) {\\n                k--;\\n                num = price[i] - diff;\\n            }\\n            if(k == 1)\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumTastiness(int[] price, int k) {\\n        Array.Sort(price);\\n        int ans = 0, low = 0, high = int.MaxValue;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(IsPossible(price, k, mid)) {\\n                ans = Math.Max(ans, mid);\\n                low = mid + 1;\\n            }\\n            else\\n                high = mid - 1;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private bool IsPossible(int[] price, int k, int diff) {\\n        var num = price[price.Length - 1] - diff;\\n        for(int i = price.Length - 2; i >= 0; i--) {\\n            if(price[i] <= num) {\\n                k--;\\n                num = price[i] - diff;\\n            }\\n            if(k == 1)\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180538,
                "title": "c-short-and-concise-solution-o-nlogn-time-complexity",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>&vec,long long mid,long long k)\\n    {\\n        long long a=0,b=1,prev=vec[0];\\n        for(int i=0;i<vec.size();i++){\\n            if(vec[i]-prev>=mid){\\n                b++;\\n                prev=vec[i];\\n            }\\n        }\\n        if(b>=k) return true;\\n        else return false;\\n    }\\n    int maximumTastiness(vector<int>& vec, int k) {\\n        sort(vec.begin(),vec.end());\\n        long long l=0,r=1e9,res=0;\\n        while(l<=r){\\n            long long mid=(l+r)/2;\\n            if(helper(vec,mid,k)){\\n                res=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return res;\\n    }\\n};\\n//      UPVOTE IF IT HELPS\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(vector<int>&vec,long long mid,long long k)\\n    {\\n        long long a=0,b=1,prev=vec[0];\\n        for(int i=0;i<vec.size();i++){\\n            if(vec[i]-prev>=mid){\\n                b++;\\n                prev=vec[i];\\n            }\\n        }\\n        if(b>=k) return true;\\n        else return false;\\n    }\\n    int maximumTastiness(vector<int>& vec, int k) {\\n        sort(vec.begin(),vec.end());\\n        long long l=0,r=1e9,res=0;\\n        while(l<=r){\\n            long long mid=(l+r)/2;\\n            if(helper(vec,mid,k)){\\n                res=mid;\\n                l=mid+1;\\n            }\\n            else r=mid-1;\\n        }\\n        return res;\\n    }\\n};\\n//      UPVOTE IF IT HELPS\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161902,
                "title": "c-binary-search-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) \\n    {\\n        sort(price.begin(),price.end());\\n        int left=0,right=price.back()-price.front(),mid;\\n        while(left<right)\\n        {\\n            mid=(left+right+1)/2;\\n            int take=1,j=0;\\n            for(int i=1;i<price.size();i++)\\n            {\\n                if(price[i]-price[j]>=mid)\\n                {\\n                    take++;\\n                    j=i;\\n                }\\n            }\\n            if(take<k)\\n            {\\n                right=mid-1;\\n            }\\n            else\\n            {\\n                left=mid;\\n            }\\n        }\\n        return left;\\n        \\n    }\\n};\\n```\\nIf you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) \\n    {\\n        sort(price.begin(),price.end());\\n        int left=0,right=price.back()-price.front(),mid;\\n        while(left<right)\\n        {\\n            mid=(left+right+1)/2;\\n            int take=1,j=0;\\n            for(int i=1;i<price.size();i++)\\n            {\\n                if(price[i]-price[j]>=mid)\\n                {\\n                    take++;\\n                    j=i;\\n                }\\n            }\\n            if(take<k)\\n            {\\n                right=mid-1;\\n            }\\n            else\\n            {\\n                left=mid;\\n            }\\n        }\\n        return left;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147252,
                "title": "c-golang-sorting-binary-search",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\n    bool check(vector<int> &price, int mid, int k) {\\n        int prev = price[0];\\n        for(int i = 1; i < price.size(); i++) {\\n            if(price[i] - prev >= mid) {\\n                k--;\\n                prev = price[i];\\n            }\\n        } \\n        return k <= 1;\\n    }\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int low = 0;\\n        int high = 1e9;\\n        int ans = 0;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(check(price, mid, k)) {\\n                ans = max(ans, mid);\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc check(price []int, mid, k int) bool {\\n    var prev int = price[0]\\n    for i := 1; i < len(price); i++ {\\n        if price[i] - prev >= mid {\\n            k--\\n            prev = price[i]\\n        }\\n    } \\n    return k <= 1\\n}\\nfunc maximumTastiness(price []int, k int) int {\\n    sort.Ints(price)\\n    var low, high int = 0, 1e9\\n    var ans int = 0\\n    for low <= high {\\n        var mid int = low + (high - low) / 2\\n        if check(price, mid, k) {\\n            if mid > ans {ans = mid}\\n            low = mid + 1\\n        } else {\\n            high = mid - 1\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n// C++\\nclass Solution {\\n    bool check(vector<int> &price, int mid, int k) {\\n        int prev = price[0];\\n        for(int i = 1; i < price.size(); i++) {\\n            if(price[i] - prev >= mid) {\\n                k--;\\n                prev = price[i];\\n            }\\n        } \\n        return k <= 1;\\n    }\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int low = 0;\\n        int high = 1e9;\\n        int ans = 0;\\n        while(low <= high) {\\n            int mid = low + (high - low) / 2;\\n            if(check(price, mid, k)) {\\n                ans = max(ans, mid);\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc check(price []int, mid, k int) bool {\\n    var prev int = price[0]\\n    for i := 1; i < len(price); i++ {\\n        if price[i] - prev >= mid {\\n            k--\\n            prev = price[i]\\n        }\\n    } \\n    return k <= 1\\n}\\nfunc maximumTastiness(price []int, k int) int {\\n    sort.Ints(price)\\n    var low, high int = 0, 1e9\\n    var ans int = 0\\n    for low <= high {\\n        var mid int = low + (high - low) / 2\\n        if check(price, mid, k) {\\n            if mid > ans {ans = mid}\\n            low = mid + 1\\n        } else {\\n            high = mid - 1\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125262,
                "title": "c-easy-approch-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst you have to sort the array and then apply binary search and find mid so now we ahve to make a one more function which is bool type and here we find the element which we select for finding the minimum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        bool check(int x,vector<int>price,int k){\\n            int len=1;\\n            int j=0;\\n            for(int i=1;i<price.size();i++){\\n                if(price[i]-price[j]>=x){\\n                len++;\\n                j=i;\\n                }\\n                if(len>=k){\\n                    return 1;\\n                }\\n            }return 0;\\n        }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        int n=price.size();\\n        int s=0;\\n        int ans=0;\\n        int e=price[n-1]-price[0];\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            bool res=check(mid,price,k);\\n            if(res){\\n                ans=mid;\\n                s=mid+1;\\n            }else{\\n                e=mid-1;\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        bool check(int x,vector<int>price,int k){\\n            int len=1;\\n            int j=0;\\n            for(int i=1;i<price.size();i++){\\n                if(price[i]-price[j]>=x){\\n                len++;\\n                j=i;\\n                }\\n                if(len>=k){\\n                    return 1;\\n                }\\n            }return 0;\\n        }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        int n=price.size();\\n        int s=0;\\n        int ans=0;\\n        int e=price[n-1]-price[0];\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n            bool res=check(mid,price,k);\\n            if(res){\\n                ans=mid;\\n                s=mid+1;\\n            }else{\\n                e=mid-1;\\n            }\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125220,
                "title": "clean-and-concise-solution-with-binary-search-correct-time-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search on answer and check for the maximum possible answer which satisfies the condition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*log(maxNum-minNum) + N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(log(maxNum-minNum))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n       \\n        int l = 0;\\n        int r = price[price.length - 1] - price[0];\\n        while (l < r ) {\\n            int mid = r - (r - l) / 2;\\n            if (check(price, k, mid)) {\\n                l = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return r;\\n    }\\n    \\n\\n    boolean check(int[] a, int k, int minDist) {\\n        int i = 0;\\n        k--;\\n        while (i < a.length) {\\n            int next = -1;\\n            for (int j = i + 1; j < a.length; j++) {\\n                if (a[i] + minDist <= a[j]) {\\n                    next = j;\\n                    k--;\\n                    break;\\n                }\\n            }\\n            if (k == 0) return true;\\n            if (next == -1) return false;\\n            i = next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        Arrays.sort(price);\\n       \\n        int l = 0;\\n        int r = price[price.length - 1] - price[0];\\n        while (l < r ) {\\n            int mid = r - (r - l) / 2;\\n            if (check(price, k, mid)) {\\n                l = mid;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        return r;\\n    }\\n    \\n\\n    boolean check(int[] a, int k, int minDist) {\\n        int i = 0;\\n        k--;\\n        while (i < a.length) {\\n            int next = -1;\\n            for (int j = i + 1; j < a.length; j++) {\\n                if (a[i] + minDist <= a[j]) {\\n                    next = j;\\n                    k--;\\n                    break;\\n                }\\n            }\\n            if (k == 0) return true;\\n            if (next == -1) return false;\\n            i = next;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116997,
                "title": "c-clean-code-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& p, int k) {\\n        sort(p.begin(),p.end());\\n        int s=0;\\n        int e=abs(p[0]-p[p.size()-1]);\\n        int ans=0;\\n        while(s<=e)\\n        {\\n            int m=(s+e)/2;\\n            vector<int> a={p[0]};\\n            for(int i=1;i<p.size();i++)\\n            {\\n                if(p[i]-a.back()>=m)\\n                    a.push_back(p[i]);\\n            }\\n            if(a.size()>=k)\\n            {\\n                s=m+1;\\n                ans=max(ans,m);\\n            }\\n            else\\n            e=m-1;\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& p, int k) {\\n        sort(p.begin(),p.end());\\n        int s=0;\\n        int e=abs(p[0]-p[p.size()-1]);\\n        int ans=0;\\n        while(s<=e)\\n        {\\n            int m=(s+e)/2;\\n            vector<int> a={p[0]};\\n            for(int i=1;i<p.size();i++)\\n            {\\n                if(p[i]-a.back()>=m)\\n                    a.push_back(p[i]);\\n            }\\n            if(a.size()>=k)\\n            {\\n                s=m+1;\\n                ans=max(ans,m);\\n            }\\n            else\\n            e=m-1;\\n        };\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108154,
                "title": "c-binary-search-be-greedy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        \\n        sort(price.begin(), price.end());\\n        \\n        int n = price.size();\\n        int low = 0;\\n        int high = price[n - 1] - price[0];\\n        int ans = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if (isValid(price, k - 1, mid)) {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            \\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    bool isValid (vector<int>&price, int k, int mid) {\\n        int prev = price[0];\\n        \\n        for (int i = 1; i < price.size(); i++) {\\n            if (price[i] - prev >= mid) {\\n                prev = price[i];\\n                k--;\\n            }\\n        }\\n        \\n        if (k <= 0) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        \\n        sort(price.begin(), price.end());\\n        \\n        int n = price.size();\\n        int low = 0;\\n        int high = price[n - 1] - price[0];\\n        int ans = 0;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            \\n            if (isValid(price, k - 1, mid)) {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            \\n            else {\\n                high = mid - 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    bool isValid (vector<int>&price, int k, int mid) {\\n        int prev = price[0];\\n        \\n        for (int i = 1; i < price.size(); i++) {\\n            if (price[i] - prev >= mid) {\\n                prev = price[i];\\n                k--;\\n            }\\n        }\\n        \\n        if (k <= 0) return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107442,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def maximumTastiness(price: Array[Int], k: Int): Int = {\\n    val list = price.sorted.toList\\n\\n    def chk(n: Int): Boolean = {\\n      def recurse(ls: List[Int], curr: Int): Boolean = {\\n        if (curr == 0) true\\n        else {\\n          ls match {\\n            case Nil     => false\\n            case x :: xs => recurse(ls.dropWhile(_ - x < n), curr - 1)\\n          }\\n        }\\n      }\\n      recurse(list, k)\\n    }\\n\\n    def solve(l: Int, h: Int): Int = {\\n      if (l == h) l\\n      else {\\n        val m = (l + h + 1) / 2\\n        if (chk(m)) solve(m, h)\\n        else solve(l, m - 1)\\n      }\\n    }\\n\\n    solve(0, list.last - list.head)\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def maximumTastiness(price: Array[Int], k: Int): Int = {\\n    val list = price.sorted.toList\\n\\n    def chk(n: Int): Boolean = {\\n      def recurse(ls: List[Int], curr: Int): Boolean = {\\n        if (curr == 0) true\\n        else {\\n          ls match {\\n            case Nil     => false\\n            case x :: xs => recurse(ls.dropWhile(_ - x < n), curr - 1)\\n          }\\n        }\\n      }\\n      recurse(list, k)\\n    }\\n\\n    def solve(l: Int, h: Int): Int = {\\n      if (l == h) l\\n      else {\\n        val m = (l + h + 1) / 2\\n        if (chk(m)) solve(m, h)\\n        else solve(l, m - 1)\\n      }\\n    }\\n\\n    solve(0, list.last - list.head)\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3092290,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int maximumTastiness(vector<int>& price, int k) {\\n    sort(price.begin(), price.end());\\n    int lo = 0, hi = 1e9;\\n    while (lo < hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if (check(mid, price, k)) lo = mid + 1;\\n        else hi = mid;\\n    }\\n    return lo - 1;\\n}\\nbool check(int x, vector<int>& price, int k) {\\n    int last = price[0], count = 1, i = 1;\\n    while (count < k && i < price.size()) {\\n        if (price[i] - last >= x)\\n            last = price[i], count++;\\n        i++;\\n    }\\n    return count == k;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int maximumTastiness(vector<int>& price, int k) {\\n    sort(price.begin(), price.end());\\n    int lo = 0, hi = 1e9;\\n    while (lo < hi) {\\n        int mid = lo + (hi - lo) / 2;\\n        if (check(mid, price, k)) lo = mid + 1;\\n        else hi = mid;\\n    }\\n    return lo - 1;\\n}\\nbool check(int x, vector<int>& price, int k) {\\n    int last = price[0], count = 1, i = 1;\\n    while (count < k && i < price.size()) {\\n        if (price[i] - last >= x)\\n            last = price[i], count++;\\n        i++;\\n    }\\n    return count == k;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033383,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaximumTastiness(int[] price, int k) {\\n        Array.Sort(price);\\n        int head = 0;\\n        int tail = 1000_000_000;\\n        while (head < tail) {\\n            int mid = head + (tail - head) / 2;\\n            if (check(mid, price, k)){\\n                head = mid + 1;\\n            }else{\\n                tail = mid;\\n            }\\n        }\\n        return head - 1;\\n    }\\n\\n    private bool check(int mid, int[] price, int k) {\\n        int last = price[0];\\n        int count = 1;\\n        int i = 1;\\n        while (count < k && i < price.Length) {\\n            if (price[i] - last >= mid) {\\n                last = price[i]; \\n                count++;\\n            }\\n            i++;\\n        }\\n        return count == k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumTastiness(int[] price, int k) {\\n        Array.Sort(price);\\n        int head = 0;\\n        int tail = 1000_000_000;\\n        while (head < tail) {\\n            int mid = head + (tail - head) / 2;\\n            if (check(mid, price, k)){\\n                head = mid + 1;\\n            }else{\\n                tail = mid;\\n            }\\n        }\\n        return head - 1;\\n    }\\n\\n    private bool check(int mid, int[] price, int k) {\\n        int last = price[0];\\n        int count = 1;\\n        int i = 1;\\n        while (count < k && i < price.Length) {\\n            if (price[i] - last >= mid) {\\n                last = price[i]; \\n                count++;\\n            }\\n            i++;\\n        }\\n        return count == k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024541,
                "title": "c",
                "content": "```\\nint cmp(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\nbool check(int* arr, int n, int d, int k){\\n    int cn = 1;\\n    int next = arr[0] + d;\\n    for(int i = 1; i < n; i++){\\n        if(arr[i] >= next){\\n            cn++;\\n            next = arr[i] + d;\\n            if(cn == k)\\n                return true;\\n        }\\n    }\\n    return false;\\n}\\nint maximumTastiness(int* price, int priceSize, int k){\\n    int n = priceSize;\\n    qsort(price, n, sizeof(int), cmp);\\n    int left = 0, right = price[n-1];\\n    int mid;\\n    while(left < right){\\n        mid = right - (right - left)/2;\\n        if( check(price, n, mid, k) )\\n            left = mid;\\n        else\\n            right = mid - 1;\\n    }\\n    return left;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmp(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\nbool check(int* arr, int n, int d, int k){\\n    int cn = 1;\\n    int next = arr[0] + d;\\n    for(int i = 1; i < n; i++){\\n        if(arr[i] >= next){\\n            cn++;\\n            next = arr[i] + d;\\n            if(cn == k)\\n                return true;\\n        }\\n    }\\n    return false;\\n}\\nint maximumTastiness(int* price, int priceSize, int k){\\n    int n = priceSize;\\n    qsort(price, n, sizeof(int), cmp);\\n    int left = 0, right = price[n-1];\\n    int mid;\\n    while(left < right){\\n        mid = right - (right - left)/2;\\n        if( check(price, n, mid, k) )\\n            left = mid;\\n        else\\n            right = mid - 1;\\n    }\\n    return left;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3024193,
                "title": "simple-soln-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} price\\n * @param {number} k\\n * @return {number}\\n */\\n//     function possible(diff,price,k){\\n//         let count = 1;\\n//         let last  = price[0];\\n\\n//         for(let i=1; i<price.length; i++){\\n//             if(price[i] - last >= diff){\\n                \\n//                 count++;\\n//                 last = price[i]            \\n//             }\\n//         }\\n//         if(count >= k) return true;\\n//         return false;\\n//     }\\n// var maximumTastiness = function(price, k) {\\n//     let n = price.length;\\n//     price.sort((a,b)=> a-b);\\n    \\n//     let l = 0, r = price[n-1]-price[0]\\n//     while(l<=r){\\n//         let mid = l + Math.floor((r-l)/2);\\n//         if(possible(mid,price,k)){\\n//             l = mid+1;\\n//         }else{\\n//             r = mid-1;\\n//         }\\n       \\n//     }\\n//     return r;\\n    \\n// };\\n\\nvar maximumTastiness = function(price, k) {\\n    let n = price.length;\\n    price = price.sort((a,b)=> a-b);\\n    let left = 0, right = price[n-1] - price[0] , ans = 0;\\n\\n    while(left <= right){\\n        let mid = Math.floor(left+(right-left)/2);\\n        if(possible(mid)){\\n            ans = mid;\\n            left = mid+1;\\n        }else{\\n            right = mid-1;\\n        }\\n    }\\n\\n    function possible(diff){\\n        let count = 1;\\n        let curr = 0;\\n\\n        for(let i=1; i<n; i++){\\n            if(price[i] - price[curr] >= diff){\\n                curr = i;\\n                count++;\\n            }\\n        }\\n\\n        if(count >= k) return true\\n        else return false;\\n\\n    }\\n\\n    return ans;\\n\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} price\\n * @param {number} k\\n * @return {number}\\n */\\n//     function possible(diff,price,k){\\n//         let count = 1;\\n//         let last  = price[0];\\n\\n//         for(let i=1; i<price.length; i++){\\n//             if(price[i] - last >= diff){\\n                \\n//                 count++;\\n//                 last = price[i]            \\n//             }\\n//         }\\n//         if(count >= k) return true;\\n//         return false;\\n//     }\\n// var maximumTastiness = function(price, k) {\\n//     let n = price.length;\\n//     price.sort((a,b)=> a-b);\\n    \\n//     let l = 0, r = price[n-1]-price[0]\\n//     while(l<=r){\\n//         let mid = l + Math.floor((r-l)/2);\\n//         if(possible(mid,price,k)){\\n//             l = mid+1;\\n//         }else{\\n//             r = mid-1;\\n//         }\\n       \\n//     }\\n//     return r;\\n    \\n// };\\n\\nvar maximumTastiness = function(price, k) {\\n    let n = price.length;\\n    price = price.sort((a,b)=> a-b);\\n    let left = 0, right = price[n-1] - price[0] , ans = 0;\\n\\n    while(left <= right){\\n        let mid = Math.floor(left+(right-left)/2);\\n        if(possible(mid)){\\n            ans = mid;\\n            left = mid+1;\\n        }else{\\n            right = mid-1;\\n        }\\n    }\\n\\n    function possible(diff){\\n        let count = 1;\\n        let curr = 0;\\n\\n        for(let i=1; i<n; i++){\\n            if(price[i] - price[curr] >= diff){\\n                curr = i;\\n                count++;\\n            }\\n        }\\n\\n        if(count >= k) return true\\n        else return false;\\n\\n    }\\n\\n    return ans;\\n\\n}\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3024054,
                "title": "c-solution-descrived",
                "content": "# Intuition\\nBasically we need to find k elements from the given array so that minimum absolute diffrence between any two items among picked items is maximum.\\n\\n# Approach\\nOvserving the problem we can see that we know what is the minimum and maximum result can be[minimum can be 0 and maximum can be the absolute difference between maximum and minimum prices in the given list]. So we have found a range to search (Of course binary search).\\nNow we can easily find if we can pick k elements from the the given array by fullfilling the condition for any particular result.\\n\\n# Complexity\\n- Time complexity:\\nO(N*log(N))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool possible(vector<int>& prices, int n, int diff, int k) {\\n        int lastPicked = prices[0];\\n        int picked = 1;\\n        for (int i=1; i<n; i++) {\\n            if (prices[i]-lastPicked >= diff) {\\n                lastPicked = prices[i];\\n                picked++;\\n            }\\n        }\\n\\n        return picked >= k;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int n = price.size();\\n        int left = 0, right = price[n-1] - price[0];\\n\\n        while (left <= right) {\\n            int mid = (left+right) / 2;\\n            if (possible(price, n, mid, k)) {\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n\\n        return right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool possible(vector<int>& prices, int n, int diff, int k) {\\n        int lastPicked = prices[0];\\n        int picked = 1;\\n        for (int i=1; i<n; i++) {\\n            if (prices[i]-lastPicked >= diff) {\\n                lastPicked = prices[i];\\n                picked++;\\n            }\\n        }\\n\\n        return picked >= k;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int n = price.size();\\n        int left = 0, right = price[n-1] - price[0];\\n\\n        while (left <= right) {\\n            int mid = (left+right) / 2;\\n            if (possible(price, n, mid, k)) {\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n\\n        return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3023509,
                "title": "c-with-explanation-binary-search-on-answer-set",
                "content": "# Intuition\\nCommonly, there are two use case on binary search: (1) on answer set, (2) on input set. \\n\\n### First: analysis the questions into math equation\\nIn this question, we are going to find a set of a[i] and return max(min(abs(a[i] - a[j] for all pair[a[i], a[j]]))). Notice that if we sorted the array, a[i] > a[i - 1] and we do not need to consider a[i + 1] and a[i - 1] cases as it will not be the minimum. Therefore, the return could be simiplify to max(min(a[i] - a[i - 1] for all i)).\\n\\n### Second: solve the math equation using algortihm\\nThen, how do we solve max(min(a[i] - a[i - 1] for all i)). Here we choose the method to search on binary set such that the search result >= a[i] - a[i - 1] for all i. Since if the answer failed for x, then x + 1, x + 2, x + n would not be the answer due to the minimum constraint. As a result, the answer must be monotonic and could use binary search.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int low(0), high(*price.rbegin() - *price.begin()), ans(0);\\n        while (low <= high){\\n            int mid((low + high) / 2);\\n            if (searchAns(price, k, mid)) {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else high = mid - 1;\\n        }\\n        return ans;\\n    }\\n\\n    bool searchAns(vector<int> &price, int k, int answer){\\n        auto ptr(price.begin());\\n        while (k > 1){\\n            ptr = lower_bound(ptr, price.end(), *ptr + answer);\\n            if (ptr == price.end()) return false;\\n            k--;\\n        }\\n        if (ptr != price.end()) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int low(0), high(*price.rbegin() - *price.begin()), ans(0);\\n        while (low <= high){\\n            int mid((low + high) / 2);\\n            if (searchAns(price, k, mid)) {\\n                ans = mid;\\n                low = mid + 1;\\n            }\\n            else high = mid - 1;\\n        }\\n        return ans;\\n    }\\n\\n    bool searchAns(vector<int> &price, int k, int answer){\\n        auto ptr(price.begin());\\n        while (k > 1){\\n            ptr = lower_bound(ptr, price.end(), *ptr + answer);\\n            if (ptr == price.end()) return false;\\n            k--;\\n        }\\n        if (ptr != price.end()) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021385,
                "title": "python-simple-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTastiness(self, price, k):\\n        n = len(price)\\n\\n        price.sort()\\n\\n        def func_(max_val):\\n            total, last_candy = 1, price[0]\\n\\n            for i in range(1,n):\\n                if price[i] - last_candy >= max_val:\\n                    total += 1\\n                    last_candy = price[i]\\n\\n            return total >= k\\n\\n        low, high = 0, sum(price)\\n\\n        while low <= high:\\n            mid = (low + high)//2\\n\\n            if func_(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n\\n        return high\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price, k):\\n        n = len(price)\\n\\n        price.sort()\\n\\n        def func_(max_val):\\n            total, last_candy = 1, price[0]\\n\\n            for i in range(1,n):\\n                if price[i] - last_candy >= max_val:\\n                    total += 1\\n                    last_candy = price[i]\\n\\n            return total >= k\\n\\n        low, high = 0, sum(price)\\n\\n        while low <= high:\\n            mid = (low + high)//2\\n\\n            if func_(mid):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n\\n        return high\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019106,
                "title": "c-binary-search-sorting-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    bool okay(int diff,vector<int> &price,int k){\\n        int count = 1;\\n        int last = price[0];\\n\\n        for(int i = 0; i < price.size();i++){\\n            if(price[i] - last >= diff){\\n                count++;\\n                last = price[i];\\n            }\\n        }\\n\\n        if(count >= k) return true;\\n\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int n = price.size();\\n\\n        sort(price.begin(),price.end());\\n\\n        int low = 0;\\n        int high = price[n-1] - price[0];\\n\\n        int ans = -1;\\n\\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n\\n            // we assume mid as the minimum difference between candies \\n            // and try to see if it is possible to choose k candies\\n            // keeping this minimum difference\\n            // if it is possible we need to maximize our answer according \\n            // to question so , reduce search space low = mid + 1\\n            if(okay(mid,price,k)){\\n                low = mid + 1;     \\n            }\\n            \\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n\\n        return high;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    bool okay(int diff,vector<int> &price,int k){\\n        int count = 1;\\n        int last = price[0];\\n\\n        for(int i = 0; i < price.size();i++){\\n            if(price[i] - last >= diff){\\n                count++;\\n                last = price[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3009050,
                "title": "python-3-binary-search-for-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince any value less then maximum will always satisfy the condition and every value above will not follow so it looks natural to use Binary search.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(Nlog(N))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        def is_possible(v):\\n            count,j=1,0\\n            for i,x in enumerate(price):\\n                if x-price[j]>=v:\\n                    count+=1\\n                    j=i\\n            return count>=k\\n\\n        l,r=0,price[-1]-price[0]\\n        while l<=r:\\n            mid=l+(r-l)//2\\n            if is_possible(mid):\\n                res=mid\\n                l=mid+1\\n            else:\\n                r=mid-1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        def is_possible(v):\\n            count,j=1,0\\n            for i,x in enumerate(price):\\n                if x-price[j]>=v:\\n                    count+=1\\n                    j=i\\n            return count>=k\\n\\n        l,r=0,price[-1]-price[0]\\n        while l<=r:\\n            mid=l+(r-l)//2\\n            if is_possible(mid):\\n                res=mid\\n                l=mid+1\\n            else:\\n                r=mid-1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997195,
                "title": "a-simple-binary-search-solution",
                "content": "# Intuition\\nThe intuition for solving this problem is to do binary search over answer across the sorted array of price .\\n\\n# Approach\\nThe approach of this problem is simple binary search over answer where answer can lie between 0 to 1e9 . Here 0 is left limit & 1e9 is right limit .Every time we will take middle(mid) of left limit(l) & right limit(r) .\\nStarting from first element we will find the next element with difference bewteen 2 selected consecutive elements >= mid .\\nIf we can select such subsequence with this condition of length >= k then we will increase our left limit(l) = mid + 1 otherwise deduce right limit(r) = mid - 1 ;\\n# Complexity\\n- Time complexity: O(N*logN) , where N is the length of array .\\n\\n- Space complexity: O(1) , here we are not using any auxiliary container , only using l , r , mid , count as varibles .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& prices , int k) {\\n        sort(prices.begin() , prices.end()) ;\\n        int n = prices.size() ;\\n        int l = 0 , r = 1e9 , ans = -1 ;\\n        while(l <= r){\\n            int mid = l + (r - l) / 2 , count = 1 , prev = prices[0] ;\\n            for(int i = 1 ; i < n ; i ++) if(prices[i] - prev >= mid) count ++ , prev = prices[i] ;\\n            if(count >= k){\\n                l = mid + 1 ;\\n                if(count == k) ans = mid ;\\n            }\\n            else r = mid - 1 ;\\n        }\\n        if(ans == -1) return r ;\\n        else return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& prices , int k) {\\n        sort(prices.begin() , prices.end()) ;\\n        int n = prices.size() ;\\n        int l = 0 , r = 1e9 , ans = -1 ;\\n        while(l <= r){\\n            int mid = l + (r - l) / 2 , count = 1 , prev = prices[0] ;\\n            for(int i = 1 ; i < n ; i ++) if(prices[i] - prev >= mid) count ++ , prev = prices[i] ;\\n            if(count >= k){\\n                l = mid + 1 ;\\n                if(count == k) ans = mid ;\\n            }\\n            else r = mid - 1 ;\\n        }\\n        if(ans == -1) return r ;\\n        else return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995263,
                "title": "java-simple-binary-search-approach",
                "content": "# Intuition\\nBinary Search \\n# Complexity\\n- Sort Array - O(nlogn)\\n- max, min - Maximum & Minimum price in array\\n- Time complexity: \\n- O(log(max - min) * k * logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - constant space\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        int n = price.length;\\n        Arrays.sort(price);\\n        int temp = k;\\n        \\n        int low = 0, high = price[n - 1] - price[0];\\n        int mid = 0, idx = 0, maxTastiness = 0;\\n        \\n        while(low <= high) {\\n            mid = (low + high)/2;\\n            idx = 0;\\n            \\n            while(k-- > 1) {\\n                idx = binSearch(price, idx + 1, n - 1, price[idx] + mid);    \\n                if(idx == -1) \\n                    break;\\n            }\\n            \\n            if(idx != -1) {\\n                maxTastiness = mid;\\n                low = mid + 1;\\n            }\\n            else \\n                high = mid - 1;\\n            \\n            k = temp;\\n        }\\n        \\n        return maxTastiness;\\n    }\\n    \\n    public int binSearch(int[] arr, int low, int high, int x) {\\n        int idx = -1;\\n        while(low <= high) {\\n            int mid = (low + high)/2;\\n            \\n            if(arr[mid] == x)\\n                return mid;\\n            else if(arr[mid] > x) {\\n                idx = mid;\\n                high = mid - 1;\\n            }\\n            else \\n                low = mid + 1;\\n        }\\n        \\n        return idx;\\n    }\\n    \\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] price, int k) {\\n        int n = price.length;\\n        Arrays.sort(price);\\n        int temp = k;\\n        \\n        int low = 0, high = price[n - 1] - price[0];\\n        int mid = 0, idx = 0, maxTastiness = 0;\\n        \\n        while(low <= high) {\\n            mid = (low + high)/2;\\n            idx = 0;\\n            \\n            while(k-- > 1) {\\n                idx = binSearch(price, idx + 1, n - 1, price[idx] + mid);    \\n                if(idx == -1) \\n                    break;\\n            }\\n            \\n            if(idx != -1) {\\n                maxTastiness = mid;\\n                low = mid + 1;\\n            }\\n            else \\n                high = mid - 1;\\n            \\n            k = temp;\\n        }\\n        \\n        return maxTastiness;\\n    }\\n    \\n    public int binSearch(int[] arr, int low, int high, int x) {\\n        int idx = -1;\\n        while(low <= high) {\\n            int mid = (low + high)/2;\\n            \\n            if(arr[mid] == x)\\n                return mid;\\n            else if(arr[mid] > x) {\\n                idx = mid;\\n                high = mid - 1;\\n            }\\n            else \\n                low = mid + 1;\\n        }\\n        \\n        return idx;\\n    }\\n    \\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993529,
                "title": "easy-understanding-c-solution-simple-approach",
                "content": "```\\nclass Solution {\\n    bool check(int n,vector<int> &price,int k)\\n    {\\n        k--;\\n        int prev = price[0];\\n        for(int i=1;i<price.size();i++)\\n        {\\n            if((price[i] - prev) >= n)\\n            {\\n                k--;\\n                prev = price[i];\\n            }\\n        }\\n        \\n        return k<=0;\\n    }\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        \\n        sort(price.begin(),price.end());\\n        int n = price.size();\\n        int l=0,h;\\n        h = price[n-1] - price[0];\\n        int ans = 0;\\n        while(l<=h)\\n        {\\n            int mid = (l+(h-l)/2);\\n\\n            if(check(mid,price,k))\\n            {\\n                ans = max(ans,mid);\\n                l = mid+1;\\n            }else{\\n                h = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool check(int n,vector<int> &price,int k)\\n    {\\n        k--;\\n        int prev = price[0];\\n        for(int i=1;i<price.size();i++)\\n        {\\n            if((price[i] - prev) >= n)\\n            {\\n                k--;\\n                prev = price[i];\\n            }\\n        }\\n        \\n        return k<=0;\\n    }\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        \\n        sort(price.begin(),price.end());\\n        int n = price.size();\\n        int l=0,h;\\n        h = price[n-1] - price[0];\\n        int ans = 0;\\n        while(l<=h)\\n        {\\n            int mid = (l+(h-l)/2);\\n\\n            if(check(mid,price,k))\\n            {\\n                ans = max(ans,mid);\\n                l = mid+1;\\n            }else{\\n                h = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992993,
                "title": "c-sort-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(max(nlogn, kn))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int l = 0, r = (price.back()-price[0])/(k-1)+1;\\n        while(l+1<r){\\n            int mid = (l+r)/2;\\n            if(test(price, k, mid))\\n                l = mid;\\n            else\\n                r = mid;\\n        }\\n        return l;\\n    }\\n    bool test(vector<int>& price, int k, int v){\\n        int cur = 0, next = 0, n=1;\\n        while(cur<price.size()){\\n            next = cur+1;\\n            while(next<price.size() && price[next] - price[cur] < v)\\n                next++;\\n            if(next <price.size() && price[next] - price[cur] >= v)\\n                n++;\\n            cur = next;\\n        }\\n        return n>=k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int l = 0, r = (price.back()-price[0])/(k-1)+1;\\n        while(l+1<r){\\n            int mid = (l+r)/2;\\n            if(test(price, k, mid))\\n                l = mid;\\n            else\\n                r = mid;\\n        }\\n        return l;\\n    }\\n    bool test(vector<int>& price, int k, int v){\\n        int cur = 0, next = 0, n=1;\\n        while(cur<price.size()){\\n            next = cur+1;\\n            while(next<price.size() && price[next] - price[cur] < v)\\n                next++;\\n            if(next <price.size() && price[next] - price[cur] >= v)\\n                n++;\\n            cur = next;\\n        }\\n        return n>=k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992623,
                "title": "accepted-binary-search-on-answer-aggressive-cows",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAggressive Cows based problem.\\nWe need to apply binary search on a search space ranging from 1 to maximum difference available in the array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary Search On Answer/Range\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    vector<int> v;\\n    int n;\\npublic:\\n    // dist --. tastiness\\n    bool check(int dist, int k){\\n        int cnt = 1;\\n        int _taken = v[0];\\n        for(int i = 1; i < n; i++){\\n            if(v[i] - _taken >= dist){\\n                cnt++;\\n                _taken = v[i];\\n            }\\n        }\\n        if(cnt >= k) return true;\\n        return false;\\n    }\\n\\n    int maximumTastiness(vector<int>& price, int k) {\\n        v = price;\\n        sort(v.begin(), v.end());\\n        n = v.size();\\n        int hi = v[n-1] - v[0], lo = 1;\\n        while(hi >= lo){\\n            int mid = lo + (hi - lo)/2;\\n            if(check(mid, k)){\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> v;\\n    int n;\\npublic:\\n    // dist --. tastiness\\n    bool check(int dist, int k){\\n        int cnt = 1;\\n        int _taken = v[0];\\n        for(int i = 1; i < n; i++){\\n            if(v[i] - _taken >= dist){\\n                cnt++;\\n                _taken = v[i];\\n            }\\n        }\\n        if(cnt >= k) return true;\\n        return false;\\n    }\\n\\n    int maximumTastiness(vector<int>& price, int k) {\\n        v = price;\\n        sort(v.begin(), v.end());\\n        n = v.size();\\n        int hi = v[n-1] - v[0], lo = 1;\\n        while(hi >= lo){\\n            int mid = lo + (hi - lo)/2;\\n            if(check(mid, k)){\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return hi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988980,
                "title": "double-binary-search-in-c",
                "content": "# Intuition\\nSince tastiness is determined by the distance between adjacent elements, it\\'s always possible to pick k elements with distance that is at least `0` but as we expand this gap, at some point it will no longer be possible to pick the right set of elements. This monotonicity property suggests usage of binary search to find the highest tastiness that is still small enough to form valid set of elements.\\n\\n# Approach\\nBisect is used to find the highest value of tastiness for which `valid` is still true. `valid` function picks the first element and tries to eagerly pick the next smallest element that is at at least `tastiness` bigger (`*first + tastiness`). Since `price` is sorted, it\\'s possible to use `lower_bound` to find the next such element.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\times log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$ since the input array is modified.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(begin(price), end(price));\\n        auto valid = [&price, k](int tastiness) {\\n            auto first = begin(price);\\n            for (int i = 1; i < k && first != end(price); ++i)\\n                first = lower_bound(next(first), end(price), *first + tastiness);\\n            return first != end(price);\\n        };\\n        int lo = 0, hi = price.back();\\n        while (lo + 1 < hi)\\n            if (int mid = lo + (hi - lo) / 2; valid(mid)) {\\n                lo = mid;\\n            } else {\\n                hi = mid;\\n            }\\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(begin(price), end(price));\\n        auto valid = [&price, k](int tastiness) {\\n            auto first = begin(price);\\n            for (int i = 1; i < k && first != end(price); ++i)\\n                first = lower_bound(next(first), end(price), *first + tastiness);\\n            return first != end(price);\\n        };\\n        int lo = 0, hi = price.back();\\n        while (lo + 1 < hi)\\n            if (int mid = lo + (hi - lo) / 2; valid(mid)) {\\n                lo = mid;\\n            } else {\\n                hi = mid;\\n            }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2988155,
                "title": "binary-search-similar-to-spoj-aggressive-cows-syed-mujtaba",
                "content": "# Intuition\\nhttps://www.spoj.com/problems/AGGRCOW/\\nBinary search on answer\\n\\n# Complexity\\n- Time complexity:\\nlog(1e9) * N\\n\\n- Space complexity: \\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        \\n        sort(price.begin(), price.end());\\n        \\n        long long ans = 0;\\n        \\n        long long lo = 1, hi = 1000000001, mid;\\n        \\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            \\n            long long fill = 1;\\n            \\n            long long cur = price[0] + mid;\\n            \\n            for (int j = 1; j < (int)price.size(); j++) {\\n                if (price[j] >= cur) {\\n                    cur = price[j] + mid;\\n                    fill++;\\n                    if (fill >= k) {\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (fill == k) {\\n                ans = max(ans, mid);\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        \\n        sort(price.begin(), price.end());\\n        \\n        long long ans = 0;\\n        \\n        long long lo = 1, hi = 1000000001, mid;\\n        \\n        while (lo <= hi) {\\n            mid = (lo + hi) / 2;\\n            \\n            long long fill = 1;\\n            \\n            long long cur = price[0] + mid;\\n            \\n            for (int j = 1; j < (int)price.size(); j++) {\\n                if (price[j] >= cur) {\\n                    cur = price[j] + mid;\\n                    fill++;\\n                    if (fill >= k) {\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (fill == k) {\\n                ans = max(ans, mid);\\n                lo = mid + 1;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2985138,
                "title": "simple-java-binary-search",
                "content": "# Intuition\\nBinary Search on Answer\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumTastiness(int[] arr, int k) {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        int l = 0;\\n        int h = arr[n-1] - arr[0];\\n        int res = 0;\\n        while(l<=h){\\n            int mid = l + (h-l)/2;\\n            if(possible(arr,mid,k)){\\n                l = mid+1;\\n                res = Math.max(res,mid);\\n            }\\n            else{\\n                h = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n    boolean possible(int arr[], int mid, int k){\\n        int l = arr[0];\\n        int temp = 1;\\n        for(int i = 1; i<arr.length;i++){\\n            if(arr[i] - l >= mid){\\n                l = arr[i];\\n                temp++;\\n            }\\n        }\\n        return temp>=k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumTastiness(int[] arr, int k) {\\n        int n = arr.length;\\n        Arrays.sort(arr);\\n        int l = 0;\\n        int h = arr[n-1] - arr[0];\\n        int res = 0;\\n        while(l<=h){\\n            int mid = l + (h-l)/2;\\n            if(possible(arr,mid,k)){\\n                l = mid+1;\\n                res = Math.max(res,mid);\\n            }\\n            else{\\n                h = mid-1;\\n            }\\n        }\\n        return res;\\n    }\\n    boolean possible(int arr[], int mid, int k){\\n        int l = arr[0];\\n        int temp = 1;\\n        for(int i = 1; i<arr.length;i++){\\n            if(arr[i] - l >= mid){\\n                l = arr[i];\\n                temp++;\\n            }\\n        }\\n        return temp>=k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984871,
                "title": "swift-binarysearch",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nI don\\'t think it\\'s easy to comes to binary search\\nhere\\'s my take away\\n\\n1. maximum diff in arry is [max of arry] - [min of array]\\n2. in sorted array, can check is the given diff exist or not in one loop\\n3. now add one more requirement: k, should match k times for the condition, in the other words, we need to find k pairs which diff >= target\\n4. still can cehck in one loop by two-pointers, the concept is: if `(i, j)` is the first pair that `nums[j] - nums[i] \\u2265 diff`\\nit\\u2019s impossible to have another pair between [i\\u2026j] for the array is in ascending order, so we can find next pair from j to end\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nBtw, the binary search is not the best shortest approach, but I\\'d like to use same template due to variation somehow means error-prone to me.\\n\\nMy binary search pattern here for your reference\\n1. always check left <= right\\n2. find the case can cut half\\n3. handle two items case by left == mid, check the right item result if need\\n\\n# Code\\n```\\n/*\\n    [1, 2, 5, 8, 13, 21], k = 3\\n                          maxDiff = 21 - 1 = 20\\n                          mid: tastiness\\n   i ^\\n   j       ^: if price[j] - price[i] < tastiness -> j+=1 to look for larger number\\n                            else: i = j, find next pair\\n                            because ascending, i...j impossible to build another pair diff > tastiness\\n    \\n */\\nclass Solution {\\n    func maximumTastiness(_ price: [Int], _ k: Int) -> Int {\\n        let sorted = price.sorted { $0 < $1 }\\n        return maximumTastiness(sorted, k, 0, sorted[sorted.count - 1] - sorted[0])\\n    }\\n    \\n    func maximumTastiness(_ price: [Int], _ k: Int, _ left: Int, _ right: Int) -> Int {\\n        guard left <= right else {\\n            return 0\\n        }\\n        let mid = left + (right - left) / 2\\n        if !check(price, k, mid) {\\n            // diff num too large, should shrink the number\\n            return maximumTastiness(price, k, left, mid-1)\\n        } else {\\n            // can match the target, try find smaller solution\\n            // [1, 2], check: true  [1, 2], check :false\\n            //  ^                    ^\\n            if left == mid {\\n                return check(price, k, right) ? right : left\\n            }\\n            return maximumTastiness(price, k, mid, right)\\n        }\\n    }\\n        \\n    func check(_ price: [Int], _ k: Int, _ target: Int) -> Bool {\\n        var count = 1\\n        var i = 0\\n        for j in 1..<price.count {\\n            if price[j] - price[i] >= target {\\n                i = j\\n                count += 1\\n            }\\n            if count >= k {\\n                break\\n            }\\n        }\\n        return count >= k\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/*\\n    [1, 2, 5, 8, 13, 21], k = 3\\n                          maxDiff = 21 - 1 = 20\\n                          mid: tastiness\\n   i ^\\n   j       ^: if price[j] - price[i] < tastiness -> j+=1 to look for larger number\\n                            else: i = j, find next pair\\n                            because ascending, i...j impossible to build another pair diff > tastiness\\n    \\n */\\nclass Solution {\\n    func maximumTastiness(_ price: [Int], _ k: Int) -> Int {\\n        let sorted = price.sorted { $0 < $1 }\\n        return maximumTastiness(sorted, k, 0, sorted[sorted.count - 1] - sorted[0])\\n    }\\n    \\n    func maximumTastiness(_ price: [Int], _ k: Int, _ left: Int, _ right: Int) -> Int {\\n        guard left <= right else {\\n            return 0\\n        }\\n        let mid = left + (right - left) / 2\\n        if !check(price, k, mid) {\\n            // diff num too large, should shrink the number\\n            return maximumTastiness(price, k, left, mid-1)\\n        } else {\\n            // can match the target, try find smaller solution\\n            // [1, 2], check: true  [1, 2], check :false\\n            //  ^                    ^\\n            if left == mid {\\n                return check(price, k, right) ? right : left\\n            }\\n            return maximumTastiness(price, k, mid, right)\\n        }\\n    }\\n        \\n    func check(_ price: [Int], _ k: Int, _ target: Int) -> Bool {\\n        var count = 1\\n        var i = 0\\n        for j in 1..<price.count {\\n            if price[j] - price[i] >= target {\\n                i = j\\n                count += 1\\n            }\\n            if count >= k {\\n                break\\n            }\\n        }\\n        return count >= k\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981605,
                "title": "binary-search-details-boolean-fn-to-produce-monotonicity-and-search-range-shrinkage-python",
                "content": "Here we aim to explain the genric binary search usage. It consists of two main steps: 1. Boolean function to produce monotonicity; 2. Determine search range, and do proper search range shrinkage and then proper return.\\n\\n1- A Solution format \\n```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        \\n        # 1. prep\\n        n = len(price)\\n        price.sort()\\n        \\n        # 2. define boolean fn for binary search\\n        def fulfill(t):\\n            \"\"\"\\n            check if k distinct candies can achive tastiness >= t\\n            \"\"\"\\n            cnt = 1\\n            last_price = price[0]\\n            for i in range(1, n):\\n                if price[i] - last_price >= t:\\n                    cnt += 1\\n                    last_price = price[i]\\n            return cnt >= k\\n        \\n        # 3. binary search: determine search range, and find search range thrinkage\\n        # find max t such that fulfill(t) is True\\n        low, high = 0, price[-1] - price[0]\\n        while low < high:\\n            mid = high - (high - low) // 2\\n            if fulfill(mid):\\n                low = mid\\n            else:\\n                high = mid - 1\\n        return low\\n        \\n```\\n\\n2. Digest\\n\\nVideo Explanation: [Click Here](https://youtu.be/0VII82H7UeM;)\\n\\n```\\nMethod: Binary Search\\n\\nComment: this is a standard Binary Search Problem.\\n\\nRecall in general Binary Search, we need to do two things:\\n    - Define boolean fn to produce monotonicity\\n    - Determine Search Range and do proper Search Range shrinkage\\n    \\nFor this problem, we are going to do the explanation while doing the coding.\\n\\nComment: the hints for this problem almost readily give a full solution.\\nMore practices: Please check the playlist in our Youtube Channel for a number of Leetcode problems that can be solved using Binary Search, especially for digesting the thought processes to address the two ingredients in Binary Search.\\n```\\n\\nExtention and more practices:\\n\\nChannel: [channel](https://www.youtube.com/channel/UCGLKd0UanbI6qRiSkekCZmA;)\\nBinary Search Playlist: [Playlist](https://www.youtube.com/watch?v=cz81mA5T-L4&list=PLWmR_uGniCLmn7w-vpJ_wo7y54SVpJ4Kq;)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        \\n        # 1. prep\\n        n = len(price)\\n        price.sort()\\n        \\n        # 2. define boolean fn for binary search\\n        def fulfill(t):\\n            \"\"\"\\n            check if k distinct candies can achive tastiness >= t\\n            \"\"\"\\n            cnt = 1\\n            last_price = price[0]\\n            for i in range(1, n):\\n                if price[i] - last_price >= t:\\n                    cnt += 1\\n                    last_price = price[i]\\n            return cnt >= k\\n        \\n        # 3. binary search: determine search range, and find search range thrinkage\\n        # find max t such that fulfill(t) is True\\n        low, high = 0, price[-1] - price[0]\\n        while low < high:\\n            mid = high - (high - low) // 2\\n            if fulfill(mid):\\n                low = mid\\n            else:\\n                high = mid - 1\\n        return low\\n        \\n```\n```\\nMethod: Binary Search\\n\\nComment: this is a standard Binary Search Problem.\\n\\nRecall in general Binary Search, we need to do two things:\\n    - Define boolean fn to produce monotonicity\\n    - Determine Search Range and do proper Search Range shrinkage\\n    \\nFor this problem, we are going to do the explanation while doing the coding.\\n\\nComment: the hints for this problem almost readily give a full solution.\\nMore practices: Please check the playlist in our Youtube Channel for a number of Leetcode problems that can be solved using Binary Search, especially for digesting the thought processes to address the two ingredients in Binary Search.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981388,
                "title": "a-few-solutions",
                "content": "Perform a logarithmic amount of guesses via binary search to find the maximum threshold `T` via a linear scan of the *sorted* input array `A` per guess.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun maximumTastiness(A: IntArray, K: Int): Int {\\n        A.sort()\\n        fun ok(T: Int): Boolean {\\n            var edges = 0\\n            var (i, j) = Pair(0, 0)\\n            while (j < A.size) {\\n                if (T <= A[j] - A[i]) {\\n                    i = j; ++edges\\n                }\\n                ++j\\n            }\\n            return K <= edges + 1 // +1 to count vertices edges connect\\n        }\\n        var (i, j) = Pair(0, 1e9.toInt())\\n        while (i < j) {\\n            var T = (i + j + 1) / 2\\n            if (ok(T))\\n                i = T\\n            else\\n                j = T - 1\\n        }\\n        return i\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet maximumTastiness = (A, K) => {\\n    A.sort((a, b) => a - b);\\n    let ok = (T, edges = 0) => {\\n        let [i, j] = [0, 0];\\n        while (j < A.length) {\\n            if (T <= A[j] - A[i])\\n                i = j, ++edges;\\n            ++j;\\n        }\\n        return K <= edges + 1; // +1 to count vertices edges connect\\n    };\\n    let [i, j] = [0, Number(1e9)];\\n    while (i < j) {\\n        let T = Math.floor((i + j + 1) / 2);\\n        if (ok(T))\\n            i = T;\\n        else\\n            j = T - 1;\\n    }\\n    return i;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def maximumTastiness(self, A: List[int], K: int) -> int:\\n        A.sort()\\n        def ok(T, edges = 0):\\n            i, j = 0, 0\\n            while j < len(A):\\n                if T <= A[j] - A[i]:\\n                    i = j; edges += 1\\n                j += 1\\n            return K <= edges + 1 # +1 to count vertices edges connect\\n        i, j = 0, int(1e9)\\n        while i < j:\\n            T = (i + j + 1) // 2\\n            if ok(T):\\n                i = T\\n            else:\\n                j = T - 1\\n        return i\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn maximum_tastiness(mut A: VI, K: i32) -> i32 {\\n        A.sort();\\n        fn ok(A: &VI, T: i32, K: i32) -> bool {\\n            let mut edges = 0;\\n            let (mut i, mut j) = (0, 0);\\n            while (j < A.len()) {\\n                if T <= A[j] - A[i] {\\n                    i = j; edges += 1;\\n                }\\n                j += 1;\\n            }\\n            K <= edges + 1 // +1 to count vectices edges connect\\n        }\\n        let (mut i, mut j) = (0, 1e9 as i32);\\n        while i < j {\\n            let T = (i + j + 1) / 2;\\n            if ok(&A, T, K) {\\n                i = T;\\n            } else {\\n                j = T - 1;\\n            }\\n        }\\n        i\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maximumTastiness(VI& A, int K) {\\n        sort(A.begin(), A.end());\\n        auto ok = [&](auto T) {\\n            auto edges = 0;\\n            auto [i, j] = make_pair(0, 0);\\n            while (j < A.size()) {\\n                if (T <= A[j] - A[i])\\n                    i = j, ++edges;\\n                ++j;\\n            }\\n            return K <= edges + 1; // +1 to count vertices edges connect\\n        };\\n        auto [i, j] = make_pair(0, int(1e9));\\n        while (i < j) {\\n            auto T = (i + j + 1) / 2;\\n            if (ok(T))\\n                i = T;\\n            else\\n                j = T - 1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun maximumTastiness(A: IntArray, K: Int): Int {\\n        A.sort()\\n        fun ok(T: Int): Boolean {\\n            var edges = 0\\n            var (i, j) = Pair(0, 0)\\n            while (j < A.size) {\\n                if (T <= A[j] - A[i]) {\\n                    i = j; ++edges\\n                }\\n                ++j\\n            }\\n            return K <= edges + 1 // +1 to count vertices edges connect\\n        }\\n        var (i, j) = Pair(0, 1e9.toInt())\\n        while (i < j) {\\n            var T = (i + j + 1) / 2\\n            if (ok(T))\\n                i = T\\n            else\\n                j = T - 1\\n        }\\n        return i\\n    }\\n}\\n```\n```\\nlet maximumTastiness = (A, K) => {\\n    A.sort((a, b) => a - b);\\n    let ok = (T, edges = 0) => {\\n        let [i, j] = [0, 0];\\n        while (j < A.length) {\\n            if (T <= A[j] - A[i])\\n                i = j, ++edges;\\n            ++j;\\n        }\\n        return K <= edges + 1; // +1 to count vertices edges connect\\n    };\\n    let [i, j] = [0, Number(1e9)];\\n    while (i < j) {\\n        let T = Math.floor((i + j + 1) / 2);\\n        if (ok(T))\\n            i = T;\\n        else\\n            j = T - 1;\\n    }\\n    return i;\\n};\\n```\n```\\nclass Solution:\\n    def maximumTastiness(self, A: List[int], K: int) -> int:\\n        A.sort()\\n        def ok(T, edges = 0):\\n            i, j = 0, 0\\n            while j < len(A):\\n                if T <= A[j] - A[i]:\\n                    i = j; edges += 1\\n                j += 1\\n            return K <= edges + 1 # +1 to count vertices edges connect\\n        i, j = 0, int(1e9)\\n        while i < j:\\n            T = (i + j + 1) // 2\\n            if ok(T):\\n                i = T\\n            else:\\n                j = T - 1\\n        return i\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn maximum_tastiness(mut A: VI, K: i32) -> i32 {\\n        A.sort();\\n        fn ok(A: &VI, T: i32, K: i32) -> bool {\\n            let mut edges = 0;\\n            let (mut i, mut j) = (0, 0);\\n            while (j < A.len()) {\\n                if T <= A[j] - A[i] {\\n                    i = j; edges += 1;\\n                }\\n                j += 1;\\n            }\\n            K <= edges + 1 // +1 to count vectices edges connect\\n        }\\n        let (mut i, mut j) = (0, 1e9 as i32);\\n        while i < j {\\n            let T = (i + j + 1) / 2;\\n            if ok(&A, T, K) {\\n                i = T;\\n            } else {\\n                j = T - 1;\\n            }\\n        }\\n        i\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int maximumTastiness(VI& A, int K) {\\n        sort(A.begin(), A.end());\\n        auto ok = [&](auto T) {\\n            auto edges = 0;\\n            auto [i, j] = make_pair(0, 0);\\n            while (j < A.size()) {\\n                if (T <= A[j] - A[i])\\n                    i = j, ++edges;\\n                ++j;\\n            }\\n            return K <= edges + 1; // +1 to count vertices edges connect\\n        };\\n        auto [i, j] = make_pair(0, int(1e9));\\n        while (i < j) {\\n            auto T = (i + j + 1) / 2;\\n            if (ok(T))\\n                i = T;\\n            else\\n                j = T - 1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981083,
                "title": "sort-binary-search-explained",
                "content": "# Intuition\\nSort it.\\n# Approach\\nThe max absolute difference needed will be between 0 and max(prices) - min(prices). Run a binary search (logn) in this space, assume mid to be the max absolute difference. Check if you can collect elements from prices such that the max absolute difference is mid. If yes, then either this will be your answer or answer lies within values greater than it. If no, then values beyond mid will not be the answer hence reduce the search space such that end = mid - 1\\n\\n# Complexity\\n- Time complexity:\\n O(nlogn)\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        end = price[-1] - price[0]\\n        start = 0\\n        n = len(price)\\n        res = 0\\n\\n        while start <= end:\\n            mid = (start + end) // 2\\n            if self.isValid(price, k, mid, n):\\n                res = mid\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n\\n        return res\\n        \\n\\n    def isValid(self, price, k, mid, n):\\n        last_in = price[0]\\n        k -= 1\\n        for i in range(1, n):\\n            if price[i] - last_in >= mid:\\n                last_in = price[i]\\n                k -= 1\\n            if k == 0:\\n                return True\\n        return False\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumTastiness(self, price: List[int], k: int) -> int:\\n        price.sort()\\n        end = price[-1] - price[0]\\n        start = 0\\n        n = len(price)\\n        res = 0\\n\\n        while start <= end:\\n            mid = (start + end) // 2\\n            if self.isValid(price, k, mid, n):\\n                res = mid\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n\\n        return res\\n        \\n\\n    def isValid(self, price, k, mid, n):\\n        last_in = price[0]\\n        k -= 1\\n        for i in range(1, n):\\n            if price[i] - last_in >= mid:\\n                last_in = price[i]\\n                k -= 1\\n            if k == 0:\\n                return True\\n        return False\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975566,
                "title": "binary-search",
                "content": "\\nclass Solution {\\npublic:\\nint count(vector<int>& price,int mid,int k)\\n{\\n    int c=1;\\n    int pre=price[0];\\n    for(int i=1;i<price.size();i++)\\n    {\\n        if(price[i]-pre>=mid)\\n        {\\n            c++;\\n            pre=price[i];\\n        }\\n    }\\n    if(c>=k)\\n    return c;\\n    return 0;\\n}\\n    int maximumTastiness(vector<int>& price, int k) {\\n     //using pp=pair<int,int>;\\n     int n=price.size();\\n     sort(price.begin(),price.end());\\n     int low=0;\\n     int high=price[n-1]-price[0];\\n     int mid,ans=0;\\n     while(low<=high)\\n     {\\n         int mid=low+(high-low)/2;\\n         int y=count(price,mid,k);\\n\\n         if(y>=k)\\n         {\\n             low=mid+1;\\n             ans=mid;\\n         }\\n         else high=mid-1;\\n     }\\n     return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\nint count(vector<int>& price,int mid,int k)\\n{\\n    int c=1;\\n    int pre=price[0];\\n    for(int i=1;i<price.size();i++)\\n    {\\n        if(price[i]-pre>=mid)\\n        {\\n            c++;\\n            pre=price[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2975515,
                "title": "binary-search-simple-elegant-o-nlogn",
                "content": "```\\nbool isPossible(int &currDiff,vector<int>&arr,int &k){\\n    int currPrice = arr[0];\\n    int count=1;\\n    int i=0;\\n    while(true){\\n        int pos = lower_bound(arr.begin()+i,arr.end(),currPrice+currDiff) - arr.begin();\\n        if(pos>=arr.size()) break; // not possible so break it;\\n        else{\\n            count++;\\n            currPrice = arr[pos];\\n            i=pos+1;\\n        }\\n    }\\n    // cout<<currDiff<<\" \"<<(count>=k)<<\"\\\\n\";\\n    return (count >= k);\\n}\\n\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        int low=0;\\n        int n = price.size();\\n        int high = price[n-1] - price[0];\\n        while(low<high){\\n            int mid  = low + (high-low)/2;\\n            if(isPossible(mid,price,k))\\n                low=mid;\\n            else\\n                high=mid;\\n            if(high-low==1) break;\\n        }\\n        \\n        if(isPossible(high,price,k))\\n            return high;\\n        else\\n            return low;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPossible(int &currDiff,vector<int>&arr,int &k){\\n    int currPrice = arr[0];\\n    int count=1;\\n    int i=0;\\n    while(true){\\n        int pos = lower_bound(arr.begin()+i,arr.end(),currPrice+currDiff) - arr.begin();\\n        if(pos>=arr.size()) break; // not possible so break it;\\n        else{\\n            count++;\\n            currPrice = arr[pos];\\n            i=pos+1;\\n        }\\n    }\\n    // cout<<currDiff<<\" \"<<(count>=k)<<\"\\\\n\";\\n    return (count >= k);\\n}\\n\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        int low=0;\\n        int n = price.size();\\n        int high = price[n-1] - price[0];\\n        while(low<high){\\n            int mid  = low + (high-low)/2;\\n            if(isPossible(mid,price,k))\\n                low=mid;\\n            else\\n                high=mid;\\n            if(high-low==1) break;\\n        }\\n        \\n        if(isPossible(high,price,k))\\n            return high;\\n        else\\n            return low;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2973766,
                "title": "binary-search-on-answer-in-c",
                "content": "# Intuition\\nMaximize the minimum difference,these kind of problems requires dp or binary search\\n\\n# Approach\\nThe question asks to maximize the minimum ,so we can let the maximum value as a potential answer and can check it on the given price vector whether it can be the answer or not ,if yes then goes on taking the higher number as our maximum value and if not then come to lower values and check.(Apply binary search after sorting the price vector)\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long int lli;\\n    bool isok(lli mid,vector<int>&price,lli k)\\n    {\\n      lli i=0,num=0;\\n        while(i<price.size())\\n        {   num++;\\n            lli a=price[i]+mid;\\n         i=lower_bound(price.begin()+i+1,price.end(),a)-price.begin();\\n            \\n        }\\n        return num>=k;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        lli left=0,high=1e9,ans=-1;\\n        while(left<=high)\\n        {\\n            lli mid=(left+high)/2;\\n            if(isok(mid,price,k))\\n            {\\n                ans=mid;\\n                left=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long int lli;\\n    bool isok(lli mid,vector<int>&price,lli k)\\n    {\\n      lli i=0,num=0;\\n        while(i<price.size())\\n        {   num++;\\n            lli a=price[i]+mid;\\n         i=lower_bound(price.begin()+i+1,price.end(),a)-price.begin();\\n            \\n        }\\n        return num>=k;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        lli left=0,high=1e9,ans=-1;\\n        while(left<=high)\\n        {\\n            lli mid=(left+high)/2;\\n            if(isok(mid,price,k))\\n            {\\n                ans=mid;\\n                left=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970901,
                "title": "o-nlogm-solution-explained-intuition-with-clean-code-aggressive-cows-exactly-same",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- If u see first u think take all subsets and find ans.\\n- We may use RECURSION  - PICK and NOT PICK TECHNIQUE. \\n- But its O(2^N) - USELESS - WONT PASS - GIVES TLE \\n- Then We may write a O(N^2)\\n- By trying out all answers from 1 to 10^9 \\n- But this also gives a TLE.\\n- We observe a pattern the SEARCH SPACE. \\n- i.e. 1 to M = A[N-1] - A[0]\\n- This is SORTED and MONOTONIC INC FUNCTION\\n- This triggers BIN SEARCH IDEA.\\n- EG:\\n- If u see MAX Taste of 5 is not possible then 6, 7 ... also DEFENITELY NOT Possible at all. \\n- In such case the SEARCH SPACE IS NOW from 1 to 5 only.\\n- THIS KIND of cut down of SEARCH SPACE INTO HALVES happens only in BIN SEARCH.\\n- THIS WAY MOST OPTIMAL IS N*LOGM solution using **GREEDY and BIN SEARCH ALGO.**\\n\\n\\n# Complexity\\n-  **Time complexity:**\\n- O(NLOGN) + O(NLOGM) (sort thing  + greedy * bin serch = N*LogM)\\n- N is price len , M is A[N-1] - A[0]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:**\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//TIME : O(NLOGN) + O(NLOGM) (sort thing  + greedy * bin serch = N*LogM)\\n//N is price len , M is A[N-1] - A[0]\\n//EXTRA SPACE : O(1)\\n\\nclass Solution { \\nprivate:\\n    //GREEDY WAY - TAKES O(N)\\n    bool Found(vector<int>& price, int k, int diff){\\n        int ctr = 1; //count of how many selected - as we place first candy as 0th\\n        int last = 0; //its the GREEDY way to start from 0th idx when sorted\\n        for(int i=0; i<price.size(); i++){\\n            if(price[i] - price[last] >= diff){\\n                last = i; // 1 candy placed and from this we need to find next position\\n                ctr++;\\n            }\\n            if(ctr == k) return true;\\n            //at any point of time we picked all k candies then just return found\\n        }\\n        return false;\\n        // we can never find such config\\n    }\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int N = price.size();\\n        sort(price.begin(),price.end()); // NLogN\\n        \\n        int ans = -1;\\n\\n        int s = 0; //min most diff can be 0\\n        int e = price[N-1] - price[0]; // last - first in sorted is max diff possible \\n\\n        while(s <= e){\\n            int mid = s + (e-s)/2;\\n            if(Found(price, k, mid)){\\n                ans = mid;\\n                //still we need max most ans - so go right\\n                s = mid+1;\\n            }\\n            else{\\n                //then we need shrink the search space to left side SMALLER VALS\\n                e = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n- THIS PROVES ITS EXACTLY SAME AS AGGRESSIVE COWS.\\n\\n## KINDLY UPVOTE IF U LIKED IT AND UNDERSTOOD.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//TIME : O(NLOGN) + O(NLOGM) (sort thing  + greedy * bin serch = N*LogM)\\n//N is price len , M is A[N-1] - A[0]\\n//EXTRA SPACE : O(1)\\n\\nclass Solution { \\nprivate:\\n    //GREEDY WAY - TAKES O(N)\\n    bool Found(vector<int>& price, int k, int diff){\\n        int ctr = 1; //count of how many selected - as we place first candy as 0th\\n        int last = 0; //its the GREEDY way to start from 0th idx when sorted\\n        for(int i=0; i<price.size(); i++){\\n            if(price[i] - price[last] >= diff){\\n                last = i; // 1 candy placed and from this we need to find next position\\n                ctr++;\\n            }\\n            if(ctr == k) return true;\\n            //at any point of time we picked all k candies then just return found\\n        }\\n        return false;\\n        // we can never find such config\\n    }\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        int N = price.size();\\n        sort(price.begin(),price.end()); // NLogN\\n        \\n        int ans = -1;\\n\\n        int s = 0; //min most diff can be 0\\n        int e = price[N-1] - price[0]; // last - first in sorted is max diff possible \\n\\n        while(s <= e){\\n            int mid = s + (e-s)/2;\\n            if(Found(price, k, mid)){\\n                ans = mid;\\n                //still we need max most ans - so go right\\n                s = mid+1;\\n            }\\n            else{\\n                //then we need shrink the search space to left side SMALLER VALS\\n                e = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970472,
                "title": "binary-search-c",
                "content": "# Intuition\\nWhen ever we have to find the max of min or min of max. 90% of that question is of binary search in which first find the range where we have to apply binary search and the function which will valid that mid point or not.\\n\\n# Approach\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(0)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //The function which provide validation to the current mid point\\n    int ok(vector<int>&arr,int diff){\\n        int i=0,cnt=1;\\n        while(i<arr.size()){\\n            int in=lower_bound(arr.begin(),arr.end(),arr[i]+diff)-arr.begin();\\n            if(in==arr.size()){break;}\\n            cnt++;i=in;\\n        }return cnt;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        int ma=price.back()-price[0];\\n        if(ma==0){return 0;}\\n        //The range where gonna apply the BS.\\n        int l=1,r=ma;int ans=0;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(ok(price,m)>=k){\\n                ans=m;l=m+1;\\n            }else{r=m-1;}\\n        }return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //The function which provide validation to the current mid point\\n    int ok(vector<int>&arr,int diff){\\n        int i=0,cnt=1;\\n        while(i<arr.size()){\\n            int in=lower_bound(arr.begin(),arr.end(),arr[i]+diff)-arr.begin();\\n            if(in==arr.size()){break;}\\n            cnt++;i=in;\\n        }return cnt;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        int ma=price.back()-price[0];\\n        if(ma==0){return 0;}\\n        //The range where gonna apply the BS.\\n        int l=1,r=ma;int ans=0;\\n        while(l<=r){\\n            int m=l+(r-l)/2;\\n            if(ok(price,m)>=k){\\n                ans=m;l=m+1;\\n            }else{r=m-1;}\\n        }return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968947,
                "title": "binary-search-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int left = 0;\\n        int right = price[price.size()-1] - price[0]+1;\\n\\n\\n        while(left < right){\\n            int mid = left + (right - left)/2;\\n\\n            bool check = binarySearch(price, k, mid);\\n            if(check) {\\n                left = mid+1;\\n            }else{\\n                right = mid;\\n            }\\n        }\\n        \\n        if(left == 0){\\n            return left;\\n        }\\n        left--;\\n        return left;\\n\\n    }\\n\\n    bool binarySearch(vector<int>& prices, int k, int price){\\n        if(prices[prices.size()-1] - prices[0] < price){\\n            return false;\\n        }\\n        int count = 2;\\n        if(count>=k){\\n            return true;\\n        }\\n        int pre = 0;\\n        for(int i=1;i<prices.size()-1;i++){\\n            if(prices[i] - prices[pre]>=price && prices[prices.size()-1] - prices[i]>=price){\\n                count++;\\n                pre = i;\\n            }\\n\\n            if(count >= k){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(), price.end());\\n        int left = 0;\\n        int right = price[price.size()-1] - price[0]+1;\\n\\n\\n        while(left < right){\\n            int mid = left + (right - left)/2;\\n\\n            bool check = binarySearch(price, k, mid);\\n            if(check) {\\n                left = mid+1;\\n            }else{\\n                right = mid;\\n            }\\n        }\\n        \\n        if(left == 0){\\n            return left;\\n        }\\n        left--;\\n        return left;\\n\\n    }\\n\\n    bool binarySearch(vector<int>& prices, int k, int price){\\n        if(prices[prices.size()-1] - prices[0] < price){\\n            return false;\\n        }\\n        int count = 2;\\n        if(count>=k){\\n            return true;\\n        }\\n        int pre = 0;\\n        for(int i=1;i<prices.size()-1;i++){\\n            if(prices[i] - prices[pre]>=price && prices[prices.size()-1] - prices[i]>=price){\\n                count++;\\n                pre = i;\\n            }\\n\\n            if(count >= k){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967719,
                "title": "simple-easy-binary-search",
                "content": "```\\n      // First thing the tastiness will be in between maxPrice-minPrice and 0\\n     // So sort price and get r = maxPrice-minPrice and l=0\\n    // run binary search and check if mid can be that tastiness by forming k len array with it\\nclass Solution {\\npublic:\\n    bool check(int x,vector<int> price,int k){\\n        int len=1,j=0;\\n        for(int i=1;i<price.size();i++){\\n            if((price[i]-price[j])>=x){\\n                j=i;\\n                len++;\\n            }\\n        }\\n        if(len>=k) return true;\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n\\n        sort(price.begin(),price.end());\\n        int l = 0,r = price[price.size()-1]-price[0],ans=0;\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            cout<<mid<<endl;\\n            // check if the founded mid can form k length subarray if then ans is mid\\n            if(check(mid,price,k)){\\n                ans = mid;\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n      // First thing the tastiness will be in between maxPrice-minPrice and 0\\n     // So sort price and get r = maxPrice-minPrice and l=0\\n    // run binary search and check if mid can be that tastiness by forming k len array with it\\nclass Solution {\\npublic:\\n    bool check(int x,vector<int> price,int k){\\n        int len=1,j=0;\\n        for(int i=1;i<price.size();i++){\\n            if((price[i]-price[j])>=x){\\n                j=i;\\n                len++;\\n            }\\n        }\\n        if(len>=k) return true;\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n\\n        sort(price.begin(),price.end());\\n        int l = 0,r = price[price.size()-1]-price[0],ans=0;\\n        while(l<=r){\\n            int mid = l+(r-l)/2;\\n            cout<<mid<<endl;\\n            // check if the founded mid can form k length subarray if then ans is mid\\n            if(check(mid,price,k)){\\n                ans = mid;\\n                l = mid+1;\\n            }else{\\n                r = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2967497,
                "title": "swift-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func calculateCandies(_ mid: Int, _ prices: [Int],_ k: Int) -> Bool{\\n    var i = 0\\n    var len = 1\\n    for j in 1..<prices.count{\\n        if prices[j] - prices[i] >= mid{\\n            len += 1\\n            i = j\\n        }\\n    }\\n    if len>=k{\\n        return true\\n    }\\n    return false\\n}\\n\\n\\nfunc maximumTastiness(_ price: [Int], _ k: Int) -> Int {\\n    var price = price.sorted()\\n    var length = price.count\\n    var left = 0\\n    var right = price[length-1] - price[0]\\n    var ans = 0\\n    while left <= right{\\n        var mid =  left + (right-left)/2\\n        var validValue = calculateCandies(mid, price,k)\\n        if validValue{\\n            ans = mid\\n            left = mid + 1\\n        }else{\\n            right = mid - 1\\n        }\\n    }\\n    return ans\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func calculateCandies(_ mid: Int, _ prices: [Int],_ k: Int) -> Bool{\\n    var i = 0\\n    var len = 1\\n    for j in 1..<prices.count{\\n        if prices[j] - prices[i] >= mid{\\n            len += 1\\n            i = j\\n        }\\n    }\\n    if len>=k{\\n        return true\\n    }\\n    return false\\n}\\n\\n\\nfunc maximumTastiness(_ price: [Int], _ k: Int) -> Int {\\n    var price = price.sorted()\\n    var length = price.count\\n    var left = 0\\n    var right = price[length-1] - price[0]\\n    var ans = 0\\n    while left <= right{\\n        var mid =  left + (right-left)/2\\n        var validValue = calculateCandies(mid, price,k)\\n        if validValue{\\n            ans = mid\\n            left = mid + 1\\n        }else{\\n            right = mid - 1\\n        }\\n    }\\n    return ans\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966460,
                "title": "binary-search-solution",
                "content": "# Intuition\\nBased on aggresive cows using binary search\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&price,int k,int dis){\\n        int cnt=1,cur=price[0];\\n        for(int i=1;i<price.size();i++){\\n            if(price[i]-cur>=dis){\\n                cnt++;cur=price[i];\\n            }\\n            if(cnt==k)return true;\\n        }\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        int l=0,h=price.back()-price[0];\\n        int ans=1;\\n        while(l<=h){\\n            int mid=l+((h-l)/2);\\n            if(check(price,k,mid))\\n            { l=mid+1;ans=mid;}\\n            else\\n                h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&price,int k,int dis){\\n        int cnt=1,cur=price[0];\\n        for(int i=1;i<price.size();i++){\\n            if(price[i]-cur>=dis){\\n                cnt++;cur=price[i];\\n            }\\n            if(cnt==k)return true;\\n        }\\n        return false;\\n    }\\n    int maximumTastiness(vector<int>& price, int k) {\\n        sort(price.begin(),price.end());\\n        int l=0,h=price.back()-price[0];\\n        int ans=1;\\n        while(l<=h){\\n            int mid=l+((h-l)/2);\\n            if(check(price,k,mid))\\n            { l=mid+1;ans=mid;}\\n            else\\n                h=mid-1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965595,
                "title": "binary-search",
                "content": "lets assume if we find maximum difference is 5 then we dont need to check for less than 5 so we shift our range on right side means greater than 5\\nTC -> O(nlog(n))\\nSC -> O(1)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool valid(vector<int>&a,int diff,int k)\\n    {\\n        int cnt =1;\\n        int  prev_value = a[0];\\n        for(int i=1;i<a.size();i++){\\n            if((a[i]-prev_value)>=diff){\\n                prev_value = a[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n    int maximumTastiness(vector<int>& a, int k) {\\n        sort(a.begin(),a.end());\\n        int l =0,r = a.back()-a[0];\\n        while(l<=r){\\n           int mid =  (l+r)/2;\\n            if(valid(a,mid,k)){\\n                \\n                l =mid+1;\\n            }\\n            else r =mid-1;\\n        }\\n        return l-1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(vector<int>&a,int diff,int k)\\n    {\\n        int cnt =1;\\n        int  prev_value = a[0];\\n        for(int i=1;i<a.size();i++){\\n            if((a[i]-prev_value)>=diff){\\n                prev_value = a[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt>=k;\\n    }\\n    int maximumTastiness(vector<int>& a, int k) {\\n        sort(a.begin(),a.end());\\n        int l =0,r = a.back()-a[0];\\n        while(l<=r){\\n           int mid =  (l+r)/2;\\n            if(valid(a,mid,k)){\\n                \\n                l =mid+1;\\n            }\\n            else r =mid-1;\\n        }\\n        return l-1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1727559,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1727476,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1727664,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1745573,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1775508,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1858506,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1739665,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1873797,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1787287,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1992785,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1727559,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1727476,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1727664,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1745573,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1775508,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1858506,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1739665,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1873797,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1787287,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            },
            {
                "id": 1992785,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "the description should be more clear!!"
                    },
                    {
                        "username": "kit_kat123",
                        "content": "I think the description is enough clear to understand. I think you need to just read the problem twice and thrice   & you will really get to know about the beauty of this problem. It a great problem based on binary search."
                    },
                    {
                        "username": "deepak130797",
                        "content": "Didn\\'t understand the question how they pick a groups [13,5,21]"
                    },
                    {
                        "username": "kormulev",
                        "content": "[@yeedaKing](/yeedaKing) not, as you have to return min([13, 1, 21]) which is still 8."
                    },
                    {
                        "username": "sammy-timalsina",
                        "content": "[@yeedaKing](/yeedaKing) No, this would still give you same ans because of this Min( Abs(13-1), Abs(13-21),Abs (1-21)) which is min(11,8,20) => 8."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "[@polyp](/polyp) If that\\'s the case, how come the answer isn\\'t [13, 1, 21]?  Wouldn\\'t this yield a greater difference?"
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price.\\n\\nFor the basket with items [13,5,21] the smallest price difference we can find is 8 (21-13 or 13-5) and there is no other combination of items that yields a higher value than 8."
                    },
                    {
                        "username": "_SID_",
                        "content": "we can pick any element one by one and group the elements such that the size of group is \"k\"...like wise we can form many groups... out of all groups we have to return max(min(diffs))"
                    },
                    {
                        "username": "Susheel4115",
                        "content": "Who wrote this probelm?\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21\\uD83D\\uDE21"
                    },
                    {
                        "username": "sepac",
                        "content": "Very unclear. "
                    },
                    {
                        "username": "piyuzh",
                        "content": "bro what does this even mean"
                    },
                    {
                        "username": "ui20ec21",
                        "content": "Agressive Cows\\n"
                    },
                    {
                        "username": "acmmisha",
                        "content": "Yeah, and magnetic force ))"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "Can someone share any link/post which explains the intuition behind this problem?\n\nWould be great if the explanation begins from a naive solution and move towards efficient ones."
                    },
                    {
                        "username": "Noob_SWEbot",
                        "content": "\"The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket\" is rather misleading (ambiguous at best). It implies that the answer involves just finding the two elements with the largest difference. You cannot as that would be incorrect because then that difference would not be the smallest in the basket. \\n\\nYou have a basket of K candies. You want to find the largest possible difference of any two candies where this difference is smaller than ALL the other differences (all the other pairs of candies) in the basket.\\n\\nSay you have a basket that looks like [x, y, z] and the answer is x - y, then x - y must be less than y - z and x - z (i.e. |x - y|  <  |y - z| and |x - y|  <  |x - z|). What you are trying to do is maximize x - y while keeping it less than y - z and x - z. \\n\\nHope this helps!"
                    },
                    {
                        "username": "mas15",
                        "content": "Makes no sense, for the 1st example answer should be (1, 2, 5) what gives us diffs of (1, 4, 3) and the result is 4"
                    },
                    {
                        "username": "maximgrafin",
                        "content": "`8` is testier than `4`."
                    },
                    {
                        "username": "polyp",
                        "content": "We want to find baskets with k items such that the smallest difference we can find in the basket is maximized. In other words, we want the prices of the items in the basket to be \"spread out\" so that it is hard to find two items that are close in price. Hope that helps."
                    },
                    {
                        "username": "ronitroushan21102",
                        "content": "We just need to sort the array and apply the same logic as aggressive cows .\\nhttps://youtu.be/R_Mfw4ew-Vo\\nThis whole binary search playlist is gem I am able to solve this problem without looking into discussion."
                    }
                ]
            }
        ]
    }
]