[
    {
        "title": "Time Needed to Rearrange a Binary String",
        "question_content": "You are given a binary string s. In one second, all occurrences of \"01\" are simultaneously replaced with \"10\". This process repeats until no occurrences of \"01\" exist.\nReturn the number of seconds needed to complete this process.\n&nbsp;\nExample 1:\n\nInput: s = \"0110101\"\nOutput: 4\nExplanation: \nAfter one second, s becomes \"1011010\".\nAfter another second, s becomes \"1101100\".\nAfter the third second, s becomes \"1110100\".\nAfter the fourth second, s becomes \"1111000\".\nNo occurrence of \"01\" exists any longer, and the process needed 4 seconds to complete,\nso we return 4.\n\nExample 2:\n\nInput: s = \"11100\"\nOutput: 0\nExplanation:\nNo occurrence of \"01\" exists in s, and the processes needed 0 seconds to complete,\nso we return 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 1000\n\ts[i] is either '0' or '1'.\n\n&nbsp;\nFollow up:\nCan you solve this problem in O(n) time complexity?",
        "solutions": [
            {
                "id": 2454262,
                "title": "dp-vs-brute-force",
                "content": "DP is O(n) but could be tricky to figure out; Brute-Force is good enough for the contest since `n <= 1,000`.\\n\\n#### DP\\n\\nWe count \"zeros\" so far. If we have a string `00001`, we need `4` seconds (as we have `4` zeros) to make it `10000`.\\n\\nWe also track `seconds` we need to rearrange first `i` letters.\\n\\nIf `i + 1` letter is `1`, we need at least `seconds + 1` seconds, but not less than `zero` seconds.\\n\\nHere is calculation for the `\"100111110001000001\"` test case:\\n- For `i == 11` (yellow), the result is `7` as we need `6` seconds for `i - 1`.\\n- For `i == 17` (green), the result is `10` as we have `10` zeros, even though we need `7` seconds for `i - 1`.\\n\\n![image](https://assets.leetcode.com/users/images/c15cc22e-885f-47ab-8f67-4225cb40525c_1661020625.9402463.png)\\n\\n**Java**\\n```java\\npublic int secondsToRemoveOccurrences(String s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.length(); ++i) {\\n        zeros += s.charAt(i) == \\'0\\' ? 1 : 0;\\n        if (s.charAt(i) == \\'1\\' && zeros > 0)\\n            seconds = Math.max(seconds + 1, zeros);\\n    }\\n    return seconds;        \\n}\\n```\\n**C++**\\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        zeros += s[i] == \\'0\\';\\n        if (s[i] == \\'1\\' && zeros)\\n            seconds = max(seconds + 1, zeros);\\n    }\\n    return seconds;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n)\\n- Memory: O(1)\\n\\n#### Brute-Force\\n**C++**\\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int seconds = 0, changed = true;\\n    while(changed) {\\n        changed = false;\\n        for (int i = 0; i < s.size() - 1; ++i) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                swap(s[i], s[i + 1]);\\n                ++i;\\n                changed = true;\\n            }\\n        }\\n        seconds += changed;\\n    }\\n    return seconds;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n * n) - OK for n <= 1,000. We process `n` characters in the string `n` times in the worst case (`0111...1`).\\n- Memory: O(n) to store an interim string.",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int secondsToRemoveOccurrences(String s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.length(); ++i) {\\n        zeros += s.charAt(i) == \\'0\\' ? 1 : 0;\\n        if (s.charAt(i) == \\'1\\' && zeros > 0)\\n            seconds = Math.max(seconds + 1, zeros);\\n    }\\n    return seconds;        \\n}\\n```\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        zeros += s[i] == \\'0\\';\\n        if (s[i] == \\'1\\' && zeros)\\n            seconds = max(seconds + 1, zeros);\\n    }\\n    return seconds;\\n}\\n```\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int seconds = 0, changed = true;\\n    while(changed) {\\n        changed = false;\\n        for (int i = 0; i < s.size() - 1; ++i) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                swap(s[i], s[i + 1]);\\n                ++i;\\n                changed = true;\\n            }\\n        }\\n        seconds += changed;\\n    }\\n    return seconds;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454884,
                "title": "no-dp-o-n-time-o-1-space",
                "content": "First off, the final string will be of the form 1111....000.... \\n\\nOne observation is that since a \\'1\\' has to be swapped with every occurence of \\'0\\' to its left, the time taken for that \\'1\\' to reach its final position is atleast the number of zeroes to its left.\\n\\nWhy is it not equal to number of \\'0\\'s to its left ?\\nIn a testcase like \\'011\\' -> \\'101\\' -> \\'110\\', the second \\'1\\' had to wait for the first \\'1\\' in the first turn. \\n\\nThe total number of time taken for a \\'1\\' to reach its final position is number of \\'0\\'s to its left + number of turns it waits.\\n\\nEvery time we come across two consequetive ones, the waiting time increases by one.\\n\\nAnd everytime we come acress two consequetive zeroes, the waiting time decreases by one.\\n( consider 0 1 1 0 0 1  The waiting time for the first \\'1\\' is 0, for the second \\'1\\' is 1 , but for the third \\'1\\' is again 0, because while the second \\'1\\' was waiting, the third \\'1\\' would not waste a turn by moving through the zeroes before it.)\\n\\nAlso, it is obvious that the last occurence of a \\'1\\' is the one that will reach its destination the last. \\nSo we just have to find the number of zeroes to the left of it + its waiting time\\n\\nPython:\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = zeroCount = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\t\\t\\t# increase waiting time if we come across 2 conseq 1\\'s\\n\\t\\t\\t# however, if there are no zeroes to the left, then there is no waiting time\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and zeroCount > 0:\\n                waitingTime += 1\\n            \\n\\t\\t\\t# decrease waiting time if we come across 2 conseq 0\\'s\\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                zeroCount += 1\\n                \\n        return zeroCount + waitingTime\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = zeroCount = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\t\\t\\t# increase waiting time if we come across 2 conseq 1\\'s\\n\\t\\t\\t# however, if there are no zeroes to the left, then there is no waiting time\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and zeroCount > 0:\\n                waitingTime += 1\\n            \\n\\t\\t\\t# decrease waiting time if we come across 2 conseq 0\\'s\\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                zeroCount += 1\\n                \\n        return zeroCount + waitingTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454195,
                "title": "python3-o-n-dp-approach",
                "content": "Please pull this git [commit](https://github.com/gaosanyong/leetcode/commit/e999ea07dc2ea2e8b7aad97696f67a3b965e496d) for solutions of biweekly 85. \\n\\n**Intuition**\\nGiven the size of the problem, it is okay to run a simulation which takes `O(N^2)` to complete. However, a faster `O(N)` DP approach is available. \\nHere, we consider the task as \"moving 1s to the left\". Two key observatoins are \\n1) to move \\'1\\' at `i`th index it takes at least x steps if there are x \\'0\\'s preceeding it. \\n2) if there is a \\'1\\' at \\'i-1\\'st index, it takes at least one more step to move this \\'1\\' to proper position. \\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(1)`\\n```\\nclass Solution: \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = prefix = prev = 0 \\n        for i, ch in enumerate(s): \\n            if ch == \\'1\\': \\n                ans = max(prev, i - prefix)\\n                prefix += 1\\n                if ans: prev = ans+1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = prefix = prev = 0 \\n        for i, ch in enumerate(s): \\n            if ch == \\'1\\': \\n                ans = max(prev, i - prefix)\\n                prefix += 1\\n                if ans: prev = ans+1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454526,
                "title": "java-3-lines-easy-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454176,
                "title": "c-brute-force-with-explanation",
                "content": "Upvote if it helps :)\\n```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int one = count(s.begin(), s.end(), \\'1\\');\\n        int i = 0;\\n        int swap = 0;\\n        while(one){//place a \\'1\\' at the index i and reduce one\\'s count and increase i, and place another \\'1\\' there and so on, till there is no \\'one\\' left\\n            if(s[i] == \\'1\\'){ //if i\\'th index has already \\'1\\', then reduce one\\'s count and update i to next index\\n                one--;\\n                i++;\\n            }else{//swap all possible \"01\" to \"10\" and increase swap count, don\\'t reduce one\\'s count, casue we don\\'t know s[i] == \\'1\\' or not\\n                for(int j = i; j < n-1; j++){\\n                    if(s[j] == \\'0\\' && s[j+1] == \\'1\\'){\\n                        s[j] = \\'1\\';\\n                        s[j+1] = \\'0\\';\\n                        j++;\\n                    }\\n                }\\n                swap++;\\n            }\\n        }\\n        return swap;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int one = count(s.begin(), s.end(), \\'1\\');\\n        int i = 0;\\n        int swap = 0;\\n        while(one){//place a \\'1\\' at the index i and reduce one\\'s count and increase i, and place another \\'1\\' there and so on, till there is no \\'one\\' left\\n            if(s[i] == \\'1\\'){ //if i\\'th index has already \\'1\\', then reduce one\\'s count and update i to next index\\n                one--;\\n                i++;\\n            }else{//swap all possible \"01\" to \"10\" and increase swap count, don\\'t reduce one\\'s count, casue we don\\'t know s[i] == \\'1\\' or not\\n                for(int j = i; j < n-1; j++){\\n                    if(s[j] == \\'0\\' && s[j+1] == \\'1\\'){\\n                        s[j] = \\'1\\';\\n                        s[j+1] = \\'0\\';\\n                        j++;\\n                    }\\n                }\\n                swap++;\\n            }\\n        }\\n        return swap;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454424,
                "title": "python-easy-approach-replace-5-lines",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n\\n        ans = 0\\n\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n\\n        ans = 0\\n\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454160,
                "title": "easy-understanding-python",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        cnt = 0\\n        while (\\'01\\' in s):\\n            s = s.replace(\\'01\\', \\'10\\')\\n            cnt += 1\\n        return cnt\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        cnt = 0\\n        while (\\'01\\' in s):\\n            s = s.replace(\\'01\\', \\'10\\')\\n            cnt += 1\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454388,
                "title": "c-straightforward-easy-short",
                "content": "![image](https://assets.leetcode.com/users/images/bc6076ed-f081-429f-a169-c78f621230f4_1661011671.1091099.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint secondsToRemoveOccurrences(string s) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tbool flag=false;\\n\\t\\t\\t\\tfor(int j=0;j<n-1;j++){\\n\\t\\t\\t\\t\\tif(s[j]==\\'0\\' && s[j+1]==\\'1\\'){\\n\\t\\t\\t\\t\\t\\ts[j]=\\'1\\';\\n\\t\\t\\t\\t\\t\\ts[j+1]=\\'0\\';\\n\\t\\t\\t\\t\\t\\tflag=true;\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(flag) count++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint secondsToRemoveOccurrences(string s) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tbool flag=false;\\n\\t\\t\\t\\tfor(int j=0;j<n-1;j++){\\n\\t\\t\\t\\t\\tif(s[j]==\\'0\\' && s[j+1]==\\'1\\'){\\n\\t\\t\\t\\t\\t\\ts[j]=\\'1\\';\\n\\t\\t\\t\\t\\t\\ts[j+1]=\\'0\\';\\n\\t\\t\\t\\t\\t\\tflag=true;\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2467821,
                "title": "c-two-loop-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int t = 0;\\n        int n = s.size();\\n        if(n == 1) return 0;\\n        \\n        while(true){\\n            bool flag = false;\\n            int i=1;\\n            while(i < n){\\n                if(s[i-1] == \\'0\\' && s[i] == \\'1\\'){\\n                    s[i-1] = \\'1\\' , s[i] = \\'0\\';\\n                    i = i+2;\\n                    flag = true;\\n                }\\n                else i++;\\n            }\\n            if(flag == false) break;\\n            t++;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int t = 0;\\n        int n = s.size();\\n        if(n == 1) return 0;\\n        \\n        while(true){\\n            bool flag = false;\\n            int i=1;\\n            while(i < n){\\n                if(s[i-1] == \\'0\\' && s[i] == \\'1\\'){\\n                    s[i-1] = \\'1\\' , s[i] = \\'0\\';\\n                    i = i+2;\\n                    flag = true;\\n                }\\n                else i++;\\n            }\\n            if(flag == false) break;\\n            t++;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488547,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans=0;\\n        \\n        while(s.indexOf(\"01\")!=-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans=0;\\n        \\n        while(s.indexOf(\"01\")!=-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454162,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int count=0;                       // counter for counting the operations\\n        int flag=1;                        // declare a flag value for check we have 01 pair or not\\n        int n=s.length();\\n        \\n        // while we still have pair\\n        while(flag==1)\\n        {\\n            // check from start to end\\n            for(int i=0;i<n-1;i++)\\n            { \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\')              // if we our pair then just swap it move i to next value and make flag 0 that will show we have pair 01\\n                {\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                    flag=0;\\n                }\\n            }\\n            \\n            flag = 1-flag;                                // update flag\\n            count++;                                      // make operations count+1\\n        }\\n        \\n        return (count-1);                                 // return count-1 because at the last call when we will not find pair although count will increase by one while eding the loop\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int count=0;                       // counter for counting the operations\\n        int flag=1;                        // declare a flag value for check we have 01 pair or not\\n        int n=s.length();\\n        \\n        // while we still have pair\\n        while(flag==1)\\n        {\\n            // check from start to end\\n            for(int i=0;i<n-1;i++)\\n            { \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\')              // if we our pair then just swap it move i to next value and make flag 0 that will show we have pair 01\\n                {\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                    flag=0;\\n                }\\n            }\\n            \\n            flag = 1-flag;                                // update flag\\n            count++;                                      // make operations count+1\\n        }\\n        \\n        return (count-1);                                 // return count-1 because at the last call when we will not find pair although count will increase by one while eding the loop\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467165,
                "title": "leetcode-the-hard-way-brute-force-approach-with-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), need = 1, ans = 0;\\n        // bruce force approach as n <= 1000\\n        while (need) {\\n            // unset need\\n            need = 0;\\n            // iterate the string\\n            for (int i = 1; i < n; i++) {\\n                // check if there is 01\\n                if (s[i - 1] == \\'0\\' && s[i] == \\'1\\') {\\n                    // if so, swap them to become 10\\n                    swap(s[i], s[i - 1]);\\n                    // skip this character\\n                    i += 1;\\n                    // after swapping, it could possibly produce another 01\\n                    // hence set it to 1\\n                    need = 1;\\n                }                \\n            }\\n            // if we swapped it, then we need 1 second for the action\\n            ans += need;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), need = 1, ans = 0;\\n        // bruce force approach as n <= 1000\\n        while (need) {\\n            // unset need\\n            need = 0;\\n            // iterate the string\\n            for (int i = 1; i < n; i++) {\\n                // check if there is 01\\n                if (s[i - 1] == \\'0\\' && s[i] == \\'1\\') {\\n                    // if so, swap them to become 10\\n                    swap(s[i], s[i - 1]);\\n                    // skip this character\\n                    i += 1;\\n                    // after swapping, it could possibly produce another 01\\n                    // hence set it to 1\\n                    need = 1;\\n                }                \\n            }\\n            // if we swapped it, then we need 1 second for the action\\n            ans += need;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458917,
                "title": "explanation-python-c-simple-and-concise-code",
                "content": "Intituion:\\nWe do the operation untill all the \\'1\\'s and \\'0\\'s are separated and take the count.\\n\\n\\n*  **C++** \\n```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), ans = 0;\\n        while(s.find(\"01\") != string::npos){   // iterate till a \\'01\\' is present, * string::npos is same as s.end()\\n            for(int i=0;i<n-1;i++){\\n                if(s.substr(i,2)==\"01\"){\\n                    swap(s[i],s[i+1]);             // change \\'01\\' to \\'10\\'\\n                    i++;                        // we increase the i since when \\'01\\' changed to \\'10\\' we can\\'t again swap this if there a \\'1\\' present after this \\'0\\'\\n                 }\\n            }\\n            ans++;          // for every loop we add 1 to ans \\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n* **Python**\\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = 0\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n\\t\\t\\t\\n        return ans\\n```\\n\\nAppriciate an upvote...",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), ans = 0;\\n        while(s.find(\"01\") != string::npos){   // iterate till a \\'01\\' is present, * string::npos is same as s.end()\\n            for(int i=0;i<n-1;i++){\\n                if(s.substr(i,2)==\"01\"){\\n                    swap(s[i],s[i+1]);             // change \\'01\\' to \\'10\\'\\n                    i++;                        // we increase the i since when \\'01\\' changed to \\'10\\' we can\\'t again swap this if there a \\'1\\' present after this \\'0\\'\\n                 }\\n            }\\n            ans++;          // for every loop we add 1 to ans \\n        }\\n        return ans;\\n    }\\n```\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = 0\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2795812,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s):\\n        total = zeros = 0\\n\\n        for i in range(len(s)):\\n            zeros += 1 if s[i] == \"0\" else 0\\n\\n            if s[i] == \"1\" and zeros:\\n                total = max(total+1,zeros)\\n\\n        return total\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s):\\n        total = zeros = 0\\n\\n        for i in range(len(s)):\\n            zeros += 1 if s[i] == \"0\" else 0\\n\\n            if s[i] == \"1\" and zeros:\\n                total = max(total+1,zeros)\\n\\n        return total\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458535,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-5-line-solution-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q2380. Time Needed to Rearrange a Binary String***\\nYou are given a binary string s. In one second, all occurrences of `\"01\"` are simultaneously replaced with `\"10\"`. This process repeats until no occurrences of `\"01\"` exist.\\n\\nReturn the number of seconds needed to complete this process.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans=0\\n        while \\'01\\' in s:\\n            ans+=1\\n            s=s.replace(\\'01\\',\\'10\\')\\n        return ans\\n```\\n**Runtime:**  139 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Runtime:**  338 ms\\t\\t\\n**Memory Usage:**  114.8 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bool flag=false;\\n            for(int j=0;j<n-1;j++)\\n            {\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\')\\n                {\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Runtime:** 129 ms\\t\\n**Memory Usage:**  5.9 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans=0\\n        while \\'01\\' in s:\\n            ans+=1\\n            s=s.replace(\\'01\\',\\'10\\')\\n        return ans\\n```\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bool flag=false;\\n            for(int j=0;j<n-1;j++)\\n            {\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\')\\n                {\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454989,
                "title": "my-dp-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        vector<int>zerocnt;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\')\\n                cnt++;\\n            zerocnt.push_back(cnt);\\n        }\\n      \\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\' && zerocnt[i]){\\n                sum = max(sum + 1, zerocnt[i]);\\n            }\\n        }\\n      \\n        \\n        return sum;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        vector<int>zerocnt;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\')\\n                cnt++;\\n            zerocnt.push_back(cnt);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3684059,
                "title": "simple-recursive-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimulate the process until there is at least 1 swap.\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string &s)\\n    {\\n        int i = 1,n = s.size(),fleg = 1;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\' && s[i-1]==\\'0\\')\\n            {\\n                swap(s[i],s[i-1]);\\n                fleg = 0;\\n                i+=2;\\n            }\\n            else\\n            i+=1;\\n        }\\n        if(fleg) return 0;\\n        return 1+solve(s);\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        return solve(s);\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/9d11b9c5-0846-4f56-b069-b501a37463f4_1687765172.989497.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string &s)\\n    {\\n        int i = 1,n = s.size(),fleg = 1;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\' && s[i-1]==\\'0\\')\\n            {\\n                swap(s[i],s[i-1]);\\n                fleg = 0;\\n                i+=2;\\n            }\\n            else\\n            i+=1;\\n        }\\n        if(fleg) return 0;\\n        return 1+solve(s);\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        return solve(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439289,
                "title": "c-very-easy-solution-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int n=s.length();\\n        int flag=1;\\n        int cc=0;\\n        while(1){\\n            flag=1;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i]=\\'1\\';\\n                    s[i+1]=\\'0\\';\\n                    i++;\\n                    flag=0;\\n\\n                }\\n\\n            }\\n            \\n            if(flag==1){\\n                break;\\n            }\\n            cc++;\\n        }\\n        return cc;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int n=s.length();\\n        int flag=1;\\n        int cc=0;\\n        while(1){\\n            flag=1;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i]=\\'1\\';\\n                    s[i+1]=\\'0\\';\\n                    i++;\\n                    flag=0;\\n\\n                }\\n\\n            }\\n            \\n            if(flag==1){\\n                break;\\n            }\\n            cc++;\\n        }\\n        return cc;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163010,
                "title": "brute-force-c-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0;int st=0;int n=s.length();bool flag=false;\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\'){swap(s[j],s[j+1]);j++;flag=true;}\\n            }\\n            if(flag==false){return i;}flag=false;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0;int st=0;int n=s.length();bool flag=false;\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\'){swap(s[j],s[j+1]);j++;flag=true;}\\n            }\\n            if(flag==false){return i;}flag=false;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032709,
                "title": "queue-solution",
                "content": "# Intuition\\nIdea come from that we can perform some operation and put it to the queue for the next iteration on it ( checking the number of swaps) and so on\\n\\n# Approach\\nInit queue and push the giving string. Start process of swap and push it again the queue\\n\\n# Complexity\\n- Time complexity:\\nO(N) * O(K), where the N is the length of string and K the number of \"seconds\"\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Deque<StringBuilder> queue = new ArrayDeque();\\n        int ans = 0;\\n        queue.addLast(new StringBuilder(s));\\n\\n        while (!queue.isEmpty()){\\n            StringBuilder poped = queue.pollFirst();\\n            boolean isChange = false;\\n            for (int i=0; i<poped.length()-1; i++){\\n                if (poped.charAt(i)==\\'0\\' && poped.charAt(i+1)==\\'1\\'){\\n                    isChange = true;\\n                    poped.setCharAt(i,\\'1\\');\\n                    poped.setCharAt(i+1,\\'0\\');\\n                    i++;\\n                }\\n            }\\n\\n            if (isChange) {\\n                \\n                queue.addLast(poped);\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Deque<StringBuilder> queue = new ArrayDeque();\\n        int ans = 0;\\n        queue.addLast(new StringBuilder(s));\\n\\n        while (!queue.isEmpty()){\\n            StringBuilder poped = queue.pollFirst();\\n            boolean isChange = false;\\n            for (int i=0; i<poped.length()-1; i++){\\n                if (poped.charAt(i)==\\'0\\' && poped.charAt(i+1)==\\'1\\'){\\n                    isChange = true;\\n                    poped.setCharAt(i,\\'1\\');\\n                    poped.setCharAt(i+1,\\'0\\');\\n                    i++;\\n                }\\n            }\\n\\n            if (isChange) {\\n                \\n                queue.addLast(poped);\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676981,
                "title": "brute-force-approach-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        int idx=0;\\n        while(idx<s.length())\\n        {\\n            if(idx<s.length() and s[idx]==\\'0\\' and s[idx+1]==\\'1\\')\\n            {\\n                count++;\\n                swap(s[idx],s[idx+1]);\\n                idx+=2;\\n            }\\n            else\\n            {\\n                idx++;\\n            }\\n        }\\n        if(count==0)\\n        {\\n            return 0;\\n        }\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        int idx=0;\\n        while(idx<s.length())\\n        {\\n            if(idx<s.length() and s[idx]==\\'0\\' and s[idx+1]==\\'1\\')\\n            {\\n                count++;\\n                swap(s[idx],s[idx+1]);\\n                idx+=2;\\n            }\\n            else\\n            {\\n                idx++;\\n            }\\n        }\\n        if(count==0)\\n        {\\n            return 0;\\n        }\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585925,
                "title": "java-no-dp-o-n-time-o-1-space-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) \\n    {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) \\n    {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489509,
                "title": "single-pass-with-explanation",
                "content": "`jth` \"1\" at index `i` will take at a minimum `i-j` moves to reach `jth` index.\\nFirst incorrectly placed \\'1\\' will take `i-0` steps\\nIf the next \"1\" was right next to it, then it will have to wait a round. To extend it further, each \"1\" will take either `j-i` moves or it will take as many moves as the previous \"1\" takes + 1\\n\\nIf the ones are at indexes [1, 2], then `j-i` for both are [1-0, 2-1]. However, since the first one takes 1 move which is equal to the number of moves taken by the second \"1\", it means that the second \"1\" will have to wait a turn.\\n\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        j = 0\\n        for i, e in enumerate(s):\\n            if e == \\'0\\':\\n                continue\\n            if count >= i-j and count != 0:\\n                count += 1\\n            else:\\n                count = i-j\\n            j +=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        j = 0\\n        for i, e in enumerate(s):\\n            if e == \\'0\\':\\n                continue\\n            if count >= i-j and count != 0:\\n                count += 1\\n            else:\\n                count = i-j\\n            j +=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457959,
                "title": "3-lines-of-code-easy-and-simple-c-java",
                "content": "**Time Needed to Rearrange a Binary String Solution :**\\n.\\n.\\n**In Java :**\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans = 0;\\n        while(s.contains(\"01\")){\\n            s = s.replaceAll(\"01\", \"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**In C++ :**\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0,check=1;\\n        while(check){\\n            check=0;\\n\\t\\t\\tfor(int i=1;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'1\\' && s[i-1]==\\'0\\'){\\n\\t\\t\\t\\t\\tswap(s[i],s[i-1]);\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tcheck=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            cnt++;\\n        }\\n        return cnt-1;\\n    }\\n};\\n```\\n.\\n.\\n.\\n**Happy Coding** \\uD83D\\uDE0A!!!\\nIf you get value from this, then show some love by ***upvoting*** it !!\\n\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans = 0;\\n        while(s.contains(\"01\")){\\n            s = s.replaceAll(\"01\", \"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0,check=1;\\n        while(check){\\n            check=0;\\n\\t\\t\\tfor(int i=1;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'1\\' && s[i-1]==\\'0\\'){\\n\\t\\t\\t\\t\\tswap(s[i],s[i-1]);\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tcheck=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            cnt++;\\n        }\\n        return cnt-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457634,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Brute Force***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string str) {\\n        \\n        int n = str.size();\\n        \\n        int time = 0;\\n        \\n        while(true)\\n        {\\n            // flag will keep track of is there any \"01\" pair in str or not\\n            \\n            bool flag = false;\\n            \\n            for(int i = 0; i < n - 1;)\\n            {\\n                // if there is \"01\" pair\\n                \\n                if(str[i] == \\'0\\' && str[i + 1] == \\'1\\')\\n                {\\n                    str[i] = \\'1\\';\\n                    \\n                    str[i + 1] = \\'0\\';\\n\\n                    flag = true;\\n                    \\n                    i += 2;\\n                }\\n                \\n                else\\n                    i++;\\n            }\\n            \\n            // flag == false, means there is not any \"01\" pair in str, return time\\n            \\n            if(flag == false)\\n                return time;\\n            else\\n                time++;\\n        }\\n        \\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string str) {\\n        \\n        int n = str.size();\\n        \\n        int time = 0;\\n        \\n        while(true)\\n        {\\n            // flag will keep track of is there any \"01\" pair in str or not\\n            \\n            bool flag = false;\\n            \\n            for(int i = 0; i < n - 1;)\\n            {\\n                // if there is \"01\" pair\\n                \\n                if(str[i] == \\'0\\' && str[i + 1] == \\'1\\')\\n                {\\n                    str[i] = \\'1\\';\\n                    \\n                    str[i + 1] = \\'0\\';\\n\\n                    flag = true;\\n                    \\n                    i += 2;\\n                }\\n                \\n                else\\n                    i++;\\n            }\\n            \\n            // flag == false, means there is not any \"01\" pair in str, return time\\n            \\n            if(flag == false)\\n                return time;\\n            else\\n                time++;\\n        }\\n        \\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456398,
                "title": "beginner-friendly-java-javascript-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    int count = -1;\\n    public int secondsToRemoveOccurrences(String s) {\\n        count++;\\n        StringBuilder str = new StringBuilder();\\n        boolean isvalid = true;\\n        for(int i=0; i<s.length(); i++){\\n            if(i < s.length()-1 && s.charAt(i) < s.charAt(i+1)){\\n                isvalid = false;\\n                str.append(s.charAt(i+1));\\n                str.append(s.charAt(i));\\n                i++;\\n            }else if(i < s.length()){\\n                str.append(s.charAt(i));\\n            }\\n        }\\n        return isvalid == true ? count : secondsToRemoveOccurrences(str.toString());\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar secondsToRemoveOccurrences = function(s) {\\n    let cnt = -1\\n    \\n    function count(s){\\n        cnt++\\n        str = \"\"\\n        let isvalid = true\\n        for(let i=0; i<s.length; i++){\\n            if(i < s.length-1 && s[i] < s[i+1]){\\n                isvalid = false\\n                str += s[i+1]\\n                str += s[i]\\n                i++;\\n            }else if(i < s.length){\\n                str += s[i];\\n            }\\n        }\\n        return isvalid == true ? cnt : count(str);\\n    }\\n    \\n    return count(s)\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    int count = -1;\\n    public int secondsToRemoveOccurrences(String s) {\\n        count++;\\n        StringBuilder str = new StringBuilder();\\n        boolean isvalid = true;\\n        for(int i=0; i<s.length(); i++){\\n            if(i < s.length()-1 && s.charAt(i) < s.charAt(i+1)){\\n                isvalid = false;\\n                str.append(s.charAt(i+1));\\n                str.append(s.charAt(i));\\n                i++;\\n            }else if(i < s.length()){\\n                str.append(s.charAt(i));\\n            }\\n        }\\n        return isvalid == true ? count : secondsToRemoveOccurrences(str.toString());\\n    }\\n}\\n```\n```\\nvar secondsToRemoveOccurrences = function(s) {\\n    let cnt = -1\\n    \\n    function count(s){\\n        cnt++\\n        str = \"\"\\n        let isvalid = true\\n        for(let i=0; i<s.length; i++){\\n            if(i < s.length-1 && s[i] < s[i+1]){\\n                isvalid = false\\n                str += s[i+1]\\n                str += s[i]\\n                i++;\\n            }else if(i < s.length){\\n                str += s[i];\\n            }\\n        }\\n        return isvalid == true ? cnt : count(str);\\n    }\\n    \\n    return count(s)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456280,
                "title": "go-solution",
                "content": "```\\nfunc secondsToRemoveOccurrences(s string) int {\\n    var res int\\n    \\n    for strings.Contains(s, \"01\") {\\n        res++ \\n        s = strings.Replace(s, \"01\", \"10\", -1)\\n    }\\n    \\n    return res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc secondsToRemoveOccurrences(s string) int {\\n    var res int\\n    \\n    for strings.Contains(s, \"01\") {\\n        res++ \\n        s = strings.Replace(s, \"01\", \"10\", -1)\\n    }\\n    \\n    return res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455850,
                "title": "easy-approach-c-no-dp-simple-solution-beginners-friendly",
                "content": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            bool flag=false;\\n            for(int j=0;j<s.size()-1;j++){\\n                if(s[j]==\\'0\\' and s[j+1]==\\'1\\'){\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag==true)\\n                count++;\\n        }\\n        return count;  \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "String"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            bool flag=false;\\n            for(int j=0;j<s.size()-1;j++){\\n                if(s[j]==\\'0\\' and s[j+1]==\\'1\\'){\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag==true)\\n                count++;\\n        }\\n        return count;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455588,
                "title": "c-brute-force-solution-easy-to-understand",
                "content": "```\\nbool check(string& s)       //to check whether the string is in desired form or not\\n{\\n        int n=s.size();\\n        for(int i=1;i<n;i++){\\n            if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n\\t\\tint cnt=0;           //counter\\n        int n=s.size();\\n        if(check(s)){       // if string is already in desired form\\n            return 0;\\n        }\\n        while(!check(s)){      //while string is not in desired form\\n            cnt++;           //increase the count\\n            for(int i=1;i<n;i++)      //look for zeroes and ones together and swap them\\n\\t\\t\\t{\\n                if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                    // cout<<\"yes\"<<endl;\\n                    swap(s[i-1],s[i]);\\n                    i++;    //also increment i by 1 everytime as you can swap and zero and one only once in one operation\\n                }   \\n            }\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool check(string& s)       //to check whether the string is in desired form or not\\n{\\n        int n=s.size();\\n        for(int i=1;i<n;i++){\\n            if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n\\t\\tint cnt=0;           //counter\\n        int n=s.size();\\n        if(check(s)){       // if string is already in desired form\\n            return 0;\\n        }\\n        while(!check(s)){      //while string is not in desired form\\n            cnt++;           //increase the count\\n            for(int i=1;i<n;i++)      //look for zeroes and ones together and swap them\\n\\t\\t\\t{\\n                if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                    // cout<<\"yes\"<<endl;\\n                    swap(s[i-1],s[i]);\\n                    i++;    //also increment i by 1 everytime as you can swap and zero and one only once in one operation\\n                }   \\n            }\\n        }\\n        return cnt;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2454917,
                "title": "easy-o-n-2-brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int x=s.size();\\n        int ans=0;\\n        while(x) {\\n            int y=0;\\n            for(int i=1;i<s.size();i++) {\\n                if (s[i]==\\'1\\' && s[i-1]==\\'0\\') {\\n                    swap(s[i],s[i-1]);\\n                    y++;\\n                    i++;\\n                }\\n            }\\n            if (y) ans++;\\n            x=y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int x=s.size();\\n        int ans=0;\\n        while(x) {\\n            int y=0;\\n            for(int i=1;i<s.size();i++) {\\n                if (s[i]==\\'1\\' && s[i-1]==\\'0\\') {\\n                    swap(s[i],s[i-1]);\\n                    y++;\\n                    i++;\\n                }\\n            }\\n            if (y) ans++;\\n            x=y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454387,
                "title": "no-math-solution",
                "content": "I spent my whole time finding a math solution for this question. Is there any?\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2454358,
                "title": "simple-beginner-friendly-c-solution-o-n-2",
                "content": "**Upvote if You Like**\\n```\\nclass Solution {\\n    bool check(string &s)\\n    {\\n        for(int i = 0; i < s.size()-1; i++)\\n            if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                return true;\\n        return false;\\n    }\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        if(s.size()<2) return 0;\\n        while(check(s))\\n        {\\n            ans++;\\n\\t\\t\\tint i = 0;\\n            while(i <s.size()-1)\\n            {\\n                if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                    s[i] = \\'1\\',s[i+1] = \\'0\\',i+=2;\\n                else\\n                    i++;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool check(string &s)\\n    {\\n        for(int i = 0; i < s.size()-1; i++)\\n            if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                return true;\\n        return false;\\n    }\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        if(s.size()<2) return 0;\\n        while(check(s))\\n        {\\n            ans++;\\n\\t\\t\\tint i = 0;\\n            while(i <s.size()-1)\\n            {\\n                if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                    s[i] = \\'1\\',s[i+1] = \\'0\\',i+=2;\\n                else\\n                    i++;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454340,
                "title": "loop-until-all-ones-placed-at-left-side-and-zeros-places-right-side",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char str_string[]=s.toCharArray();\\n        int ans=0;\\n        \\n        boolean flag_enter=true;\\n        \\n        while(flag_enter){\\n            flag_enter=false;\\n            s=new String(str_string);\\n            for(int i=0; i<s.length()-1; i++){\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\'){  \\n                    flag_enter=true;\\n                    swapChar(str_string,i,i+1);\\n                }\\n            }\\n            if(flag_enter==true) \\n                ans++;\\n        }\\n        return ans;\\n    }\\n    void swapChar(char ch_arr[],int i,int j){\\n        char temp=ch_arr[i];\\n        ch_arr[i]=ch_arr[j];\\n        ch_arr[j]=temp;\\n    }\\n}\\n\\n\\n\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char str_string[]=s.toCharArray();\\n        int ans=0;\\n        \\n        boolean flag_enter=true;\\n        \\n        while(flag_enter){\\n            flag_enter=false;\\n            s=new String(str_string);\\n            for(int i=0; i<s.length()-1; i++){\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\'){  \\n                    flag_enter=true;\\n                    swapChar(str_string,i,i+1);\\n                }\\n            }\\n            if(flag_enter==true) \\n                ans++;\\n        }\\n        return ans;\\n    }\\n    void swapChar(char ch_arr[],int i,int j){\\n        char temp=ch_arr[i];\\n        ch_arr[i]=ch_arr[j];\\n        ch_arr[j]=temp;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454319,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int cnt=0;\\n        int fl=1; //flag helps in checking whether any \"01\" exists or not\\n        \\n        while(fl) \\n        {\\n            fl=1;\\n            for(int i=0; i<s.size(); i++)\\n            {    \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\' && i+1<s.size()) //if \"01\" exists we convert it into \"10\"\\n                {\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                    fl=0;\\n                }    \\n            }\\n            fl = 1-fl; \\n            cnt++; //increase time by 1 unit\\n        }\\n        return cnt-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int cnt=0;\\n        int fl=1; //flag helps in checking whether any \"01\" exists or not\\n        \\n        while(fl) \\n        {\\n            fl=1;\\n            for(int i=0; i<s.size(); i++)\\n            {    \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\' && i+1<s.size()) //if \"01\" exists we convert it into \"10\"\\n                {\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                    fl=0;\\n                }    \\n            }\\n            fl = 1-fl; \\n            cnt++; //increase time by 1 unit\\n        }\\n        return cnt-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454264,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char c[]=s.toCharArray();\\n        int k=0;\\n        while(s.contains(\"01\"))\\n        {\\n            \\n            for(int i=0;i<c.length-1;i++)\\n            {\\n                if(c[i]==\\'0\\' && c[i+1]==\\'1\\')\\n                {\\n                    task(c,i,i+1);\\n                    i++;\\n                }\\n            }\\n            s=String.valueOf(c);\\n            c=s.toCharArray();\\n            k++;\\n        }\\n        return k;\\n    }\\n    public void task(char c[], int i, int j)\\n    {\\n        char d=c[i];\\n        c[i]=c[j];\\n        c[j]=d;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char c[]=s.toCharArray();\\n        int k=0;\\n        while(s.contains(\"01\"))\\n        {\\n            \\n            for(int i=0;i<c.length-1;i++)\\n            {\\n                if(c[i]==\\'0\\' && c[i+1]==\\'1\\')\\n                {\\n                    task(c,i,i+1);\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2454241,
                "title": "python-7-lines",
                "content": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        ans = 0\\n        while s.count(\"01\") > 0 :\\n            s = s.replace(\"01\", \"10\");\\n            ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        ans = 0\\n        while s.count(\"01\") > 0 :\\n            s = s.replace(\"01\", \"10\");\\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454214,
                "title": "c-brute-force-dp-o-n-time",
                "content": "**Method 1: Brute force**\\nTime O(n^2)\\n```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        while (s.Contains(\"01\"))\\n        {\\n            count++;\\n            s = s.Replace(\"01\", \"10\");\\n        }\\n        return count;\\n    }\\n```\\n**Method 2: DP**\\nTime O(n)\\n```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        int zeroCount = 0;\\n        for (int i = 0; i < s.Length; ++i)\\n        {\\n            if (s[i] == \\'0\\')\\n                zeroCount++;\\n            else if (s[i] == \\'1\\' && zeroCount > 0)\\n                count = Math.Max(count + 1, zeroCount);\\n        }\\n        return count;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        while (s.Contains(\"01\"))\\n        {\\n            count++;\\n            s = s.Replace(\"01\", \"10\");\\n        }\\n        return count;\\n    }\\n```\n```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        int zeroCount = 0;\\n        for (int i = 0; i < s.Length; ++i)\\n        {\\n            if (s[i] == \\'0\\')\\n                zeroCount++;\\n            else if (s[i] == \\'1\\' && zeroCount > 0)\\n                count = Math.Max(count + 1, zeroCount);\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3724659,
                "title": "tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n=s.length();\\n        int time=0,zeros=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                zeros++;\\n            }\\n            if(s.charAt(i)==\\'1\\'&&zeros>0)\\n            {\\n                time=Math.max(time+1,zeros);\\n            }\\n\\n\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n=s.length();\\n        int time=0,zeros=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                zeros++;\\n            }\\n            if(s.charAt(i)==\\'1\\'&&zeros>0)\\n            {\\n                time=Math.max(time+1,zeros);\\n            }\\n\\n\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439219,
                "title": "c-very-easy-solution-beginner-friendly",
                "content": "<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int ans = 0;\\n        string temp =\"-1\";\\n        while( true )\\n        {\\n            temp = s;\\n            for( int i=1 ; i<n ; i++ )\\n            {\\n                if( s[i]==\\'1\\' && s[i-1]==\\'0\\' )\\n                {\\n                    s[i]=\\'0\\';\\n                    s[i-1]=\\'1\\';\\n                    i++;\\n                }\\n            }\\n            if( temp==s )\\n            {\\n                break;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int ans = 0;\\n        string temp =\"-1\";\\n        while( true )\\n        {\\n            temp = s;\\n            for( int i=1 ; i<n ; i++ )\\n            {\\n                if( s[i]==\\'1\\' && s[i-1]==\\'0\\' )\\n                {\\n                    s[i]=\\'0\\';\\n                    s[i-1]=\\'1\\';\\n                    i++;\\n                }\\n            }\\n            if( temp==s )\\n            {\\n                break;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253347,
                "title": "python3-easy-with-string-replace",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        count = 0\\n        while \"01\" in s:\\n            s = s.replace(\"01\", \"10\")\\n            count += 1\\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        count = 0\\n        while \"01\" in s:\\n            s = s.replace(\"01\", \"10\")\\n            count += 1\\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930334,
                "title": "runtime-35ms-memory-13-8mb-python-solution",
                "content": "# Approach\\n- The last \"1\" will take the longest time to travel to its destination in the string, which is the number of \"0\"s infront. \\n- The special case is when \"1\" is right next to another \"1\", which will add one more step for the second 1 to move to the right.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        n = len(s)\\n        count, res = 0, 0\\n\\n        for i in range(n):\\n            if (s[i] == \\'0\\'):\\n                count += 1\\n            else:\\n                if count > 0:\\n                    res = max(res+1, count)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        n = len(s)\\n        count, res = 0, 0\\n\\n        for i in range(n):\\n            if (s[i] == \\'0\\'):\\n                count += 1\\n            else:\\n                if count > 0:\\n                    res = max(res+1, count)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864901,
                "title": "simple-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        \\n        int n = s.length();\\n        int zero =0;\\n        int ans =0;\\n        for(int i=0; i< n ; i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zero++;\\n            }else{\\n                if(zero>0)\\n                ans = Math.max(ans+1, zero);\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        \\n        int n = s.length();\\n        int zero =0;\\n        int ans =0;\\n        for(int i=0; i< n ; i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zero++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2677222,
                "title": "python-beginner-easy-81-faster",
                "content": "**Please upvode if it helps...**\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        for i in range(len(s)):\\n            if \"01\" in s:\\n                s=s.replace(\"01\",\"10\")\\n                c+=1\\n        return(c)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        for i in range(len(s)):\\n            if \"01\" in s:\\n                s=s.replace(\"01\",\"10\")\\n                c+=1\\n        return(c)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2675000,
                "title": "brute-force-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool flag=false;\\n    \\n        for(int i=0;i<s.length()-1;)\\n        {\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n            {\\n                flag=true;\\n                swap(s[i],s[i+1]);\\n                i++;\\n                i++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n\\n        if(flag==false)\\n        return 0;\\n\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool flag=false;\\n    \\n        for(int i=0;i<s.length()-1;)\\n        {\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n            {\\n                flag=true;\\n                swap(s[i],s[i+1]);\\n                i++;\\n                i++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n\\n        if(flag==false)\\n        return 0;\\n\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605893,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n = 0;\\n        while(s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++n;\\n        }\\n        return n;\\n    }\\n}\\n```\\nDo upvote if you find helpful !",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n = 0;\\n        while(s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++n;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558947,
                "title": "c-don-t-know-the-time-complexity-simple-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        string s1=s;\\n        int n=s.size();\\n        int seconds=0;\\n        int count=0;\\n        do{\\n            count=0;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    count++;\\n                    s1[i]=\\'1\\';\\n                    s1[i+1]=\\'0\\';\\n                }\\n            }\\n            s=s1;\\n            if(count!=0)\\n                seconds++;\\n        }while(count!=0);\\n        return seconds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        string s1=s;\\n        int n=s.size();\\n        int seconds=0;\\n        int count=0;\\n        do{\\n            count=0;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    count++;\\n                    s1[i]=\\'1\\';\\n                    s1[i+1]=\\'0\\';\\n                }\\n            }\\n            s=s1;\\n            if(count!=0)\\n                seconds++;\\n        }while(count!=0);\\n        return seconds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554095,
                "title": "rust-0-ms-functional-style-one-liner-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/795590438/) employs a functional-style approach to scan the string and count swaps. It demonstrated **0 ms runtime (100%)** and used **2.0 MB memory (83.87%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 \\n    {\\n        s.chars()\\n        // [1] leading \\'1\\'s are irrelevant \\n            .skip_while(|&c| c == \\'1\\')\\n        // [2] while iterating, we keep track of zeros and compute swaps\\n            .fold(\\n                (0,0), |(swaps, zeros), c|\\n        // [3] when we encounter \\'1\\', we conclude that the amount \\n        //     of swaps it requires to travel to left is not less than:\\n        //     - the amount of zeros seen before\\n        //     - the amount of swaps needed for previous \\'1\\'s plus one (if blocked)\\n                match c \\n                {\\n                    \\'1\\' => ((swaps + 1).max(zeros), zeros),\\n                    \\'0\\' => (swaps, zeros + 1),\\n                    _   => unreachable!(\"Wrong symbol {}\", c)\\n                }\\n            ).0 as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 \\n    {\\n        s.chars()\\n        // [1] leading \\'1\\'s are irrelevant \\n            .skip_while(|&c| c == \\'1\\')\\n        // [2] while iterating, we keep track of zeros and compute swaps\\n            .fold(\\n                (0,0), |(swaps, zeros), c|\\n        // [3] when we encounter \\'1\\', we conclude that the amount \\n        //     of swaps it requires to travel to left is not less than:\\n        //     - the amount of zeros seen before\\n        //     - the amount of swaps needed for previous \\'1\\'s plus one (if blocked)\\n                match c \\n                {\\n                    \\'1\\' => ((swaps + 1).max(zeros), zeros),\\n                    \\'0\\' => (swaps, zeros + 1),\\n                    _   => unreachable!(\"Wrong symbol {}\", c)\\n                }\\n            ).0 as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482625,
                "title": "2-appoach-dp-o-n-bruteforce-o-n-n",
                "content": "DP APPROACH\\n\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string a) {\\n        int n=a.size();\\n        int zero=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'0\\')zero++;\\n            else{\\n                if(i>0&&a[i-1]==\\'1\\'&&zero>0)ans++;\\n                else if(i>0&&a[i-1]==\\'0\\'){\\n                    ans=max(ans+1,zero);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nif(a[i]==0)\\n    does nt matter because we are coming from left to right and we have at the end of string till i is 0 and its placed correctly\\nif(a[i]==1){\\n    last = a[i-1]\\n    if(last==1){\\n        if(num of zeres till here are zero){ \\n            then its fine, no increment in answwert answer reamins 0 only because string till here is -> 111...i times\\n        }\\n        else if(numOfZero>0){\\n            then number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till i-1\\n            to know y, dry run the problemStatment for the example 01 and 011.\\n        }\\n    }else if(last==\\'0\\'){\\n        0001\\n            then ans will be number of zereos before this\\n        or \\n        01111101\\n            then ans will be current ans+1, i.e. ( number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till last 1)\\n            \\n        // simple mai agr zeroes bht zda aagye hai last 1 aur is one k bich mai then answer is total number of zereos till ith \\n        else bht sare one hogye toh asnwer is 1+ last one ji b tha :)\\n    }\\n}\\n*/\\n```\\n\\nBRUTE FORCE :\\n\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        bool ok=true;\\n        int ans=0;\\n        while(ok){\\n            ok=false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);i++;\\n                    ok=true;\\n                }\\n            }\\n            if(ok)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string a) {\\n        int n=a.size();\\n        int zero=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'0\\')zero++;\\n            else{\\n                if(i>0&&a[i-1]==\\'1\\'&&zero>0)ans++;\\n                else if(i>0&&a[i-1]==\\'0\\'){\\n                    ans=max(ans+1,zero);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nif(a[i]==0)\\n    does nt matter because we are coming from left to right and we have at the end of string till i is 0 and its placed correctly\\nif(a[i]==1){\\n    last = a[i-1]\\n    if(last==1){\\n        if(num of zeres till here are zero){ \\n            then its fine, no increment in answwert answer reamins 0 only because string till here is -> 111...i times\\n        }\\n        else if(numOfZero>0){\\n            then number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till i-1\\n            to know y, dry run the problemStatment for the example 01 and 011.\\n        }\\n    }else if(last==\\'0\\'){\\n        0001\\n            then ans will be number of zereos before this\\n        or \\n        01111101\\n            then ans will be current ans+1, i.e. ( number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till last 1)\\n            \\n        // simple mai agr zeroes bht zda aagye hai last 1 aur is one k bich mai then answer is total number of zereos till ith \\n        else bht sare one hogye toh asnwer is 1+ last one ji b tha :)\\n    }\\n}\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        bool ok=true;\\n        int ans=0;\\n        while(ok){\\n            ok=false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);i++;\\n                    ok=true;\\n                }\\n            }\\n            if(ok)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478370,
                "title": "python-brute-force-step-by-step-solution-small-solution",
                "content": "### **Brute Force Solution**\\n\\n```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\ttemp = \"\"\\n\\t\\tones = s.count(\"1\") # get the count of 1\\n\\t\\tfor _ in range(ones):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmake a string with total number of 1\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ttemp += \"1\"\\n\\n\\t\\twhile s[:ones] != temp:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tloop through index 0 to count of 1 while the string is not equal to temp string\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tleft, right = 0, 1\\n\\t\\t\\twhile right < len(s):\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tCompare the two index from left to right if\\n\\t\\t\\t\\tthey both are equal to \"01\"\\n\\t\\t\\t\\tif so then replace them\\n\\t\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tif s[left : left + 1] + s[right : right + 1] == \"01\":\\n\\t\\t\\t\\t\\ts = s.replace(s[left : left + 1] + s[right : right + 1], \"10\")\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\t\\tright += 1\\n\\t\\treturn count\\n```\\n\\n### **Easy & Small Solution**\\n\\n```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\twhile \"01\" in s:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tWhile we are getting \"01\" in the string\\n\\t\\t\\twe will replace them into \"10\"\\n\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ts = s.replace(\"01\", \"10\")\\n\\t\\t\\tcount += 1\\n\\t\\treturn count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\ttemp = \"\"\\n\\t\\tones = s.count(\"1\") # get the count of 1\\n\\t\\tfor _ in range(ones):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmake a string with total number of 1\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ttemp += \"1\"\\n\\n\\t\\twhile s[:ones] != temp:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tloop through index 0 to count of 1 while the string is not equal to temp string\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tleft, right = 0, 1\\n\\t\\t\\twhile right < len(s):\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tCompare the two index from left to right if\\n\\t\\t\\t\\tthey both are equal to \"01\"\\n\\t\\t\\t\\tif so then replace them\\n\\t\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tif s[left : left + 1] + s[right : right + 1] == \"01\":\\n\\t\\t\\t\\t\\ts = s.replace(s[left : left + 1] + s[right : right + 1], \"10\")\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\t\\tright += 1\\n\\t\\treturn count\\n```\n```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\twhile \"01\" in s:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tWhile we are getting \"01\" in the string\\n\\t\\t\\twe will replace them into \"10\"\\n\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ts = s.replace(\"01\", \"10\")\\n\\t\\t\\tcount += 1\\n\\t\\treturn count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466135,
                "title": "java-solution-2-3-ms",
                "content": "1. Any **\"1\"** needs to pass all **\"0\"** before it. -> Count the number of **\"0\"**\\n2. **00 ... 00 111**\\n* Suppose first **\"1\"** need **m** steps to pass all **\"0\"** before it.\\n* Second **\"1\"** need **m+1** steps\\n* Third **\"1\"** need **m+2** steps\\n* Summary: count steps of previous **\"1\"** + 1\\n3. **00 ... 00 1 00 ... 00 1**\\n* Suppose the number of **\"0\"** between **\"1\"** s are **n** and first **\"1\"** need **m** steps\\n* If there is a X, X >= n and X < m, String s becomes **00 ... 00 11 00 ... 00** after X steps and Y is the remaining steps for first **\"1\"** to pass all **\"0\"**\\n* The remaining steps of second **\"1\"** is Y+1 -> the total steps of second **\"1\"** is X+Y+1 = m+1\\n* If X does not exist, count zeros before it because first **\"1\"** won\\'t impact second **\"1\"**\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0;\\n        int step = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') zero++;\\n            else if (zero > 0) step = Math.max(step+1, zero);\\n        }\\n        return step;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0;\\n        int step = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') zero++;\\n            else if (zero > 0) step = Math.max(step+1, zero);\\n        }\\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459556,
                "title": "easy-to-understand-c-simple",
                "content": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int c=0;\\n        int z;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            z=s.find(\"01\");\\n            if(s[0]==\\'0\\' && s[1]==\\'1\\')\\n            {\\n                z=1;\\n            }\\n            if(z>0)\\n            {\\n                 for(int j=0;j<s.size()-1;j++)\\n                 {\\n                     if(s[j]==\\'0\\' && s[j+1]==\\'1\\')\\n                     {\\n                            s[j]=\\'1\\';\\n                           s[j+1]=\\'0\\';\\n                           j++;\\n                     }\\n                 }\\n              \\n            }\\n            else\\n            {\\n                break;\\n            }\\n            c++;\\n           \\n        }\\n       return c;   \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int c=0;\\n        int z;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            z=s.find(\"01\");\\n            if(s[0]==\\'0\\' && s[1]==\\'1\\')\\n            {\\n                z=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2459235,
                "title": "java-bruteforce-approach",
                "content": "\\t private static int secondsToRemoveOccurrences(String s) {\\n        int count =0;\\n        for (int i = 0; i <s.length() ; i++) {\\n            if(s.contains(\"01\")){\\n             s = new String(s.replaceAll(\"01\",\"10\"));\\n                count++;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\t private static int secondsToRemoveOccurrences(String s) {\\n        int count =0;\\n        for (int i = 0; i <s.length() ; i++) {\\n            if(s.contains(\"01\")){\\n             s = new String(s.replaceAll(\"01\",\"10\"));\\n                count++;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2458555,
                "title": "c-brute-force-solution-74-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int res=0;\\n        while(true)\\n      { \\n              int i=0,j=1;\\n            int n=s.size();\\n            int cnt=0; // to count the number of \"01\" occured in string\\n            while(j<n){\\n                    if(s[i]==\\'0\\'&&s[j]==\\'1\\'){\\n                        swap(s[i],s[j]);\\n                        cnt++;\\n                        i+=2; // we have to jump to next pair of i,j ;\\n                        j+=2;\\n                        continue;\\n                    }\\n                      i++;\\n                      j++; \\n            }\\n             if(cnt==0)return res;\\n            res++;\\n      } \\n        return 0;\\n        \\n    }\\n};\\n```\\n\\nplease upvote if post is helpful for you.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int res=0;\\n        while(true)\\n      { \\n              int i=0,j=1;\\n            int n=s.size();\\n            int cnt=0; // to count the number of \"01\" occured in string\\n            while(j<n){\\n                    if(s[i]==\\'0\\'&&s[j]==\\'1\\'){\\n                        swap(s[i],s[j]);\\n                        cnt++;\\n                        i+=2; // we have to jump to next pair of i,j ;\\n                        j+=2;\\n                        continue;\\n                    }\\n                      i++;\\n                      j++; \\n            }\\n             if(cnt==0)return res;\\n            res++;\\n      } \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458298,
                "title": "java-easy-approach-less-space-complexity",
                "content": "It is a very easy approach just, we have to do one thing that if \"01\" is present in the string, then replace it with \"10\" untill all \"01\" is vanished. \\n\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return  count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return  count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458069,
                "title": "o-n-time-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), zero = 0, ans = 0;\\n        \\n        for(int i = 0;i < n;++i)\\n        {\\n            if(s[i] == \\'0\\')\\n                ++zero;\\n            else if(zero)\\n                ans = max(ans + 1, zero);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), zero = 0, ans = 0;\\n        \\n        for(int i = 0;i < n;++i)\\n        {\\n            if(s[i] == \\'0\\')\\n                ++zero;\\n            else if(zero)\\n                ans = max(ans + 1, zero);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2458003,
                "title": "java-ac-solution-60-faster",
                "content": "\\n\\t \\n\\t class Solution {\\n      public int secondsToRemoveOccurrences(String s) {\\n        \\n        char ch[] = s.toCharArray();\\n        boolean change = false;\\n        int c=0;\\n        // 1 1 1 1 0 0 0\\n        while(true)\\n        {\\n             for(int i=0;i<ch.length-1;){\\n            \\n            if(ch[i]==\\'0\\' && ch[i+1]==\\'1\\'){\\n                ch[i]=(char)(49);\\n                ch[i+1]=(char)(48);\\n                i+=2;\\n                change = true;\\n                // System.out.println(1);\\n                continue;\\n            } \\n            i++;\\n        }\\n            if(change==true)\\n            {\\n              c++;\\n              change = false;\\n            }\\n            else if(change == false){\\n                break;\\n            }\\n            \\n            \\n        }\\n        return c;\\n        \\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public int secondsToRemoveOccurrences(String s) {\\n        \\n        char ch[] = s.toCharArray();\\n        boolean change = false;\\n        int c=0;\\n        // 1 1 1 1 0 0 0\\n        while(true)\\n        {\\n             for(int i=0;i<ch.length-1;){\\n            \\n            if(ch[i]==\\'0\\' && ch[i+1]==\\'1\\'){\\n                ch[i]=(char)(49);\\n                ch[i+1]=(char)(48);\\n                i+=2;\\n                change = true;\\n                // System.out.println(1);\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2457683,
                "title": "python3-for-beiginners",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        while \\'01\\' in s:\\n            s=s.replace(\\'01\\',\\'10\\')\\n            c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        while \\'01\\' in s:\\n            s=s.replace(\\'01\\',\\'10\\')\\n            c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456194,
                "title": "python-o-n",
                "content": "finally the string will become \"11111...00000\", when encoutner a `\"1\"` we try to move it to the final position `final_pos`, it might be delayed when there are multiple `\"1\"`s stick together, bc you have to wait for the closest `\"0\"` to come, delay can be mitigated by an appearance of a `\"0\"`.\\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        res = final_pos = delay = 0\\n        for i,v in enumerate(s):\\n            if v==\"1\":\\n                if i>final_pos:\\n                    res = max(res, i-final_pos+delay)\\n                    delay+=1\\n                final_pos+=1\\n            elif delay:\\n                delay-=1\\n        return res",
                "solutionTags": [],
                "code": "finally the string will become \"11111...00000\", when encoutner a `\"1\"` we try to move it to the final position `final_pos`, it might be delayed when there are multiple `\"1\"`s stick together, bc you have to wait for the closest `\"0\"` to come, delay can be mitigated by an appearance of a `\"0\"`.\\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        res = final_pos = delay = 0\\n        for i,v in enumerate(s):\\n            if v==\"1\":\\n                if i>final_pos:\\n                    res = max(res, i-final_pos+delay)\\n                    delay+=1\\n                final_pos+=1\\n            elif delay:\\n                delay-=1\\n        return res",
                "codeTag": "C++"
            },
            {
                "id": 2456038,
                "title": "javascript-brute-force",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nfunction secondsToRemoveOccurrences(s) {\\n  const arr = s.split(\\'\\'),\\n    n = s.length\\n  let count = 0\\n  while (true) {\\n    let allSorted = true\\n    for (let i = n - 2; i >= 0; i--) {\\n      if (arr[i] === \\'0\\' && arr[i + 1] === \\'1\\') {\\n        allSorted = false\\n        const temp = arr[i + 1]\\n        arr[i + 1] = arr[i]\\n        arr[i] = temp\\n        i--\\n      }\\n    }\\n    if (allSorted) break\\n    count++\\n  }\\n  return count\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nfunction secondsToRemoveOccurrences(s) {\\n  const arr = s.split(\\'\\'),\\n    n = s.length\\n  let count = 0\\n  while (true) {\\n    let allSorted = true\\n    for (let i = n - 2; i >= 0; i--) {\\n      if (arr[i] === \\'0\\' && arr[i + 1] === \\'1\\') {\\n        allSorted = false\\n        const temp = arr[i + 1]\\n        arr[i + 1] = arr[i]\\n        arr[i] = temp\\n        i--\\n      }\\n    }\\n    if (allSorted) break\\n    count++\\n  }\\n  return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455948,
                "title": "simple-rust-solution-explained-2ms-o-n-time-o-1-mem",
                "content": "Firstly, we need to understand that in this problem we need to find how many steps will it take the rightmost one to travel all the way to the left. \\n\\nImagine input `00001`: one needs to travel to the left as many steps as there are zeroes before it. If there are some ones in the very beginning they won\\'t make a difference: `11100001`, so we ignore all the ones before the first zero. \\n\\nThen the question is what happens if there are two ones in a row: `000011`. Second one is blocked on the very first step, but then it can travel in parallel with the first one. So, it will always be 1 step slower than the previous one. Note, that it still needs to travel as many steps as there are zeroes before it + maybe get blocked by other ones. \\n\\nIf there are few blocks of ones interchanged with zeroes it doesn\\'t really change anything. If our last one catches up with a block of ones (`011.111.001 -> 110.111.100 -> 111.110.100` - dots just for visibility) it will need at least 1 more second than the previous one, but not less than number of zeroes (ex. `011.111.000000000000000001`).\\n\\n\\n```rust\\nuse std::cmp;\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut zeroes=0;\\n        let mut started = false; \\n        let mut last=0;\\n        for c in s.chars(){\\n            if c==\\'1\\'{\\n                if started {\\n                    last = cmp::max(last+1, zeroes);\\n                }else{\\n                    continue;\\n                }\\n            }else{\\n                if !started {\\n                    started = true\\n                }   \\n                zeroes+=1;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp;\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut zeroes=0;\\n        let mut started = false; \\n        let mut last=0;\\n        for c in s.chars(){\\n            if c==\\'1\\'{\\n                if started {\\n                    last = cmp::max(last+1, zeroes);\\n                }else{\\n                    continue;\\n                }\\n            }else{\\n                if !started {\\n                    started = true\\n                }   \\n                zeroes+=1;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455367,
                "title": "java-simple-solution-clean-code-easy-approach",
                "content": "```\\nclass Solution {\\n            public int secondsToRemoveOccurrences(String s) {\\n                StringBuilder sb=new StringBuilder(s);\\n                int ans=0;\\n                while(sb.indexOf(\"01\")!=-1){\\n                    ans++;\\n                    int i=0;\\n                    while(i<sb.length()-1){\\n                        if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\') {\\n                            sb.setCharAt(i, \\'1\\');\\n                            sb.setCharAt(i + 1, \\'0\\');\\n                            i = i + 2;\\n                        }\\n                        else{\\n                            i++;\\n                        }\\n                    }\\n                }return ans;\\n            }\\n        }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n            public int secondsToRemoveOccurrences(String s) {\\n                StringBuilder sb=new StringBuilder(s);\\n                int ans=0;\\n                while(sb.indexOf(\"01\")!=-1){\\n                    ans++;\\n                    int i=0;\\n                    while(i<sb.length()-1){\\n                        if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\') {\\n                            sb.setCharAt(i, \\'1\\');\\n                            sb.setCharAt(i + 1, \\'0\\');\\n                            i = i + 2;\\n                        }\\n                        else{\\n                            i++;\\n                        }\\n                    }\\n                }return ans;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455308,
                "title": "cpp-java-python-dp-brute-force-tc-0-n-2-o-n-sc-o-n-o-1",
                "content": "**Please Upvote, If you like this solutions.**\\n\\n```\\n// Brute-Force - CPP\\n// Time - O(N*2) \\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int cnt = 0; bool flag = true;\\n        while(flag){\\n            flag = false;\\n            \\n            for(int i = 0; i < s.size()-1; ++i){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    flag = true;\\n                    ++i;\\n                }     \\n            }\\n            \\n            cnt += flag;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n```\\n// DP - CP\\n// Time - O(N)\\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int zeros = 0, seconds = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            zeros += s[i] == \\'0\\' ? 1 : 0;\\n            if (s[i] == \\'1\\' && zeros > 0)\\n                seconds = max(seconds + 1, zeros);\\n        }\\n        return seconds; \\n    }\\n};\\n```\\n\\n```\\n// Java Solution\\n// TIme - O(N)\\n// Space - O(1) \\n\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```\\n```\\n# Python \\n# Time - O(N)\\n# Space - O(1)\\n\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = 0\\n        cntZeros = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and cntZeros > 0:\\n                waitingTime += 1\\n    \\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                cntZeros += 1\\n                \\n        return cntZeros + waitingTime\\n\\t\\t\\n```\\n\\n**Thank you...**\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Brute-Force - CPP\\n// Time - O(N*2) \\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int cnt = 0; bool flag = true;\\n        while(flag){\\n            flag = false;\\n            \\n            for(int i = 0; i < s.size()-1; ++i){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    flag = true;\\n                    ++i;\\n                }     \\n            }\\n            \\n            cnt += flag;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\n// DP - CP\\n// Time - O(N)\\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int zeros = 0, seconds = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            zeros += s[i] == \\'0\\' ? 1 : 0;\\n            if (s[i] == \\'1\\' && zeros > 0)\\n                seconds = max(seconds + 1, zeros);\\n        }\\n        return seconds; \\n    }\\n};\\n```\n```\\n// Java Solution\\n// TIme - O(N)\\n// Space - O(1) \\n\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```\n```\\n# Python \\n# Time - O(N)\\n# Space - O(1)\\n\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = 0\\n        cntZeros = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and cntZeros > 0:\\n                waitingTime += 1\\n    \\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                cntZeros += 1\\n                \\n        return cntZeros + waitingTime\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455044,
                "title": "c-solution-using-two-loops",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string &s) {\\n        int res = 0, n = s.size();\\n        for (int i = 0; i < n; i++) {\\n            bool flag = false;\\n            for (int j = 0; j < n - 1; j++) {\\n                if (s[j] == \\'0\\' && s[j + 1] == \\'1\\') {\\n                    flag = true;\\n                    swap(s[j], s[j + 1]);\\n                    j++;\\n                }\\n            }\\n            if (flag) res++;\\n            else break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string &s) {\\n        int res = 0, n = s.size();\\n        for (int i = 0; i < n; i++) {\\n            bool flag = false;\\n            for (int j = 0; j < n - 1; j++) {\\n                if (s[j] == \\'0\\' && s[j + 1] == \\'1\\') {\\n                    flag = true;\\n                    swap(s[j], s[j + 1]);\\n                    j++;\\n                }\\n            }\\n            if (flag) res++;\\n            else break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454872,
                "title": "c-easy-solution-by-swaping",
                "content": "**C++ Code:**\\n\\n```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.length();\\n        int time = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n             bool happen = false;\\n            for(int j=0;j<n-1;)\\n            {\\n                if(s[j]==\\'0\\'&& s[j+1]==\\'1\\'){\\n                    swap(s[j],s[j+1]);\\n                    j = j+2;\\n                    happen = true;\\n                }\\n                else j++;\\n            }\\n            if(happen)\\n            time ++;\\n            else break;\\n        }\\n        return time;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.length();\\n        int time = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n             bool happen = false;\\n            for(int j=0;j<n-1;)\\n            {\\n                if(s[j]==\\'0\\'&& s[j+1]==\\'1\\'){\\n                    swap(s[j],s[j+1]);\\n                    j = j+2;\\n                    happen = true;\\n                }\\n                else j++;\\n            }\\n            if(happen)\\n            time ++;\\n            else break;\\n        }\\n        return time;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454742,
                "title": "easy-c-code",
                "content": "class Solution {\\npublic:\\n\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt = 0;\\n        bool flag = false;\\n        while(flag == false) {\\n            flag = true;\\n            for(int i = 0; i < s.size(); ) {\\n                if(i + 1 < s.size() and s[i] == \\'0\\' and s[i + 1] == \\'1\\') {\\n                    if(flag) {\\n                        cnt++;\\n                        flag = false;\\n                    }\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i+=2;\\n                }\\n                else i++;\\n            }      \\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt = 0;\\n        bool flag = false;\\n        while(flag == false) {\\n            flag = true;\\n            for(int i = 0; i < s.size(); ) {\\n                if(i + 1 < s.size() and s[i] == \\'0\\' and s[i + 1] == \\'1\\') {\\n                    if(flag) {\\n                        cnt++;\\n                        flag = false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2454731,
                "title": "java-easy-understanding-o-n-2",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        //int flag=1;\\n        int seconds=0;\\n        String curr= s;\\n        while(true){\\n            StringBuilder newString= new StringBuilder();\\n            int zeroOneFlag=0;\\n            for(int i=0;i<curr.length()-1;i++){\\n                if(curr.charAt(i)==\\'0\\' && curr.charAt(i+1)==\\'1\\'){\\n                    newString.append(\"10\");\\n                    i++;\\n                    zeroOneFlag=1;\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n                else{\\n                    newString.append(curr.charAt(i));\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n            }\\n            if(zeroOneFlag==0){\\n                break;\\n            }\\n            seconds++;\\n            //System.out.println(curr);\\n            curr= newString.toString();\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        //int flag=1;\\n        int seconds=0;\\n        String curr= s;\\n        while(true){\\n            StringBuilder newString= new StringBuilder();\\n            int zeroOneFlag=0;\\n            for(int i=0;i<curr.length()-1;i++){\\n                if(curr.charAt(i)==\\'0\\' && curr.charAt(i+1)==\\'1\\'){\\n                    newString.append(\"10\");\\n                    i++;\\n                    zeroOneFlag=1;\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n                else{\\n                    newString.append(curr.charAt(i));\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n            }\\n            if(zeroOneFlag==0){\\n                break;\\n            }\\n            seconds++;\\n            //System.out.println(curr);\\n            curr= newString.toString();\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454695,
                "title": "best-java-solution-easy",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454658,
                "title": "c-easy-beginner",
                "content": "\\'\\'\\'\\n\\n\\tint size=s.length();\\n        int arr[size];\\n        for(int i=0;i<size;i++)\\n        {\\n            arr[i]=s[i]-48;\\n        }\\n        \\n        int ones=0;\\n        for (int i=0;i<size;i++)\\n        {\\n            if(arr[i]==1) ones++;\\n        }\\n        int ans=0;\\n        int k=0;\\n        int s1=0;\\n        while(k==0)\\n        {\\n            for (int i=1;i<size;i++)\\n            {\\n                if (arr[i]==1 && arr[i-1]==0)\\n                {\\n                    int temp=arr[i];\\n                    arr[i]=arr[i-1];\\n                    arr[i-1]=temp;   \\n                    i++;\\n                    s1++;\\n                }   \\n            }\\n            if (s1==0) return ans;\\n            ans++;\\n            int a=0;\\n            int b=0;\\n            for (int i=0;i<size;i++)\\n            {\\n                if (arr[i]==1) a++;\\n                else\\n                {\\n                    b=max(b,a);\\n                    a=0;\\n                }\\n            }\\n            if (b==ones)\\n            {\\n                k=1;\\n            }\\n        }\\n        return ans;\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\tint size=s.length();\\n        int arr[size];\\n        for(int i=0;i<size;i++)\\n        {\\n            arr[i]=s[i]-48;\\n        }\\n        \\n        int ones=0;\\n        for (int i=0;i<size;i++)\\n        {\\n            if(arr[i]==1) ones++;\\n        }\\n        int ans=0;\\n        int k=0;\\n        int s1=0;\\n        while(k==0)\\n        {\\n            for (int i=1;i<size;i++)\\n            {\\n                if (arr[i]==1 && arr[i-1]==0)\\n                {\\n                    int temp=arr[i];\\n                    arr[i]=arr[i-1];\\n                    arr[i-1]=temp;   \\n                    i++;\\n                    s1++;\\n                }   \\n            }\\n            if (s1==0) return ans;\\n            ans++;\\n            int a=0;\\n            int b=0;\\n            for (int i=0;i<size;i++)\\n            {\\n                if (arr[i]==1) a++;\\n                else\\n                {\\n                    b=max(b,a);\\n                    a=0;\\n                }\\n            }\\n            if (b==ones)\\n            {\\n                k=1;\\n            }\\n        }\\n        return ans;\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2454548,
                "title": "rust-solution",
                "content": "~~~\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut s = s.chars().collect::<Vec<char>>();\\n        let mut finished = false;\\n        let mut ret = 0;\\n        \\n        while finished == false {\\n            finished = true;\\n            let mut i = 0;\\n            \\n            while i < s.len() - 1 {\\n                if s[i] == \\'0\\' && s[i + 1] == \\'1\\' {\\n                    s.swap(i, i + 1);\\n                    i += 2;\\n                    finished = false;\\n                } else { \\n                    i += 1; \\n                }\\n            }\\n            \\n            if finished == false { ret += 1; }\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut s = s.chars().collect::<Vec<char>>();\\n        let mut finished = false;\\n        let mut ret = 0;\\n        \\n        while finished == false {\\n            finished = true;\\n            let mut i = 0;\\n            \\n            while i < s.len() - 1 {\\n                if s[i] == \\'0\\' && s[i + 1] == \\'1\\' {\\n                    s.swap(i, i + 1);\\n                    i += 2;\\n                    finished = false;\\n                } else { \\n                    i += 1; \\n                }\\n            }\\n            \\n            if finished == false { ret += 1; }\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2454486,
                "title": "easy-and-concise-java-solution",
                "content": "```\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sc = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.contains(\"01\")) {\\n                s = s.replace(\"01\", \"10\");\\n                sc++;\\n            }\\n        }\\n        return sc;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sc = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.contains(\"01\")) {\\n                s = s.replace(\"01\", \"10\");\\n                sc++;\\n            }\\n        }\\n        return sc;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454464,
                "title": "easy-solution",
                "content": "```\\nint secondsToRemoveOccurrences(string s) {\\n        \\n       int count = 0, check = 1;\\n        \\n       while(check) {\\n           \\n           \\n            check = 0;\\n           \\n            for (int i = 0; i < s.size() - 1; i++) {\\n            \\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                \\n                    swap(s[i], s[i + 1]);\\n                \\n                    i++;\\n                \\n                    check = 1;\\n                }\\n            }\\n           \\n            count += check;\\n    \\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        \\n       int count = 0, check = 1;\\n        \\n       while(check) {\\n           \\n           \\n            check = 0;\\n           \\n            for (int i = 0; i < s.size() - 1; i++) {\\n            \\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                \\n                    swap(s[i], s[i + 1]);\\n                \\n                    i++;\\n                \\n                    check = 1;\\n                }\\n            }\\n           \\n            count += check;\\n    \\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454438,
                "title": "java-easy-solution",
                "content": "```\\n  public int secondsToRemoveOccurrences(String s) {\\n        char[] c=s.toCharArray();\\n        int res=0;\\n        while(s.contains(\"01\")){\\n            for(int i=0;i<c.length-1;i++)\\n                if(c[i]==\\'0\\'&&c[i+1]==\\'1\\'){\\n                    char temp=c[i];\\n                    c[i]=c[i+1];\\n                    c[i+1]=temp;\\n                    i++;\\n                }\\n            s=String.valueOf(c);\\n            c=s.toCharArray();\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n  public int secondsToRemoveOccurrences(String s) {\\n        char[] c=s.toCharArray();\\n        int res=0;\\n        while(s.contains(\"01\")){\\n            for(int i=0;i<c.length-1;i++)\\n                if(c[i]==\\'0\\'&&c[i+1]==\\'1\\'){\\n                    char temp=c[i];\\n                    c[i]=c[i+1];\\n                    c[i+1]=temp;\\n                    i++;\\n                }\\n            s=String.valueOf(c);\\n            c=s.toCharArray();\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454393,
                "title": "c",
                "content": "```\\n   public int SecondsToRemoveOccurrences(string s)\\n        {\\n            var count = 0;\\n            while (s.Contains(\"01\"))\\n            {\\n                var answer = new char[s.Length];\\n                for (int j = 0; j < s.Length; j++)\\n                {\\n                    answer[j] = s[j];\\n                }\\n                int i = 0;\\n                while (i < answer.Length - 1)\\n                {\\n                    if (s[i].ToString() + s[i + 1].ToString() == \"01\")\\n                    {\\n                        answer[i] = \\'1\\';\\n                        answer[i + 1] = \\'0\\';\\n                        i += 2;\\n                    }\\n                    else\\n                    {\\n                        i++;\\n                    }\\n                }\\n                count++;\\n                s = new string(answer);\\n            }\\n            return count;\\n        }",
                "solutionTags": [],
                "code": "```\\n   public int SecondsToRemoveOccurrences(string s)\\n        {\\n            var count = 0;\\n            while (s.Contains(\"01\"))\\n            {\\n                var answer = new char[s.Length];\\n                for (int j = 0; j < s.Length; j++)\\n                {\\n                    answer[j] = s[j];\\n                }\\n                int i = 0;\\n                while (i < answer.Length - 1)\\n                {\\n                    if (s[i].ToString() + s[i + 1].ToString() == \"01\")\\n                    {\\n                        answer[i] = \\'1\\';\\n                        answer[i + 1] = \\'0\\';\\n                        i += 2;\\n                    }\\n                    else\\n                    {\\n                        i++;\\n                    }\\n                }\\n                count++;\\n                s = new string(answer);\\n            }\\n            return count;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2454316,
                "title": "c-easy-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool zeroOne = false;\\n        int cnt = 0;\\n        while(true)\\n        {\\n            zeroOne = false;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' &&  s[i+1] == \\'1\\'){\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i++;\\n                    zeroOne = true;\\n                }\\n            }\\n            \\n            if(zeroOne == false)\\n                break;\\n            \\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool zeroOne = false;\\n        int cnt = 0;\\n        while(true)\\n        {\\n            zeroOne = false;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' &&  s[i+1] == \\'1\\'){\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i++;\\n                    zeroOne = true;\\n                }\\n            }\\n            \\n            if(zeroOne == false)\\n                break;\\n            \\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454295,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sec = 0;\\n        int n = s.length();\\n        boolean changes = true;\\n        while(changes)\\n        {\\n            boolean flag = false;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\')\\n                {\\n                    sec++;\\n                    flag = true;\\n                    s = s.replace(\"01\",\"10\");\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n                changes = false;\\n        }\\n        return sec;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sec = 0;\\n        int n = s.length();\\n        boolean changes = true;\\n        while(changes)\\n        {\\n            boolean flag = false;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\')\\n                {\\n                    sec++;\\n                    flag = true;\\n                    s = s.replace(\"01\",\"10\");\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2454293,
                "title": "cpp-easy",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        queue<int> q;\\n        int count =0 ;\\n        \\n        for(int i=0; i<s.size()-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                // mpp[s[i]] =true ;\\n                q.push(i) ;\\n        }\\n        \\n        while(!q.empty()){\\n            count++ ;\\n            int size = q.size() ;\\n            \\n            for(int i=0; i<size; i++){\\n                int ind = q.front() ;\\n                q.pop() ;\\n               \\n                s[ind] = \\'1\\' ;\\n                s[ind+1] = \\'0\\' ;\\n            }\\n            \\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                    q.push(i) ;\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n};\\n```\\n\\n\\nSimilar to Rotting oranges \\n\\n**Please Upvote!!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        queue<int> q;\\n        int count =0 ;\\n        \\n        for(int i=0; i<s.size()-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                // mpp[s[i]] =true ;\\n                q.push(i) ;\\n        }\\n        \\n        while(!q.empty()){\\n            count++ ;\\n            int size = q.size() ;\\n            \\n            for(int i=0; i<size; i++){\\n                int ind = q.front() ;\\n                q.pop() ;\\n               \\n                s[ind] = \\'1\\' ;\\n                s[ind+1] = \\'0\\' ;\\n            }\\n            \\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                    q.push(i) ;\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454190,
                "title": "intutive-solution-using-stack-easy-to-understand",
                "content": "```\\nfunction isValid(s){\\n    for(let i=1;i<s.length;i++){\\n        if(s[i]==\"1\" && s[i-1]==\"0\") return false;\\n    }\\n    return true;\\n}\\n\\nvar secondsToRemoveOccurrences = function(s) {\\n    let stack=[];\\n   \\n    let operations=0;\\n    \\n    while(!isValid(s)){\\n         stack.push(s[0]);\\n        for(let i=1;i<s.length;i++){\\n            if(stack.length && s[i]==\"1\" && s[i-1]==\"0\"){\\n                stack.pop();\\n                stack.push(\"1\");\\n                stack.push(\"0\");\\n            }else{\\n                stack.push(s[i]);\\n            }\\n        }\\n        \\n        let newTemp=\"\";\\n        \\n        for(let i=0;i<stack.length;i++) newTemp+=stack[i];\\n        s=newTemp;\\n        operations++;\\n        stack=[];\\n    }\\n    return operations;\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nfunction isValid(s){\\n    for(let i=1;i<s.length;i++){\\n        if(s[i]==\"1\" && s[i-1]==\"0\") return false;\\n    }\\n    return true;\\n}\\n\\nvar secondsToRemoveOccurrences = function(s) {\\n    let stack=[];\\n   \\n    let operations=0;\\n    \\n    while(!isValid(s)){\\n         stack.push(s[0]);\\n        for(let i=1;i<s.length;i++){\\n            if(stack.length && s[i]==\"1\" && s[i-1]==\"0\"){\\n                stack.pop();\\n                stack.push(\"1\");\\n                stack.push(\"0\");\\n            }else{\\n                stack.push(s[i]);\\n            }\\n        }\\n        \\n        let newTemp=\"\";\\n        \\n        for(let i=0;i<stack.length;i++) newTemp+=stack[i];\\n        s=newTemp;\\n        operations++;\\n        stack=[];\\n    }\\n    return operations;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454180,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        ll sz = s.length(), res = 0;\\n        while (true) {\\n            bool fl = true;\\n            for (ll i = 1;i < sz;++i) {\\n                if (s[i] == \\'1\\' && s[i - 1] == \\'0\\') {\\n                    s[i] = \\'0\\';\\n                    s[i - 1] = \\'1\\';\\n                    ++i;\\n                    fl = false;\\n                }\\n            }\\n            if (fl) {\\n                break;\\n            }\\n            else {\\n                ++res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        ll sz = s.length(), res = 0;\\n        while (true) {\\n            bool fl = true;\\n            for (ll i = 1;i < sz;++i) {\\n                if (s[i] == \\'1\\' && s[i - 1] == \\'0\\') {\\n                    s[i] = \\'0\\';\\n                    s[i - 1] = \\'1\\';\\n                    ++i;\\n                    fl = false;\\n                }\\n            }\\n            if (fl) {\\n                break;\\n            }\\n            else {\\n                ++res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056868,
                "title": "the-real-bruteforce-solution-self-explanatory-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int one = 0, zero = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'0\\') zero++;\\n            else one++;\\n        }\\n        \\n        string str = \"\";   \\n        for(int i=0; i<one; i++){\\n            str+=\\'1\\';\\n        }\\n        \\n        for(int i=0; i<zero; i++){\\n            str+=\\'0\\';\\n        }\\n        \\n        int count = 0;\\n        while(s!=str){\\n            count++;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                }\\n            }\\n            \\n            // cout<<s<<endl;\\n        }\\n        \\n        // cout<<s<<endl;\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int one = 0, zero = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'0\\') zero++;\\n            else one++;\\n        }\\n        \\n        string str = \"\";   \\n        for(int i=0; i<one; i++){\\n            str+=\\'1\\';\\n        }\\n        \\n        for(int i=0; i<zero; i++){\\n            str+=\\'0\\';\\n        }\\n        \\n        int count = 0;\\n        while(s!=str){\\n            count++;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                }\\n            }\\n            \\n            // cout<<s<<endl;\\n        }\\n        \\n        // cout<<s<<endl;\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4032305,
                "title": "go-dp-80-faster-100-less-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maxInt(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\n\\tout := 0\\n\\tzeros := 0\\n\\n\\tfor _, v := range s {\\n\\t\\tif string(v) == \"0\" {\\n\\t\\t\\tzeros++\\n\\t\\t} else if zeros > 0 {\\n\\t\\t\\tout = maxInt(out+1, zeros)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Dynamic Programming",
                    "Simulation"
                ],
                "code": "```\\nfunc maxInt(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\n\\tout := 0\\n\\tzeros := 0\\n\\n\\tfor _, v := range s {\\n\\t\\tif string(v) == \"0\" {\\n\\t\\t\\tzeros++\\n\\t\\t} else if zeros > 0 {\\n\\t\\t\\tout = maxInt(out+1, zeros)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028005,
                "title": "time-needed-to-rearrange-a-binary-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int[] arr = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr[i] = Integer.valueOf(s.substring(i,i+1));\\n        }\\n        int count=0;\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                count++;\\n            }\\n            else if(count>0)\\n            ans = Math.max(ans+1,count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int[] arr = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr[i] = Integer.valueOf(s.substring(i,i+1));\\n        }\\n        int count=0;\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                count++;\\n            }\\n            else if(count>0)\\n            ans = Math.max(ans+1,count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966171,
                "title": "c-simple-beginner-friendly-do-upvote-if-the-solution-helped-u",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int sec=0;\\n        for (int i =0;i<s.length();i++){\\n            bool flag = false;\\n            for (int j=0;j<s.length()-1;j++){\\n                if ( s[j] == \\'0\\'  && s[j+1] == \\'1\\')\\n                {\\n                    s[j] = \\'1\\';\\n                    s[j+1] = \\'0\\';\\n                    flag = true;\\n                    j++;\\n                }\\n            }\\n            if ( flag ) sec++;\\n        }\\n        return sec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int sec=0;\\n        for (int i =0;i<s.length();i++){\\n            bool flag = false;\\n            for (int j=0;j<s.length()-1;j++){\\n                if ( s[j] == \\'0\\'  && s[j+1] == \\'1\\')\\n                {\\n                    s[j] = \\'1\\';\\n                    s[j+1] = \\'0\\';\\n                    flag = true;\\n                    j++;\\n                }\\n            }\\n            if ( flag ) sec++;\\n        }\\n        return sec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923545,
                "title": "java-optimized-solution-bubble-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char arr[]=s.toCharArray();\\n        int n=arr.length;\\n        int count=0;\\n        for(count=0;count<n-1;count++){\\n            boolean swap=false;\\n            for(int j=0;j<n-1;j++){\\n                if(arr[j]==\\'0\\' && arr[j+1]==\\'1\\'){\\n                    arr[j]=\\'1\\';\\n                    arr[j+1]=\\'0\\';\\n                    swap=true;\\n                    j++;\\n                }\\n                \\n            }\\n           \\n            if(swap==false)break;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char arr[]=s.toCharArray();\\n        int n=arr.length;\\n        int count=0;\\n        for(count=0;count<n-1;count++){\\n            boolean swap=false;\\n            for(int j=0;j<n-1;j++){\\n                if(arr[j]==\\'0\\' && arr[j+1]==\\'1\\'){\\n                    arr[j]=\\'1\\';\\n                    arr[j+1]=\\'0\\';\\n                    swap=true;\\n                    j++;\\n                }\\n                \\n            }\\n           \\n            if(swap==false)break;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909426,
                "title": "easy-bruteforce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt =0;\\n        int n = s.length();\\n        bool flag=true;\\n        while(flag){\\n            flag =false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    flag = true;\\n                    swap(s[i],s[i+1]);\\n                    i+=1;\\n                }\\n            }\\n            if(flag){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt =0;\\n        int n = s.length();\\n        bool flag=true;\\n        while(flag){\\n            flag =false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    flag = true;\\n                    swap(s[i],s[i+1]);\\n                    i+=1;\\n                }\\n            }\\n            if(flag){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906406,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Map<Character,Integer> hm=new HashMap<>();\\n        for(char c:s.toCharArray()) hm.put(c,hm.getOrDefault(c,0)+1);\\n        StringBuilder res=new StringBuilder();\\n        int op=0;\\n        for(int i=0;hm.containsKey(\\'1\\') && i<hm.get(\\'1\\');i++) res.append(\\'1\\');\\n        for(int i=0;hm.containsKey(\\'0\\') && i<hm.get(\\'0\\');i++) res.append(\\'0\\');\\n        return helper(s.toCharArray(),res.toString(),0);\\n    }\\n    int helper(char[] arr,String s,int op){\\n        if(s.equals(new String(arr))){\\n            return op;\\n        }\\n        op++;\\n        for(int i=0;i+1<arr.length;i++){\\n            if(arr[i]==\\'0\\' && arr[i+1]==\\'1\\'){\\n                arr=swap(i,i+1,arr);\\n                i++;\\n            }\\n        }\\n        return helper(arr,s,op);\\n    }\\n    char[] swap(int i,int j,char[] arr){\\n        char t=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=t;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Map<Character,Integer> hm=new HashMap<>();\\n        for(char c:s.toCharArray()) hm.put(c,hm.getOrDefault(c,0)+1);\\n        StringBuilder res=new StringBuilder();\\n        int op=0;\\n        for(int i=0;hm.containsKey(\\'1\\') && i<hm.get(\\'1\\');i++) res.append(\\'1\\');\\n        for(int i=0;hm.containsKey(\\'0\\') && i<hm.get(\\'0\\');i++) res.append(\\'0\\');\\n        return helper(s.toCharArray(),res.toString(),0);\\n    }\\n    int helper(char[] arr,String s,int op){\\n        if(s.equals(new String(arr))){\\n            return op;\\n        }\\n        op++;\\n        for(int i=0;i+1<arr.length;i++){\\n            if(arr[i]==\\'0\\' && arr[i+1]==\\'1\\'){\\n                arr=swap(i,i+1,arr);\\n                i++;\\n            }\\n        }\\n        return helper(arr,s,op);\\n    }\\n    char[] swap(int i,int j,char[] arr){\\n        char t=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=t;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853046,
                "title": "worst-solution-ever-but-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int n = s.size();\\n        int i=0;\\n        while(i<n-1){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n    void solve(string s , int& ans){\\n        if(check(s)){\\n            return;\\n        }\\n\\n        ans++;\\n        \\n        for(int i=0 ; i<s.size()-1 ; i++){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                swap(s[i],s[i+1]);\\n                i++;\\n            }\\n        }\\n        solve(s,ans);\\n\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        solve(s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int n = s.size();\\n        int i=0;\\n        while(i<n-1){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n    void solve(string s , int& ans){\\n        if(check(s)){\\n            return;\\n        }\\n\\n        ans++;\\n        \\n        for(int i=0 ; i<s.size()-1 ; i++){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                swap(s[i],s[i+1]);\\n                i++;\\n            }\\n        }\\n        solve(s,ans);\\n\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        solve(s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845360,
                "title": "1-nested-loop-to-speed-up-and-in-place-replacing-to-reduce-memory-usage",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        if (s == null) return 0;\\n        int t = s.length();\\n        if (t < 2) return 0;\\n        char[] ch_array = s.toCharArray();\\n\\n        int count = 0;\\n        // for (int i = 0 ; i < t ; i++) {\\n        //     if (s.contains(\"01\")) {\\n        //         s = s.replace(\"01\", \"10\");\\n        //         count++;\\n        //     }\\n        //     else break;\\n        // }\\n        boolean found = false;\\n        for (int i = 0 ; i < t ; i++) {\\n            for (int j = 0 ; j < t - 1 ; j++) {\\n                if (ch_array[j] == \\'0\\' && ch_array[j+1] == \\'1\\') {\\n                    ch_array[j] = \\'1\\';\\n                    ch_array[j+1] = \\'0\\';\\n                    j += 1;\\n                    found = true;\\n                }\\n            }\\n            if (found) {\\n                count += 1;\\n                found = false;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        if (s == null) return 0;\\n        int t = s.length();\\n        if (t < 2) return 0;\\n        char[] ch_array = s.toCharArray();\\n\\n        int count = 0;\\n        // for (int i = 0 ; i < t ; i++) {\\n        //     if (s.contains(\"01\")) {\\n        //         s = s.replace(\"01\", \"10\");\\n        //         count++;\\n        //     }\\n        //     else break;\\n        // }\\n        boolean found = false;\\n        for (int i = 0 ; i < t ; i++) {\\n            for (int j = 0 ; j < t - 1 ; j++) {\\n                if (ch_array[j] == \\'0\\' && ch_array[j+1] == \\'1\\') {\\n                    ch_array[j] = \\'1\\';\\n                    ch_array[j+1] = \\'0\\';\\n                    j += 1;\\n                    found = true;\\n                }\\n            }\\n            if (found) {\\n                count += 1;\\n                found = false;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812224,
                "title": "brute-force-c-o-n-2-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPerform the replacement process and count number of iterations.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a sliding window to keep track of whether a \"01\" sequence exists and replace it if so, continue until no further \"01\" sequence exists.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(std::string & s) {\\n        int num_seconds = 0;\\n        bool seq_found = true;\\n        bool replacement_occured = false;\\n        \\n        while(seq_found){\\n                replacement_occured = false;\\n                // loop through and replace all occurences\\n                for(int i = 0; i < s.length() - 1; i++){\\n                    if(s.at(i) == \\'0\\' && s.at(i+1) == \\'1\\'){\\n                        s[i] = \\'1\\';\\n                        s[i+1] = \\'0\\';\\n                        replacement_occured = true;\\n                        i++; // advance ptr to prevent overlap\\n                    }\\n                }\\n                if(replacement_occured){\\n                    num_seconds++;\\n                }else{\\n                    seq_found = false;\\n                }            \\n        }\\n        \\n        \\n        return num_seconds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(std::string & s) {\\n        int num_seconds = 0;\\n        bool seq_found = true;\\n        bool replacement_occured = false;\\n        \\n        while(seq_found){\\n                replacement_occured = false;\\n                // loop through and replace all occurences\\n                for(int i = 0; i < s.length() - 1; i++){\\n                    if(s.at(i) == \\'0\\' && s.at(i+1) == \\'1\\'){\\n                        s[i] = \\'1\\';\\n                        s[i+1] = \\'0\\';\\n                        replacement_occured = true;\\n                        i++; // advance ptr to prevent overlap\\n                    }\\n                }\\n                if(replacement_occured){\\n                    num_seconds++;\\n                }else{\\n                    seq_found = false;\\n                }            \\n        }\\n        \\n        \\n        return num_seconds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628857,
                "title": "time-needed-to-rearrange-a-binary-string",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        return time(s,0);\\n    }\\n    public static int time(String s,int count) {\\n        //base case\\n        if(!s.contains(\"01\"))\\n        {\\n            return count;\\n        }\\n        return time(s.replace(\"01\", \"10\"),count+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        return time(s,0);\\n    }\\n    public static int time(String s,int count) {\\n        //base case\\n        if(!s.contains(\"01\"))\\n        {\\n            return count;\\n        }\\n        return time(s.replace(\"01\", \"10\"),count+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565584,
                "title": "ruby-w-reduce",
                "content": "\\n```ruby\\n# @param {String} s\\n# @return {Integer}\\ndef seconds_to_remove_occurrences(s)\\n  s.each_char.reduce([0, 0]) {|(num_zeros, num_rounds), char|\\n    if char == \"0\"\\n      num_zeros += 1\\n    elsif num_zeros > 0\\n      num_rounds = [num_rounds + 1, num_zeros].max\\n    end\\n    [num_zeros, num_rounds]\\n  }[1]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {String} s\\n# @return {Integer}\\ndef seconds_to_remove_occurrences(s)\\n  s.each_char.reduce([0, 0]) {|(num_zeros, num_rounds), char|\\n    if char == \"0\"\\n      num_zeros += 1\\n    elsif num_zeros > 0\\n      num_rounds = [num_rounds + 1, num_zeros].max\\n    end\\n    [num_zeros, num_rounds]\\n  }[1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3540886,
                "title": "easy-in-java-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int c=0;\\n        while(s.contains(\"01\"))\\n        {\\n            String b=s.replace(\"01\",\"10\");\\n            s=b;\\n            c++;\\n            \\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int c=0;\\n        while(s.contains(\"01\"))\\n        {\\n            String b=s.replace(\"01\",\"10\");\\n            s=b;\\n            c++;\\n            \\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538129,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean flag = false;\\n\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        for (int i = 0; i < sb.length() - 1;) {\\n            if (sb.charAt(i) == \\'0\\' && sb.charAt(i + 1) == \\'1\\') {\\n                flag = true;\\n                swap(sb, i, i + 1);\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        if (!flag)\\n            return 0;\\n\\n        return 1 + secondsToRemoveOccurrences(sb.toString());\\n    }\\n\\n    private void swap(StringBuilder sb, int i, int j) {\\n        char temp = sb.charAt(i);\\n        sb.setCharAt(i, sb.charAt(j));\\n        sb.setCharAt(j, temp);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean flag = false;\\n\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        for (int i = 0; i < sb.length() - 1;) {\\n            if (sb.charAt(i) == \\'0\\' && sb.charAt(i + 1) == \\'1\\') {\\n                flag = true;\\n                swap(sb, i, i + 1);\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        if (!flag)\\n            return 0;\\n\\n        return 1 + secondsToRemoveOccurrences(sb.toString());\\n    }\\n\\n    private void swap(StringBuilder sb, int i, int j) {\\n        char temp = sb.charAt(i);\\n        sb.setCharAt(i, sb.charAt(j));\\n        sb.setCharAt(j, temp);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490329,
                "title": "solve-the-problem-in-typescript-it-s-very-inefficient-from-the-looks-of-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this algorithm is to use a recursive function to iterate over the string and replace all occurrences of \"01\" with \"10\". The recursive function starts by checking if the current character is less than the next character. If it is, then the recursive function replaces the current character and the next character with \"10\". The recursive function then recursively calls itself with the new string. The algorithm continues to recursively call itself until the string no longer contains any occurrences of \"01\".\\n\\nThe intuition behind this algorithm is that it is more efficient to replace all occurrences of \"01\" in one step than to do it one at a time. By using a recursive function, we can avoid having to do the same work over and over again.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe approach of this algorithm is to recursively iterate over the string and replace all occurrences of \"01\" with \"10\". The algorithm starts by calling the count() function with the original string. The count() function iterates over the string, and for each character, it checks if the next character is less than it. If the next character is less than it, then the count() function replaces the current character and the next character with \"10\". The count() function then recursively calls itself with the new string. The algorithm continues to recursively call itself until the string no longer contains any occurrences of \"01\". The number of steps taken by the algorithm is the number of times the count() function is called.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nThe time complexity of the algorithm is $$O(n)$$ where n is the length of the string, because it takes linear time to iterate over the string and replace all occurrences of \"01\" with \"10\".\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this algorithm is $$O(1)$$  because it only uses constant space to store the current string and the number of steps taken\\n\\n# Code\\n```\\nfunction secondsToRemoveOccurrences(s: string): number {\\n  let cnt = -1;\\n\\n  function count(s: string): number {\\n    cnt++;\\n    let str = s;\\n    let isValid = true;\\n    for (let i = 0; i < s.length; i++) {\\n      if (i < s.length - 1 && s[i] < s[i + 1]) {\\n        isValid = false;\\n        str = str.slice(0, i) + \"10\" + str.slice(i + 2);\\n      }\\n    }\\n    return isValid ? cnt : count(str);\\n  }\\n\\n  return count(s);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction secondsToRemoveOccurrences(s: string): number {\\n  let cnt = -1;\\n\\n  function count(s: string): number {\\n    cnt++;\\n    let str = s;\\n    let isValid = true;\\n    for (let i = 0; i < s.length; i++) {\\n      if (i < s.length - 1 && s[i] < s[i + 1]) {\\n        isValid = false;\\n        str = str.slice(0, i) + \"10\" + str.slice(i + 2);\\n      }\\n    }\\n    return isValid ? cnt : count(str);\\n  }\\n\\n  return count(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3489805,
                "title": "recursion-for-fun",
                "content": "\\n```\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\tif !strings.Contains(s, \"01\") {\\n\\t\\treturn 0\\t\\n\\t}\\n\\ts = strings.ReplaceAll(s, \"01\", \"10\")\\n\\treturn 1 + secondsToRemoveOccurrences(s)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\tif !strings.Contains(s, \"01\") {\\n\\t\\treturn 0\\t\\n\\t}\\n\\ts = strings.ReplaceAll(s, \"01\", \"10\")\\n\\treturn 1 + secondsToRemoveOccurrences(s)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486712,
                "title": "just-replace-01-with-10-until-end",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse while loop and str.replace 01 with 10 until no any 01 in str any more\\nand count how many loop executed \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nevery time search and replace will take n**2 time\\nand there are count time in loop so total time:**O(n**2*count)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)** as long as s\\n\\n# Code\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486711,
                "title": "just-replace-01-with-10-until-end",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse while loop and str.replace 01 with 10 until no any 01 in str any more\\nand count how many loop executed \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nevery time search and replace will take n**2 time\\nand there are count time in loop so total time:**O(n**2*count)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)** as long as s\\n\\n# Code\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482087,
                "title": "o-n-time-o-1-space-c-concise-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        while(i < n && s[i] == \\'1\\') i++;\\n        \\n        int cnt = 0, prev = 0;\\n        for(; i < n; i++){\\n            if(s[i] == \\'0\\') cnt++;\\n            else prev = max(prev+1, cnt);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        while(i < n && s[i] == \\'1\\') i++;\\n        \\n        int cnt = 0, prev = 0;\\n        for(; i < n; i++){\\n            if(s[i] == \\'0\\') cnt++;\\n            else prev = max(prev+1, cnt);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457443,
                "title": "easy-brute-force-and-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDone it Using brute force and simple sliding window with Every pass\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        start = 0\\n        n=[i for i in s]\\n        count = 0\\n        C = Counter(s)\\n        ones = C[\"1\"]\\n        dummy = [\"1\" for i in range(ones)]\\n        while n[:ones] != dummy:\\n            start = 0\\n            while start<len(n)-1:\\n                if n[start] == \"0\" and n[start+1] == \"1\":\\n                        n[start], n[start+1] = \"1\",\"0\"\\n                        start += 2\\n                else:\\n                    start+=1\\n            count+=1\\n            # print(n)\\n        return count\\n\\n                \\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        start = 0\\n        n=[i for i in s]\\n        count = 0\\n        C = Counter(s)\\n        ones = C[\"1\"]\\n        dummy = [\"1\" for i in range(ones)]\\n        while n[:ones] != dummy:\\n            start = 0\\n            while start<len(n)-1:\\n                if n[start] == \"0\" and n[start+1] == \"1\":\\n                        n[start], n[start+1] = \"1\",\"0\"\\n                        start += 2\\n                else:\\n                    start+=1\\n            count+=1\\n            # print(n)\\n        return count\\n\\n                \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414865,
                "title": "java-solution-brute-force-approach-dp-solution",
                "content": "### Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity: $$O(n^2)$$ $$replace() method takes O(n) for each replace $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Brute-Force Code\\n```\\nclass Solution {\\n    private int i;\\n    private int j;\\n    private boolean checkString(String s){\\n        while(i < s.length() && s.charAt(i) == \\'1\\') i++;\\n        while(j >= 0 && s.charAt(j) == \\'0\\') j--;\\n\\n        return !(i-1 == j);\\n    }\\n    public int secondsToRemoveOccurrences(String s) {\\n        i = 0; j = s.length()-1;\\n        int count = 0;\\n        if(s.length() == 1) return 0;\\n        while(checkString(s)){\\n            count++;\\n            s = s.replace(\"01\",\"10\");\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n### DP Code\\n\\n## \\uD83E\\uDEE1 Inspired by @[votrubac](https://leetcode.com/votrubac/)\\n## [code Link](https://leetcode.com/problems/time-needed-to-rearrange-a-binary-string/solutions/2454262/dp-vs-brute-force/?orderBy=most_votes)\\n\\n##### complexity :\\n- Time Compexity : $$O(n)$$\\n- Space Compexity : $$O(1)$$\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int second = 0;\\n        int n = s.length();\\n\\n        int zero = 0;\\n        for(int i=0; i<n; i++){\\n            zero += s.charAt(i) == \\'0\\' ? 1 : 0;\\n            if(s.charAt(i) == \\'1\\' && zero > 0){\\n                second = Math.max(second+1,zero);\\n            }\\n        }\\n        return second;\\n    }\\n}\\n```\\n\\n# Happy Coding \\uD83D\\uDC96",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int i;\\n    private int j;\\n    private boolean checkString(String s){\\n        while(i < s.length() && s.charAt(i) == \\'1\\') i++;\\n        while(j >= 0 && s.charAt(j) == \\'0\\') j--;\\n\\n        return !(i-1 == j);\\n    }\\n    public int secondsToRemoveOccurrences(String s) {\\n        i = 0; j = s.length()-1;\\n        int count = 0;\\n        if(s.length() == 1) return 0;\\n        while(checkString(s)){\\n            count++;\\n            s = s.replace(\"01\",\"10\");\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int second = 0;\\n        int n = s.length();\\n\\n        int zero = 0;\\n        for(int i=0; i<n; i++){\\n            zero += s.charAt(i) == \\'0\\' ? 1 : 0;\\n            if(s.charAt(i) == \\'1\\' && zero > 0){\\n                second = Math.max(second+1,zero);\\n            }\\n        }\\n        return second;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413225,
                "title": "easy-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c = 0\\n        while(\"01\" in s):\\n            s = s.replace(\"01\", \"10\")\\n            c += 1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c = 0\\n        while(\"01\" in s):\\n            s = s.replace(\"01\", \"10\")\\n            c += 1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375961,
                "title": "c-easy-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count1 = count(s.begin(),s.end(),\\'1\\');\\n        int count0 = count(s.begin(),s.end(),\\'0\\');\\n        string st = \"\";\\n        while(count1--) st += \\'1\\';\\n        while(count0--) st += \\'0\\';\\n        int count = 0;\\n        while(st != s){\\n            count++;\\n            for(int i = 0;i<s.length();i++){\\n                if(s.substr(i,2) == \"01\"){ \\n                    s.replace(i,2,\"10\");\\n                    i++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count1 = count(s.begin(),s.end(),\\'1\\');\\n        int count0 = count(s.begin(),s.end(),\\'0\\');\\n        string st = \"\";\\n        while(count1--) st += \\'1\\';\\n        while(count0--) st += \\'0\\';\\n        int count = 0;\\n        while(st != s){\\n            count++;\\n            for(int i = 0;i<s.length();i++){\\n                if(s.substr(i,2) == \"01\"){ \\n                    s.replace(i,2,\"10\");\\n                    i++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374059,
                "title": "python-o-n-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nJust like the brute force approach but using bit manipulation instead of transforming the string.\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        x = int(\\'0b\\' + s, 2)\\n        nums = [int(l) for l in s]\\n        n = len(nums)\\n        mask = (1 << n) - 1\\n\\n        # def transform(x):\\n        #     i = 0\\n        #     while i < n - 1:\\n        #         j = i + 1\\n        #         a = x[i]\\n        #         b = x[j]\\n        #         if a == 0 and b == 1:\\n        #             x[i] = 1\\n        #             x[j] = 0\\n        #             i += 1\\n        #         i += 1\\n        #     return x\\n\\n        def fast_transform(x):\\n            zero = ~x & mask\\n            next_one = (x << 1) & mask\\n            starting_ixs = zero & next_one & mask\\n            inv = ~(starting_ixs >> 1) & mask\\n            foo = (x | starting_ixs) & mask\\n            res = (foo & inv) & mask\\n            return res\\n\\n        ones = 0\\n        for l in s:\\n            if l == \\'1\\':\\n                ones += 1\\n        zeros = n - ones\\n        final = [1] * ones + [0] * zeros\\n        s_fin = \\'\\'.join([str(x) for x in final])\\n        y = int(\\'0b\\' + s_fin, 2)\\n\\n        res = 0\\n        while x != y:\\n            x = fast_transform(x)\\n            res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        x = int(\\'0b\\' + s, 2)\\n        nums = [int(l) for l in s]\\n        n = len(nums)\\n        mask = (1 << n) - 1\\n\\n        # def transform(x):\\n        #     i = 0\\n        #     while i < n - 1:\\n        #         j = i + 1\\n        #         a = x[i]\\n        #         b = x[j]\\n        #         if a == 0 and b == 1:\\n        #             x[i] = 1\\n        #             x[j] = 0\\n        #             i += 1\\n        #         i += 1\\n        #     return x\\n\\n        def fast_transform(x):\\n            zero = ~x & mask\\n            next_one = (x << 1) & mask\\n            starting_ixs = zero & next_one & mask\\n            inv = ~(starting_ixs >> 1) & mask\\n            foo = (x | starting_ixs) & mask\\n            res = (foo & inv) & mask\\n            return res\\n\\n        ones = 0\\n        for l in s:\\n            if l == \\'1\\':\\n                ones += 1\\n        zeros = n - ones\\n        final = [1] * ones + [0] * zeros\\n        s_fin = \\'\\'.join([str(x) for x in final])\\n        y = int(\\'0b\\' + s_fin, 2)\\n\\n        res = 0\\n        while x != y:\\n            x = fast_transform(x)\\n            res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359385,
                "title": "java-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  - O(n)\\n\\n- Space complexity:\\n  - O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0, time = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n\\n            if (ch == \\'0\\') zero++;\\n            if (ch == \\'1\\' && zero > 0)\\n                time = Math.max(time + 1, zero);\\n        }\\n\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0, time = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n\\n            if (ch == \\'0\\') zero++;\\n            if (ch == \\'1\\' && zero > 0)\\n                time = Math.max(time + 1, zero);\\n        }\\n\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303295,
                "title": "here-comes-the-brute-force-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    \\n\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int count=0;\\n\\n        while(s.find(\"01\")!=string::npos){\\n            count++;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n        } \\n        return count;\\n       \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    \\n\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int count=0;\\n\\n        while(s.find(\"01\")!=string::npos){\\n            count++;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n        } \\n        return count;\\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283278,
                "title": "c-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.length();\\n            int count=0,ans=0;\\n            for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n            while(count>0){\\n                    count=0;\\n                    for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n                    ans++;\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.length();\\n            int count=0,ans=0;\\n            for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n            while(count>0){\\n                    count=0;\\n                    for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n                    ans++;\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219765,
                "title": "simulation-python3-solution-o-n-2-time",
                "content": "```\\nclass Solution:\\n    \\n    \\n    def remove(self, s: List[int]) -> int:\\n        \\n        to_remove = []\\n        i = 0\\n        \\n        while i < len(s)-1:\\n            if s[i] == 0 and s[i+1] == 1:\\n                to_remove.append(i)\\n                i += 2\\n            else:\\n                i += 1\\n                \\n        for i in to_remove:\\n            s[i] = 1\\n            s[i+1] = 0\\n            \\n        return len(to_remove)\\n    \\n    \\n    # O(n^2) time,\\n    # O(n) space,\\n    # Approach: simulation, \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        s = [int(ch) for ch in s]\\n        time = 0\\n        \\n        while self.remove(s) > 0:\\n            time += 1\\n            \\n        return time\\n```",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    \\n    \\n    def remove(self, s: List[int]) -> int:\\n        \\n        to_remove = []\\n        i = 0\\n        \\n        while i < len(s)-1:\\n            if s[i] == 0 and s[i+1] == 1:\\n                to_remove.append(i)\\n                i += 2\\n            else:\\n                i += 1\\n                \\n        for i in to_remove:\\n            s[i] = 1\\n            s[i+1] = 0\\n            \\n        return len(to_remove)\\n    \\n    \\n    # O(n^2) time,\\n    # O(n) space,\\n    # Approach: simulation, \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        s = [int(ch) for ch in s]\\n        time = 0\\n        \\n        while self.remove(s) > 0:\\n            time += 1\\n            \\n        return time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206965,
                "title": "acc-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int cnt=0;\\n        \\n        char[] arr = s.toCharArray();\\n        while(true){\\n            int i=0,j=1;\\n            boolean flag=false;\\n             while(j<arr.length)\\n             {\\n                 if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                    flag=true;\\n                i++;j++;\\n             }\\n            if(!flag)\\n                break;\\n            cnt++;\\n            i=0;j=1;\\n            while(j<arr.length)\\n            {\\n                if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                {\\n                    arr[i]=\\'1\\'; arr[j]=\\'0\\';\\n                    i++;\\n                    j++;\\n                }\\n                    i++;j++;\\n            }\\n                       \\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int cnt=0;\\n        \\n        char[] arr = s.toCharArray();\\n        while(true){\\n            int i=0,j=1;\\n            boolean flag=false;\\n             while(j<arr.length)\\n             {\\n                 if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                    flag=true;\\n                i++;j++;\\n             }\\n            if(!flag)\\n                break;\\n            cnt++;\\n            i=0;j=1;\\n            while(j<arr.length)\\n            {\\n                if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                {\\n                    arr[i]=\\'1\\'; arr[j]=\\'0\\';\\n                    i++;\\n                    j++;\\n                }\\n                    i++;j++;\\n            }\\n                       \\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203109,
                "title": "java-brute-force-clear-explanations",
                "content": "# Approach\\n1. While there are replaces to be made, traverse the char[] chars of String from 0 to n and replace all 01 with 10. \\nAfter each loop, if changes have been made, increment the steps, break otherwise.\\n2. Return the number of steps.\\n\\n# Complexity\\n- Time complexity:$$O(n * n - worst-case)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] chrs = s.toCharArray();\\n        boolean swapped = true;\\n        int steps = 0;\\n        while(swapped) {\\n            swapped = false;\\n            for (int i = 0; i < s.length() - 1; i++) {       \\n                if (chrs[i] == \\'0\\' && chrs[i+1] == \\'1\\') {\\n                    chrs[i] = \\'1\\';\\n                    chrs[i+1] = \\'0\\';\\n                    i++;\\n                    swapped = true;\\n                }\\n            }\\n            if(swapped) {\\n                steps++;\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] chrs = s.toCharArray();\\n        boolean swapped = true;\\n        int steps = 0;\\n        while(swapped) {\\n            swapped = false;\\n            for (int i = 0; i < s.length() - 1; i++) {       \\n                if (chrs[i] == \\'0\\' && chrs[i+1] == \\'1\\') {\\n                    chrs[i] = \\'1\\';\\n                    chrs[i+1] = \\'0\\';\\n                    i++;\\n                    swapped = true;\\n                }\\n            }\\n            if(swapped) {\\n                steps++;\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196527,
                "title": "easy-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size() , count = 0 , flag = 0 ;\\n        while(1)\\n        {\\n            flag = 0 ;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i] = \\'1\\' ;\\n                    s[i+1] = \\'0\\' ;\\n                    flag = 1 ;\\n                    i++ ;\\n                }\\n            }\\n            if(flag==0){\\n                break ;\\n            }\\n            count++ ;\\n        }\\n        return count ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size() , count = 0 , flag = 0 ;\\n        while(1)\\n        {\\n            flag = 0 ;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i] = \\'1\\' ;\\n                    s[i+1] = \\'0\\' ;\\n                    flag = 1 ;\\n                    i++ ;\\n                }\\n            }\\n            if(flag==0){\\n                break ;\\n            }\\n            count++ ;\\n        }\\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194877,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] ch =s.toCharArray();\\n        int count=0;\\n        for(int i=0; i<s.length();i++){\\n            boolean check=true;\\n            int j=0;\\n            while(j<s.length()-1){\\n                if(ch[j]==\\'0\\' && ch[j+1]==\\'1\\'){\\n                    check=false;\\n                    swapped(ch,j,j+1);\\n                    j=j+2;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            if(check==false)count++;\\n            if(check==true) return count;\\n        \\n        }\\n        return count;\\n    }\\n    private void swapped(char[] ch,int i, int j){\\n        char temp=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] ch =s.toCharArray();\\n        int count=0;\\n        for(int i=0; i<s.length();i++){\\n            boolean check=true;\\n            int j=0;\\n            while(j<s.length()-1){\\n                if(ch[j]==\\'0\\' && ch[j+1]==\\'1\\'){\\n                    check=false;\\n                    swapped(ch,j,j+1);\\n                    j=j+2;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            if(check==false)count++;\\n            if(check==true) return count;\\n        \\n        }\\n        return count;\\n    }\\n    private void swapped(char[] ch,int i, int j){\\n        char temp=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187791,
                "title": "worst-solution-for-java-aasheesh-63th-day",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![UP vote ki bhik.jpeg](https://assets.leetcode.com/users/images/25b0befb-f6d4-46b1-baa8-c0a53ef3f36d_1676440598.5032725.jpeg)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0;\\n        while (s.contains(\"01\")){\\n            s = s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0;\\n        while (s.contains(\"01\")){\\n            s = s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166454,
                "title": "easy-python-dp-n-time-complexity",
                "content": "Each \"1\" has a predetermined slot. What will the time be to get a 1 to its slot? \\n\\nBest case is if there is no other \"1\" blocking it in front, then it can move along without delay. Assume j is its predetermined slot, then simply i-j will be the time. \\n\\nWhat if there are \"1\"s in front of it? What if there are multiple delays of blocking \"1\"s. You only have to care about the prev \"1\". This is because it\\'s delay will also take into account the other previous \"1\"s blocking it. So how long to wait? Just +1 because once the prev 1 move, each turn the previous 1 and the current 1 can move simultaneously. \\n\\n\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n        nearestOneTime=0\\n        j=0\\n        \\n        \\n        for i in range(len(s)):\\n            if s[i]==\"1\":\\n                if i!=j:\\n                    nearestOneTime=max(nearestOneTime+1,i-j)\\n                j+=1\\n        \\n        return nearestOneTime",
                "solutionTags": [],
                "code": "Each \"1\" has a predetermined slot. What will the time be to get a 1 to its slot? \\n\\nBest case is if there is no other \"1\" blocking it in front, then it can move along without delay. Assume j is its predetermined slot, then simply i-j will be the time. \\n\\nWhat if there are \"1\"s in front of it? What if there are multiple delays of blocking \"1\"s. You only have to care about the prev \"1\". This is because it\\'s delay will also take into account the other previous \"1\"s blocking it. So how long to wait? Just +1 because once the prev 1 move, each turn the previous 1 and the current 1 can move simultaneously. \\n\\n\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n        nearestOneTime=0\\n        j=0\\n        \\n        \\n        for i in range(len(s)):\\n            if s[i]==\"1\":\\n                if i!=j:\\n                    nearestOneTime=max(nearestOneTime+1,i-j)\\n                j+=1\\n        \\n        return nearestOneTime",
                "codeTag": "Java"
            },
            {
                "id": 3159238,
                "title": "super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int time=0;\\n        int f=1;\\n        int n=s.size();\\n        while(f)\\n        {\\n            int flag=0;\\n            for(int x=0; x<n-1; x++)\\n            {\\n                if(s[x]==\\'0\\' && s[x+1]==\\'1\\')\\n                {\\n                    s[x]=\\'1\\';\\n                    s[x+1]=\\'0\\';\\n                    x++;\\n                    flag=1;\\n                }\\n            }\\n            if(flag) time++;\\n            else f=0;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int time=0;\\n        int f=1;\\n        int n=s.size();\\n        while(f)\\n        {\\n            int flag=0;\\n            for(int x=0; x<n-1; x++)\\n            {\\n                if(s[x]==\\'0\\' && s[x+1]==\\'1\\')\\n                {\\n                    s[x]=\\'1\\';\\n                    s[x+1]=\\'0\\';\\n                    x++;\\n                    flag=1;\\n                }\\n            }\\n            if(flag) time++;\\n            else f=0;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137643,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int res=0,c=1;\\n        while(c==1)\\n        {\\n            c=0;\\n            int i=0;\\n            string s1 = s;  //take a copy of string \\n            while(i<s.size()-1)\\n            {\\n                \\n                if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n                {\\n                    swap(s1[i],s1[i+1]);\\n                    c=1;\\n                }\\n                i++;\\n            }\\n            s = s1;\\n            res += c;\\n            //cout<<s<<endl;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int res=0,c=1;\\n        while(c==1)\\n        {\\n            c=0;\\n            int i=0;\\n            string s1 = s;  //take a copy of string \\n            while(i<s.size()-1)\\n            {\\n                \\n                if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n                {\\n                    swap(s1[i],s1[i+1]);\\n                    c=1;\\n                }\\n                i++;\\n            }\\n            s = s1;\\n            res += c;\\n            //cout<<s<<endl;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3122250,
                "title": "easy-brute-force-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        if(s.size() == 1) \\n            return 0;\\n\\n        int ans = 0;\\n        int flag = 0;\\n\\n        while(true) {\\n            flag = 0;\\n            for(int i=0; i<s.size()-1; i++) {\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\') {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    flag = 1;\\n                    i++;\\n                } \\n            }\\n            if(flag == 0) break;\\n            else ans++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        if(s.size() == 1) \\n            return 0;\\n\\n        int ans = 0;\\n        int flag = 0;\\n\\n        while(true) {\\n            flag = 0;\\n            for(int i=0; i<s.size()-1; i++) {\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\') {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    flag = 1;\\n                    i++;\\n                } \\n            }\\n            if(flag == 0) break;\\n            else ans++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104832,
                "title": "c-easy-simple-solution",
                "content": "# Dont forget to give it upvote if you like the solution\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans=0 , n =s.size();\\n\\n        while( true){\\n            bool fl=true;\\n            for( int i =1 ; i< n ; i++){\\n                if( s[i-1]==\\'0\\' and s[i]==\\'1\\'){\\n                    swap(s[i-1], s[i]);\\n                    i++;\\n                    fl=false;   \\n                }\\n            }\\n             if( !fl)ans++;\\n             if( fl)break;\\n        }\\n        return ans; \\n    }\\n};\\n```\\n\\n![you-upvote-me.webp](https://assets.leetcode.com/users/images/55fd002e-b472-4a22-ac71-3205b8775a2e_1674813108.8949456.webp)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans=0 , n =s.size();\\n\\n        while( true){\\n            bool fl=true;\\n            for( int i =1 ; i< n ; i++){\\n                if( s[i-1]==\\'0\\' and s[i]==\\'1\\'){\\n                    swap(s[i-1], s[i]);\\n                    i++;\\n                    fl=false;   \\n                }\\n            }\\n             if( !fl)ans++;\\n             if( fl)break;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094520,
                "title": "simple-cpp-datta-bayo",
                "content": "Simple BrutForce Solution nothing tough go throgh one dry run you will get it buddy. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n         if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        bool check=true;\\n        for(int i=s.length()-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n        }\\n        int occr_remv=0;\\n        while(check)\\n        {\\n             for(int i=s.length()-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n             for(int i=s.length()-2;i>=0;i--)\\n           {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n            }\\n            occr_remv++;\\n        }\\n        return occr_remv;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n         if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        bool check=true;\\n        for(int i=s.length()-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n        }\\n        int occr_remv=0;\\n        while(check)\\n        {\\n             for(int i=s.length()-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n             for(int i=s.length()-2;i>=0;i--)\\n           {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n            }\\n            occr_remv++;\\n        }\\n        return occr_remv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086280,
                "title": "concise-java-solution-using-inbuilt-function",
                "content": "\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(true){\\n            int idx=s.indexOf(\"01\");\\n            if(idx==-1)break;\\n            else{\\n                s=s.replaceAll(\"01\",\"10\");\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(true){\\n            int idx=s.indexOf(\"01\");\\n            if(idx==-1)break;\\n            else{\\n                s=s.replaceAll(\"01\",\"10\");\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057262,
                "title": "c-solution",
                "content": "```\\nint secondsToRemoveOccurrences(char * s){\\n    int i, len = strlen(s), flag = 1, times = 0;\\n\\n    if (len == 1)\\n        return 0;\\n\\n    while (flag) {\\n        flag = 0;\\n        for (i = 0; i < len - 1; i++) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                flag = 1;\\n                char temp = s[i];\\n                s[i] = s[i + 1];\\n                s[i + 1] = temp;\\n                i++;\\n            }\\n        }\\n\\n        times++;\\n    }\\n\\n    return times - 1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(char * s){\\n    int i, len = strlen(s), flag = 1, times = 0;\\n\\n    if (len == 1)\\n        return 0;\\n\\n    while (flag) {\\n        flag = 0;\\n        for (i = 0; i < len - 1; i++) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                flag = 1;\\n                char temp = s[i];\\n                s[i] = s[i + 1];\\n                s[i + 1] = temp;\\n                i++;\\n            }\\n        }\\n\\n        times++;\\n    }\\n\\n    return times - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3040964,
                "title": "hindi-version-c-easy-approach",
                "content": "The post is in hindi because there are very less post written in HINDI language.\\n\\n# Approach\\nSimply har baar string mein last se traverse karke check karenge ki kya \\'01\\' present hai agar present hai toh replacements karne honge warna number of seconds ko return kardenge. Code mein comments ke through explain kiya hai ek baar read karo and dry run karo saath mein ek case lekar.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*N) because worst case 01111 hoga is par dry run karo toh tumhe pata chalega ki string ke through N times jaana padega 0 last position par le jaane ke liye\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        // Pehle if condition mein 2 cases ko dekh rahe hai : \\n        // Case-1 : agar string ki length 1 hai toh number of seconds 0 honge\\n        // Case-2 : agar string ki length 2 hai toh hume ye check karna hoga ki 0th index par 1 hoga and 1th postion par 0 hoga toh number of seconds 0 honge warna number of seconds 1 honge\\n        if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        int n = s.size();\\n        bool flag = true;\\n        int count = 0;\\n        // last se traverse karke ye check karenge ki kya koyi index aesa hai jispar \\'0\\' hai and next index par \\'1\\' hai and agar aesa nahi hai toh number of seconds 0 honge because replace karna hi nahi hoga\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\' && ch2==\\'1\\')\\n            {\\n                flag = true;\\n                break;\\n            }\\n            else\\n            {\\n                flag = false;\\n            }\\n        }\\n        // agar string mein \\'01\\' hai toh replace karne ki try karenge and replace karnege jahan bhi \\'01\\' milega and swap kardenge\\n        while(flag)\\n        {\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n            // string ko traverse karke ke swap karne ke baad phirse check karenge agar \\'01\\' hai phirse toh replace karne jaana padega warna loop se break hojaayenge\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                else\\n                {\\n                    flag = false;\\n                }\\n            }\\n            // pure string ke through traverse karne ke baad hi ek second count hoga because 1 baar string ke through traverse karke replacement karne mein 1 second keh rahe hai\\n            ++count;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n\\nAgar approach samajh aayi ho and kuch help mili ho toh please upvote karna!!!",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        // Pehle if condition mein 2 cases ko dekh rahe hai : \\n        // Case-1 : agar string ki length 1 hai toh number of seconds 0 honge\\n        // Case-2 : agar string ki length 2 hai toh hume ye check karna hoga ki 0th index par 1 hoga and 1th postion par 0 hoga toh number of seconds 0 honge warna number of seconds 1 honge\\n        if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        int n = s.size();\\n        bool flag = true;\\n        int count = 0;\\n        // last se traverse karke ye check karenge ki kya koyi index aesa hai jispar \\'0\\' hai and next index par \\'1\\' hai and agar aesa nahi hai toh number of seconds 0 honge because replace karna hi nahi hoga\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\' && ch2==\\'1\\')\\n            {\\n                flag = true;\\n                break;\\n            }\\n            else\\n            {\\n                flag = false;\\n            }\\n        }\\n        // agar string mein \\'01\\' hai toh replace karne ki try karenge and replace karnege jahan bhi \\'01\\' milega and swap kardenge\\n        while(flag)\\n        {\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n            // string ko traverse karke ke swap karne ke baad phirse check karenge agar \\'01\\' hai phirse toh replace karne jaana padega warna loop se break hojaayenge\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                else\\n                {\\n                    flag = false;\\n                }\\n            }\\n            // pure string ke through traverse karne ke baad hi ek second count hoga because 1 baar string ke through traverse karke replacement karne mein 1 second keh rahe hai\\n            ++count;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025011,
                "title": "string-replace-easy-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        String temp=s.replace(\"01\",\"10\");\\n        if(temp.compareTo(s)==0) return 0;\\n        int cnt=0;\\n        while(temp.compareTo(s)!=0){\\n            s=temp;\\n            temp=s.replace(\"01\",\"10\");\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        String temp=s.replace(\"01\",\"10\");\\n        if(temp.compareTo(s)==0) return 0;\\n        int cnt=0;\\n        while(temp.compareTo(s)!=0){\\n            s=temp;\\n            temp=s.replace(\"01\",\"10\");\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015272,
                "title": "easy-to-understand-python-o-n-time-o-1-space",
                "content": "```\\n    def secondsToRemoveOccurrences(self, s):\\n        \\n        p = \\'01\\'\\n        c = 0\\n        \\n        if p not in s: return 0\\n        else:\\n            while p in s:\\n                s = s.replace(p, \\'10\\')\\n                c += 1\\n        \\n            return c\\n```\\nRuntime: 52.17%\\nMemory: 45.65%",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def secondsToRemoveOccurrences(self, s):\\n        \\n        p = \\'01\\'\\n        c = 0\\n        \\n        if p not in s: return 0\\n        else:\\n            while p in s:\\n                s = s.replace(p, \\'10\\')\\n                c += 1\\n        \\n            return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2976460,
                "title": "simple-java",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n\\n        int count=0;\\n       while(s.indexOf(\"01\")>-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++; \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n\\n        int count=0;\\n       while(s.indexOf(\"01\")>-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++; \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925364,
                "title": "recursive-scala-solution",
                "content": "\\n```\\nobject Solution {\\n    def secondsToRemoveOccurrences(s: String): Int = {\\n        def loop(s: String, acc: Int): Int = s match {\\n            case s if s.sliding(2).count(_.contains(\"01\")) == 0 => acc\\n            case _                                              => loop(s.replace(\"01\", \"10\"), acc + 1)\\n        }\\n\\n        loop(s, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def secondsToRemoveOccurrences(s: String): Int = {\\n        def loop(s: String, acc: Int): Int = s match {\\n            case s if s.sliding(2).count(_.contains(\"01\")) == 0 => acc\\n            case _                                              => loop(s.replace(\"01\", \"10\"), acc + 1)\\n        }\\n\\n        loop(s, 0)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2911314,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0, n = s.length();\\n        while (true) {\\n            bool b = false;\\n            for (int i = 0; i < n - 1; ++i) {\\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                    s[i++] = \\'1\\';\\n                    s[i] = \\'0\\';\\n                    b = true;\\n                }\\n            }\\n\\n            if (!b) {\\n                break;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0, n = s.length();\\n        while (true) {\\n            bool b = false;\\n            for (int i = 0; i < n - 1; ++i) {\\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                    s[i++] = \\'1\\';\\n                    s[i] = \\'0\\';\\n                    b = true;\\n                }\\n            }\\n\\n            if (!b) {\\n                break;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903199,
                "title": "dart-implementation-o-n-time-o-1-space",
                "content": "# Intuition\\nSimple observation - every second we move \"1\" to the left whenever there is a \"0\" on the left side. If not and there are continues \"11111\" - the rightmost \"1\" waits number of seconds equal to the length of the \"train of 1\" till at least one zero comes on the left and we can start moving it. \\nSo for every \"1\" we can calculate two variables - number of 0-s to swap with and number of 1-s to wait for. Solution if the max( 0-s + 1-s) :-)\\n\\n\\n\\n# Approach\\nAt first we can clean the input string from the leading \"1\"s and tailing \"0\"\\'s since they do not affect result.\\n\\nThen iterate through the remaining string and calculate two variables mentioned above- zero - number of zeros up to the index i, and dup - number of continues \"11111\" to wait for (increased whenever we meet \"11\" and decreased whenever we meet \"00\"). \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n\\nclass Solution {\\n  int secondsToRemoveOccurrences(String s) {\\n    int rem1 = s.indexOf(\\'0\\');\\n    int rem0 = s.codeUnits.lastIndexOf(\"1\".codeUnitAt(0));\\n    if (rem1 == -1 || rem0 == -1 || rem0 == rem1 - 1) return 0;\\n    s = s.substring(rem1, rem0 + 1);\\n\\n    int N = s.length;\\n    int zero = 0;\\n    int dup = 0;\\n    zero = s[0] == \\'0\\' ? 1 : 0;\\n\\n    int res = 0;\\n    for (int i = 1; i < N; i++) {\\n      int dupDelta = 0;\\n      if (s[i] == \\'1\\' && s[i - 1] == \\'1\\')\\n        dupDelta = 1;\\n      else if (s[i] == \\'0\\' && s[i - 1] == \\'0\\') dupDelta = -1;\\n\\n      zero = zero + (s[i] == \\'0\\' ? 1 : 0);\\n      dup = max(0, dup + dupDelta);\\n      res = max(res, zero + dup);\\n    }\\n\\n    return res;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n\\nclass Solution {\\n  int secondsToRemoveOccurrences(String s) {\\n    int rem1 = s.indexOf(\\'0\\');\\n    int rem0 = s.codeUnits.lastIndexOf(\"1\".codeUnitAt(0));\\n    if (rem1 == -1 || rem0 == -1 || rem0 == rem1 - 1) return 0;\\n    s = s.substring(rem1, rem0 + 1);\\n\\n    int N = s.length;\\n    int zero = 0;\\n    int dup = 0;\\n    zero = s[0] == \\'0\\' ? 1 : 0;\\n\\n    int res = 0;\\n    for (int i = 1; i < N; i++) {\\n      int dupDelta = 0;\\n      if (s[i] == \\'1\\' && s[i - 1] == \\'1\\')\\n        dupDelta = 1;\\n      else if (s[i] == \\'0\\' && s[i - 1] == \\'0\\') dupDelta = -1;\\n\\n      zero = zero + (s[i] == \\'0\\' ? 1 : 0);\\n      dup = max(0, dup + dupDelta);\\n      res = max(res, zero + dup);\\n    }\\n\\n    return res;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902460,
                "title": "simple-solution",
                "content": "# Approach\\nRepeat replacing all `\"01\"` with `\"10\"` until all is done. Count and return the times that this process is executed \\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        seconds = 0\\n        while \\'01\\' in s:\\n            seconds += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n        \\n        return seconds\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        seconds = 0\\n        while \\'01\\' in s:\\n            seconds += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n        \\n        return seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889075,
                "title": "no-string-replace-o-n-time-o-1-space-solution",
                "content": "# Intuition\\nTook me a while and a few iterations to get here. If current 1 encounters or gets blocked the previous 1, then the answer is one more than the previous one. Whether or not current 1 encounters a previous 1 depends on the number of 0s before it.\\n\\n# Approach\\nSimple for loop that keeps track of num0s and previous ans to compute the current answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int num0s = 0, ans = 0;\\n        for (char ch : s) {\\n            if (ch == \\'0\\') {\\n                num0s++;\\n                continue;\\n            }\\n            // ignore the 1s if there are no 0s.\\n            if (num0s == 0) continue;\\n            ans = max(ans + 1, num0s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int num0s = 0, ans = 0;\\n        for (char ch : s) {\\n            if (ch == \\'0\\') {\\n                num0s++;\\n                continue;\\n            }\\n            // ignore the 1s if there are no 0s.\\n            if (num0s == 0) continue;\\n            ans = max(ans + 1, num0s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876822,
                "title": "easy-and-clean-solution-using-simple-approach",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean changed = true;\\n        char [] ch = s.toCharArray();\\n        int count = 0;\\n        while(changed)\\n        {\\n            changed = false;\\n            for(int i = 0; i < ch.length-1;i++)\\n            {\\n                if(ch[i] == \\'0\\' && ch[i+1] == \\'1\\')\\n                {\\n                    ch[i] = \\'1\\';\\n                    ch[i+1] = \\'0\\';\\n                    changed = true;\\n                    i++;\\n                }\\n            }\\n            if(changed)\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean changed = true;\\n        char [] ch = s.toCharArray();\\n        int count = 0;\\n        while(changed)\\n        {\\n            changed = false;\\n            for(int i = 0; i < ch.length-1;i++)\\n            {\\n                if(ch[i] == \\'0\\' && ch[i+1] == \\'1\\')\\n                {\\n                    ch[i] = \\'1\\';\\n                    ch[i+1] = \\'0\\';\\n                    changed = true;\\n                    i++;\\n                }\\n            }\\n            if(changed)\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869692,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int zero=0,second=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            zero+=(s[i]==\\'0\\');\\n            if(s[i]==\\'1\\'&&zero)\\n            {\\n                second=max(second+1,zero);\\n            }\\n        }\\n        return second;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int zero=0,second=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            zero+=(s[i]==\\'0\\');\\n            if(s[i]==\\'1\\'&&zero)\\n            {\\n                second=max(second+1,zero);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2858463,
                "title": "o-n-time-o-1-space",
                "content": "# Intuition\\nBased on the description, I realized that the result would always be of the form 111...111000...000. Therefore, I just tried a few examples until I got the pattern and condensed it into a dp solution. Here are 3 examples that I tried that helped me:\\n\\nConsider \"10001\". In this case, it takes the number of zeros\\' seconds, 3 shifts of the 1 to the left to get to \"11000\"\\n\\nNext, consider \"10011\". In this case, we need 2 seconds for the zeros and an additional second for the 1 on the far right. Visually, it looks like this (with a \"wait\" second for the farthest right 1):\\n    10011 -> (\"furthest right waits 1 second\") 10101 -> 11010 -> 11100\\n\\nLastly, consider \"1100011101\". If we just do the arduous work, we can see it takes 6 seconds:\\n    1100011101 -> 1100101110 -> 1101010110 -> 1110101010 -> 1111010100 -> 1111101000 -> 1111110000\\nBreaking it down at each step, as we encounter a 0, that adds one second to the solution, however, each subsequent 1 could potentially add an additional second to the solution depending on the number of zeros we have encountered thus far. Taking the max of each suffices.\\n\\nLastly, our corner cases to explain the if statement in my code: 11111, 111000\\nThe problem states that s[i] is either \\'0\\' or \\'1\\', but doesn\\'t state there have to be both. In either case, the same if statement catches both. Namely, we don\\'t encounter any 0\\'s before 1\\'s, hence the result is 0.\\n\\n# Approach\\n```\\n1. Loop through each character in s\\n2. Increment our total zeros found\\n3. If we reach a 1, and have encountered at least a single 0, update our result to be the max(result+1, zeros)\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ where $$n$$ is the length of $$s$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SecondsToRemoveOccurrences(string s) {\\n        if (string.IsNullOrWhiteSpace(s)) {\\n            return 0;\\n        }\\n\\n        int result = 0;\\n        int zeros = 0;\\n        foreach (char c in s) {\\n            zeros += c == \\'0\\' ? 1 : 0;\\n            if (c == \\'1\\' && zeros > 0) {\\n                result = Math.Max(result+1, zeros);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\n1. Loop through each character in s\\n2. Increment our total zeros found\\n3. If we reach a 1, and have encountered at least a single 0, update our result to be the max(result+1, zeros)\\n```\n```\\npublic class Solution {\\n    public int SecondsToRemoveOccurrences(string s) {\\n        if (string.IsNullOrWhiteSpace(s)) {\\n            return 0;\\n        }\\n\\n        int result = 0;\\n        int zeros = 0;\\n        foreach (char c in s) {\\n            zeros += c == \\'0\\' ? 1 : 0;\\n            if (c == \\'1\\' && zeros > 0) {\\n                result = Math.Max(result+1, zeros);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857310,
                "title": "easy-to-understand-python-solution-5-lines",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n            \\'\\'\\'\\n            while 01 exists in the string, perform some operation\\n            \\n            \\'\\'\\'\\n            count = 0\\n            while s.find(\\'01\\') != -1:\\n                count += 1 \\n                s = s.replace(\"01\", \"10\")\\n            return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n            \\'\\'\\'\\n            while 01 exists in the string, perform some operation\\n            \\n            \\'\\'\\'\\n            count = 0\\n            while s.find(\\'01\\') != -1:\\n                count += 1 \\n                s = s.replace(\"01\", \"10\")\\n            return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854756,
                "title": "video-walkthrough-three-line-solution-python-o-n",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/c9FPc5GNROI)\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        zeros, seconds = 0, 0\\n        for c in s:\\n            if c ==  \\'0\\': zeros += 1\\n            elif zeros: seconds = max(1 + seconds, zeros)\\n        return seconds\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        zeros, seconds = 0, 0\\n        for c in s:\\n            if c ==  \\'0\\': zeros += 1\\n            elif zeros: seconds = max(1 + seconds, zeros)\\n        return seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851409,
                "title": "python3-intelligent-tracking-of-0s",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        boundary = len(s)\\n        arr = list(s)\\n        ts=0\\n        zeros = deque()\\n        for idx,num in enumerate(arr):\\n\\t\\t\\t#if this is 01 keep track of this index\\n            if num==\\'0\\' and idx+1<boundary and arr[idx+1]==\\'1\\':\\n                zeros.append(idx)\\n                \\n        iterations = len(zeros)\\n        while zeros:\\n            iterations = len(zeros)\\n            ts+=1\\n            for _ in range(iterations):\\n                first = zeros.popleft()\\n                arr[first], arr[first+1] = arr[first+1], arr[first]\\n\\t\\t\\t\\t#if theres a 01 in front after the swap keep track of first+1\\n                if first+2<boundary and arr[first+2]==\\'1\\':\\n                    zeros.append(first+1)\\n\\t\\t\\t\\t#if there\\'s a 0 behind after the swap keep track of that zero\\n                if first-1>=0 and arr[first-1]==\\'0\\':\\n                    zeros.append(first-1)\\n\\n        return ts\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        boundary = len(s)\\n        arr = list(s)\\n        ts=0\\n        zeros = deque()\\n        for idx,num in enumerate(arr):\\n\\t\\t\\t#if this is 01 keep track of this index\\n            if num==\\'0\\' and idx+1<boundary and arr[idx+1]==\\'1\\':\\n                zeros.append(idx)\\n                \\n        iterations = len(zeros)\\n        while zeros:\\n            iterations = len(zeros)\\n            ts+=1\\n            for _ in range(iterations):\\n                first = zeros.popleft()\\n                arr[first], arr[first+1] = arr[first+1], arr[first]\\n\\t\\t\\t\\t#if theres a 01 in front after the swap keep track of first+1\\n                if first+2<boundary and arr[first+2]==\\'1\\':\\n                    zeros.append(first+1)\\n\\t\\t\\t\\t#if there\\'s a 0 behind after the swap keep track of that zero\\n                if first-1>=0 and arr[first-1]==\\'0\\':\\n                    zeros.append(first-1)\\n\\n        return ts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850116,
                "title": "here-is-javascript-solution",
                "content": "```\\n\\n```var secondsToRemoveOccurrences = function(s) {\\n    let count=0\\n\\n  while(s.indexOf(\"01\")!=-1)\\n    {\\n        ar=s.split(\"\")\\n        for(let i=0;i<ar.length;i++)\\n            {\\n                if(ar[i]==\"0\" && ar[i+1]==\"1\" )\\n                    {\\n                        ar[i]=\"1\"\\n                        ar[i+1]=\"0\"\\n                        i++\\n                    }\\n            }\\n      \\n      s=ar.join(\"\")\\n      count++\\n   }\\n    return count\\n    \\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2848029,
                "title": "easiest-java-solution-java",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s)\\n    {\\n        StringBuilder sb=new StringBuilder(s);\\n        int k=1;\\n        int count=0;\\n        while(sb.indexOf(\"01\")!=-1)\\n        {\\n            for(int i=sb.indexOf(\"01\");i<sb.length()-1;i+=k)\\n            {\\n                if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\')\\n                {\\n                    sb.setCharAt(i,\\'1\\');\\n                    sb.setCharAt(i+1,\\'0\\');\\n                    k=2;\\n                }\\n                else\\n                {\\n                    k=1;\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s)\\n    {\\n        StringBuilder sb=new StringBuilder(s);\\n        int k=1;\\n        int count=0;\\n        while(sb.indexOf(\"01\")!=-1)\\n        {\\n            for(int i=sb.indexOf(\"01\");i<sb.length()-1;i+=k)\\n            {\\n                if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\')\\n                {\\n                    sb.setCharAt(i,\\'1\\');\\n                    sb.setCharAt(i+1,\\'0\\');\\n                    k=2;\\n                }\\n                else\\n                {\\n                    k=1;\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837892,
                "title": "simple-well-explained-c-solution",
                "content": "- After completely swapping all the \\'01\\' to \\'10\\', at the end we will get a sorted string in such a way that all the 1\\'s will come before all the 0\\'s. Eg. if a string is \"10111000\" it will become \"11110000\" at the end.\\n- So we will make a temporary string equal to the string we will obtain at the end and run a loop until our original string becomes equal to that string.\\n- Then in each iteration of while loop we will maintain the indices of the 0\\'s who have 1 as the next element and swap them all at once and increment the time needed by 1.\\n- Doing so will give us the answer. \\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        string temp = s;\\n        sort(temp.begin(),temp.end());\\n        reverse(temp.begin(),temp.end());\\n        while(s!=temp){\\n            vector<int> v;\\n            for(int i = 0;i<s.length()-1;i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    v.push_back(i);\\n                }\\n            }\\n            for(int i = 0;i<v.size();i++){\\n                swap(s[v[i]],s[v[i]+1]);\\n            }\\n            ans++;\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        string temp = s;\\n        sort(temp.begin(),temp.end());\\n        reverse(temp.begin(),temp.end());\\n        while(s!=temp){\\n            vector<int> v;\\n            for(int i = 0;i<s.length()-1;i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    v.push_back(i);\\n                }\\n            }\\n            for(int i = 0;i<v.size();i++){\\n                swap(s[v[i]],s[v[i]+1]);\\n            }\\n            ans++;\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805690,
                "title": "brute-force-recursion-2-solutions",
                "content": "### **Brute Force Easy One Two While**\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        while(1)\\n        {\\n            int k=0,i=0;\\n            while(i<s.size())\\n            {\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n                {\\n                    swap(s[i],s[i+1]);\\n                    k++;\\n                    i+=2;\\n                }\\n                else\\n                    i++;\\n            }\\n            if(k==0)return res;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n#### **Recursion Easy Solution Function calling**\\n```\\nclass Solution \\n{\\npublic:\\n    int solvethis(string s,int res)\\n    {\\n        int i=0,k=0;\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n            {\\n                swap(s[i],s[i+1]);\\n                k++;\\n                i+=2;\\n            }\\n            else i++;\\n        }\\n        if(k==0)return res;\\n        return solvethis(s,res+1);\\n    }\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        return solvethis(s,res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        while(1)\\n        {\\n            int k=0,i=0;\\n            while(i<s.size())\\n            {\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n                {\\n                    swap(s[i],s[i+1]);\\n                    k++;\\n                    i+=2;\\n                }\\n                else\\n                    i++;\\n            }\\n            if(k==0)return res;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int solvethis(string s,int res)\\n    {\\n        int i=0,k=0;\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n            {\\n                swap(s[i],s[i+1]);\\n                k++;\\n                i+=2;\\n            }\\n            else i++;\\n        }\\n        if(k==0)return res;\\n        return solvethis(s,res+1);\\n    }\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        return solvethis(s,res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794996,
                "title": "normal-solution-for-javascript",
                "content": "var secondsToRemoveOccurrences = function (s) {\\n  let res = 0;\\n  while (s.includes(\\'01\\')) {\\n    const arrs = s.split(\\'\\');\\n    for (let i = 0; i < arrs.length; i++) {\\n      if (arrs[i + 1] && arrs[i] === \\'0\\' && arrs[i + 1] === \\'1\\') {\\n        arrs[i] = \\'1\\';\\n        arrs[i + 1] = \\'0\\';\\n        i++;\\n      }\\n    }\\n    s = arrs.join(\\'\\');\\n    res++;\\n  }\\n  return res\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var secondsToRemoveOccurrences = function (s) {\\n  let res = 0;\\n  while (s.includes(\\'01\\')) {\\n    const arrs = s.split(\\'\\');\\n    for (let i = 0; i < arrs.length; i++) {\\n      if (arrs[i + 1] && arrs[i] === \\'0\\' && arrs[i + 1] === \\'1\\') {\\n        arrs[i] = \\'1\\';\\n        arrs[i + 1] = \\'0\\';\\n        i++;\\n      }\\n    }\\n    s = arrs.join(\\'\\');\\n    res++;\\n  }\\n  return res\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2764667,
                "title": "c-o-n-simple-and-intuitive-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int lz = 0; //zeros to left\\n        int wt = 0; // additional wait time for one\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == \\'0\\') {\\n                wt = max(0, wt - 1);\\n                ++lz;\\n            }\\n            else {\\n                if(lz == 0)\\n                    continue;\\n                ans = max(ans, lz + wt);\\n                ++wt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int lz = 0; //zeros to left\\n        int wt = 0; // additional wait time for one\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == \\'0\\') {\\n                wt = max(0, wt - 1);\\n                ++lz;\\n            }\\n            else {\\n                if(lz == 0)\\n                    continue;\\n                ans = max(ans, lz + wt);\\n                ++wt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749641,
                "title": "dp-bruteforce",
                "content": "*\\'\\'\\'\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int n = s.length();\\n        int flag= 0;\\n        for(int i = 0; i<n-1; i++){\\n            string str =\"\";\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                flag = 1;\\n                swap(s[i], s[i+1]);\\n                 i++;\\n            }\\n            \\n        }\\n         if(flag == 0) return 0;\\n        return 1 + secondsToRemoveOccurrences(s);\\n    }\\n};\\n\\'\\'\\'*",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int n = s.length();\\n        int flag= 0;\\n        for(int i = 0; i<n-1; i++){\\n            string str =\"\";\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                flag = 1;\\n                swap(s[i], s[i+1]);\\n                 i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2749273,
                "title": "javascript-dp-vs-brute",
                "content": "```\\n// BruteForce TLE\\nvar secondsToRemoveOccurrences = function(s) {\\n    let count = 0;\\n    \\n    while (s.indexOf(\\'01\\') != -1) {\\n      s.replaceAll(\\'01\\', \\'10\\');\\n      count++;\\n    }\\n    \\n    return count;\\n};\\n\\n// DP\\nvar secondsToRemoveOccurrences = function(s) {\\n  let zeroes = 0;\\n  let count = 0;\\n  \\n  for (let i = 0; i < s.length; i++) {\\n    zeroes += s[i] === \\'0\\' ? 1 : 0;\\n    \\n    if (s[i] === \\'1\\' && zeroes) {\\n      count = Math.max(count + 1, zeroes);\\n    }\\n  }\\n  \\n  return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// BruteForce TLE\\nvar secondsToRemoveOccurrences = function(s) {\\n    let count = 0;\\n    \\n    while (s.indexOf(\\'01\\') != -1) {\\n      s.replaceAll(\\'01\\', \\'10\\');\\n      count++;\\n    }\\n    \\n    return count;\\n};\\n\\n// DP\\nvar secondsToRemoveOccurrences = function(s) {\\n  let zeroes = 0;\\n  let count = 0;\\n  \\n  for (let i = 0; i < s.length; i++) {\\n    zeroes += s[i] === \\'0\\' ? 1 : 0;\\n    \\n    if (s[i] === \\'1\\' && zeroes) {\\n      count = Math.max(count + 1, zeroes);\\n    }\\n  }\\n  \\n  return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2745988,
                "title": "javascript-easy-approach-100-faster-beginners-friendly",
                "content": "```\\nconst secondsToRemoveOccurrences = (s) => {\\n    let count = 0;\\n    while(s.indexOf(\"01\")!=-1)\\n    {\\n        s = s.replaceAll(\"01\",\"10\");\\n        count++;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nconst secondsToRemoveOccurrences = (s) => {\\n    let count = 0;\\n    while(s.indexOf(\"01\")!=-1)\\n    {\\n        s = s.replaceAll(\"01\",\"10\");\\n        count++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738487,
                "title": "easy-brute-force-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0 ;\\n        String current = s;\\n        while(true){\\n            boolean hasZeroOne = false;\\n            for(int i = 0; i < s.length(); i++){\\n                if(i < s.length() - 1 && s.charAt(i) == \\'0\\' &&  s.charAt(i + 1) == \\'1\\'){\\n                    hasZeroOne = true;\\n                    current = swap(current, i, i + 1);\\n                }\\n            }\\n            s = current;\\n            if(hasZeroOne){\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n    private String swap(String str, int i, int j){\\n        StringBuilder sb = new StringBuilder(str);\\n        sb.setCharAt(i, str.charAt(j));\\n        sb.setCharAt(j, str.charAt(i));\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0 ;\\n        String current = s;\\n        while(true){\\n            boolean hasZeroOne = false;\\n            for(int i = 0; i < s.length(); i++){\\n                if(i < s.length() - 1 && s.charAt(i) == \\'0\\' &&  s.charAt(i + 1) == \\'1\\'){\\n                    hasZeroOne = true;\\n                    current = swap(current, i, i + 1);\\n                }\\n            }\\n            s = current;\\n            if(hasZeroOne){\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n    private String swap(String str, int i, int j){\\n        StringBuilder sb = new StringBuilder(str);\\n        sb.setCharAt(i, str.charAt(j));\\n        sb.setCharAt(j, str.charAt(i));\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735369,
                "title": "c",
                "content": "```\\nvoid swap(char* a, char* b){\\n    char temp; \\n    temp  = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nint secondsToRemoveOccurrences(char * s){\\n    int n = strlen(s);\\n    int* stack = malloc(n * sizeof(int));\\n    int idx = 0;\\n    int step = 0;\\n    while(1){\\n        idx = 0;\\n        for(int i = 0; i < n-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                stack[idx] = i;\\n                idx++;\\n            }\\n        }\\n        if(idx == 0)\\n            break;\\n        else{\\n            step++;\\n            for(int i = 0; i < idx; i++){\\n                swap(&s[stack[i]], &s[stack[i]+1]);\\n            }\\n        }\\n    }\\n    return step;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid swap(char* a, char* b){\\n    char temp; \\n    temp  = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nint secondsToRemoveOccurrences(char * s){\\n    int n = strlen(s);\\n    int* stack = malloc(n * sizeof(int));\\n    int idx = 0;\\n    int step = 0;\\n    while(1){\\n        idx = 0;\\n        for(int i = 0; i < n-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                stack[idx] = i;\\n                idx++;\\n            }\\n        }\\n        if(idx == 0)\\n            break;\\n        else{\\n            step++;\\n            for(int i = 0; i < idx; i++){\\n                swap(&s[stack[i]], &s[stack[i]+1]);\\n            }\\n        }\\n    }\\n    return step;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2728807,
                "title": "python-simple-maths",
                "content": "\\n    def secondsToRemoveOccurrences(self, s):\\n        count = 0\\n        \\n        while \"01\" in s:\\n            count += 1\\n            s = s.replace(\"01\",\"10\")\\n            \\n        return count\\n",
                "solutionTags": [],
                "code": "\\n    def secondsToRemoveOccurrences(self, s):\\n        count = 0\\n        \\n        while \"01\" in s:\\n            count += 1\\n            s = s.replace(\"01\",\"10\")\\n            \\n        return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2719115,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719113,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709322,
                "title": "easy-solution-java-simple-approach-no-dp",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] charArray = s.toCharArray();\\n        int count = 0;\\n        int swap = 1;\\n        while(swap == 1){\\n            swap = 0;\\n            count++;\\n            for(int i=0; i<charArray.length-1; i++){\\n                if(charArray[i] == \\'0\\' && charArray[i+1] == \\'1\\'){\\n                    charArray[i] = \\'1\\';\\n                    charArray[i+1] = \\'0\\';\\n                    i++;\\n                    swap = 1;\\n                }\\n            }\\n            \\n        }\\n        return (count-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] charArray = s.toCharArray();\\n        int count = 0;\\n        int swap = 1;\\n        while(swap == 1){\\n            swap = 0;\\n            count++;\\n            for(int i=0; i<charArray.length-1; i++){\\n                if(charArray[i] == \\'0\\' && charArray[i+1] == \\'1\\'){\\n                    charArray[i] = \\'1\\';\\n                    charArray[i+1] = \\'0\\';\\n                    i++;\\n                    swap = 1;\\n                }\\n            }\\n            \\n        }\\n        return (count-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692721,
                "title": "c-solution",
                "content": "```\\n\\n int secondsToRemoveOccurrences(string s) {\\n      int n=s.size();int ans=0;\\n        int need=1;\\n        while(need)\\n        {\\n            need=0;                              \\n            int i=1;\\n            while(i<n)\\n            {\\n                if(s[i-1]==\\'0\\'&& s[i]==\\'1\\'){        //if condition satisfies \\n                    swap(s[i-1],s[i]);                         // then we have to swap\\n                    need=1;                           // if we swap the elements then may be it forms another pair of \"01\" so we turn need to \\'1\\'\\n                    i+=2;\\n                }   \\n                else i++;\\n            }\\n            ans+=need;                        // add all need to ans because it tells us that how many time our condition satisfy\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n\\n int secondsToRemoveOccurrences(string s) {\\n      int n=s.size();int ans=0;\\n        int need=1;\\n        while(need)\\n        {\\n            need=0;                              \\n            int i=1;\\n            while(i<n)\\n            {\\n                if(s[i-1]==\\'0\\'&& s[i]==\\'1\\'){        //if condition satisfies \\n                    swap(s[i-1],s[i]);                         // then we have to swap\\n                    need=1;                           // if we swap the elements then may be it forms another pair of \"01\" so we turn need to \\'1\\'\\n                    i+=2;\\n                }   \\n                else i++;\\n            }\\n            ans+=need;                        // add all need to ans because it tells us that how many time our condition satisfy\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1709830,
                "content": [
                    {
                        "username": "pokerboy_leet",
                        "content": "I Thought there might be any logic i missed but its simply a brute force approach..  : )"
                    },
                    {
                        "username": "adibahmed5004",
                        "content": "Does string.replace works in O(n) time ? any idea?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "You don\\'t want to use that. Str. replace makes some internal copies of the original string, and traverses it few times. It\\'s better to simply use char[] and traverse the char[] yourself, replacing 01 to 10. "
                    }
                ]
            },
            {
                "id": 1751017,
                "content": [
                    {
                        "username": "pokerboy_leet",
                        "content": "I Thought there might be any logic i missed but its simply a brute force approach..  : )"
                    },
                    {
                        "username": "adibahmed5004",
                        "content": "Does string.replace works in O(n) time ? any idea?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "You don\\'t want to use that. Str. replace makes some internal copies of the original string, and traverses it few times. It\\'s better to simply use char[] and traverse the char[] yourself, replacing 01 to 10. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Shifting Letters II",
        "question_content": "<p>You are given a string <code>s</code> of lowercase English letters and a 2D integer array <code>shifts</code> where <code>shifts[i] = [start<sub>i</sub>, end<sub>i</sub>, direction<sub>i</sub>]</code>. For every <code>i</code>, <strong>shift</strong> the characters in <code>s</code> from the index <code>start<sub>i</sub></code> to the index <code>end<sub>i</sub></code> (<strong>inclusive</strong>) forward if <code>direction<sub>i</sub> = 1</code>, or shift the characters backward if <code>direction<sub>i</sub> = 0</code>.</p>\n\n<p>Shifting a character <strong>forward</strong> means replacing it with the <strong>next</strong> letter in the alphabet (wrapping around so that <code>&#39;z&#39;</code> becomes <code>&#39;a&#39;</code>). Similarly, shifting a character <strong>backward</strong> means replacing it with the <strong>previous</strong> letter in the alphabet (wrapping around so that <code>&#39;a&#39;</code> becomes <code>&#39;z&#39;</code>).</p>\n\n<p>Return <em>the final string after all such shifts to </em><code>s</code><em> are applied</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abc&quot;, shifts = [[0,1,0],[1,2,1],[0,2,1]]\n<strong>Output:</strong> &quot;ace&quot;\n<strong>Explanation:</strong> Firstly, shift the characters from index 0 to index 1 backward. Now s = &quot;zac&quot;.\nSecondly, shift the characters from index 1 to index 2 forward. Now s = &quot;zbd&quot;.\nFinally, shift the characters from index 0 to index 2 forward. Now s = &quot;ace&quot;.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;dztz&quot;, shifts = [[0,0,0],[1,1,1]]\n<strong>Output:</strong> &quot;catz&quot;\n<strong>Explanation:</strong> Firstly, shift the characters from index 0 to index 0 backward. Now s = &quot;cztz&quot;.\nFinally, shift the characters from index 1 to index 1 forward. Now s = &quot;catz&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, shifts.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>shifts[i].length == 3</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt; s.length</code></li>\n\t<li><code>0 &lt;= direction<sub>i</sub> &lt;= 1</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2454167,
                "title": "line-sweep-with-explanation",
                "content": "**Explanation:-**\\n\\n1. ```Lets say we are given [1,10000] and [2,10000] intervals and we are supposed to increase the  count of values between  1 to 10000 and 2 to 10000 by 1.```\\n2. So how you will do?\\n3. ```Brute force is to iterate over each interval and increase each position count that is appearing in intervals.```\\n4. Can we do better?\\n5. ```Lets create a array from index 0 to 1e5.```\\n6. ```Now iterate over each interval.Eg.:-```\\n7.  ```[1,10000]:- increase the counter at pos 1 and decrease at 10001.Same for other intervals.```\\n8. ``` Now do prefix sum.```\\n9.  This will incerase each position value in linear time.\\n10. In question when we do forward shift then we have to increase the count from position left to right.\\n11.So i will do line[left]++ and line[right+1]--.\\n12. For backward shift we want to decrease the value so\\n13. So i will do line[left]-- and line[right+1]++.\\nI hope you can do question now.\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sh) {\\n        long sz=s.size();\\n        vector<long>line(sz+1,0);\\n        for(auto & i:sh){\\n            // forward shift so do +1\\n            if(i[2]==1){\\n                line[i[0]]++;\\n                line[i[1]+1]--;\\n            }\\n            //backward shift so do -1\\n            else{\\n                line[i[0]]--;\\n                line[i[1]+1]++;                \\n            }\\n        }\\n        for(int i=1;i<=sz;i++)\\n            line[i]+=line[i-1];\\n        for(int i=0;i<sz;i++){\\n\\t\\t// line[i] is how many times i have to increase or decrease the s[i] char.So i am adding it and taking modulo\\n\\t\\t\\tint increaseBy=(s[i]-\\'a\\'+line[i])%26;\\n\\t\\t// this is to make -ve module +ve. \\n\\t\\t\\tincreaseBy=(increaseBy+26)%26;\\n\\t\\t\\ts[i]=\\'a\\'+increaseBy;\\n        }\\n        return s;      \\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```Lets say we are given [1,10000] and [2,10000] intervals and we are supposed to increase the  count of values between  1 to 10000 and 2 to 10000 by 1.```\n```Brute force is to iterate over each interval and increase each position count that is appearing in intervals.```\n```Lets create a array from index 0 to 1e5.```\n```Now iterate over each interval.Eg.:-```\n```[1,10000]:- increase the counter at pos 1 and decrease at 10001.Same for other intervals.```\n``` Now do prefix sum.```\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sh) {\\n        long sz=s.size();\\n        vector<long>line(sz+1,0);\\n        for(auto & i:sh){\\n            // forward shift so do +1\\n            if(i[2]==1){\\n                line[i[0]]++;\\n                line[i[1]+1]--;\\n            }\\n            //backward shift so do -1\\n            else{\\n                line[i[0]]--;\\n                line[i[1]+1]++;                \\n            }\\n        }\\n        for(int i=1;i<=sz;i++)\\n            line[i]+=line[i-1];\\n        for(int i=0;i<sz;i++){\\n\\t\\t// line[i] is how many times i have to increase or decrease the s[i] char.So i am adding it and taking modulo\\n\\t\\t\\tint increaseBy=(s[i]-\\'a\\'+line[i])%26;\\n\\t\\t// this is to make -ve module +ve. \\n\\t\\t\\tincreaseBy=(increaseBy+26)%26;\\n\\t\\t\\ts[i]=\\'a\\'+increaseBy;\\n        }\\n        return s;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454158,
                "title": "fenwick-tree-vs-line-sweep",
                "content": "First, we accumulate all shifts. To do that efficiently, we can use a Fenwick Tree or Line Sweep.\\n\\n#### Line Sweep\\nWe add shifts to the beginning and end of each interval. Then, we use a line sweep technique to accumulate shifts for each position in `s`.\\n\\n**C++**\\n```cpp\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n    int line[50001] = {};\\n    for (auto &shift : shifts) {\\n        line[shift[0]] += shift[2] ? 1 : -1;\\n        line[shift[1] + 1] += shift[2] ? -1 : 1;\\n    }\\n    for (int i = 0, val = 0; i < s.size(); ++i) {\\n        val = (val + line[i]) % 26;\\n        s[i] = \\'a\\' + (26 + (s[i] - \\'a\\') + val) % 26;\\n    }\\n    return s;\\n}\\n```\\n#### Fenwick Tree\\nFenwick Tree provides is a mutable prefix sum functionality - we can increment all elements in a range, and get a sum of that range in O(log n).\\n\\n**C++**\\n```cpp\\nconstexpr int static n = 50000;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n    for (auto &shift : shifts) {\\n        add(shift[0], shift[2] == 1 ? 1 : -1);\\n        add(shift[1] + 1, shift[2] == 1 ? -1 : 1);\\n    }\\n    for (int i = 0; i < s.size(); ++i)\\n        s[i] = \\'a\\' + (26 + (s[i] - \\'a\\') + prefix_sum(i) % 26) % 26;\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n    int line[50001] = {};\\n    for (auto &shift : shifts) {\\n        line[shift[0]] += shift[2] ? 1 : -1;\\n        line[shift[1] + 1] += shift[2] ? -1 : 1;\\n    }\\n    for (int i = 0, val = 0; i < s.size(); ++i) {\\n        val = (val + line[i]) % 26;\\n        s[i] = \\'a\\' + (26 + (s[i] - \\'a\\') + val) % 26;\\n    }\\n    return s;\\n}\\n```\n```cpp\\nconstexpr int static n = 50000;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n    for (auto &shift : shifts) {\\n        add(shift[0], shift[2] == 1 ? 1 : -1);\\n        add(shift[1] + 1, shift[2] == 1 ? -1 : 1);\\n    }\\n    for (int i = 0; i < s.size(); ++i)\\n        s[i] = \\'a\\' + (26 + (s[i] - \\'a\\') + prefix_sum(i) % 26) % 26;\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454324,
                "title": "prefix-sum-range-update-o-n-java-6-ms-100",
                "content": "```\\n  public String shiftingLetters(String s, int[][] shifts) {\\n        char[] ch = s.toCharArray();\\n        int[] count = new int[s.length()+1];\\n        \\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            count[shift[0]] += value;\\n            count[shift[1] + 1] -= value;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < count.length - 1; i++){\\n            sum += count[i];\\n            int newChar = ((ch[i] - \\'a\\') + sum) % 26;\\n            if(newChar < 0) newChar+= 26;\\n            ch[i] =  (char)(\\'a\\' + newChar);\\n        }\\n        \\n        return String.valueOf(ch);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public String shiftingLetters(String s, int[][] shifts) {\\n        char[] ch = s.toCharArray();\\n        int[] count = new int[s.length()+1];\\n        \\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            count[shift[0]] += value;\\n            count[shift[1] + 1] -= value;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < count.length - 1; i++){\\n            sum += count[i];\\n            int newChar = ((ch[i] - \\'a\\') + sum) % 26;\\n            if(newChar < 0) newChar+= 26;\\n            ch[i] =  (char)(\\'a\\' + newChar);\\n        }\\n        \\n        return String.valueOf(ch);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454359,
                "title": "prefix-sum-c-simple-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int l=shifts[i][0];\\n            int r=shifts[i][1];\\n            if(shifts[i][2]==0){\\n                v[l]--;\\n                v[r+1]++;\\n            }\\n            else{\\n                v[l]++;\\n                v[r+1]--;\\n            }\\n        }\\n    \\n        for(int i=0;i<n;i++){\\n            sum+=v[i];\\n            int k=sum%26;\\n            int p=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int l=shifts[i][0];\\n            int r=shifts[i][1];\\n            if(shifts[i][2]==0){\\n                v[l]--;\\n                v[r+1]++;\\n            }\\n            else{\\n                v[l]++;\\n                v[r+1]--;\\n            }\\n        }\\n    \\n        for(int i=0;i<n;i++){\\n            sum+=v[i];\\n            int k=sum%26;\\n            int p=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454404,
                "title": "python-cumulative-sum-easy-solution",
                "content": "In this problem, we should be doing the exact same thing as in the first part of this problem (shifting letters) but there is an extra complexity of finding the final changes for each of the letters. \\n\\nA brute force approach would be to iterate through all of the letters that need to be changed for each shift in array shifts (e.g., from 0 to 2 in forward direction). However, this adds extra complexity if we have large ranges of letters that need to be changed. This is why we should be using a cumulative sum approach here. \\n\\nFor example, instead of iterating through the range, we can add a +1 if we are moving forward in the beginning of the range and -1 in the end of the range to make sure we are no longer applying the change. The same thing goes for the backward direction with the -1 at the beginning and +1 at the end.\\n\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        cum_shifts = [0 for _ in range(len(s)+1)]\\n        \\n        for st, end, d in shifts:\\n            if d == 0:\\n                cum_shifts[st] -= 1\\n                cum_shifts[end+1] += 1\\n            else:\\n                cum_shifts[st] += 1\\n                cum_shifts[end+1] -= 1\\n        \\n        cum_sum = 0\\n        for i in range(len(s)):\\n            cum_sum += cum_shifts[i]\\n            \\n            new_code = (((ord(s[i]) + cum_sum) - 97) % 26) + 97\\n            s = s[:i] + chr(new_code) + s[i+1:]\\n        \\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        cum_shifts = [0 for _ in range(len(s)+1)]\\n        \\n        for st, end, d in shifts:\\n            if d == 0:\\n                cum_shifts[st] -= 1\\n                cum_shifts[end+1] += 1\\n            else:\\n                cum_shifts[st] += 1\\n                cum_shifts[end+1] -= 1\\n        \\n        cum_sum = 0\\n        for i in range(len(s)):\\n            cum_sum += cum_shifts[i]\\n            \\n            new_code = (((ord(s[i]) + cum_sum) - 97) % 26) + 97\\n            s = s[:i] + chr(new_code) + s[i+1:]\\n        \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454310,
                "title": "c-o-n-scanline-algorithm",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach**:\\n1. using \\'Scanline Algorithm\\' to keep track of how a particular shift is affecting a range \\n2. reference video: https://www.youtube.com/watch?v=lFBpH_Mt_LI\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int> dir(n+1,0);\\n        for(int k=0;k<shifts.size();k++){\\n            int i = shifts[k][0], j=shifts[k][1], move = (shifts[k][2] == 0 ? -1:1);\\n            dir[i] += move, dir[j+1] -= move;\\n        }\\n        \\n        for(int i=1;i<n+1;i++) dir[i] += dir[i-1]; // cummulative effect of all shifts on each index \\n        \\n        for(int i=0;i<n;i++){\\n            int idx = (s[i]-\\'a\\' + dir[i])%26;\\n            if(idx<0) idx += 26;\\n            char new_ch = (char)(idx + \\'a\\');\\n            s[i] = new_ch;\\n        }\\n        return s;\\n    }\\n}; \\n```\\n\\n**Do UPVOTE if it helps :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int> dir(n+1,0);\\n        for(int k=0;k<shifts.size();k++){\\n            int i = shifts[k][0], j=shifts[k][1], move = (shifts[k][2] == 0 ? -1:1);\\n            dir[i] += move, dir[j+1] -= move;\\n        }\\n        \\n        for(int i=1;i<n+1;i++) dir[i] += dir[i-1]; // cummulative effect of all shifts on each index \\n        \\n        for(int i=0;i<n;i++){\\n            int idx = (s[i]-\\'a\\' + dir[i])%26;\\n            if(idx<0) idx += 26;\\n            char new_ch = (char)(idx + \\'a\\');\\n            s[i] = new_ch;\\n        }\\n        return s;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485135,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n// charecter shifting function\\n    char shift(char a, int n){\\n        int i = a - \\'a\\';\\n        i = (i+n)%26;\\n        \\n        //negative case\\n        if(i<0)\\n            i = i+26;\\n        \\n        return \\'a\\' + i;\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.size();\\n        vector<int> presum(n+1,0);\\n        \\n        for(auto x: shifts){\\n            \\n            if(x[2]==0){\\n                presum[x[0]]--;;\\n                presum[x[1]+1]++;\\n            }\\n            else{\\n                presum[x[0]]++;;\\n                presum[x[1]+1]--;\\n            }            \\n        }\\n        \\n        for(int i = 1; i<presum.size();i++)\\n            presum[i]+=presum[i-1];        \\n        \\n        string ans = \"\";\\n        for(int i =0; i<n; i++)\\n            ans+= shift(s[i],presum[i]);\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n// charecter shifting function\\n    char shift(char a, int n){\\n        int i = a - \\'a\\';\\n        i = (i+n)%26;\\n        \\n        //negative case\\n        if(i<0)\\n            i = i+26;\\n        \\n        return \\'a\\' + i;\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.size();\\n        vector<int> presum(n+1,0);\\n        \\n        for(auto x: shifts){\\n            \\n            if(x[2]==0){\\n                presum[x[0]]--;;\\n                presum[x[1]+1]++;\\n            }\\n            else{\\n                presum[x[0]]++;;\\n                presum[x[1]+1]--;\\n            }            \\n        }\\n        \\n        for(int i = 1; i<presum.size();i++)\\n            presum[i]+=presum[i-1];        \\n        \\n        string ans = \"\";\\n        for(int i =0; i<n; i++)\\n            ans+= shift(s[i],presum[i]);\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465791,
                "title": "python3-8-lines-letter-indexing-w-explanation-t-m-100-60",
                "content": "```\\nclass Solution:         # Here\\'s the plan:\\n                        #   1) 1a: Initiate an array offsets with length len(s)+1. \\n                        #      1b: Iterate through shifts and collect the endpts and the direction\\n                        #          of each shift. (Note that 2*(0)-1 = -1 and 2*(1)-1 = 1.)\\n                        #      1c: Accumulate the elements in offsets to determine the cummulative\\n                        #          offset for each char in s\\n                        # \\n                        #   2) 2a: Write the letter index (1-26) of each char of s to a list chNums. \\n                        #      2b: Add to each letter index its corresponding offset and determine \\n                        #          its new letter index by applying %26.\\n                        #      2c: Return the result string from chNums. \\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n\\n        offsets = [0]*(n+1)                                     # <-- 1a\\n\\t\\t\\n        for start, end, direction in shifts:                    # <-- 1b\\n            offsets[start]+= 2*direction-1\\n            offsets[end+1]-= 2*direction-1\\n\\t\\t\\t\\n        offsets = accumulate(offsets)                           # <-- 1c\\n\\n        chNums = (ord(ch)-97 for ch in s)                       # <-- 2a\\n\\t\\t\\n        chNums = ((chNum + offset)%26 for chNum,                # <-- 2b\\n                   offset in zip(chNums, offsets))\\n\\n        return \\'\\'.join(chr(chNum+97) for chNum in chNums)       # <-- 2c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:         # Here\\'s the plan:\\n                        #   1) 1a: Initiate an array offsets with length len(s)+1. \\n                        #      1b: Iterate through shifts and collect the endpts and the direction\\n                        #          of each shift. (Note that 2*(0)-1 = -1 and 2*(1)-1 = 1.)\\n                        #      1c: Accumulate the elements in offsets to determine the cummulative\\n                        #          offset for each char in s\\n                        # \\n                        #   2) 2a: Write the letter index (1-26) of each char of s to a list chNums. \\n                        #      2b: Add to each letter index its corresponding offset and determine \\n                        #          its new letter index by applying %26.\\n                        #      2c: Return the result string from chNums. \\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n\\n        offsets = [0]*(n+1)                                     # <-- 1a\\n\\t\\t\\n        for start, end, direction in shifts:                    # <-- 1b\\n            offsets[start]+= 2*direction-1\\n            offsets[end+1]-= 2*direction-1\\n\\t\\t\\t\\n        offsets = accumulate(offsets)                           # <-- 1c\\n\\n        chNums = (ord(ch)-97 for ch in s)                       # <-- 2a\\n\\t\\t\\n        chNums = ((chNum + offset)%26 for chNum,                # <-- 2b\\n                   offset in zip(chNums, offsets))\\n\\n        return \\'\\'.join(chr(chNum+97) for chNum in chNums)       # <-- 2c",
                "codeTag": "Java"
            },
            {
                "id": 2454172,
                "title": "range-update-java",
                "content": "\\n    class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n=s.length();\\n        int arr[]=new int[n];\\n        int diff[]=new int[n+1];\\n        //doing it for update\\n        for(int i=0;i<n;i++){\\n            arr[i]=s.charAt(i)-\\'a\\';\\n        }\\n        //creating the diff array for l-r range update\\n        diff[0]=arr[0];\\n        for(int i=1;i<n;i++){\\n            diff[i]=arr[i]-arr[i-1];\\n        }\\n        for(int p[]:shifts){\\n            int u=p[0];\\n            int v=p[1];\\n            int w=p[2];\\n            //doing the range update\\n            if(w==0){\\n                diff[u]+=(-1);\\n                diff[v+1]-=(-1);\\n            }\\n            else{\\n                diff[u]+=1;\\n                diff[v+1]-=1;\\n            }\\n        }\\n        //updating the array \\n        for(int i=0;i<n;i++){\\n            if(i==0)\\n                arr[i]=diff[i];\\n            else\\n                arr[i]=diff[i]+arr[i-1];  \\n        }\\n        String str=\"\";\\n        for(int i=0;i<n;i++){\\n            //handling the negative value of arr[i]\\n            if(arr[i]<0){\\n                int c=1;\\n                while(Math.abs(arr[i])>(26*c)){\\n                    c++;\\n                }\\n                int temp=26*c;\\n                arr[i]+=temp;\\n            }\\n            //converting into string\\n            str+=(char)((arr[i]%26)+97);\\n        }\\n        return str;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n=s.length();\\n        int arr[]=new int[n];\\n        int diff[]=new int[n+1];\\n        //doing it for update\\n        for(int i=0;i<n;i++){\\n            arr[i]=s.charAt(i)-\\'a\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2454260,
                "title": "prefix-sum",
                "content": "**Please Upvote If you got it : )**\\nWe will use prefix sum concept in this problem:\\n\\nWe will perform total three passes:\\n1) In first pass we traverse shifts vector: we will put value in vector,\\n      if(shifts[i][2]==1), then do +=1 at shifts[i][0] index & -=1 at shifts[i][0]+1 index of vector(prefixsum)\\n      else ,do -=1 at shifts[i][0] index & +=1 at shifts[i][0]+1 index of vector(prefixsum)\\n\\n2) In second pass we traverse vector and do prefixsum to find displacement of character at index i\\n\\n3) In third pass we traverse string and shift the character ((s[i]-\\'a\\')+vec[i])%26 places from \\'a\\'\\n   \\n\\n**Time Complexity: 3xO(n)\\nSpaceComplexity: O(n)**\\n\\n**Code:**\\n```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> vec(n+1,0);\\n        // to fill vec\\n        for(auto &v: shifts){\\n            if(v[2]==1){\\n                vec[v[0]]+=1;\\n                vec[v[1]+1]-=1;\\n            } else{\\n                vec[v[0]]-=1;\\n                vec[v[1]+1]+=1;\\n            }\\n        }\\n        // prefix sum\\n        for(int i=1;i<=n;++i){\\n            vec[i]+=vec[i-1];\\n        }\\n        // shift character\\n        for(int i=0;i<n;++i){\\n            int val=((s[i]-\\'a\\')+vec[i])%26;\\n            if(val<0) val+=26;\\n            s[i]=\\'a\\'+val;\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> vec(n+1,0);\\n        // to fill vec\\n        for(auto &v: shifts){\\n            if(v[2]==1){\\n                vec[v[0]]+=1;\\n                vec[v[1]+1]-=1;\\n            } else{\\n                vec[v[0]]-=1;\\n                vec[v[1]+1]+=1;\\n            }\\n        }\\n        // prefix sum\\n        for(int i=1;i<=n;++i){\\n            vec[i]+=vec[i-1];\\n        }\\n        // shift character\\n        for(int i=0;i<n;++i){\\n            int val=((s[i]-\\'a\\')+vec[i])%26;\\n            if(val<0) val+=26;\\n            s[i]=\\'a\\'+val;\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455331,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>&q) {\\n        int n=s.size();\\n        vector<int>dp(n+1,0);\\n        for(auto it:q)\\n        {\\n            if(it[2]==0)\\n            {\\n                dp[it[0]]-=1;\\n                dp[it[1]+1]+=1;\\n            }\\n            else\\n            {\\n                dp[it[0]]+=1;\\n                dp[it[1]+1]-=1;\\n            }\\n            dp[it[0]]=(dp[it[0]]+26)%26;\\n            dp[it[1]]=(dp[it[1]]+26)%26;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i)\\n            {\\n                dp[i]+=dp[i-1];\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=(dp[i]+(s[i]-\\'a\\')+26)%26;\\n            s[i]=(sum+\\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>&q) {\\n        int n=s.size();\\n        vector<int>dp(n+1,0);\\n        for(auto it:q)\\n        {\\n            if(it[2]==0)\\n            {\\n                dp[it[0]]-=1;\\n                dp[it[1]+1]+=1;\\n            }\\n            else\\n            {\\n                dp[it[0]]+=1;\\n                dp[it[1]+1]-=1;\\n            }\\n            dp[it[0]]=(dp[it[0]]+26)%26;\\n            dp[it[1]]=(dp[it[1]]+26)%26;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i)\\n            {\\n                dp[i]+=dp[i-1];\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=(dp[i]+(s[i]-\\'a\\')+26)%26;\\n            s[i]=(sum+\\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456336,
                "title": "c-difference-array-solution-100-time-305ms-100-space-92mb",
                "content": "This is a problem we might be tempted to solve with a brute force approach, directly changing the characters in place at each step, but a quick look at the constraints might make us desist quickly: we might get potentially `50000` `shifts` covering the whole size of `s`, which is of the same size, for a grand total of `250M` operations, which is definitely not the cheapest we can get.\\n\\nStoring the changes might be much more convenient, but again we need to think how - having an array of `s.size()` elements we update all the time would hardly be an improvement.\\n\\nGladly this problem seems to be a handbook case for the usage of a difference array!\\n\\nThe core idea of this data structure is that if we receive a change of `x` across all the values from `a` to `b` (included), we are going to do so just by writing `x` at index `a` and `-x` at index `b + 1` (cancelling the effect of the first change on `a`).\\n\\nWhen we go and read through the difference array, we will keep a running count of what changes we encountered, giving us a measure of how they are affecting the current cell. A pretty good solution when we are going to face several changes across potentially very large intervals and when we need to read the final result only once (so we can accept a linear complexity for this!).\\n\\nLet\\'s go for some quick example, for `\"abcdefgh\"`:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t0\\t0\\t0\\t0\\t0\\t0\\t0\\t // initial values in the difference array\\n```\\n\\nThen we decide to increase by `1` all the values from `1` to `5` , so that we will have:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t0\\t0  -1\\t0\\t // values after the first change\\n```\\n\\nNow we decide to increase by `1` all the values from `4` to `6` , so that we will have:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t1\\t0  -1  -1\\t // values after the second change\\n```\\n\\nNext we decrease by `1` all the values from `2` to `3` , so that we will have:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t0\\t2\\t0  -1  -1\\t // values after the third change; notice index 4 now with a value of 2 from the previous two operations\\n```\\n\\nFinally we increase by `1` all the values from `3` to `5` , so that we will have:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t1\\t2\\t0  -2  -1\\t // values after the fourth change; notice index 7 now with a value of -2 from the first and last operations\\n```\\n\\nNow, going with a running sun as we parse our difference array, we will find that each character will have to do the following shifts:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1   0\\t1\\t3\\t0   1   0\\t // shifts for each character\\n```\\n\\nThe remaining part of the problem is just how to handle when a character gets shifted past `\\'a\\'` or `\\'z\\'`, but that is rather trivial compared to the rest.\\n\\nNow, to put our thoughts into code, we will start declaring a few support variables, as usual:\\n* `len` will store the size of `s`;\\n* `diffArray` is where we will store our indexes, creating it with a length of `len + 1` to avoid extra logic on the `-x` mark when applied to the last cell - saving us `shifts.size()` conditional statements for the cost of a couple of bytes;\\n* `dir` will be a support variable for when we iterate `shifts`.\\n\\nWe will then set all the cells of `diffArray` to `0`, but for the last one (as we said, we do not really care and we will never really use it, just as a placeholder).\\n\\nLooping though each `shift` in `shifts`, we will:\\n* set `dir` to be `1` if `shift[2]` is also `1`, `-1` otherwise, as specified in the specs;\\n* increase our starting point `diffArray[shift[0]]` by `dir`;\\n* decrease our ending point `diffArray[shift[1] + 1]` by `dir`.\\n\\nWith `diffArray` fully populated, we can now work on `s` and, with our ongoing sum `c` initialised to `0` and for each position `i` in it, we will:\\n* set `c` to increase by `diffArray[i]` (I saw some solutions doing this with a separate pass, but since we only need to do this once, no point in storing the values and writing them down updating `diffArray` in place);\\n*  set `pos` to the value in which we would pick a character in an ideal `\"abcdefghijklmnopqrstuvwxyz\"` string, with the value equal to the original (`s[i]`), minus `\\'a\\'` (to turn it into a value in the `0 - 25` range), plus `c` (so, the final shift for this specific cell);\\n*  we will add `26` to `pos` as long as it is `< 0` to make sure it is within range;\\n*  we will subtract `26` to `pos` as long as it is `> 25` to make sure it is within range - notice that this way our solution has only one expensive modulo operation per character \\uD83C\\uDFC6 ;\\n*  finally, we will set back the value in `s[i]` to be equal to `pos` (our adjusted `0 - 25` final value), plus `\\'a\\'` (to make sure it is again a valid lowercase ASCII character).\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // support variables\\n        int len = s.size(), diffArray[len + 1], dir;\\n        // populating diffArray\\n        memset(diffArray, 0, len * sizeof(int));\\n        for (auto &shift: shifts) {\\n            dir = shift[2] ? 1 : -1;\\n            diffArray[shift[0]] += dir;\\n            diffArray[shift[1] + 1] -= dir;\\n        }\\n        // populating res\\n        for (int i = 0, c = 0, pos; i < len; i++) {\\n            c += diffArray[i];\\n            pos = s[i] - \\'a\\' + c % 26;\\n            while (pos < 0) pos += 26;\\n            while (pos > 25) pos -= 26;\\n            s[i] = pos += \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t0\\t0\\t0\\t0\\t0\\t0\\t0\\t // initial values in the difference array\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t0\\t0  -1\\t0\\t // values after the first change\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t1\\t0  -1  -1\\t // values after the second change\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t0\\t2\\t0  -1  -1\\t // values after the third change; notice index 4 now with a value of 2 from the previous two operations\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t1\\t2\\t0  -2  -1\\t // values after the fourth change; notice index 7 now with a value of -2 from the first and last operations\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1   0\\t1\\t3\\t0   1   0\\t // shifts for each character\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // support variables\\n        int len = s.size(), diffArray[len + 1], dir;\\n        // populating diffArray\\n        memset(diffArray, 0, len * sizeof(int));\\n        for (auto &shift: shifts) {\\n            dir = shift[2] ? 1 : -1;\\n            diffArray[shift[0]] += dir;\\n            diffArray[shift[1] + 1] -= dir;\\n        }\\n        // populating res\\n        for (int i = 0, c = 0, pos; i < len; i++) {\\n            c += diffArray[i];\\n            pos = s[i] - \\'a\\' + c % 26;\\n            while (pos < 0) pos += 26;\\n            while (pos > 25) pos -= 26;\\n            s[i] = pos += \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454210,
                "title": "c-solution-using-prefix-array",
                "content": "```\\n class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<long long int>temp(s.length());\\n        long long int start;\\n        long long int end;\\n        long int direction;\\n        for(long long int i=0;i<shifts.size();i++){\\n            start=shifts[i][0];\\n            end=shifts[i][1];\\n            direction=shifts[i][2];\\n            int add;\\n            if(direction==0)\\n                add=-1;\\n            else\\n                add=1;\\n            temp[start]=temp[start]+add;\\n            if(end!=s.length()-1){\\n                temp[end+1]=temp[end+1]-add;\\n            }\\n        }\\n      \\n        for(long long int i=1;i<s.size();i++)\\n        {\\n           temp[i]=temp[i]+temp[i-1];\\n        }\\n        for(long long int i=0;i<s.size();i++)\\n        {\\n            s[i]=(s[i]+(temp[i]%26)-\\'a\\'+26)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<long long int>temp(s.length());\\n        long long int start;\\n        long long int end;\\n        long int direction;\\n        for(long long int i=0;i<shifts.size();i++){\\n            start=shifts[i][0];\\n            end=shifts[i][1];\\n            direction=shifts[i][2];\\n            int add;\\n            if(direction==0)\\n                add=-1;\\n            else\\n                add=1;\\n            temp[start]=temp[start]+add;\\n            if(end!=s.length()-1){\\n                temp[end+1]=temp[end+1]-add;\\n            }\\n        }\\n      \\n        for(long long int i=1;i<s.size();i++)\\n        {\\n           temp[i]=temp[i]+temp[i-1];\\n        }\\n        for(long long int i=0;i<s.size();i++)\\n        {\\n            s[i]=(s[i]+(temp[i]%26)-\\'a\\'+26)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454194,
                "title": "segment-tree-o-nlog-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n\\n    void upd(int l, int r, int v, int x, int lx, int rx) {\\n        if(lx > r or rx < l) return;\\n        if(lx >= l and rx <= r) {\\n            seg[x] += v;\\n            return;\\n        }\\n        int mid = (lx + rx) / 2;\\n        upd(l, r, v, 2 * x + 1, lx, mid);\\n        upd(l, r, v, 2 * x + 2, mid + 1, rx);\\n    }\\n\\n    int query(int i, int x, int lx, int rx) {\\n        if(lx == rx) return seg[x];\\n\\n        int mid = (lx + rx) / 2;\\n\\n        if(i <= mid)\\n            return seg[x] + query(i, 2 * x + 1, lx, mid);\\n\\n        return seg[x] + query(i, 2 * x + 2, mid + 1, rx);\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        long x = 1;\\n        while(x <= s.length()) x <<= 1;\\n        seg.resize(2 * x, 0);\\n        \\n        for(int i = 0; i < shifts.size(); ++i) {\\n            int l = shifts[i][0], r = shifts[i][1], dir;\\n            if(shifts[i][2] == 0) dir = -1;\\n            else dir = 1;\\n            \\n            //add 1 to the segment if direction is 1 else add -1 to the segment\\n            upd(l, r, dir, 0, 0, x - 1); //O(log(n))\\n        }\\n        \\n        for(int i = 0; i < s.length(); ++i) {\\n            // get the total changes made to the particular character\\n            int shift = query(i, 0, 0, x - 1);\\n            int dir = (shift > 0) ? 1 : -1; // direction of the shift\\n            shift = abs(shift) % 26; \\n            // after doing 26 shifts we come back at the same position \\n            //so instead of moving the character linearly get the exact location by modulo\\n            \\n            shift *= dir;\\n            int cur = s[i] - \\'a\\'; // current position\\n            cur = (cur + shift + 26) % 26; // new position\\n            s[i] = char(cur + \\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n\\n    void upd(int l, int r, int v, int x, int lx, int rx) {\\n        if(lx > r or rx < l) return;\\n        if(lx >= l and rx <= r) {\\n            seg[x] += v;\\n            return;\\n        }\\n        int mid = (lx + rx) / 2;\\n        upd(l, r, v, 2 * x + 1, lx, mid);\\n        upd(l, r, v, 2 * x + 2, mid + 1, rx);\\n    }\\n\\n    int query(int i, int x, int lx, int rx) {\\n        if(lx == rx) return seg[x];\\n\\n        int mid = (lx + rx) / 2;\\n\\n        if(i <= mid)\\n            return seg[x] + query(i, 2 * x + 1, lx, mid);\\n\\n        return seg[x] + query(i, 2 * x + 2, mid + 1, rx);\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        long x = 1;\\n        while(x <= s.length()) x <<= 1;\\n        seg.resize(2 * x, 0);\\n        \\n        for(int i = 0; i < shifts.size(); ++i) {\\n            int l = shifts[i][0], r = shifts[i][1], dir;\\n            if(shifts[i][2] == 0) dir = -1;\\n            else dir = 1;\\n            \\n            //add 1 to the segment if direction is 1 else add -1 to the segment\\n            upd(l, r, dir, 0, 0, x - 1); //O(log(n))\\n        }\\n        \\n        for(int i = 0; i < s.length(); ++i) {\\n            // get the total changes made to the particular character\\n            int shift = query(i, 0, 0, x - 1);\\n            int dir = (shift > 0) ? 1 : -1; // direction of the shift\\n            shift = abs(shift) % 26; \\n            // after doing 26 shifts we come back at the same position \\n            //so instead of moving the character linearly get the exact location by modulo\\n            \\n            shift *= dir;\\n            int cur = s[i] - \\'a\\'; // current position\\n            cur = (cur + shift + 26) % 26; // new position\\n            s[i] = char(cur + \\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494034,
                "title": "python-3-sweep-line-difference-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        d = [0 for _ in range(n + 1)]\\n        for start, end, direction in shifts:\\n            dir = 1 if direction else -1\\n            d[start] += dir\\n            d[end + 1] -= dir\\n        \\n        res = []\\n        for i in range(n):\\n            if i != 0: \\n                d[i] += d[i - 1]\\n            new_chr_ascii = (ord(s[i]) - ord(\"a\") + d[i]) % 26 + ord(\"a\")\\n            res.append(chr(new_chr_ascii))\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        d = [0 for _ in range(n + 1)]\\n        for start, end, direction in shifts:\\n            dir = 1 if direction else -1\\n            d[start] += dir\\n            d[end + 1] -= dir\\n        \\n        res = []\\n        for i in range(n):\\n            if i != 0: \\n                d[i] += d[i - 1]\\n            new_chr_ascii = (ord(s[i]) - ord(\"a\") + d[i]) % 26 + ord(\"a\")\\n            res.append(chr(new_chr_ascii))\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454995,
                "title": "prefix-sum-and-range-query-python-explanation-o-n",
                "content": "**Explanation**\\nFor a given shift i.e., start, end, direction, we need to shift all ```s[i]``` where ```start<=i<=end```. In other words, we shift ```s[i]``` beginning from ```i=start``` and stop the shifting operation at ```i=end+1```.\\n\\nSo, we create an array ```pos``` that stores the shift operations by marking ```pos[start]``` and ```pos[end+1]```\\n* for ```shift = [start, end, forward_shift]```\\n ```pos[start] += 1```\\n ```pos[end+1] -= 1```\\n \\n* for ```shift = [start, end, backward_shift]```\\n```pos[start] -= 1```\\n```pos[end+1] += 1```\\n\\n\\n**Example**\\n**Given**, ```shifts = [[0,1,0],[1,2,1],[0,2,1]]```\\n**Initially**, ```pos = [0, 0, 0 ,0]```\\n* After accounting  for ```shift=[0, 1, 0]```,  ``` pos = [-1, 0, 1, 0]```\\n* After accounting  for ```shift=[1,2,1]```,  ``` pos =[-1, 1, 1, -1]```\\n* After accounting  for ```shift=[0,2,1]```,  ``` pos = [0, 1, 1, -2]```\\n**Finally**, ```pos = [0, 1, 1, -2]```\\n\\nThe **net shift** of ```s[i]``` = prefix sum of ```pos[i]``` = ```pos[0]+pos[1]+pos[2]+....+pos[i]```\\n\\n\\n**Note:** The ```len(pos)=len(s)+1``` as we mark ```pos[end+1]``` to denote the end of a shift operation.\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        pos = [0 for i in range(len(s)+1)] # to store the shift value\\n        for start, end, direction in shifts:\\n            if direction: # increase all chars in s[start:end+1] by 1\\n                pos[start] += 1  # marks the position from which increment starts\\n                pos[end+1] -= 1 # marks the position where the increment stops\\n            else: # decrease all chars in s[start:end+1] by 1\\n                pos[start] -= 1 # marks the position where decrement starts\\n                pos[end+1] += 1 # marks the position where the decrement stops\\n        cur = 0 # for index i, cur = the net increase or decrease of s[i]\\n\\t\\tres = \"\"\\n        for i in range(len(s)):\\n            cur += pos[i]\\n            res += chr((cur+ord(s[i])-97)%26 + 97)\\n        return res\\n```\\n\\n**Time Complexity** = **O(n)**, where n=s.length or shifts.length\\n**Space Complexity** = **O(n)**, where n = s.length",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```s[i]```\n```start<=i<=end```\n```s[i]```\n```i=start```\n```i=end+1```\n```pos```\n```pos[start]```\n```pos[end+1]```\n```shift = [start, end, forward_shift]```\n```pos[start] += 1```\n```pos[end+1] -= 1```\n```shift = [start, end, backward_shift]```\n```pos[start] -= 1```\n```pos[end+1] += 1```\n```shifts = [[0,1,0],[1,2,1],[0,2,1]]```\n```pos = [0, 0, 0 ,0]```\n```shift=[0, 1, 0]```\n``` pos = [-1, 0, 1, 0]```\n```shift=[1,2,1]```\n``` pos =[-1, 1, 1, -1]```\n```shift=[0,2,1]```\n``` pos = [0, 1, 1, -2]```\n```pos = [0, 1, 1, -2]```\n```s[i]```\n```pos[i]```\n```pos[0]+pos[1]+pos[2]+....+pos[i]```\n```len(pos)=len(s)+1```\n```pos[end+1]```\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        pos = [0 for i in range(len(s)+1)] # to store the shift value\\n        for start, end, direction in shifts:\\n            if direction: # increase all chars in s[start:end+1] by 1\\n                pos[start] += 1  # marks the position from which increment starts\\n                pos[end+1] -= 1 # marks the position where the increment stops\\n            else: # decrease all chars in s[start:end+1] by 1\\n                pos[start] -= 1 # marks the position where decrement starts\\n                pos[end+1] += 1 # marks the position where the decrement stops\\n        cur = 0 # for index i, cur = the net increase or decrease of s[i]\\n\\t\\tres = \"\"\\n        for i in range(len(s)):\\n            cur += pos[i]\\n            res += chr((cur+ord(s[i])-97)%26 + 97)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475078,
                "title": "easy-understanding-prefix-sum-approach-detailed-aprroach-o-n-c-faster",
                "content": "In Brute force approach , we are traversing left to right and performing operation for each ith shift. So, to optimise the brute force approach , Instead of iterating through the range, we can add a +1 if we are moving forward in the beginning of the range and -1 in the end of the range to make sure we are no longer applying the change. The same thing goes for the backward direction with the -1 at the beginning and +1 at the end.\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<int> offsets(n+1);\\n        \\n        for (auto i : shifts) {\\n            int direction = i[2];\\n            \\n            offsets[i[0]] += (direction == 1)? 1: -1;\\n            offsets[i[1]+1] -= (direction == 1)? 1: -1;\\n        }\\n        \\n        int prefix = 0;\\n        string result = \"\";\\n        \\n        for (int j = 0; j < n; j ++) {\\n            prefix += offsets[j];\\n            while (prefix < 0) prefix += 26;\\n            \\n            int ch = (s[j] - \\'a\\' + prefix) % 26;\\n            result += (char)(\\'a\\' + ch);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<int> offsets(n+1);\\n        \\n        for (auto i : shifts) {\\n            int direction = i[2];\\n            \\n            offsets[i[0]] += (direction == 1)? 1: -1;\\n            offsets[i[1]+1] -= (direction == 1)? 1: -1;\\n        }\\n        \\n        int prefix = 0;\\n        string result = \"\";\\n        \\n        for (int j = 0; j < n; j ++) {\\n            prefix += offsets[j];\\n            while (prefix < 0) prefix += 26;\\n            \\n            int ch = (s[j] - \\'a\\' + prefix) % 26;\\n            result += (char)(\\'a\\' + ch);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463201,
                "title": "shifting-letters-2-prefix-sum-method",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        int n=s.size();\\n        vector <int> precalc(n+1);\\n        \\n        for(int i=0; i<shifts.size(); i++)\\n        {\\n            if(shifts[i][2]==0)\\n            {\\n                precalc[shifts[i][0]]--;\\n                precalc[shifts[i][1]+1]++;\\n            }\\n            else\\n            {\\n                precalc[shifts[i][0]]++;\\n                precalc[shifts[i][1]+1]--;\\n            }\\n        }\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            precalc[i-1]=precalc[i-1]%26;\\n            precalc[i]=precalc[i]+precalc[i-1];\\n            precalc[i]=precalc[i]%26;\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int t=s[i]-\\'a\\';\\n            t=t+precalc[i];\\n            if(t>25)\\n                t=t%26;\\n            else if(t<0)\\n                t=26+t;\\n            s[i]=t+\\'a\\';\\n        }\\n        \\n        return s;\\n    }\\n};\\n```\\nNow try doing: https://leetcode.com/problems/describe-the-painting/discuss/2463197/Just-like-Shifting-Letters-2.-Prefix-Sum-Trick.-Commented-Code",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        int n=s.size();\\n        vector <int> precalc(n+1);\\n        \\n        for(int i=0; i<shifts.size(); i++)\\n        {\\n            if(shifts[i][2]==0)\\n            {\\n                precalc[shifts[i][0]]--;\\n                precalc[shifts[i][1]+1]++;\\n            }\\n            else\\n            {\\n                precalc[shifts[i][0]]++;\\n                precalc[shifts[i][1]+1]--;\\n            }\\n        }\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            precalc[i-1]=precalc[i-1]%26;\\n            precalc[i]=precalc[i]+precalc[i-1];\\n            precalc[i]=precalc[i]%26;\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int t=s[i]-\\'a\\';\\n            t=t+precalc[i];\\n            if(t>25)\\n                t=t%26;\\n            else if(t<0)\\n                t=26+t;\\n            s[i]=t+\\'a\\';\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458572,
                "title": "segment-tree-lazy-propagation-o-n-log-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void  update(vector < long long > &segtree, vector < long long > &lazy, long long ind, long long low, long long high, long long l , long long r, long long val){\\n        \\n        if(lazy[ind] != 0){\\n            \\n            segtree[ind] += (high - low + 1) * lazy[ind];\\n            if(low != high){\\n                lazy[2 * ind + 1] += lazy[ind];\\n                lazy[2 * ind + 2] += lazy[ind];\\n            }\\n            lazy[ind] = 0;\\n        }\\n        \\n        if(r < low || l > high || low > high) return;\\n        \\n        if(low >= l && high <= r){\\n            segtree[ind] += (high - low + 1) * val;\\n            if(low != high){\\n                lazy[2 * ind + 1] += val;\\n                lazy[2 * ind + 2] += val;\\n            }\\n            \\n            return;\\n        }\\n        \\n        int mid = low + (high  - low) / 2;\\n        \\n        update(segtree, lazy , 2 * ind + 1, low, mid, l , r, val);\\n        update(segtree, lazy , 2 * ind + 2, mid + 1, high, l , r, val);\\n        segtree[ind] = segtree[2 * ind + 1] + segtree[2 * ind + 2];\\n    \\n    }\\n    \\n    long long get(vector < long long > &segtree, vector < long long > &lazy, long long ind, long long low, long long high, long long l , long long r, long long val){\\n        \\n        if(lazy[ind] != 0){\\n            \\n            segtree[ind] += (high - low + 1) * lazy[ind];\\n            if(low != high){\\n                lazy[2 * ind + 1] += lazy[ind];\\n                lazy[2 * ind + 2] += lazy[ind];\\n            }\\n            lazy[ind] = 0;\\n        }\\n        \\n        if(r < low || l > high || low > high) return 0;\\n        \\n        if(low >= l && high <= r){\\n        \\n            return segtree[ind];\\n            \\n        }\\n        \\n        int mid = low + (high  - low) / 2;\\n        \\n        return get(segtree, lazy , 2 * ind + 1, low, mid, l , r, val) + \\n        get(segtree, lazy , 2 * ind + 2, mid + 1, high, l , r, val);\\n        \\n        \\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.size();\\n        \\n        vector < long long > segtree(4 * n,0);\\n        vector < long long > lazy(4 * n,0);\\n        \\n        for(int i = 0; i < shifts.size(); i++){\\n            long long val = shifts[i][2] == 1 ? 1 : -1;\\n            \\n            update(segtree,lazy,0,0, n - 1, shifts[i][0],shifts[i][1],val);\\n        \\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            long long x = get(segtree,lazy,0,0, n - 1,i,i,0);\\n            \\n            long long y = s[i] - \\'a\\';\\n            \\n            long long z = y + x;\\n            \\n            if(z < 0 ) {\\n              z = -z;\\n              z = (z % 26);\\n              if(z != 0)\\n                z = -z + 26; \\n                \\n            }\\n            else z = z % 26;\\n            \\n            s[i] = (char)(z + 97);\\n            \\n                \\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void  update(vector < long long > &segtree, vector < long long > &lazy, long long ind, long long low, long long high, long long l , long long r, long long val){\\n        \\n        if(lazy[ind] != 0){\\n            \\n            segtree[ind] += (high - low + 1) * lazy[ind];\\n            if(low != high){\\n                lazy[2 * ind + 1] += lazy[ind];\\n                lazy[2 * ind + 2] += lazy[ind];\\n            }\\n            lazy[ind] = 0;\\n        }\\n        \\n        if(r < low || l > high || low > high) return;\\n        \\n        if(low >= l && high <= r){\\n            segtree[ind] += (high - low + 1) * val;\\n            if(low != high){\\n                lazy[2 * ind + 1] += val;\\n                lazy[2 * ind + 2] += val;\\n            }\\n            \\n            return;\\n        }\\n        \\n        int mid = low + (high  - low) / 2;\\n        \\n        update(segtree, lazy , 2 * ind + 1, low, mid, l , r, val);\\n        update(segtree, lazy , 2 * ind + 2, mid + 1, high, l , r, val);\\n        segtree[ind] = segtree[2 * ind + 1] + segtree[2 * ind + 2];\\n    \\n    }\\n    \\n    long long get(vector < long long > &segtree, vector < long long > &lazy, long long ind, long long low, long long high, long long l , long long r, long long val){\\n        \\n        if(lazy[ind] != 0){\\n            \\n            segtree[ind] += (high - low + 1) * lazy[ind];\\n            if(low != high){\\n                lazy[2 * ind + 1] += lazy[ind];\\n                lazy[2 * ind + 2] += lazy[ind];\\n            }\\n            lazy[ind] = 0;\\n        }\\n        \\n        if(r < low || l > high || low > high) return 0;\\n        \\n        if(low >= l && high <= r){\\n        \\n            return segtree[ind];\\n            \\n        }\\n        \\n        int mid = low + (high  - low) / 2;\\n        \\n        return get(segtree, lazy , 2 * ind + 1, low, mid, l , r, val) + \\n        get(segtree, lazy , 2 * ind + 2, mid + 1, high, l , r, val);\\n        \\n        \\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.size();\\n        \\n        vector < long long > segtree(4 * n,0);\\n        vector < long long > lazy(4 * n,0);\\n        \\n        for(int i = 0; i < shifts.size(); i++){\\n            long long val = shifts[i][2] == 1 ? 1 : -1;\\n            \\n            update(segtree,lazy,0,0, n - 1, shifts[i][0],shifts[i][1],val);\\n        \\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            long long x = get(segtree,lazy,0,0, n - 1,i,i,0);\\n            \\n            long long y = s[i] - \\'a\\';\\n            \\n            long long z = y + x;\\n            \\n            if(z < 0 ) {\\n              z = -z;\\n              z = (z % 26);\\n              if(z != 0)\\n                z = -z + 26; \\n                \\n            }\\n            else z = z % 26;\\n            \\n            s[i] = (char)(z + 97);\\n            \\n                \\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455055,
                "title": "easiest-solution-practice-this-type-of-question-becoming-common",
                "content": "Comment for explanation:-\\nIf you find it helpful upvote\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> sum(n+1, 0);\\n        for(int i = 0; i<shifts.size(); i++){\\n            int x = shifts[i][0], y = shifts[i][1]+1;\\n            int dir = shifts[i][2];\\n            if(dir == 1){\\n                sum[x] +=1;\\n                sum[y] -= 1;\\n            }\\n            else{\\n                sum[x] -=1;\\n                sum[y] +=1;\\n            }\\n        }\\n        for(int i = 1; i<=n; i++){\\n            sum[i] += sum[i-1];\\n        }\\n        for(int i = 0; i<n; i++){\\n            int a = sum[i];\\n            if(a<0){\\n                int b = abs(a)%26;\\n                a = s[i]-\\'a\\'+26-b;\\n                s[i] = \\'a\\'+a%26;\\n            }   \\n            else{\\n                a += s[i]-\\'a\\';\\n                s[i] = \\'a\\' + a%26;\\n            }\\n        }\\n        return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> sum(n+1, 0);\\n        for(int i = 0; i<shifts.size(); i++){\\n            int x = shifts[i][0], y = shifts[i][1]+1;\\n            int dir = shifts[i][2];\\n            if(dir == 1){\\n                sum[x] +=1;\\n                sum[y] -= 1;\\n            }\\n            else{\\n                sum[x] -=1;\\n                sum[y] +=1;\\n            }\\n        }\\n        for(int i = 1; i<=n; i++){\\n            sum[i] += sum[i-1];\\n        }\\n        for(int i = 0; i<n; i++){\\n            int a = sum[i];\\n            if(a<0){\\n                int b = abs(a)%26;\\n                a = s[i]-\\'a\\'+26-b;\\n                s[i] = \\'a\\'+a%26;\\n            }   \\n            else{\\n                a += s[i]-\\'a\\';\\n                s[i] = \\'a\\' + a%26;\\n            }\\n        }\\n        return s;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454949,
                "title": "java-ez-2-understand",
                "content": "for more details refer 2\\nhttps://iq.opengenus.org/multiple-array-range-increments-linear-time/\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char arr[]=s.toCharArray();\\n        int n=s.length();\\n        int diff[]=new int[n+1];\\n        for(int shift[]:shifts){\\n            int a=shift[0];\\n            int b=shift[1];\\n            int d=shift[2]==1?1:-1;\\n            diff[a]+=d;\\n            diff[b+1]-=d;\\n        }\\n        diff[0]%=26;\\n        for(int i=1;i<n+1;i++){\\n            diff[i]+=diff[i-1];\\n            diff[i]%=26;\\n        }\\n        for(int i=0;i<n;i++){\\n            int ind=arr[i]+diff[i];\\n            if(ind<97)\\n                ind+=26;\\n            if(ind>122)\\n                ind-=26;\\n            arr[i]=(char)ind;\\n        }\\n        return new String(arr);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char arr[]=s.toCharArray();\\n        int n=s.length();\\n        int diff[]=new int[n+1];\\n        for(int shift[]:shifts){\\n            int a=shift[0];\\n            int b=shift[1];\\n            int d=shift[2]==1?1:-1;\\n            diff[a]+=d;\\n            diff[b+1]-=d;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2454760,
                "title": "c-line-sweep-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& ranges) {\\n        unordered_map<char, int> mp;\\n        string abcd = \"abcdefghijklmnopqrstuvwxyz\";\\n        for(int i=0;i<26;i++){\\n            mp[i] = abcd[i];\\n        }\\n        int seen[50001] = {0};\\n        for(auto r : ranges) {\\n            int dir = r[2] ? 1:-1;\\n            seen[r[0]]+=dir; seen[r[1] + 1]-=dir;\\n        }\\n           \\n        for(int i = 0, prev=0; i < 50001; i++){\\n            seen[i] += prev;\\n            prev = seen[i];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            int temp = s[i] - \\'a\\';\\n            temp = (temp + (seen[i]%26) + 26)%26;\\n            s[i] = mp[temp];\\n        }\\n     \\n        return s;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& ranges) {\\n        unordered_map<char, int> mp;\\n        string abcd = \"abcdefghijklmnopqrstuvwxyz\";\\n        for(int i=0;i<26;i++){\\n            mp[i] = abcd[i];\\n        }\\n        int seen[50001] = {0};\\n        for(auto r : ranges) {\\n            int dir = r[2] ? 1:-1;\\n            seen[r[0]]+=dir; seen[r[1] + 1]-=dir;\\n        }\\n           \\n        for(int i = 0, prev=0; i < 50001; i++){\\n            seen[i] += prev;\\n            prev = seen[i];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            int temp = s[i] - \\'a\\';\\n            temp = (temp + (seen[i]%26) + 26)%26;\\n            s[i] = mp[temp];\\n        }\\n     \\n        return s;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454332,
                "title": "python-shifts",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def shift(self, c, k):\\n        return chr(ord(\\'a\\') + (26 + ord(c) - ord(\\'a\\') + k) % 26)\\n    \\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        freq = defaultdict(int)\\n        for l, r, d in shifts:\\n            d = 2 * d - 1\\n            freq[l] += d\\n            freq[r + 1] -= d\\n        for i in range(1, n + 1):\\n            freq[i] += freq[i - 1]\\n        return \"\".join([self.shift(s[i], freq[i]) for i in range(n)])\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def shift(self, c, k):\\n        return chr(ord(\\'a\\') + (26 + ord(c) - ord(\\'a\\') + k) % 26)\\n    \\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        freq = defaultdict(int)\\n        for l, r, d in shifts:\\n            d = 2 * d - 1\\n            freq[l] += d\\n            freq[r + 1] -= d\\n        for i in range(1, n + 1):\\n            freq[i] += freq[i - 1]\\n        return \"\".join([self.shift(s[i], freq[i]) for i in range(n)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291122,
                "title": "easy-prefix-sum-approach-two-approach",
                "content": "**INTUITION :**\\nWe have to increase/decrease every character by one if lying in the given range.\\n\\n# **First Approach (NAIVE TLE) :**\\nThe naive approach would be for evey shift[i] run a loop from shift[i][0] to shift[i][1] and increment or decrement depending upon shift[i][2].\\nThis is a possible solution but give TLE as per the given constraints.\\n\\n**CODE** *(TLE)*\\n```\\nchar shiftBack(char ch)  //Shift Forword\\n    {\\n        if(ch==\\'a\\')\\n            return \\'z\\';\\n        return char(int(ch) - 1);\\n    }\\n    \\n    char shiftFor(char ch)\\n    {\\n        if(ch==\\'z\\')\\n            return \\'a\\';\\n        return char(int(ch) + 1);\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(auto ele:shifts)\\n        {\\n            int from = ele[0];\\n            int to = ele[1];\\n            int dir = ele[2];\\n            if(dir==0)\\n            {\\n                for(int i=from;i<=to;i++)\\n                {\\n                    s[i]=shiftBack(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                for(int i=from;i<=to;i++)\\n                {\\n                    s[i]=shiftFor(s[i]);\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n```\\n\\n# **Second Approach (Accepted Sol.)**\\n\\nHere in this Approach we are going to use is ***PREFIX SUM***.\\ncreate a vector of integers (say v) assigh 0 to it,\\nFor every shift   \\n*if shift[i][0] is 1*:\\n* \\tIncrease v[shift[i][0]] by 1 and if shift[i][0]+1 is within the range then decrese v[shift[i][0]+1] by 1\\n\\nif shift[i][0] is 0:\\n* \\tdecrease v[shift[i][0]] by 1 and if shift[i][0]+1 is within the range then increase v[shift[i][0]+1] by 1\\n\\n**Then calculate prefix sum in a differnet array (say psum) of v and for every index increment the character at that index by psum[i].**\\n\\n**CODE**(Accepted Sol.)\\n```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int>v(s.length(),0);\\n        \\n        for(auto ele:shifts)\\n        {\\n            int from = ele[0];\\n            int to = ele[1];\\n            int dir = ele[2];\\n            if(dir==0)\\n            {\\n                v[from]--;\\n                if(to+1<v.size())\\n                {\\n                    v[to+1]++;\\n                }\\n            }\\n            else\\n            {\\n                v[from]++;\\n                if(to+1<v.size())\\n                {\\n                    v[to+1]--;\\n                }\\n            }\\n        }\\n        vector<int>psum(v.size(),0);\\n        psum[0]=v[0];\\n        for(int i=1;i<v.size();i++)\\n        {\\n            psum[i]=v[i]+psum[i-1];\\n        }\\n        \\n        for(int i=0;i<psum.size();i++)\\n        {\\n            char res;\\n            int ele = psum[i];\\n            int n=s[i];\\n            ele=ele%26;\\n            if(ele>=0)\\n            {\\n                res = char( (n%97 + ele)%26 + 97);\\n            }\\n            else\\n            {\\n                ele = 26-abs(ele);\\n                res = char( (n%97 + ele)%26 + 97);\\n            }\\n            s[i]=res;\\n        }\\n        return s;\\n    }\\n```\\n\\n***TC: O(N)\\nSC: O(N)***\\n\\n![image](https://assets.leetcode.com/users/images/f25f5a63-0b86-48b9-958a-0e189cadd307_1678691732.0941956.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar shiftBack(char ch)  //Shift Forword\\n    {\\n        if(ch==\\'a\\')\\n            return \\'z\\';\\n        return char(int(ch) - 1);\\n    }\\n    \\n    char shiftFor(char ch)\\n    {\\n        if(ch==\\'z\\')\\n            return \\'a\\';\\n        return char(int(ch) + 1);\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(auto ele:shifts)\\n        {\\n            int from = ele[0];\\n            int to = ele[1];\\n            int dir = ele[2];\\n            if(dir==0)\\n            {\\n                for(int i=from;i<=to;i++)\\n                {\\n                    s[i]=shiftBack(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                for(int i=from;i<=to;i++)\\n                {\\n                    s[i]=shiftFor(s[i]);\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n```\n```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int>v(s.length(),0);\\n        \\n        for(auto ele:shifts)\\n        {\\n            int from = ele[0];\\n            int to = ele[1];\\n            int dir = ele[2];\\n            if(dir==0)\\n            {\\n                v[from]--;\\n                if(to+1<v.size())\\n                {\\n                    v[to+1]++;\\n                }\\n            }\\n            else\\n            {\\n                v[from]++;\\n                if(to+1<v.size())\\n                {\\n                    v[to+1]--;\\n                }\\n            }\\n        }\\n        vector<int>psum(v.size(),0);\\n        psum[0]=v[0];\\n        for(int i=1;i<v.size();i++)\\n        {\\n            psum[i]=v[i]+psum[i-1];\\n        }\\n        \\n        for(int i=0;i<psum.size();i++)\\n        {\\n            char res;\\n            int ele = psum[i];\\n            int n=s[i];\\n            ele=ele%26;\\n            if(ele>=0)\\n            {\\n                res = char( (n%97 + ele)%26 + 97);\\n            }\\n            else\\n            {\\n                ele = 26-abs(ele);\\n                res = char( (n%97 + ele)%26 + 97);\\n            }\\n            s[i]=res;\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3163358,
                "title": "prefix-sum-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int>v1(n+1);\\n        for(auto it:shifts){\\n            int from=it[0],to=it[1],move=it[2];\\n            if(move==0){\\n                v1[from]-=1;v1[to+1]+=1;\\n            }else{\\n                v1[from]+=1;v1[to+1]-=1;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            v1[i]+=v1[i-1];\\n        }\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            int a=s[i]-\\'a\\';\\n            if(a+v1[i]>=0){\\n                ans.push_back(\\'a\\'+((a+v1[i])%26));\\n            }else{\\n                if((a+v1[i])%26==0){\\n                    ans.push_back(\\'a\\'+((a+v1[i])%26));\\n                }\\n                else{ans.push_back(\\'a\\'+((a+v1[i])%26)+26);}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int>v1(n+1);\\n        for(auto it:shifts){\\n            int from=it[0],to=it[1],move=it[2];\\n            if(move==0){\\n                v1[from]-=1;v1[to+1]+=1;\\n            }else{\\n                v1[from]+=1;v1[to+1]-=1;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            v1[i]+=v1[i-1];\\n        }\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            int a=s[i]-\\'a\\';\\n            if(a+v1[i]>=0){\\n                ans.push_back(\\'a\\'+((a+v1[i])%26));\\n            }else{\\n                if((a+v1[i])%26==0){\\n                    ans.push_back(\\'a\\'+((a+v1[i])%26));\\n                }\\n                else{ans.push_back(\\'a\\'+((a+v1[i])%26)+26);}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816587,
                "title": "java-entire-thought-process-working-explained-commented",
                "content": "**I\\'m damn sure, If you read then you\\'ll learn some new insights**\\n**Must read in order to learn, Clean Code at the end of commented one otherwise**\\n\\n```\\n/*\\n    Learning Factor\\n    ---------------\\n        + Whenever you encountered such a question in which interval(s) is involved/\\n            something similar to that/can be converted a problem into the interval\\n            type problem.\\n                - and the operations(addition in a range/updation by value/subtraction\\n                by value/something similar kind) is/are needs to be done in \\n                for each interval and then at the end we\\'ve to return the final\\n                state of something(updated array/updated string/final updated sums).\\n                \\n                - to know whether two/more line segments are intersection or NOT/\\n                    overlapping to each other(how-many parallel events are going on)\\n                    \\n                for such above type of requirement(s), you MUST use this technique\\n                or at least you should go for it.\\n                \\n     \\n     NOTE: Instead doing the given operation(s) for each interval naively, accumulate\\n            the operation(s)(count of type operations) for each number by \\n            considering all the given intervals and perform the operation(s) exactly \\n            once to accumulated number of times.\\n     \\n    \\n    Let\\'s how it works\\n    ------------------\\n        \\n        Let\\'s say we\\'ve an array of size n, intially filled with zeros.\\n        Your goal is to increament each indices in b/w [start, end] (inclusive)\\n        by 1 for each given list of intervals & return the final state of the array.\\n        \\n        arr = [0, 0, 0, 0, 0, 0, 0], intervals = [[3, 4], [0, 4], [1, 2]]\\n        \\n        \\n        Let\\'s update the given array naively for interval [3, 4]\\n        -------------- -------------- -------------- ------------------ \\n        \\n        arr = [0, 0, 0, 1, 1, 0, 0], \\n            \\n           number -> increament_count(accumulated operation count)\\n                3 -> 1\\n                4 -> 1\\n        \\n        \\n       for interval [0, 4]\\n       -------------------- \\n        \\n        arr = [1, 1, 1, 2, 2, 0, 0], \\n            \\n           number -> increament_count(accumulated operation count)\\n                0 -> 1\\n                1 -> 1\\n                2 -> 1\\n                3 -> 2\\n                4 -> 2\\n        \\n       for interval [1, 22\\n       -------------------- \\n        \\n        arr = [1, 2, 2, 2, 2, 0, 0], \\n        \\n        Table:\\n        ------\\n            \\n           number -> increament_count(accumulated operation count)\\n                0 -> 1\\n                1 -> 2\\n                2 -> 2\\n                3 -> 2\\n                4 -> 2\\n        \\n       \\n       Time Complexity of Naive approach: O(interval_cnt * len(arr))\\n                                            + in the worst case, [start, end]\\n                                                can always be [0, len(arr) - 1]\\n       \\n       NOTE: If we look at the table carefully, we\\'ll found that each value\\n                corresponding to an index \\'i\\' is nothing but telling that\\n                how many in total index \\'i\\' is updated/increamented.\\n        \\n              If we somehow able to know that count for each index \\'i\\' then we can\\n              go to that index and assign the count at once. Instead going to \\'i\\'\\n              for each interval and updating it.\\n                    + this will improve our time complexity drastically.\\n      \\n      Now, let\\'s see the same result by our technique\\n      -----------------------------------------------\\n      \\n        arr = [0, 0, 0, 0, 0, 0, 0], intervals = [[3, 4], [0, 4], [1, 2]]\\n        \\n        \\n        For interval [3, 4]\\n        --------------------\\n        \\n        naive = [0, 0, 0, 1, 1, 0, 0]\\n        \\n        table = [0, 0, 0, 1, 0, -1, 0, 0] --> created (len(arr) + 1) size, omittable\\n                          ^      ^\\n                          |      |\\n                        +1 here  -1 here\\n                    at index \\'3\\'  at index \\'4 + 1 = 5\\'\\n            \\n        if we do prefix sum of \\'talbe\\' array then we would get:\\n        \\n        psum = [0, 0, 0, 1, 1, 0, 0, 0]   --> exact same as \\'naive\\' one\\n        \\n        NOTE: Adding +1 to an ith index in table array will contribute +1 to\\n                all the way starting from \\'i\\'th index to up-until the end \\'n\\'.\\n                \\n                See this for what I\\'ve said above:\\n                \\n                adding +1 to index \\'3\\'\\n                =====================\\n                                  \\n                                  1  1  1  1  1\\n                talbe = [0, 0, 0, 0, 0, 0, 0, 0]\\n                                  \\n                adding -1 to index \\'(4 + 1)\\'\\n                =====================\\n                                  \\n                                  1  1  1  1  1     -> contribution of +1\\n                                       -1 -1 -1     -> contibution of -1\\n                table = [0, 0, 0, 0, 0, 0, 0, 0]\\n                \\n                \\n                when we take the prefix sum of above talbe array:\\n                                    \\n                                  1  1  1  1  1     \\n                                       -1 -1 -1    \\n                table = [0, 0, 0, 1, 1, 0, 0, 0]\\n                                  +--+  +-----+\\n                                    ^      ^\\n                                    |      |\\n                                    |      |\\n                                    |  this part (1 + (-1) = 0) gets zero/cancelled out.\\n                                    |    \\n                           only changes made into our\\n                           required interval [3, 4]\\n                           \\n             NOTE: Subtracted -1 at index (R + 1) for given interval [L, R] (inclusive)\\n                    and added +1 at index (L).\\n                    \\n                    why not R? because \\'R\\' is inclusive. Otherwise, subtracting at (R)\\n                    is OK.\\n                    \\n                    **** Think why at (R + 1)? you know the reason. ****\\n       \\n       Similarly after we\\'ve done +1 & -1 for each interval accordingly, take the prefix\\n        sum of the table array. At the end each number corresponding to an index \\'i\\'\\n        is nothing but total number(accumulated operation count) for that index \\'i\\'.\\n       \\n*/\\n```\\n\\n```\\nImplementation\\n```\\n\\n```\\nclass Solution {\\n    \\n    private static final char[] alphabet;\\n    static {\\n        alphabet = new char[26];\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch += 1) {\\n            alphabet[ch - \\'a\\'] = ch;\\n        }\\n    }\\n    \\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        // +1 to avoid extra check when (R + 1) is out of bound of array index.\\n        // To provide more meaningful meaning, I\\'m using 2 arrays. -> can be done in\\n        // single array as well.\\n        // forwardShift[i] -> tells total how many times the character at \\'ith\\'\\n        // index in the given string \\'s\\' is shifted in forward direction. Similar goes\\n        // to backwardShift.\\n        int[] forwardShift = new int[n + 1];\\n        int[] backwardShift = new int[n + 1];\\n        \\n        for(int i = 0; i < shifts.length; i += 1) {\\n            final int L = shifts[i][0], R = shifts[i][1], DIR = shifts[i][2];\\n            if(DIR == 1) {\\n                forwardShift[L] += 1;\\n                forwardShift[R + 1] -= 1;\\n            } else {\\n                // Updation also gets reversed when direction gets reversed.\\n                backwardShift[L] -= 1;\\n                backwardShift[R + 1] += 1;\\n            }\\n        }\\n        \\n        // building prefix sums\\n        for(int i = 1; i <= n; i += 1) {\\n            forwardShift[i] += forwardShift[i - 1];\\n            backwardShift[i] += backwardShift[i - 1];\\n        }\\n        \\n        StringBuilder shiftedFinalString = new StringBuilder();\\n        \\n        for(int i = 0; i < n; i += 1) {\\n            int totalShiftCount = forwardShift[i] + backwardShift[i];\\n            \\n            // You know the reason why?? we\\'re doing (cnt % 26 + 26) when cnt < 0\\n            if(totalShiftCount < 0) totalShiftCount = totalShiftCount % 26 + 26;\\n            int alphaPosition = s.charAt(i) - \\'a\\';\\n            \\n            // Shifting operation is performing Here (alphaPosition + totalShiftCount)\\n            char newShiftedChar = alphabet[(alphaPosition + totalShiftCount) % 26];\\n            shiftedFinalString.append(newShiftedChar);\\n        }\\n       \\n        return shiftedFinalString.toString();\\n    }\\n}\\n```\\n\\n\\n```\\nClean Code\\n```\\n\\n```\\nclass Solution {\\n    \\n    private static final char[] alphabet;\\n    static {\\n        alphabet = new char[26];\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch += 1) {\\n            alphabet[ch - \\'a\\'] = ch;\\n        }\\n    }\\n    \\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        int[] forwardShift = new int[n + 1];\\n        int[] backwardShift = new int[n + 1];\\n        \\n        for(int i = 0; i < shifts.length; i += 1) {\\n            final int L = shifts[i][0], R = shifts[i][1], DIR = shifts[i][2];\\n            if(DIR == 1) {\\n                forwardShift[L] += 1;\\n                forwardShift[R + 1] -= 1;\\n            } else {\\n                backwardShift[L] -= 1;\\n                backwardShift[R + 1] += 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i += 1) {\\n            forwardShift[i] += forwardShift[i - 1];\\n            backwardShift[i] += backwardShift[i - 1];\\n        }\\n        \\n        StringBuilder shiftedFinalString = new StringBuilder();\\n        for(int i = 0; i < n; i += 1) {\\n            int totalShiftCount = forwardShift[i] + backwardShift[i];\\n            if(totalShiftCount < 0) \\n                totalShiftCount = totalShiftCount % 26 + 26;\\n            \\n            int alphaPosition = s.charAt(i) - \\'a\\';\\n            char newShiftedChar = alphabet[(alphaPosition + totalShiftCount) % 26];\\n            shiftedFinalString.append(newShiftedChar);\\n        }\\n       \\n        return shiftedFinalString.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Learning Factor\\n    ---------------\\n        + Whenever you encountered such a question in which interval(s) is involved/\\n            something similar to that/can be converted a problem into the interval\\n            type problem.\\n                - and the operations(addition in a range/updation by value/subtraction\\n                by value/something similar kind) is/are needs to be done in \\n                for each interval and then at the end we\\'ve to return the final\\n                state of something(updated array/updated string/final updated sums).\\n                \\n                - to know whether two/more line segments are intersection or NOT/\\n                    overlapping to each other(how-many parallel events are going on)\\n                    \\n                for such above type of requirement(s), you MUST use this technique\\n                or at least you should go for it.\\n                \\n     \\n     NOTE: Instead doing the given operation(s) for each interval naively, accumulate\\n            the operation(s)(count of type operations) for each number by \\n            considering all the given intervals and perform the operation(s) exactly \\n            once to accumulated number of times.\\n     \\n    \\n    Let\\'s how it works\\n    ------------------\\n        \\n        Let\\'s say we\\'ve an array of size n, intially filled with zeros.\\n        Your goal is to increament each indices in b/w [start, end] (inclusive)\\n        by 1 for each given list of intervals & return the final state of the array.\\n        \\n        arr = [0, 0, 0, 0, 0, 0, 0], intervals = [[3, 4], [0, 4], [1, 2]]\\n        \\n        \\n        Let\\'s update the given array naively for interval [3, 4]\\n        -------------- -------------- -------------- ------------------ \\n        \\n        arr = [0, 0, 0, 1, 1, 0, 0], \\n            \\n           number -> increament_count(accumulated operation count)\\n                3 -> 1\\n                4 -> 1\\n        \\n        \\n       for interval [0, 4]\\n       -------------------- \\n        \\n        arr = [1, 1, 1, 2, 2, 0, 0], \\n            \\n           number -> increament_count(accumulated operation count)\\n                0 -> 1\\n                1 -> 1\\n                2 -> 1\\n                3 -> 2\\n                4 -> 2\\n        \\n       for interval [1, 22\\n       -------------------- \\n        \\n        arr = [1, 2, 2, 2, 2, 0, 0], \\n        \\n        Table:\\n        ------\\n            \\n           number -> increament_count(accumulated operation count)\\n                0 -> 1\\n                1 -> 2\\n                2 -> 2\\n                3 -> 2\\n                4 -> 2\\n        \\n       \\n       Time Complexity of Naive approach: O(interval_cnt * len(arr))\\n                                            + in the worst case, [start, end]\\n                                                can always be [0, len(arr) - 1]\\n       \\n       NOTE: If we look at the table carefully, we\\'ll found that each value\\n                corresponding to an index \\'i\\' is nothing but telling that\\n                how many in total index \\'i\\' is updated/increamented.\\n        \\n              If we somehow able to know that count for each index \\'i\\' then we can\\n              go to that index and assign the count at once. Instead going to \\'i\\'\\n              for each interval and updating it.\\n                    + this will improve our time complexity drastically.\\n      \\n      Now, let\\'s see the same result by our technique\\n      -----------------------------------------------\\n      \\n        arr = [0, 0, 0, 0, 0, 0, 0], intervals = [[3, 4], [0, 4], [1, 2]]\\n        \\n        \\n        For interval [3, 4]\\n        --------------------\\n        \\n        naive = [0, 0, 0, 1, 1, 0, 0]\\n        \\n        table = [0, 0, 0, 1, 0, -1, 0, 0] --> created (len(arr) + 1) size, omittable\\n                          ^      ^\\n                          |      |\\n                        +1 here  -1 here\\n                    at index \\'3\\'  at index \\'4 + 1 = 5\\'\\n            \\n        if we do prefix sum of \\'talbe\\' array then we would get:\\n        \\n        psum = [0, 0, 0, 1, 1, 0, 0, 0]   --> exact same as \\'naive\\' one\\n        \\n        NOTE: Adding +1 to an ith index in table array will contribute +1 to\\n                all the way starting from \\'i\\'th index to up-until the end \\'n\\'.\\n                \\n                See this for what I\\'ve said above:\\n                \\n                adding +1 to index \\'3\\'\\n                =====================\\n                                  \\n                                  1  1  1  1  1\\n                talbe = [0, 0, 0, 0, 0, 0, 0, 0]\\n                                  \\n                adding -1 to index \\'(4 + 1)\\'\\n                =====================\\n                                  \\n                                  1  1  1  1  1     -> contribution of +1\\n                                       -1 -1 -1     -> contibution of -1\\n                table = [0, 0, 0, 0, 0, 0, 0, 0]\\n                \\n                \\n                when we take the prefix sum of above talbe array:\\n                                    \\n                                  1  1  1  1  1     \\n                                       -1 -1 -1    \\n                table = [0, 0, 0, 1, 1, 0, 0, 0]\\n                                  +--+  +-----+\\n                                    ^      ^\\n                                    |      |\\n                                    |      |\\n                                    |  this part (1 + (-1) = 0) gets zero/cancelled out.\\n                                    |    \\n                           only changes made into our\\n                           required interval [3, 4]\\n                           \\n             NOTE: Subtracted -1 at index (R + 1) for given interval [L, R] (inclusive)\\n                    and added +1 at index (L).\\n                    \\n                    why not R? because \\'R\\' is inclusive. Otherwise, subtracting at (R)\\n                    is OK.\\n                    \\n                    **** Think why at (R + 1)? you know the reason. ****\\n       \\n       Similarly after we\\'ve done +1 & -1 for each interval accordingly, take the prefix\\n        sum of the table array. At the end each number corresponding to an index \\'i\\'\\n        is nothing but total number(accumulated operation count) for that index \\'i\\'.\\n       \\n*/\\n```\n```\\nImplementation\\n```\n```\\nclass Solution {\\n    \\n    private static final char[] alphabet;\\n    static {\\n        alphabet = new char[26];\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch += 1) {\\n            alphabet[ch - \\'a\\'] = ch;\\n        }\\n    }\\n    \\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        // +1 to avoid extra check when (R + 1) is out of bound of array index.\\n        // To provide more meaningful meaning, I\\'m using 2 arrays. -> can be done in\\n        // single array as well.\\n        // forwardShift[i] -> tells total how many times the character at \\'ith\\'\\n        // index in the given string \\'s\\' is shifted in forward direction. Similar goes\\n        // to backwardShift.\\n        int[] forwardShift = new int[n + 1];\\n        int[] backwardShift = new int[n + 1];\\n        \\n        for(int i = 0; i < shifts.length; i += 1) {\\n            final int L = shifts[i][0], R = shifts[i][1], DIR = shifts[i][2];\\n            if(DIR == 1) {\\n                forwardShift[L] += 1;\\n                forwardShift[R + 1] -= 1;\\n            } else {\\n                // Updation also gets reversed when direction gets reversed.\\n                backwardShift[L] -= 1;\\n                backwardShift[R + 1] += 1;\\n            }\\n        }\\n        \\n        // building prefix sums\\n        for(int i = 1; i <= n; i += 1) {\\n            forwardShift[i] += forwardShift[i - 1];\\n            backwardShift[i] += backwardShift[i - 1];\\n        }\\n        \\n        StringBuilder shiftedFinalString = new StringBuilder();\\n        \\n        for(int i = 0; i < n; i += 1) {\\n            int totalShiftCount = forwardShift[i] + backwardShift[i];\\n            \\n            // You know the reason why?? we\\'re doing (cnt % 26 + 26) when cnt < 0\\n            if(totalShiftCount < 0) totalShiftCount = totalShiftCount % 26 + 26;\\n            int alphaPosition = s.charAt(i) - \\'a\\';\\n            \\n            // Shifting operation is performing Here (alphaPosition + totalShiftCount)\\n            char newShiftedChar = alphabet[(alphaPosition + totalShiftCount) % 26];\\n            shiftedFinalString.append(newShiftedChar);\\n        }\\n       \\n        return shiftedFinalString.toString();\\n    }\\n}\\n```\n```\\nClean Code\\n```\n```\\nclass Solution {\\n    \\n    private static final char[] alphabet;\\n    static {\\n        alphabet = new char[26];\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch += 1) {\\n            alphabet[ch - \\'a\\'] = ch;\\n        }\\n    }\\n    \\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        int[] forwardShift = new int[n + 1];\\n        int[] backwardShift = new int[n + 1];\\n        \\n        for(int i = 0; i < shifts.length; i += 1) {\\n            final int L = shifts[i][0], R = shifts[i][1], DIR = shifts[i][2];\\n            if(DIR == 1) {\\n                forwardShift[L] += 1;\\n                forwardShift[R + 1] -= 1;\\n            } else {\\n                backwardShift[L] -= 1;\\n                backwardShift[R + 1] += 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i += 1) {\\n            forwardShift[i] += forwardShift[i - 1];\\n            backwardShift[i] += backwardShift[i - 1];\\n        }\\n        \\n        StringBuilder shiftedFinalString = new StringBuilder();\\n        for(int i = 0; i < n; i += 1) {\\n            int totalShiftCount = forwardShift[i] + backwardShift[i];\\n            if(totalShiftCount < 0) \\n                totalShiftCount = totalShiftCount % 26 + 26;\\n            \\n            int alphaPosition = s.charAt(i) - \\'a\\';\\n            char newShiftedChar = alphabet[(alphaPosition + totalShiftCount) % 26];\\n            shiftedFinalString.append(newShiftedChar);\\n        }\\n       \\n        return shiftedFinalString.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630531,
                "title": "c-easy-to-understand-step-by-step",
                "content": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int len=s.length();\\n        vector<int> dir(len+1, 0);\\n        for(auto &shift: shifts){\\n            int start=shift[0], end=shift[1], job=(shift[2]==1)?1:-1;\\n            if(job==1)\\n                dir[start]++, dir[end+1]--;\\n            else\\n                dir[start]--, dir[end+1]++;\\n        }\\n        long long job=0;\\n        for(int i=0; i<len; i++){\\n            job+=dir[i];\\n            s[i]=((s[i]-\\'a\\')+job+260000000LL)%26+\\'a\\';\\n        }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int len=s.length();\\n        vector<int> dir(len+1, 0);\\n        for(auto &shift: shifts){\\n            int start=shift[0], end=shift[1], job=(shift[2]==1)?1:-1;\\n            if(job==1)\\n                dir[start]++, dir[end+1]--;\\n            else\\n                dir[start]--, dir[end+1]++;\\n        }\\n        long long job=0;\\n        for(int i=0; i<len; i++){\\n            job+=dir[i];\\n            s[i]=((s[i]-\\'a\\')+job+260000000LL)%26+\\'a\\';\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2519438,
                "title": "python3-o-n-solution",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n      grid = [0]*(len(s)+1)\\n      \\n      for start, end, flag in shifts:\\n        if flag:\\n          grid[start] += 1\\n          grid[end+1] -= 1\\n        else:\\n          grid[start] -= 1\\n          grid[end+1] += 1\\n          \\n      start = grid[0]\\n      \\n      for i in range(1, len(grid)):\\n        start += grid[i]\\n        grid[i] = (start % 26)\\n        \\n      res = []\\n      \\n      for i in range(len(s)):\\n        res.append(chr((ord(s[i]) - 97 + grid[i]) % 26 + 97))\\n        \\n      return \\'\\'.join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n      grid = [0]*(len(s)+1)\\n      \\n      for start, end, flag in shifts:\\n        if flag:\\n          grid[start] += 1\\n          grid[end+1] -= 1\\n        else:\\n          grid[start] -= 1\\n          grid[end+1] += 1\\n          \\n      start = grid[0]\\n      \\n      for i in range(1, len(grid)):\\n        start += grid[i]\\n        grid[i] = (start % 26)\\n        \\n      res = []\\n      \\n      for i in range(len(s)):\\n        res.append(chr((ord(s[i]) - 97 + grid[i]) % 26 + 97))\\n        \\n      return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493593,
                "title": "c-line-sweep-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    map<char,int> mpp ;\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(char ch = \\'a\\' ; ch <= \\'z\\' ; ++ch ) mpp[ch - \\'a\\'] = ch ;\\n        vector<int> sweepForward(s.size() + 1) , sweepBackward(s.size() + 1) ;\\n        \\n        for(auto &x : shifts){\\n            int i = x[0] , j = x[1] , dir = x[2] ;\\n            if(dir){\\n                //move Forward\\n                sweepForward[i] += 1 ;\\n                sweepForward[j + 1] -= 1 ;\\n            }else{\\n                //move Backwards\\n                sweepBackward[i] += 1 ;\\n                sweepBackward[j + 1] -= 1 ;\\n            }\\n        }\\n        \\n        //find prefix sum of both the arrays ;\\n        for(int i = 1 ; i <= s.size() ; ++i) sweepBackward[i] += sweepBackward[i - 1] ,sweepForward[i] += sweepForward[i - 1] ;\\n        \\n        \\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            int travel = sweepForward[i] - sweepBackward[i] ;\\n            travel %= 26 ;\\n            if(travel > 0){\\n                int temp = (s[i] - \\'a\\') + travel ;\\n                s[i] = mpp[temp % 26] ;\\n            }else{\\n                travel *= -1 ;\\n                int temp = abs(26 + (s[i] - \\'a\\') - travel) ;\\n                s[i] = mpp[temp % 26] ;\\n            }\\n            \\n        }\\n        \\n        return s ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<char,int> mpp ;\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(char ch = \\'a\\' ; ch <= \\'z\\' ; ++ch ) mpp[ch - \\'a\\'] = ch ;\\n        vector<int> sweepForward(s.size() + 1) , sweepBackward(s.size() + 1) ;\\n        \\n        for(auto &x : shifts){\\n            int i = x[0] , j = x[1] , dir = x[2] ;\\n            if(dir){\\n                //move Forward\\n                sweepForward[i] += 1 ;\\n                sweepForward[j + 1] -= 1 ;\\n            }else{\\n                //move Backwards\\n                sweepBackward[i] += 1 ;\\n                sweepBackward[j + 1] -= 1 ;\\n            }\\n        }\\n        \\n        //find prefix sum of both the arrays ;\\n        for(int i = 1 ; i <= s.size() ; ++i) sweepBackward[i] += sweepBackward[i - 1] ,sweepForward[i] += sweepForward[i - 1] ;\\n        \\n        \\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            int travel = sweepForward[i] - sweepBackward[i] ;\\n            travel %= 26 ;\\n            if(travel > 0){\\n                int temp = (s[i] - \\'a\\') + travel ;\\n                s[i] = mpp[temp % 26] ;\\n            }else{\\n                travel *= -1 ;\\n                int temp = abs(26 + (s[i] - \\'a\\') - travel) ;\\n                s[i] = mpp[temp % 26] ;\\n            }\\n            \\n        }\\n        \\n        return s ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492482,
                "title": "python-3-prefix-sum-explanation",
                "content": "### Explanation\\n- Use prefix sum to avoid extra calculations on overlapped ranges\\n- The key is, for each shift\\n\\t- Accumulate the direction at the beginning of this shift (-1 for left, 1 for right)\\n\\t- Accumulate the inversed direction at the index after the end of this shift (1 for left, -1 for right). This is to cancel out the effect from the shift starting from the beginning index\\n\\t- For example (first example from the problem description):\\n\\t\\t- `s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]`\\n\\t\\t```\\n\\t\\tindex   : 0  1  2\\n\\t\\tshift #1:-1  *  1  -> starting from index 0, shift to left, at index 2, negate the left shift since no shift needed starting from here\\n\\t\\tshift #2: x  1  *  -> starting from index 1, shift to right, to the end\\n\\t\\tshift #3: 1  *  *  -> starting from index 0, shift to right, to the end\\n\\t\\t\\n\\t\\tx: meaning empty 0\\n\\t\\t*: meaning same as previous, but can be considered as 0 with prefix sum\\n\\t\\t```\\n\\t\\t- Then we need to accumulate shifts for each index, and do a prefix sum for the next index\\n\\t\\t```\\n\\t\\tindex   : 0  1  2\\n\\t\\tshift #1:-1  *  1  \\n\\t\\tshift #2: x  1  *  \\n\\t\\tshift #3: 1  *  *  \\n\\t\\t\\n\\t\\tsum for each column (we used a `Counter` for this calculation below)\\n\\t\\tindex 0: -1 + 1 = 0\\n\\t\\tindex 1: 0 + 1 = 1 # 0 is the result from the previous calculation (prefix sum)\\n\\t\\tindex 2: 1 + 1 = 2 # first 1 is the result from the previous calculation (prefix sum)\\n\\t\\t```\\n\\t\\t- Now we know, for `s = \"abc\"`:\\n\\t\\t\\t- No shift is needed for index 0, we get `a` \\n\\t\\t\\t- 1 right shift is needed for index 1, we get `c`\\n\\t\\t\\t- 2 right shifts are needed for index 2, we get `e`\\n\\t\\t\\t- The result is `ace`\\n- Time: `O(n), n = len(s)`\\n### Implementation\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        d = collections.Counter()\\n        for st, e, right in shifts:\\n            d[st] += 1 if right else -1         # Mark at the beginning to indicate everything after it need to be shifted\\n            if e+1 < n:                         # Mark (inversely) at the index after the end, to negate the unnecessary shifts\\n                d[e+1] += -1 if right else 1\\n        prefix = [0]                            # Initialize the prefix array\\n        ans = \\'\\'\\n        for i in range(n):                      # Use prefix sum style to accumulate all shifts needed, which were carried over from the previous index\\n            cur = prefix[-1] + d[i]\\n            prefix.append(cur)\\n            ans += string.ascii_lowercase[(ord(s[i]) - ord(\\'a\\') + cur) % 26]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\n\\t\\tindex   : 0  1  2\\n\\t\\tshift #1:-1  *  1  -> starting from index 0, shift to left, at index 2, negate the left shift since no shift needed starting from here\\n\\t\\tshift #2: x  1  *  -> starting from index 1, shift to right, to the end\\n\\t\\tshift #3: 1  *  *  -> starting from index 0, shift to right, to the end\\n\\t\\t\\n\\t\\tx: meaning empty 0\\n\\t\\t*: meaning same as previous, but can be considered as 0 with prefix sum\\n\\t\\t```\n```\\n\\t\\tindex   : 0  1  2\\n\\t\\tshift #1:-1  *  1  \\n\\t\\tshift #2: x  1  *  \\n\\t\\tshift #3: 1  *  *  \\n\\t\\t\\n\\t\\tsum for each column (we used a `Counter` for this calculation below)\\n\\t\\tindex 0: -1 + 1 = 0\\n\\t\\tindex 1: 0 + 1 = 1 # 0 is the result from the previous calculation (prefix sum)\\n\\t\\tindex 2: 1 + 1 = 2 # first 1 is the result from the previous calculation (prefix sum)\\n\\t\\t```\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        d = collections.Counter()\\n        for st, e, right in shifts:\\n            d[st] += 1 if right else -1         # Mark at the beginning to indicate everything after it need to be shifted\\n            if e+1 < n:                         # Mark (inversely) at the index after the end, to negate the unnecessary shifts\\n                d[e+1] += -1 if right else 1\\n        prefix = [0]                            # Initialize the prefix array\\n        ans = \\'\\'\\n        for i in range(n):                      # Use prefix sum style to accumulate all shifts needed, which were carried over from the previous index\\n            cur = prefix[-1] + d[i]\\n            prefix.append(cur)\\n            ans += string.ascii_lowercase[(ord(s[i]) - ord(\\'a\\') + cur) % 26]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479823,
                "title": "python-brute-force-to-optimised-detailed-explanation",
                "content": "First of all, this problem is an extension of [848. Shifting Letters](https://leetcode.com/problems/shifting-letters/)\\n\\nIf you have not solved that, I recommand you to look into that first.\\nhttps://leetcode.com/problems/shifting-letters/discuss/2479524/Python-Shift-by-sum\\n\\nCan we convert this problem to 848 by updating shifts to store shift value at each index?\\n\\nBrute force way is to loop through all the shifts and range start to end and update the shift value for each index in hashmap - O(N2)\\n\\n```\\n# Brute Force- TLE\\nhashmap = {i: 0 for i in range(len(s))}\\nfor start, end, direction in shifts:\\n\\tfor i in range(start, end + 1):\\n\\t\\tif direction == 1:\\n\\t\\t\\thashmap[i] += 1\\n\\t\\telse:\\n\\t\\t\\thashmap[i] -= 1\\n\\n```\\n***Can we improve this?***\\n\\nLets taken an example\\nWe have to increase value of index [0, 5] by 1\\nOne way is to loop from 0 to 5 and increase each index by 1 - **O(N)**\\n\\nOther way to to increase index 0 by 1 and then apply prefix sum\\n[1, 0, 0, 0, 0]\\nprefix[1] = prefix[0] + prefix[1] => 1 + 0 = 1\\nprefix[2] = prefix[1] + prefix[2] => 1 + 0 = 1\\n.......\\nwe will get [1, 1, 1, 1, 1] - **O(1)**\\n\\n```\\n\\n\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        prefix = [0] * (len(s) + 1)\\n        for start, end, direction in shifts:\\n            if direction == 1:\\n                prefix[start] += 1\\n                prefix[end + 1] -= 1\\n            else:\\n                prefix[start] -= 1\\n                prefix[end + 1] += 1\\n        \\n        res = []\\n        for i, c in enumerate(s):\\n            shift = prefix[i]\\n            res.append(chr(((ord(c) - 97 + shift) % 26) + 97))\\n            prefix[i + 1] += prefix[i]\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\n# Brute Force- TLE\\nhashmap = {i: 0 for i in range(len(s))}\\nfor start, end, direction in shifts:\\n\\tfor i in range(start, end + 1):\\n\\t\\tif direction == 1:\\n\\t\\t\\thashmap[i] += 1\\n\\t\\telse:\\n\\t\\t\\thashmap[i] -= 1\\n\\n```\n```\\n\\n\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        prefix = [0] * (len(s) + 1)\\n        for start, end, direction in shifts:\\n            if direction == 1:\\n                prefix[start] += 1\\n                prefix[end + 1] -= 1\\n            else:\\n                prefix[start] -= 1\\n                prefix[end + 1] += 1\\n        \\n        res = []\\n        for i, c in enumerate(s):\\n            shift = prefix[i]\\n            res.append(chr(((ord(c) - 97 + shift) % 26) + 97))\\n            prefix[i + 1] += prefix[i]\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474340,
                "title": "python-3-100-in-time-100-in-space",
                "content": "Consider an array of size 11 intialized with zeros.\\n**[0,0,0,0,0,0,0,0,0,0,  0]**   **<-** array\\n**[0,1,2,3,4,5,6,7,8,9,10]**   **<-** index\\nNow if you want to repeatedly increase count in a range then you can use prefix sum.\\nAssume you want to increase the count from range [1,6],[1,7],[1,8] then simply increase the count at start and decrease the count at end+1 i.e,\\nthe modified array after first query [1,6] would be as \\n**[0,1,0,0,0,0,0,-1,0,0,0]**\\nnow perform prefix sum then the result would be as\\n**[0,1,1,1,1,1,1,0,0,0,0]**\\nthis result is equivalent to iterating from start to end and increasing the count.\\nsimilary look at second query which is [1,7]\\nso the modified array would be\\n**[0,2,0,0,0,0,0,-1,-1,0,0]**\\nso after prefix sum we would have \\n**[0,2,2,2,2,2,2,1,0,0,0]** . so after performing all the shifts we do the final prefix sum and shift the string\\n## Code:-\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        ans = [0]*(len(s)+1)\\n        for i,j,k in shifts:\\n            if k:\\n                ans[i]+=1\\n                ans[j+1]-=1\\n            else:\\n                ans[i]-=1\\n                ans[j+1]+=1\\n        for i in range(1,len(ans)):\\n            ans[i]+=ans[i-1]\\n        del ans[-1]\\n        result = \\'\\'\\n        index=0\\n        for i in ans:\\n            temp = i%26\\n            temp1 = ord(s[index])\\n            sums = temp+temp1\\n            if sums>122:\\n                result+=chr(sums-26)\\n            else:\\n                result+=chr(sums)\\n            index+=1\\n        return result\\n\\n```\\n![image](https://assets.leetcode.com/users/images/a9da71f2-070f-4351-89e9-bc13f01957c9_1661360163.5349534.png)\\n",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        ans = [0]*(len(s)+1)\\n        for i,j,k in shifts:\\n            if k:\\n                ans[i]+=1\\n                ans[j+1]-=1\\n            else:\\n                ans[i]-=1\\n                ans[j+1]+=1\\n        for i in range(1,len(ans)):\\n            ans[i]+=ans[i-1]\\n        del ans[-1]\\n        result = \\'\\'\\n        index=0\\n        for i in ans:\\n            temp = i%26\\n            temp1 = ord(s[index])\\n            sums = temp+temp1\\n            if sums>122:\\n                result+=chr(sums-26)\\n            else:\\n                result+=chr(sums)\\n            index+=1\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472389,
                "title": "c-prefix-sum-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        int m=shifts.size();\\n        \\n        vector<int> arr(n+1,0);\\n        \\n        for(int i=0;i<m;i++){\\n            if(shifts[i][2]==1)\\n            {\\n                arr[shifts[i][0]]++;\\n                arr[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                arr[shifts[i][0]]--;\\n                arr[shifts[i][1]+1]++;\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            arr[i]+=arr[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n            arr[i]=arr[i]%26;\\n            if(arr[i]<0){\\n                arr[i]=arr[i]+26;\\n            }\\n            s[i]=char(int(arr[i]+s[i]-97)%26+97);\\n        }\\n        return s;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        int m=shifts.size();\\n        \\n        vector<int> arr(n+1,0);\\n        \\n        for(int i=0;i<m;i++){\\n            if(shifts[i][2]==1)\\n            {\\n                arr[shifts[i][0]]++;\\n                arr[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                arr[shifts[i][0]]--;\\n                arr[shifts[i][1]+1]++;\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            arr[i]+=arr[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n            arr[i]=arr[i]%26;\\n            if(arr[i]<0){\\n                arr[i]=arr[i]+26;\\n            }\\n            s[i]=char(int(arr[i]+s[i]-97)%26+97);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469075,
                "title": "prefix-sum-easy-clean-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=26;\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> v(s.size()+1,0);\\n        int n=shifts.size();\\n        for(auto it: shifts){\\n            if(it[2]==0){\\n                v[it[0]]--;\\n                v[it[1]+1]++;\\n            }\\n            else{\\n                v[it[0]]++;\\n                v[it[1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<v.size();i++){\\n            v[i]+=v[i-1];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            v[i]%=26;\\n            s[i]=(s[i]-\\'a\\'+v[i]+26)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```\\nTC=O(N)\\nSC=O(N)\\n**Please upvote if you liked my solution :)**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=26;\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> v(s.size()+1,0);\\n        int n=shifts.size();\\n        for(auto it: shifts){\\n            if(it[2]==0){\\n                v[it[0]]--;\\n                v[it[1]+1]++;\\n            }\\n            else{\\n                v[it[0]]++;\\n                v[it[1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<v.size();i++){\\n            v[i]+=v[i-1];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            v[i]%=26;\\n            s[i]=(s[i]-\\'a\\'+v[i]+26)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462692,
                "title": "100-00-of-c-based-on-scanline-algo-prefix-sum-optimise-tc",
                "content": "This is a problem we might be tempted to solve with a brute force approach, directly changing the characters in place at each step, but a quick look at the constraints might make us desist quickly: we might get potentially 50000 shifts covering the whole size of s, which is of the same size, for a grand total of 250M operations, which is definitely not the cheapest we can get.\\n\\nStoring the changes might be much more convenient, but again we need to think how - having an array of s.size() elements we update all the time would hardly be an improvement.\\n\\nGladly this problem seems to be a handbook case for the usage of a difference array!\\n\\nThe core idea of this data structure is that if we receive a change of x across all the values from a to b (included), we are going to do so just by writing x at index a and -x at index b + 1 (cancelling the effect of the first change on a).\\n\\nWhen we go and read through the difference array, we will keep a running count of what changes we encountered, giving us a measure of how they are affecting the current cell. A pretty good solution when we are going to face several changes across potentially very large intervals and when we need to read the final result only once (so we can accept a linear complexity for this!).\\n\\nLet\\'s go for some quick example, for \"abcdefgh\":\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t0\\t0\\t0\\t0\\t0\\t0\\t0\\t // initial values in the difference array\\n```\\nThen we decide to increase by 1 all the values from 1 to 5 , so that we will have:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t0\\t0  -1\\t0\\t // values after the first change\\n```\\nNow we decide to increase by 1 all the values from 4 to 6 , so that we will have:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t1\\t0  -1  -1\\t // values after the second change\\n```\\nNext we decrease by 1 all the values from 2 to 3 , so that we will have:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t0\\t2\\t0  -1  -1\\t // values after the third change; notice index 4 now with a value of 2 from the previous two operations\\n```\\nFinally we increase by 1 all the values from 3 to 5 , so that we will have:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t1\\t2\\t0  -2  -1\\t // values after the fourth change; notice index 7 now with a value of -2 from the first and last operations\\n```\\nNow, going with a running sun as we parse our difference array, we will find that each character will have to do the following shifts:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1   0\\t1\\t3\\t0   1   0\\t // shifts for each character\\n```\\nThe remaining part of the problem is just how to handle when a character gets shifted past \\'a\\' or \\'z\\', but that is rather trivial compared to the rest.\\n\\nNow, to put our thoughts into code, we will start declaring a few support variables, as usual:\\n\\nlen will store the size of s;\\ndiffArray is where we will store our indexes, creating it with a length of len + 1 to avoid extra logic on the -x mark when applied to the last cell - saving us shifts.size() conditional statements for the cost of a couple of bytes;\\ndir will be a support variable for when we iterate shifts.\\nWe will then set all the cells of diffArray to 0, but for the last one (as we said, we do not really care and we will never really use it, just as a placeholder).\\n\\nLooping though each shift in shifts, we will:\\n\\nset dir to be 1 if shift[2] is also 1, -1 otherwise, as specified in the specs;\\nincrease our starting point diffArray[shift[0]] by dir;\\ndecrease our ending point diffArray[shift[1] + 1] by dir.\\nWith diffArray fully populated, we can now work on s and, with our ongoing sum c initialised to 0 and for each position i in it, we will:\\n\\nset c to increase by diffArray[i] (I saw some solutions doing this with a separate pass, but since we only need to do this once, no point in storing the values and writing them down updating diffArray in place);\\nset pos to the value in which we would pick a character in an ideal \"abcdefghijklmnopqrstuvwxyz\" string, with the value equal to the original (s[i]), minus \\'a\\' (to turn it into a value in the 0 - 25 range), plus c (so, the final shift for this specific cell);\\nwe will add 26 to pos as long as it is < 0 to make sure it is within range;\\nwe will subtract 26 to pos as long as it is > 25 to make sure it is within range - notice that this way our solution has only one expensive modulo operation per character \\uD83C\\uDFC6 ;\\nfinally, we will set back the value in s[i] to be equal to pos (our adjusted 0 - 25 final value), plus \\'a\\' (to make sure it is again a valid lowercase ASCII character).\\nOnce done, we can just return res :)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sh) {\\n        \\n        int n = s.size();\\n        int m = sh.size();\\n        vector<int> dup(n+1 , 0);\\n        for(auto &i : sh){\\n            if(i[2]==1){\\n                dup[i[0]]++;\\n                dup[i[1]+1]--;\\n            }\\n            else{\\n                dup[i[0]]--;\\n                dup[i[1]+1]++;\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            dup[i]+=dup[i-1];\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int inc = (s[i]-\\'a\\'+dup[i])%26;\\n            inc=(inc+26)%26;\\n            s[i]=\\'a\\'+inc;\\n        }\\n\\n        return s;\\n    }\\n};\\n```\\n\\n# **Please Upvote if you found this helpful **",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t0\\t0\\t0\\t0\\t0\\t0\\t0\\t // initial values in the difference array\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t0\\t0  -1\\t0\\t // values after the first change\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t1\\t0  -1  -1\\t // values after the second change\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t0\\t2\\t0  -1  -1\\t // values after the third change; notice index 4 now with a value of 2 from the previous two operations\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t1\\t2\\t0  -2  -1\\t // values after the fourth change; notice index 7 now with a value of -2 from the first and last operations\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1   0\\t1\\t3\\t0   1   0\\t // shifts for each character\\n```\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sh) {\\n        \\n        int n = s.size();\\n        int m = sh.size();\\n        vector<int> dup(n+1 , 0);\\n        for(auto &i : sh){\\n            if(i[2]==1){\\n                dup[i[0]]++;\\n                dup[i[1]+1]--;\\n            }\\n            else{\\n                dup[i[0]]--;\\n                dup[i[1]+1]++;\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            dup[i]+=dup[i-1];\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int inc = (s[i]-\\'a\\'+dup[i])%26;\\n            inc=(inc+26)%26;\\n            s[i]=\\'a\\'+inc;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459170,
                "title": "leetcode-the-hard-way-line-sweep",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> line(n + 1, 0);\\n        // standard line sweep\\n        for (auto& s : shifts) {\\n            int start = s[0],\\n                end   = s[1],\\n            direction = s[2];\\n            line[start] += direction ? 1 : -1;\\n            line[end + 1] += direction ? -1 : 1;\\n        }\\n        // calculate the prefix sum\\n        partial_sum(line.begin(), line.end(), line.begin());\\n        // for each character\\n        for (int i = 0; i < n; i++) {\\n            // we calculate the new index value\\n            int v = (s[i] - \\'a\\' + line[i]) % 26;\\n            // v can be negative if it is shifting backward\\n            // in this case, we need to turn it back to positive\\n            if (v < 0) v = (v % 26 + 26) % 26;\\n            // in place update character at position i \\n            s[i] = \\'a\\' + v;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> line(n + 1, 0);\\n        // standard line sweep\\n        for (auto& s : shifts) {\\n            int start = s[0],\\n                end   = s[1],\\n            direction = s[2];\\n            line[start] += direction ? 1 : -1;\\n            line[end + 1] += direction ? -1 : 1;\\n        }\\n        // calculate the prefix sum\\n        partial_sum(line.begin(), line.end(), line.begin());\\n        // for each character\\n        for (int i = 0; i < n; i++) {\\n            // we calculate the new index value\\n            int v = (s[i] - \\'a\\' + line[i]) % 26;\\n            // v can be negative if it is shifting backward\\n            // in this case, we need to turn it back to positive\\n            if (v < 0) v = (v % 26 + 26) % 26;\\n            // in place update character at position i \\n            s[i] = \\'a\\' + v;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459015,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Prefix Sum***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string str, vector<vector<int>>& shifts) {\\n        \\n        int n = str.size();\\n        \\n        // count[i] will store the no. of times of increment or decrement of for str[i]\\n        \\n        vector<int> count(n + 1, 0);\\n        \\n        for(int i = 0; i < shifts.size(); i++)\\n        {\\n            int left = shifts[i][0];\\n            \\n            int right = shifts[i][1];\\n            \\n            int sign = shifts[i][2];\\n            \\n            if(sign == 1)\\n            {\\n                count[left]++;\\n                \\n                count[right + 1]--;\\n            }\\n            else\\n            {\\n                count[left]--;\\n                \\n                count[right + 1]++;\\n            }\\n        }\\n        \\n        // find prefix sum\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            count[i] += count[i - 1];\\n        }\\n        \\n        // shift the characters of str\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int increment = (str[i] - \\'a\\' + count[i]) % 26;\\n            \\n            // if increment becomes negative, then make it positive\\n            \\n            if(increment < 0)\\n            {\\n                increment = (increment + 26) % 26;\\n            }\\n            \\n            // update str[i]\\n            \\n            str[i] = \\'a\\' + increment;\\n        }\\n        \\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string str, vector<vector<int>>& shifts) {\\n        \\n        int n = str.size();\\n        \\n        // count[i] will store the no. of times of increment or decrement of for str[i]\\n        \\n        vector<int> count(n + 1, 0);\\n        \\n        for(int i = 0; i < shifts.size(); i++)\\n        {\\n            int left = shifts[i][0];\\n            \\n            int right = shifts[i][1];\\n            \\n            int sign = shifts[i][2];\\n            \\n            if(sign == 1)\\n            {\\n                count[left]++;\\n                \\n                count[right + 1]--;\\n            }\\n            else\\n            {\\n                count[left]--;\\n                \\n                count[right + 1]++;\\n            }\\n        }\\n        \\n        // find prefix sum\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            count[i] += count[i - 1];\\n        }\\n        \\n        // shift the characters of str\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int increment = (str[i] - \\'a\\' + count[i]) % 26;\\n            \\n            // if increment becomes negative, then make it positive\\n            \\n            if(increment < 0)\\n            {\\n                increment = (increment + 26) % 26;\\n            }\\n            \\n            // update str[i]\\n            \\n            str[i] = \\'a\\' + increment;\\n        }\\n        \\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454934,
                "title": "simple-o-n-c-prefix-sum",
                "content": "```\\nclass Solution {\\n    char getRotateChar(int f, int b, char c) {\\n        if (f==b) return c;\\n        if (f<b) {\\n            b=b-f;\\n            b%=26;\\n            for(int i=0;i<b;i++) {\\n                c--;\\n                if (c==\\'a\\'-1) c=\\'z\\';\\n            }\\n            return c;\\n        }\\n        else {\\n            f=f-b;\\n            f%=26;\\n            for(int i=0;i<f;i++) {\\n                c++;\\n                if (c==\\'z\\'+1) c=\\'a\\';\\n            }\\n            return c;\\n        }\\n    }\\n    \\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> F(n+1, 0);\\n        vector<int> B(n+1, 0);\\n        for(int i=0;i<shifts.size();i++) {\\n            if (shifts[i][2]==1) {\\n                F[shifts[i][0]]++;\\n                F[shifts[i][1]+1]--;\\n            }\\n            else {\\n                B[shifts[i][0]]++;\\n                B[shifts[i][1]+1]--;\\n            }\\n        }\\n        int f=0,b=0;\\n        for(int i=0;i<n;i++) {\\n            f+=F[i];\\n            b+=B[i];\\n            s[i]=getRotateChar(f,b,s[i]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    char getRotateChar(int f, int b, char c) {\\n        if (f==b) return c;\\n        if (f<b) {\\n            b=b-f;\\n            b%=26;\\n            for(int i=0;i<b;i++) {\\n                c--;\\n                if (c==\\'a\\'-1) c=\\'z\\';\\n            }\\n            return c;\\n        }\\n        else {\\n            f=f-b;\\n            f%=26;\\n            for(int i=0;i<f;i++) {\\n                c++;\\n                if (c==\\'z\\'+1) c=\\'a\\';\\n            }\\n            return c;\\n        }\\n    }\\n    \\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> F(n+1, 0);\\n        vector<int> B(n+1, 0);\\n        for(int i=0;i<shifts.size();i++) {\\n            if (shifts[i][2]==1) {\\n                F[shifts[i][0]]++;\\n                F[shifts[i][1]+1]--;\\n            }\\n            else {\\n                B[shifts[i][0]]++;\\n                B[shifts[i][1]+1]--;\\n            }\\n        }\\n        int f=0,b=0;\\n        for(int i=0;i<n;i++) {\\n            f+=F[i];\\n            b+=B[i];\\n            s[i]=getRotateChar(f,b,s[i]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454901,
                "title": "c-o-n-time-using-prefixsum",
                "content": "**C++ Code:**\\n\\n```\\n string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = shifts.size();\\n        int len = s.length();\\n        vector<int>arr(len,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                arr[shifts[i][1]]++;\\n                if(shifts[i][0]>0)\\n                arr[shifts[i][0]-1]--;\\n            }\\n            else{\\n                arr[shifts[i][1]]--; \\n                if(shifts[i][0]>0)\\n                arr[shifts[i][0]-1]++;\\n            }\\n        }\\n        for(int i=len-2;i>=0;i--)\\n            arr[i] += arr[i+1];\\n      for(int i=0;i<len;i++)\\n      {\\n          int temp = s[i]-\\'a\\'+arr[i];\\n          while(temp<0) temp += 26;\\n          s[i] = \\'a\\'+(temp)%26;\\n      }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\n string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = shifts.size();\\n        int len = s.length();\\n        vector<int>arr(len,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                arr[shifts[i][1]]++;\\n                if(shifts[i][0]>0)\\n                arr[shifts[i][0]-1]--;\\n            }\\n            else{\\n                arr[shifts[i][1]]--; \\n                if(shifts[i][0]>0)\\n                arr[shifts[i][0]-1]++;\\n            }\\n        }\\n        for(int i=len-2;i>=0;i--)\\n            arr[i] += arr[i+1];\\n      for(int i=0;i<len;i++)\\n      {\\n          int temp = s[i]-\\'a\\'+arr[i];\\n          while(temp<0) temp += 26;\\n          s[i] = \\'a\\'+(temp)%26;\\n      }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454536,
                "title": "doubt-why-to-use-after-v",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a) {\\n        int n=s.size(),m=a.size();\\n        vector<int> v(n);\\n        for(int i=0;i<m;i++)\\n        {\\n            if(a[i][2]==0)  //backwrd\\n            {\\n                    v[a[i][0]]--;\\n                if(a[i][1]<n-1)\\n                    v[a[i][1]+1]++;\\n            }\\n            else\\n            {\\n                v[a[i][0]]++;\\n                if(a[i][1]<n-1)\\n                    v[a[i][1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++)\\n            v[i]+=v[i-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i]=( (s[i]-\\'a\\')+26+v[i]%26)%26+\\'a\\'; \\n        }\\n        return s;\\n    }\\n};\\n```\\n why is it giving WRONG ANSWER when i am not writing %26 in  s[i]=( (s[i]-\\'a\\')+26+v[i]%26)%26+\\'a\\';\\n \\n i.e why s[i]=( (s[i]-\\'a\\')+26+v[i])%26+\\'a\\'; is giving WRONG ANSWER?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a) {\\n        int n=s.size(),m=a.size();\\n        vector<int> v(n);\\n        for(int i=0;i<m;i++)\\n        {\\n            if(a[i][2]==0)  //backwrd\\n            {\\n                    v[a[i][0]]--;\\n                if(a[i][1]<n-1)\\n                    v[a[i][1]+1]++;\\n            }\\n            else\\n            {\\n                v[a[i][0]]++;\\n                if(a[i][1]<n-1)\\n                    v[a[i][1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++)\\n            v[i]+=v[i-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i]=( (s[i]-\\'a\\')+26+v[i]%26)%26+\\'a\\'; \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454326,
                "title": "javascript-generate-a-operation-map-to-reduce-running-time",
                "content": "> Runtime: 9369 ms, faster than 100.00% of JavaScript online submissions for Shifting Letters II.\\nMemory Usage: 70.4 MB, less than 100.00% of JavaScript online submissions for Shifting Letters II.\\n\\n```js\\n/**\\n * @param {string} s\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function(s, shifts) {\\n    const cb = Array(s.length).fill(0);\\n    shifts.forEach(([s,e,d]) => {\\n        for(let i=s;i<=e;i++) {\\n            cb[i] += (d===0 ? -1 : 1)\\n        }\\n    })\\n    const arr = s.split(\\'\\');\\n    cb.forEach((e,i) => {\\n        let newCharCode = arr[i].charCodeAt() + e;\\n        while (newCharCode < 97) {\\n            newCharCode+=26\\n        }\\n        while (newCharCode > 122) {\\n            newCharCode-=26\\n        }\\n        arr[i] = String.fromCharCode(newCharCode)\\n    })\\n    return arr.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {string} s\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function(s, shifts) {\\n    const cb = Array(s.length).fill(0);\\n    shifts.forEach(([s,e,d]) => {\\n        for(let i=s;i<=e;i++) {\\n            cb[i] += (d===0 ? -1 : 1)\\n        }\\n    })\\n    const arr = s.split(\\'\\');\\n    cb.forEach((e,i) => {\\n        let newCharCode = arr[i].charCodeAt() + e;\\n        while (newCharCode < 97) {\\n            newCharCode+=26\\n        }\\n        while (newCharCode > 122) {\\n            newCharCode-=26\\n        }\\n        arr[i] = String.fromCharCode(newCharCode)\\n    })\\n    return arr.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454274,
                "title": "very-stupid-segment-tree-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>seg;\\n    vector<int>lz;\\n    void build(vector<int>&v,int l,int r,int idx){\\n        if(l==r){\\n            seg[idx]=v[l];\\n            return;\\n        }\\n        int m=l+(r-l)/2;\\n        build(v,l,m,2*idx+1);\\n        build(v,m+1,r,2*idx+2);\\n        seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\\n        seg[idx]=(26+seg[idx])%26;\\n    }\\n    void update(int l,int r,int idx,int ql,int qr,int v){\\n        if(lz[idx]!=0){\\n            seg[idx]+=lz[idx];\\n            seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                lz[2*idx+1]+=lz[idx];\\n                lz[2*idx+2]+=lz[idx];\\n            }\\n            lz[idx]=0;\\n        }\\n        if(r<ql||l>qr)return;\\n        if(l>=ql&&r<=qr){\\n            seg[idx]+=v;\\n            seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                 lz[2*idx+1]+=v;\\n                lz[2*idx+2]+=v;\\n            }\\n            return;\\n        }\\n        int m=l+(r-l)/2;\\n        update(l,m,2*idx+1,ql,qr,v);\\n        update(m+1,r,2*idx+2,ql,qr,v);\\n        seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\\n        seg[idx]=(26+seg[idx])%26;\\n        \\n    }\\n    int query(int l,int r,int idx,int k){\\n         if(lz[idx]!=0){\\n            seg[idx]+=lz[idx];\\n             seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                lz[2*idx+1]+=lz[idx];\\n                lz[2*idx+2]+=lz[idx];\\n            }\\n            lz[idx]=0;\\n        }\\n        if(l==r){\\n            if(l==k)return seg[idx];\\n        }\\n        if(r<k||l>k)return 0;\\n        int m=l+(r-l)/2;\\n       return query(l,m,2*idx+1,k)+ query(m+1,r,2*idx+2,k);\\n    }\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int>v(s.size());\\n        seg=vector<int>(4*s.size()+1,-1e9);\\n        lz=vector<int>(4*s.size()+1,0);\\n        \\n        for(int i=0;i<s.size();i++) v[i]=s[i]-\\'a\\';\\n           \\n        build(v,0,v.size()-1,0);\\n        for(auto t:shifts){\\n            int k=1;\\n            if(t[2]==0)k=-1;\\n            update(0,v.size()-1,0,t[0],t[1],k);\\n            //cout<<query(0,v.size()-1,0,t[0])<<\" \";\\n        }\\n        string a=\"\";\\n        for(int i=0;i<v.size();i++){\\n            int k=query(0,v.size()-1,0,i);\\n            k=(26+k)%26;\\n            a+=(\\'a\\'+k);\\n        }\\n        //cout<<\"\\\\n\";\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>seg;\\n    vector<int>lz;\\n    void build(vector<int>&v,int l,int r,int idx){\\n        if(l==r){\\n            seg[idx]=v[l];\\n            return;\\n        }\\n        int m=l+(r-l)/2;\\n        build(v,l,m,2*idx+1);\\n        build(v,m+1,r,2*idx+2);\\n        seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\\n        seg[idx]=(26+seg[idx])%26;\\n    }\\n    void update(int l,int r,int idx,int ql,int qr,int v){\\n        if(lz[idx]!=0){\\n            seg[idx]+=lz[idx];\\n            seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                lz[2*idx+1]+=lz[idx];\\n                lz[2*idx+2]+=lz[idx];\\n            }\\n            lz[idx]=0;\\n        }\\n        if(r<ql||l>qr)return;\\n        if(l>=ql&&r<=qr){\\n            seg[idx]+=v;\\n            seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                 lz[2*idx+1]+=v;\\n                lz[2*idx+2]+=v;\\n            }\\n            return;\\n        }\\n        int m=l+(r-l)/2;\\n        update(l,m,2*idx+1,ql,qr,v);\\n        update(m+1,r,2*idx+2,ql,qr,v);\\n        seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\\n        seg[idx]=(26+seg[idx])%26;\\n        \\n    }\\n    int query(int l,int r,int idx,int k){\\n         if(lz[idx]!=0){\\n            seg[idx]+=lz[idx];\\n             seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                lz[2*idx+1]+=lz[idx];\\n                lz[2*idx+2]+=lz[idx];\\n            }\\n            lz[idx]=0;\\n        }\\n        if(l==r){\\n            if(l==k)return seg[idx];\\n        }\\n        if(r<k||l>k)return 0;\\n        int m=l+(r-l)/2;\\n       return query(l,m,2*idx+1,k)+ query(m+1,r,2*idx+2,k);\\n    }\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int>v(s.size());\\n        seg=vector<int>(4*s.size()+1,-1e9);\\n        lz=vector<int>(4*s.size()+1,0);\\n        \\n        for(int i=0;i<s.size();i++) v[i]=s[i]-\\'a\\';\\n           \\n        build(v,0,v.size()-1,0);\\n        for(auto t:shifts){\\n            int k=1;\\n            if(t[2]==0)k=-1;\\n            update(0,v.size()-1,0,t[0],t[1],k);\\n            //cout<<query(0,v.size()-1,0,t[0])<<\" \";\\n        }\\n        string a=\"\";\\n        for(int i=0;i<v.size();i++){\\n            int k=query(0,v.size()-1,0,i);\\n            k=(26+k)%26;\\n            a+=(\\'a\\'+k);\\n        }\\n        //cout<<\"\\\\n\";\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2454215,
                "title": "python3-line-sweep",
                "content": "Please pull this git [commit](https://github.com/gaosanyong/leetcode/commit/e999ea07dc2ea2e8b7aad97696f67a3b965e496d) for solutions of biweekly 85. \\n\\n**Intuition**\\nThis is a typical line sweeping problem. While looping through `shifts`, we break [start, end, direction] into two paris and put them on a line of ops \\n\\n```\\n[start, 2direction-1]\\n[end+1, -2direction+1]\\n```\\nIn addition, I use a linear transformation to scale {0, 1} direction to {1, -1} for later calculations. I sort the ops and process the amount of shift via a prefix sum. At index i, I\\'d sum all shifts up to this point and apply the shift to the character. \\n**Caveat** Python modulo automatically gives positive value which nicely suits the requirement of this problem. For other languages (e.g. C++), you might need to manually offset it by another 26 to avoid negative values. \\n\\n**Analysis**\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`\\n\\n```\\nclass Solution: \\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        ops = []\\n        for start, end, direction in shifts: \\n            direction = 2*direction-1\\n            ops.append((start, direction))\\n            ops.append((end+1, -direction))\\n        ops.sort()\\n        ans = []\\n        prefix = ii = 0 \\n        for i, ch in enumerate(s): \\n            while ii < len(ops) and ops[ii][0] == i: \\n                prefix += ops[ii][1]\\n                ii += 1\\n            ans.append(chr((ord(ch)-97+prefix)%26+97))\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n[start, 2direction-1]\\n[end+1, -2direction+1]\\n```\n```\\nclass Solution: \\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        ops = []\\n        for start, end, direction in shifts: \\n            direction = 2*direction-1\\n            ops.append((start, direction))\\n            ops.append((end+1, -direction))\\n        ops.sort()\\n        ans = []\\n        prefix = ii = 0 \\n        for i, ch in enumerate(s): \\n            while ii < len(ops) and ops[ii][0] == i: \\n                prefix += ops[ii][1]\\n                ii += 1\\n            ans.append(chr((ord(ch)-97+prefix)%26+97))\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390639,
                "title": "java-100-faster-100-beats",
                "content": "# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] ch = s.toCharArray();\\n        int[] count = new int[s.length()+1];\\n\\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            count[shift[0]] += value;\\n            count[shift[1] + 1] -= value;\\n        }\\n\\n        int sum = 0;\\n        for(int i = 0; i < count.length - 1; i++){\\n            sum += count[i];\\n            int newChar = ((ch[i] - \\'a\\') + sum) % 26;\\n            if(newChar < 0) newChar+= 26;\\n            ch[i] =  (char)(\\'a\\' + newChar);\\n        }\\n\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] ch = s.toCharArray();\\n        int[] count = new int[s.length()+1];\\n\\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            count[shift[0]] += value;\\n            count[shift[1] + 1] -= value;\\n        }\\n\\n        int sum = 0;\\n        for(int i = 0; i < count.length - 1; i++){\\n            sum += count[i];\\n            int newChar = ((ch[i] - \\'a\\') + sum) % 26;\\n            if(newChar < 0) newChar+= 26;\\n            ch[i] =  (char)(\\'a\\' + newChar);\\n        }\\n\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263580,
                "title": "prefix-sum-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 26;\\n    string shiftingLetters(string s, vector<vector<int>>& arr) \\n    {\\n         //getting the max end value from the arr \\n         int maxval = INT_MIN;\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             maxval = max(maxval,arr[i][1]);\\n         }\\n\\n         //making the prefix array \\n         vector<long long int>prefix(maxval+7,0);\\n\\n         //processing the queries\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             int start = arr[i][0];\\n             int end = arr[i][1];\\n             int val = arr[i][2];\\n             bool flag = false;\\n\\n             if(val == 1) flag = true;  //true means forward shifting\\n             else if(val == 0) flag = false;  //false means backward shifting\\n\\n             if(flag == true)    //this means for this query we need forward shifting\\n             {\\n                 prefix[start]   += 1;\\n                 prefix[end+1]   -= 1;\\n             } \\n             else if(flag == false)\\n             {\\n                 prefix[start]   -= 1;\\n                 prefix[end+1]   +=1;\\n             }\\n         }\\n         for(int i=0;i<prefix.size();i++)\\n         {\\n             if(i == 0) continue;\\n           \\n             prefix[i] = prefix[i] + prefix[i-1];\\n         }\\n        //  for(int i=0;i<prefix.size();i++)\\n        //  {\\n        //      cout<<prefix[i]<<\" \";\\n        //  }\\n         for(int i=0;i<s.length();i++)\\n         {\\n             // cout<<\"i = \"<<i<<endl;\\n              char prv_ch = s[i];\\n\\n              if(prefix[i] >= 0)\\n              {\\n                   long long int val = (prv_ch - \\'a\\');\\n                   \\n                   //forward shifting\\n                   val = ((val%mod) + (prefix[i]%mod))%mod;\\n\\n                   char new_ch = \\'a\\' + val;\\n\\n                   s[i] = new_ch;\\n\\n              }\\n              else if(prefix[i] < 0)\\n              {\\n                   long long int val = (prv_ch - \\'a\\');\\n\\n                   //backward shifting\\n                   val = ((val%mod) - (abs(prefix[i])%mod) + mod)%mod;\\n\\n                   char new_ch = \\'a\\' + val;\\n\\n                   s[i] = new_ch;\\n              }\\n         }\\n         return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 26;\\n    string shiftingLetters(string s, vector<vector<int>>& arr) \\n    {\\n         //getting the max end value from the arr \\n         int maxval = INT_MIN;\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             maxval = max(maxval,arr[i][1]);\\n         }\\n\\n         //making the prefix array \\n         vector<long long int>prefix(maxval+7,0);\\n\\n         //processing the queries\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             int start = arr[i][0];\\n             int end = arr[i][1];\\n             int val = arr[i][2];\\n             bool flag = false;\\n\\n             if(val == 1) flag = true;  //true means forward shifting\\n             else if(val == 0) flag = false;  //false means backward shifting\\n\\n             if(flag == true)    //this means for this query we need forward shifting\\n             {\\n                 prefix[start]   += 1;\\n                 prefix[end+1]   -= 1;\\n             } \\n             else if(flag == false)\\n             {\\n                 prefix[start]   -= 1;\\n                 prefix[end+1]   +=1;\\n             }\\n         }\\n         for(int i=0;i<prefix.size();i++)\\n         {\\n             if(i == 0) continue;\\n           \\n             prefix[i] = prefix[i] + prefix[i-1];\\n         }\\n        //  for(int i=0;i<prefix.size();i++)\\n        //  {\\n        //      cout<<prefix[i]<<\" \";\\n        //  }\\n         for(int i=0;i<s.length();i++)\\n         {\\n             // cout<<\"i = \"<<i<<endl;\\n              char prv_ch = s[i];\\n\\n              if(prefix[i] >= 0)\\n              {\\n                   long long int val = (prv_ch - \\'a\\');\\n                   \\n                   //forward shifting\\n                   val = ((val%mod) + (prefix[i]%mod))%mod;\\n\\n                   char new_ch = \\'a\\' + val;\\n\\n                   s[i] = new_ch;\\n\\n              }\\n              else if(prefix[i] < 0)\\n              {\\n                   long long int val = (prv_ch - \\'a\\');\\n\\n                   //backward shifting\\n                   val = ((val%mod) - (abs(prefix[i])%mod) + mod)%mod;\\n\\n                   char new_ch = \\'a\\' + val;\\n\\n                   s[i] = new_ch;\\n              }\\n         }\\n         return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3160790,
                "title": "beats-91-prefix-sum-similar-to-range-addition",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\"\\n        we can apply similar concept of range addition problem to solve this\\n        problem as well\\n        \"\"\"\\n        prefix_array = [0] * (len(s)+1)\\n        for start, end, direction in shifts:\\n            counter = 1 if direction == 1 else -1\\n            prefix_array[start]+=counter\\n            prefix_array[end+1]-=counter\\n\\n        for i in range(1, len(prefix_array)):\\n            prefix_array[i]+=prefix_array[i-1]\\n\\n        result = \"\"\\n        for i in range(len(s)):\\n            new_val = (ord(s[i]) + prefix_array[i]%26)\\n            if 97 <= new_val <= 122:\\n                result+=chr(new_val)\\n            elif new_val > 122:\\n                result+=chr(new_val%123 + 97)\\n            else:\\n                result+=chr(new_val+26)\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\"\\n        we can apply similar concept of range addition problem to solve this\\n        problem as well\\n        \"\"\"\\n        prefix_array = [0] * (len(s)+1)\\n        for start, end, direction in shifts:\\n            counter = 1 if direction == 1 else -1\\n            prefix_array[start]+=counter\\n            prefix_array[end+1]-=counter\\n\\n        for i in range(1, len(prefix_array)):\\n            prefix_array[i]+=prefix_array[i-1]\\n\\n        result = \"\"\\n        for i in range(len(s)):\\n            new_val = (ord(s[i]) + prefix_array[i]%26)\\n            if 97 <= new_val <= 122:\\n                result+=chr(new_val)\\n            elif new_val > 122:\\n                result+=chr(new_val%123 + 97)\\n            else:\\n                result+=chr(new_val+26)\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046286,
                "title": "c-o-n-solution",
                "content": "# Approach\\n-Prefix Sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int sh=shifts.size(),l=s.size();\\n\\n        vector<int> tshift(l+1,0);\\n        for(int i=0;i<sh;i++){\\n            tshift[shifts[i][0]]+=shifts[i][2]?1:-1;\\n            tshift[shifts[i][1]+1]-=shifts[i][2]?1:-1;\\n        }\\n        string ans;\\n        for(int i=0;i<l;i++){\\n            tshift[i]%=26;\\n            int st=(int(s[i])-97)+(tshift[i]);\\n            ans+=((26+st)%26)+97;\\n            tshift[i+1]+=tshift[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int sh=shifts.size(),l=s.size();\\n\\n        vector<int> tshift(l+1,0);\\n        for(int i=0;i<sh;i++){\\n            tshift[shifts[i][0]]+=shifts[i][2]?1:-1;\\n            tshift[shifts[i][1]+1]-=shifts[i][2]?1:-1;\\n        }\\n        string ans;\\n        for(int i=0;i<l;i++){\\n            tshift[i]%=26;\\n            int st=(int(s[i])-97)+(tshift[i]);\\n            ans+=((26+st)%26)+97;\\n            tshift[i+1]+=tshift[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718990,
                "title": "c-o-n-time-complexity",
                "content": "# Intuition\\nAs problem is related to segments, first thought was to use segment tree. But we have to increment each character, complexity will be n^2 to update segment tree. Then prefix sum will work as shown in approach below.\\n\\n# Approach \\nFor example consider string of length 10.\\nIf we have to update string as [2,5,1].\\nWhat we can do here is, we can increment each character from 2nd position till last. But to reduce updation after 5 at position we will derement it by 1;\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sf) {\\n        int n = s.size();\\n        vector<int>pf(n+1,0);\\n        for(int i=0;i<sf.size();i++){\\n            if(sf[i][2]==0){\\n                pf[sf[i][0]] -= 1;\\n                pf[sf[i][1]+1] += 1;\\n            }else{\\n                pf[sf[i][0]] += 1;\\n                pf[sf[i][1]+1] -= 1;\\n            }\\n        }\\n\\n        int cur = 0;\\n        for(int i=0;i<n;i++){\\n            \\n            cur += pf[i];\\n\\n            cur %= 26;\\n\\n            if(cur<0)\\n                cur += 26;\\n\\n            int b =  s[i]+cur;\\n\\n            if(b>122)\\n                b = b-26;\\n\\n            s[i] = b;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sf) {\\n        int n = s.size();\\n        vector<int>pf(n+1,0);\\n        for(int i=0;i<sf.size();i++){\\n            if(sf[i][2]==0){\\n                pf[sf[i][0]] -= 1;\\n                pf[sf[i][1]+1] += 1;\\n            }else{\\n                pf[sf[i][0]] += 1;\\n                pf[sf[i][1]+1] -= 1;\\n            }\\n        }\\n\\n        int cur = 0;\\n        for(int i=0;i<n;i++){\\n            \\n            cur += pf[i];\\n\\n            cur %= 26;\\n\\n            if(cur<0)\\n                cur += 26;\\n\\n            int b =  s[i]+cur;\\n\\n            if(b>122)\\n                b = b-26;\\n\\n            s[i] = b;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597481,
                "title": "segment-tree-template-including-lazy-coolest-segment-tree-problem",
                "content": "**Segment Tree : Sum Template**\\n`Applications:`\\n1. Find sum in particular range.\\n2. Point Update.\\n3. Range Update\\n\\n```\\n// TC: O(NlogN);\\n// SC: (4*N) ~ O(N);\\n// Segement Trees : Implementation : Find the sum in particular range.\\n\\n// Query : TC: O(logN) for single query & O(NlogN) for n Queries\\n// Working fine : )\\nclass Segment\\n{\\n    vector<int> segmentTree, lazy;\\n    int n;\\npublic:\\n    Segment(vector<int> &arr){\\n        this->n = arr.size();\\n\\n        segmentTree.resize(4 * n + 1);\\n        lazy.resize(4 * n + 1, 0);\\n        buildSegmentTree(arr, 0, 0, n - 1);\\n    }\\n\\n    void buildSegmentTree(vector<int> &arr, int ind, int left, int right){\\n        if(left == right){\\n            segmentTree[ind] = arr[left];\\n            return;\\n        }\\n\\n        int mid = left + (right - left) / 2;\\n\\n        buildSegmentTree(arr, 2 * ind + 1, left, mid);\\n        buildSegmentTree(arr, 2 * ind + 2, mid + 1, right);\\n\\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    \\n    int sumBro(int ind, int left, int right, int l, int r){\\n        // Case 1 : IF current_segment comes under range...\\n        if (left >= l && right <= r){\\n            return segmentTree[ind];\\n        }\\n\\n        // Case 2 : If current_segement doesn\\'t comes in range.... :then we return 0 as answer to not pick current segment\\n        if (r < left || right < l)\\n            return 0;\\n\\n        // Case 3 : If current_segement comes partitally...\\n        int mid = left + (right - left) / 2;\\n        \\n        int leftSum = sumBro(2 * ind + 1, left, mid, l, r);\\n        int rightSum = sumBro(2 * ind + 2, mid + 1, right, l, r);\\n\\n        return leftSum + rightSum;\\n    }\\n    int getSum(int l, int r){ return sumBro(0, 0, n-1, l, r); }\\n\\n    \\n    void pointUpdate(int ind, int left, int right, int index, int value){\\n        // Doing Actual update at leaf node.\\n        if(left == right){\\n            segmentTree[ind] += value;\\n            return ;\\n        }\\n\\n        int mid = (left + right)/2;\\n\\n        // If index comes into left part, then we will update only left part and update complete component after if-else & vice versa\\n        if(index <= mid) pointUpdate(2*ind+1, left, mid, index, value);\\n        else pointUpdate(2*ind+2, mid+1, right, index, value);\\n\\n        segmentTree[ind] = segmentTree[2*ind+1] + segmentTree[2*ind+2];\\n    }\\n    void pointUpdateBro(int index, int value){ pointUpdate(0, 0, n-1, index, value); }\\n\\n    void lazyUpdate(int ind, int left, int right, int l, int r, int value){\\n        // We always do : pending updates first, then actual update.\\n        if(lazy[ind] != 0){\\n            segmentTree[ind] += (right-left+1) * lazy[ind];\\n\\n            // Propagating lazy updates if current node is having childrens...\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            } \\n\\n            // we done updating, so make current lazy_updates = 0\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1 : If current range comes outside...\\n        if(right < l || r < left) return ;\\n\\n        // Case 2 : If current range comes inside... \\n        if(left >= l && right <= r){\\n            segmentTree[ind] += (right-left+1) * value;\\n\\n            if(left != right){\\n                lazy[2*ind+1] += value;\\n                lazy[2*ind+2] += value;\\n            }\\n            return ;\\n        }\\n\\n        // Case 3: Partial Overlap\\n        int mid = left + (right-left)/2;\\n\\n        lazyUpdate(2 * ind + 1, left, mid, l, r, value);\\n        lazyUpdate(2 * ind + 2, mid+1, right, l, r, value);\\n\\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    void lazyUpdateBro(int l, int r, int value){ lazyUpdate(0, 0, n-1, l, r, value); }\\n\\n    int querySumLazy(int ind, int left, int right, int l, int r){\\n        // Executing pending updates at first.\\n        if(lazy[ind]){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind];\\n            \\n            // If current node is not leaf node, then we have to propagate updates to childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We, are done updating : )\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1: If range is completely outside...\\n        if(r < left || right < l || left > right) return 0;\\n\\n        // Case 2: If range is completely inside...\\n        if(left >= l && right <= r) return segmentTree[ind];\\n\\n        // Case 3: If range is partially inside or partially outside...\\n        int mid = (right + left)/2;\\n        \\n        int leftSide = querySumLazy(2*ind+1, left, mid, l, r);\\n        int rightSide = querySumLazy(2*ind+2, mid+1, right, l, r);\\n        \\n        return leftSide + rightSide;\\n    }\\n    int getSumLazy(int l, int r) { return querySumLazy(0, 0, n- 1, l, r); }\\n\\n    void printSegmentTree(){\\n        for(int i : segmentTree) cout<<i<<\" \"; \\n        cout<<endl;\\n    }\\n\\n    int printSegmentTreeSum(){\\n        return segmentTree[0];\\n    }\\n};\\n```\\n\\n**Approach : Straighforward Range update in Segment Tree**\\n\\n```\\n#define ll long long\\nclass Segment{\\n    int n;\\n    vector<ll> segmentTree, lazy;\\npublic:\\n    Segment(int n){\\n        this->n = n;\\n        \\n        segmentTree.resize(4 * n, 0);\\n        lazy.resize(4 * n, 0);\\n    }\\n    \\n    void rangeUpdate(int ind, int left, int right, int l, int r, int value){\\n        // Executing pending updates at first.\\n        if(lazy[ind] != 0){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind]; \\n            \\n            // If current node is not leaf, node means we have to propagate lazy updates to its childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We have done all pending updates.\\n            lazy[ind] = 0;\\n        }\\n        \\n        // Case 1 : If current segment is out of range.\\n        if(right < l || r < left) return ;\\n        \\n        // Case 2 : If current segment completely lies in range.\\n        if(l <= left && right <= r){\\n            segmentTree[ind] += (right - left + 1) * (value);\\n            \\n            if(left != right){\\n                lazy[2*ind+1] += value;\\n                lazy[2*ind+2] += value;\\n            }\\n            return ;\\n        }\\n        \\n        // Case 3 : If current segment lies partially.\\n        int mid = left + (right-left)/2;\\n        \\n        rangeUpdate(2 * ind + 1, left, mid, l, r, value);\\n        rangeUpdate(2 * ind + 2, mid + 1, right, l, r, value);\\n        \\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    \\n    void rangeUpdateQuery(int l, int r, int value){\\n        rangeUpdate(0, 0, n-1, l, r, value);\\n    }\\n    \\n    int querySumLazy(int ind, int left, int right, int l, int r){\\n        // Executing pending updates at first.\\n        if(lazy[ind]){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind];\\n            \\n            // If current node is not leaf node, then we have to propagate updates to childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We, are done updating : )\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1 : If range is completely outside...\\n        if(r < left || right < l) return 0;\\n\\n        // Case 2 : If range is completely inside...\\n        if(left >= l && right <= r) return segmentTree[ind];\\n\\n        // Case 3 : If range is partially inside or partially outside...\\n        int mid = (right + left)/2;\\n        \\n        int leftSide = querySumLazy(2*ind+1, left, mid, l, r);\\n        int rightSide = querySumLazy(2*ind+2, mid+1, right, l, r);\\n        \\n        return leftSide + rightSide;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {        \\n        Segment sT(s.size());\\n\\n        // Doing Range Update in Segement trees \\n        for(auto &shift : shifts){\\n            sT.rangeUpdateQuery(shift[0], shift[1], shift[2] ? 1 : -1);\\n        }\\n        \\n        \\n        for(int i = 0; i < s.size(); i++){\\n            // Fetching element updates which need to be done on current character...\\n            int element = (sT.querySumLazy(0, 0, s.size()-1, i,i) + s[i] - \\'a\\');    \\n            \\n            // If after adding update, if our character goes negative-outside-region of our lowercase range [a....z]\\n            // Then we need to subtract the nodes difference from the end...\\n            if(((element%26) + \\'a\\') < 97) s[i] = (char)(123 + (element%26));\\n            \\n            // Otherwise, if current element is in lowercase range, we will add it into answer...\\n            else s[i] = (char)((element%26) + \\'a\\');\\n        }\\n\\n        return s;\\n    }\\n};\\n```\\n\\n**Doubts, Queries & Better Approaches are most welcome\\uD83C\\uDF3B**",
                "solutionTags": [],
                "code": "```\\n// TC: O(NlogN);\\n// SC: (4*N) ~ O(N);\\n// Segement Trees : Implementation : Find the sum in particular range.\\n\\n// Query : TC: O(logN) for single query & O(NlogN) for n Queries\\n// Working fine : )\\nclass Segment\\n{\\n    vector<int> segmentTree, lazy;\\n    int n;\\npublic:\\n    Segment(vector<int> &arr){\\n        this->n = arr.size();\\n\\n        segmentTree.resize(4 * n + 1);\\n        lazy.resize(4 * n + 1, 0);\\n        buildSegmentTree(arr, 0, 0, n - 1);\\n    }\\n\\n    void buildSegmentTree(vector<int> &arr, int ind, int left, int right){\\n        if(left == right){\\n            segmentTree[ind] = arr[left];\\n            return;\\n        }\\n\\n        int mid = left + (right - left) / 2;\\n\\n        buildSegmentTree(arr, 2 * ind + 1, left, mid);\\n        buildSegmentTree(arr, 2 * ind + 2, mid + 1, right);\\n\\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    \\n    int sumBro(int ind, int left, int right, int l, int r){\\n        // Case 1 : IF current_segment comes under range...\\n        if (left >= l && right <= r){\\n            return segmentTree[ind];\\n        }\\n\\n        // Case 2 : If current_segement doesn\\'t comes in range.... :then we return 0 as answer to not pick current segment\\n        if (r < left || right < l)\\n            return 0;\\n\\n        // Case 3 : If current_segement comes partitally...\\n        int mid = left + (right - left) / 2;\\n        \\n        int leftSum = sumBro(2 * ind + 1, left, mid, l, r);\\n        int rightSum = sumBro(2 * ind + 2, mid + 1, right, l, r);\\n\\n        return leftSum + rightSum;\\n    }\\n    int getSum(int l, int r){ return sumBro(0, 0, n-1, l, r); }\\n\\n    \\n    void pointUpdate(int ind, int left, int right, int index, int value){\\n        // Doing Actual update at leaf node.\\n        if(left == right){\\n            segmentTree[ind] += value;\\n            return ;\\n        }\\n\\n        int mid = (left + right)/2;\\n\\n        // If index comes into left part, then we will update only left part and update complete component after if-else & vice versa\\n        if(index <= mid) pointUpdate(2*ind+1, left, mid, index, value);\\n        else pointUpdate(2*ind+2, mid+1, right, index, value);\\n\\n        segmentTree[ind] = segmentTree[2*ind+1] + segmentTree[2*ind+2];\\n    }\\n    void pointUpdateBro(int index, int value){ pointUpdate(0, 0, n-1, index, value); }\\n\\n    void lazyUpdate(int ind, int left, int right, int l, int r, int value){\\n        // We always do : pending updates first, then actual update.\\n        if(lazy[ind] != 0){\\n            segmentTree[ind] += (right-left+1) * lazy[ind];\\n\\n            // Propagating lazy updates if current node is having childrens...\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            } \\n\\n            // we done updating, so make current lazy_updates = 0\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1 : If current range comes outside...\\n        if(right < l || r < left) return ;\\n\\n        // Case 2 : If current range comes inside... \\n        if(left >= l && right <= r){\\n            segmentTree[ind] += (right-left+1) * value;\\n\\n            if(left != right){\\n                lazy[2*ind+1] += value;\\n                lazy[2*ind+2] += value;\\n            }\\n            return ;\\n        }\\n\\n        // Case 3: Partial Overlap\\n        int mid = left + (right-left)/2;\\n\\n        lazyUpdate(2 * ind + 1, left, mid, l, r, value);\\n        lazyUpdate(2 * ind + 2, mid+1, right, l, r, value);\\n\\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    void lazyUpdateBro(int l, int r, int value){ lazyUpdate(0, 0, n-1, l, r, value); }\\n\\n    int querySumLazy(int ind, int left, int right, int l, int r){\\n        // Executing pending updates at first.\\n        if(lazy[ind]){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind];\\n            \\n            // If current node is not leaf node, then we have to propagate updates to childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We, are done updating : )\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1: If range is completely outside...\\n        if(r < left || right < l || left > right) return 0;\\n\\n        // Case 2: If range is completely inside...\\n        if(left >= l && right <= r) return segmentTree[ind];\\n\\n        // Case 3: If range is partially inside or partially outside...\\n        int mid = (right + left)/2;\\n        \\n        int leftSide = querySumLazy(2*ind+1, left, mid, l, r);\\n        int rightSide = querySumLazy(2*ind+2, mid+1, right, l, r);\\n        \\n        return leftSide + rightSide;\\n    }\\n    int getSumLazy(int l, int r) { return querySumLazy(0, 0, n- 1, l, r); }\\n\\n    void printSegmentTree(){\\n        for(int i : segmentTree) cout<<i<<\" \"; \\n        cout<<endl;\\n    }\\n\\n    int printSegmentTreeSum(){\\n        return segmentTree[0];\\n    }\\n};\\n```\n```\\n#define ll long long\\nclass Segment{\\n    int n;\\n    vector<ll> segmentTree, lazy;\\npublic:\\n    Segment(int n){\\n        this->n = n;\\n        \\n        segmentTree.resize(4 * n, 0);\\n        lazy.resize(4 * n, 0);\\n    }\\n    \\n    void rangeUpdate(int ind, int left, int right, int l, int r, int value){\\n        // Executing pending updates at first.\\n        if(lazy[ind] != 0){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind]; \\n            \\n            // If current node is not leaf, node means we have to propagate lazy updates to its childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We have done all pending updates.\\n            lazy[ind] = 0;\\n        }\\n        \\n        // Case 1 : If current segment is out of range.\\n        if(right < l || r < left) return ;\\n        \\n        // Case 2 : If current segment completely lies in range.\\n        if(l <= left && right <= r){\\n            segmentTree[ind] += (right - left + 1) * (value);\\n            \\n            if(left != right){\\n                lazy[2*ind+1] += value;\\n                lazy[2*ind+2] += value;\\n            }\\n            return ;\\n        }\\n        \\n        // Case 3 : If current segment lies partially.\\n        int mid = left + (right-left)/2;\\n        \\n        rangeUpdate(2 * ind + 1, left, mid, l, r, value);\\n        rangeUpdate(2 * ind + 2, mid + 1, right, l, r, value);\\n        \\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    \\n    void rangeUpdateQuery(int l, int r, int value){\\n        rangeUpdate(0, 0, n-1, l, r, value);\\n    }\\n    \\n    int querySumLazy(int ind, int left, int right, int l, int r){\\n        // Executing pending updates at first.\\n        if(lazy[ind]){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind];\\n            \\n            // If current node is not leaf node, then we have to propagate updates to childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We, are done updating : )\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1 : If range is completely outside...\\n        if(r < left || right < l) return 0;\\n\\n        // Case 2 : If range is completely inside...\\n        if(left >= l && right <= r) return segmentTree[ind];\\n\\n        // Case 3 : If range is partially inside or partially outside...\\n        int mid = (right + left)/2;\\n        \\n        int leftSide = querySumLazy(2*ind+1, left, mid, l, r);\\n        int rightSide = querySumLazy(2*ind+2, mid+1, right, l, r);\\n        \\n        return leftSide + rightSide;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {        \\n        Segment sT(s.size());\\n\\n        // Doing Range Update in Segement trees \\n        for(auto &shift : shifts){\\n            sT.rangeUpdateQuery(shift[0], shift[1], shift[2] ? 1 : -1);\\n        }\\n        \\n        \\n        for(int i = 0; i < s.size(); i++){\\n            // Fetching element updates which need to be done on current character...\\n            int element = (sT.querySumLazy(0, 0, s.size()-1, i,i) + s[i] - \\'a\\');    \\n            \\n            // If after adding update, if our character goes negative-outside-region of our lowercase range [a....z]\\n            // Then we need to subtract the nodes difference from the end...\\n            if(((element%26) + \\'a\\') < 97) s[i] = (char)(123 + (element%26));\\n            \\n            // Otherwise, if current element is in lowercase range, we will add it into answer...\\n            else s[i] = (char)((element%26) + \\'a\\');\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2543352,
                "title": "c-line-sweep-easy",
                "content": "```\\nclass Solution {\\n  public:\\n    string shiftingLetters(string s, vector < vector < int >> & shifts) {\\n      sort(shifts.begin(), shifts.end());\\n      int n = s.length();\\n      // to store the cummulative sum \\n      vector < int > line(n + 1, 0);\\n      for (int i = 0; i < shifts.size(); i++) {\\n        auto shift = shifts[i];\\n        // setting the starting point\\n        if (shift[2]) {\\n          line[shift[0]] += 1;\\n        }\\n         else {\\n          line[shift[0]] -= 1;\\n        }\\n        // setting the ending point\\n        if (shift[1] < n - 1) {\\n          if (shift[2]) {\\n            line[shift[1] + 1] -= 1;\\n          } else {\\n            line[shift[1] + 1] += 1;\\n          }\\n        }\\n      }\\n      for (int i = 1; i < n; i++) {\\n        line[i] += line[i - 1];\\n      }\\n      for (int i = 0; i < n; i++) {\\n        if (line[i] == 0) continue;\\n        line[i] %= 26;\\n        s[i] = (s[i] - \\'a\\' + line[i] + 26) % 26 + \\'a\\';\\n      }\\n      return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    string shiftingLetters(string s, vector < vector < int >> & shifts) {\\n      sort(shifts.begin(), shifts.end());\\n      int n = s.length();\\n      // to store the cummulative sum \\n      vector < int > line(n + 1, 0);\\n      for (int i = 0; i < shifts.size(); i++) {\\n        auto shift = shifts[i];\\n        // setting the starting point\\n        if (shift[2]) {\\n          line[shift[0]] += 1;\\n        }\\n         else {\\n          line[shift[0]] -= 1;\\n        }\\n        // setting the ending point\\n        if (shift[1] < n - 1) {\\n          if (shift[2]) {\\n            line[shift[1] + 1] -= 1;\\n          } else {\\n            line[shift[1] + 1] += 1;\\n          }\\n        }\\n      }\\n      for (int i = 1; i < n; i++) {\\n        line[i] += line[i - 1];\\n      }\\n      for (int i = 0; i < n; i++) {\\n        if (line[i] == 0) continue;\\n        line[i] %= 26;\\n        s[i] = (s[i] - \\'a\\' + line[i] + 26) % 26 + \\'a\\';\\n      }\\n      return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512848,
                "title": "98-faster-concise-t-c-o-n-explained",
                "content": "**PLS UPVOTE IF you like the SOLUTION!!!**\\n**IDEA:-**\\nWE HAVE THREE PARTS FOR THIS QUESTION \\n**1. LINE SWEEP**\\n we use this technique because its efficient as compared to increase a given range by 1 by visiting each and every element.\\n In this technique to achieve the same we mark only the first index of the range suppose increment by 1 (if direction is forward) and decrement the (last index+1 ) by 1.\\n Now move to the next step.\\n**2. PREFIX SUM**\\n\\tNow after using the technique you just have to take the prefix sum and you will notice that we have achieved the same thing and this method is very efficient as it runs in O(N) runtime as compared to earlier O(N^2) which will give TLE in this question.\\n**3. SHIFTING LETTERS**\\nwe use the statement provided in the code to shift the letters.\\n\\n**T.C:-** O(N)  **S.C:-** O(N)\\n\\t\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        vector<int>vec(s.length(),0);\\n        //FOR LINE SWEEP\\n        for(int i{0};i<shifts.size();++i){\\n            if(shifts[i][2]==0){\\n                vec.at(shifts[i][0])--;\\n                if(shifts[i][1]+1<vec.size()){\\n                    vec.at(shifts[i][1]+1)++;\\n                }\\n            }else{\\n                vec.at(shifts[i][0])++;\\n                if(shifts[i][1]+1<vec.size()){\\n                    vec.at(shifts[i][1]+1)--;\\n                }\\n            }\\n        }\\n        //FOR PREFIX SUM\\n        for(int i{1};i<vec.size();++i){\\n            vec.at(i)=vec.at(i)+vec.at(i-1);\\n        }\\n        //FOR SHIFTING LETTERS\\n        for(int i{0};i<vec.size();++i){\\n            s[i]=\\'a\\'+ (26+(s[i]-\\'a\\')+vec.at(i)%26)%26;   \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        vector<int>vec(s.length(),0);\\n        //FOR LINE SWEEP\\n        for(int i{0};i<shifts.size();++i){\\n            if(shifts[i][2]==0){\\n                vec.at(shifts[i][0])--;\\n                if(shifts[i][1]+1<vec.size()){\\n                    vec.at(shifts[i][1]+1)++;\\n                }\\n            }else{\\n                vec.at(shifts[i][0])++;\\n                if(shifts[i][1]+1<vec.size()){\\n                    vec.at(shifts[i][1]+1)--;\\n                }\\n            }\\n        }\\n        //FOR PREFIX SUM\\n        for(int i{1};i<vec.size();++i){\\n            vec.at(i)=vec.at(i)+vec.at(i-1);\\n        }\\n        //FOR SHIFTING LETTERS\\n        for(int i{0};i<vec.size();++i){\\n            s[i]=\\'a\\'+ (26+(s[i]-\\'a\\')+vec.at(i)%26)%26;   \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496267,
                "title": "python3-line-sweep-o-n-simple",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \\n        def helper(char,val):\\n            return chr(ord(\\'a\\')+(ord(char)-ord(\\'a\\')+val%26)%26)\\n        \\n        n=len(s)\\n        arr=[0 for _ in range(n)]\\n        for start,e,d in shifts:\\n            arr[start]+=1 if d else -1\\n            if e+1<n: arr[e+1]-=1 if d else -1\\n        for i in range(1,n):\\n            arr[i]+=arr[i-1]\\n        for i in range(n):\\n            arr[i]=helper(s[i],arr[i])\\n        return \\'\\'.join(arr)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \\n        def helper(char,val):\\n            return chr(ord(\\'a\\')+(ord(char)-ord(\\'a\\')+val%26)%26)\\n        \\n        n=len(s)\\n        arr=[0 for _ in range(n)]\\n        for start,e,d in shifts:\\n            arr[start]+=1 if d else -1\\n            if e+1<n: arr[e+1]-=1 if d else -1\\n        for i in range(1,n):\\n            arr[i]+=arr[i-1]\\n        for i in range(n):\\n            arr[i]=helper(s[i],arr[i])\\n        return \\'\\'.join(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485096,
                "title": "scanline-algorithm",
                "content": "\\n\\n\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        // Scanline Algorithm\\n        vector<int> prefix(n);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            (shifts[i][2]==1)?prefix[shifts[i][0]]+=1 : prefix[shifts[i][0]]-=1;\\n            if(shifts[i][1] + 1<n) (shifts[i][2]==1)?prefix[shifts[i][1] + 1]-=1 : prefix[shifts[i][1]+1]+=1;\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i]+=prefix[i-1];    // prefix sum  // to calculate how many times a particular index is changed\\n        }\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            prefix[i]%=26;    // to keep offset within 26 as a-z are 26\\n            \\n            if(int(s[i])+prefix[i] < 97) \\n            {\\n                s[i] = char(int(s[i])+prefix[i]+26); // ascii value of a-z are from 97 to 122;\\n            }\\n            else if(int(s[i])+prefix[i]>122)\\n            {\\n                s[i] = char(int(s[i])+prefix[i]-26);\\n            }\\n            else\\n            {\\n                s[i] = char(int(s[i])+prefix[i]);\\n            }\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        // Scanline Algorithm\\n        vector<int> prefix(n);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            (shifts[i][2]==1)?prefix[shifts[i][0]]+=1 : prefix[shifts[i][0]]-=1;\\n            if(shifts[i][1] + 1<n) (shifts[i][2]==1)?prefix[shifts[i][1] + 1]-=1 : prefix[shifts[i][1]+1]+=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2485017,
                "title": "easy-c-faster-then-80-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=shifts.size();\\n        vector<int>dp(s.size(),0);\\n        for(int i=0;i<n;i++){\\n            if(shifts[i][2]==0){\\n                dp[shifts[i][0]]-=1;\\n                if(shifts[i][1]<s.size()-1){\\n                    dp[shifts[i][1]+1]+=1;\\n                }\\n               }\\n            else{\\n                 dp[shifts[i][0]]+=1;\\n                if(shifts[i][1]<s.size()-1){\\n                    dp[shifts[i][1]+1]-=1;\\n                }\\n\\t\\t\\t}\\n        }\\n        for(int i=1;i<s.size();i++){\\n            dp[i]=dp[i-1]+dp[i];   //Saving no of movement required \\n        }\\n\\t\\t//some aptitude maths \\n        for(int i=0;i<s.size();i++){\\n            dp[i]=dp[i]%26;\\n            if(dp[i]+s[i]>\\'z\\'){\\n                char indx=dp[i]+s[i]-\\'z\\';\\n                s[i]=\\'a\\'+indx-1;\\n            }\\n            else if (dp[i]+s[i]<\\'a\\'){\\n                s[i]=s[i]+(26+dp[i]);\\n            }\\n            else\\n                s[i]=s[i]+dp[i];  \\n        }\\n        return s;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=shifts.size();\\n        vector<int>dp(s.size(),0);\\n        for(int i=0;i<n;i++){\\n            if(shifts[i][2]==0){\\n                dp[shifts[i][0]]-=1;\\n                if(shifts[i][1]<s.size()-1){\\n                    dp[shifts[i][1]+1]+=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2476492,
                "title": "best-easiest-solution-in-c",
                "content": "***Please Upvote if U liked my solution***\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n\\t\\n        int size=s.size();\\n        vector<int> vec(size+1);\\n        for(auto it:shifts){\\n            int start=it[0],end=it[1],dir=it[2];\\n            if(dir==1){\\n                vec[start]+=1;\\n                vec[end+1]+=-1;\\n            }\\n            else{\\n                vec[start]+=-1;\\n                vec[end+1]+=1;\\n            }\\n        }\\n        int prefixSum=0;\\n        for(int i=0;i<size;i++){\\n            prefixSum+=vec[i];\\n            while(prefixSum<0)\\n                prefixSum+=26;\\n            s[i]=(char)(\\'a\\'+(((s[i]-\\'a\\')+prefixSum)%26));\\n        }   \\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n\\t\\n        int size=s.size();\\n        vector<int> vec(size+1);\\n        for(auto it:shifts){\\n            int start=it[0],end=it[1],dir=it[2];\\n            if(dir==1){\\n                vec[start]+=1;\\n                vec[end+1]+=-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2476153,
                "title": "java-range-caching",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        // shifts[i] = [starti, endi, directioni]\\n        char[] ch = s.toCharArray();\\n        int n = s.length();\\n        int[] count = new int[s.length()+1];\\n        for(int[] shift : shifts){\\n            int starti = shift[0];\\n            int endi = shift[1];\\n            int directioni = shift[2];\\n            if(directioni == 1){\\n                count[starti] = count[starti] + 1;\\n                count[endi + 1] = count[endi + 1] - 1;\\n            }\\n            else{\\n                count[starti] = count[starti] - 1;\\n                count[endi + 1] = count[endi + 1] + 1;\\n            }\\n        }\\n        \\n        int temp = 0;\\n        for(int i = 0; i < count.length -1; i++){\\n            temp = temp + count[i];\\n            int newChar = ((ch[i] - \\'a\\') + temp) % 26;\\n            newChar = newChar < 0 ? newChar + 26 : newChar;\\n            ch[i] = (char)(\\'a\\' + newChar);\\n        }\\n        return String.valueOf(ch);\\n    }       \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        // shifts[i] = [starti, endi, directioni]\\n        char[] ch = s.toCharArray();\\n        int n = s.length();\\n        int[] count = new int[s.length()+1];\\n        for(int[] shift : shifts){\\n            int starti = shift[0];\\n            int endi = shift[1];\\n            int directioni = shift[2];\\n            if(directioni == 1){\\n                count[starti] = count[starti] + 1;\\n                count[endi + 1] = count[endi + 1] - 1;\\n            }\\n            else{\\n                count[starti] = count[starti] - 1;\\n                count[endi + 1] = count[endi + 1] + 1;\\n            }\\n        }\\n        \\n        int temp = 0;\\n        for(int i = 0; i < count.length -1; i++){\\n            temp = temp + count[i];\\n            int newChar = ((ch[i] - \\'a\\') + temp) % 26;\\n            newChar = newChar < 0 ? newChar + 26 : newChar;\\n            ch[i] = (char)(\\'a\\' + newChar);\\n        }\\n        return String.valueOf(ch);\\n    }       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472774,
                "title": "python3-line-sweep-method-with-hashmap",
                "content": "Note that for one who doesn\\'t know about line sweep technique, there will be a test case with enormous length giving TLE.\\n\\nFor knowing what character will become after shifting **n** position forward, we can use a list to achieve that purpose.\\nAs there will be only lower letter, we can assign \"a\" ~ \"z\" to a list of length 26.\\nFor instance, to know what character will be given after shifting \"a\" 3 times forward, the answer will be :\\n**lettermap[ ( ord(\"a\") - 97 + 3 ) % 26 ]** = \"d\"\\n\\nNext is to determine how to shift each character efficiently. It will be time-consuming if one goes to all characters between start and end of an interval then do the same to all intervals. \\nBy applying line sweep, the time complexity could be reduced substantially to linear time.\\n\\nTo see the idea of line sweep : \\n![image](https://assets.leetcode.com/users/images/1babae20-e732-41c5-9d33-c24ec3806bd1_1661335019.4304667.png)\\n\\nAfter iterating all shifting intervals and keep track of the shift offset starting at specific index,\\nwe can get the number of shifts starting at each index then use this information to perform character shifting.\\n\\n![image](https://assets.leetcode.com/users/images/0f4c25f2-6cd0-4b55-870e-e281a04ca38f_1661336267.0428574.png)\\n\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        # As in Python string is immutable, so need to convert it into character list.\\n        arr = list(s)\\n        n = len(arr)\\n        \\n        # Since there are only lowercase letter, we can use a list to serve the need for referring shifting character.\\n        maplist = [chr(i) for i in range(97, 123)]\\n        shiftmap = defaultdict(int)\\n        \\n        # shiftmap[i] = d means all characters from ith index to the end of the string\\n        # need to be shifted forward d times (if d < 0, shift backward.)\\n        # For each interval, we only need to use start and (end + 1) index.\\n        for start, end, direct in shifts:\\n            d = 1 if direct == 1 else -1\\n            shiftmap[start] += d\\n            if end + 1 < n: # we only care about index < length of s\\n                shiftmap[end + 1] -= d\\n        \\n        # Iterate each index and check its shift offset from the map\\n        # update the offset continuously then find the character after shifting the accumulated offset.\\n        offset = 0\\n        for i in range(n):\\n            if shiftmap[i] != 0:\\n                offset += shiftmap[i]\\n            arr[i] = maplist[(ord(arr[i]) - 97 + offset) % 26]\\n        \\n        return \"\".join(arr)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        # As in Python string is immutable, so need to convert it into character list.\\n        arr = list(s)\\n        n = len(arr)\\n        \\n        # Since there are only lowercase letter, we can use a list to serve the need for referring shifting character.\\n        maplist = [chr(i) for i in range(97, 123)]\\n        shiftmap = defaultdict(int)\\n        \\n        # shiftmap[i] = d means all characters from ith index to the end of the string\\n        # need to be shifted forward d times (if d < 0, shift backward.)\\n        # For each interval, we only need to use start and (end + 1) index.\\n        for start, end, direct in shifts:\\n            d = 1 if direct == 1 else -1\\n            shiftmap[start] += d\\n            if end + 1 < n: # we only care about index < length of s\\n                shiftmap[end + 1] -= d\\n        \\n        # Iterate each index and check its shift offset from the map\\n        # update the offset continuously then find the character after shifting the accumulated offset.\\n        offset = 0\\n        for i in range(n):\\n            if shiftmap[i] != 0:\\n                offset += shiftmap[i]\\n            arr[i] = maplist[(ord(arr[i]) - 97 + offset) % 26]\\n        \\n        return \"\".join(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467047,
                "title": "very-easy-explanation-brute-force-prefix-sum-optimized",
                "content": "* **Brute Force ( Time Limit Exceed )**\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(auto it:shifts){\\n            int l=it[0];\\n            int r=it[1];\\n            int dir=it[2];\\n            if(dir==1){\\n                for(int i=l;i<=r;i++)\\n                {\\n                    if(s[i]==\\'z\\') s[i]=\\'a\\';\\n                    else s[i]+=1;\\n                }\\n            }\\n            else{\\n                 for(int i=l;i<=r;i++)\\n                {\\n                    if(s[i]==\\'a\\') s[i]=\\'z\\';\\n                    else s[i]-=1;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n*  **Prefix Sum ( Optimized )**\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int>offset(n+1,0);\\n        for(auto it:shifts){\\n            int l=it[0];\\n            int r=it[1];\\n            int dir=it[2];\\n            if(dir==0){                // go backward by -1\\n               offset[l]+=-1;\\n               offset[r+1]+=1;\\n            }\\n            else{                   // go forward by +1\\n              offset[l]+=1;\\n              offset[r+1]+=-1;\\n            }\\n        }\\n        int prefix=0;\\n        for(int i=0;i<n;i++){\\n            prefix+=offset[i];\\n            while(prefix<0) prefix+=26;    // to cycle in \\'a\\'(97) to \\'z\\'(122) (negative remainder thrm)\\n            int ch=(s[i]-\\'a\\'+prefix)%26;  // jb tk 26 ke range me na a jaye tb tk prefix+=26 krte rho\\n            s[i]=char(\\'a\\'+ch);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(auto it:shifts){\\n            int l=it[0];\\n            int r=it[1];\\n            int dir=it[2];\\n            if(dir==1){\\n                for(int i=l;i<=r;i++)\\n                {\\n                    if(s[i]==\\'z\\') s[i]=\\'a\\';\\n                    else s[i]+=1;\\n                }\\n            }\\n            else{\\n                 for(int i=l;i<=r;i++)\\n                {\\n                    if(s[i]==\\'a\\') s[i]=\\'z\\';\\n                    else s[i]-=1;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int>offset(n+1,0);\\n        for(auto it:shifts){\\n            int l=it[0];\\n            int r=it[1];\\n            int dir=it[2];\\n            if(dir==0){                // go backward by -1\\n               offset[l]+=-1;\\n               offset[r+1]+=1;\\n            }\\n            else{                   // go forward by +1\\n              offset[l]+=1;\\n              offset[r+1]+=-1;\\n            }\\n        }\\n        int prefix=0;\\n        for(int i=0;i<n;i++){\\n            prefix+=offset[i];\\n            while(prefix<0) prefix+=26;    // to cycle in \\'a\\'(97) to \\'z\\'(122) (negative remainder thrm)\\n            int ch=(s[i]-\\'a\\'+prefix)%26;  // jb tk 26 ke range me na a jaye tb tk prefix+=26 krte rho\\n            s[i]=char(\\'a\\'+ch);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460326,
                "title": "rust-linear-solution-almost-all-contest-front-runners-use",
                "content": "\\n~~~\\nimpl Solution {\\n    pub fn shifting_letters(s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let n = s.len();\\n        let mut data = vec![0; n + 1];\\n        \\n        for shift in shifts {\\n            let amt = if shift[2] == 1 { 1 } else { -1 };\\n            data[s[0] as usize] += amt;\\n            data[s[1] as usize + 1] -= amt;\\n        }\\n        \\n        for i in 0..n {\\n            if i > 0 { data[i] = data[i] + data[i - 1]; }\\n            data[i] %= 26;\\n            if data[i] < 0 { data[i] += 26; }\\n        }\\n        \\n        let mut s = s.chars().collect::<Vec<char>>();\\n        for i in 0..n {\\n            s[i] = (\\'a\\' as u8 + (s[i] as u8 - \\'a\\' as u8 + data[i] as u8) % 26) as char;\\n        }\\n        \\n        s.iter().collect()\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "\\n~~~\\nimpl Solution {\\n    pub fn shifting_letters(s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let n = s.len();\\n        let mut data = vec![0; n + 1];\\n        \\n        for shift in shifts {\\n            let amt = if shift[2] == 1 { 1 } else { -1 };\\n            data[s[0] as usize] += amt;\\n            data[s[1] as usize + 1] -= amt;\\n        }\\n        \\n        for i in 0..n {\\n            if i > 0 { data[i] = data[i] + data[i - 1]; }\\n            data[i] %= 26;\\n            if data[i] < 0 { data[i] += 26; }\\n        }\\n        \\n        let mut s = s.chars().collect::<Vec<char>>();\\n        for i in 0..n {\\n            s[i] = (\\'a\\' as u8 + (s[i] as u8 - \\'a\\' as u8 + data[i] as u8) % 26) as char;\\n        }\\n        \\n        s.iter().collect()\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2458908,
                "title": "square-root-decompostion",
                "content": "Hello Friends,\\nThis question can be easily done by prefix-sum array but here I want to give an approach of sqaure root decomposition. First of all learning sqaure root decomposition is an way to solve range queries question. Generally this has time complexity of sqrt(n)*n;\\nl=shifts[i][0];\\nr=shifts[i][1];\\n\\nPrerequiste : Sqaure Root Decomposition \\n\\nAll the questions of SQRTD has a common structure so learning only question will push you to solve this one.\\nFor practicing you can solve \\nhttps://www.spoj.com/problems/RMQSQ/\\n\\nAfter this you will get this without any explaination.\\n\\n\\'\\'\\'\\n\\n\\t class Solution {\\n    \\n     public:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n=s.size();\\n        int blk=sqrt(n);\\n        int siz=ceil(n*1.0/blk);\\n        vector<int> f(siz,0);\\n        vector<int> arr(n,0);\\n        \\n        for(auto x: shifts){\\n            \\n            int l=x[0];\\n            int r=x[1];\\n            int add=x[2]==1?1:-1;\\n            int lb=l/blk;\\n            int rb=r/blk;\\n            if(lb==rb){\\n                for(int i=l;i<=r;i++){\\n                    arr[i]+=add;\\n                }\\n            }\\n            else{\\n                \\n                for(int i=l;i<blk*(lb+1);i++){\\n                    arr[i]+=add;\\n                }\\n              \\n                for(int i=lb+1;i<rb;i++){\\n                    f[i]+=add;\\n                }\\n                \\n                for(int i=blk*rb;i<=r;i++){\\n                    arr[i]+=add;\\n                }\\n             \\n            }\\n           \\n            \\n        }\\n        \\n        \\n       \\n        \\n     \\n       \\n        for(int i=0;i<n;i++){\\n           \\n            int change=arr[i]+f[i/blk];\\n            int k=change%26;\\n            int p1=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p1);\\n            \\n        }\\n        \\n        return s;\\n    }\\n    };\\n\\'\\'\\'\\nTC ==> O(N*SQRT(N))\\nSC==> O(N)",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n     public:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n=s.size();\\n        int blk=sqrt(n);\\n        int siz=ceil(n*1.0/blk);\\n        vector<int> f(siz,0);\\n        vector<int> arr(n,0);\\n        \\n        for(auto x: shifts){\\n            \\n            int l=x[0];\\n            int r=x[1];\\n            int add=x[2]==1?1:-1;\\n            int lb=l/blk;\\n            int rb=r/blk;\\n            if(lb==rb){\\n                for(int i=l;i<=r;i++){\\n                    arr[i]+=add;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2458369,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\npublic class Solution {\\n\\n    public String shiftingLetters(String input, int[][] shifts) {\\n        final int ALPHABET_SIZE = 26;\\n        int[] totalShifts = new int[input.length() + 1];\\n\\n        for (int[] shift : shifts) {\\n            int change = (shift[2] == 1) ? 1 : -1;\\n            totalShifts[shift[0]] += change;\\n            totalShifts[shift[1] + 1] -= change;\\n        }\\n\\n        char[] shiftedLetters = input.toCharArray();\\n        for (int i = 0; i < input.length(); ++i) {\\n            int currentShift = (shiftedLetters[i] - \\'a\\' + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                               % ALPHABET_SIZE;\\n            shiftedLetters[i] = (char) (currentShift + \\'a\\');\\n            totalShifts[i + 1] += totalShifts[i];\\n        }\\n\\n        return String.valueOf(shiftedLetters);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {string} input\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function (input, shifts) {\\n    const  ALPHABET_SIZE = 26;\\n    const ASCII_SMALL_CASE_A = 97;\\n    const totalShifts = new Array(input.length + 1).fill(0);\\n\\n    for (let shift of shifts) {\\n        const change = (shift[2] === 1) ? 1 : -1;\\n        totalShifts[shift[0]] += change;\\n        totalShifts[shift[1] + 1] -= change;\\n    }\\n\\n    let shiftedLetters = input.split(\\'\\');\\n    for (let i = 0; i < input.length; ++i) {\\n        const currentShift = (input.codePointAt(i) - ASCII_SMALL_CASE_A + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                             % ALPHABET_SIZE;\\n        shiftedLetters[i] = String.fromCodePoint(currentShift + ASCII_SMALL_CASE_A);\\n        totalShifts[i + 1] += totalShifts[i];\\n    }\\n\\n    return shiftedLetters.join(\\'\\');\\n};\\n```\\n**C++**\\n```\\n#include <string>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    string shiftingLetters(string input, vector<vector<int>>& shifts) {\\n        const int ALPHABET_SIZE = 26;\\n        vector<int> totalShifts(input.length() + 1);\\n\\n        for (const auto& shift : shifts) {\\n            int change = (shift[2] == 1) ? 1 : -1;\\n            totalShifts[shift[0]] += change;\\n            totalShifts[shift[1] + 1] -= change;\\n        }\\n\\n        for (int i = 0; i < input.length(); ++i) {\\n            int currentShift = (input[i] - \\'a\\' + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                               % ALPHABET_SIZE;\\n            input[i] = (char) (currentShift + \\'a\\');\\n            totalShifts[i + 1] += totalShifts[i];\\n        }\\n\\n        return input;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public String shiftingLetters(String input, int[][] shifts) {\\n        final int ALPHABET_SIZE = 26;\\n        int[] totalShifts = new int[input.length() + 1];\\n\\n        for (int[] shift : shifts) {\\n            int change = (shift[2] == 1) ? 1 : -1;\\n            totalShifts[shift[0]] += change;\\n            totalShifts[shift[1] + 1] -= change;\\n        }\\n\\n        char[] shiftedLetters = input.toCharArray();\\n        for (int i = 0; i < input.length(); ++i) {\\n            int currentShift = (shiftedLetters[i] - \\'a\\' + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                               % ALPHABET_SIZE;\\n            shiftedLetters[i] = (char) (currentShift + \\'a\\');\\n            totalShifts[i + 1] += totalShifts[i];\\n        }\\n\\n        return String.valueOf(shiftedLetters);\\n    }\\n}\\n```\n```\\n/**\\n * @param {string} input\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function (input, shifts) {\\n    const  ALPHABET_SIZE = 26;\\n    const ASCII_SMALL_CASE_A = 97;\\n    const totalShifts = new Array(input.length + 1).fill(0);\\n\\n    for (let shift of shifts) {\\n        const change = (shift[2] === 1) ? 1 : -1;\\n        totalShifts[shift[0]] += change;\\n        totalShifts[shift[1] + 1] -= change;\\n    }\\n\\n    let shiftedLetters = input.split(\\'\\');\\n    for (let i = 0; i < input.length; ++i) {\\n        const currentShift = (input.codePointAt(i) - ASCII_SMALL_CASE_A + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                             % ALPHABET_SIZE;\\n        shiftedLetters[i] = String.fromCodePoint(currentShift + ASCII_SMALL_CASE_A);\\n        totalShifts[i + 1] += totalShifts[i];\\n    }\\n\\n    return shiftedLetters.join(\\'\\');\\n};\\n```\n```\\n#include <string>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    string shiftingLetters(string input, vector<vector<int>>& shifts) {\\n        const int ALPHABET_SIZE = 26;\\n        vector<int> totalShifts(input.length() + 1);\\n\\n        for (const auto& shift : shifts) {\\n            int change = (shift[2] == 1) ? 1 : -1;\\n            totalShifts[shift[0]] += change;\\n            totalShifts[shift[1] + 1] -= change;\\n        }\\n\\n        for (int i = 0; i < input.length(); ++i) {\\n            int currentShift = (input[i] - \\'a\\' + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                               % ALPHABET_SIZE;\\n            input[i] = (char) (currentShift + \\'a\\');\\n            totalShifts[i + 1] += totalShifts[i];\\n        }\\n\\n        return input;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2457263,
                "title": "prefix-sum",
                "content": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> v(n+1, 0);\\n        for(int i=0; i<shifts.size(); i++){\\n            int st = shifts[i][0];\\n            int end = shifts[i][1]+1;\\n            int dir = shifts[i][2];\\n            if(dir==1){\\n                v[st]++;\\n                v[end]--;\\n            }else{\\n                v[st]--;\\n                v[end]++;\\n            }\\n        }\\n        \\n        v[0] = v[0]%26;\\n        for(int i=1; i<n; i++){\\n            v[i]+= v[i-1];\\n            v[i] = v[i]%26;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            int curr = s[i]-\\'a\\';\\n            int shift = curr+v[i];\\n            if(v[i]>0){\\n                if(shift>=26){\\n                    shift%=26;\\n                }\\n                s[i] = (char)\\'a\\'+shift;\\n            }else if(v[i]<0){\\n                if(shift<0){\\n                    shift+=26;\\n                }\\n                s[i] = (char)\\'a\\'+shift;\\n            }\\n        }\\n        return s;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> v(n+1, 0);\\n        for(int i=0; i<shifts.size(); i++){\\n            int st = shifts[i][0];\\n            int end = shifts[i][1]+1;\\n            int dir = shifts[i][2];\\n            if(dir==1){\\n                v[st]++;\\n                v[end]--;\\n            }else{\\n                v[st]--;\\n                v[end]++;\\n            }\\n        }\\n        \\n        v[0] = v[0]%26;\\n        for(int i=1; i<n; i++){\\n            v[i]+= v[i-1];\\n            v[i] = v[i]%26;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            int curr = s[i]-\\'a\\';\\n            int shift = curr+v[i];\\n            if(v[i]>0){\\n                if(shift>=26){\\n                    shift%=26;\\n                }\\n                s[i] = (char)\\'a\\'+shift;\\n            }else if(v[i]<0){\\n                if(shift<0){\\n                    shift+=26;\\n                }\\n                s[i] = (char)\\'a\\'+shift;\\n            }\\n        }\\n        return s;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456450,
                "title": "beats-100-c-solution-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    /* LOGIC:\\n    + Instead of storing the count of number of times a character is changing \\n    using hash table, \\n    + Make an array for indexes of string s then mark those indexes where \\n    the count of number of times a char changing according to given\\n    shifts\\'s starting and ending index.\\n    + And use a count variable to find that a number of times a particular\\n    char changed in the string s by changing the count variable using array\\n    on the go.\\n    \\n    e.g\\n    For, s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]\\n    // initially, markArray = [0, 0, 0, 0] (means every char in s changed 0 times, taking the markArray size = n+1 for simplicity purpose)\\n    for idx = 0 in shifts:\\n    markArray = [-1, 0, +1, 0] \\n    for idx = 1 in shifts:\\n    markArray = [-1, 0+(1), +1, 0+(-1)]\\n    for idx = 2 in shifts:\\n    markArray = [-1+(+1), +1, +1, -1+(-1)]\\n    \\n    final markArray = [0, 1, 1, 2]\\n    which means,\\n    cnt = 0 // initially\\n    for i = 0:\\n    cnt += markArray[0] => cnt = 0\\n    s[0] not changed, ie \\'a\\' => \\'a\\'\\n    for i = 1:\\n    cnt += markArray[1] => cnt = 1\\n    s[1] incremented by cnt=1, ie \\'b\\' => \\'c\\'\\n    for i = 2:\\n    cnt += markArray[1] => cnt = 2\\n    s[2] incremented by cnt=2, ie \\'c\\' => \\'e\\'\\n    \\n    output=>\\'ace\\'\\n    */\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<long long> shiftcnt (n+1, 0);\\n        for (int i=0; i<shifts.size(); i++) {\\n            if (shifts[i][2]==1) {\\n                shiftcnt[shifts[i][0]] += 1;\\n                shiftcnt[shifts[i][1]+1] -= 1; \\n            }\\n            else {\\n                shiftcnt[shifts[i][0]] -= 1;\\n                shiftcnt[shifts[i][1]+1] += 1; \\n            }\\n        }\\n        \\n        string chrs = \"abcdefghijklmnopqrstuvwxyz\";\\n        \\n        long long cnt = 0;\\n        for (int i=0; i<n; i++) {\\n            cnt += shiftcnt[i];\\n            int nshift = cnt%26;\\n            int c_idx = s[i]-\\'a\\';\\n            if (nshift>=0) {\\n                if (c_idx+nshift<=25) {\\n                    s[i] = chrs[c_idx+nshift];\\n                } else {\\n                    s[i] = chrs[c_idx+nshift-26];\\n                }\\n            }\\n            else {\\n                if (c_idx+nshift>=0) {\\n                    s[i] = chrs[c_idx+nshift];\\n                } else {\\n                    s[i] = chrs[26+c_idx+nshift];\\n                }\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* LOGIC:\\n    + Instead of storing the count of number of times a character is changing \\n    using hash table, \\n    + Make an array for indexes of string s then mark those indexes where \\n    the count of number of times a char changing according to given\\n    shifts\\'s starting and ending index.\\n    + And use a count variable to find that a number of times a particular\\n    char changed in the string s by changing the count variable using array\\n    on the go.\\n    \\n    e.g\\n    For, s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]\\n    // initially, markArray = [0, 0, 0, 0] (means every char in s changed 0 times, taking the markArray size = n+1 for simplicity purpose)\\n    for idx = 0 in shifts:\\n    markArray = [-1, 0, +1, 0] \\n    for idx = 1 in shifts:\\n    markArray = [-1, 0+(1), +1, 0+(-1)]\\n    for idx = 2 in shifts:\\n    markArray = [-1+(+1), +1, +1, -1+(-1)]\\n    \\n    final markArray = [0, 1, 1, 2]\\n    which means,\\n    cnt = 0 // initially\\n    for i = 0:\\n    cnt += markArray[0] => cnt = 0\\n    s[0] not changed, ie \\'a\\' => \\'a\\'\\n    for i = 1:\\n    cnt += markArray[1] => cnt = 1\\n    s[1] incremented by cnt=1, ie \\'b\\' => \\'c\\'\\n    for i = 2:\\n    cnt += markArray[1] => cnt = 2\\n    s[2] incremented by cnt=2, ie \\'c\\' => \\'e\\'\\n    \\n    output=>\\'ace\\'\\n    */\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<long long> shiftcnt (n+1, 0);\\n        for (int i=0; i<shifts.size(); i++) {\\n            if (shifts[i][2]==1) {\\n                shiftcnt[shifts[i][0]] += 1;\\n                shiftcnt[shifts[i][1]+1] -= 1; \\n            }\\n            else {\\n                shiftcnt[shifts[i][0]] -= 1;\\n                shiftcnt[shifts[i][1]+1] += 1; \\n            }\\n        }\\n        \\n        string chrs = \"abcdefghijklmnopqrstuvwxyz\";\\n        \\n        long long cnt = 0;\\n        for (int i=0; i<n; i++) {\\n            cnt += shiftcnt[i];\\n            int nshift = cnt%26;\\n            int c_idx = s[i]-\\'a\\';\\n            if (nshift>=0) {\\n                if (c_idx+nshift<=25) {\\n                    s[i] = chrs[c_idx+nshift];\\n                } else {\\n                    s[i] = chrs[c_idx+nshift-26];\\n                }\\n            }\\n            else {\\n                if (c_idx+nshift>=0) {\\n                    s[i] = chrs[c_idx+nshift];\\n                } else {\\n                    s[i] = chrs[26+c_idx+nshift];\\n                }\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456011,
                "title": "2-python-solutions-with-explanation-bruteforce-linesweep",
                "content": "\\t**BRUTE-FORCE SOLUTION** (GIVING TLE)\\n\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = defaultdict(int)\\n\\n\\t\\t\\tfor i in shifts:\\n\\t\\t\\t\\tif i[2] == 0:\\n\\t\\t\\t\\t\\tc = -1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tc = 1\\n\\t\\t\\t\\tfor j in range(i[0], i[1] + 1):\\n\\t\\t\\t\\t\\ttoshift[j] += c\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tl = list(s)\\n\\t\\t\\tfor i in range(len(l)):\\n\\t\\t\\t\\tif toshift[i]>0:\\n\\t\\t\\t\\t\\tacc= ord(l[i]) + (toshift[i]%26)\\n\\t\\t\\t\\t\\tif (acc) > 122:\\n\\t\\t\\t\\t\\t\\tacc = 96 + (acc-122)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tacc= ord(l[i]) - (abs(toshift[i])%26)\\n\\t\\t\\t\\t\\tif (acc) < 97:\\n\\t\\t\\t\\t\\t\\tacc = 123 - (97 - acc)\\n\\t\\t\\t\\tl[i] = chr(acc)\\n\\n\\t\\t\\treturn(\\'\\'.join(l))\\n\\t\\n\\t**OPTIMIZED SOLUTION**: (*LINE SWEEPING*)\\n\\t\\n\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = [0]*(len(s) +1)\\n\\t\\t\\t\\n\\t\\t\\t#marking start and end points only for start and end points of each shift \\n\\t\\t\\tfor i in shifts:\\n\\t\\t\\t\\tif i[2] == 1:\\n\\t\\t\\t\\t\\ttoshift[i[0]] += 1\\n\\t\\t\\t\\t\\ttoshift[i[1]+1] -= 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ttoshift[i[0]] -= 1\\n\\t\\t\\t\\t\\ttoshift[i[1]+1] += 1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tfor j in range(1, len(s)):                  #calculating prefixSum\\n\\t\\t\\t\\t\\ttoshift[j] += toshift[j-1]\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tl = list(s)                                 #converting in list for doing modification\\n\\t\\t\\tfor i in range(len(l)):\\n\\t\\t\\t\\tif toshift[i]>0:                        #for forward\\n\\t\\t\\t\\t\\tacc= ord(l[i]) + (toshift[i]%26)    #doing modulo by 26 because we have 26 alphabets and if suppose we to shift alphabet by 43 ie(43 % 26 = 1) so we will shift by 1 \\n\\t\\t\\t\\t\\tif (acc) > 122:\\n\\t\\t\\t\\t\\t\\tacc = 96 + (acc-122)            #if range exceeds then first subtract by 122 then add it in 96 (if still you did\\'nt get intution of it try doing dry run of it on some test cases)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse:                                   #for backward\\n\\t\\t\\t\\t\\tacc= ord(l[i]) - (abs(toshift[i])%26)\\n\\t\\t\\t\\t\\tif (acc) < 97:\\n\\t\\t\\t\\t\\t\\tacc = 123 - (97 - acc)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tl[i] = chr(acc)                         #finally updating that character\\n\\n\\t\\t\\treturn(\\'\\'.join(l))\\n\\t\\t\\t\\nDo **UPVOTE** :)\\n\\n**COMPLEXITY :**  O(N) time and O(N) space",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "\\t**BRUTE-FORCE SOLUTION** (GIVING TLE)\\n\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = defaultdict(int)\\n\\n\\t\\t\\tfor i in shifts:\\n\\t\\t\\t\\tif i[2] == 0:\\n\\t\\t\\t\\t\\tc = -1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tc = 1\\n\\t\\t\\t\\tfor j in range(i[0], i[1] + 1):\\n\\t\\t\\t\\t\\ttoshift[j] += c\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tl = list(s)\\n\\t\\t\\tfor i in range(len(l)):\\n\\t\\t\\t\\tif toshift[i]>0:\\n\\t\\t\\t\\t\\tacc= ord(l[i]) + (toshift[i]%26)\\n\\t\\t\\t\\t\\tif (acc) > 122:\\n\\t\\t\\t\\t\\t\\tacc = 96 + (acc-122)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tacc= ord(l[i]) - (abs(toshift[i])%26)\\n\\t\\t\\t\\t\\tif (acc) < 97:\\n\\t\\t\\t\\t\\t\\tacc = 123 - (97 - acc)\\n\\t\\t\\t\\tl[i] = chr(acc)\\n\\n\\t\\t\\treturn(\\'\\'.join(l))\\n\\t\\n\\t**OPTIMIZED SOLUTION**: (*LINE SWEEPING*)\\n\\t\\n\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = [0]*(len(s) +1)\\n\\t\\t\\t\\n\\t\\t\\t#marking start and end points only for start and end points of each shift \\n\\t\\t\\tfor i in shifts:\\n\\t\\t\\t\\tif i[2] == 1:\\n\\t\\t\\t\\t\\ttoshift[i[0]] += 1\\n\\t\\t\\t\\t\\ttoshift[i[1]+1] -= 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ttoshift[i[0]] -= 1\\n\\t\\t\\t\\t\\ttoshift[i[1]+1] += 1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tfor j in range(1, len(s)):                  #calculating prefixSum\\n\\t\\t\\t\\t\\ttoshift[j] += toshift[j-1]\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tl = list(s)                                 #converting in list for doing modification\\n\\t\\t\\tfor i in range(len(l)):\\n\\t\\t\\t\\tif toshift[i]>0:                        #for forward\\n\\t\\t\\t\\t\\tacc= ord(l[i]) + (toshift[i]%26)    #doing modulo by 26 because we have 26 alphabets and if suppose we to shift alphabet by 43 ie(43 % 26 = 1) so we will shift by 1 \\n\\t\\t\\t\\t\\tif (acc) > 122:\\n\\t\\t\\t\\t\\t\\tacc = 96 + (acc-122)            #if range exceeds then first subtract by 122 then add it in 96 (if still you did\\'nt get intution of it try doing dry run of it on some test cases)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse:                                   #for backward\\n\\t\\t\\t\\t\\tacc= ord(l[i]) - (abs(toshift[i])%26)\\n\\t\\t\\t\\t\\tif (acc) < 97:\\n\\t\\t\\t\\t\\t\\tacc = 123 - (97 - acc)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tl[i] = chr(acc)                         #finally updating that character\\n\\n\\t\\t\\treturn(\\'\\'.join(l))\\n\\t\\t\\t\\nDo **UPVOTE** :)\\n\\n**COMPLEXITY :**  O(N) time and O(N) space",
                "codeTag": "Java"
            },
            {
                "id": 2455458,
                "title": "java-solution-prefix-sum",
                "content": "```java \\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int[] a = new int[s.length()+1];\\n        \\n        for(int[] shift: shifts)\\n        {\\n            fill(a,shift[0],shift[1],shift[2]);\\n        }\\n        StringBuffer sb = new StringBuffer();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(i>0)\\n                a[i]+=a[i-1];\\n            a[i]%=26;\\n            if(s.charAt(i)+a[i]<97)\\n                sb.append((char)(s.charAt(i)+26+a[i]));\\n            else if(s.charAt(i)+a[i]>122)\\n                sb.append((char)(s.charAt(i)-26+a[i]));\\n            else\\n                sb.append((char)(s.charAt(i)+a[i]));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void fill(int[] a,int start,int end, int shift)\\n    {\\n        if(shift==0){\\n        a[start]--;\\n        a[end+1]++;\\n        }\\n        else{\\n        a[start]++;\\n        a[end+1]--;\\n        }   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int[] a = new int[s.length()+1];\\n        \\n        for(int[] shift: shifts)\\n        {\\n            fill(a,shift[0],shift[1],shift[2]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2455351,
                "title": "c-easy-to-understand-using-prefix-array-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> pref(s.size()+1,0);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            int z=shifts[i][2],l=shifts[i][0],r=shifts[i][1];\\n            if(z==0) // suppose given string of size 4 so initially pref array 0,0,0,0,0, and given range from (1,3)\\n            {\\n                pref[l]-=1; // for -1 case 0 -1 0 0 1 \\n                pref[r+1]+=1;\\n            }\\n            else\\n            {\\n                pref[l]+=1; // for the +1 case 0 1 0 0 -1  \\n                pref[r+1]-=1;\\n            }\\n        }\\n        for(int i=1;i<pref.size();i++)\\n        {\\n              pref[i]+=pref[i-1]; // calculating pref sum and we see that for +1 case 0 1 1 1 0  and for -1 case 0 -1 -1 -1 0 \\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(pref[i]<0) // if pref[i]<0 \\n            {\\n                int z=abs(pref[i]); // taking absolute value and converting it into multiple of z if modulo 0 then taking direct value by division or +1 in case not divisible\\n                if(z%26==0) \\n                z=z/26;\\n                else\\n                z=z/26+1;\\n                s[i]=(s[i]-\\'a\\'+pref[i]+z*26)%26+\\'a\\';\\n            }\\n            else\\n                s[i]=(s[i]-\\'a\\'+pref[i])%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```\\n**Please Upvote if you like it**",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> pref(s.size()+1,0);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            int z=shifts[i][2],l=shifts[i][0],r=shifts[i][1];\\n            if(z==0) // suppose given string of size 4 so initially pref array 0,0,0,0,0, and given range from (1,3)\\n            {\\n                pref[l]-=1; // for -1 case 0 -1 0 0 1 \\n                pref[r+1]+=1;\\n            }\\n            else\\n            {\\n                pref[l]+=1; // for the +1 case 0 1 0 0 -1  \\n                pref[r+1]-=1;\\n            }\\n        }\\n        for(int i=1;i<pref.size();i++)\\n        {\\n              pref[i]+=pref[i-1]; // calculating pref sum and we see that for +1 case 0 1 1 1 0  and for -1 case 0 -1 -1 -1 0 \\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(pref[i]<0) // if pref[i]<0 \\n            {\\n                int z=abs(pref[i]); // taking absolute value and converting it into multiple of z if modulo 0 then taking direct value by division or +1 in case not divisible\\n                if(z%26==0) \\n                z=z/26;\\n                else\\n                z=z/26+1;\\n                s[i]=(s[i]-\\'a\\'+pref[i]+z*26)%26+\\'a\\';\\n            }\\n            else\\n                s[i]=(s[i]-\\'a\\'+pref[i])%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454931,
                "title": "c-easy-and-simple-solution-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int>v(n+1,0);\\n        for(int i=0;i<shifts.size();i++){\\n            if(shifts[i][2]==0){\\n                v[shifts[i][0]]--;\\n                v[shifts[i][1] + 1]++;\\n            }\\n            else{\\n                 v[shifts[i][0]]++;\\n                v[shifts[i][1] + 1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            v[i]=v[i]+v[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]>=0){\\n                int a=v[i]%26;\\n                int b=(s[i]-\\'a\\'+a)%26;\\n                s[i]=\\'a\\'+b;\\n            } \\n            else{\\n                int a=(-1*v[i])%26;\\n                int b=(s[i]-\\'a\\'-a);\\n                if(b<0){\\n                    b=26+b;\\n                    s[i]=\\'a\\'+b;\\n                }\\n                else{\\n                    s[i]=\\'a\\'+b;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int>v(n+1,0);\\n        for(int i=0;i<shifts.size();i++){\\n            if(shifts[i][2]==0){\\n                v[shifts[i][0]]--;\\n                v[shifts[i][1] + 1]++;\\n            }\\n            else{\\n                 v[shifts[i][0]]++;\\n                v[shifts[i][1] + 1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            v[i]=v[i]+v[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]>=0){\\n                int a=v[i]%26;\\n                int b=(s[i]-\\'a\\'+a)%26;\\n                s[i]=\\'a\\'+b;\\n            } \\n            else{\\n                int a=(-1*v[i])%26;\\n                int b=(s[i]-\\'a\\'-a);\\n                if(b<0){\\n                    b=26+b;\\n                    s[i]=\\'a\\'+b;\\n                }\\n                else{\\n                    s[i]=\\'a\\'+b;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454745,
                "title": "easy-c-code-prefix-sum",
                "content": "class Solution {\\npublic:\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> v(s.size() + 2, 0);\\n\\n        for (auto &it : shifts) {\\n            int l = it[0], r = it[1], d = it[2];\\n\\n            if (d == 0) {\\n                v[l]--;\\n                v[r + 1]++;\\n            }\\n            else {\\n                v[l]++;\\n                v[r + 1]--;\\n            }\\n        }\\n\\n        for (int i = 1; i < s.size(); i++) {\\n            v[i] = v[i] + v[i - 1];\\n        }\\n        \\n        for(auto i = 0; i < s.size(); i++) {\\n            \\n            int ans = ((s[i] - \\'a\\') + v[i]) % 26;\\n            s[i] = \\'a\\' + (ans + 26)%26;\\n        }\\n\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> v(s.size() + 2, 0);\\n\\n        for (auto &it : shifts) {\\n            int l = it[0], r = it[1], d = it[2];\\n\\n            if (d == 0) {\\n                v[l]--;\\n                v[r + 1]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2454607,
                "title": "using-1-1-trick-prefix-sum-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> f(n);\\n        \\n        for(vector<int> a : shifts){\\n            if(a[2] == 0){\\n                f[a[0]] -= 1;\\n                if(a[1] + 1 < n) f[a[1] + 1] += 1;\\n            }\\n            else{\\n                f[a[0]] += 1;\\n                if(a[1] + 1 < n) f[a[1] + 1] -= 1;\\n            }\\n        }\\n        \\n        for(int i=1; i<n; i++){\\n            f[i] += f[i-1];\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(f[i] < 0){\\n                f[i] *= -1;\\n                f[i] %= 26;\\n                f[i] = 26 - f[i];\\n            }\\n            else{\\n                f[i] %= 26;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            s[i] = ((s[i] - \\'a\\' + f[i]) % 26 + \\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> f(n);\\n        \\n        for(vector<int> a : shifts){\\n            if(a[2] == 0){\\n                f[a[0]] -= 1;\\n                if(a[1] + 1 < n) f[a[1] + 1] += 1;\\n            }\\n            else{\\n                f[a[0]] += 1;\\n                if(a[1] + 1 < n) f[a[1] + 1] -= 1;\\n            }\\n        }\\n        \\n        for(int i=1; i<n; i++){\\n            f[i] += f[i-1];\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(f[i] < 0){\\n                f[i] *= -1;\\n                f[i] %= 26;\\n                f[i] = 26 - f[i];\\n            }\\n            else{\\n                f[i] %= 26;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            s[i] = ((s[i] - \\'a\\' + f[i]) % 26 + \\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454592,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public string ShiftingLetters(string s, int[][] shifts) {\\n        const int n = 26;\\n        var diffs = new int[s.Length + 1];\\n\\n        foreach (var shift in shifts)\\n            if (shift[2] == 0) {\\n                diffs[shift[0]]--;\\n                diffs[shift[1] + 1]++;\\n            }\\n            else {\\n                diffs[shift[0]]++;\\n                diffs[shift[1] + 1]--;\\n            }\\n\\n        var arr = s.ToCharArray();\\n        var diff = 0;\\n\\n        for (var i = 0; i < s.Length; i++) {\\n            diff += diffs[i];\\n            arr[i] = (char)(\\'a\\' + ((arr[i] + diff - \\'a\\') % n + n) % n);\\n        }\\n\\n        return new string(arr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string ShiftingLetters(string s, int[][] shifts) {\\n        const int n = 26;\\n        var diffs = new int[s.Length + 1];\\n\\n        foreach (var shift in shifts)\\n            if (shift[2] == 0) {\\n                diffs[shift[0]]--;\\n                diffs[shift[1] + 1]++;\\n            }\\n            else {\\n                diffs[shift[0]]++;\\n                diffs[shift[1] + 1]--;\\n            }\\n\\n        var arr = s.ToCharArray();\\n        var diff = 0;\\n\\n        for (var i = 0; i < s.Length; i++) {\\n            diff += diffs[i];\\n            arr[i] = (char)(\\'a\\' + ((arr[i] + diff - \\'a\\') % n + n) % n);\\n        }\\n\\n        return new string(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454585,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\tres = [0] * (len(s) + 1)\\n\\t\\t\\tfor start, end, direction in shifts:\\n\\t\\t\\t\\tif direction == 0:\\n\\t\\t\\t\\t\\tres[start] -= 1\\n\\t\\t\\t\\t\\tres[end + 1] += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres[start] += 1\\n\\t\\t\\t\\t\\tres[end + 1] -= 1\\n\\t\\t\\tfor i in range(1, len(res)):\\n\\t\\t\\t\\tres[i] += res[i - 1]\\n\\t\\t\\tfor i, c in enumerate(s):\\n\\t\\t\\t\\tres[i] = chr(ord(\"a\") + (ord(c) - ord(\"a\") + res[i] + 26) % 26)\\n\\t\\t\\treturn \"\".join(res[:-1])",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\tres = [0] * (len(s) + 1)\\n\\t\\t\\tfor start, end, direction in shifts:\\n\\t\\t\\t\\tif direction == 0:\\n\\t\\t\\t\\t\\tres[start] -= 1\\n\\t\\t\\t\\t\\tres[end + 1] += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres[start] += 1\\n\\t\\t\\t\\t\\tres[end + 1] -= 1\\n\\t\\t\\tfor i in range(1, len(res)):\\n\\t\\t\\t\\tres[i] += res[i - 1]\\n\\t\\t\\tfor i, c in enumerate(s):\\n\\t\\t\\t\\tres[i] = chr(ord(\"a\") + (ord(c) - ord(\"a\") + res[i] + 26) % 26)\\n\\t\\t\\treturn \"\".join(res[:-1])",
                "codeTag": "Java"
            },
            {
                "id": 2454506,
                "title": "python3-sum-changes-per-element",
                "content": "**Biweekly Contest 85 Submission**\\n\\n**Sum Changes per Element**\\n1. Get the sum of the changes to each character in ```s``` given the intervals in ```shifts``` (linearly with a prefix sum array ```dp```).\\n2. Apply the changes from ```dp``` per character in ```s``` and return the result.\\n\\n**Code**\\n```Python3 []\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        dp = [0]*(n + 1)\\n        res = \"\"\\n        \\n        #Get changes\\n        for u, v, w in shifts:\\n            if w:\\n                dp[u] += 1\\n                dp[v + 1] -= 1\\n            else:\\n                dp[u] -= 1\\n                dp[v + 1] += 1\\n                    \\n        #Prefix sum\\n        for idx in range(1, n):\\n            dp[idx] += dp[idx - 1]\\n        \\n        #Apply changes\\n        for idx in range(n):\\n            res += chr((ord(s[idx]) - ord(\\'a\\') + dp[idx]) % 26 + ord(\\'a\\'))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```s```\n```shifts```\n```dp```\n```dp```\n```s```\n```Python3 []\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        dp = [0]*(n + 1)\\n        res = \"\"\\n        \\n        #Get changes\\n        for u, v, w in shifts:\\n            if w:\\n                dp[u] += 1\\n                dp[v + 1] -= 1\\n            else:\\n                dp[u] -= 1\\n                dp[v + 1] += 1\\n                    \\n        #Prefix sum\\n        for idx in range(1, n):\\n            dp[idx] += dp[idx - 1]\\n        \\n        #Apply changes\\n        for idx in range(n):\\n            res += chr((ord(s[idx]) - ord(\\'a\\') + dp[idx]) % 26 + ord(\\'a\\'))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454412,
                "title": "c-partial-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        int arr[n+1];\\n        memset(arr,0,sizeof(arr));\\n        \\n        for(auto shift : shifts){\\n            int l = shift[0];\\n            int r = shift[1];\\n            int dir = shift[2];\\n            \\n            if(dir==1){\\n                arr[l]++;\\n                arr[r+1]--;\\n            }else{\\n                arr[l]--;\\n                arr[r+1]++;\\n            }\\n        }\\n        for(int i = 0 ; i <= n ; i++){\\n            if(i!=0) arr[i] += arr[i-1];\\n            // cout<<arr[i]<<\" \";\\n        }\\n        // cout<<\"\\\\n\";\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            arr[i] = (arr[i] + s[i]-\\'a\\')%(26);\\n            if(arr[i]<0) arr[i] = (arr[i]+26)%26;\\n        }\\n        string ans = \"\";\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            ans += (char)(arr[i]+\\'a\\');\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        int arr[n+1];\\n        memset(arr,0,sizeof(arr));\\n        \\n        for(auto shift : shifts){\\n            int l = shift[0];\\n            int r = shift[1];\\n            int dir = shift[2];\\n            \\n            if(dir==1){\\n                arr[l]++;\\n                arr[r+1]--;\\n            }else{\\n                arr[l]--;\\n                arr[r+1]++;\\n            }\\n        }\\n        for(int i = 0 ; i <= n ; i++){\\n            if(i!=0) arr[i] += arr[i-1];\\n            // cout<<arr[i]<<\" \";\\n        }\\n        // cout<<\"\\\\n\";\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            arr[i] = (arr[i] + s[i]-\\'a\\')%(26);\\n            if(arr[i]<0) arr[i] = (arr[i]+26)%26;\\n        }\\n        string ans = \"\";\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            ans += (char)(arr[i]+\\'a\\');\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2454399,
                "title": "o-n-difference-array",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \\n        def convert(c, ch):\\n            return chr((ord(c.upper()) + ch - 65) % 26 + 65).lower()\\n        \\n        n, l = len(s), list(s)\\n        changes = [0] * (n+1)\\n        \\n        for shift in shifts:\\n            changes[shift[0]] += 1 if shift[2] == 1 else -1\\n            changes[shift[1] + 1] += 1 if shift[2] == 0 else -1\\n            \\n        for i in range(1, n+1):\\n            changes[i] += changes[i-1]\\n            \\n        for i, c in enumerate(l):\\n            l[i] = convert(c, changes[i])\\n            \\n        return \\'\\'.join(l)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \\n        def convert(c, ch):\\n            return chr((ord(c.upper()) + ch - 65) % 26 + 65).lower()\\n        \\n        n, l = len(s), list(s)\\n        changes = [0] * (n+1)\\n        \\n        for shift in shifts:\\n            changes[shift[0]] += 1 if shift[2] == 1 else -1\\n            changes[shift[1] + 1] += 1 if shift[2] == 0 else -1\\n            \\n        for i in range(1, n+1):\\n            changes[i] += changes[i-1]\\n            \\n        for i, c in enumerate(l):\\n            l[i] = convert(c, changes[i])\\n            \\n        return \\'\\'.join(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454355,
                "title": "c-range-query-o-n",
                "content": "Upvote If you like the solution\\ncomment down any doubts or suggestions\\nTime : O(n)\\nSpace : O(n)\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> arr(n, 0);\\n        \\n        for(auto it: shifts) {\\n            int curr = 0;\\n            if(!it[2]) curr = -1;\\n            else curr = 1;\\n            \\n            int s = it[0], e = it[1];\\n            arr[s] += curr;\\n            if(e+1 < n) arr[e+1] -= curr;\\n        }\\n        \\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            cnt += arr[i];\\n            cnt %= 26;\\n            int temp = ((s[i]-\\'a\\') + cnt + 26) % 26;\\n            s[i] = temp + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> arr(n, 0);\\n        \\n        for(auto it: shifts) {\\n            int curr = 0;\\n            if(!it[2]) curr = -1;\\n            else curr = 1;\\n            \\n            int s = it[0], e = it[1];\\n            arr[s] += curr;\\n            if(e+1 < n) arr[e+1] -= curr;\\n        }\\n        \\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            cnt += arr[i];\\n            cnt %= 26;\\n            int temp = ((s[i]-\\'a\\') + cnt + 26) % 26;\\n            s[i] = temp + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454345,
                "title": "partial-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        long long int arr[s.size()+1];\\n        memset(arr, 0, sizeof(arr));\\n        for(auto it : shifts)\\n        {\\n            long long int l = it[0], r = it[1], dir = it[2];\\n            if(dir)\\n            {\\n                arr[l]+=1;\\n                arr[r+1]+=-1;\\n            }\\n            else \\n            {\\n                arr[l]-=1;\\n                arr[r+1]+=1;\\n            }\\n        }\\n        int s2=0;\\n        for(int i=0;i<s.size()+1;i++)\\n        {\\n            s2+=arr[i];\\n            arr[i]=s2;\\n        }\\n        for(long long int i =0 ; i < s.size(); ++i)\\n        {\\n            if(arr[i]>=0)\\n            {\\n                int shift = arr[i]%26;\\n                int k = (int)s[i];\\n                int t =(k+shift);\\n                if(t > 122)\\n                {\\n                    int c = t-122;\\n                    t=96+c;\\n                }\\n                s[i] = (char)t;\\n            }\\n            if(arr[i] < 0)\\n            {\\n                int shift = abs(arr[i])%26;\\n                int k = (int)s[i];\\n                int t= (k-shift);\\n                if(t<97)\\n                {\\n                    int c = 97-t;\\n                    t = 123-c;\\n                }\\n                s[i] = (char)t;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        long long int arr[s.size()+1];\\n        memset(arr, 0, sizeof(arr));\\n        for(auto it : shifts)\\n        {\\n            long long int l = it[0], r = it[1], dir = it[2];\\n            if(dir)\\n            {\\n                arr[l]+=1;\\n                arr[r+1]+=-1;\\n            }\\n            else \\n            {\\n                arr[l]-=1;\\n                arr[r+1]+=1;\\n            }\\n        }\\n        int s2=0;\\n        for(int i=0;i<s.size()+1;i++)\\n        {\\n            s2+=arr[i];\\n            arr[i]=s2;\\n        }\\n        for(long long int i =0 ; i < s.size(); ++i)\\n        {\\n            if(arr[i]>=0)\\n            {\\n                int shift = arr[i]%26;\\n                int k = (int)s[i];\\n                int t =(k+shift);\\n                if(t > 122)\\n                {\\n                    int c = t-122;\\n                    t=96+c;\\n                }\\n                s[i] = (char)t;\\n            }\\n            if(arr[i] < 0)\\n            {\\n                int shift = abs(arr[i])%26;\\n                int k = (int)s[i];\\n                int t= (k-shift);\\n                if(t<97)\\n                {\\n                    int c = 97-t;\\n                    t = 123-c;\\n                }\\n                s[i] = (char)t;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454343,
                "title": "scala-sorted-shifts-and-simple-recursion",
                "content": "```scala\\ncase class Shift(start: Int, finish: Int, up: Boolean)\\n\\ndef shiftingLetters(s: String, shifts: Array[Array[Int]]): String = {\\n  val shfts = shifts.map {\\n    case Array(start, finish, 0) => Shift(start, finish, false)\\n    case Array(start, finish, 1) => Shift(start, finish, true)\\n    case _ => ???\\n  }\\n  val start = shfts.sortBy(_.start)\\n  val finish = shfts.sortBy(_.finish)\\n  val chars = s.map(_ - \\'a\\').zipWithIndex\\n  goShift(chars.toList, 0, start.toList, finish.toList, List.empty).map(toChar).mkString\\n}\\n\\ndef goShift(chars: List[(Int, Int)], k:  Int, start: List[Shift], finish: List[Shift], acc: List[Int]): List[Int] =\\n  chars match {\\n    case Nil => acc.reverse\\n    case (c, i) :: tail =>\\n      val started = start.takeWhile(_.start <= i).map(s => if(s.up) 1 else -1)\\n      val finished = finish.takeWhile(_.finish < i).map(s => if(s.up) -1 else 1)\\n      val nK = k + started.sum + finished.sum\\n      goShift(tail, nK, start.drop(started.size), finish.drop(finished.size), c + nK :: acc)\\n  }\\n\\ndef toChar(i: Int) = (\\'a\\' + math.floorMod(i, 26)).toChar\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```scala\\ncase class Shift(start: Int, finish: Int, up: Boolean)\\n\\ndef shiftingLetters(s: String, shifts: Array[Array[Int]]): String = {\\n  val shfts = shifts.map {\\n    case Array(start, finish, 0) => Shift(start, finish, false)\\n    case Array(start, finish, 1) => Shift(start, finish, true)\\n    case _ => ???\\n  }\\n  val start = shfts.sortBy(_.start)\\n  val finish = shfts.sortBy(_.finish)\\n  val chars = s.map(_ - \\'a\\').zipWithIndex\\n  goShift(chars.toList, 0, start.toList, finish.toList, List.empty).map(toChar).mkString\\n}\\n\\ndef goShift(chars: List[(Int, Int)], k:  Int, start: List[Shift], finish: List[Shift], acc: List[Int]): List[Int] =\\n  chars match {\\n    case Nil => acc.reverse\\n    case (c, i) :: tail =>\\n      val started = start.takeWhile(_.start <= i).map(s => if(s.up) 1 else -1)\\n      val finished = finish.takeWhile(_.finish < i).map(s => if(s.up) -1 else 1)\\n      val nK = k + started.sum + finished.sum\\n      goShift(tail, nK, start.drop(started.size), finish.drop(finished.size), c + nK :: acc)\\n  }\\n\\ndef toChar(i: Int) = (\\'a\\' + math.floorMod(i, 26)).toChar\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454322,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        indices = [0 for i in range(len(s)+1)]\\n        for i,j,k in shifts:\\n            if k == 1:\\n                indices[i] += 1\\n                indices[j+1] -= 1\\n            else:\\n                indices[i] += 25\\n                indices[j+1] -= 25\\n        count = 0\\n        alpha = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        pos = {alpha[i]:i for i in range(len(alpha))}\\n        new = \\'\\'\\n        for i in range(len(s)):\\n            count += indices[i]\\n            new+=alpha[(count+pos[s[i]])%26]\\n        return new\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        indices = [0 for i in range(len(s)+1)]\\n        for i,j,k in shifts:\\n            if k == 1:\\n                indices[i] += 1\\n                indices[j+1] -= 1\\n            else:\\n                indices[i] += 25\\n                indices[j+1] -= 25\\n        count = 0\\n        alpha = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        pos = {alpha[i]:i for i in range(len(alpha))}\\n        new = \\'\\'\\n        for i in range(len(s)):\\n            count += indices[i]\\n            new+=alpha[(count+pos[s[i]])%26]\\n        return new\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454280,
                "title": "segment-tree-lazy-propagation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    // Solution based on Segment Tree and Lazy propagation, I feel this solution is not optimal and can be optimized a lot.\\n    \\n    #define M (beg+end)/2\\n    void pushdown(int pos, int beg, int end,vector<int> &lazy, vector<int> &st)\\n    {\\n        if (lazy[pos] > 0)\\n        {\\n            st[pos] += (end - beg + 1) * lazy[pos];\\n            st[pos]%=26;\\n            if (beg != end)\\n            {\\n                lazy[2 * pos + 1] =(lazy[2 * pos + 1] + lazy[pos])%26;\\n                lazy[2 * pos + 2] =(lazy[2 * pos + 2] + lazy[pos])%26;\\n            }\\n            lazy[pos] = 0;\\n        }\\n    }\\n    \\n    void update(int beg, int end, int ul, int ur, int val, int pos,vector<int> &lazy,vector<int> &st)\\n    {\\n        pushdown(pos, beg, end,lazy,st);\\n        if (ul <= beg && ur >= end)\\n        {\\n            lazy[pos] += val;\\n            lazy[pos]%=26;\\n            pushdown(pos, beg, end,lazy,st);\\n            return;\\n        }\\n        if (ul > end || ur < beg)\\n            return;\\n        update(beg, M, ul, ur, val, 2 * pos + 1,lazy,st);\\n        update(M + 1, end, ul, ur, val, 2 * pos + 2,lazy,st);\\n        st[pos] = st[2 * pos + 1] + st[2 * pos + 2];\\n        st[pos]%=26;\\n    }\\n    \\n    int query(int beg, int end, int ql, int qr, int pos, vector<int> &lazy, vector<int> &st)\\n    {\\n        pushdown(pos, beg, end,lazy,st);\\n        if (ql <= beg && qr >= end)\\n        {\\n            return st[pos];\\n        }\\n        if (ql > end || qr < beg)\\n            return 0;\\n        return (query(beg, M, ql, qr, 2 * pos + 1,lazy,st) + query(M + 1, end, ql, qr, 2 * pos + 2,lazy,st))%26;\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        int m=shifts.size();\\n        vector<int> st(4*n);\\n        vector<int> lazy(4*n);\\n        for(int i=0; i<m; i++) {\\n            if(shifts[i][2]==0){\\n                update(0,n-1,shifts[i][0],shifts[i][1],25,0,lazy,st);\\n            }else{\\n                update(0,n-1,shifts[i][0],shifts[i][1],1,0,lazy,st);\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0; i<n; i++){\\n            // cout<<\"query : \"<<query(0,n-1,i,i,0,lazy,st)<<endl;\\n            ans+=(char(\\'a\\'+((((s[i]-\\'a\\'+query(0,n-1,i,i,0,lazy,st))%26)+26)%26)));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Solution based on Segment Tree and Lazy propagation, I feel this solution is not optimal and can be optimized a lot.\\n    \\n    #define M (beg+end)/2\\n    void pushdown(int pos, int beg, int end,vector<int> &lazy, vector<int> &st)\\n    {\\n        if (lazy[pos] > 0)\\n        {\\n            st[pos] += (end - beg + 1) * lazy[pos];\\n            st[pos]%=26;\\n            if (beg != end)\\n            {\\n                lazy[2 * pos + 1] =(lazy[2 * pos + 1] + lazy[pos])%26;\\n                lazy[2 * pos + 2] =(lazy[2 * pos + 2] + lazy[pos])%26;\\n            }\\n            lazy[pos] = 0;\\n        }\\n    }\\n    \\n    void update(int beg, int end, int ul, int ur, int val, int pos,vector<int> &lazy,vector<int> &st)\\n    {\\n        pushdown(pos, beg, end,lazy,st);\\n        if (ul <= beg && ur >= end)\\n        {\\n            lazy[pos] += val;\\n            lazy[pos]%=26;\\n            pushdown(pos, beg, end,lazy,st);\\n            return;\\n        }\\n        if (ul > end || ur < beg)\\n            return;\\n        update(beg, M, ul, ur, val, 2 * pos + 1,lazy,st);\\n        update(M + 1, end, ul, ur, val, 2 * pos + 2,lazy,st);\\n        st[pos] = st[2 * pos + 1] + st[2 * pos + 2];\\n        st[pos]%=26;\\n    }\\n    \\n    int query(int beg, int end, int ql, int qr, int pos, vector<int> &lazy, vector<int> &st)\\n    {\\n        pushdown(pos, beg, end,lazy,st);\\n        if (ql <= beg && qr >= end)\\n        {\\n            return st[pos];\\n        }\\n        if (ql > end || qr < beg)\\n            return 0;\\n        return (query(beg, M, ql, qr, 2 * pos + 1,lazy,st) + query(M + 1, end, ql, qr, 2 * pos + 2,lazy,st))%26;\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        int m=shifts.size();\\n        vector<int> st(4*n);\\n        vector<int> lazy(4*n);\\n        for(int i=0; i<m; i++) {\\n            if(shifts[i][2]==0){\\n                update(0,n-1,shifts[i][0],shifts[i][1],25,0,lazy,st);\\n            }else{\\n                update(0,n-1,shifts[i][0],shifts[i][1],1,0,lazy,st);\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0; i<n; i++){\\n            // cout<<\"query : \"<<query(0,n-1,i,i,0,lazy,st)<<endl;\\n            ans+=(char(\\'a\\'+((((s[i]-\\'a\\'+query(0,n-1,i,i,0,lazy,st))%26)+26)%26)));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2454253,
                "title": "c-o-n-time",
                "content": "```\\n    public string ShiftingLetters(string s, int[][] shifts) \\n    {\\n        int[] change = new int[s.Length + 1];\\n        foreach (int[] shift in shifts)\\n        {\\n            if (shift[2] == 1)\\n            {\\n                change[shift[0]]++;\\n                change[shift[1] + 1]--;\\n            }\\n            else\\n            {\\n                change[shift[0]]--;\\n                change[shift[1] + 1]++;\\n            }\\n        }\\n\\n        StringBuilder sb = new StringBuilder(s);\\n        int pre = 0;\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            pre += change[i];\\n            int numChange = ((sb[i] - \\'a\\' + pre)%26 + 26)%26;\\n            sb[i] = (char)(\\'a\\' + numChange);\\n        }\\n        return sb.ToString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public string ShiftingLetters(string s, int[][] shifts) \\n    {\\n        int[] change = new int[s.Length + 1];\\n        foreach (int[] shift in shifts)\\n        {\\n            if (shift[2] == 1)\\n            {\\n                change[shift[0]]++;\\n                change[shift[1] + 1]--;\\n            }\\n            else\\n            {\\n                change[shift[0]]--;\\n                change[shift[1] + 1]++;\\n            }\\n        }\\n\\n        StringBuilder sb = new StringBuilder(s);\\n        int pre = 0;\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            pre += change[i];\\n            int numChange = ((sb[i] - \\'a\\' + pre)%26 + 26)%26;\\n            sb[i] = (char)(\\'a\\' + numChange);\\n        }\\n        return sb.ToString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454200,
                "title": "java-solution-o-n-range-sum-update-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int[] ch=new int[s.length()];\\n        for(int[] shift:shifts){\\n            int start=shift[0];\\n            int end=shift[1];\\n            int add=shift[2]==0?-1:1;\\n            ch[start]+=add;\\n            if(end+1<ch.length)\\n                ch[end+1]-=add;\\n        }\\n        int sum=0;\\n        for(int i=0;i<ch.length;i++){\\n            sum+=ch[i];\\n            ch[i]=sum;\\n        }\\n        \\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            int shift=ch[i];\\n            if(shift>=0)\\n                shift=ch[i]%26;\\n            else\\n                shift=ch[i]%26+26;\\n            \\n            if(shift==0)\\n                sb.append(s.charAt(i));\\n            else {\\n                int diff = c + shift;\\n                if (diff < 123)\\n                    sb.append((char) diff);\\n                else\\n                    sb.append((char) (diff - 123 + \\'a\\'));\\n            }\\n\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int[] ch=new int[s.length()];\\n        for(int[] shift:shifts){\\n            int start=shift[0];\\n            int end=shift[1];\\n            int add=shift[2]==0?-1:1;\\n            ch[start]+=add;\\n            if(end+1<ch.length)\\n                ch[end+1]-=add;\\n        }\\n        int sum=0;\\n        for(int i=0;i<ch.length;i++){\\n            sum+=ch[i];\\n            ch[i]=sum;\\n        }\\n        \\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            int shift=ch[i];\\n            if(shift>=0)\\n                shift=ch[i]%26;\\n            else\\n                shift=ch[i]%26+26;\\n            \\n            if(shift==0)\\n                sb.append(s.charAt(i));\\n            else {\\n                int diff = c + shift;\\n                if (diff < 123)\\n                    sb.append((char) diff);\\n                else\\n                    sb.append((char) (diff - 123 + \\'a\\'));\\n            }\\n\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086434,
                "title": "cpp-range-sum-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstring main=\"abcdefghijklmnopqrstuvwxyz\";\\nstd::map<char,int>char2intmap;\\nstd::map<int,char>int2charmap;\\n\\nchar shiftCharacter(char c, int shiftValue) {\\n    int newidx = char2intmap[c] + shiftValue;\\n    newidx = (newidx % 26 + 26) % 26;\\n    return int2charmap[newidx];\\n}\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\nfor(int i=0;i<main.length();i++)\\n{\\n    char2intmap[main[i]]=i;\\n    int2charmap[i]=main[i];\\n}\\n        vector<int>util;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            util.push_back(0);\\n        }\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                util[shifts[i][0]]+=1;\\n                if(shifts[i][1]+1<s.length())\\n                {\\n                    util[shifts[i][1]+1]-=1;\\n                }\\n            }\\n            else\\n            {\\n                 util[shifts[i][0]]-=1;\\n                if(shifts[i][1]+1<s.length())\\n                {\\n                    util[shifts[i][1]+1]+=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<s.length();i++)\\n        {\\n            util[i]+=util[i-1];\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            s[i]=shiftCharacter(s[i],util[i]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring main=\"abcdefghijklmnopqrstuvwxyz\";\\nstd::map<char,int>char2intmap;\\nstd::map<int,char>int2charmap;\\n\\nchar shiftCharacter(char c, int shiftValue) {\\n    int newidx = char2intmap[c] + shiftValue;\\n    newidx = (newidx % 26 + 26) % 26;\\n    return int2charmap[newidx];\\n}\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\nfor(int i=0;i<main.length();i++)\\n{\\n    char2intmap[main[i]]=i;\\n    int2charmap[i]=main[i];\\n}\\n        vector<int>util;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            util.push_back(0);\\n        }\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                util[shifts[i][0]]+=1;\\n                if(shifts[i][1]+1<s.length())\\n                {\\n                    util[shifts[i][1]+1]-=1;\\n                }\\n            }\\n            else\\n            {\\n                 util[shifts[i][0]]-=1;\\n                if(shifts[i][1]+1<s.length())\\n                {\\n                    util[shifts[i][1]+1]+=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<s.length();i++)\\n        {\\n            util[i]+=util[i-1];\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            s[i]=shiftCharacter(s[i],util[i]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969482,
                "title": "o-n-javascript-typescript-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst shiftingLetters = (s: string, shifts: number[][]): string => {\\n  const shiftTracker = new Array(s.length + 1).fill(0);\\n\\n  for (const [start, end, direction] of shifts) {\\n    const amount = direction ? 1 : -1;\\n    shiftTracker[start] += amount;\\n    shiftTracker[end + 1] -= amount;\\n  }\\n\\n  let afterShift = \"\";\\n  let toShift = 0;\\n  for (let i = 0; i < s.length; i++) {\\n    toShift += shiftTracker[i];\\n    const letterNum = (s[i].charCodeAt(0) - 97 + toShift) % 26;\\n    afterShift += String.fromCharCode(letterNum + (letterNum < 0 ? 123 : 97));\\n  }\\n\\n  return afterShift;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst shiftingLetters = (s: string, shifts: number[][]): string => {\\n  const shiftTracker = new Array(s.length + 1).fill(0);\\n\\n  for (const [start, end, direction] of shifts) {\\n    const amount = direction ? 1 : -1;\\n    shiftTracker[start] += amount;\\n    shiftTracker[end + 1] -= amount;\\n  }\\n\\n  let afterShift = \"\";\\n  let toShift = 0;\\n  for (let i = 0; i < s.length; i++) {\\n    toShift += shiftTracker[i];\\n    const letterNum = (s[i].charCodeAt(0) - 97 + toShift) % 26;\\n    afterShift += String.fromCharCode(letterNum + (letterNum < 0 ? 123 : 97));\\n  }\\n\\n  return afterShift;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938533,
                "title": "rust-solution-from-interval-tree-to-o-n-solution",
                "content": "# First Intuition\\nWe have to update a range so the first idea can be to use an interval tree that updates ranges (in `O(log(n))`) and gets a single value (also in `O(log(n)`)).\\n\\n# Approach\\nWe construct an interval tree and then update every range from `shifts`.\\n\\n# Notes\\nObviously, when `shifts[i][2]` is `0` we can treat it as `-1` but to avoid if statements (which are typically slower than arithmetic operations) we can multiply it by `2` and then subtract `1`\\n\\nSecondly, to handle wrapping we can simply do `v mod 26` (we count `a` as `0`, `b` as `1`, and so on). Unfortunately when we for example do `-3%26` we get `-3` instead of `23` to fix this we will do `((v%26) + 26)%26` which gives desired results.\\n\\n# Complexity\\n`n` - string length\\n`m` - shifts count\\n- Time complexity: `O(nlog(n) + mlog(n))`\\n  - Constructing tree O(n) - because of creating vector\\n  - Updating tree with every of m shifts in `O(log(n))` so it\\'s `O(mlog(n))`\\n  - Reading every of `n` values in `O(log(n))` and making computation in `O(1)` so it\\'s `O(nlog(n))`\\n- Space complexity: `O(n)`\\n  - Tree has at worst `2*n - 1` elements, so it\\'s `O(n)`\\n\\n# Code\\n```\\nstruct IntervalTree {\\n    data: Vec<i32>,\\n    offset: usize,\\n}\\n\\nimpl IntervalTree {\\n    pub fn new(n: usize) -> Self {\\n        let offset = (2usize).pow((n as f64).log2().ceil() as u32); // Calculating how many elements we need to construct binary tree (element at index 0 is never used, root is at 1)\\n        Self { data: vec![0; offset + n], offset: offset }\\n    }\\n\\n    pub fn update(&mut self, mut p: usize, mut q: usize, c: i32) {\\n        p += self.offset;\\n        q += self.offset;\\n        self.data[p] += c;\\n        if p == q {\\n            return;\\n        }\\n        self.data[q] += c;\\n        let mut is_p_left = p%2 == 0;\\n        let mut is_q_right = q%2 == 1;\\n        p /= 2;\\n        q /= 2;\\n        while p != q {\\n            if is_p_left {\\n                self.data[p*2 + 1] += c;\\n            }\\n            if is_q_right {\\n                self.data[q*2] += c;\\n            }\\n            is_p_left = p%2 == 0;\\n            is_q_right = q%2 == 1;\\n            p /= 2;\\n            q /= 2;\\n        }\\n    }\\n\\n    pub fn get_value(&self, mut i: usize) -> i32 {\\n        i += self.offset;\\n        let mut ans = 0;\\n        while i != 0 {\\n            ans += self.data[i];\\n            i /= 2;\\n        }\\n        ans\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn shifting_letters(mut s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let mut tree = IntervalTree::new(s.len());\\n        for shift in shifts {\\n            tree.update(shift[0] as usize, shift[1] as usize, shift[2] as i32 * 2 - 1);\\n        }\\n        unsafe {    // Code is unsafe because of as_bytes_mut() - but since we are ensured that input is only lowercase english alphabet everything is safe\\n            for (i, char) in s.as_bytes_mut().into_iter().enumerate() {\\n                *char = ((((*char as i32 - 97) + tree.get_value(i))%26 + 26)%26) as u8 + 97;\\n            }\\n        }\\n        s\\n    }\\n}\\n```\\n\\n# Observation\\nAdding any value to every value of any arbitrary range of whole numbers `[beg; end]` is the same as adding it to every value of `[beg; inf)` and subtracting from every value of `(end; inf)`\\n\\n\\n# Approach\\nWe create an `array` in which `array[i]` represents a value that should be added to `[i;inf)` and then we fill it with shifts.\\nFinally, we iterate over the whole string keeping track of the current prefix sum of the `array` and adding it to every element of the string (of course we still have to do some modulo operations).\\n\\nIn other words:\\n``\\ns[i] += prefix_sum_of_array[i]\\n``\\n``\\ns[i] = ((s[i]%26) + 26)%26\\n``\\n\\n# Complexity\\n`n` - string length\\n`m` - shifts count\\n- Time complexity: `O(n + m)`\\n  - Creating `array` `O(n)`\\n  - Filling `array` with every of `m` shifts in `O(1)` each, so it\\'s `O(m)`\\n  - Iterating over every of `n` element of string and applying changes `O(1)`, so it\\'s `O(n)`\\n\\n- Space complexity: `O(n)`\\n  - `array` has `n + 1` elements, so it\\'s `O(n)`\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn shifting_letters(mut s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let mut suffix_add = vec![0; s.len() + 1];\\n        for mut shift in shifts {\\n            shift[2] += shift[2] - 1;   // turning 0 into -1 (and leaving 1 as 1)\\n            suffix_add[shift[0] as usize] += shift[2];  // applying change for [beg;inf)\\n            suffix_add[shift[1] as usize + 1] -= shift[2];  // applying  reversed change for (end; inf)\\n        }\\n        unsafe {    // Code is unsafe because of as_bytes_mut() - but since we are ensured that input is only lowercase english alphabet everything is safe\\n            let s = s.as_bytes_mut();\\n            let mut it = suffix_add.into_iter();    // We create iterator over suffix_add but it would be perfectly fine to use additional variable to keep track of current position\\n            let mut n = it.next().unwrap();                     \\n            for byte in s {                                 // ^... or we can simply enumerate\\n                *byte = ((((*byte as i32 - 97) + n)%26 + 26)%26) as u8 + 97;    // Whole magic :-) (Notes)\\n                n += it.next().unwrap();\\n            }\\n        }\\n        s\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct IntervalTree {\\n    data: Vec<i32>,\\n    offset: usize,\\n}\\n\\nimpl IntervalTree {\\n    pub fn new(n: usize) -> Self {\\n        let offset = (2usize).pow((n as f64).log2().ceil() as u32); // Calculating how many elements we need to construct binary tree (element at index 0 is never used, root is at 1)\\n        Self { data: vec![0; offset + n], offset: offset }\\n    }\\n\\n    pub fn update(&mut self, mut p: usize, mut q: usize, c: i32) {\\n        p += self.offset;\\n        q += self.offset;\\n        self.data[p] += c;\\n        if p == q {\\n            return;\\n        }\\n        self.data[q] += c;\\n        let mut is_p_left = p%2 == 0;\\n        let mut is_q_right = q%2 == 1;\\n        p /= 2;\\n        q /= 2;\\n        while p != q {\\n            if is_p_left {\\n                self.data[p*2 + 1] += c;\\n            }\\n            if is_q_right {\\n                self.data[q*2] += c;\\n            }\\n            is_p_left = p%2 == 0;\\n            is_q_right = q%2 == 1;\\n            p /= 2;\\n            q /= 2;\\n        }\\n    }\\n\\n    pub fn get_value(&self, mut i: usize) -> i32 {\\n        i += self.offset;\\n        let mut ans = 0;\\n        while i != 0 {\\n            ans += self.data[i];\\n            i /= 2;\\n        }\\n        ans\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn shifting_letters(mut s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let mut tree = IntervalTree::new(s.len());\\n        for shift in shifts {\\n            tree.update(shift[0] as usize, shift[1] as usize, shift[2] as i32 * 2 - 1);\\n        }\\n        unsafe {    // Code is unsafe because of as_bytes_mut() - but since we are ensured that input is only lowercase english alphabet everything is safe\\n            for (i, char) in s.as_bytes_mut().into_iter().enumerate() {\\n                *char = ((((*char as i32 - 97) + tree.get_value(i))%26 + 26)%26) as u8 + 97;\\n            }\\n        }\\n        s\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn shifting_letters(mut s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let mut suffix_add = vec![0; s.len() + 1];\\n        for mut shift in shifts {\\n            shift[2] += shift[2] - 1;   // turning 0 into -1 (and leaving 1 as 1)\\n            suffix_add[shift[0] as usize] += shift[2];  // applying change for [beg;inf)\\n            suffix_add[shift[1] as usize + 1] -= shift[2];  // applying  reversed change for (end; inf)\\n        }\\n        unsafe {    // Code is unsafe because of as_bytes_mut() - but since we are ensured that input is only lowercase english alphabet everything is safe\\n            let s = s.as_bytes_mut();\\n            let mut it = suffix_add.into_iter();    // We create iterator over suffix_add but it would be perfectly fine to use additional variable to keep track of current position\\n            let mut n = it.next().unwrap();                     \\n            for byte in s {                                 // ^... or we can simply enumerate\\n                *byte = ((((*byte as i32 - 97) + n)%26 + 26)%26) as u8 + 97;    // Whole magic :-) (Notes)\\n                n += it.next().unwrap();\\n            }\\n        }\\n        s\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932589,
                "title": "scaline-algo-prefix-sum",
                "content": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        //using scaline algorithm\\n        int n = s.length();\\n        int [] dir = new int[n + 1];\\n        \\n        for(int [] shift : shifts){\\n            int i = shift[0];\\n            int j = shift[1];\\n            int move = (shift[2] == 0 ? -1 : 1);\\n            dir[i] += move;\\n            dir[j + 1] -= move;\\n        }\\n        \\n        //now take the prefix sums\\n        for(int i = 1; i < n + 1; i++){\\n            dir[i] += dir[i - 1];\\n        }\\n        \\n        char [] res = new char[n];\\n        \\n        for(int i = 0; i < n; i++){\\n            int idx = (s.charAt(i) - \\'a\\' + dir[i]) % 26;\\n            if(idx < 0){\\n                idx += 26;\\n            }\\n            \\n           char newCh = (char)(idx + \\'a\\'); \\n            res[i] = newCh;\\n        }\\n        \\n        return new String(res);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        //using scaline algorithm\\n        int n = s.length();\\n        int [] dir = new int[n + 1];\\n        \\n        for(int [] shift : shifts){\\n            int i = shift[0];\\n            int j = shift[1];\\n            int move = (shift[2] == 0 ? -1 : 1);\\n            dir[i] += move;\\n            dir[j + 1] -= move;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3899045,
                "title": "c-clearly-explained-maintaining-ranges",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // O(s.length() * shifts.length())  Brute Force....\\n        // We can optimmize thiis s.length() part, try and remove this\\n        // Preprocess the shifts...\\n        // arr of length of string + bookeeping in array = [{+|- freq},......]\\n        // +, - signifying forward or backward shifts\\n        // Go through the array uppdating the string ans. \\n        vector<int> bookeeping(s.length() + 1, 0);\\n        for(int i=0;i<shifts.size();i++){\\n          bool isfrwrd = shifts[i][2] == 1 ? true : false;\\n          if(isfrwrd){\\n            bookeeping[shifts[i][0]] += 1;\\n            bookeeping[shifts[i][1] + 1] -= 1; \\n          }else{\\n            bookeeping[shifts[i][0]] -= 1;\\n            bookeeping[shifts[i][1] + 1] += 1; \\n          }\\n        }\\n        int running = 0;\\n        for(int i=0;i<s.length();i++){\\n          int k = bookeeping[i]%26;\\n          running += k;\\n          running %= 26;\\n          int newVar = running + (s[i] - \\'a\\'); // New position of the updated character\\n          newVar = (newVar + 26)%26; // Handle Negatives..... \\n          s[i] = newVar + \\'a\\'; \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // O(s.length() * shifts.length())  Brute Force....\\n        // We can optimmize thiis s.length() part, try and remove this\\n        // Preprocess the shifts...\\n        // arr of length of string + bookeeping in array = [{+|- freq},......]\\n        // +, - signifying forward or backward shifts\\n        // Go through the array uppdating the string ans. \\n        vector<int> bookeeping(s.length() + 1, 0);\\n        for(int i=0;i<shifts.size();i++){\\n          bool isfrwrd = shifts[i][2] == 1 ? true : false;\\n          if(isfrwrd){\\n            bookeeping[shifts[i][0]] += 1;\\n            bookeeping[shifts[i][1] + 1] -= 1; \\n          }else{\\n            bookeeping[shifts[i][0]] -= 1;\\n            bookeeping[shifts[i][1] + 1] += 1; \\n          }\\n        }\\n        int running = 0;\\n        for(int i=0;i<s.length();i++){\\n          int k = bookeeping[i]%26;\\n          running += k;\\n          running %= 26;\\n          int newVar = running + (s[i] - \\'a\\'); // New position of the updated character\\n          newVar = (newVar + 26)%26; // Handle Negatives..... \\n          s[i] = newVar + \\'a\\'; \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881792,
                "title": "c-simple-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a)\\n    {\\n        int n=s.size();\\n        vector<int>v(n+1,0);\\n        for(auto &x:a)\\n        {\\n            v[x[0]]+=(x[2]==1)?1:-1;\\n            v[x[1]+1]+=(x[2]==1)?-1:1;\\n            v[x[0]]=(v[x[0]]+26)%26;\\n            v[x[1]+1]=(v[x[1]+1]+26)%26;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i]+=(i>0)?v[i-1]:0;\\n            s[i]=\\'a\\'+((s[i]-\\'a\\')+v[i])%26;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a)\\n    {\\n        int n=s.size();\\n        vector<int>v(n+1,0);\\n        for(auto &x:a)\\n        {\\n            v[x[0]]+=(x[2]==1)?1:-1;\\n            v[x[1]+1]+=(x[2]==1)?-1:1;\\n            v[x[0]]=(v[x[0]]+26)%26;\\n            v[x[1]+1]=(v[x[1]+1]+26)%26;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i]+=(i>0)?v[i-1]:0;\\n            s[i]=\\'a\\'+((s[i]-\\'a\\')+v[i])%26;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847262,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n       int n=s.size();\\n       vector<int>temp(n,0);\\n       for (auto it:shifts)\\n       {\\n           if (it[2]==0)\\n           {\\n             temp[it[0]]-=1;\\n             if (it[1]+1<n) temp[it[1]+1]+=1;\\n           }\\n           else\\n           {\\n               temp[it[0]]+=1;\\n             if (it[1]+1<n) temp[it[1]+1]-=1;\\n           }\\n       }\\n       string ans=\"\";\\n       int sum=0;\\n       for (int i=0;i<n;i++)\\n       {\\n           sum+=temp[i];\\n           sum=(sum+26)%26;\\n           int val=((s[i]-\\'a\\')+sum+26)%26;\\n           char ch=\\'a\\'+val;\\n           ans.push_back(ch);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n       int n=s.size();\\n       vector<int>temp(n,0);\\n       for (auto it:shifts)\\n       {\\n           if (it[2]==0)\\n           {\\n             temp[it[0]]-=1;\\n             if (it[1]+1<n) temp[it[1]+1]+=1;\\n           }\\n           else\\n           {\\n               temp[it[0]]+=1;\\n             if (it[1]+1<n) temp[it[1]+1]-=1;\\n           }\\n       }\\n       string ans=\"\";\\n       int sum=0;\\n       for (int i=0;i<n;i++)\\n       {\\n           sum+=temp[i];\\n           sum=(sum+26)%26;\\n           int val=((s[i]-\\'a\\')+sum+26)%26;\\n           char ch=\\'a\\'+val;\\n           ans.push_back(ch);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835782,
                "title": "prefix-sum-python-97-in-runtime-98-in-space",
                "content": "# Intuition\\nFor each shift operation, the direct way is to shift all the chars in the range one by one. However, when the range is large, this brute force method is too slow. A better way is to calculated the cumulative shifts for each char first and then shift each char only once. To do this in an efficient way, we need to maintain an array `cnt` with the same length as `s`\\uFF0Cthen for the shift [start,end,direction], we should first transform direction into $\\\\pm 1$\\uFF0Cthen add `direction` to `cnt[start]` and substract it from `cnt[end+1]`. Finally, calculate the cumulative sums of `cnt` and they are just the cumulative shift distance for each char.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        base = ord(\"a\")\\n        s_int = [ord(c)-base for c in s]\\n        cnt = [0] * len(s)\\n        for start,end,direction in shifts:\\n            direction = 2*direction - 1\\n            cnt[start] += direction\\n            if end < len(s)-1:\\n                cnt[end+1] -= direction\\n        delta = cnt[0]\\n        s_int[0] = (s_int[0] + delta) % 26\\n        for i in range(1,len(cnt)):\\n            delta = (delta + cnt[i]) % 26\\n            s_int[i] = (s_int[i] + delta) % 26\\n        return \"\".join([chr(i+base) for i in s_int])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        base = ord(\"a\")\\n        s_int = [ord(c)-base for c in s]\\n        cnt = [0] * len(s)\\n        for start,end,direction in shifts:\\n            direction = 2*direction - 1\\n            cnt[start] += direction\\n            if end < len(s)-1:\\n                cnt[end+1] -= direction\\n        delta = cnt[0]\\n        s_int[0] = (s_int[0] + delta) % 26\\n        for i in range(1,len(cnt)):\\n            delta = (delta + cnt[i]) % 26\\n            s_int[i] = (s_int[i] + delta) % 26\\n        return \"\".join([chr(i+base) for i in s_int])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814493,
                "title": "easiest-difference-array",
                "content": "# Intuition\\nWe can maintain an array which keeps track of the total positive and negative shift of each char in s. But that would take $$O(n\\xB2)$$ complexity. We need to use a difference array to reduce the time complexity. Difference array is kind of the reverse of presum array, and you can do further research on it before attempting this question, it is a classic range-update query algorithm. \\n\\n# Approach\\nWe traverse through shifts and appropriately update our difference array. Then we use a variable sum to gather the presum of this difference array(hint:The presum at each index is the change/shift for that index). Next, we calculate how the char is turned due to the change, and finally we update the characters one by one.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ we traverse the shifts array and the difference array which is linear complexity.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ extra space for difference array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string &s, vector<vector<int>>& shifts) {\\n        int n=s.size(),sum=0,turn;\\n        vector<int> dif(n+1);\\n        for(auto &u:shifts){\\n            if(u[2]&1) dif[u[0]]++,dif[u[1]+1]--; \\n            else   dif[u[0]]-- ,  dif[u[1]+1]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            sum = (sum+dif[i])%26;\\n            turn =s[i]-\\'a\\'+sum+26;\\n            s[i] = \\'a\\' + turn %26;\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n*__UPVOTE IF EASY__*",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string &s, vector<vector<int>>& shifts) {\\n        int n=s.size(),sum=0,turn;\\n        vector<int> dif(n+1);\\n        for(auto &u:shifts){\\n            if(u[2]&1) dif[u[0]]++,dif[u[1]+1]--; \\n            else   dif[u[0]]-- ,  dif[u[1]+1]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            sum = (sum+dif[i])%26;\\n            turn =s[i]-\\'a\\'+sum+26;\\n            s[i] = \\'a\\' + turn %26;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778541,
                "title": "c-line-sweep-easy-solution",
                "content": "# Approach\\nStore the contribution of each index using line sweep and then update each character in final string.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> vec(n+1);\\n        for(auto &i:shifts)\\n        {\\n            int dir = i[2];\\n            if(dir==0)\\n            dir = -1;\\n            vec[i[0]] = (vec[i[0]]+dir+26)%26;\\n            vec[i[1]+1] = (vec[i[1]+1]-dir+26)%26;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        vec[i]+=vec[i-1];\\n        for(int i=0;i<n+1;i++)\\n        vec[i]%=26;\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i] = (((s[i]-\\'a\\')+vec[i])%26)+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Line Sweep",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> vec(n+1);\\n        for(auto &i:shifts)\\n        {\\n            int dir = i[2];\\n            if(dir==0)\\n            dir = -1;\\n            vec[i[0]] = (vec[i[0]]+dir+26)%26;\\n            vec[i[1]+1] = (vec[i[1]+1]-dir+26)%26;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        vec[i]+=vec[i-1];\\n        for(int i=0;i<n+1;i++)\\n        vec[i]%=26;\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i] = (((s[i]-\\'a\\')+vec[i])%26)+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774892,
                "title": "line-sweep-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    char findS(char c,int ct){\\n        int idx = c-\\'a\\';\\n        int pos = (26+idx+ct)%26;\\n        return \\'a\\'+pos;\\n    }\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> vec(n+1,0);\\n        \\n        for(auto it:shifts){\\n            if(it[2]){\\n                vec[it[0]]++;\\n                vec[it[1]+1]--;\\n            }\\n            else{\\n                vec[it[0]]--;\\n                vec[it[1]+1]++;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            int dir = vec[i]%26;\\n            ct = (ct + dir) % 26;\\n            char ch = findS(s[i],ct);\\n            s[i] = ch;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char findS(char c,int ct){\\n        int idx = c-\\'a\\';\\n        int pos = (26+idx+ct)%26;\\n        return \\'a\\'+pos;\\n    }\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> vec(n+1,0);\\n        \\n        for(auto it:shifts){\\n            if(it[2]){\\n                vec[it[0]]++;\\n                vec[it[1]+1]--;\\n            }\\n            else{\\n                vec[it[0]]--;\\n                vec[it[1]+1]++;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            int dir = vec[i]%26;\\n            ct = (ct + dir) % 26;\\n            char ch = findS(s[i],ct);\\n            s[i] = ch;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742530,
                "title": "most-smallest-code-i-bet-you-will-not-understand-last-line-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        //AUTHOR :: MOHD FAISAL FROM INDIA\\n        int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==0)v[shifts[i][0]]--,v[shifts[i][1]+1]++;\\n            else v[shifts[i][0]]++,v[shifts[i][1]+1]--;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i]=char(\\'a\\'+int((s[i]-\\'a\\'+(sum+=v[i])%26+26)%26));\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        //AUTHOR :: MOHD FAISAL FROM INDIA\\n        int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==0)v[shifts[i][0]]--,v[shifts[i][1]+1]++;\\n            else v[shifts[i][0]]++,v[shifts[i][1]+1]--;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i]=char(\\'a\\'+int((s[i]-\\'a\\'+(sum+=v[i])%26+26)%26));\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593600,
                "title": "o-n-time-and-space",
                "content": "# Intuition\\nSweep line\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n=len(s)\\n        delta = [0]*(n+1)\\n        for start, end, direction in shifts:\\n            delta[start] += 1 if direction==1 else -1\\n            delta[end+1] -= 1 if direction==1 else -1\\n\\n        res = []\\n        for i in range(n):\\n            if i:delta[i]+=delta[i-1]\\n            res.append(chr((ord(s[i]) - ord(\"a\") + delta[i]) % 26 + ord(\"a\")))\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n=len(s)\\n        delta = [0]*(n+1)\\n        for start, end, direction in shifts:\\n            delta[start] += 1 if direction==1 else -1\\n            delta[end+1] -= 1 if direction==1 else -1\\n\\n        res = []\\n        for i in range(n):\\n            if i:delta[i]+=delta[i-1]\\n            res.append(chr((ord(s[i]) - ord(\"a\") + delta[i]) % 26 + ord(\"a\")))\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567965,
                "title": "prefix-sum-solution-with-explanation-easy-to-understand",
                "content": "# Intuition\\nAt first we see that we have to print the final string after performing all operation so we can perform operation at a time we don\\'t need to perform every time to do this we can use prefix sum technique to store how many time a operation perform in an index\\n\\n# Approach\\nTo solve this problem, we can declare two array one for forwad direction another for backward direction in those array we mark the starting index and ending index of every operation to do this we have to increase the array value in starting index of an operation and decrease the value for ending index then in those array we can do prefix sum after that we just travers every index and see how many time we have to do forward operation and backward we simply perform those operation in that index\\n\\n# Complexity\\n- Time complexity:\\nO(max(string size,shifts size))\\n\\n- Space complexity:\\nO(max(string size,shifts size))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        int m=shifts.size();\\n        int prefixFor[n+1],prefixBck[n+1];\\n        memset(prefixFor,0,sizeof(prefixFor));\\n        memset(prefixBck,0,sizeof(prefixBck));\\n        for(int i=0;i<m;i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                prefixFor[shifts[i][0]]++;\\n                prefixFor[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                prefixBck[shifts[i][0]]++;\\n                prefixBck[shifts[i][1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            prefixFor[i]+=prefixFor[i-1];\\n            prefixBck[i]+=prefixBck[i-1];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int forwardDir=prefixFor[i]%26,backwardDir=prefixBck[i]%26;\\n            int finall=((s[i]-\\'a\\')+forwardDir-backwardDir+26)%26;\\n            s[i]=(finall+\\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        int m=shifts.size();\\n        int prefixFor[n+1],prefixBck[n+1];\\n        memset(prefixFor,0,sizeof(prefixFor));\\n        memset(prefixBck,0,sizeof(prefixBck));\\n        for(int i=0;i<m;i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                prefixFor[shifts[i][0]]++;\\n                prefixFor[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                prefixBck[shifts[i][0]]++;\\n                prefixBck[shifts[i][1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            prefixFor[i]+=prefixFor[i-1];\\n            prefixBck[i]+=prefixBck[i-1];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int forwardDir=prefixFor[i]%26,backwardDir=prefixBck[i]%26;\\n            int finall=((s[i]-\\'a\\')+forwardDir-backwardDir+26)%26;\\n            s[i]=(finall+\\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566455,
                "title": "c-prefix-sum-faster-easy-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& vec) {\\n        int n=s.size();\\n        int ar[n+5];\\n        for(int i=0;i<=n;i++)ar[i]=0;\\n        for(auto x:vec)\\n        {\\n            int a=x[0];\\n            int b=x[1];\\n            int c=x[2];\\n            if(c==0)\\n            {\\n                ar[a]--;\\n                ar[b+1]++;\\n            }\\n            else \\n            {\\n                ar[a]++;\\n                ar[b+1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++)ar[i]+=ar[i-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=s[i]-\\'a\\';\\n            x=(x+26+(ar[i]%26))%26;\\n            x+=97;\\n            s[i]=char(x);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& vec) {\\n        int n=s.size();\\n        int ar[n+5];\\n        for(int i=0;i<=n;i++)ar[i]=0;\\n        for(auto x:vec)\\n        {\\n            int a=x[0];\\n            int b=x[1];\\n            int c=x[2];\\n            if(c==0)\\n            {\\n                ar[a]--;\\n                ar[b+1]++;\\n            }\\n            else \\n            {\\n                ar[a]++;\\n                ar[b+1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++)ar[i]+=ar[i-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=s[i]-\\'a\\';\\n            x=(x+26+(ar[i]%26))%26;\\n            x+=97;\\n            s[i]=char(x);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553363,
                "title": "rust-diff-array-and-prefix-o-n-solution-100",
                "content": "# Intuition\\n\\nOriginal array is the prefix sum of it\\'s diff array.\\nif you want to update range from [a, b] to some value -\\nupdate diff[a] += val and diff[b + 1] -= val, then build the prefix sum and convert indexes to chars\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn shifting_letters(s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let letters = (\\'a\\'..=\\'z\\').collect::<Vec<_>>();\\n        let s = s.chars().map(|x| x as i32 - \\'a\\' as i32).collect::<Vec<_>>();\\n\\n        let mut diff = vec![s[0]];\\n        for i in 1..s.len() {\\n            diff.push(s[i] - s[i - 1]);\\n        }\\n        let n = diff.len();\\n\\n        for sh in shifts {\\n            let (left, right, val) = (\\n                sh[0] as usize,\\n                sh[1] as usize,\\n                if sh[2] == 0 { -1 } else { 1 },\\n            );\\n            diff[left] += val;\\n            diff[left] %= 26;\\n            if right + 1 < n {\\n                diff[right + 1] -= val;\\n                diff[right] %= 26;\\n            }\\n        }\\n        // converting to prefix sum, e.g. new original array\\n        for i in 1..n {\\n            diff[i] += diff[i - 1] % 26;\\n            diff[i] %= 26;\\n        }\\n        \\n        diff.into_iter()\\n            .map(|x| letters[((x + 26) % 26) as usize])\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn shifting_letters(s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let letters = (\\'a\\'..=\\'z\\').collect::<Vec<_>>();\\n        let s = s.chars().map(|x| x as i32 - \\'a\\' as i32).collect::<Vec<_>>();\\n\\n        let mut diff = vec![s[0]];\\n        for i in 1..s.len() {\\n            diff.push(s[i] - s[i - 1]);\\n        }\\n        let n = diff.len();\\n\\n        for sh in shifts {\\n            let (left, right, val) = (\\n                sh[0] as usize,\\n                sh[1] as usize,\\n                if sh[2] == 0 { -1 } else { 1 },\\n            );\\n            diff[left] += val;\\n            diff[left] %= 26;\\n            if right + 1 < n {\\n                diff[right + 1] -= val;\\n                diff[right] %= 26;\\n            }\\n        }\\n        // converting to prefix sum, e.g. new original array\\n        for i in 1..n {\\n            diff[i] += diff[i - 1] % 26;\\n            diff[i] %= 26;\\n        }\\n        \\n        diff.into_iter()\\n            .map(|x| letters[((x + 26) % 26) as usize])\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3538804,
                "title": "segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    String str;\\n    int [] tree;\\n    int []moves;\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        tree=new int [s.length()*4];\\n        moves=new int[s.length()-1];\\n        for(int []arr:shifts)\\n            if(arr[2]!=1)\\n                update(0,s.length()-1,0,arr[0],arr[1],-1);\\n            else\\n                update(0,s.length()-1,0,arr[0],arr[1],1);\\n        char [] arr=s.toCharArray();\\n        int range = 26;\\n        for(int i=0; i<s.length();i++){\\n            int value=query(0,s.length()-1,0,i);\\n            int currentOffset = arr[i] - \\'a\\';\\n            int newOffset = (currentOffset + value%26+range) % range;  \\n            arr[i] = (char) (\\'a\\' + newOffset);\\n        }\\n\\n        return String.valueOf(arr);\\n\\n\\n        \\n    }\\n    void update(int leftB, int rightB, int index, int l, int r,int sign)\\n    {\\n        int [] arr=tree;\\n        int mid=(leftB+rightB)/2;\\n        if(l>rightB||leftB>r)\\n            return;\\n        if(l<=leftB&&r>=rightB)\\n            tree[index]+=sign;\\n        else{\\n            update(leftB,mid,index*2+1,l,r,sign);\\n            update(mid+1,rightB,index*2+2,l,r,sign);\\n        }\\n    }\\n    int query(int leftB, int rightB, int ti,int index)\\n    {\\n        int []arr=tree;\\n        int mid=(leftB+rightB)/2;\\n        if(index>rightB||index<leftB)\\n            return 0;\\n        if(leftB==rightB)\\n            return tree[ti];\\n        return tree[ti]+query(leftB,mid,ti*2+1,index)+query(mid+1,rightB,ti*2+2,index);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String str;\\n    int [] tree;\\n    int []moves;\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        tree=new int [s.length()*4];\\n        moves=new int[s.length()-1];\\n        for(int []arr:shifts)\\n            if(arr[2]!=1)\\n                update(0,s.length()-1,0,arr[0],arr[1],-1);\\n            else\\n                update(0,s.length()-1,0,arr[0],arr[1],1);\\n        char [] arr=s.toCharArray();\\n        int range = 26;\\n        for(int i=0; i<s.length();i++){\\n            int value=query(0,s.length()-1,0,i);\\n            int currentOffset = arr[i] - \\'a\\';\\n            int newOffset = (currentOffset + value%26+range) % range;  \\n            arr[i] = (char) (\\'a\\' + newOffset);\\n        }\\n\\n        return String.valueOf(arr);\\n\\n\\n        \\n    }\\n    void update(int leftB, int rightB, int index, int l, int r,int sign)\\n    {\\n        int [] arr=tree;\\n        int mid=(leftB+rightB)/2;\\n        if(l>rightB||leftB>r)\\n            return;\\n        if(l<=leftB&&r>=rightB)\\n            tree[index]+=sign;\\n        else{\\n            update(leftB,mid,index*2+1,l,r,sign);\\n            update(mid+1,rightB,index*2+2,l,r,sign);\\n        }\\n    }\\n    int query(int leftB, int rightB, int ti,int index)\\n    {\\n        int []arr=tree;\\n        int mid=(leftB+rightB)/2;\\n        if(index>rightB||index<leftB)\\n            return 0;\\n        if(leftB==rightB)\\n            return tree[ti];\\n        return tree[ti]+query(leftB,mid,ti*2+1,index)+query(mid+1,rightB,ti*2+2,index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538286,
                "title": "line-sweep-algorithm-solution-c-best-approach-for-this-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> line(n+1,0);\\n        for(int i=0;i<shifts.size();i++){\\n            int a = shifts[i][0];\\n            int b = shifts[i][1];\\n            int direction = shifts[i][2];\\n            if(direction == 1){\\n                //move forward\\n                line[a]++;\\n                line[b+1]--;\\n            }\\n            else if(direction == 0){\\n                //move backward\\n                line[a]--;\\n                line[b+1]++;\\n            }\\n        }\\n        string a = \"\";\\n        //line sweep algorithm great \\n        cout<<endl;\\n        int currentsum = 0;\\n        for(int i=0;i<n;i++){\\n            currentsum = currentsum + line[i];\\n            if(currentsum >= 0){\\n            char c = ((s[i]-\\'a\\' + currentsum)%26) + \\'a\\';\\n                a+=c;\\n            }\\n            else if(currentsum < 0){\\n                int ass = s[i]-\\'a\\' + currentsum;\\n                while(ass<0){\\n                    ass+=26;\\n                }\\n                char c = ass + \\'a\\';\\n                a+=c;\\n\\n            }\\n        }\\n        return a;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> line(n+1,0);\\n        for(int i=0;i<shifts.size();i++){\\n            int a = shifts[i][0];\\n            int b = shifts[i][1];\\n            int direction = shifts[i][2];\\n            if(direction == 1){\\n                //move forward\\n                line[a]++;\\n                line[b+1]--;\\n            }\\n            else if(direction == 0){\\n                //move backward\\n                line[a]--;\\n                line[b+1]++;\\n            }\\n        }\\n        string a = \"\";\\n        //line sweep algorithm great \\n        cout<<endl;\\n        int currentsum = 0;\\n        for(int i=0;i<n;i++){\\n            currentsum = currentsum + line[i];\\n            if(currentsum >= 0){\\n            char c = ((s[i]-\\'a\\' + currentsum)%26) + \\'a\\';\\n                a+=c;\\n            }\\n            else if(currentsum < 0){\\n                int ass = s[i]-\\'a\\' + currentsum;\\n                while(ass<0){\\n                    ass+=26;\\n                }\\n                char c = ass + \\'a\\';\\n                a+=c;\\n\\n            }\\n        }\\n        return a;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3490375,
                "title": "translate-lachezartsk-s-javascript-to-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI simply translated LachezarTsK\\'s approach from JavaScript to TypeScript.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nThe code first defines a constant called ALPHABET_SIZE which is the number of letters in the alphabet (26). It also defines a constant called ASCII_SMALL_CASE_A which is the ASCII code for the letter \\'a\\' (97).\\n\\nNext, the code defines an array called totalShifts. This array will be used to store the total number of shifts that have been applied to each letter in the input string. The array is initialized to all zeros.\\n\\nThe next loop iterates through the shifts array. The shifts array is an array of arrays. Each inner array contains three elements: the start index, the end index, and the shift amount.\\n\\nFor each inner array, the code adds the shift amount to the totalShifts array at the start index. It then subtracts the shift amount from the totalShifts array at the end index + 1.\\n\\nNext, the code defines an array called shiftedLetters. This array will be used to store the shifted letters of the input string. The array is initialized to be the same as the input string.\\n\\nThe next loop iterates through the shiftedLetters array. For each letter, the code calculates the new position of the letter by adding the total shift for that letter to the original position of the letter. The code then uses the String.fromCodePoint() function to convert the new position to a letter.\\n\\nThe final step is to join the shiftedLetters array together to form a string. The code then returns the string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is $$O(n)$$. This is because the code iterates through the shifts array once, and the input and shiftedLetters arrays twice. The number of iterations is proportional to the length of the input string.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity is $$O(n)$$, where n is the length of the input string. This is because the code only needs to store the input string, the totalShifts array, and the shiftedLetters array. The size of these arrays is proportional to the length of the input string.\\n\\n\\n# Code\\n```\\nfunction shiftingLetters(input: string, shifts: number[][]): string {\\n  const ALPHABET_SIZE = 26;\\n  const ASCII_SMALL_CASE_A = 97;\\n  const totalShifts = new Array(input.length + 1).fill(0);\\n\\n  for (let shift of shifts) {\\n    const change = (shift[2] === 1) ? 1 : -1;\\n    totalShifts[shift[0]] += change;\\n    totalShifts[shift[1] + 1] -= change;\\n  }\\n\\n  let shiftedLetters = input.split(\\'\\');\\n  for (let i = 0; i < input.length; ++i) {\\n    const currentShift = (input.codePointAt(i) - ASCII_SMALL_CASE_A + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                             % ALPHABET_SIZE;\\n    shiftedLetters[i] = String.fromCodePoint(currentShift + ASCII_SMALL_CASE_A);\\n    totalShifts[i + 1] += totalShifts[i];\\n  }\\n\\n  return shiftedLetters.join(\\'\\');\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction shiftingLetters(input: string, shifts: number[][]): string {\\n  const ALPHABET_SIZE = 26;\\n  const ASCII_SMALL_CASE_A = 97;\\n  const totalShifts = new Array(input.length + 1).fill(0);\\n\\n  for (let shift of shifts) {\\n    const change = (shift[2] === 1) ? 1 : -1;\\n    totalShifts[shift[0]] += change;\\n    totalShifts[shift[1] + 1] -= change;\\n  }\\n\\n  let shiftedLetters = input.split(\\'\\');\\n  for (let i = 0; i < input.length; ++i) {\\n    const currentShift = (input.codePointAt(i) - ASCII_SMALL_CASE_A + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                             % ALPHABET_SIZE;\\n    shiftedLetters[i] = String.fromCodePoint(currentShift + ASCII_SMALL_CASE_A);\\n    totalShifts[i + 1] += totalShifts[i];\\n  }\\n\\n  return shiftedLetters.join(\\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3457566,
                "title": "prefix-sum-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        int n=s.size();\\n        vector<int> v(n+1,0);\\n        for(int x=0; x<shifts.size(); x++)\\n        {\\n            int st=shifts[x][0], en=shifts[x][1], forward=shifts[x][2];\\n            if(forward)\\n            {\\n                v[st]++;\\n                v[en+1]--;\\n            }\\n            else\\n            {\\n                v[st]--;\\n                v[en+1]++;\\n            }\\n        }\\n        v[0]=(v[0]%26+26)%26;\\n        for(int x=1; x<n+1; x++) v[x]=(v[x-1]+v[x]%26+26)%26;\\n        for(auto it: v) cout<<it<<\" \";\\n        cout<<endl;\\n        for(int x=0; x<n; x++)\\n        {\\n            for(int y=1; y<=v[x]; y++)\\n            {\\n                if(s[x]==\\'z\\')\\n                {\\n                    s[x]=\\'a\\';\\n                    continue;\\n                }\\n                s[x]++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        int n=s.size();\\n        vector<int> v(n+1,0);\\n        for(int x=0; x<shifts.size(); x++)\\n        {\\n            int st=shifts[x][0], en=shifts[x][1], forward=shifts[x][2];\\n            if(forward)\\n            {\\n                v[st]++;\\n                v[en+1]--;\\n            }\\n            else\\n            {\\n                v[st]--;\\n                v[en+1]++;\\n            }\\n        }\\n        v[0]=(v[0]%26+26)%26;\\n        for(int x=1; x<n+1; x++) v[x]=(v[x-1]+v[x]%26+26)%26;\\n        for(auto it: v) cout<<it<<\" \";\\n        cout<<endl;\\n        for(int x=0; x<n; x++)\\n        {\\n            for(int y=1; y<=v[x]; y++)\\n            {\\n                if(s[x]==\\'z\\')\\n                {\\n                    s[x]=\\'a\\';\\n                    continue;\\n                }\\n                s[x]++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3393419,
                "title": "line-sweep",
                "content": "**time: `O(N+S)`; space: `O(S)`**\\n```\\nstring shiftingLetters(string s, vector<vector<int>>& x)\\n{\\n\\tint d[50001]{};\\n\\tfor(const auto & x : x)\\n\\t\\td[x[0]]+=2*x[2]-1, d[x[1]+1]-=2*x[2]-1;\\n\\n\\tfor(int t{}, i{}; i<size(s); ++i)          \\n\\t\\ts[i]=\\'a\\'+(s[i]+(t+=d[i])+2600000-\\'a\\')%26;\\n\\treturn s;\\n}\\n```\\n**Similar problems:**\\n[2406. Divide Intervals Into Minimum Number of Groups](https://leetcode.com/problems/divide-intervals-into-minimum-number-of-groups/discuss/3393422/line-sweep)\\n[2381. Shifting Letters II](https://leetcode.com/problems/shifting-letters-ii/discuss/3393419/line-sweep)\\n[1943. Describe the Painting](https://leetcode.com/problems/describe-the-painting/discuss/3387661/line-sweep)\\n[253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/discuss/2115681/few-solutions)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring shiftingLetters(string s, vector<vector<int>>& x)\\n{\\n\\tint d[50001]{};\\n\\tfor(const auto & x : x)\\n\\t\\td[x[0]]+=2*x[2]-1, d[x[1]+1]-=2*x[2]-1;\\n\\n\\tfor(int t{}, i{}; i<size(s); ++i)          \\n\\t\\ts[i]=\\'a\\'+(s[i]+(t+=d[i])+2600000-\\'a\\')%26;\\n\\treturn s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3388373,
                "title": "c-accumulate-line-sweep",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> sf(s.size(), 0);\\n        for(int i = 0; i < shifts.size(); i++){\\n            if(shifts[i][2] == 1){\\n                sf[shifts[i][0]]++;\\n                if(shifts[i][1] < s.size()-1)\\n                    sf[shifts[i][1]+1]--;\\n            }\\n            else if(shifts[i][2] == 0){\\n                sf[shifts[i][0]]--;\\n                if(shifts[i][1] < s.size()-1)\\n                    sf[shifts[i][1]+1]++;\\n            }\\n        }\\n        for(int i = 1; i < sf.size(); i++) sf[i] += sf[i-1];\\n        for(int i = 0; i < s.size(); i++){\\n            int val = s[i] - \\'a\\' + sf[i];\\n            while(val < 0) val += 26;\\n            val = val % 26;\\n            s[i] = val + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> sf(s.size(), 0);\\n        for(int i = 0; i < shifts.size(); i++){\\n            if(shifts[i][2] == 1){\\n                sf[shifts[i][0]]++;\\n                if(shifts[i][1] < s.size()-1)\\n                    sf[shifts[i][1]+1]--;\\n            }\\n            else if(shifts[i][2] == 0){\\n                sf[shifts[i][0]]--;\\n                if(shifts[i][1] < s.size()-1)\\n                    sf[shifts[i][1]+1]++;\\n            }\\n        }\\n        for(int i = 1; i < sf.size(); i++) sf[i] += sf[i-1];\\n        for(int i = 0; i < s.size(); i++){\\n            int val = s[i] - \\'a\\' + sf[i];\\n            while(val < 0) val += 26;\\n            val = val % 26;\\n            s[i] = val + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345046,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n          int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int l=shifts[i][0];\\n            int r=shifts[i][1];\\n            if(shifts[i][2]==0){\\n                v[l]--;\\n                v[r+1]++;\\n            }\\n            else{\\n                v[l]++;\\n                v[r+1]--;\\n            }\\n        }\\n    \\n        for(int i=0;i<n;i++){\\n            sum+=v[i];\\n            int k=sum%26;\\n            int p=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p);\\n        }\\n        return s;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n          int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int l=shifts[i][0];\\n            int r=shifts[i][1];\\n            if(shifts[i][2]==0){\\n                v[l]--;\\n                v[r+1]++;\\n            }\\n            else{\\n                v[l]++;\\n                v[r+1]--;\\n            }\\n        }\\n    \\n        for(int i=0;i<n;i++){\\n            sum+=v[i];\\n            int k=sum%26;\\n            int p=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p);\\n        }\\n        return s;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310229,
                "title": "c-golang-prefix-sum",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<int> prefix(n, 0);\\n        for(vector<int> shift: shifts) {\\n            prefix[shift[0]] += (shift[2] == 1? 1: -1);\\n            if(shift[1] + 1 < n)\\n                prefix[shift[1] + 1] -= (shift[2] == 1? 1: -1);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            prefix[i] = (prefix[i] + (i > 0? prefix[i - 1]: 0)) % 26;\\n            int val = s[i] + prefix[i];\\n            val -= val > \\'z\\'? 26: 0;\\n            val += val < \\'a\\'? 26: 0;\\n            s[i] = val;\\n        }\\n        return s;\\n    }\\n};\\n\\n\\n// Golang\\nfunc shiftingLetters(s string, shifts [][]int) string {\\n    var n int = len(s)\\n    prefix := make([]int, n)\\n    for _, shift := range shifts {\\n        val := -1\\n        if shift[2] == 1 { val = 1 }\\n        prefix[shift[0]] += val\\n        if shift[1] + 1 < n {\\n            prefix[shift[1] + 1] -= val\\n        }\\n    }\\n    prefix[0] %= 26\\n    b := make([]byte, n)\\n    for i := 0; i < n; i++ {\\n        if i > 0 {\\n             prefix[i] = (prefix[i] + prefix[i - 1]) % 26\\n        }\\n        var val int = int(s[i]) + prefix[i]\\n        if val > \\'z\\' {val -= 26}\\n        if val < \\'a\\' {val += 26}\\n        b[i] = byte(val)\\n    }\\n    return string(b)\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<int> prefix(n, 0);\\n        for(vector<int> shift: shifts) {\\n            prefix[shift[0]] += (shift[2] == 1? 1: -1);\\n            if(shift[1] + 1 < n)\\n                prefix[shift[1] + 1] -= (shift[2] == 1? 1: -1);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            prefix[i] = (prefix[i] + (i > 0? prefix[i - 1]: 0)) % 26;\\n            int val = s[i] + prefix[i];\\n            val -= val > \\'z\\'? 26: 0;\\n            val += val < \\'a\\'? 26: 0;\\n            s[i] = val;\\n        }\\n        return s;\\n    }\\n};\\n\\n\\n// Golang\\nfunc shiftingLetters(s string, shifts [][]int) string {\\n    var n int = len(s)\\n    prefix := make([]int, n)\\n    for _, shift := range shifts {\\n        val := -1\\n        if shift[2] == 1 { val = 1 }\\n        prefix[shift[0]] += val\\n        if shift[1] + 1 < n {\\n            prefix[shift[1] + 1] -= val\\n        }\\n    }\\n    prefix[0] %= 26\\n    b := make([]byte, n)\\n    for i := 0; i < n; i++ {\\n        if i > 0 {\\n             prefix[i] = (prefix[i] + prefix[i - 1]) % 26\\n        }\\n        var val int = int(s[i]) + prefix[i]\\n        if val > \\'z\\' {val -= 26}\\n        if val < \\'a\\' {val += 26}\\n        b[i] = byte(val)\\n    }\\n    return string(b)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297769,
                "title": "java-concise-linesweep",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int N = s.length();\\n        int[] A = new int[N+1];\\n        for(int[] S : shifts){\\n            if(S[2] == 1){\\n                A[S[0]]++;\\n                A[S[1]+1]--;\\n            }else{\\n                A[S[0]]--;\\n                A[S[1]+1]++;\\n            }\\n        }\\n        \\n        int shift = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<N; i++){\\n            shift += A[i];\\n            int n = (((s.charAt(i) - \\'a\\') + shift) % 26 + 26) % 26;\\n            sb.append((char)(\\'a\\' + n));\\n        }\\n        return sb.toString();\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int N = s.length();\\n        int[] A = new int[N+1];\\n        for(int[] S : shifts){\\n            if(S[2] == 1){\\n                A[S[0]]++;\\n                A[S[1]+1]--;\\n            }else{\\n                A[S[0]]--;\\n                A[S[1]+1]++;\\n            }\\n        }\\n        \\n        int shift = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<N; i++){\\n            shift += A[i];\\n            int n = (((s.charAt(i) - \\'a\\') + shift) % 26 + 26) % 26;\\n            sb.append((char)(\\'a\\' + n));\\n        }\\n        return sb.toString();\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240516,
                "title": "line-sweep-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> v(n + 1);\\n\\n        for(auto i : shifts) {\\n            if(i[2]) {\\n                v[i[0]]++;\\n                v[i[1] + 1]--;\\n            }\\n            else {\\n                v[i[0]]--;\\n                v[i[1] + 1]++;\\n            }\\n        }\\n        for(int i=1; i<=n; i++) {\\n            v[i] += v[i - 1];\\n        }\\n        for(int i=0; i<n; i++) {\\n            s[i] = (s[i] - \\'a\\' + v[i] % 26 + 26) % 26 + 97;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> v(n + 1);\\n\\n        for(auto i : shifts) {\\n            if(i[2]) {\\n                v[i[0]]++;\\n                v[i[1] + 1]--;\\n            }\\n            else {\\n                v[i[0]]--;\\n                v[i[1] + 1]++;\\n            }\\n        }\\n        for(int i=1; i<=n; i++) {\\n            v[i] += v[i - 1];\\n        }\\n        for(int i=0; i<n; i++) {\\n            s[i] = (s[i] - \\'a\\' + v[i] % 26 + 26) % 26 + 97;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236883,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n\\n       int[] res = new int[s.length()];\\n       for( int[] ch :shifts){\\n           int i=ch[0];\\n           int j=ch[1];\\n           int k=ch[2];\\n           if(k==1){\\n               for(int l=i;l<=j;l++){\\n                   res[l]++;\\n               }\\n           }else{\\n               for(int l=i; l<=j;l++){\\n                   res[l]--;\\n               }\\n           }\\n\\n       }\\n       char[] check=s.toCharArray();\\n       for(int i=0; i<s.length();i++){\\n           int newchar=((s.charAt(i)-\\'a\\')+res[i])%26;\\n           if(newchar<0) newchar+=26;\\n           check[i]=(char)(newchar+\\'a\\');\\n       }\\n       \\n       return String.valueOf(check);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n\\n       int[] res = new int[s.length()];\\n       for( int[] ch :shifts){\\n           int i=ch[0];\\n           int j=ch[1];\\n           int k=ch[2];\\n           if(k==1){\\n               for(int l=i;l<=j;l++){\\n                   res[l]++;\\n               }\\n           }else{\\n               for(int l=i; l<=j;l++){\\n                   res[l]--;\\n               }\\n           }\\n\\n       }\\n       char[] check=s.toCharArray();\\n       for(int i=0; i<s.length();i++){\\n           int newchar=((s.charAt(i)-\\'a\\')+res[i])%26;\\n           if(newchar<0) newchar+=26;\\n           check[i]=(char)(newchar+\\'a\\');\\n       }\\n       \\n       return String.valueOf(check);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234339,
                "title": "c-o-n-m-simple-prefix-sum-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMove an interval `[l, r]` forward for 1 alphabet is equivalent to a representation of \\n```\\n[0,...,1,0,0,...,0,-1,0,..,0]\\n       ^           ^\\n       l           r+1\\nprefix sum:\\n[0,...,1,1,1,...,1,0 ,0,..,0]\\n```\\nwhere the 1 at entry `l` means every element after index `l` are shifted by 1 char forward. The -1 at `r+1` means we are resetting the element after `r+1` backward for one char.\\n\\nSuch representation is accumulative, meaning we can accumulate all the shifts and then compute the total shift of each element. The representation can also be updated in `O(1)` time for each interval shift.\\n\\nWhen querying the total shift after all the operations at index `i`, it is equivalent to the prefix sum of `0` to `i` in the above array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix Sum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(|shift| + n)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        int shift[n+1];\\n        memset(shift, 0, sizeof(shift));\\n        for (auto & v: shifts) {\\n            int d = v[2]?1:-1;\\n            shift[v[0]] += d;\\n            shift[v[1]+1] -= d;\\n        }\\n        int cur = 0;\\n        for (int i = 0; i < n; ++i) {\\n            cur += shift[i];\\n            s[i] = (((s[i]-\\'a\\' + cur) % 26) + 26) % 26 + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n[0,...,1,0,0,...,0,-1,0,..,0]\\n       ^           ^\\n       l           r+1\\nprefix sum:\\n[0,...,1,1,1,...,1,0 ,0,..,0]\\n```\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        int shift[n+1];\\n        memset(shift, 0, sizeof(shift));\\n        for (auto & v: shifts) {\\n            int d = v[2]?1:-1;\\n            shift[v[0]] += d;\\n            shift[v[1]+1] -= d;\\n        }\\n        int cur = 0;\\n        for (int i = 0; i < n; ++i) {\\n            cur += shift[i];\\n            s[i] = (((s[i]-\\'a\\' + cur) % 26) + 26) % 26 + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226312,
                "title": "python-2381-shifting-letters-ii-easy-and-neat-python-code",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        temp=[0 for i in range(len(s) + 1)]\\n        \\n        for start, end, state in shifts:\\n            temp[start] += [1, -1][1 - state]\\n            temp[end + 1] -= [1, -1][1 - state]\\n                \\n        total = 0\\n        for i in range(len(temp)):\\n            total += temp[i]\\n            temp[i] = total\\n        \\n        ans=\"\"\\n        for i in range(len(s)):\\n            temp[i]= ((ord(s[i]) - ord(\\'a\\')) + temp[i]) % 26 + ord(\\'a\\')\\n            ans += chr(temp[i])\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        temp=[0 for i in range(len(s) + 1)]\\n        \\n        for start, end, state in shifts:\\n            temp[start] += [1, -1][1 - state]\\n            temp[end + 1] -= [1, -1][1 - state]\\n                \\n        total = 0\\n        for i in range(len(temp)):\\n            total += temp[i]\\n            temp[i] = total\\n        \\n        ans=\"\"\\n        for i in range(len(s)):\\n            temp[i]= ((ord(s[i]) - ord(\\'a\\')) + temp[i]) % 26 + ord(\\'a\\')\\n            ans += chr(temp[i])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226309,
                "title": "python-prefix-sum-easy-solution",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        string = list(s)\\n        prefix = [0]*(len(s)+1)\\n        \\n        for left, right, direction in shifts:\\n            \\n            if direction == 1:\\n                prefix[left]+=1\\n                prefix[right+1]-=1\\n                \\n            else:\\n                prefix[left]-=1\\n                prefix[right+1]+=1\\n                \\n        prefix = list(accumulate(prefix))\\n        \\n        ans = []\\n        \\n        for i in range(len(prefix)-1):\\n            \\n            res = (((ord(s[i])-97)+prefix[i])%26)+97\\n            ans.append(chr(res))\\n            \\n            \\n        return (\"\".join(ans))\\n            \\n            \\n            \\n                \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        string = list(s)\\n        prefix = [0]*(len(s)+1)\\n        \\n        for left, right, direction in shifts:\\n            \\n            if direction == 1:\\n                prefix[left]+=1\\n                prefix[right+1]-=1\\n                \\n            else:\\n                prefix[left]-=1\\n                prefix[right+1]+=1\\n                \\n        prefix = list(accumulate(prefix))\\n        \\n        ans = []\\n        \\n        for i in range(len(prefix)-1):\\n            \\n            res = (((ord(s[i])-97)+prefix[i])%26)+97\\n            ans.append(chr(res))\\n            \\n            \\n        return (\"\".join(ans))\\n            \\n            \\n            \\n                \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209927,
                "title": "java-solution-with-prefix-sum-line-sweep",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] arr = s.toCharArray();\\n        int count[] = new int[s.length()+1];\\n        for(int i=0;i<shifts.length;i++)\\n        {\\n            int[] shift =shifts[i];\\n            int beg=shift[0],end=shift[1],dir=shift[2];\\n            \\n            int sh = dir==1 ? 1:-1;\\n            count[beg]+=sh;\\n            count[end+1]-=sh;\\n        }\\n\\n        for(int i=1;i<count.length;i++) count[i]+=count[i-1];\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            //the new character after we add the shift modulo 26\\n            int n = arr[i]+(count[i])%26;\\n            //we make sure it is within \\'a\\' to \\'z\\'\\n            if(n>\\'z\\') n=\\'a\\'+(n-\\'z\\')-1;\\n            if(n<\\'a\\') n=\\'z\\'-(\\'a\\'-n)+1;\\n            arr[i]=(char)(n);\\n        }\\n        \\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] arr = s.toCharArray();\\n        int count[] = new int[s.length()+1];\\n        for(int i=0;i<shifts.length;i++)\\n        {\\n            int[] shift =shifts[i];\\n            int beg=shift[0],end=shift[1],dir=shift[2];\\n            \\n            int sh = dir==1 ? 1:-1;\\n            count[beg]+=sh;\\n            count[end+1]-=sh;\\n        }\\n\\n        for(int i=1;i<count.length;i++) count[i]+=count[i-1];\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            //the new character after we add the shift modulo 26\\n            int n = arr[i]+(count[i])%26;\\n            //we make sure it is within \\'a\\' to \\'z\\'\\n            if(n>\\'z\\') n=\\'a\\'+(n-\\'z\\')-1;\\n            if(n<\\'a\\') n=\\'z\\'-(\\'a\\'-n)+1;\\n            arr[i]=(char)(n);\\n        }\\n        \\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140384,
                "title": "python-endpoints-trick",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        offsets, cur, ans = [0] * (len(s) + 1), 0, \\'\\'\\n        for start, end, d in shifts:\\n            shift = (-1) ** (1 - d)\\n            offsets[start] += shift\\n            offsets[end + 1] -= shift\\n        for o, c in zip(offsets, s):\\n            cur += o\\n            ans += chr(97 + (ord(c) - 97 + cur) % 26)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        offsets, cur, ans = [0] * (len(s) + 1), 0, \\'\\'\\n        for start, end, d in shifts:\\n            shift = (-1) ** (1 - d)\\n            offsets[start] += shift\\n            offsets[end + 1] -= shift\\n        for o, c in zip(offsets, s):\\n            cur += o\\n            ans += chr(97 + (ord(c) - 97 + cur) % 26)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134802,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def shiftingLetters(s: String, shifts: Array[Array[Int]]): String = {\\n        val as = shifts.foldLeft(new Array[Int](s.length))((ans, cur) =>{\\n        if(cur(2) == 0)\\n            for(i <- cur(0) to cur(1))\\n                ans(i) = ans(i) - 1\\n        else\\n            for (i <- cur(0) to cur(1))\\n                ans(i) = ans(i) + 1\\n        ans\\n        })\\n        (s zip as).map{case (ch, sh) => (\\'a\\' + (ch - \\'a\\' + 26 + sh % 26) % 26).toChar}.mkString\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def shiftingLetters(s: String, shifts: Array[Array[Int]]): String = {\\n        val as = shifts.foldLeft(new Array[Int](s.length))((ans, cur) =>{\\n        if(cur(2) == 0)\\n            for(i <- cur(0) to cur(1))\\n                ans(i) = ans(i) - 1\\n        else\\n            for (i <- cur(0) to cur(1))\\n                ans(i) = ans(i) + 1\\n        ans\\n        })\\n        (s zip as).map{case (ch, sh) => (\\'a\\' + (ch - \\'a\\' + 26 + sh % 26) % 26).toChar}.mkString\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3110448,
                "title": "python-o-n-labeling-to-do-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        chars = \"abcdefghijklmnopqrstuvwxyz\"\\n        index_to_char = {}\\n        for i, c in enumerate(chars):\\n            index_to_char[i] = c\\n\\n        chars = [ord(c) - ord(\"a\") for c in s]\\n        prefix = [0] * len(s)\\n        for start, end, direction in shifts:\\n            prefix[start] += 1 if direction == 1 else -1\\n            if end + 1 < len(prefix):\\n                prefix[end + 1] -= 1 if direction == 1 else -1\\n\\n        for i in range(1, len(prefix)):\\n            prefix[i] += prefix[i-1]\\n\\n        for i in range(len(chars)):\\n            chars[i] = (chars[i] + prefix[i]) % 26\\n\\n        chars = [index_to_char[c] for c in chars]\\n        return \"\".join(chars)\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        chars = \"abcdefghijklmnopqrstuvwxyz\"\\n        index_to_char = {}\\n        for i, c in enumerate(chars):\\n            index_to_char[i] = c\\n\\n        chars = [ord(c) - ord(\"a\") for c in s]\\n        prefix = [0] * len(s)\\n        for start, end, direction in shifts:\\n            prefix[start] += 1 if direction == 1 else -1\\n            if end + 1 < len(prefix):\\n                prefix[end + 1] -= 1 if direction == 1 else -1\\n\\n        for i in range(1, len(prefix)):\\n            prefix[i] += prefix[i-1]\\n\\n        for i in range(len(chars)):\\n            chars[i] = (chars[i] + prefix[i]) % 26\\n\\n        chars = [index_to_char[c] for c in chars]\\n        return \"\".join(chars)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084036,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> dp(s.size()+1, 0);\\n\\n        for(auto& ele: shifts) {\\n            if(ele[2] == 1) {\\n                dp[ele[0]] += 1;\\n                dp[ele[1]+1]-=1;\\n            }else {\\n                dp[ele[0]] -= 1;\\n                dp[ele[1]+1] += 1;\\n            }\\n        }\\n\\n\\n        for(int i=0;i<s.size();i++) {\\n            char c = s[i];\\n            if(i>0) {\\n                dp[i] += dp[i-1];\\n            }\\n\\n            int move = dp[i]%26;\\n            if(move < 0) {\\n                move += 26;\\n            }\\n\\n            if(c + move > \\'z\\') {\\n                c = char(c + move - 26);\\n            }else {\\n                c = char(c + move);\\n            }\\n\\n            s[i] = c;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> dp(s.size()+1, 0);\\n\\n        for(auto& ele: shifts) {\\n            if(ele[2] == 1) {\\n                dp[ele[0]] += 1;\\n                dp[ele[1]+1]-=1;\\n            }else {\\n                dp[ele[0]] -= 1;\\n                dp[ele[1]+1] += 1;\\n            }\\n        }\\n\\n\\n        for(int i=0;i<s.size();i++) {\\n            char c = s[i];\\n            if(i>0) {\\n                dp[i] += dp[i-1];\\n            }\\n\\n            int move = dp[i]%26;\\n            if(move < 0) {\\n                move += 26;\\n            }\\n\\n            if(c + move > \\'z\\') {\\n                c = char(c + move - 26);\\n            }else {\\n                c = char(c + move);\\n            }\\n\\n            s[i] = c;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079200,
                "title": "java-line-sweep-time-o-n-space-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        char[] sch = s.toCharArray();\\n        int[] line = new int[n + 1];\\n        for (int[] shift : shifts) {\\n            if (shift[2] == 1) {\\n                line[shift[0]] = line[shift[0]] + 1;\\n                line[shift[1] + 1] = line[shift[1] + 1] - 1;\\n            } else {\\n                line[shift[0]] = line[shift[0]] - 1;\\n                line[shift[1] + 1] = line[shift[1] + 1] + 1;\\n            }\\n        }\\n        int moves = 0;\\n        for (int i = 0; i < n; i++) {\\n            moves += line[i];\\n            int move = (sch[i] - \\'a\\' + moves) % 26;\\n            if (move < 0) {\\n                move += 26;\\n            }\\n            sch[i] = (char)(\\'a\\' + move);\\n        }\\n        return new String(sch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        char[] sch = s.toCharArray();\\n        int[] line = new int[n + 1];\\n        for (int[] shift : shifts) {\\n            if (shift[2] == 1) {\\n                line[shift[0]] = line[shift[0]] + 1;\\n                line[shift[1] + 1] = line[shift[1] + 1] - 1;\\n            } else {\\n                line[shift[0]] = line[shift[0]] - 1;\\n                line[shift[1] + 1] = line[shift[1] + 1] + 1;\\n            }\\n        }\\n        int moves = 0;\\n        for (int i = 0; i < n; i++) {\\n            moves += line[i];\\n            int move = (sch[i] - \\'a\\' + moves) % 26;\\n            if (move < 0) {\\n                move += 26;\\n            }\\n            sch[i] = (char)(\\'a\\' + move);\\n        }\\n        return new String(sch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062613,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shift) {\\n        \\n        int n=s.length();\\n        vector<int> freq(n,0);\\n        for(int i=0;i<shift.size();i++)\\n        {\\n            if(shift[i][2]==0)\\n            {\\n                freq[shift[i][0]]--;\\n                if(shift[i][1]<n-1)\\n                {\\n                    freq[shift[i][1]+1]++;\\n                }\\n            }\\n            \\n            if(shift[i][2]==1)\\n            {\\n                freq[shift[i][0]]++;\\n                if(shift[i][1]<n-1)\\n                {\\n                    freq[shift[i][1]+1]--;\\n                }\\n            }    \\n        }\\n        \\n        for(int i=1;i<n;i++)\\n            freq[i]=freq[i-1]+freq[i];\\n        \\n        for(int i=0;i<n;i++)\\n        cout<<freq[i]<<\" \";\\n\\n        for(int i=0;i<n;i++){\\n        int idx = (s[i]-\\'a\\' + freq[i])%26;\\n        if(idx<0) idx += 26;\\n        char new_ch = (char)(idx + \\'a\\');\\n        s[i] = new_ch;\\n    }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shift) {\\n        \\n        int n=s.length();\\n        vector<int> freq(n,0);\\n        for(int i=0;i<shift.size();i++)\\n        {\\n            if(shift[i][2]==0)\\n            {\\n                freq[shift[i][0]]--;\\n                if(shift[i][1]<n-1)\\n                {\\n                    freq[shift[i][1]+1]++;\\n                }\\n            }\\n            \\n            if(shift[i][2]==1)\\n            {\\n                freq[shift[i][0]]++;\\n                if(shift[i][1]<n-1)\\n                {\\n                    freq[shift[i][1]+1]--;\\n                }\\n            }    \\n        }\\n        \\n        for(int i=1;i<n;i++)\\n            freq[i]=freq[i-1]+freq[i];\\n        \\n        for(int i=0;i<n;i++)\\n        cout<<freq[i]<<\" \";\\n\\n        for(int i=0;i<n;i++){\\n        int idx = (s[i]-\\'a\\' + freq[i])%26;\\n        if(idx<0) idx += 26;\\n        char new_ch = (char)(idx + \\'a\\');\\n        s[i] = new_ch;\\n    }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3030017,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        HashMap<Integer,Character> map = new HashMap();\\n        int val = 0;\\n        for(char ch = \\'a\\' ; ch <= \\'z\\'; ch++) {\\n            map.put(val++,ch);\\n        }\\n        int[] arr = new int[s.length()+1];\\n        int index = 0;        \\n        for(int i = 0; i < shifts.length; i++) {\\n            int add = -1;\\n            if(shifts[i][2] == 1)\\n                add = 1;\\n            arr[shifts[i][0]]+=add;\\n            arr[shifts[i][1]+1]-=add;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length();i++) {\\n            if(i != 0)\\n                arr[i]+=arr[i-1];\\n            val = s.charAt(i)-\\'a\\'+arr[i];\\n            while(val < 0)\\n                val+=26;\\n            val%=26;\\n            sb.append(map.get(val));\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        HashMap<Integer,Character> map = new HashMap();\\n        int val = 0;\\n        for(char ch = \\'a\\' ; ch <= \\'z\\'; ch++) {\\n            map.put(val++,ch);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2966735,
                "title": "c-simple-line-sweep-prefix-sum-o-n-o-n",
                "content": "# Intuition : Intervals are given and we have to modify the values in the intervals\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Prefix Sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.length();\\n        vector<int> prefixSum(n, 0);\\n\\n        for(auto shift : shifts) {\\n            int val = shift[2] == 1 ? 1 : -1;\\n            prefixSum[shift[0]] = prefixSum[shift[0]] + val;\\n            if(shift[1] + 1 < n)\\n                prefixSum[shift[1]+1] = prefixSum[shift[1]+1] - val;\\n        }\\n\\n        //calculatePrefixSum\\n        for(int i = 1; i < n; i++) {\\n            prefixSum[i] = prefixSum[i] + prefixSum[i-1];\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            int dax = (s[i]-\\'a\\');\\n            int val = ((((dax + prefixSum[i] + 26) % 26) + 26)) % 26;\\n            s[i] = \\'a\\' + val;\\n        }\\n\\n        return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.length();\\n        vector<int> prefixSum(n, 0);\\n\\n        for(auto shift : shifts) {\\n            int val = shift[2] == 1 ? 1 : -1;\\n            prefixSum[shift[0]] = prefixSum[shift[0]] + val;\\n            if(shift[1] + 1 < n)\\n                prefixSum[shift[1]+1] = prefixSum[shift[1]+1] - val;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2949488,
                "title": "beats-95-python-solution-prefixsum-technique",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\"\\n        We need to find a way to generate an array that will contain the steps that should be taken for\\n        each index of s.\\n\\n        Approach (Prefix Sum):\\n        create an array called steps\\n        Loop through shifts array and increment the upper bound index of shift in steps(steps[upperbound]) by either -1 or 1 (decrementing or incrementing). Also increment or decrement the value at steps[lowerbound - 1]\\n\\n        Finally, loop through steps in reverse order and compute the prefix sum array.\\n\\n        \"\"\"\\n\\n        steps = [0]*len(s) \\n        for l, u, d in shifts:\\n            if d == 1:\\n                steps[u] += 1\\n                if l - 1 >= 0:\\n                    steps[l - 1] -= 1\\n            else:\\n                steps[u] -= 1\\n                if l - 1 >= 0:\\n                    steps[l - 1] += 1\\n\\n        # Compute Prefix sum array in reverse order\\n        for i in range(len(steps) - 2, -1, -1):\\n            steps[i] = steps[i] + steps[i + 1]\\n\\n        res = []\\n        for i in range(len(s)):\\n            shifted_letter = chr(97 + (ord(s[i]) + steps[i] - 97)%26)\\n            res.append(shifted_letter)\\n\\n        return  \"\".join(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\"\\n        We need to find a way to generate an array that will contain the steps that should be taken for\\n        each index of s.\\n\\n        Approach (Prefix Sum):\\n        create an array called steps\\n        Loop through shifts array and increment the upper bound index of shift in steps(steps[upperbound]) by either -1 or 1 (decrementing or incrementing). Also increment or decrement the value at steps[lowerbound - 1]\\n\\n        Finally, loop through steps in reverse order and compute the prefix sum array.\\n\\n        \"\"\"\\n\\n        steps = [0]*len(s) \\n        for l, u, d in shifts:\\n            if d == 1:\\n                steps[u] += 1\\n                if l - 1 >= 0:\\n                    steps[l - 1] -= 1\\n            else:\\n                steps[u] -= 1\\n                if l - 1 >= 0:\\n                    steps[l - 1] += 1\\n\\n        # Compute Prefix sum array in reverse order\\n        for i in range(len(steps) - 2, -1, -1):\\n            steps[i] = steps[i] + steps[i + 1]\\n\\n        res = []\\n        for i in range(len(s)):\\n            shifted_letter = chr(97 + (ord(s[i]) + steps[i] - 97)%26)\\n            res.append(shifted_letter)\\n\\n        return  \"\".join(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926396,
                "title": "python-clean-solution-with-explanation",
                "content": "This problem is basically the same as https://leetcode.com/problems/maximum-population-year/. I use the same approach:\\n1. Count the number of shifts occurring at each index\\n2. Scan the string from left to right, keeping track of the cumulative shift amount\\n\\nInstead of using 4 arrays to track the shifts, I could use a single array where the `ith` element indicates how much shift to add before processing the `ith` character. This would be more concise, but with the same asymptotic time complexity and less readability.\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        forward_starts = [0]*len(s)\\n        forward_ends = [0]*len(s)\\n        back_starts = [0]*len(s)\\n        back_ends = [0]*len(s)\\n\\n        for shift in shifts:\\n            start, end, direction = shift\\n            if direction == 1:\\n                forward_starts[start] += 1\\n                forward_ends[end] += 1\\n            else:\\n                back_starts[start] += 1\\n                back_ends[end] += 1\\n\\n        res = []\\n        shift_amount = 0\\n        for i, ch in enumerate(s):\\n            shift_amount += forward_starts[i]\\n            shift_amount -= back_starts[i]\\n            \\n            res.append(self.shift_letter(ch, shift_amount))\\n\\n            shift_amount -= forward_ends[i]\\n            shift_amount += back_ends[i]\\n\\n        return \"\".join(res)\\n    \\n    def shift_letter(self, letter, amount):\\n        letter_index = ord(letter) - ord(\"a\")\\n        new_letter_index = (letter_index + amount) % 26\\n        return chr(new_letter_index + ord(\"a\"))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        forward_starts = [0]*len(s)\\n        forward_ends = [0]*len(s)\\n        back_starts = [0]*len(s)\\n        back_ends = [0]*len(s)\\n\\n        for shift in shifts:\\n            start, end, direction = shift\\n            if direction == 1:\\n                forward_starts[start] += 1\\n                forward_ends[end] += 1\\n            else:\\n                back_starts[start] += 1\\n                back_ends[end] += 1\\n\\n        res = []\\n        shift_amount = 0\\n        for i, ch in enumerate(s):\\n            shift_amount += forward_starts[i]\\n            shift_amount -= back_starts[i]\\n            \\n            res.append(self.shift_letter(ch, shift_amount))\\n\\n            shift_amount -= forward_ends[i]\\n            shift_amount += back_ends[i]\\n\\n        return \"\".join(res)\\n    \\n    def shift_letter(self, letter, amount):\\n        letter_index = ord(letter) - ord(\"a\")\\n        new_letter_index = (letter_index + amount) % 26\\n        return chr(new_letter_index + ord(\"a\"))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907010,
                "title": "line-sweep-algo-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    static bool cmp(vector<ll>&v1,vector<ll>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }\\n        return v1[0]<v2[0];\\n    }\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        ll current=0,index=0,mayank=0;\\n        vector<vector<ll>>container;\\n        string answer=s;\\n        for(auto &x:shifts){\\n            container.push_back({x[0],1,(x[2]==1)?1:-1});\\n            container.push_back({x[1],-1,(x[2]==1)?1:-1});\\n        }\\n        ll n=s.length();\\n        sort(container.begin(),container.end(),cmp);\\n        while(mayank<n){\\n            ll now=mayank;\\n            while(index<container.size() && container[index][0]==now && container[index][1]==1){\\n                current+=container[index][2];\\n                index++;\\n            }\\n            bool condition=(current<0?true:false);\\n            current=abs(current)%26;\\n            if(condition){\\n                current=-current;\\n            }\\n            for(ll i=0;i<abs(current);i++){\\n                if(current>0){\\n                    answer[mayank]++;\\n                    if(answer[mayank]>\\'z\\'){\\n                        answer[mayank]=\\'a\\';\\n                    }\\n                }\\n                else{\\n                    answer[mayank]--;\\n                    if(answer[mayank]<\\'a\\'){\\n                        answer[mayank]=\\'z\\';\\n                    }\\n                }\\n            }\\n            while(index<container.size() && container[index][0]==now && container[index][1]==-1){\\n                current-=container[index][2];\\n                index++;\\n            }\\n            mayank++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    static bool cmp(vector<ll>&v1,vector<ll>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }\\n        return v1[0]<v2[0];\\n    }\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        ll current=0,index=0,mayank=0;\\n        vector<vector<ll>>container;\\n        string answer=s;\\n        for(auto &x:shifts){\\n            container.push_back({x[0],1,(x[2]==1)?1:-1});\\n            container.push_back({x[1],-1,(x[2]==1)?1:-1});\\n        }\\n        ll n=s.length();\\n        sort(container.begin(),container.end(),cmp);\\n        while(mayank<n){\\n            ll now=mayank;\\n            while(index<container.size() && container[index][0]==now && container[index][1]==1){\\n                current+=container[index][2];\\n                index++;\\n            }\\n            bool condition=(current<0?true:false);\\n            current=abs(current)%26;\\n            if(condition){\\n                current=-current;\\n            }\\n            for(ll i=0;i<abs(current);i++){\\n                if(current>0){\\n                    answer[mayank]++;\\n                    if(answer[mayank]>\\'z\\'){\\n                        answer[mayank]=\\'a\\';\\n                    }\\n                }\\n                else{\\n                    answer[mayank]--;\\n                    if(answer[mayank]<\\'a\\'){\\n                        answer[mayank]=\\'z\\';\\n                    }\\n                }\\n            }\\n            while(index<container.size() && container[index][0]==now && container[index][1]==-1){\\n                current-=container[index][2];\\n                index++;\\n            }\\n            mayank++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891766,
                "title": "python-simple-sweep-line-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s, shifts):\\n        dict1, res = defaultdict(int), []\\n\\n        for i,j,k in shifts:\\n            if k == 0:\\n                dict1[i] -= 1\\n                dict1[j+1] += 1\\n            else:\\n                dict1[i] += 1\\n                dict1[j+1] -= 1\\n\\n        total = 0\\n\\n        for i in range(len(s)):\\n            total += dict1[i]\\n            res.append(total)\\n\\n        str1 = \"\"\\n\\n        for i in range(len(s)):\\n            str1 += chr(((ord(s[i]) - 97) + res[i])%26 + 97)\\n\\n        return str1\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s, shifts):\\n        dict1, res = defaultdict(int), []\\n\\n        for i,j,k in shifts:\\n            if k == 0:\\n                dict1[i] -= 1\\n                dict1[j+1] += 1\\n            else:\\n                dict1[i] += 1\\n                dict1[j+1] -= 1\\n\\n        total = 0\\n\\n        for i in range(len(s)):\\n            total += dict1[i]\\n            res.append(total)\\n\\n        str1 = \"\"\\n\\n        for i in range(len(s)):\\n            str1 += chr(((ord(s[i]) - 97) + res[i])%26 + 97)\\n\\n        return str1\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872407,
                "title": "simple-prefix-sum-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a) {\\n        int n=s.length();\\n        vector<int> cnt(n+2,0);\\n        \\n        for(auto v:a){\\n            int c=-1;\\n            if(v[2])\\n                c=1;\\n            cnt[v[0]]+=c;\\n            cnt[v[1]+1]-=c;\\n        }\\n        \\n        cnt[0]=(cnt[0]%26+26)%26;\\n        string t;\\n        t.push_back(\\'a\\'+(s[0]-\\'a\\'+cnt[0])%26);\\n        \\n        for(int i=1;i<n;i++){\\n            cnt[i]=((cnt[i]+cnt[i-1])%26+26)%26;\\n            t.push_back(\\'a\\'+(s[i]-\\'a\\'+cnt[i])%26);\\n        }\\n        \\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a) {\\n        int n=s.length();\\n        vector<int> cnt(n+2,0);\\n        \\n        for(auto v:a){\\n            int c=-1;\\n            if(v[2])\\n                c=1;\\n            cnt[v[0]]+=c;\\n            cnt[v[1]+1]-=c;\\n        }\\n        \\n        cnt[0]=(cnt[0]%26+26)%26;\\n        string t;\\n        t.push_back(\\'a\\'+(s[0]-\\'a\\'+cnt[0])%26);\\n        \\n        for(int i=1;i<n;i++){\\n            cnt[i]=((cnt[i]+cnt[i-1])%26+26)%26;\\n            t.push_back(\\'a\\'+(s[i]-\\'a\\'+cnt[i])%26);\\n        }\\n        \\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862852,
                "title": "c",
                "content": "```\\nchar * shiftingLetters(char * s, int** shifts, int shiftsSize, int* shiftsColSize){\\n    int n = strlen(s);\\n    int* prefixSum = calloc( (n + 1) , sizeof(int));\\n    prefixSum[n] = 0;\\n    for(int i = 0; i < shiftsSize; i++){\\n        if(shifts[i][2] == 1 ){\\n            prefixSum[shifts[i][0]]++;\\n            prefixSum[shifts[i][1] + 1]--;\\n        }\\n        else{\\n            prefixSum[shifts[i][0]]--;\\n            prefixSum[shifts[i][1] + 1]++;\\n        }\\n    }\\n    for(int i= 1; i < n; i++){\\n        prefixSum[i] += prefixSum[i-1]; \\n    }\\n    char* ans = malloc((n+1) * sizeof(char));\\n    ans[n] = \\'\\\\0\\';\\n    for(int i = 0; i < n; i++){\\n        prefixSum[i] += s[i] - \\'a\\';\\n        if(prefixSum[i] >= 0){\\n            prefixSum[i] %= 26;\\n        }\\n        else{\\n            prefixSum[i] = (prefixSum[i]%26 + 26) %26;\\n        }\\n        ans[i] = \\'a\\' + prefixSum[i] ;\\n    }\\n    free(prefixSum);\\n    return ans;   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * shiftingLetters(char * s, int** shifts, int shiftsSize, int* shiftsColSize){\\n    int n = strlen(s);\\n    int* prefixSum = calloc( (n + 1) , sizeof(int));\\n    prefixSum[n] = 0;\\n    for(int i = 0; i < shiftsSize; i++){\\n        if(shifts[i][2] == 1 ){\\n            prefixSum[shifts[i][0]]++;\\n            prefixSum[shifts[i][1] + 1]--;\\n        }\\n        else{\\n            prefixSum[shifts[i][0]]--;\\n            prefixSum[shifts[i][1] + 1]++;\\n        }\\n    }\\n    for(int i= 1; i < n; i++){\\n        prefixSum[i] += prefixSum[i-1]; \\n    }\\n    char* ans = malloc((n+1) * sizeof(char));\\n    ans[n] = \\'\\\\0\\';\\n    for(int i = 0; i < n; i++){\\n        prefixSum[i] += s[i] - \\'a\\';\\n        if(prefixSum[i] >= 0){\\n            prefixSum[i] %= 26;\\n        }\\n        else{\\n            prefixSum[i] = (prefixSum[i]%26 + 26) %26;\\n        }\\n        ans[i] = \\'a\\' + prefixSum[i] ;\\n    }\\n    free(prefixSum);\\n    return ans;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2834226,
                "title": "javascript-intuitive",
                "content": "```\\nvar shiftingLetters = function(s, shifts) {\\n    const n = s.length, countShifts = Array(n).fill(0);\\n\\n    for (const [start, end, dir] of shifts) {\\n        let mathSign = dir ? 1 : -1;\\n        for (let i = start; i<=end; i++) {\\n            countShifts[i] += mathSign;\\n        }\\n    }\\n    s = s.split(\\'\\');\\n\\n    for (let i = 0; i<n; i++) {\\n        let val = s[i].charCodeAt()-97 + countShifts[i];\\n        if (val < 0) {\\n            val = 26 + (val%26);\\n        } \\n        if (val > 25) {\\n            val%=26;\\n        }\\n        if (val < 0) console.log(s[i], countShifts[i])\\n        s[i] = String.fromCharCode(val+97);\\n    }\\n\\n    return s.join(\\'\\');\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftingLetters = function(s, shifts) {\\n    const n = s.length, countShifts = Array(n).fill(0);\\n\\n    for (const [start, end, dir] of shifts) {\\n        let mathSign = dir ? 1 : -1;\\n        for (let i = start; i<=end; i++) {\\n            countShifts[i] += mathSign;\\n        }\\n    }\\n    s = s.split(\\'\\');\\n\\n    for (let i = 0; i<n; i++) {\\n        let val = s[i].charCodeAt()-97 + countShifts[i];\\n        if (val < 0) {\\n            val = 26 + (val%26);\\n        } \\n        if (val > 25) {\\n            val%=26;\\n        }\\n        if (val < 0) console.log(s[i], countShifts[i])\\n        s[i] = String.fromCharCode(val+97);\\n    }\\n\\n    return s.join(\\'\\');\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2828211,
                "title": "python3-using-cumulative-sum",
                "content": "class Solution:\\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        direction = [-1,1]\\n        cumSum = [0]*(1+n)\\n        ordA = ord(\\'a\\')\\n        \\n        for l,r,d in shifts:\\n            di = direction[d]\\n            cumSum[l]+=di\\n            cumSum[r+1]-=di\\n            \\n        for i in range(1,n):\\n            cumSum[i]+=cumSum[i-1]    \\n            \\n        sList = list(s)\\n        for i in range(n):\\n            curr = (ord(s[i])-ordA+cumSum[i])%26\\n            sList[i] = chr(ordA+curr)\\n            \\n        return \\'\\'.join(sList)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        direction = [-1,1]\\n        cumSum = [0]*(1+n)\\n        ordA = ord(\\'a\\')\\n        \\n        for l,r,d in shifts:\\n            di = direction[d]\\n            cumSum[l]+=di\\n            cumSum[r+1]-=di\\n            \\n        for i in range(1,n):\\n            cumSum[i]+=cumSum[i-1]    \\n            \\n        sList = list(s)\\n        for i in range(n):\\n            curr = (ord(s[i])-ordA+cumSum[i])%26\\n            sList[i] = chr(ordA+curr)\\n            \\n        return \\'\\'.join(sList)",
                "codeTag": "Java"
            },
            {
                "id": 2798405,
                "title": "javascript-cumulative-sum-efficient-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCreate an array to find all the shifts using cumulative sum approach, this way TC will be O(n) otherwise it\\'ll be O(n**2)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function (s, shifts) {\\n\\tconst arr = new Array(s.length).fill(0);\\n\\tfor (const [start, end, direction] of shifts) {\\n\\t\\tif (direction === 0) {\\n\\t\\t\\tarr[start] -= 1;\\n\\t\\t\\tend !== arr.length - 1 && (arr[end + 1] += 1)\\n\\t\\t} else {\\n\\t\\t\\tarr[start] += 1;\\n\\t\\t\\tend !== arr.length - 1 && (arr[end + 1] -= 1)\\n\\t\\t}\\n\\t}\\n\\n\\tfor (let i = 1; i < arr.length; i++) arr[i] += arr[i - 1]\\n\\n\\tlet res = \\'\\'\\n\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\tconst code = s[i].charCodeAt() + arr[i];\\n\\n\\t\\tif (code < 97) {\\n\\t\\t\\tlet diff = (97 - code) % 26;\\n            // to handle negative and zero\\n\\t\\t\\tif (diff <= 0) diff += 26\\n\\t\\t\\tres += String.fromCharCode(123 - diff);\\n\\t\\t}\\n\\t\\telse if (code > 122) {\\n\\t\\t\\tlet diff = (code - 122) % 26;\\n\\t\\t\\tif (diff <= 0) diff += 26\\n\\t\\t\\tres += String.fromCharCode(96 + diff);\\n\\t\\t}\\n\\t\\telse res += String.fromCharCode(code)\\n\\t}\\n\\t\\n\\treturn res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function (s, shifts) {\\n\\tconst arr = new Array(s.length).fill(0);\\n\\tfor (const [start, end, direction] of shifts) {\\n\\t\\tif (direction === 0) {\\n\\t\\t\\tarr[start] -= 1;\\n\\t\\t\\tend !== arr.length - 1 && (arr[end + 1] += 1)\\n\\t\\t} else {\\n\\t\\t\\tarr[start] += 1;\\n\\t\\t\\tend !== arr.length - 1 && (arr[end + 1] -= 1)\\n\\t\\t}\\n\\t}\\n\\n\\tfor (let i = 1; i < arr.length; i++) arr[i] += arr[i - 1]\\n\\n\\tlet res = \\'\\'\\n\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\tconst code = s[i].charCodeAt() + arr[i];\\n\\n\\t\\tif (code < 97) {\\n\\t\\t\\tlet diff = (97 - code) % 26;\\n            // to handle negative and zero\\n\\t\\t\\tif (diff <= 0) diff += 26\\n\\t\\t\\tres += String.fromCharCode(123 - diff);\\n\\t\\t}\\n\\t\\telse if (code > 122) {\\n\\t\\t\\tlet diff = (code - 122) % 26;\\n\\t\\t\\tif (diff <= 0) diff += 26\\n\\t\\t\\tres += String.fromCharCode(96 + diff);\\n\\t\\t}\\n\\t\\telse res += String.fromCharCode(code)\\n\\t}\\n\\t\\n\\treturn res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774832,
                "title": "c-10-line",
                "content": "```\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size(), x = 0;\\n        vector<int> vshif(n+1);\\n        for(auto& v:shifts) {\\n            if(v[2] == 1) vshif[v[0]]++, vshif[v[1]+1]--;\\n            else vshif[v[0]]--, vshif[v[1]+1]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            x += vshif[i];\\n            s[i] = \\'a\\' + (s[i] - \\'a\\' + x + 2600000) % 26;\\n        }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "```\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size(), x = 0;\\n        vector<int> vshif(n+1);\\n        for(auto& v:shifts) {\\n            if(v[2] == 1) vshif[v[0]]++, vshif[v[1]+1]--;\\n            else vshif[v[0]]--, vshif[v[1]+1]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            x += vshif[i];\\n            s[i] = \\'a\\' + (s[i] - \\'a\\' + x + 2600000) % 26;\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2768330,
                "title": "c-prefix-o-mn",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int size1=s.size(), size2=shifts.size();\\n        \\n        vector<int> prefix(size1+1);\\n        \\n        for(int i=0; i<size2; i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                prefix[shifts[i][0]]++;\\n                prefix[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                prefix[shifts[i][0]]--;\\n                prefix[shifts[i][1]+1]++;\\n            }\\n        }\\n        \\n        string ans=s;\\n        \\n        int offset=0;\\n        \\n        for(int i=0; i<size1; i++)\\n        {\\n            offset+=prefix[i];\\n            ans[i]=\\'a\\'+(ans[i]-\\'a\\'+offset%26+26)%26;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int size1=s.size(), size2=shifts.size();\\n        \\n        vector<int> prefix(size1+1);\\n        \\n        for(int i=0; i<size2; i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                prefix[shifts[i][0]]++;\\n                prefix[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                prefix[shifts[i][0]]--;\\n                prefix[shifts[i][1]+1]++;\\n            }\\n        }\\n        \\n        string ans=s;\\n        \\n        int offset=0;\\n        \\n        for(int i=0; i<size1; i++)\\n        {\\n            offset+=prefix[i];\\n            ans[i]=\\'a\\'+(ans[i]-\\'a\\'+offset%26+26)%26;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764071,
                "title": "python-3-line-sweep-o-n-o-n",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        totalShifts = [0] * (n + 1)\\n        for start, end, direction in shifts:\\n            if not direction:\\n                direction = -1\\n            totalShifts[start] += direction\\n            totalShifts[end + 1] -= direction\\n        \\n        for i in range(1, n):\\n            totalShifts[i] += totalShifts[i - 1]\\n        \\n        res = []\\n        for c, totalShift in zip(s, totalShifts):\\n            res.append(chr((ord(c) - 97 + totalShift) % 26 + 97))\\n        return \\'\\'.join(res)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        totalShifts = [0] * (n + 1)\\n        for start, end, direction in shifts:\\n            if not direction:\\n                direction = -1\\n            totalShifts[start] += direction\\n            totalShifts[end + 1] -= direction\\n        \\n        for i in range(1, n):\\n            totalShifts[i] += totalShifts[i - 1]\\n        \\n        res = []\\n        for c, totalShift in zip(s, totalShifts):\\n            res.append(chr((ord(c) - 97 + totalShift) % 26 + 97))\\n        return \\'\\'.join(res)",
                "codeTag": "Java"
            },
            {
                "id": 2753031,
                "title": "golang-move-solution",
                "content": "```go\\nfunc shiftingLetters(s string, shifts [][]int) string {\\n\\tshiftRecorder := make([]int, len(s)+1)\\n\\tfor _, shift := range shifts {\\n\\t\\tif shift[2] == 1 {\\n\\t\\t\\tshiftRecorder[shift[0]]++\\n\\t\\t\\tshiftRecorder[shift[1]+1]--\\n\\t\\t} else {\\n\\t\\t\\tshiftRecorder[shift[0]]--\\n\\t\\t\\tshiftRecorder[shift[1]+1]++\\n\\t\\t}\\n\\t}\\n\\tbb := bytes.Buffer{}\\n\\tmove := 0\\n\\tfor i, c := range s {\\n\\t\\tmove += shiftRecorder[i]\\n\\t\\tif move < 0 {\\n\\t\\t\\tmove = (26 - (-move)%26) % 26\\n\\t\\t}\\n\\t\\tmove %= 26\\n\\t\\tnc := c + rune(move)\\n\\t\\tif nc > \\'z\\' {\\n\\t\\t\\tnc -= 26\\n\\t\\t}\\n\\t\\tbb.WriteRune(nc)\\n\\t}\\n\\treturn bb.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc shiftingLetters(s string, shifts [][]int) string {\\n\\tshiftRecorder := make([]int, len(s)+1)\\n\\tfor _, shift := range shifts {\\n\\t\\tif shift[2] == 1 {\\n\\t\\t\\tshiftRecorder[shift[0]]++\\n\\t\\t\\tshiftRecorder[shift[1]+1]--\\n\\t\\t} else {\\n\\t\\t\\tshiftRecorder[shift[0]]--\\n\\t\\t\\tshiftRecorder[shift[1]+1]++\\n\\t\\t}\\n\\t}\\n\\tbb := bytes.Buffer{}\\n\\tmove := 0\\n\\tfor i, c := range s {\\n\\t\\tmove += shiftRecorder[i]\\n\\t\\tif move < 0 {\\n\\t\\t\\tmove = (26 - (-move)%26) % 26\\n\\t\\t}\\n\\t\\tmove %= 26\\n\\t\\tnc := c + rune(move)\\n\\t\\tif nc > \\'z\\' {\\n\\t\\t\\tnc -= 26\\n\\t\\t}\\n\\t\\tbb.WriteRune(nc)\\n\\t}\\n\\treturn bb.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2752763,
                "title": "python-prefix-sum-solution-o-n-time",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        sz, sm, prefix, s = len(s), 0, [0] * (len(s) + 1), list(s)\\n        for shift in shifts:\\n            left, right = shift[0], shift[1]\\n            if shift[2] == 0:\\n                prefix[left] -= 1\\n                prefix[right + 1] += 1\\n            else:\\n                prefix[left] += 1\\n                prefix[right + 1] -= 1\\n        for i in range(sz):\\n            sm += prefix[i]\\n            amountOfShift = (ord(s[i]) - ord(\\'a\\') + (sm % 26) + 26) % 26\\n            s[i] = chr(ord(\\'a\\') + amountOfShift)\\n        return \\'\\'.join(s)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        sz, sm, prefix, s = len(s), 0, [0] * (len(s) + 1), list(s)\\n        for shift in shifts:\\n            left, right = shift[0], shift[1]\\n            if shift[2] == 0:\\n                prefix[left] -= 1\\n                prefix[right + 1] += 1\\n            else:\\n                prefix[left] += 1\\n                prefix[right + 1] -= 1\\n        for i in range(sz):\\n            sm += prefix[i]\\n            amountOfShift = (ord(s[i]) - ord(\\'a\\') + (sm % 26) + 26) % 26\\n            s[i] = chr(ord(\\'a\\') + amountOfShift)\\n        return \\'\\'.join(s)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732749,
                "title": "ruby-solution",
                "content": "```ruby\\n# @param {String} s\\n# @param {Integer[][]} shifts\\n# @return {String}\\ndef shifting_letters(s, shifts)\\n  arr = Array.new( s.length + 1, 0 )\\n  \\n  shifts.each do |start_index, end_index, step|\\n    arr[ start_index ] += step * 2 - 1\\n    arr[ end_index + 1] -= step * 2 - 1\\n  end\\n\\n  change = 0\\n  s.each_char.with_index do |char, index|\\n    change += arr[index]\\n    s[index] = ((char.ord - 97 + change) % 26 + 97).chr\\n  end\\n  \\nend\\n```",
                "solutionTags": [],
                "code": "```ruby\\n# @param {String} s\\n# @param {Integer[][]} shifts\\n# @return {String}\\ndef shifting_letters(s, shifts)\\n  arr = Array.new( s.length + 1, 0 )\\n  \\n  shifts.each do |start_index, end_index, step|\\n    arr[ start_index ] += step * 2 - 1\\n    arr[ end_index + 1] -= step * 2 - 1\\n  end\\n\\n  change = 0\\n  s.each_char.with_index do |char, index|\\n    change += arr[index]\\n    s[index] = ((char.ord - 97 + change) % 26 + 97).chr\\n  end\\n  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2668723,
                "title": "python3-line-sweep",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        sz=len(s)\\n        freq=[0 for i in range(sz+1)]\\n        for a,b,c in shifts:\\n            if c==1:\\n                freq[a]+=1\\n                freq[b+1]-=1\\n            else:\\n                freq[a]-=1\\n                freq[b+1]+=1\\n        for i in range(sz+1):\\n            freq[i]=freq[i-1]+freq[i] if i>=1 else freq[i]\\n        s=list(s)\\n        for i in range(sz):\\n            s[i]=chr(((ord(s[i])+freq[i]-97)%26)+97)\\n        return \"\".join(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        sz=len(s)\\n        freq=[0 for i in range(sz+1)]\\n        for a,b,c in shifts:\\n            if c==1:\\n                freq[a]+=1\\n                freq[b+1]-=1\\n            else:\\n                freq[a]-=1\\n                freq[b+1]+=1\\n        for i in range(sz+1):\\n            freq[i]=freq[i-1]+freq[i] if i>=1 else freq[i]\\n        s=list(s)\\n        for i in range(sz):\\n            s[i]=chr(((ord(s[i])+freq[i]-97)%26)+97)\\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668634,
                "title": "c-prefix-sum-simple",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tvector<int> preSum(n+1,0);\\n\\t\\t\\tfor(auto it : shifts){\\n\\t\\t\\t\\tint st = it[0] , e = it[1];\\n\\t\\t\\t\\tint d = it[2];\\n\\t\\t\\t\\tif(d) {\\n\\t\\t\\t\\t\\tpreSum[st] += 1;\\n\\t\\t\\t\\t\\tpreSum[e+1] += (-1);\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tpreSum[st] += (-1);\\n\\t\\t\\t\\t\\tpreSum[e+1] += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\t\\t\\tsum += preSum[i];\\n\\t\\t\\t\\tint val = (s[i] - \\'a\\' + sum%26 + 26) % 26;\\n\\t\\t\\t\\ts[i] = \\'a\\' + val;\\n\\t\\t\\t}\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tvector<int> preSum(n+1,0);\\n\\t\\t\\tfor(auto it : shifts){\\n\\t\\t\\t\\tint st = it[0] , e = it[1];\\n\\t\\t\\t\\tint d = it[2];\\n\\t\\t\\t\\tif(d) {\\n\\t\\t\\t\\t\\tpreSum[st] += 1;\\n\\t\\t\\t\\t\\tpreSum[e+1] += (-1);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2642136,
                "title": "easy-js-solution-with-diagram",
                "content": "**Approach 1**: O(n ^2)\\n\\n```\\nvar shiftingLetters = function(s, shifts) {\\n\\tlet n = s.length;\\n    let pfx = new Array(n).fill(0);\\n    \\n    for(let i = 0; i < shifts.length; i++) {\\n        let [start, end, dir] = shifts[i];\\n        \\n        for(let j = start; j <= end; j++) {\\n            \\n            if(dir === 1) {\\n                pfx[j] += 1;\\n            } else {\\n                pfx[j] -= 1;\\n            }\\n            \\n        }\\n    }\\n    \\n    let str = \"\";\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let t = s[i].charCodeAt(0) - 97;\\n        let tsign = t + pfx[i] < 0 ? 26 + (t + pfx[i]) % 26: t + pfx[i];\\n        let code = 97 + tsign % 26;\\n        let ch = String.fromCharCode(code);\\n        str += ch;\\n    }\\n    \\n    return str;\\n}\\n```\\n\\n**Approach 2**: O(n)\\n```\\nvar shiftingLetters = function(s, shifts) {\\n\\tlet n = s.length;\\n    let pfx = new Array(n + 1).fill(0);\\n    \\n    for(let i = 0; i < shifts.length; i++) {\\n        let [start, end, dir] = shifts[i];\\n        \\n        if(dir === 1) {\\n            pfx[start] += 1;\\n            pfx[end + 1] -= 1; \\n        } else {\\n            pfx[start] -= 1;\\n            pfx[end + 1] += 1;\\n        }\\n        \\n    }\\n    \\n    for(let i = 1; i < pfx.length; i++) {\\n        pfx[i] += pfx[i - 1];\\n    }\\n    \\n    let str = \"\";\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let t = s[i].charCodeAt(0) - 97;\\n        let tsign = t + pfx[i] < 0 ? 26 + (t + pfx[i]) % 26: t + pfx[i];\\n        let code = 97 + tsign % 26;\\n        let ch = String.fromCharCode(code);\\n        str += ch;\\n    }\\n    \\n    return str;\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/4727f50b-c129-4be0-8a66-30f44ba6c508_1664537717.8534641.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\nvar shiftingLetters = function(s, shifts) {\\n\\tlet n = s.length;\\n    let pfx = new Array(n).fill(0);\\n    \\n    for(let i = 0; i < shifts.length; i++) {\\n        let [start, end, dir] = shifts[i];\\n        \\n        for(let j = start; j <= end; j++) {\\n            \\n            if(dir === 1) {\\n                pfx[j] += 1;\\n            } else {\\n                pfx[j] -= 1;\\n            }\\n            \\n        }\\n    }\\n    \\n    let str = \"\";\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let t = s[i].charCodeAt(0) - 97;\\n        let tsign = t + pfx[i] < 0 ? 26 + (t + pfx[i]) % 26: t + pfx[i];\\n        let code = 97 + tsign % 26;\\n        let ch = String.fromCharCode(code);\\n        str += ch;\\n    }\\n    \\n    return str;\\n}\\n```\n```\\nvar shiftingLetters = function(s, shifts) {\\n\\tlet n = s.length;\\n    let pfx = new Array(n + 1).fill(0);\\n    \\n    for(let i = 0; i < shifts.length; i++) {\\n        let [start, end, dir] = shifts[i];\\n        \\n        if(dir === 1) {\\n            pfx[start] += 1;\\n            pfx[end + 1] -= 1; \\n        } else {\\n            pfx[start] -= 1;\\n            pfx[end + 1] += 1;\\n        }\\n        \\n    }\\n    \\n    for(let i = 1; i < pfx.length; i++) {\\n        pfx[i] += pfx[i - 1];\\n    }\\n    \\n    let str = \"\";\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let t = s[i].charCodeAt(0) - 97;\\n        let tsign = t + pfx[i] < 0 ? 26 + (t + pfx[i]) % 26: t + pfx[i];\\n        let code = 97 + tsign % 26;\\n        let ch = String.fromCharCode(code);\\n        str += ch;\\n    }\\n    \\n    return str;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2605876,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] sol = s.toCharArray();\\n        int[] pref = new int[s.length()+1];\\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            pref[shift[0]] += value;\\n            pref[shift[1] + 1] -= value;\\n        }\\n        int sum = 0;\\n        for(int i=0;i<pref.length-1;i++){\\n            sum += pref[i];\\n            int n = ((sol[i]-\\'a\\')+sum) % 26;\\n            if(n<0) n += 26;\\n            sol[i] =  (char)(\\'a\\'+n);\\n        }\\n        return String.valueOf(sol);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] sol = s.toCharArray();\\n        int[] pref = new int[s.length()+1];\\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            pref[shift[0]] += value;\\n            pref[shift[1] + 1] -= value;\\n        }\\n        int sum = 0;\\n        for(int i=0;i<pref.length-1;i++){\\n            sum += pref[i];\\n            int n = ((sol[i]-\\'a\\')+sum) % 26;\\n            if(n<0) n += 26;\\n            sol[i] =  (char)(\\'a\\'+n);\\n        }\\n        return String.valueOf(sol);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596771,
                "title": "python-cumulative-shift-deltas",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, st: str, shifts: List[List[int]]) -> str:\\n        \\n        deltas = [0] * (len(st) + 1)\\n        # deltas = dict()\\n        for s, e, d in shifts:\\n            d = (d << 1) - 1\\n            deltas[s] += d\\n            deltas[e + 1] -= d\\n\\n        \\n        shifted = []\\n        cur_shift = 0\\n        for delta, letter in zip(deltas, st):\\n            cur_shift += delta\\n            if cur_shift != 0:\\n                letter = chr(97 + (ord(letter) - 97 + cur_shift) % 26)\\n            shifted.append(letter)\\n                \\n        return \"\".join(shifted)\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, st: str, shifts: List[List[int]]) -> str:\\n        \\n        deltas = [0] * (len(st) + 1)\\n        # deltas = dict()\\n        for s, e, d in shifts:\\n            d = (d << 1) - 1\\n            deltas[s] += d\\n            deltas[e + 1] -= d\\n\\n        \\n        shifted = []\\n        cur_shift = 0\\n        for delta, letter in zip(deltas, st):\\n            cur_shift += delta\\n            if cur_shift != 0:\\n                letter = chr(97 + (ord(letter) - 97 + cur_shift) % 26)\\n            shifted.append(letter)\\n                \\n        return \"\".join(shifted)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572585,
                "title": "prefix-sum-ascii",
                "content": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int size = shifts.size();\\n        int n= s.size();\\n        vector<int> v(n+1,0);\\n        for(int i=0;i<size;i++){\\n          int start = shifts[i][0];\\n          int end = shifts[i][1];\\n          int direction = shifts[i][2];\\n          if(direction == 1){\\n            v[start] +=  1;\\n           v[end+1] += -1; \\n          }\\n          else{\\n            v[start] +=-1;\\n            v[end+1] +=1;\\n          }\\n        }\\n        for(int i=1;i<n;i++){\\n          v[i]+=v[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n          v[i] = v[i]%26;\\n        }\\n        for(int i=0;i<n;i++){\\n          int x = s[i]-\\'a\\';\\n          v[i]+=x;\\n          v[i] = v[i]%26;\\n            if(v[i]<0){\\n            v[i]= 26+v[i];\\n          }\\n          cout<<v[i]<<\" \";\\n        }\\n        string res = \"\";\\n        for(int i=0;i<n;i++){\\n          res+=v[i]+\\'a\\';\\n        }\\n\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int size = shifts.size();\\n        int n= s.size();\\n        vector<int> v(n+1,0);\\n        for(int i=0;i<size;i++){\\n          int start = shifts[i][0];\\n          int end = shifts[i][1];\\n          int direction = shifts[i][2];\\n          if(direction == 1){\\n            v[start] +=  1;\\n           v[end+1] += -1; \\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2559073,
                "title": "c-line-sweep-solution",
                "content": "```\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int len=s.length();\\n        vector<int> dir(len+1, 0);\\n        for(auto &shift: shifts){\\n            int start=shift[0], end=shift[1], job=(shift[2]==1)?1:-1;\\n            if(job==1)\\n                dir[start]++, dir[end+1]--;\\n            else\\n                dir[start]--, dir[end+1]++;\\n        }\\n        long long job=0;\\n        for(int i=0; i<len; i++){\\n            job+=dir[i];\\n            s[i]=((s[i]-\\'a\\')+job+260000000LL)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int len=s.length();\\n        vector<int> dir(len+1, 0);\\n        for(auto &shift: shifts){\\n            int start=shift[0], end=shift[1], job=(shift[2]==1)?1:-1;\\n            if(job==1)\\n                dir[start]++, dir[end+1]--;\\n            else\\n                dir[start]--, dir[end+1]++;\\n        }\\n        long long job=0;\\n        for(int i=0; i<len; i++){\\n            job+=dir[i];\\n            s[i]=((s[i]-\\'a\\')+job+260000000LL)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2525964,
                "title": "c-segment-tree-solution",
                "content": "```\\nint64_t e_group_op = 0;\\n\\nstruct treeNode {\\n    treeNode() : s(0), g(e_group_op), num(1) {}\\n\\ttreeNode (int64_t val, int64_t g_val=e_group_op, int n=1) : s(val), g(g_val), num(n) {}\\n    int64_t s, g;\\n    int num;\\n};\\n\\ntreeNode e_op = {0, e_group_op, 0};\\n\\n\\nvoid group_op(treeNode& x, int64_t val) {\\n    // x.g += val;\\n    // x.s += val * x.num;\\n    // ----------------------------------\\n    // if (x.g < val) x.s = x.g = val;\\n    // ----------------------------------\\n    x.g += val;\\n    x.s = x.g;\\n}\\n\\ntreeNode main_tree_op(const treeNode& x, const treeNode& y) {\\n    return treeNode(x.s + y.s, e_group_op, x.num + y.num);\\n    // ------------------------------------------------------\\n    // return treeNode(max(x.s, y.s));\\n}\\n\\n\\nclass segmentTree {\\nprivate:\\n    bool rightInclude;\\n\\n    int upper_power2(int x) {\\n        int power2 = 1;\\n        while (power2 < x) {\\n            power2 *= 2;\\n        }\\n        return power2;\\n    }\\n\\n    int n, N;\\n\\npublic:\\n    vector<treeNode> tree;\\n    segmentTree() {}\\n    segmentTree(vector<int>& arr, bool rightInclusive=false, bool initialize=true) {\\n        rightInclude = rightInclusive;\\n        n = arr.size();\\n        N = 2 * upper_power2(n) - 1;\\n        tree.assign(N, e_op);\\n        if (initialize) {\\n            for (int i = 0; i < n; ++i) {\\n                tree[N / 2 + i] = arr[i];\\n            }\\n            for (int x = N - 1; x > 1; x -= 2) {\\n                tree[(x - 1) / 2] = main_tree_op(tree[x], tree[x - 1]);\\n            }            \\n        }\\n    }\\n\\n    void propagate(int x, int lx, int rx) {\\n        if (rx - lx == 1 || tree[x].g == e_group_op) return;\\n        group_op(tree[2 * x + 1], tree[x].g);\\n        group_op(tree[2 * x + 2], tree[x].g);\\n        tree[x].g = e_group_op;\\n    }\\n\\n    void set(int i, int64_t v, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) rx = N / 2 + 1;            \\n        propagate(x, lx, rx);\\n        if (rx - lx == 1) {\\n            tree[x].s = v;\\n            return;\\n        }\\n        int m = (rx + lx) / 2;\\n        if (i < m) {\\n            set(i, v, 2 * x + 1, lx, m);\\n        } else {\\n            set(i, v, 2 * x + 2, m, rx);\\n        }\\n        tree[x] = main_tree_op(tree[2 * x + 1], tree[2 * x + 2]);\\n    }\\n\\n    int64_t query(int l, int r, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) {\\n            rx = N / 2 + 1;\\n            if (rightInclude) r += 1;\\n        }\\n\\n        propagate(x, lx, rx);\\n\\n        if (lx >= r || l >= rx) return e_op.s;\\n        if (lx >= l && rx <= r) return tree[x].s;\\n        int m = (rx + lx) / 2;\\n        int64_t ans_l = query(l, r, 2 * x + 1, lx, m);\\n        int64_t ans_r = query(l, r, 2 * x + 2, m, rx);\\n        return main_tree_op(ans_l, ans_r).s;\\n    }\\n\\n    void group_change(int l, int r, int64_t group_val, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) {\\n            rx = N / 2 + 1;\\n            if (rightInclude) r += 1;\\n        }\\n\\n        propagate(x, lx, rx);\\n\\n        if (lx >= r || l >= rx) return;\\n        if (lx >= l && rx <= r) {\\n            group_op(tree[x], group_val);\\n            return;\\n        }\\n        int m = (rx + lx) / 2;\\n        group_change(l, r, group_val, 2 * x + 1, lx, m);\\n        group_change(l, r, group_val, 2 * x + 2, m, rx);\\n        tree[x] = main_tree_op(tree[2 * x + 1], tree[2 * x + 2]);\\n    }\\n    \\n    void print() {\\n        for (int i = 0; i < tree.size(); ++i) {\\n            cout << \"\\\\\"\" << tree[i].s << \"|\" << tree[i].g << \"\\\\\"\" << \", \";\\n        }\\n        cout << endl;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    segmentTree st;\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> tmp(s.size());\\n        st = segmentTree(tmp, true, false);\\n        int dir;\\n        for (int i = 0; i < shifts.size(); ++i) {\\n            dir = (shifts[i][2] == 0) ? -1 : 1;\\n            st.group_change(shifts[i][0], shifts[i][1], dir);\\n        }\\n        for (int i = 0; i < s.size(); ++i) {\\n            s[i] = (((s[i] - \\'a\\' + st.query(i, i)) % 26) + 26) % 26 + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint64_t e_group_op = 0;\\n\\nstruct treeNode {\\n    treeNode() : s(0), g(e_group_op), num(1) {}\\n\\ttreeNode (int64_t val, int64_t g_val=e_group_op, int n=1) : s(val), g(g_val), num(n) {}\\n    int64_t s, g;\\n    int num;\\n};\\n\\ntreeNode e_op = {0, e_group_op, 0};\\n\\n\\nvoid group_op(treeNode& x, int64_t val) {\\n    // x.g += val;\\n    // x.s += val * x.num;\\n    // ----------------------------------\\n    // if (x.g < val) x.s = x.g = val;\\n    // ----------------------------------\\n    x.g += val;\\n    x.s = x.g;\\n}\\n\\ntreeNode main_tree_op(const treeNode& x, const treeNode& y) {\\n    return treeNode(x.s + y.s, e_group_op, x.num + y.num);\\n    // ------------------------------------------------------\\n    // return treeNode(max(x.s, y.s));\\n}\\n\\n\\nclass segmentTree {\\nprivate:\\n    bool rightInclude;\\n\\n    int upper_power2(int x) {\\n        int power2 = 1;\\n        while (power2 < x) {\\n            power2 *= 2;\\n        }\\n        return power2;\\n    }\\n\\n    int n, N;\\n\\npublic:\\n    vector<treeNode> tree;\\n    segmentTree() {}\\n    segmentTree(vector<int>& arr, bool rightInclusive=false, bool initialize=true) {\\n        rightInclude = rightInclusive;\\n        n = arr.size();\\n        N = 2 * upper_power2(n) - 1;\\n        tree.assign(N, e_op);\\n        if (initialize) {\\n            for (int i = 0; i < n; ++i) {\\n                tree[N / 2 + i] = arr[i];\\n            }\\n            for (int x = N - 1; x > 1; x -= 2) {\\n                tree[(x - 1) / 2] = main_tree_op(tree[x], tree[x - 1]);\\n            }            \\n        }\\n    }\\n\\n    void propagate(int x, int lx, int rx) {\\n        if (rx - lx == 1 || tree[x].g == e_group_op) return;\\n        group_op(tree[2 * x + 1], tree[x].g);\\n        group_op(tree[2 * x + 2], tree[x].g);\\n        tree[x].g = e_group_op;\\n    }\\n\\n    void set(int i, int64_t v, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) rx = N / 2 + 1;            \\n        propagate(x, lx, rx);\\n        if (rx - lx == 1) {\\n            tree[x].s = v;\\n            return;\\n        }\\n        int m = (rx + lx) / 2;\\n        if (i < m) {\\n            set(i, v, 2 * x + 1, lx, m);\\n        } else {\\n            set(i, v, 2 * x + 2, m, rx);\\n        }\\n        tree[x] = main_tree_op(tree[2 * x + 1], tree[2 * x + 2]);\\n    }\\n\\n    int64_t query(int l, int r, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) {\\n            rx = N / 2 + 1;\\n            if (rightInclude) r += 1;\\n        }\\n\\n        propagate(x, lx, rx);\\n\\n        if (lx >= r || l >= rx) return e_op.s;\\n        if (lx >= l && rx <= r) return tree[x].s;\\n        int m = (rx + lx) / 2;\\n        int64_t ans_l = query(l, r, 2 * x + 1, lx, m);\\n        int64_t ans_r = query(l, r, 2 * x + 2, m, rx);\\n        return main_tree_op(ans_l, ans_r).s;\\n    }\\n\\n    void group_change(int l, int r, int64_t group_val, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) {\\n            rx = N / 2 + 1;\\n            if (rightInclude) r += 1;\\n        }\\n\\n        propagate(x, lx, rx);\\n\\n        if (lx >= r || l >= rx) return;\\n        if (lx >= l && rx <= r) {\\n            group_op(tree[x], group_val);\\n            return;\\n        }\\n        int m = (rx + lx) / 2;\\n        group_change(l, r, group_val, 2 * x + 1, lx, m);\\n        group_change(l, r, group_val, 2 * x + 2, m, rx);\\n        tree[x] = main_tree_op(tree[2 * x + 1], tree[2 * x + 2]);\\n    }\\n    \\n    void print() {\\n        for (int i = 0; i < tree.size(); ++i) {\\n            cout << \"\\\\\"\" << tree[i].s << \"|\" << tree[i].g << \"\\\\\"\" << \", \";\\n        }\\n        cout << endl;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    segmentTree st;\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> tmp(s.size());\\n        st = segmentTree(tmp, true, false);\\n        int dir;\\n        for (int i = 0; i < shifts.size(); ++i) {\\n            dir = (shifts[i][2] == 0) ? -1 : 1;\\n            st.group_change(shifts[i][0], shifts[i][1], dir);\\n        }\\n        for (int i = 0; i < s.size(); ++i) {\\n            s[i] = (((s[i] - \\'a\\' + st.query(i, i)) % 26) + 26) % 26 + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2514522,
                "title": "c-easy-solution-line-sweep-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<pair<int,int>>v(s.size()+1);\\n        //{no_of_zeroes,no_of_ones}\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==0)\\n            {\\n                v[shifts[i][0]].first++;\\n                v[shifts[i][1]+1].first--;\\n            }\\n            else\\n            {\\n                v[shifts[i][0]].second++;\\n                v[shifts[i][1]+1].second--;\\n            }\\n        }\\n        string ans;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            v[i].first+=v[i-1].first;\\n            v[i].second+=v[i-1].second;\\n        }\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            int y = s[i]-\\'a\\';\\n            int u = (v[i].first)%26;\\n            char t = 0;\\n            if(u>y)\\n            {\\n                int ko = u-y;\\n                int mk = 26-ko;\\n                t=\\'a\\'+mk;\\n            }\\n            else\\n            {\\n                int lo = y-u;\\n                t=\\'a\\'+lo;\\n            }\\n            int ji = ((t-\\'a\\')+v[i].second)%26;\\n            char ll = ji+\\'a\\';\\n            ans.push_back(ll);\\n        }\\n        for(int i=ans.size();i<s.size();i++)\\n        {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<pair<int,int>>v(s.size()+1);\\n        //{no_of_zeroes,no_of_ones}\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==0)\\n            {\\n                v[shifts[i][0]].first++;\\n                v[shifts[i][1]+1].first--;\\n            }\\n            else\\n            {\\n                v[shifts[i][0]].second++;\\n                v[shifts[i][1]+1].second--;\\n            }\\n        }\\n        string ans;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            v[i].first+=v[i-1].first;\\n            v[i].second+=v[i-1].second;\\n        }\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            int y = s[i]-\\'a\\';\\n            int u = (v[i].first)%26;\\n            char t = 0;\\n            if(u>y)\\n            {\\n                int ko = u-y;\\n                int mk = 26-ko;\\n                t=\\'a\\'+mk;\\n            }\\n            else\\n            {\\n                int lo = y-u;\\n                t=\\'a\\'+lo;\\n            }\\n            int ji = ((t-\\'a\\')+v[i].second)%26;\\n            char ll = ji+\\'a\\';\\n            ans.push_back(ll);\\n        }\\n        for(int i=ans.size();i<s.size();i++)\\n        {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513237,
                "title": "o-n-time-o-n-space-clear-explanation-also-1943-1854-1094-1109",
                "content": "![image](https://assets.leetcode.com/users/images/91060c43-2af3-4c4d-a4ca-e18b8ec12e2d_1662024192.9286475.png)\\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\" O(N)TS \"\"\"\\n        line = collections.Counter()\\n        [line.update({a: 1, b + 1: -1}) if c else line.update({a: -1, b + 1: 1}) for a, b, c in shifts]\\n        acc = list(itertools.accumulate([line[i] for i in range(len(s))]))\\n        ans = (chr((ord(c) - 97 + i) % 26 + 97) for c, i in zip(s, acc))\\n        return \\'\\'.join(ans)",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/91060c43-2af3-4c4d-a4ca-e18b8ec12e2d_1662024192.9286475.png)\\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\" O(N)TS \"\"\"\\n        line = collections.Counter()\\n        [line.update({a: 1, b + 1: -1}) if c else line.update({a: -1, b + 1: 1}) for a, b, c in shifts]\\n        acc = list(itertools.accumulate([line[i] for i in range(len(s))]))\\n        ans = (chr((ord(c) - 97 + i) % 26 + 97) for c, i in zip(s, acc))\\n        return \\'\\'.join(ans)",
                "codeTag": "Python3"
            },
            {
                "id": 2495789,
                "title": "c",
                "content": "**Bucket**\\nSimilar to: https://leetcode.com/problems/meeting-rooms-ii/discuss/2135429/four-cpp-methods (First Method and follow up)\\n```\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> bucket(s.size() + 1, 0);\\n        for (auto& it: shifts){\\n            if (it[2] == 1){\\n                bucket[it[0]] ++;\\n                bucket[it[1] + 1] --;\\n            }else{\\n                bucket[it[0]] --;\\n                bucket[it[1] + 1] ++;\\n            }\\n        }\\n        \\n        int accumulate = 0;\\n        string ans = \"\";\\n        for (int i = 0; i < s.size(); ++ i){\\n            accumulate += bucket[i];\\n            \\n            int temp = (accumulate % 26 + 26) % 26;\\n            if (temp > \\'z\\' - s[i]){\\n                ans += \\'a\\' + temp - \\'z\\' + s[i] - 1;\\n            }else{\\n                ans += s[i] + temp;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> bucket(s.size() + 1, 0);\\n        for (auto& it: shifts){\\n            if (it[2] == 1){\\n                bucket[it[0]] ++;\\n                bucket[it[1] + 1] --;\\n            }else{\\n                bucket[it[0]] --;\\n                bucket[it[1] + 1] ++;\\n            }\\n        }\\n        \\n        int accumulate = 0;\\n        string ans = \"\";\\n        for (int i = 0; i < s.size(); ++ i){\\n            accumulate += bucket[i];\\n            \\n            int temp = (accumulate % 26 + 26) % 26;\\n            if (temp > \\'z\\' - s[i]){\\n                ans += \\'a\\' + temp - \\'z\\' + s[i] - 1;\\n            }else{\\n                ans += s[i] + temp;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2495654,
                "title": "very-easy-java-solution-using-prefixsum",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n=s.length();\\n        int[] preSum=new int[n+1];\\n        for(int[] shift: shifts){\\n            int start=shift[0];\\n            int end=shift[1];\\n            int dir=shift[2];\\n            if(dir==0){\\n                preSum[start]--;\\n                preSum[end+1]++;\\n            }\\n            else{\\n                preSum[start]++;\\n                preSum[end+1]--;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            preSum[i]+=preSum[i-1];\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<n;i++){\\n            char ch=s.charAt(i);\\n            int shift=preSum[i];\\n            ch=(char)(((ch-\\'a\\'+shift)%26+26)%26+\\'a\\');\\n            sb.append(ch);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n=s.length();\\n        int[] preSum=new int[n+1];\\n        for(int[] shift: shifts){\\n            int start=shift[0];\\n            int end=shift[1];\\n            int dir=shift[2];\\n            if(dir==0){\\n                preSum[start]--;\\n                preSum[end+1]++;\\n            }\\n            else{\\n                preSum[start]++;\\n                preSum[end+1]--;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            preSum[i]+=preSum[i-1];\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<n;i++){\\n            char ch=s.charAt(i);\\n            int shift=preSum[i];\\n            ch=(char)(((ch-\\'a\\'+shift)%26+26)%26+\\'a\\');\\n            sb.append(ch);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490446,
                "title": "c-prefix-sum",
                "content": "```\\n  string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int>v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int a=shifts[i][0];\\n            int b=shifts[i][1];\\n            int c=shifts[i][2];\\n            \\n            if(c==0){\\n                v[a]--;\\n                v[b+1]++;\\n            }else{\\n                v[a]++;\\n                v[b+1]--;\\n            }\\n        }\\n        \\n        \\n        \\n        for(int i=1;i<v.size();i++){\\n            v[i]=v[i]+v[i-1];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            \\n            \\n            int ind= s[i]-\\'a\\';\\n            ind=(ind+v[i])%26;\\n            \\n            if(ind<0){\\n                ind=ind+26;\\n            }\\n            char nextChar = \\'a\\'+ind;\\n            s[i]=nextChar;\\n            \\n        \\n            \\n        }\\n        return s;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int>v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int a=shifts[i][0];\\n            int b=shifts[i][1];\\n            int c=shifts[i][2];\\n            \\n            if(c==0){\\n                v[a]--;\\n                v[b+1]++;\\n            }else{\\n                v[a]++;\\n                v[b+1]--;\\n            }\\n        }\\n        \\n        \\n        \\n        for(int i=1;i<v.size();i++){\\n            v[i]=v[i]+v[i-1];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            \\n            \\n            int ind= s[i]-\\'a\\';\\n            ind=(ind+v[i])%26;\\n            \\n            if(ind<0){\\n                ind=ind+26;\\n            }\\n            char nextChar = \\'a\\'+ind;\\n            s[i]=nextChar;\\n            \\n        \\n            \\n        }\\n        return s;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2489403,
                "title": "c-easy-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> v(n, 0);//for storing from which index to which index forward or backward operation takes place\\n        for(int i=0;i<shifts.size();i++){\\n            if(shifts[i][2]){\\n                //forward operation\\n                if(shifts[i][1]+1<n){\\n                    v[shifts[i][1]+1]-=1;\\n                }\\n                v[shifts[i][0]] += 1;\\n            }\\n            else{\\n                //backward operation\\n                if(shifts[i][1]+1<n){\\n                    v[shifts[i][1]+1]+=1;\\n                }\\n                v[shifts[i][0]] -= 1;\\n            }\\n        }\\n        //summing up everything to we will know what operation to do and howmany times we should do\\n        int num=v[0];\\n        for(int i=1;i<n;i++){\\n            v[i] += v[i-1];\\n        }\\n        //converting the character\\n        for (int j = 0; j < s.size(); j++) {\\n\\t\\t\\tint num = s[j] - \\'a\\';\\n\\t\\t\\tnum += v[j];\\n            num %= 26;\\n            num += 26;\\n\\t\\t\\tnum %= 26;\\n\\t\\t\\ts[j] = \\'a\\' + num;\\n\\t\\t}\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> v(n, 0);//for storing from which index to which index forward or backward operation takes place\\n        for(int i=0;i<shifts.size();i++){\\n            if(shifts[i][2]){\\n                //forward operation\\n                if(shifts[i][1]+1<n){\\n                    v[shifts[i][1]+1]-=1;\\n                }\\n                v[shifts[i][0]] += 1;\\n            }\\n            else{\\n                //backward operation\\n                if(shifts[i][1]+1<n){\\n                    v[shifts[i][1]+1]+=1;\\n                }\\n                v[shifts[i][0]] -= 1;\\n            }\\n        }\\n        //summing up everything to we will know what operation to do and howmany times we should do\\n        int num=v[0];\\n        for(int i=1;i<n;i++){\\n            v[i] += v[i-1];\\n        }\\n        //converting the character\\n        for (int j = 0; j < s.size(); j++) {\\n\\t\\t\\tint num = s[j] - \\'a\\';\\n\\t\\t\\tnum += v[j];\\n            num %= 26;\\n            num += 26;\\n\\t\\t\\tnum %= 26;\\n\\t\\t\\ts[j] = \\'a\\' + num;\\n\\t\\t}\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489120,
                "title": "c-recursive-solution-simple-bruteforce-o-n-2",
                "content": "```\\n\\nclass Solution {\\n    int traversal=0;\\n     int veci=0;\\n       \\npublic:\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // AlphaBet Pushed\\n        vector<char> alpha;\\n        alpha.push_back(\\'z\\');\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            alpha.push_back(i);\\n        }\\n        alpha.push_back(\\'a\\');\\n        \\n        //Base case\\n        int row = shifts.size();\\n         if(veci==row){\\n             return s;\\n         }\\n        //rec case\\n            for(int i=shifts[veci][0];i<=shifts[veci][1];i++){\\n                  int idx = find(alpha.begin()+1,alpha.end()-1,s[i])-alpha.begin();\\n                  if(shifts[veci][2]==0){\\n                     s[i]= alpha[idx-1] ;\\n                  }\\n                  else if(shifts[veci][2]==1){\\n                      s[i]= alpha[idx+1] ;\\n                  } \\n            }\\n            veci++;\\n        return  shiftingLetters(s,shifts) ;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    int traversal=0;\\n     int veci=0;\\n       \\npublic:\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // AlphaBet Pushed\\n        vector<char> alpha;\\n        alpha.push_back(\\'z\\');\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            alpha.push_back(i);\\n        }\\n        alpha.push_back(\\'a\\');\\n        \\n        //Base case\\n        int row = shifts.size();\\n         if(veci==row){\\n             return s;\\n         }\\n        //rec case\\n            for(int i=shifts[veci][0];i<=shifts[veci][1];i++){\\n                  int idx = find(alpha.begin()+1,alpha.end()-1,s[i])-alpha.begin();\\n                  if(shifts[veci][2]==0){\\n                     s[i]= alpha[idx-1] ;\\n                  }\\n                  else if(shifts[veci][2]==1){\\n                      s[i]= alpha[idx+1] ;\\n                  } \\n            }\\n            veci++;\\n        return  shiftingLetters(s,shifts) ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2029012,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "Tips: line sweep:\\n- for left:  add -1 at index shift[0] and +1 at index shift[1] +1 (and reverse for right direction).\\n- traverse each index and apply prefix sum shift for each character."
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "A hint : \\nTry one of the Prefix sum techniques used for range : Line Sweep or Fenwick Tree"
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "The test cases given here do not justify the detailed problem as to what the question is expecting. Kindly look into this Leetcode and try to add one or two more detailed test cases."
                    }
                ]
            },
            {
                "id": 1925903,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "Tips: line sweep:\\n- for left:  add -1 at index shift[0] and +1 at index shift[1] +1 (and reverse for right direction).\\n- traverse each index and apply prefix sum shift for each character."
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "A hint : \\nTry one of the Prefix sum techniques used for range : Line Sweep or Fenwick Tree"
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "The test cases given here do not justify the detailed problem as to what the question is expecting. Kindly look into this Leetcode and try to add one or two more detailed test cases."
                    }
                ]
            },
            {
                "id": 1925899,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "Tips: line sweep:\\n- for left:  add -1 at index shift[0] and +1 at index shift[1] +1 (and reverse for right direction).\\n- traverse each index and apply prefix sum shift for each character."
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "A hint : \\nTry one of the Prefix sum techniques used for range : Line Sweep or Fenwick Tree"
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "The test cases given here do not justify the detailed problem as to what the question is expecting. Kindly look into this Leetcode and try to add one or two more detailed test cases."
                    }
                ]
            }
        ]
    }
]