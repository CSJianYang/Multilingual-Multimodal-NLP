[
    {
        "title": "Words Within Two Edits of Dictionary",
        "question_content": "You are given two string arrays, queries and dictionary. All words in each array comprise of lowercase English letters and have the same length.\nIn one edit you can take a word from queries, and change any letter in it to any other letter. Find all words from queries that, after a maximum of two edits, equal some word from dictionary.\nReturn a list of all words from queries, that match with some word from dictionary after a maximum of two edits. Return the words in the same order they appear in queries.\n&nbsp;\nExample 1:\n\nInput: queries = [\"word\",\"note\",\"ants\",\"wood\"], dictionary = [\"wood\",\"joke\",\"moat\"]\nOutput: [\"word\",\"note\",\"wood\"]\nExplanation:\n- Changing the 'r' in \"word\" to 'o' allows it to equal the dictionary word \"wood\".\n- Changing the 'n' to 'j' and the 't' to 'k' in \"note\" changes it to \"joke\".\n- It would take more than 2 edits for \"ants\" to equal a dictionary word.\n- \"wood\" can remain unchanged (0 edits) and match the corresponding dictionary word.\nThus, we return [\"word\",\"note\",\"wood\"].\n\nExample 2:\n\nInput: queries = [\"yes\"], dictionary = [\"not\"]\nOutput: []\nExplanation:\nApplying any two edits to \"yes\" cannot make it equal to \"not\". Thus, we return an empty array.\n\n&nbsp;\nConstraints:\n\n\t1 <= queries.length, dictionary.length <= 100\n\tn == queries[i].length == dictionary[j].length\n\t1 <= n <= 100\n\tAll queries[i] and dictionary[j] are composed of lowercase English letters.",
        "solutions": [
            {
                "id": 2756369,
                "title": "trie-vs-hamming-distance",
                "content": "If we try to generate all edits and check against the dictionary, you will get TLE even with these somewhat lower constraints.\\n\\nWe can compute the Hamming distance between a query and each dictionary word for O(n ^ 2) solution.\\n\\nAlso, Trie is a good data structure to do dictionary search with skips. The Trie approach would be faster if we have a lot of words in the dictionary.\\n\\n#### Hamming Distance\\n**C++**\\n```cpp\\nvector<string> twoEditWords(vector<string>& queries, vector<string>& dict) {\\n    vector<string> res;\\n    for (auto &q : queries)\\n        for (auto &d : dict)\\n            if (inner_product(begin(q), end(q), begin(d), 0, plus<int>(), not_equal_to<char>()) < 3) {\\n                res.push_back(q);\\n                break;\\n            }\\n    return res;\\n} \\n```\\n#### Trie\\n**C++**\\n```cpp\\nstruct Trie{\\n    Trie* ch[26] = {};\\n    void insert(string &s, int i = 0) {\\n        if (i < s.size()) {\\n            if (ch[s[i] - \\'a\\'] == nullptr)\\n                ch[s[i] - \\'a\\'] = new Trie();\\n            ch[s[i] - \\'a\\']->insert(s, i + 1);\\n        }\\n    }\\n    bool match(string &s, int cnt, int i = 0) {\\n        if (cnt < 0 || i == s.size())\\n            return cnt >= 0;\\n        bool res = false;\\n        for (int j = 0; j < 26; ++j)\\n            if (ch[j] != nullptr)\\n                res |= ch[j]->match(s, cnt - (j != s[i] - \\'a\\'), i + 1);\\n        return res;\\n    }\\n};\\nvector<string> twoEditWords(vector<string>& queries, vector<string>& dict) {\\n    vector<string> res;\\n    Trie t;\\n    for (auto &d : dict)\\n        t.insert(d);\\n    for (auto &q : queries) {\\n        if (t.match(q, 2))\\n            res.push_back(q);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<string> twoEditWords(vector<string>& queries, vector<string>& dict) {\\n    vector<string> res;\\n    for (auto &q : queries)\\n        for (auto &d : dict)\\n            if (inner_product(begin(q), end(q), begin(d), 0, plus<int>(), not_equal_to<char>()) < 3) {\\n                res.push_back(q);\\n                break;\\n            }\\n    return res;\\n} \\n```\n```cpp\\nstruct Trie{\\n    Trie* ch[26] = {};\\n    void insert(string &s, int i = 0) {\\n        if (i < s.size()) {\\n            if (ch[s[i] - \\'a\\'] == nullptr)\\n                ch[s[i] - \\'a\\'] = new Trie();\\n            ch[s[i] - \\'a\\']->insert(s, i + 1);\\n        }\\n    }\\n    bool match(string &s, int cnt, int i = 0) {\\n        if (cnt < 0 || i == s.size())\\n            return cnt >= 0;\\n        bool res = false;\\n        for (int j = 0; j < 26; ++j)\\n            if (ch[j] != nullptr)\\n                res |= ch[j]->match(s, cnt - (j != s[i] - \\'a\\'), i + 1);\\n        return res;\\n    }\\n};\\nvector<string> twoEditWords(vector<string>& queries, vector<string>& dict) {\\n    vector<string> res;\\n    Trie t;\\n    for (auto &d : dict)\\n        t.insert(d);\\n    for (auto &q : queries) {\\n        if (t.match(q, 2))\\n            res.push_back(q);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2756375,
                "title": "python-c-java-rust-hamming-distance-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs hamming-distance function. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is linear: **O(N)**. \\n\\n**Python.**\\n```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dic: List[str]) -> List[str]:\\n        words = []\\n        for q in queries:\\n            # hamming distance condition \\n            if any(sum(c1 != c2 for c1, c2 in zip(q, d)) <=2 for d in dic):\\n                words.append(q)\\n        return words\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/VLdPFVoj/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dic: List[str]) -> List[str]:\\n        words = []\\n        for q in queries:\\n            # hamming distance condition \\n            if any(sum(c1 != c2 for c1, c2 in zip(q, d)) <=2 for d in dic):\\n                words.append(q)\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756364,
                "title": "c-solution-without-trie-explained-very-simple-and-easy-to-understand",
                "content": "<b> Up Vote if you like the solution\\n```\\n/* \\nVery Simple approach, we need to just write the check function, that will check if the string is in the dictionary or not.\\nTo do this further, we hust need to compare query sting with each of the string in dict and then simply count number diff. char in both string. If the count is less than or equal to 2 return true from check function and add it to the ans.\\n\\nTime Complexity = O(q x N x l ) q = qurey length, l = dictionary length, l = length of each sting\\n*/\\nclass Solution {\\npublic:\\n    \\n    bool check(string& q, vector<string>& dict){\\n        for(auto d: dict){\\n            int c = 0;\\n            for(int i = 0; i < d.size(); ++i){\\n                if(q[i] != d[i]) c++;\\n            }\\n            if(c <= 2) return true;\\n        }\\n        return false;\\n    }\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dict) {\\n        vector<string> ans;\\n        for(auto q: queries){\\n            if(check(q, dict)) ans.push_back(q);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/* \\nVery Simple approach, we need to just write the check function, that will check if the string is in the dictionary or not.\\nTo do this further, we hust need to compare query sting with each of the string in dict and then simply count number diff. char in both string. If the count is less than or equal to 2 return true from check function and add it to the ans.\\n\\nTime Complexity = O(q x N x l ) q = qurey length, l = dictionary length, l = length of each sting\\n*/\\nclass Solution {\\npublic:\\n    \\n    bool check(string& q, vector<string>& dict){\\n        for(auto d: dict){\\n            int c = 0;\\n            for(int i = 0; i < d.size(); ++i){\\n                if(q[i] != d[i]) c++;\\n            }\\n            if(c <= 2) return true;\\n        }\\n        return false;\\n    }\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dict) {\\n        vector<string> ans;\\n        for(auto q: queries){\\n            if(check(q, dict)) ans.push_back(q);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757049,
                "title": "two-approach-java-solution-brute-force-using-trie-data-structure",
                "content": "Brute Force Solution\\nTime Complexity: O(m * n * k)\\nSpace Complexity : O(1)\\nm = length queries array\\nn  = length dictionary array\\nm = length String \\n```\\nclass Solution {\\n    private int diff(String a, String b) {\\n        int n = a.length();\\n        int same = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(a.charAt(i) == b.charAt(i)){\\n                same++;\\n            }\\n        }\\n        int count = n -same;\\n        return count;\\n    }\\n   \\n\\tpublic List<String> twoEditWords(String[] queries, String[] dictionary) {\\n\\t\\tList<String> ans = new ArrayList<>();\\n\\t\\tfor (String query : queries) {\\n\\t\\t\\tfor (String word : dictionary) {\\n\\t\\t\\t\\tint diff = diff(query, word);\\n\\t\\t\\t\\tif (diff <= 2) {\\n\\t\\t\\t\\t\\tans.add(query);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\\nUsing Trie Data Structure Solution\\nTime Complexity: O(n * k + m * k)\\nSpace Complexity : O(n * k * 26)\\nm = length queries array\\nn  = length dictionary array\\nm = length String \\n\\n```\\nclass Solution {\\n    private static class Node {\\n\\t\\tprivate char data;\\n\\t\\tprivate boolean isEnd;\\n\\t\\tprivate Node[] children;\\n\\n\\t\\tpublic Node(char data) {\\n\\t\\t\\tthis.data = data;\\n\\t\\t\\tthis.isEnd = false;\\n\\t\\t\\tthis.children = new Node[26];\\n\\t\\t}\\n\\t}\\n\\n\\tprivate Node root = new Node(\\'/\\');\\n\\n\\tprivate void insertWord(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\tint childIdx = word.charAt(i) - \\'a\\';\\n\\t\\t\\tif (curr.children[childIdx] == null) {\\n\\t\\t\\t\\tcurr.children[childIdx] = new Node(word.charAt(i));\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr.children[childIdx];\\n\\t\\t}\\n\\t\\tcurr.isEnd = true;\\n\\t}\\n\\n\\tprivate boolean searchWord(Node root, String word, int count, int index) {\\n\\t\\tif (index == word.length()) {\\n\\t\\t\\treturn count <= 2;\\n\\t\\t}\\n\\t\\tboolean ans = false;\\n\\t\\tfor (int i = 0; i < root.children.length; i++) {\\n\\t\\t\\tif (root.children[i] != null) {\\n\\t\\t\\t\\tans |= searchWord(root.children[i], word, count + (((word.charAt(index) - \\'a\\') == i) ? 0 : 1),\\n\\t\\t\\t\\t\\t\\tindex + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic List<String> twoEditWords(String[] queries, String[] dictionary) {\\n\\t\\tList<String> ans = new ArrayList<>();\\n\\t\\tfor (String word : dictionary) {\\n\\t\\t\\tinsertWord(word);\\n\\t\\t}\\n\\t\\tfor (String query : queries) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tif (searchWord(curr, query, 0, 0)) {\\n\\t\\t\\t\\tans.add(query);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\\nSome Other Problems Using Trie Data Structure \\n[1268 : Search Suggestions System](https://leetcode.com/problems/search-suggestions-system/discuss/2638534/java-solution-using-trie-runtime-37-ms-beats-7219)\\n[1233 : Remove Sub-Folders from the Filesystem](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/discuss/2638522/java-solution-using-trie-runtime-43-ms-beats-9605)\\n[648\\t: Replace Words](https://leetcode.com/problems/replace-words/discuss/2638625/java-solution-using-trie-runtime-14-ms-beats-962219)\\n[820\\t: Short Encoding of Words](https://leetcode.com/problems/short-encoding-of-words/discuss/2639021/java-solution-using-trie)\\n[208\\t: Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/discuss/2638657/simple-java-solution)\\n[386\\t: Lexicographical Numbers](https://leetcode.com/problems/lexicographical-numbers/discuss/2639107/java-solution-using-trie)\\n[1023 : Camelcase Matching](https://leetcode.com/problems/camelcase-matching/discuss/2639736/java-solution-using-trie)\\n[677\\t: Map Sum Pairs](https://leetcode.com/problems/map-sum-pairs/discuss/2639994/java-solution-using-trie-and-hashmap)\\n[676\\t: Implement Magic Dictionary](https://leetcode.com/problems/implement-magic-dictionary/discuss/2640276/java-solution-using-trie)\\n[421\\t: Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/discuss/2643276/java-trie-approach-add-number-and-check-its-max-xor-on-fly-tc-on-and-sc-on)\\n[792\\t: Number of Matching Subsequences](https://leetcode.com/problems/number-of-matching-subsequences/discuss/2643489/java-solutions-two-approach-1-using-trie-2-hashmap)\\n[720\\t: Longest Word in Dictionary](https://leetcode.com/problems/longest-word-in-dictionary/discuss/2643586/java-solution-using-trie-dfs)\\n[2261 : K Divisible Elements Subarrays](https://leetcode.com/problems/k-divisible-elements-subarrays/discuss/2643761/java-solution-sliding-window-trie-runtime-41-ms-faster-than-9846)\\n[139\\t: Word Break](https://leetcode.com/problems/word-break/discuss/2643915/java-solutions-two-approach-1-using-trie-bfs-2-dp)\\n[211\\t: Design Add and Search Words Data Structure](https://leetcode.com/problems/design-add-and-search-words-data-structure/discuss/2643839/java-solution-using-trie-dfs)\\n[1948 : Delete Duplicate Folders in System](https://leetcode.com/problems/delete-duplicate-folders-in-system/discuss/2646138/java-solution-using-trie-with-postorder-and-inorder-dfs-traversal)\\n[1032 : Stream of Characters](https://leetcode.com/problems/stream-of-characters/discuss/2646970/java-solution-using-trie)\\n[212. Word Search II](https://leetcode.com/problems/word-search-ii/discuss/2779677/Java-Solution-or-Using-Trie)",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    private int diff(String a, String b) {\\n        int n = a.length();\\n        int same = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(a.charAt(i) == b.charAt(i)){\\n                same++;\\n            }\\n        }\\n        int count = n -same;\\n        return count;\\n    }\\n   \\n\\tpublic List<String> twoEditWords(String[] queries, String[] dictionary) {\\n\\t\\tList<String> ans = new ArrayList<>();\\n\\t\\tfor (String query : queries) {\\n\\t\\t\\tfor (String word : dictionary) {\\n\\t\\t\\t\\tint diff = diff(query, word);\\n\\t\\t\\t\\tif (diff <= 2) {\\n\\t\\t\\t\\t\\tans.add(query);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n    private static class Node {\\n\\t\\tprivate char data;\\n\\t\\tprivate boolean isEnd;\\n\\t\\tprivate Node[] children;\\n\\n\\t\\tpublic Node(char data) {\\n\\t\\t\\tthis.data = data;\\n\\t\\t\\tthis.isEnd = false;\\n\\t\\t\\tthis.children = new Node[26];\\n\\t\\t}\\n\\t}\\n\\n\\tprivate Node root = new Node(\\'/\\');\\n\\n\\tprivate void insertWord(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (int i = 0; i < word.length(); i++) {\\n\\t\\t\\tint childIdx = word.charAt(i) - \\'a\\';\\n\\t\\t\\tif (curr.children[childIdx] == null) {\\n\\t\\t\\t\\tcurr.children[childIdx] = new Node(word.charAt(i));\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr.children[childIdx];\\n\\t\\t}\\n\\t\\tcurr.isEnd = true;\\n\\t}\\n\\n\\tprivate boolean searchWord(Node root, String word, int count, int index) {\\n\\t\\tif (index == word.length()) {\\n\\t\\t\\treturn count <= 2;\\n\\t\\t}\\n\\t\\tboolean ans = false;\\n\\t\\tfor (int i = 0; i < root.children.length; i++) {\\n\\t\\t\\tif (root.children[i] != null) {\\n\\t\\t\\t\\tans |= searchWord(root.children[i], word, count + (((word.charAt(index) - \\'a\\') == i) ? 0 : 1),\\n\\t\\t\\t\\t\\t\\tindex + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic List<String> twoEditWords(String[] queries, String[] dictionary) {\\n\\t\\tList<String> ans = new ArrayList<>();\\n\\t\\tfor (String word : dictionary) {\\n\\t\\t\\tinsertWord(word);\\n\\t\\t}\\n\\t\\tfor (String query : queries) {\\n\\t\\t\\tNode curr = root;\\n\\t\\t\\tif (searchWord(curr, query, 0, 0)) {\\n\\t\\t\\t\\tans.add(query);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756343,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\nprivate:\\n    int fun(string &a, string &b){\\n        int k = 0;\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]!=b[i])  k++;\\n        }\\n        return k;\\n    }\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        int n = q.size(), m = d.size();\\n        vector<string> ans;\\n        for(int i=0; i<n; i++){\\n            string a = q[i];\\n            for(int j=0; j<m; j++){\\n                string b = d[j];\\n                int check = fun(a, b);\\n                if(check<=2){\\n                    ans.push_back(a);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int fun(string &a, string &b){\\n        int k = 0;\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]!=b[i])  k++;\\n        }\\n        return k;\\n    }\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        int n = q.size(), m = d.size();\\n        vector<string> ans;\\n        for(int i=0; i<n; i++){\\n            string a = q[i];\\n            for(int j=0; j<m; j++){\\n                string b = d[j];\\n                int check = fun(a, b);\\n                if(check<=2){\\n                    ans.push_back(a);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756540,
                "title": "java-python-3-bruteforce-code",
                "content": "**Q & A**\\n*Q1*: What is the `outer` in java code?\\n*A1*: It is a java statement label. Please refer to [w3resource](https://www.w3resource.com/java-tutorial/java-branching-statements.php#:~:text=Labeled%20Statements.%20Although%20many%20statements%20in%20a%20Java,valid%20identifier%20that%20ends%20with%20a%20colon%20%28%3A%29.) and [Oracle The Java\\u2122 Tutorials](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/branch.html) for more details.\\n\\n**End of Q & A**\\n\\n----\\n\\nTraverse the `queries`, for each query, `q`, traverse the `dictionary` to look for if any word has no more than 2 different characters from `q`; If yes, store it into the solution `ans`, and continue to the next query;\\n\\n```java\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        outer:\\n        for (String q : queries) {\\n            for (String w : dictionary) {\\n                int cnt = 0;\\n                for (int i = 0; cnt < 3 && i < q.length(); ++i) {\\n                    if (q.charAt(i) != w.charAt(i)) {\\n                        ++cnt;\\n                    }\\n                }\\n                if (cnt < 3) {\\n                    ans.add(q);\\n                    continue outer;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\nor simplified as:\\n```java\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for (String q : queries) {\\n            if (Arrays.stream(dictionary).anyMatch(w -> IntStream.range(0, w.length()).filter(i -> w.charAt(i) != q.charAt(i)).count() <= 2)) {\\n                ans.add(q);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        ans = []\\n        for q in queries:\\n            for w in dictionary:\\n                cnt = 0\\n                for c, d in zip(w, q):\\n                    if c != d:\\n                        cnt += 1\\n                        if cnt > 2:\\n                            break\\n                if cnt <= 2:\\n                    ans.append(q)\\n                    break\\n        return ans\\n```\\nor simplified as:\\n```python\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        ans = []\\n        for q in queries:\\n            if any(sum(c != d for c, d in zip(w, q)) <= 2 for w in dictionary):\\n                ans.append(q)\\n        return ans\\n```\\n\\n**Analysis:**\\n\\nTime: `O(Q * D * W)`, space: `O(Q * W)`, where `Q = queries.length, D = dictionary.length, W = word size`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        outer:\\n        for (String q : queries) {\\n            for (String w : dictionary) {\\n                int cnt = 0;\\n                for (int i = 0; cnt < 3 && i < q.length(); ++i) {\\n                    if (q.charAt(i) != w.charAt(i)) {\\n                        ++cnt;\\n                    }\\n                }\\n                if (cnt < 3) {\\n                    ans.add(q);\\n                    continue outer;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```java\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for (String q : queries) {\\n            if (Arrays.stream(dictionary).anyMatch(w -> IntStream.range(0, w.length()).filter(i -> w.charAt(i) != q.charAt(i)).count() <= 2)) {\\n                ans.add(q);\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        ans = []\\n        for q in queries:\\n            for w in dictionary:\\n                cnt = 0\\n                for c, d in zip(w, q):\\n                    if c != d:\\n                        cnt += 1\\n                        if cnt > 2:\\n                            break\\n                if cnt <= 2:\\n                    ans.append(q)\\n                    break\\n        return ans\\n```\n```python\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        ans = []\\n        for q in queries:\\n            if any(sum(c != d for c, d in zip(w, q)) <= 2 for w in dictionary):\\n                ans.append(q)\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2756344,
                "title": "easy-java-solution",
                "content": "```\\npublic List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        \\n       List<String> list = new ArrayList<>();\\n        for(int i=0; i<queries.length; i++) {\\n            for(int j=0; j<dictionary.length; j++) {\\n                if(queries[i].equals(dictionary[j])) {\\n                    list.add(queries[i]);\\n                    break;\\n                }\\n                \\n                int k = diff(queries[i], dictionary[j]);\\n                if(k<=2) {\\n                    list.add(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return list;\\n        \\n    }\\n    \\n    \\n    public static int diff(String a, String b) {\\n\\n        int n = a.length();\\n        int s = 0;\\n        for(int i=0; i<n; i++) {\\n            if(a.charAt(i)==b.charAt(i)) s++;\\n        }\\n        int count = n-s;\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        \\n       List<String> list = new ArrayList<>();\\n        for(int i=0; i<queries.length; i++) {\\n            for(int j=0; j<dictionary.length; j++) {\\n                if(queries[i].equals(dictionary[j])) {\\n                    list.add(queries[i]);\\n                    break;\\n                }\\n                \\n                int k = diff(queries[i], dictionary[j]);\\n                if(k<=2) {\\n                    list.add(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return list;\\n        \\n    }\\n    \\n    \\n    public static int diff(String a, String b) {\\n\\n        int n = a.length();\\n        int s = 0;\\n        for(int i=0; i<n; i++) {\\n            if(a.charAt(i)==b.charAt(i)) s++;\\n        }\\n        int count = n-s;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2759908,
                "title": "c-copy-if-any-of-and-custom-predicate",
                "content": "### Approach 1: copy_if, any_of, and custom predicate (4ms)\\n\\nThis is basically a fancy nest loop, checking each query against the dicionary\\n\\n```cpp\\n    static vector<string> twoEditWords(const vector<string>& queries, const vector<string>& dictionary) {\\n        vector<string> ans;\\n        ans.reserve(size(queries));\\n        copy_if(begin(queries), end(queries), back_inserter(ans), [&](const string& query) {\\n            return any_of(begin(dictionary), end(dictionary), [&](const string& word) {\\n                for (int i = 0, diffs = 0; i < size(word); ++i)\\n                    if (word[i] != query[i])\\n                        if (++diffs > 2) return false;\\n\\n                return true;\\n            });\\n        });\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the size of ```queries```, $$m$$ be size of ```dictionary```, and $$k$$ the size of each of the words then the\\n  * Time complexity is $$O(n * m * k)$$ as we are checking all the combinations and the\\n  * Space complexity is $$O(n * k)$$ for the output\\n\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n    static vector<string> twoEditWords(const vector<string>& queries, const vector<string>& dictionary) {\\n        vector<string> ans;\\n        ans.reserve(size(queries));\\n        copy_if(begin(queries), end(queries), back_inserter(ans), [&](const string& query) {\\n            return any_of(begin(dictionary), end(dictionary), [&](const string& word) {\\n                for (int i = 0, diffs = 0; i < size(word); ++i)\\n                    if (word[i] != query[i])\\n                        if (++diffs > 2) return false;\\n\\n                return true;\\n            });\\n        });\\n        return ans;\\n    }\\n```\n```queries```\n```dictionary```",
                "codeTag": "Unknown"
            },
            {
                "id": 2756786,
                "title": "simple-java-please-upvote-if-it-helps",
                "content": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for(int i = 0; i < queries.length; i++){\\n            String str = queries[i];\\n            \\n            for(int j = 0; j < dictionary.length; j++){\\n                String s = dictionary[j];\\n                int count = 0;\\n                for(int k = 0; k < s.length(); k++){\\n                    if(str.charAt(k) != s.charAt(k)){\\n                        count++;\\n                    }\\n                    if(count > 2){\\n                        break;\\n                    }\\n                }\\n                if(count <= 2){\\n                    ans.add(str);\\n                    break;\\n                }\\n                count = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for(int i = 0; i < queries.length; i++){\\n            String str = queries[i];\\n            \\n            for(int j = 0; j < dictionary.length; j++){\\n                String s = dictionary[j];\\n                int count = 0;\\n                for(int k = 0; k < s.length(); k++){\\n                    if(str.charAt(k) != s.charAt(k)){\\n                        count++;\\n                    }\\n                    if(count > 2){\\n                        break;\\n                    }\\n                }\\n                if(count <= 2){\\n                    ans.add(str);\\n                    break;\\n                }\\n                count = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757855,
                "title": "python-3-8-lines-t-m-308-ms-14-2-mb",
                "content": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n\\n        N, ans = range(len(queries[0])), []\\n\\n        f = lambda x,y: sum(x[i] != y[i] for i in N) < 3  # boolean function that returns whether\\n                                                          # x and y are within two edits\\n        for q in queries:                                 \\n            for d in dictionary:\\n                if f(q,d):\\n                    ans.append(q)\\n                    break\\n        return  ans\\n```\\n[https://leetcode.com/submissions/detail/833022066/](http://)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n\\n        N, ans = range(len(queries[0])), []\\n\\n        f = lambda x,y: sum(x[i] != y[i] for i in N) < 3  # boolean function that returns whether\\n                                                          # x and y are within two edits\\n        for q in queries:                                 \\n            for d in dictionary:\\n                if f(q,d):\\n                    ans.append(q)\\n                    break\\n        return  ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756371,
                "title": "c-clean-code",
                "content": "```\\n//Bruteforce Approach \\n\\n    bool isValid(string &q, string &d)\\n    {\\n\\t\\tint editCnt = 0;\\n        for (int i = 0; i < size(q); i++)\\n            if (q[i] != d[i]) \\n                if (++editCnt > 2)  return false; //max 2 edit allowed\\n        return true;\\n    }\\n\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        vector<string> ans;\\n        \\n        for (int i = 0; i < size(q); i++)\\n            for (int j = 0; j < size(d); j++)\\n                if (isValid(q[i], d[j]))\\n                {\\n                    ans.push_back(q[i]);\\n                    break;\\n                }\\n\\n        return ans;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//Bruteforce Approach \\n\\n    bool isValid(string &q, string &d)\\n    {\\n\\t\\tint editCnt = 0;\\n        for (int i = 0; i < size(q); i++)\\n            if (q[i] != d[i]) \\n                if (++editCnt > 2)  return false; //max 2 edit allowed\\n        return true;\\n    }\\n\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        vector<string> ans;\\n        \\n        for (int i = 0; i < size(q); i++)\\n            for (int j = 0; j < size(d); j++)\\n                if (isValid(q[i], d[j]))\\n                {\\n                    ans.push_back(q[i]);\\n                    break;\\n                }\\n\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783333,
                "title": "c-solution",
                "content": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> soln;\\n        for (string x:queries) {\\n            for (string y:dictionary) {\\n                int diff{0};\\n                for (int k=0; k<y.length(); ++k) {\\n                    if (x[k]!=y[k]) diff++;\\n                }\\n                if (diff<3) {\\n                    soln.push_back(x);\\n                    break;\\n                }\\n            }\\n        }\\n        return soln;\\n    }\\n};\\n```\\n\\n*Upvote if solution helped*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> soln;\\n        for (string x:queries) {\\n            for (string y:dictionary) {\\n                int diff{0};\\n                for (int k=0; k<y.length(); ++k) {\\n                    if (x[k]!=y[k]) diff++;\\n                }\\n                if (diff<3) {\\n                    soln.push_back(x);\\n                    break;\\n                }\\n            }\\n        }\\n        return soln;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756469,
                "title": "brute-force-simple-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(length of 1st array x length of 2nd array x length of each word)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] q, String[] d) {\\n        int k=q.length;\\n        List<String> nm=new ArrayList<>();\\n        for(int i=0;i<k;i++)\\n        {\\n            for(int j=0;j<d.length;j++)\\n            {\\n                int c=0;\\n                for(int p=0;p<Math.min(d[j].length(),q[i].length());p++)\\n                {\\n                    if(d[j].charAt(p)!=q[i].charAt(p))\\n                        c++;\\n                }\\n                if(c<=2)\\n                {\\n                    nm.add(q[i]);\\n                    break;\\n                }\\n                //System.out.println(c+\" \"+q[i]+\" \"+d[j]);\\n            }\\n        }\\n        return nm;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] q, String[] d) {\\n        int k=q.length;\\n        List<String> nm=new ArrayList<>();\\n        for(int i=0;i<k;i++)\\n        {\\n            for(int j=0;j<d.length;j++)\\n            {\\n                int c=0;\\n                for(int p=0;p<Math.min(d[j].length(),q[i].length());p++)\\n                {\\n                    if(d[j].charAt(p)!=q[i].charAt(p))\\n                        c++;\\n                }\\n                if(c<=2)\\n                {\\n                    nm.add(q[i]);\\n                    break;\\n                }\\n                //System.out.println(c+\" \"+q[i]+\" \"+d[j]);\\n            }\\n        }\\n        return nm;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756385,
                "title": "c-brute-force",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    vector<string> twoEditWords(vector<string>& que, vector<string>& dict) \\n    {\\n        vector<string> res;\\n        int count=0;\\n        for(int i=0; i<que.size(); i++)\\n        {\\n            for(int j=0; j<dict.size(); j++)\\n            {\\n                count=0;\\n                for(int k=0; k<que[0].size(); k++)\\n                {\\n                    if(que[i][k]!=dict[j][k])\\n                        count++;\\n                }\\n                if(count <= 2)\\n                {\\n                    res.push_back(que[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<string> twoEditWords(vector<string>& que, vector<string>& dict) \\n    {\\n        vector<string> res;\\n        int count=0;\\n        for(int i=0; i<que.size(); i++)\\n        {\\n            for(int j=0; j<dict.size(); j++)\\n            {\\n                count=0;\\n                for(int k=0; k<que[0].size(); k++)\\n                {\\n                    if(que[i][k]!=dict[j][k])\\n                        count++;\\n                }\\n                if(count <= 2)\\n                {\\n                    res.push_back(que[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292236,
                "title": "easy-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def twoEditWords(self, queries, dictionary):\\n        \"\"\"\\n        :type queries: List[str]\\n        :type dictionary: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        lst=[]\\n        val=Counter(queries)\\n        for i in queries:\\n            for j in dictionary:\\n                cnt=len(i)\\n                idx1=0\\n                while idx1<len(i):\\n                    if i[idx1]==j[idx1]:\\n                        cnt-=1\\n                    idx1+=1\\n                if cnt<=2 and val[i]!=0:\\n                    val[i]-=1\\n                    lst.append(i)\\n                    break\\n        return lst\\n\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution(object):\\n    def twoEditWords(self, queries, dictionary):\\n        \"\"\"\\n        :type queries: List[str]\\n        :type dictionary: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        lst=[]\\n        val=Counter(queries)\\n        for i in queries:\\n            for j in dictionary:\\n                cnt=len(i)\\n                idx1=0\\n                while idx1<len(i):\\n                    if i[idx1]==j[idx1]:\\n                        cnt-=1\\n                    idx1+=1\\n                if cnt<=2 and val[i]!=0:\\n                    val[i]-=1\\n                    lst.append(i)\\n                    break\\n        return lst\\n\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799388,
                "title": "get-score-brute-force",
                "content": "# Intuition\\nTo find all such strings we find score for reach query with each element in the `dictionary` and if the `score >= n - 2` it means we can compute the string by changing at max `2` characters.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n`canFit` function tells if string can fit int the dictionary by compute the `score` with each word in the dictionary.\\nIterating over all the queries we all all the strings that fit.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    bool canFit(string& word, vector<string>& dict) {\\n        int i, score;\\n        for(string& d: dict) {\\n            score = 0;\\n            for(i = 0; i < n; i++) {\\n                if(word[i] == d[i])\\n                    score++;\\n            }\\n            if(score >= n - 2)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        n = dictionary[0].length();\\n        vector<string> res;\\n        \\n        for(string& word: queries)\\n            if(canFit(word, dictionary))\\n                res.push_back(word);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    bool canFit(string& word, vector<string>& dict) {\\n        int i, score;\\n        for(string& d: dict) {\\n            score = 0;\\n            for(i = 0; i < n; i++) {\\n                if(word[i] == d[i])\\n                    score++;\\n            }\\n            if(score >= n - 2)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        n = dictionary[0].length();\\n        vector<string> res;\\n        \\n        for(string& word: queries)\\n            if(canFit(word, dictionary))\\n                res.push_back(word);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781229,
                "title": "c-no-trie-usage-easy-to-understand",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        bool twodiff(string s1, string s2)\\n        {\\n            int diff = 0;\\n            for(int i = 0; i < s1.size(); i++){\\n                if(s1[i] != s2[i]) diff++;\\n            }\\n            if (diff <= 2) return true;\\n            return false;\\n        }\\n\\n    vector<string> twoEditWords(vector<string> &queries, vector<string> &dictionary)\\n    {\\n        vector<string> ans;\\n        int i = 0, n = queries.size();\\n        for (int i = 0; i < queries.size(); i++)\\n        {\\n            for (int j = 0; j < dictionary.size(); j++)\\n            {\\n                if (twodiff(queries[i], dictionary[j]))\\n                {\\n                    ans.push_back(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        bool twodiff(string s1, string s2)\\n        {\\n            int diff = 0;\\n            for(int i = 0; i < s1.size(); i++){\\n                if(s1[i] != s2[i]) diff++;\\n            }\\n            if (diff <= 2) return true;\\n            return false;\\n        }\\n\\n    vector<string> twoEditWords(vector<string> &queries, vector<string> &dictionary)\\n    {\\n        vector<string> ans;\\n        int i = 0, n = queries.size();\\n        for (int i = 0; i < queries.size(); i++)\\n        {\\n            for (int j = 0; j < dictionary.size(); j++)\\n            {\\n                if (twodiff(queries[i], dictionary[j]))\\n                {\\n                    ans.push_back(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758838,
                "title": "c-simple-solution-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string &q,vector<string> &dict){\\n        for(auto d: dict){\\n            int c= 0;\\n            for(int i=0;i<d.size();i++){\\n                if(q[i] != d[i]){\\n                    c++;\\n                }\\n            }\\n            if( c <= 2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dict) {\\n        vector<string> ans;\\n        for(auto q: queries){\\n            if(check(q,dict)){\\n                ans.push_back(q);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string &q,vector<string> &dict){\\n        for(auto d: dict){\\n            int c= 0;\\n            for(int i=0;i<d.size();i++){\\n                if(q[i] != d[i]){\\n                    c++;\\n                }\\n            }\\n            if( c <= 2){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dict) {\\n        vector<string> ans;\\n        for(auto q: queries){\\n            if(check(q,dict)){\\n                ans.push_back(q);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758834,
                "title": "python3-solution-o-1-and-o-q-d-l",
                "content": "```\\n\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        res=[]\\n        N=len(queries[0])\\n        for query in queries:\\n            for word in dictionary:\\n                delta=0\\n                \\n                for i in range(N):\\n                    if query[i]!=word[i]:\\n                        delta+=1\\n                        \\n                if delta<=2:\\n                    res.append(query)\\n                    break\\n                    \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        res=[]\\n        N=len(queries[0])\\n        for query in queries:\\n            for word in dictionary:\\n                delta=0\\n                \\n                for i in range(N):\\n                    if query[i]!=word[i]:\\n                        delta+=1\\n                        \\n                if delta<=2:\\n                    res.append(query)\\n                    break\\n                    \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2757564,
                "title": "beats-100-js",
                "content": "\\n```\\n/**\\n * @param {string[]} queries\\n * @param {string[]} dictionary\\n * @return {string[]}\\n */\\nvar twoEditWords = function(queries, dictionary) {\\n    const res = [], n = queries[0].length;\\n\\n    for (const q of queries) {\\n        if (helper(q)) res.push(q)\\n    }\\n    return res;\\n\\n    function helper(q_word) {\\n        for (const w of dictionary) {\\n            if (diffLessThanTwo(q_word, w)) return true;\\n        }\\n        return false;\\n    }\\n\\n    function diffLessThanTwo(w1, w2) {\\n        let cnt = 0;\\n        for (let i = 0; i<n; i++) {\\n            if (cnt > 2) return false;\\n            if (w1[i]!==w2[i]) cnt++;\\n        }\\n        return cnt <= 2;\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/8c7d5d0a-e70c-44e3-8e76-4d94f8ede457_1667080370.75869.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} queries\\n * @param {string[]} dictionary\\n * @return {string[]}\\n */\\nvar twoEditWords = function(queries, dictionary) {\\n    const res = [], n = queries[0].length;\\n\\n    for (const q of queries) {\\n        if (helper(q)) res.push(q)\\n    }\\n    return res;\\n\\n    function helper(q_word) {\\n        for (const w of dictionary) {\\n            if (diffLessThanTwo(q_word, w)) return true;\\n        }\\n        return false;\\n    }\\n\\n    function diffLessThanTwo(w1, w2) {\\n        let cnt = 0;\\n        for (let i = 0; i<n; i++) {\\n            if (cnt > 2) return false;\\n            if (w1[i]!==w2[i]) cnt++;\\n        }\\n        return cnt <= 2;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2757378,
                "title": "python-simple-hashset-solution-o-n-m-l-3",
                "content": "With the help of a generator we can produce all the possible modifications:\\n* 1 character is different (e.g. wood --> `[\\'*ood\\', \\'w*od\\', \\'wo*d\\', \\'woo*\\']`)\\n* 2 characters are different (e.g. wood --> `[\\'**od\\', \\'*o*d\\', \\'*oo*\\', \\'w**d\\', \\'w*o*\\', \\'wo**\\']`)\\n\\nWe traverse the dictionary array and store each modification in a HashSet.\\nLastly, we traverse the queries array and we to try find any of the possible modifications in the HashSet. If we\\'re able to do so, then we include that word in our answer, as it can match a word from dictionary after at most two edits.\\n\\n```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        # T: ((N + M) * L^3), S: O(M * L^3)\\n        N, M, L = len(queries), len(dictionary), len(queries[0])\\n        validWords = set()\\n        \\n        for word in dictionary:\\n            for w in self.wordModifications(word):\\n                validWords.add(w)\\n        \\n        ans = []\\n        for word in queries:\\n            for w in self.wordModifications(word):\\n                if w in validWords:\\n                    ans.append(word)\\n                    break\\n\\n        return ans\\n    \\n    def wordModifications(self, word):\\n        # T: O(L^3)\\n        L = len(word)\\n        for i in range(L):\\n            yield word[:i] + \"*\" + word[i+1:]\\n\\n        for i, j in itertools.combinations(range(L), 2):\\n            yield word[:i] + \"*\" + word[i+1:j] + \"*\" + word[j+1:]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        # T: ((N + M) * L^3), S: O(M * L^3)\\n        N, M, L = len(queries), len(dictionary), len(queries[0])\\n        validWords = set()\\n        \\n        for word in dictionary:\\n            for w in self.wordModifications(word):\\n                validWords.add(w)\\n        \\n        ans = []\\n        for word in queries:\\n            for w in self.wordModifications(word):\\n                if w in validWords:\\n                    ans.append(word)\\n                    break\\n\\n        return ans\\n    \\n    def wordModifications(self, word):\\n        # T: O(L^3)\\n        L = len(word)\\n        for i in range(L):\\n            yield word[:i] + \"*\" + word[i+1:]\\n\\n        for i, j in itertools.combinations(range(L), 2):\\n            yield word[:i] + \"*\" + word[i+1:j] + \"*\" + word[j+1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757117,
                "title": "javascript-trie-and-dfs-solution",
                "content": "I highly recommend going through this problem first: https://leetcode.com/problems/design-add-and-search-words-data-structure/\\n\\n```\\nvar WordDictionary = function () {\\n  this.trie = {};\\n};\\n\\nWordDictionary.prototype.addWord = function (word) {\\n  let root = this.trie;\\n  for (let i = 0; i < word.length; i++) {\\n    if (root[word[i]] == null) root[word[i]] = {};\\n    root = root[word[i]];\\n  }\\n};\\n\\nWordDictionary.prototype.search = function (word) {\\n  return this.dfs(word, 0, this.trie, 0);\\n};\\n\\nWordDictionary.prototype.dfs = function (word, index, node, score) {\\n  if(score > 2) return false;\\n  if (index == word.length) return true\\n  for (let key in node) {\\n    if(this.dfs(word, index + 1, node[key], score + +(key != word[index]))) return true;\\n  }\\n  return false\\n};\\nvar twoEditWords = function (queries, dictionary) {\\n  const t = new WordDictionary();\\n  for (let i = 0; i < dictionary.length; i++) {\\n    t.addWord(dictionary[i]);\\n  }\\n  let ans = [];\\n  for (const query of queries) {\\n    if(t.search(query)) ans.push(query);\\n  }\\n  return ans;\\n};\\n\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\nvar WordDictionary = function () {\\n  this.trie = {};\\n};\\n\\nWordDictionary.prototype.addWord = function (word) {\\n  let root = this.trie;\\n  for (let i = 0; i < word.length; i++) {\\n    if (root[word[i]] == null) root[word[i]] = {};\\n    root = root[word[i]];\\n  }\\n};\\n\\nWordDictionary.prototype.search = function (word) {\\n  return this.dfs(word, 0, this.trie, 0);\\n};\\n\\nWordDictionary.prototype.dfs = function (word, index, node, score) {\\n  if(score > 2) return false;\\n  if (index == word.length) return true\\n  for (let key in node) {\\n    if(this.dfs(word, index + 1, node[key], score + +(key != word[index]))) return true;\\n  }\\n  return false\\n};\\nvar twoEditWords = function (queries, dictionary) {\\n  const t = new WordDictionary();\\n  for (let i = 0; i < dictionary.length; i++) {\\n    t.addWord(dictionary[i]);\\n  }\\n  let ans = [];\\n  for (const query of queries) {\\n    if(t.search(query)) ans.push(query);\\n  }\\n  return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2757012,
                "title": "java-brute-force-easy",
                "content": "### **Please Upvote** :D\\nDid exactly what is said in the hints.\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        \\n        for (int i = 0; i < queries.length; i++){\\n            String s = queries[i];\\n            \\n            for (int j = 0; j < dictionary.length; j++){\\n                String str = dictionary[j];\\n                int diff = 0;\\n                \\n                for(int k = 0; k < str.length(); k++){\\n                    if (str.charAt(k) != s.charAt(k)) {\\n                        diff++;\\n                    }\\n                }\\n                \\n                if (diff <= 2) {\\n                    ans.add(s);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1) - ignoring the output array\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        \\n        for (int i = 0; i < queries.length; i++){\\n            String s = queries[i];\\n            \\n            for (int j = 0; j < dictionary.length; j++){\\n                String str = dictionary[j];\\n                int diff = 0;\\n                \\n                for(int k = 0; k < str.length(); k++){\\n                    if (str.charAt(k) != s.charAt(k)) {\\n                        diff++;\\n                    }\\n                }\\n                \\n                if (diff <= 2) {\\n                    ans.add(s);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1) - ignoring the output array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756798,
                "title": "java-easy-solution-brute-force-7ms",
                "content": "Please let me know if any explaination needed!\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ls=new ArrayList<>();\\n        for(String s:queries){\\n            for(String ss:dictionary){\\n               int count=0;\\n                for(int i=0;i<ss.length();i++){\\n                    if(s.charAt(i)!=ss.charAt(i)){\\n                        count++;\\n                        if(count>2)break;\\n                    }\\n                }\\n                if(count<=2){\\n                ls.add(s);\\n                    break;\\n                }\\n            }\\n        }\\n        return ls;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ls=new ArrayList<>();\\n        for(String s:queries){\\n            for(String ss:dictionary){\\n               int count=0;\\n                for(int i=0;i<ss.length();i++){\\n                    if(s.charAt(i)!=ss.charAt(i)){\\n                        count++;\\n                        if(count>2)break;\\n                    }\\n                }\\n                if(count<=2){\\n                ls.add(s);\\n                    break;\\n                }\\n            }\\n        }\\n        return ls;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756465,
                "title": "c-one-line-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public IList<string> TwoEditWords(string[] queries, string[] dictionary)\\n    {\\n        return queries.Where(query => dictionary.Any(word => query.Where((c, i) => c != word[i]).Count() <= 2)).ToList();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public IList<string> TwoEditWords(string[] queries, string[] dictionary)\\n    {\\n        return queries.Where(query => dictionary.Any(word => query.Where((c, i) => c != word[i]).Count() <= 2)).ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756459,
                "title": "optimised-solution-trie-and-dfs-c",
                "content": "We just insert all words into trie, and now iterate query strings we can change atmost 2 char and we will keep count of them in our dfs.\\n\\n```\\nclass Solution {\\npublic:\\n    struct trie {\\n        bool isword;\\n        map < char , trie* > next;\\n        trie() {\\n            isword = false;\\n        }\\n    };\\n    void insert(string s , trie *r) {\\n        for(char c : s){\\n            if(!r->next[c]) r->next[c] = new trie();\\n            r = r->next[c];\\n        }\\n        r->isword = true;\\n    }\\n    \\n    bool dfs(int i , string &s , int left , trie *r) {\\n        if(left < 0) return false;\\n        if(i == s.size()){\\n            return r->isword;\\n        }\\n        int can = 0;\\n        for(auto a : r->next) {\\n            if(a.first == s[i]) can = dfs(i + 1 , s , left , r->next[a.first]);\\n            else can = dfs(i + 1 , s , left - 1 , r->next[a.first]);\\n            if(can) return  true;\\n        }\\n        return false;\\n    }\\n    \\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        set < string > ok1;\\n        trie *root = new trie();\\n        for(auto a : dictionary) {\\n            insert(a , root);\\n        }\\n        vector < string > ans;\\n        for(auto b : queries) {\\n            if(dfs(0 , b , 2 , root)) ans.push_back(b);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Depth-First Search",
                    "Trie",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct trie {\\n        bool isword;\\n        map < char , trie* > next;\\n        trie() {\\n            isword = false;\\n        }\\n    };\\n    void insert(string s , trie *r) {\\n        for(char c : s){\\n            if(!r->next[c]) r->next[c] = new trie();\\n            r = r->next[c];\\n        }\\n        r->isword = true;\\n    }\\n    \\n    bool dfs(int i , string &s , int left , trie *r) {\\n        if(left < 0) return false;\\n        if(i == s.size()){\\n            return r->isword;\\n        }\\n        int can = 0;\\n        for(auto a : r->next) {\\n            if(a.first == s[i]) can = dfs(i + 1 , s , left , r->next[a.first]);\\n            else can = dfs(i + 1 , s , left - 1 , r->next[a.first]);\\n            if(can) return  true;\\n        }\\n        return false;\\n    }\\n    \\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        set < string > ok1;\\n        trie *root = new trie();\\n        for(auto a : dictionary) {\\n            insert(a , root);\\n        }\\n        vector < string > ans;\\n        for(auto b : queries) {\\n            if(dfs(0 , b , 2 , root)) ans.push_back(b);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422648,
                "title": "brute-force-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> v;\\n\\n        map<string,int> m;\\n        for(int i=0;i<dictionary.size();i++) {\\n            m[dictionary[i]] = 1;\\n        }\\n\\n        for(int i=0;i<queries.size();i++) {\\n            if(m.find(queries[i]) != m.end() || queries[i].length() <= 2) {\\n                v.push_back(queries[i]);\\n                continue;\\n            }\\n            else{\\n                for(auto it: m) {\\n                    string s = it.first;\\n                    int c = 0;\\n                    for(int j=0;j<s.length();j++) {\\n                        if(queries[i][j] == s[j]) {\\n                            c++;\\n                        }\\n                    }\\n\\n                    if(c >= s.length()-2) {\\n                        v.push_back(queries[i]);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> v;\\n\\n        map<string,int> m;\\n        for(int i=0;i<dictionary.size();i++) {\\n            m[dictionary[i]] = 1;\\n        }\\n\\n        for(int i=0;i<queries.size();i++) {\\n            if(m.find(queries[i]) != m.end() || queries[i].length() <= 2) {\\n                v.push_back(queries[i]);\\n                continue;\\n            }\\n            else{\\n                for(auto it: m) {\\n                    string s = it.first;\\n                    int c = 0;\\n                    for(int j=0;j<s.length();j++) {\\n                        if(queries[i][j] == s[j]) {\\n                            c++;\\n                        }\\n                    }\\n\\n                    if(c >= s.length()-2) {\\n                        v.push_back(queries[i]);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422617,
                "title": "brute-force-approach-o-1-space",
                "content": "\\n\\n# Approach\\nWe naively check each pair of queries and dictionary strings and count the number of mismatching characters. If the count of mismatching characters is less than or equal to 2, it means we can generate the given query string from the dictionary and we add query string to the answer. Finally, we return the result that contains required answer. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity Analysis :\\n# Time Complexity : \\n###### O(queries.len * dictionary.len * queries[string].len)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Space Complexity : O(1)\\nWe do not use any extra space other than to store the Final Result to be returned.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) \\n    {\\n        vector<string>res;\\n        vector<string>queriesc = queries;\\n        for(int i=0; i<queriesc.size();i++)\\n        {\\n            for(int j=0; j<dictionary.size();j++)\\n            {\\n                int counter = 0;\\n                for(int k=0; k<queriesc[i].length();k++)\\n                {\\n                    if(queriesc[i][k] != dictionary[j][k])\\n                    {\\n                        counter++;\\n                    }\\n                }\\n                if(counter<=2) \\n                {\\n                    res.push_back(queries[i]);\\n                    cout<<queriesc[i]<<\" \"<<dictionary[j]<<endl<<\" \"<<counter<<endl;\\n                    break;\\n                }\\n            }\\n        }    \\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) \\n    {\\n        vector<string>res;\\n        vector<string>queriesc = queries;\\n        for(int i=0; i<queriesc.size();i++)\\n        {\\n            for(int j=0; j<dictionary.size();j++)\\n            {\\n                int counter = 0;\\n                for(int k=0; k<queriesc[i].length();k++)\\n                {\\n                    if(queriesc[i][k] != dictionary[j][k])\\n                    {\\n                        counter++;\\n                    }\\n                }\\n                if(counter<=2) \\n                {\\n                    res.push_back(queries[i]);\\n                    cout<<queriesc[i]<<\" \"<<dictionary[j]<<endl<<\" \"<<counter<<endl;\\n                    break;\\n                }\\n            }\\n        }    \\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3162798,
                "title": "words-within-two-edits-of-dictionary-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- The function is_valid takes two words as input, query and word, and returns True if the number of different characters between the two words is less than or equal to 2.\\n- The main function wordWithinTwoEdits loops through each query in queries and then loops through each word in dictionary. If is_valid returns True for the current query and word, the query is added to the result list res and the inner loop breaks.\\n- Finally, the function returns the res list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom typing import List\\n\\nclass Solution:\\n  def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n    def is_valid(query, word):\\n        count = 0\\n        for i in range(len(word)):\\n            if word[i] != query[i]:\\n                count += 1\\n                if count > 2:\\n                    return False\\n        return count <= 2\\n\\n    res = []\\n    for query in queries:\\n        for word in dictionary:\\n            if is_valid(query, word):\\n                res.append(query)\\n                break\\n    return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n  def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n    def is_valid(query, word):\\n        count = 0\\n        for i in range(len(word)):\\n            if word[i] != query[i]:\\n                count += 1\\n                if count > 2:\\n                    return False\\n        return count <= 2\\n\\n    res = []\\n    for query in queries:\\n        for word in dictionary:\\n            if is_valid(query, word):\\n                res.append(query)\\n                break\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124044,
                "title": "brute-force-trie-solution-highly-optimised",
                "content": "# **Intution**\\nWe have to just check that for any word in query , if their are less than or equal to 2 charcters in any word from dictionary list also the position of characters should be same.\\n\\nEx.\\nQueries= {\"abcdef\", \"qwerty\", \"abcmnx\", \"qwerxy\"};\\ndictionary= {\"abclde\", \"qwerxx\"}\\n\\nHere as you can see in word **abcdef** matches with **abmdex** as  \"c\" changes to \"m\" and  \"f\" changes to \"x\" therfore two changes only \\nhence we will consider it.\\n\\nabcdef   --> abmdex by total 2 char change.....        **consider**\\nqwerty  --> qwerxx by 2 char change..................      **consider**\\nabclnx  --> abcmde by 3 char change.............      **not consider**\\nqwerxy   --> qwerxx by total 1 char change.......        **consider**\\n\\nTherefore we have to just check different character count as well as their position.\\n\\n# code\\n**Brute force Approach**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dic) {\\n        \\n        vector<string>ans;\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            if(check(queries[i], dic))ans.push_back(queries[i]);\\n        }\\n        return ans;\\n        \\n    }\\n\\t// funtion to check given string should be considered or not\\n    bool check(string &s, vector<string>& dic)\\n    {\\n       for(auto it: dic)\\n       {\\n         int diff_char=0;   \\n           for(int i=0; i<s.length() ; i++)\\n           {\\n               if(s[i]!= it[i])diff_char++;\\n               if(diff_char>2)break;\\n           }\\n           if(diff_char<=2)return 1;\\n           \\n       }\\n        return 0;\\n    }\\n};\\n```\\n\\n\\n**Optimised Approach (Trie solution)**\\n\\n```\\nclass TrieNode\\n{\\n    public:\\n    TrieNode* links[26];\\n    int eow;\\n    TrieNode()\\n    {\\n        eow=0;\\n        for(int i=0; i<26;i++)links[i]=NULL;\\n    }\\n};\\nclass Trie\\n{\\n    public:\\n    TrieNode* root;\\n    Trie()\\n    {\\n        root= new TrieNode();\\n    }\\n    \\n    void insert(string &s)\\n    {\\n        TrieNode* temp= root;\\n        for(auto it: s)\\n        {\\n            if(!temp->links[it-\\'a\\'])temp->links[it-\\'a\\']= new TrieNode();\\n            temp= temp->links[it-\\'a\\'];\\n        }\\n        temp->eow++;\\n    }\\n    bool checkmatch(string &s)\\n    {\\n        TrieNode*temp = root;\\n        \\n        return go(temp, s, 2, 0);\\n    }\\n    bool go(TrieNode* temp, string & s, int steps, int ind)\\n    {\\n        if(steps<0 || ind==s.length())return steps>=0;\\n        bool ans=0;\\n        for(int i=0; i<26; i++)\\n        {\\n            if(temp->links[i])\\n            {\\n                ans= ans|go(temp->links[i], s, steps- (i+\\'a\\'!=s[ind]), ind+1 );\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        Trie t;\\n        for(auto it: dictionary)\\n        {\\n            t.insert(it);\\n        }\\n        vector<string >ans;\\n        for(auto it: queries)\\n        {\\n            if(t.checkmatch(it))ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dic) {\\n        \\n        vector<string>ans;\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            if(check(queries[i], dic))ans.push_back(queries[i]);\\n        }\\n        return ans;\\n        \\n    }\\n\\t// funtion to check given string should be considered or not\\n    bool check(string &s, vector<string>& dic)\\n    {\\n       for(auto it: dic)\\n       {\\n         int diff_char=0;   \\n           for(int i=0; i<s.length() ; i++)\\n           {\\n               if(s[i]!= it[i])diff_char++;\\n               if(diff_char>2)break;\\n           }\\n           if(diff_char<=2)return 1;\\n           \\n       }\\n        return 0;\\n    }\\n};\\n```\n```\\nclass TrieNode\\n{\\n    public:\\n    TrieNode* links[26];\\n    int eow;\\n    TrieNode()\\n    {\\n        eow=0;\\n        for(int i=0; i<26;i++)links[i]=NULL;\\n    }\\n};\\nclass Trie\\n{\\n    public:\\n    TrieNode* root;\\n    Trie()\\n    {\\n        root= new TrieNode();\\n    }\\n    \\n    void insert(string &s)\\n    {\\n        TrieNode* temp= root;\\n        for(auto it: s)\\n        {\\n            if(!temp->links[it-\\'a\\'])temp->links[it-\\'a\\']= new TrieNode();\\n            temp= temp->links[it-\\'a\\'];\\n        }\\n        temp->eow++;\\n    }\\n    bool checkmatch(string &s)\\n    {\\n        TrieNode*temp = root;\\n        \\n        return go(temp, s, 2, 0);\\n    }\\n    bool go(TrieNode* temp, string & s, int steps, int ind)\\n    {\\n        if(steps<0 || ind==s.length())return steps>=0;\\n        bool ans=0;\\n        for(int i=0; i<26; i++)\\n        {\\n            if(temp->links[i])\\n            {\\n                ans= ans|go(temp->links[i], s, steps- (i+\\'a\\'!=s[ind]), ind+1 );\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        Trie t;\\n        for(auto it: dictionary)\\n        {\\n            t.insert(it);\\n        }\\n        vector<string >ans;\\n        for(auto it: queries)\\n        {\\n            if(t.checkmatch(it))ans.push_back(it);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785089,
                "title": "c-python-brute-force",
                "content": "**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> v;\\n        for(auto& i : queries){\\n            for(auto& j : dictionary){\\n                int c=0, p=0, q=0;\\n                while(p<i.size() && q<j.size()){\\n                    if(i[p] != j[q]) ++c;\\n                    if(c>2) break;\\n                    ++p,++q;\\n                }\\n                if(c<=2){\\n                    v.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        v = []\\n        for i in queries:\\n            for j in dictionary:\\n                c,p,q = 0,0,0\\n                while(p<len(i) and q<len(j)):\\n                    if(i[p] != j[q]): c += 1\\n                    if(c>2): break\\n                    p += 1\\n                    q += 1\\n                if(c<=2):\\n                    v.append(i)\\n                    break\\n        return v\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> v;\\n        for(auto& i : queries){\\n            for(auto& j : dictionary){\\n                int c=0, p=0, q=0;\\n                while(p<i.size() && q<j.size()){\\n                    if(i[p] != j[q]) ++c;\\n                    if(c>2) break;\\n                    ++p,++q;\\n                }\\n                if(c<=2){\\n                    v.push_back(i);\\n                    break;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        v = []\\n        for i in queries:\\n            for j in dictionary:\\n                c,p,q = 0,0,0\\n                while(p<len(i) and q<len(j)):\\n                    if(i[p] != j[q]): c += 1\\n                    if(c>2): break\\n                    p += 1\\n                    q += 1\\n                if(c<=2):\\n                    v.append(i)\\n                    break\\n        return v\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775130,
                "title": "python-simple-solution-using-sets",
                "content": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        a=[]\\n        s=set(dictionary)\\n        for i in queries:\\n            if i in s:\\n                a.append(i)\\n            else:\\n                for j in s:\\n                    c=0\\n                    for k in range(len(i)):\\n                        if i[k]!=j[k]:\\n                            c+=1\\n                    if c<=2:\\n                        a.append(i)\\n                        break\\n        return a\\n                \\n```\\n\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        a=[]\\n        s=set(dictionary)\\n        for i in queries:\\n            if i in s:\\n                a.append(i)\\n            else:\\n                for j in s:\\n                    c=0\\n                    for k in range(len(i)):\\n                        if i[k]!=j[k]:\\n                            c+=1\\n                    if c<=2:\\n                        a.append(i)\\n                        break\\n        return a\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773215,
                "title": "java-slow-but-understandable-solution",
                "content": "```\\nclass Solution {\\n\\n    //helper function to count number of characters which are not matching\\n    public int func(String a,String b){\\n        int count=0;\\n        int n=a.length();\\n        for(int i=0;i<n;i++){\\n            if(a.charAt(i)!=b.charAt(i)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        ArrayList<String>l=new ArrayList<>();\\n        int q=queries.length;\\n        int d=dictionary.length;\\n        int x=0;\\n        int count=0;\\n        \\n        for(int i=0;i<q;i++){\\n            String a=queries[i];\\n            x=0;\\n            for(int j=0;j<d;j++){\\n                String b=dictionary[j];\\n                count=func(a,b);\\n                if(count<3){\\n                    l.add(a);\\n                    x=1;\\n                }\\n                if(x==1){\\n                    j=d;\\n                }\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    //helper function to count number of characters which are not matching\\n    public int func(String a,String b){\\n        int count=0;\\n        int n=a.length();\\n        for(int i=0;i<n;i++){\\n            if(a.charAt(i)!=b.charAt(i)){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        ArrayList<String>l=new ArrayList<>();\\n        int q=queries.length;\\n        int d=dictionary.length;\\n        int x=0;\\n        int count=0;\\n        \\n        for(int i=0;i<q;i++){\\n            String a=queries[i];\\n            x=0;\\n            for(int j=0;j<d;j++){\\n                String b=dictionary[j];\\n                count=func(a,b);\\n                if(count<3){\\n                    l.add(a);\\n                    x=1;\\n                }\\n                if(x==1){\\n                    j=d;\\n                }\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2767316,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans  = new ArrayList<>();\\n        \\n        for(int i=0; i<queries.length; i++){\\n            String q = queries[i];\\n            for(int idx =0; idx<dictionary.length; idx++){\\n                if(q.length()==dictionary[idx].length()){ \\n                int count =0;\\n                String d =dictionary[idx]; \\n                for(int x=0; x<d.length(); x++){\\n                    if(q.charAt(x)!=d.charAt(x)){\\n                        count++;\\n                    }\\n                }\\n                    if(count<=2){ans.add(q); break;}\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n**second way**\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] q, String[] d) {\\n        List<String> ans  = new ArrayList<>();\\n        int n = q.length;\\n        int m = d.length;\\n        for(int i=0; i<n; i++){\\n            for(int idx =0; idx<m; idx++){\\n               if(helper(q[i],d[idx])==true){\\n                   ans.add(q[i]);\\n                   break;\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean helper(String first , String second){\\n        int count =0;\\n        for(int i=0; i<first.length(); i++){\\n            if(first.charAt(i)!=second.charAt(i)){\\n                count++;\\n            }\\n        }\\n        return count <=2 ? true : false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans  = new ArrayList<>();\\n        \\n        for(int i=0; i<queries.length; i++){\\n            String q = queries[i];\\n            for(int idx =0; idx<dictionary.length; idx++){\\n                if(q.length()==dictionary[idx].length()){ \\n                int count =0;\\n                String d =dictionary[idx]; \\n                for(int x=0; x<d.length(); x++){\\n                    if(q.charAt(x)!=d.charAt(x)){\\n                        count++;\\n                    }\\n                }\\n                    if(count<=2){ans.add(q); break;}\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] q, String[] d) {\\n        List<String> ans  = new ArrayList<>();\\n        int n = q.length;\\n        int m = d.length;\\n        for(int i=0; i<n; i++){\\n            for(int idx =0; idx<m; idx++){\\n               if(helper(q[i],d[idx])==true){\\n                   ans.add(q[i]);\\n                   break;\\n               }\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean helper(String first , String second){\\n        int count =0;\\n        for(int i=0; i<first.length(); i++){\\n            if(first.charAt(i)!=second.charAt(i)){\\n                count++;\\n            }\\n        }\\n        return count <=2 ? true : false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766304,
                "title": "c-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int diff(string a, string b)\\n    {\\n        int n=a.size();\\n        int d=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(a[x]!=b[x]) d++;\\n        }\\n        return d;\\n    }\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) \\n    {\\n        int q=queries.size(), d=dictionary.size();\\n        vector<string> ans;\\n        for(int x=0; x<q; x++)\\n        {\\n            for(int y=0; y<d; y++)\\n            {\\n                if(diff(queries[x],dictionary[y])<=2)\\n                {\\n                    ans.push_back(queries[x]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Kshipra Malviya",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution \\n{\\npublic:\\n    int diff(string a, string b)\\n    {\\n        int n=a.size();\\n        int d=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(a[x]!=b[x]) d++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2762249,
                "title": "java-words-within-two-edits-of-dictionary",
                "content": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> l=new ArrayList<>();\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            for(int j=0;j<dictionary.length;j++)\\n            {\\n                if(match(queries[i],dictionary[j])){l.add(queries[i]);break;}\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    public static boolean match(String s1,String s2)\\n    {\\n        int c=0;\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(s1.charAt(i)!=s2.charAt(i))c++;\\n        }\\n        return c<=2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> l=new ArrayList<>();\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            for(int j=0;j<dictionary.length;j++)\\n            {\\n                if(match(queries[i],dictionary[j])){l.add(queries[i]);break;}\\n            }\\n        }\\n        return l;\\n    }\\n    \\n    public static boolean match(String s1,String s2)\\n    {\\n        int c=0;\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(s1.charAt(i)!=s2.charAt(i))c++;\\n        }\\n        return c<=2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759046,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        res = []\\n        for q in range(len(queries)):\\n            for d in range(len(dictionary)):\\n                c = 0\\n                for i in range(len(queries[q])):\\n                    if queries[q][i] != dictionary[d][i]:\\n                        c += 1\\n                if c <= 2:\\n                    res.append(queries[q])\\n                    break\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        res = []\\n        for q in range(len(queries)):\\n            for d in range(len(dictionary)):\\n                c = 0\\n                for i in range(len(queries[q])):\\n                    if queries[q][i] != dictionary[d][i]:\\n                        c += 1\\n                if c <= 2:\\n                    res.append(queries[q])\\n                    break\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757451,
                "title": "c-faster-than-100-solution",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) \\n    {\\n        vector<string> ans;\\n        for(int i = 0; i < queries.size(); i++)\\n        {\\n            for(int j = 0; j < dictionary.size(); j++)\\n            {\\n                int count = 0;\\n                for(int k = 0; k < queries[0].size(); k++)\\n                {\\n                    if(dictionary[j][k] != queries[i][k])\\n                    {\\n                        count++;\\n                    }\\n                    if(count > 2)\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(count <= 2)\\n                {\\n                    ans.push_back(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) \\n    {\\n        vector<string> ans;\\n        for(int i = 0; i < queries.size(); i++)\\n        {\\n            for(int j = 0; j < dictionary.size(); j++)\\n            {\\n                int count = 0;\\n                for(int k = 0; k < queries[0].size(); k++)\\n                {\\n                    if(dictionary[j][k] != queries[i][k])\\n                    {\\n                        count++;\\n                    }\\n                    if(count > 2)\\n                    {\\n                        break;\\n                    }\\n                }\\n                if(count <= 2)\\n                {\\n                    ans.push_back(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757409,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    \\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        \\n        ans = []\\n        \\n        for query_word in queries:        \\n            for dictionary_word in dictionary:\\n                \\n                edits = 0\\n                for letter1, letter2 in zip(query_word, dictionary_word):\\n                    \\n                    if letter1 != letter2:\\n                        edits += 1\\n                        \\n                    if edits > 2:\\n                        break\\n                else:\\n                    ans.append(query_word) \\n                    break\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        \\n        ans = []\\n        \\n        for query_word in queries:        \\n            for dictionary_word in dictionary:\\n                \\n                edits = 0\\n                for letter1, letter2 in zip(query_word, dictionary_word):\\n                    \\n                    if letter1 != letter2:\\n                        edits += 1\\n                        \\n                    if edits > 2:\\n                        break\\n                else:\\n                    ans.append(query_word) \\n                    break\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757167,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        vector<string>ans;\\n        for(auto q_str:q)\\n        {\\n            for(auto d_str:d)\\n            {\\n                int cnt=0;\\n                for(int i=0;i<d_str.size();i++)\\n                {\\n                    if(q_str[i]!=d_str[i])\\n                        cnt++;\\n                }\\n                if(cnt<=2)\\n                {\\n                    ans.push_back(q_str);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        vector<string>ans;\\n        for(auto q_str:q)\\n        {\\n            for(auto d_str:d)\\n            {\\n                int cnt=0;\\n                for(int i=0;i<d_str.size();i++)\\n                {\\n                    if(q_str[i]!=d_str[i])\\n                        cnt++;\\n                }\\n                if(cnt<=2)\\n                {\\n                    ans.push_back(q_str);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757018,
                "title": "java-15-ms-brute-force-approach",
                "content": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> l=new ArrayList<>();\\n        for(int i=0; i<queries.length; i++){\\n            char arr[]= queries[i].toCharArray();\\n            for(int j=0; j<dictionary.length; j++){\\n                int count=0;\\n                for(int k=0; k<arr.length; k++){\\n                    if(dictionary[j].charAt(k)==arr[k]){\\n                        count++;\\n                    }\\n                }\\n                if(Math.abs(dictionary[j].length()-count)<=2){\\n                    l.add(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> l=new ArrayList<>();\\n        for(int i=0; i<queries.length; i++){\\n            char arr[]= queries[i].toCharArray();\\n            for(int j=0; j<dictionary.length; j++){\\n                int count=0;\\n                for(int k=0; k<arr.length; k++){\\n                    if(dictionary[j].charAt(k)==arr[k]){\\n                        count++;\\n                    }\\n                }\\n                if(Math.abs(dictionary[j].length()-count)<=2){\\n                    l.add(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756988,
                "title": "python-brute-force",
                "content": "```\\nres = [] \\n        for s in queries: \\n            #count=0\\n            for d in range(0,len(dictionary)):\\n                count=0\\n                i,j=0,0\\n                if len(s)!=len(dictionary[d]):\\n                    continue \\n                while(j<len(s)):\\n                    if s[j]==dictionary[d][i]:\\n                        j+=1 \\n                        i+=1\\n                    elif s[j]!=dictionary[d][i]:\\n                        count+=1 \\n                        if count>2:\\n                            count=-1\\n                            break\\n                        i+=1\\n                        j+=1 \\n                if count!=-1:\\n                    res.append(s)\\n                    break\\n        return res",
                "solutionTags": [],
                "code": "```\\nres = [] \\n        for s in queries: \\n            #count=0\\n            for d in range(0,len(dictionary)):\\n                count=0\\n                i,j=0,0\\n                if len(s)!=len(dictionary[d]):\\n                    continue \\n                while(j<len(s)):\\n                    if s[j]==dictionary[d][i]:\\n                        j+=1 \\n                        i+=1\\n                    elif s[j]!=dictionary[d][i]:\\n                        count+=1 \\n                        if count>2:\\n                            count=-1\\n                            break\\n                        i+=1\\n                        j+=1 \\n                if count!=-1:\\n                    res.append(s)\\n                    break\\n        return res",
                "codeTag": "Unknown"
            },
            {
                "id": 2756862,
                "title": "bruteforce-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        \\n        for (auto &str1: queries) {\\n            int mn = INT_MAX;\\n            \\n            for (auto &str2: dictionary) {\\n                int cnt = 0;\\n                \\n                for (int i = 0; i < str1.size(); i++) {\\n                    if (str1[i] != str2[i]) cnt++;\\n                }\\n                \\n                mn = min(cnt, mn);\\n            }\\n            \\n            if (mn <= 2) ans.push_back(str1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        \\n        for (auto &str1: queries) {\\n            int mn = INT_MAX;\\n            \\n            for (auto &str2: dictionary) {\\n                int cnt = 0;\\n                \\n                for (int i = 0; i < str1.size(); i++) {\\n                    if (str1[i] != str2[i]) cnt++;\\n                }\\n                \\n                mn = min(cnt, mn);\\n            }\\n            \\n            if (mn <= 2) ans.push_back(str1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756646,
                "title": "python-straight-forward-code",
                "content": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        output = []\\n        count = 0\\n        for word_queries in queries:\\n            for word_dictionary in dictionary:\\n                count = 0\\n                for i in range(len(word_queries)):\\n                    if word_queries[i] != word_dictionary[i]:\\n                        count += 1\\n                if count<=2:\\n                    output.append(word_queries)\\n                    break\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        output = []\\n        count = 0\\n        for word_queries in queries:\\n            for word_dictionary in dictionary:\\n                count = 0\\n                for i in range(len(word_queries)):\\n                    if word_queries[i] != word_dictionary[i]:\\n                        count += 1\\n                if count<=2:\\n                    output.append(word_queries)\\n                    break\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756645,
                "title": "c-with-notes-and-explanation",
                "content": "# Approach\\n1) Compare each word `queries` to each word of `dictionary`\\n2) Count the number of different letters (this is the number of edit)\\n3) If there are less or equal than 2 different letter, add that query to res \\n\\n# Complexity\\n`k = queries.size()`\\n`m = dictionary.size()`\\n`n = queries[0].size()`\\n- Time complexity:$$O(k*m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(k)$$ (worst case)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        int n = queries[0].size();\\n        vector<string> res;\\n        \\n        //take in consideration each word in queries\\n        for (string query : queries){\\n            //compare it to each word in dictionary\\n            for (string word : dictionary){\\n                int edits = 0;\\n                //find number of edits need to make query == word\\n                for (int i = 0; i < n; i++){\\n                    if (query[i] != word[i])\\n                        edits++;\\n                    //go to next word because we can have maximum of two edit\\n                    if (edits > 2)\\n                        break;\\n                }\\n                \\n                //if making query == word, needs less or equal than 2 edits, add it to res, and check next query\\n                if (edits <= 2){\\n                    res.push_back(query);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        int n = queries[0].size();\\n        vector<string> res;\\n        \\n        //take in consideration each word in queries\\n        for (string query : queries){\\n            //compare it to each word in dictionary\\n            for (string word : dictionary){\\n                int edits = 0;\\n                //find number of edits need to make query == word\\n                for (int i = 0; i < n; i++){\\n                    if (query[i] != word[i])\\n                        edits++;\\n                    //go to next word because we can have maximum of two edit\\n                    if (edits > 2)\\n                        break;\\n                }\\n                \\n                //if making query == word, needs less or equal than 2 edits, add it to res, and check next query\\n                if (edits <= 2){\\n                    res.push_back(query);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756567,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        vector<string> ans;\\n        for(string s : q) {\\n            for(string str : d) {\\n                int d = 0;\\n                for(int i=0; i<s.size(); i++) {\\n                    if(str[i] != s[i]) d++;\\n                }\\n                if(d <= 2) {ans.push_back(s); break;}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        vector<string> ans;\\n        for(string s : q) {\\n            for(string str : d) {\\n                int d = 0;\\n                for(int i=0; i<s.size(); i++) {\\n                    if(str[i] != s[i]) d++;\\n                }\\n                if(d <= 2) {ans.push_back(s); break;}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756565,
                "title": "c-brute-force-82-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(string &a, string &b){\\n      int cnt = 0;\\n      for(int i = 0; i < a.size(); i++){\\n        if(a[i] != b[i])\\n          cnt++;\\n      }\\n      return cnt <= 2;\\n    }\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n      vector<string> ans;\\n      for(auto &i: q){\\n        for(auto &j: d){\\n          if(helper(i, j)){\\n            ans.emplace_back(i); break;\\n          } \\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(string &a, string &b){\\n      int cnt = 0;\\n      for(int i = 0; i < a.size(); i++){\\n        if(a[i] != b[i])\\n          cnt++;\\n      }\\n      return cnt <= 2;\\n    }\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n      vector<string> ans;\\n      for(auto &i: q){\\n        for(auto &j: d){\\n          if(helper(i, j)){\\n            ans.emplace_back(i); break;\\n          } \\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756531,
                "title": "java-easy-but-brute-force",
                "content": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        HashSet<String> set = new HashSet<>();\\n        List<String> list = new ArrayList<>();\\n        int n = queries.length;\\n        \\n        for(int i=0; i<n; i++){\\n            String word1 = queries[i];\\n            for(int j=0; j<dictionary.length; j++){\\n                int cnt=0;\\n                String word2 = dictionary[j];\\n                \\n                int len=0;\\n                \\n                if(word1.length() < word2.length()) len = word1.length();\\n                else len = word2.length();\\n                \\n                for(int k=0; k<len; k++){\\n                    if(word1.charAt(k) != word2.charAt(k)) cnt++;\\n                    if(cnt > 2) break;\\n                }\\n                if(cnt <=2) {\\n                    set.add(word1);\\n                    list.add(word1);\\n                    break;\\n\\n                }\\n            }\\n        }\\n        \\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        HashSet<String> set = new HashSet<>();\\n        List<String> list = new ArrayList<>();\\n        int n = queries.length;\\n        \\n        for(int i=0; i<n; i++){\\n            String word1 = queries[i];\\n            for(int j=0; j<dictionary.length; j++){\\n                int cnt=0;\\n                String word2 = dictionary[j];\\n                \\n                int len=0;\\n                \\n                if(word1.length() < word2.length()) len = word1.length();\\n                else len = word2.length();\\n                \\n                for(int k=0; k<len; k++){\\n                    if(word1.charAt(k) != word2.charAt(k)) cnt++;\\n                    if(cnt > 2) break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2756527,
                "title": "brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int compare(string s1,string s2, int cnt = 0){\\n        for(int i = 0;i<s1.size();i++)\\n            if(s1[i] != s2[i])++cnt;\\n        return cnt;\\n    }\\n    \\n    vector<string> twoEditWords(vector<string>& q, vector<string>& dict) {\\n       vector<string> ans;\\n        for(auto s:q){\\n            for(auto ele:dict){\\n                if(compare(s,ele) <= 2){\\n                    ans.push_back(s);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int compare(string s1,string s2, int cnt = 0){\\n        for(int i = 0;i<s1.size();i++)\\n            if(s1[i] != s2[i])++cnt;\\n        return cnt;\\n    }\\n    \\n    vector<string> twoEditWords(vector<string>& q, vector<string>& dict) {\\n       vector<string> ans;\\n        for(auto s:q){\\n            for(auto ele:dict){\\n                if(compare(s,ele) <= 2){\\n                    ans.push_back(s);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756481,
                "title": "easy-c-brute-force-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string>mm;\\n        for(int i=0;i<queries.size();i++){\\n            for(int j=0;j<dictionary.size();j++){\\n                int cnt=0;\\n                for(int k=0;k<dictionary[j].size();k++){\\n                    if(queries[i][k]!=dictionary[j][k]){\\n                        cnt++;\\n                    }\\n                }\\n                if(cnt<=2){\\n                mm.push_back(queries[i]);\\n                break;\\n                }\\n\\n            }\\n\\n        }\\n\\n        return mm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string>mm;\\n        for(int i=0;i<queries.size();i++){\\n            for(int j=0;j<dictionary.size();j++){\\n                int cnt=0;\\n                for(int k=0;k<dictionary[j].size();k++){\\n                    if(queries[i][k]!=dictionary[j][k]){\\n                        cnt++;\\n                    }\\n                }\\n                if(cnt<=2){\\n                mm.push_back(queries[i]);\\n                break;\\n                }\\n\\n            }\\n\\n        }\\n\\n        return mm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756445,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    bool func(const string&a, const string&b){\\n        ll ans=0;\\n        for(ll i=0;i<a.size();++i){\\n            ans+=a[i]!=b[i];\\n        }\\n        return (ans<3);\\n    }\\n    vector<string> twoEditWords(vector<string>&q, vector<string>&d) {\\n        vi(string)ans;\\n        for(const string&a:q){\\n            for(const string&b:d){\\n                if(func(a, b)){\\n                    ans.pb(a);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    bool func(const string&a, const string&b){\\n        ll ans=0;\\n        for(ll i=0;i<a.size();++i){\\n            ans+=a[i]!=b[i];\\n        }\\n        return (ans<3);\\n    }\\n    vector<string> twoEditWords(vector<string>&q, vector<string>&d) {\\n        vi(string)ans;\\n        for(const string&a:q){\\n            for(const string&b:d){\\n                if(func(a, b)){\\n                    ans.pb(a);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756437,
                "title": "java-simple-array-solution",
                "content": "public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n\\n        List<String> ans = new ArrayList<>();\\n        for(int i=0;i<queries.length;i++) {\\n            String q = queries[i];\\n            for(int j=0;j<dictionary.length;j++) {\\n                int count =0;\\n                String d = dictionary[j];\\n                for(int k=0;k<queries[0].length();k++) {\\n                    if(q.charAt(k) != d.charAt(k))\\n                        count++;\\n                }\\n                if(count<=2) {\\n                    ans.add(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n\\n        List<String> ans = new ArrayList<>();\\n        for(int i=0;i<queries.length;i++) {\\n            String q = queries[i];\\n            for(int j=0;j<dictionary.length;j++) {\\n                int count =0;\\n                String d = dictionary[j];\\n                for(int k=0;k<queries[0].length();k++) {\\n                    if(q.charAt(k) != d.charAt(k))\\n                        count++;\\n                }\\n                if(count<=2) {\\n                    ans.add(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2756420,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        int sz = dictionary[0].size();\\n        vector<string> res;\\n        for(int i = 0; i < queries.size(); i++) {\\n            string word = queries[i];\\n            for(auto it: dictionary) {\\n                int count = 0;\\n                for(int j = 0; j < sz; j++) {\\n                    if(word[j] == it[j]) count += 1;\\n                }\\n                if(count >= sz - 2) {\\n                    res.push_back(word);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        int sz = dictionary[0].size();\\n        vector<string> res;\\n        for(int i = 0; i < queries.size(); i++) {\\n            string word = queries[i];\\n            for(auto it: dictionary) {\\n                int count = 0;\\n                for(int j = 0; j < sz; j++) {\\n                    if(word[j] == it[j]) count += 1;\\n                }\\n                if(count >= sz - 2) {\\n                    res.push_back(word);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756376,
                "title": "brute-force-c",
                "content": "The Idea is simple, comapre each string of query with all strings of dictionary.If for any string in dictionary given string of query differ in less than 3 position , add this string of query to our result vector.\\n```\\n//function to check if given two string differ in less than 3 positions\\nbool check(string s,string t)\\n    {\\n        int n=s.length();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=t[i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count<=2;\\n    }\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        vector<string> res;\\n        int n=q.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string s=q[i];\\n            for(int j=0;j<d.size();j++)\\n            {\\n                if(check(s,d[j]))\\n                {\\n                    res.push_back(s);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//function to check if given two string differ in less than 3 positions\\nbool check(string s,string t)\\n    {\\n        int n=s.length();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]!=t[i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count<=2;\\n    }\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        vector<string> res;\\n        int n=q.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string s=q[i];\\n            for(int j=0;j<d.size();j++)\\n            {\\n                if(check(s,d[j]))\\n                {\\n                    res.push_back(s);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090405,
                "title": "array-of-chars-comparison-in-c",
                "content": "# Intuition\\nCount the number of different chars for each of the quaries words, relating to the dictionary words\\n# Approach\\nTread the strings as array of chars.\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) \\n    {\\n        vector<string> returnVector;\\n        for (int quaryIndex = 0; quaryIndex < queries.size(); ++quaryIndex)\\n        {\\n            for (int dictionaryIndex = 0; dictionaryIndex < dictionary.size(); ++dictionaryIndex)\\n            {\\n                int neededChangesCounter = 0;\\n                for (int wordIndex = 0; wordIndex < queries[quaryIndex].size() && neededChangesCounter < 3 ; ++wordIndex)\\n                {\\n                    if (queries[quaryIndex][wordIndex] != dictionary[dictionaryIndex][wordIndex])\\n                    {\\n                        neededChangesCounter += 1;\\n                    }\\n                }\\n                if (neededChangesCounter < 3)\\n                {\\n                    returnVector.push_back(queries[quaryIndex]);\\n                    break;                  \\n                }\\n            }\\n        }\\n\\n        return returnVector;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) \\n    {\\n        vector<string> returnVector;\\n        for (int quaryIndex = 0; quaryIndex < queries.size(); ++quaryIndex)\\n        {\\n            for (int dictionaryIndex = 0; dictionaryIndex < dictionary.size(); ++dictionaryIndex)\\n            {\\n                int neededChangesCounter = 0;\\n                for (int wordIndex = 0; wordIndex < queries[quaryIndex].size() && neededChangesCounter < 3 ; ++wordIndex)\\n                {\\n                    if (queries[quaryIndex][wordIndex] != dictionary[dictionaryIndex][wordIndex])\\n                    {\\n                        neededChangesCounter += 1;\\n                    }\\n                }\\n                if (neededChangesCounter < 3)\\n                {\\n                    returnVector.push_back(queries[quaryIndex]);\\n                    break;                  \\n                }\\n            }\\n        }\\n\\n        return returnVector;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060366,
                "title": "java-beats-98-59-2ms-runtime-easy-to-understand-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean wordChangePossible(String query, String word){\\n        int cnt=0;\\n        for(int i=0; i < word.length(); i++){\\n            if(word.charAt(i) != query.charAt(i))\\n                cnt++;\\n            if(cnt > 2)\\n                return false;    \\n        }\\n        return true;\\n    }\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for(String query : queries){\\n            for(String word : dictionary){\\n                if(wordChangePossible(query, word)){\\n                    ans.add(query);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean wordChangePossible(String query, String word){\\n        int cnt=0;\\n        for(int i=0; i < word.length(); i++){\\n            if(word.charAt(i) != query.charAt(i))\\n                cnt++;\\n            if(cnt > 2)\\n                return false;    \\n        }\\n        return true;\\n    }\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for(String query : queries){\\n            for(String word : dictionary){\\n                if(wordChangePossible(query, word)){\\n                    ans.add(query);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058483,
                "title": "js-brutforce-with-map-every",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} queries\\n * @param {string[]} dictionary\\n * @return {string[]}\\n */\\nvar twoEditWords = function(queries, dictionary) {\\n    const answer = [];\\n    queries.map(word=>{\\n        dictionary.every(dWord=>{\\n            let countDiscrepancy = 0;\\n            word.split(\\'\\').map((oneLetterOfWord,i)=>{\\n                if(oneLetterOfWord !== dWord[i]) countDiscrepancy+=1;\\n            })\\n            if(countDiscrepancy<=2) {\\n                answer.push(word);\\n                return false\\n            }\\n            return true\\n        })\\n    })\\n    return answer\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} queries\\n * @param {string[]} dictionary\\n * @return {string[]}\\n */\\nvar twoEditWords = function(queries, dictionary) {\\n    const answer = [];\\n    queries.map(word=>{\\n        dictionary.every(dWord=>{\\n            let countDiscrepancy = 0;\\n            word.split(\\'\\').map((oneLetterOfWord,i)=>{\\n                if(oneLetterOfWord !== dWord[i]) countDiscrepancy+=1;\\n            })\\n            if(countDiscrepancy<=2) {\\n                answer.push(word);\\n                return false\\n            }\\n            return true\\n        })\\n    })\\n    return answer\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018059,
                "title": "greedily-compare-each-query-to-word-inside-dic",
                "content": "# Intuition\\nGreedily just check each query against the words in dic. \\nSince each query and word inside dic are of same length, we can easily check them letter by letter at their position. If there are more than 2 differences we move to the next word in dic, else we add this query and move to next query.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n\\n        valid = []\\n\\n        for q in  queries:\\n            for d in dictionary:\\n                \\n                c = 0\\n\\n                for ql,dl in zip(q,d):\\n                    if ql != dl:\\n                        c +=1\\n                    \\n                    if c >2:\\n                        break\\n                \\n                if c <= 2:\\n                    valid.append(q)\\n                    break\\n\\n        return valid\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n\\n        valid = []\\n\\n        for q in  queries:\\n            for d in dictionary:\\n                \\n                c = 0\\n\\n                for ql,dl in zip(q,d):\\n                    if ql != dl:\\n                        c +=1\\n                    \\n                    if c >2:\\n                        break\\n                \\n                if c <= 2:\\n                    valid.append(q)\\n                    break\\n\\n        return valid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954299,
                "title": "esay-one",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n# Code\\n```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        out = []\\n        count = 0\\n        for i in queries:\\n            for j in dictionary:\\n                count = 0\\n                for k in range(len(i)):\\n                    if i[k] != j[k]:\\n                        count += 1\\n                if count <= 2:\\n                    out.append(i)\\n                    break\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        out = []\\n        count = 0\\n        for i in queries:\\n            for j in dictionary:\\n                count = 0\\n                for k in range(len(i)):\\n                    if i[k] != j[k]:\\n                        count += 1\\n                if count <= 2:\\n                    out.append(i)\\n                    break\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895993,
                "title": "c-simple-solution-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        for(int i=0;i<queries.size();i++){\\n            for(int j=0;j<dictionary.size();j++){\\n                int c=0;\\n                for(int k=0;k<dictionary[j].size();k++){\\n                   \\n                    if(queries[i][k]!=dictionary[j][k]){\\n                        c++;\\n                    }\\n                  \\n                }\\n                if(c<=2){\\n                    ans.push_back(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        for(int i=0;i<queries.size();i++){\\n            for(int j=0;j<dictionary.size();j++){\\n                int c=0;\\n                for(int k=0;k<dictionary[j].size();k++){\\n                   \\n                    if(queries[i][k]!=dictionary[j][k]){\\n                        c++;\\n                    }\\n                  \\n                }\\n                if(c<=2){\\n                    ans.push_back(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893430,
                "title": "brute-force-approach-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> res;\\n\\n        for(int i=0; i<queries.size(); i++){\\n            string s= queries[i];\\n\\n            for(int j=0; j<dictionary.size(); j++){\\n                string s1 = dictionary[j];\\n                int diff=0;\\n\\n                for(int k=0; k<s1.size(); k++){\\n                    if(s1[k] != s[k]){\\n                        diff++;\\n                    }\\n                }\\n                if(diff<=2){\\n                        res.push_back(s);\\n                        break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> res;\\n\\n        for(int i=0; i<queries.size(); i++){\\n            string s= queries[i];\\n\\n            for(int j=0; j<dictionary.size(); j++){\\n                string s1 = dictionary[j];\\n                int diff=0;\\n\\n                for(int k=0; k<s1.size(); k++){\\n                    if(s1[k] != s[k]){\\n                        diff++;\\n                    }\\n                }\\n                if(diff<=2){\\n                        res.push_back(s);\\n                        break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833576,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n\\nJust check every query string if it could be changed 2 times.\\n\\n# Approach\\n\\n1. Loop over `q` string from `queries`\\n2. For each `q` loop over `dictionary` and check if there is a diff of 2 runes between them.\\n3. Add `q` to `res` if diff less or equal 2.\\n\\n# Complexity\\n- Time complexity:\\n`O(len(queries) * len(dicitionary))`\\n\\n- Space complexity:\\n`O(1)`\\n\\n# Code\\n```\\nfunc twoEditWords(queries []string, dictionary []string) []string {\\n\\n    twoEdit := func(word string) bool {\\n        for _, d := range dictionary {\\n            if len(word) != len(d) {continue}\\n            i, c := 0, 0\\n            for i < len(word) {\\n                if word[i] != d[i] {c += 1}\\n                if c > 2 {break}\\n                i += 1\\n            }\\n            if c <= 2 {return true}\\n        }\\n        return false\\n    }\\n\\n    res := []string{}\\n\\n    for _, q := range queries {\\n        if twoEdit(q) {\\n            res = append(res, q)\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc twoEditWords(queries []string, dictionary []string) []string {\\n\\n    twoEdit := func(word string) bool {\\n        for _, d := range dictionary {\\n            if len(word) != len(d) {continue}\\n            i, c := 0, 0\\n            for i < len(word) {\\n                if word[i] != d[i] {c += 1}\\n                if c > 2 {break}\\n                i += 1\\n            }\\n            if c <= 2 {return true}\\n        }\\n        return false\\n    }\\n\\n    res := []string{}\\n\\n    for _, q := range queries {\\n        if twoEdit(q) {\\n            res = append(res, q)\\n        }\\n    }\\n\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3795566,
                "title": "words-within-two-edits-of-dictionary-easy-approach-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int fun(string &a, string &b)\\n    {\\n        int k = 0;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(a[i]!=b[i])\\n            {\\n                k++;\\n            }\\n        }\\n        return k;\\n    }\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) \\n    {\\n        int n = q.size();\\n        int m = d.size();\\n        vector<string> ans;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            string a = q[i];\\n            for(int j=0; j<m; j++)\\n            {\\n                string b = d[j];\\n                int check = fun(a, b);\\n                if(check<=2)\\n                {\\n                    ans.push_back(a);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int fun(string &a, string &b)\\n    {\\n        int k = 0;\\n        for(int i=0; i<a.size(); i++)\\n        {\\n            if(a[i]!=b[i])\\n            {\\n                k++;\\n            }\\n        }\\n        return k;\\n    }\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) \\n    {\\n        int n = q.size();\\n        int m = d.size();\\n        vector<string> ans;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            string a = q[i];\\n            for(int j=0; j<m; j++)\\n            {\\n                string b = d[j];\\n                int check = fun(a, b);\\n                if(check<=2)\\n                {\\n                    ans.push_back(a);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784350,
                "title": "simple-brute-force",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n\\n        vector<string> ans;\\n\\n        int m = q.size();\\n        int n = d.size();\\n\\n        int word_size = q[0].size();\\n\\n        for(int i=0; i<m; i++)//queries\\n        {\\n            for(int j=0; j<n; j++)//dictionary\\n            {\\n                int count = 0;\\n                for(int k=0; k<word_size; k++)//words\\n                {\\n                    if(d[j][k] != q[i][k])\\n                        count++;\\n                }\\n                if(count < 3){\\n                    ans.push_back(q[i]);\\n                    break;\\n                }\\n            }\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/0ccb1873-4160-4688-a490-3c4b2d7ea372_1689703103.3330512.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n\\n        vector<string> ans;\\n\\n        int m = q.size();\\n        int n = d.size();\\n\\n        int word_size = q[0].size();\\n\\n        for(int i=0; i<m; i++)//queries\\n        {\\n            for(int j=0; j<n; j++)//dictionary\\n            {\\n                int count = 0;\\n                for(int k=0; k<word_size; k++)//words\\n                {\\n                    if(d[j][k] != q[i][k])\\n                        count++;\\n                }\\n                if(count < 3){\\n                    ans.push_back(q[i]);\\n                    break;\\n                }\\n            }\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782025,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool present(string s,vector<string>& dictionary){\\n    unordered_map<char,int>mp;\\n    int diff=0;\\n    int n1=s.size();\\n    for(auto it: dictionary){\\n      int n=it.size();\\n      if(n1!=n){\\n          continue;\\n      }\\n      for(int i=0;i<n;i++){\\n      if(it[i]!=s[i]){\\n          diff++;\\n      }\\n      }\\n      if(diff<=2){\\n          return true;\\n      }\\n      diff=0;\\n    }\\n    return false;\\n}\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string>ans;\\n        for(auto it:queries){\\n            if(present(it,dictionary)){\\n                ans.push_back(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool present(string s,vector<string>& dictionary){\\n    unordered_map<char,int>mp;\\n    int diff=0;\\n    int n1=s.size();\\n    for(auto it: dictionary){\\n      int n=it.size();\\n      if(n1!=n){\\n          continue;\\n      }\\n      for(int i=0;i<n;i++){\\n      if(it[i]!=s[i]){\\n          diff++;\\n      }\\n      }\\n      if(diff<=2){\\n          return true;\\n      }\\n      diff=0;\\n    }\\n    return false;\\n}\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string>ans;\\n        for(auto it:queries){\\n            if(present(it,dictionary)){\\n                ans.push_back(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723172,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> words = new ArrayList<>();\\n        for(String query : queries){\\n            for(String word : dictionary){\\n                int count = 0;\\n                int i = 0;\\n                boolean flag = false;\\n                while(i<word.length()){\\n                    if(word.charAt(i) != query.charAt(i) && count<3){\\n                        count++;\\n                    }\\n                    if(count == 3){\\n                        flag = true;\\n                        break;\\n                    }\\n                    i++;\\n                }\\n                if(flag == false){\\n                    words.add(query);\\n                    break;\\n                }\\n            }\\n        }\\n        return words;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> words = new ArrayList<>();\\n        for(String query : queries){\\n            for(String word : dictionary){\\n                int count = 0;\\n                int i = 0;\\n                boolean flag = false;\\n                while(i<word.length()){\\n                    if(word.charAt(i) != query.charAt(i) && count<3){\\n                        count++;\\n                    }\\n                    if(count == 3){\\n                        flag = true;\\n                        break;\\n                    }\\n                    i++;\\n                }\\n                if(flag == false){\\n                    words.add(query);\\n                    break;\\n                }\\n            }\\n        }\\n        return words;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707285,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public IList<string> TwoEditWords(string[] queries, string[] dictionary) {\\n        var list = new List<string>();\\n        foreach(var query in queries) {\\n            foreach(var word in dictionary) {\\n                var nonMatchingChars = FindNonMatchingChars(query, word);\\n                if(nonMatchingChars <= 2) {\\n                    list.Add(query);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return list;\\n    }\\n\\n    private int FindNonMatchingChars(string str1, string str2) {\\n        var nonMatchingChars = 0;\\n        for(int idx = 0; idx < str1.Length && nonMatchingChars < 3; idx++) {\\n            if(str1[idx] != str2[idx])\\n                nonMatchingChars++;\\n        }\\n\\n        return nonMatchingChars;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "String"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> TwoEditWords(string[] queries, string[] dictionary) {\\n        var list = new List<string>();\\n        foreach(var query in queries) {\\n            foreach(var word in dictionary) {\\n                var nonMatchingChars = FindNonMatchingChars(query, word);\\n                if(nonMatchingChars <= 2) {\\n                    list.Add(query);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return list;\\n    }\\n\\n    private int FindNonMatchingChars(string str1, string str2) {\\n        var nonMatchingChars = 0;\\n        for(int idx = 0; idx < str1.Length && nonMatchingChars < 3; idx++) {\\n            if(str1[idx] != str2[idx])\\n                nonMatchingChars++;\\n        }\\n\\n        return nonMatchingChars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703582,
                "title": "100-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> list = new ArrayList<>();\\n        int n = queries.length;\\n        int m = dictionary.length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (isEqualWithinTwoEdits(queries[i], dictionary[j])) {\\n                    list.add(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n    public boolean isEqualWithinTwoEdits(String s1, String s2) {\\n        int unequal = 0;\\n        int i = 0;\\n        while (i < s1.length()) {\\n            if (s1.charAt(i) != s2.charAt(i)) {\\n                ++unequal;\\n            }\\n            if (unequal > 2) return false;\\n            ++i;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> list = new ArrayList<>();\\n        int n = queries.length;\\n        int m = dictionary.length;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (isEqualWithinTwoEdits(queries[i], dictionary[j])) {\\n                    list.add(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return list;\\n    }\\n    public boolean isEqualWithinTwoEdits(String s1, String s2) {\\n        int unequal = 0;\\n        int i = 0;\\n        while (i < s1.length()) {\\n            if (s1.charAt(i) != s2.charAt(i)) {\\n                ++unequal;\\n            }\\n            if (unequal > 2) return false;\\n            ++i;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3667204,
                "title": "very-easy-and-simple-solution-explained-for-beginners",
                "content": "just check for no. of different char in query[i] and all dic word if it is less than or equal to 2 ...store into the answer\\nelse skip..\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& dic) {\\n        vector<string>ans;\\n        for(int i=0;i<q.size();i++){\\n            for(int j=0;j<dic.size();j++){\\n                int c=0;\\n                for(int k=0;k<q[i].size();k++){\\n                    if(q[i][k]!=dic[j][k]) c++;\\n                    if(c>2) break;   //till here only c is greater than 2 so it further also can not validate \\n                }\\n                if(c<=2){              //if for a particular word in dictionary no. of edits required is 2 then no need to check for further elements in dictinary just store in ans and move for next query\\n                    ans.push_back(q[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& dic) {\\n        vector<string>ans;\\n        for(int i=0;i<q.size();i++){\\n            for(int j=0;j<dic.size();j++){\\n                int c=0;\\n                for(int k=0;k<q[i].size();k++){\\n                    if(q[i][k]!=dic[j][k]) c++;\\n                    if(c>2) break;   //till here only c is greater than 2 so it further also can not validate \\n                }\\n                if(c<=2){              //if for a particular word in dictionary no. of edits required is 2 then no need to check for further elements in dictinary just store in ans and move for next query\\n                    ans.push_back(q[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664850,
                "title": "python3-brute-force-solution-easy-and-intuitive-top-5",
                "content": "<h2> Solution for Python3 </h2>\\n\\n```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        two_edit_words = []\\n        for word1 in queries:\\n            for word2 in dictionary:\\n                miss = 0\\n                for char1, char2, in zip(word1, word2):\\n                    if char1 != char2:\\n                        miss += 1\\n                        if miss > 2:\\n                            break\\n\\n                # skip or save word\\n                if miss < 3:\\n                    two_edit_words.append(word1)\\n                    break\\n        return two_edit_words\\n```\\n\\nA simple Python3 solution that brute forces all possible strings. Note the early stopping conditions that greatly improve our average time complexity. time complexity is O(n^2 * k) with n the length of queries and dictionary and k the amount of characters in them. Space complexity is O(n) because the result has to be saved in a new array which is at most n elements. \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        two_edit_words = []\\n        for word1 in queries:\\n            for word2 in dictionary:\\n                miss = 0\\n                for char1, char2, in zip(word1, word2):\\n                    if char1 != char2:\\n                        miss += 1\\n                        if miss > 2:\\n                            break\\n\\n                # skip or save word\\n                if miss < 3:\\n                    two_edit_words.append(word1)\\n                    break\\n        return two_edit_words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640146,
                "title": "java-readable-bruteforce-faster-than-100",
                "content": "```\\npublic List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        var res = new ArrayList<String>();\\n        for (var q:queries){\\n            for (var d:dictionary){\\n                if (isCorrect(q,d)) {\\n                    res.add(q);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean isCorrect(String q, String d){\\n        if (q.length()!=d.length()) return false;\\n        for (int i=0, cnt=0;i<q.length();i++){\\n            cnt+=q.charAt(i)!=d.charAt(i)?1:0;\\n            if (cnt>2) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        var res = new ArrayList<String>();\\n        for (var q:queries){\\n            for (var d:dictionary){\\n                if (isCorrect(q,d)) {\\n                    res.add(q);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public boolean isCorrect(String q, String d){\\n        if (q.length()!=d.length()) return false;\\n        for (int i=0, cnt=0;i<q.length();i++){\\n            cnt+=q.charAt(i)!=d.charAt(i)?1:0;\\n            if (cnt>2) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638122,
                "title": "java-dp",
                "content": "# Approach\\nCalculate edit distance via DP\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    List<String> result = new ArrayList();\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        if(queries == null) return null;\\n        if(queries.length == 0) return List.of();\\n        for(String query: queries){\\n            search(query, dictionary);\\n        }\\n        return result;\\n    }\\n\\n    private void search(String query, String[] dictionary){\\n        for(String word: dictionary){\\n            if(calculateEditDistance(query, word) <=2) {\\n                result.add(query);\\n                break;\\n            }\\n        }\\n    }\\n\\n    private int calculateEditDistance(String s1, String s2){\\n        int[][]dp = new int[s1.length() + 1][s2.length() + 1];\\n        for(int i = 0; i<dp.length; i++){\\n            dp[i][0] = i;\\n            dp[0][i] = i;\\n        }\\n        for(int row = 1; row<dp.length; row++){\\n            for(int col = 1; col<dp[0].length; col++){\\n                if(s1.charAt(row-1) == s2.charAt(col-1)){\\n                    dp[row][col] = dp[row-1][col-1];\\n                } else{\\n                    dp[row][col] = 1 + Math.min(dp[row-1][col-1], Math.min(dp[row-1][col], dp[row][col-1]));\\n                } \\n            }\\n\\n        }\\n        return dp[dp.length-1][dp.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    List<String> result = new ArrayList();\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        if(queries == null) return null;\\n        if(queries.length == 0) return List.of();\\n        for(String query: queries){\\n            search(query, dictionary);\\n        }\\n        return result;\\n    }\\n\\n    private void search(String query, String[] dictionary){\\n        for(String word: dictionary){\\n            if(calculateEditDistance(query, word) <=2) {\\n                result.add(query);\\n                break;\\n            }\\n        }\\n    }\\n\\n    private int calculateEditDistance(String s1, String s2){\\n        int[][]dp = new int[s1.length() + 1][s2.length() + 1];\\n        for(int i = 0; i<dp.length; i++){\\n            dp[i][0] = i;\\n            dp[0][i] = i;\\n        }\\n        for(int row = 1; row<dp.length; row++){\\n            for(int col = 1; col<dp[0].length; col++){\\n                if(s1.charAt(row-1) == s2.charAt(col-1)){\\n                    dp[row][col] = dp[row-1][col-1];\\n                } else{\\n                    dp[row][col] = 1 + Math.min(dp[row-1][col-1], Math.min(dp[row-1][col], dp[row][col-1]));\\n                } \\n            }\\n\\n        }\\n        return dp[dp.length-1][dp.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632874,
                "title": "c-extremely-easy-solution-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        int s=queries[0].size();\\n        int cnt=0;\\n        for(auto s1:queries){\\n            for(auto s2:dictionary){\\n                cnt=0;\\n                for(int i=0;i<s;i++){\\n                    if(s1[i]!=s2[i]) cnt++;\\n                    if(cnt > 2) break;\\n                }\\n                if(cnt<=2){\\n                    ans.push_back(s1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        int s=queries[0].size();\\n        int cnt=0;\\n        for(auto s1:queries){\\n            for(auto s2:dictionary){\\n                cnt=0;\\n                for(int i=0;i<s;i++){\\n                    if(s1[i]!=s2[i]) cnt++;\\n                    if(cnt > 2) break;\\n                }\\n                if(cnt<=2){\\n                    ans.push_back(s1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625501,
                "title": "c-brute-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        int n = queries.size(), m = dictionary.size();\\n        vector<string> res;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int diff = 0;\\n                for (int k = 0; k < queries[i].size(); k++) {\\n                    if (queries[i][k] != dictionary[j][k]) diff++;\\n                }\\n                if (diff <= 2) {\\n                    res.push_back(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        int n = queries.size(), m = dictionary.size();\\n        vector<string> res;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int diff = 0;\\n                for (int k = 0; k < queries[i].size(); k++) {\\n                    if (queries[i][k] != dictionary[j][k]) diff++;\\n                }\\n                if (diff <= 2) {\\n                    res.push_back(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595808,
                "title": "java-brute-force-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N * M * n), N = length of queries[], M = length of dictionary[], n = length of word in dictionary[]\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), except the space of List to return output\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> result = new ArrayList<>();\\n\\n        for(String query : queries){\\n            for(String word : dictionary){\\n                \\n                int n = word.length();\\n                int edit = 0;\\n\\n                for(int i = 0; i < n; i++){\\n                    if(query.charAt(i) != word.charAt(i)) edit++;\\n                    if(edit > 2) break;\\n                }\\n                if(edit <= 2) {\\n                    result.add(query);\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> result = new ArrayList<>();\\n\\n        for(String query : queries){\\n            for(String word : dictionary){\\n                \\n                int n = word.length();\\n                int edit = 0;\\n\\n                for(int i = 0; i < n; i++){\\n                    if(query.charAt(i) != word.charAt(i)) edit++;\\n                    if(edit > 2) break;\\n                }\\n                if(edit <= 2) {\\n                    result.add(query);\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595282,
                "title": "brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n    for(auto &i : queries){\\n        for(auto &j : dictionary){\\n            int c = 0;\\n            for(int k=0;k<i.length();k++) {\\n                if(i[k] != j[k]) \\n                c++;\\n            }\\n            if(c <= 2){ans.push_back(i) ; break;}\\n        }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n    for(auto &i : queries){\\n        for(auto &j : dictionary){\\n            int c = 0;\\n            for(int k=0;k<i.length();k++) {\\n                if(i[k] != j[k]) \\n                c++;\\n            }\\n            if(c <= 2){ans.push_back(i) ; break;}\\n        }\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522429,
                "title": "java-using-basic-comparison-of-characters-with-comments",
                "content": "\\n// b <======2452. Words Within Two Edits of Dictionary ====>\\n    // https://leetcode.com/problems/words-within-two-edits-of-dictionary/description/\\n\\n    // # Simple bas compare kiya characters ko. Agar difference <=2 hai, to possible\\n    // # hai use convert karna.\\n\\n```\\npublic List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n\\n        for (String str : queries) {\\n            for (String s : dictionary) {\\n                int diff = 0;\\n                for (int i = 0; i < str.length(); i++) {\\n                    char ch1 = str.charAt(i);\\n                    char ch2 = s.charAt(i);\\n\\n                    if (ch1 != ch2)\\n                        diff++;\\n                }\\n                if (diff <= 2) {\\n                    ans.add(str);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n\\n        for (String str : queries) {\\n            for (String s : dictionary) {\\n                int diff = 0;\\n                for (int i = 0; i < str.length(); i++) {\\n                    char ch1 = str.charAt(i);\\n                    char ch2 = s.charAt(i);\\n\\n                    if (ch1 != ch2)\\n                        diff++;\\n                }\\n                if (diff <= 2) {\\n                    ans.add(str);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515025,
                "title": "c-easy-brute-force",
                "content": "\\n\\n# Approach\\nSince the maximum size of the queries and dictionary array is only 100.We can try comparing each queries[i] with every word in dictionary and check whether it is having atmost 2 edits.\\n\\n# Complexity\\n- Time complexity:\\nO(n * n * sizeofword)\\nsizeofword=n so O(n * n * n) or O(n^3)=1e6 [worst case]\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dicto) \\n    {\\n       vector<string>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            bool found=0;\\n            for(int j=0;j<dicto.size();j++)\\n            {\\n                if(queries[i].size()!=dicto[j].size())\\n                {\\n                    continue;\\n                }\\n                int cnt=0;\\n                for(int k=0;k<dicto[j].size();k++)\\n                {\\n                    if(queries[i][k]!=dicto[j][k])\\n                    {\\n                        ++cnt;\\n                    }\\n                }\\n                if(cnt<=2)\\n                {\\n                    found=1;\\n                    break;\\n                }\\n            }\\n            if(found)\\n                ans.push_back(queries[i]);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dicto) \\n    {\\n       vector<string>ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            bool found=0;\\n            for(int j=0;j<dicto.size();j++)\\n            {\\n                if(queries[i].size()!=dicto[j].size())\\n                {\\n                    continue;\\n                }\\n                int cnt=0;\\n                for(int k=0;k<dicto[j].size();k++)\\n                {\\n                    if(queries[i][k]!=dicto[j][k])\\n                    {\\n                        ++cnt;\\n                    }\\n                }\\n                if(cnt<=2)\\n                {\\n                    found=1;\\n                    break;\\n                }\\n            }\\n            if(found)\\n                ans.push_back(queries[i]);\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488569,
                "title": "words-within-two-edits-of-dictionary",
                "content": "--------------------- Easy C++ Solution ---------------------\\n\\n# Complexity\\n- Time complexity: $$O(q*d*l)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        const auto& check = [&](const auto& w1, const auto& w2) {\\n            int cnt = 0;\\n            for (int i = 0; i < size(w1); ++i) {\\n                cnt += static_cast<int>(w1[i] != w2[i]);\\n            }\\n            return cnt <= 2;\\n        };\\n        \\n        vector<string> result;\\n        for (const auto& q : queries) {\\n            for (const auto& d : dictionary) {\\n                if (check(q, d)) {\\n                    result.emplace_back(q);\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        const auto& check = [&](const auto& w1, const auto& w2) {\\n            int cnt = 0;\\n            for (int i = 0; i < size(w1); ++i) {\\n                cnt += static_cast<int>(w1[i] != w2[i]);\\n            }\\n            return cnt <= 2;\\n        };\\n        \\n        vector<string> result;\\n        for (const auto& q : queries) {\\n            for (const auto& d : dictionary) {\\n                if (check(q, d)) {\\n                    result.emplace_back(q);\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482533,
                "title": "sometimes-bruteforce-is-way-too-good",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool iseq(string & a,string &b)\\n{\\n    if(a.length()!=b.length())\\n    return false;\\n    int c=0;\\n    for(int i=0;i<b.size();i++)\\n    {\\n        if(a[i]!=b[i])\\n        c++;\\n        if(c>2)\\n        return false;\\n    }\\n    return true;\\n    \\n}\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n      \\n        vector<string>res;\\n       for(int i=0;i<queries.size();i++)\\n       {\\n           for(int j=0;j<dictionary.size();j++)\\n           {\\n               if(iseq(queries[i],dictionary[j]))\\n               {\\n              \\n                  \\n               res.push_back(queries[i]);\\n               \\n               \\n               break;\\n               }\\n\\n           }\\n       }\\n       return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool iseq(string & a,string &b)\\n{\\n    if(a.length()!=b.length())\\n    return false;\\n    int c=0;\\n    for(int i=0;i<b.size();i++)\\n    {\\n        if(a[i]!=b[i])\\n        c++;\\n        if(c>2)\\n        return false;\\n    }\\n    return true;\\n    \\n}\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n      \\n        vector<string>res;\\n       for(int i=0;i<queries.size();i++)\\n       {\\n           for(int j=0;j<dictionary.size();j++)\\n           {\\n               if(iseq(queries[i],dictionary[j]))\\n               {\\n              \\n                  \\n               res.push_back(queries[i]);\\n               \\n               \\n               break;\\n               }\\n\\n           }\\n       }\\n       return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450099,
                "title": "python-easy-solution-string",
                "content": "\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        res=[]\\n        for x in queries:\\n            if x in dictionary:\\n                res.append(x)\\n            else:\\n                for y in dictionary:\\n                    i=0\\n                    ct=0\\n                    while i<len(x):\\n                        if ct>2:\\n                            break\\n                        if x[i]!=y[i]:\\n                            ct+=1\\n                        i+=1\\n                    if ct<=2 and x not in res:\\n                        res.append(x)\\n        return res",
                "solutionTags": [
                    "Python",
                    "Array",
                    "String"
                ],
                "code": "\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        res=[]\\n        for x in queries:\\n            if x in dictionary:\\n                res.append(x)\\n            else:\\n                for y in dictionary:\\n                    i=0\\n                    ct=0\\n                    while i<len(x):\\n                        if ct>2:\\n                            break\\n                        if x[i]!=y[i]:\\n                            ct+=1\\n                        i+=1\\n                    if ct<=2 and x not in res:\\n                        res.append(x)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 3437169,
                "title": "javascript-solution-brute-force-and-trie",
                "content": "# Brute Force\\n```\\n/**\\n * @param {string[]} queries\\n * @param {string[]} dictionary\\n * @return {string[]}\\n */\\nvar twoEditWords = function(queries, dictionary) {\\n    let res = []\\n    let map = {}\\n    \\n    for(let d of dictionary) {\\n        map[d] = true\\n    }\\n    \\n    \\n    for(let q of queries) {\\n        if(map[q] !== undefined) {\\n            res.push(q)\\n        } else {\\n            for(let d of dictionary) {\\n                let count = 0\\n\\n                for(let i = 0; i < q.length; i++) {\\n                    if(q[i] !== d[i]) count++    \\n                    if(count > 2) break\\n                }\\n\\n                if(count <= 2) {\\n                    res.push(q)\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res\\n};\\n```\\n\\n# Trie\\n```\\n/**\\n * @param {string[]} queries\\n * @param {string[]} dictionary\\n * @return {string[]}\\n */\\nvar twoEditWords = function(queries, dictionary) {\\n    let trie = {}\\n    \\n    for(let d of dictionary) {\\n        let temp = trie\\n        \\n        for(let c of d) {\\n            temp[c] ||= {}\\n            temp = temp[c]\\n        }\\n    }\\n    \\n    let res = []\\n    \\n    for(let q of queries) {\\n        if(helper(q, trie, 0, 2)) res.push(q)\\n    }\\n    \\n    return res\\n};\\n\\nconst helper = (s, trie, idx, count) => {\\n    if(count < 0) return false\\n    if(idx === s.length) return true\\n    \\n    let res = false\\n    \\n    for(let k of Object.keys(trie)) {\\n        res |= helper(s, trie[k], idx + 1, s[idx] === k ? count : count - 1)\\n    }\\n        \\n    return res\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```\\n/**\\n * @param {string[]} queries\\n * @param {string[]} dictionary\\n * @return {string[]}\\n */\\nvar twoEditWords = function(queries, dictionary) {\\n    let res = []\\n    let map = {}\\n    \\n    for(let d of dictionary) {\\n        map[d] = true\\n    }\\n    \\n    \\n    for(let q of queries) {\\n        if(map[q] !== undefined) {\\n            res.push(q)\\n        } else {\\n            for(let d of dictionary) {\\n                let count = 0\\n\\n                for(let i = 0; i < q.length; i++) {\\n                    if(q[i] !== d[i]) count++    \\n                    if(count > 2) break\\n                }\\n\\n                if(count <= 2) {\\n                    res.push(q)\\n                    break\\n                }\\n            }\\n        }\\n    }\\n    \\n    return res\\n};\\n```\n```\\n/**\\n * @param {string[]} queries\\n * @param {string[]} dictionary\\n * @return {string[]}\\n */\\nvar twoEditWords = function(queries, dictionary) {\\n    let trie = {}\\n    \\n    for(let d of dictionary) {\\n        let temp = trie\\n        \\n        for(let c of d) {\\n            temp[c] ||= {}\\n            temp = temp[c]\\n        }\\n    }\\n    \\n    let res = []\\n    \\n    for(let q of queries) {\\n        if(helper(q, trie, 0, 2)) res.push(q)\\n    }\\n    \\n    return res\\n};\\n\\nconst helper = (s, trie, idx, count) => {\\n    if(count < 0) return false\\n    if(idx === s.length) return true\\n    \\n    let res = false\\n    \\n    for(let k of Object.keys(trie)) {\\n        res |= helper(s, trie[k], idx + 1, s[idx] === k ? count : count - 1)\\n    }\\n        \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3410863,
                "title": "trie-based-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    class Node {\\n        Map<Character, Node> cache = new HashMap<>();\\n        boolean eof = false; \\n    }\\n\\n    class Trie {\\n        Node root = new Node();\\n\\n        public void insert(String word) {\\n            Node curr = root;\\n\\n            for (char ch : word.toCharArray()) {\\n                \\n                if (!curr.cache.containsKey(ch)) {\\n                    curr.cache.put(ch, new Node());\\n                }\\n                curr = curr.cache.get(ch);\\n            }\\n            curr.eof = true;\\n        }\\n\\n        public boolean check(String word) {\\n            return check(root, word, 0, 0);\\n        }\\n\\n        private boolean check(Node node, String word, int index, int count) {\\n\\n            if (index == word.length()) {\\n                return count <= 2;\\n            }\\n\\n            if (count > 2) {\\n                return false;\\n            }\\n            char ch = word.charAt(index);\\n            Map<Character, Node> cache = node.cache;\\n                    \\n            for (char key : node.cache.keySet()) {\\n                int cnt = count;\\n                \\n                if (key != ch) {\\n                    cnt++;\\n                }\\n\\n                if (check(node.cache.get(key), word, index + 1, cnt)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        Trie trie = new Trie();\\n\\n        for (String word : dictionary) {\\n            trie.insert(word);\\n        }\\n        List<String> ans = new ArrayList<>();\\n\\n        for (String word : queries) {\\n\\n            if (trie.check(word)) {\\n                ans.add(word);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    class Node {\\n        Map<Character, Node> cache = new HashMap<>();\\n        boolean eof = false; \\n    }\\n\\n    class Trie {\\n        Node root = new Node();\\n\\n        public void insert(String word) {\\n            Node curr = root;\\n\\n            for (char ch : word.toCharArray()) {\\n                \\n                if (!curr.cache.containsKey(ch)) {\\n                    curr.cache.put(ch, new Node());\\n                }\\n                curr = curr.cache.get(ch);\\n            }\\n            curr.eof = true;\\n        }\\n\\n        public boolean check(String word) {\\n            return check(root, word, 0, 0);\\n        }\\n\\n        private boolean check(Node node, String word, int index, int count) {\\n\\n            if (index == word.length()) {\\n                return count <= 2;\\n            }\\n\\n            if (count > 2) {\\n                return false;\\n            }\\n            char ch = word.charAt(index);\\n            Map<Character, Node> cache = node.cache;\\n                    \\n            for (char key : node.cache.keySet()) {\\n                int cnt = count;\\n                \\n                if (key != ch) {\\n                    cnt++;\\n                }\\n\\n                if (check(node.cache.get(key), word, index + 1, cnt)) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    }\\n\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        Trie trie = new Trie();\\n\\n        for (String word : dictionary) {\\n            trie.insert(word);\\n        }\\n        List<String> ans = new ArrayList<>();\\n\\n        for (String word : queries) {\\n\\n            if (trie.check(word)) {\\n                ans.add(word);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387764,
                "title": "easy-cpp-solution-simple-brute-force",
                "content": "### Brute Force Solution\\nTime Complexity: O(n * n * n)\\nSpace Complexity : O(1)\\nqueries.length == dictionary.length == n\\nqueries[i].length == dictionary[j].length == n\\n\\n```\\nclass Solution {\\n    bool findDiff(string s1,string s2){\\n        int ct=0;\\n        for(int i=0;i<s1.size();i++){\\n            if(s1[i]!=s2[i]) ct++;\\n            if(ct>2) return 0;\\n        }\\n        return 1;\\n    }\\n    \\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        for(auto it:queries){\\n            for(auto it2:dictionary){\\n                if(findDiff(it,it2)){\\n                    ans.push_back(it);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool findDiff(string s1,string s2){\\n        int ct=0;\\n        for(int i=0;i<s1.size();i++){\\n            if(s1[i]!=s2[i]) ct++;\\n            if(ct>2) return 0;\\n        }\\n        return 1;\\n    }\\n    \\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        for(auto it:queries){\\n            for(auto it2:dictionary){\\n                if(findDiff(it,it2)){\\n                    ans.push_back(it);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376806,
                "title": "c-bf",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> res;\\n        for(int i = 0; i < queries.size(); i++){\\n            for(int j = 0; j < dictionary.size(); j++){\\n                if(queries[i].size() != dictionary[j].size()) continue;\\n                int count = 0;\\n                for(int k = 0; k < queries[i].size(); k++){\\n                    if(queries[i][k] != dictionary[j][k]) count++;\\n                }\\n                if(count <= 2){\\n                    res.push_back(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> res;\\n        for(int i = 0; i < queries.size(); i++){\\n            for(int j = 0; j < dictionary.size(); j++){\\n                if(queries[i].size() != dictionary[j].size()) continue;\\n                int count = 0;\\n                for(int k = 0; k < queries[i].size(); k++){\\n                    if(queries[i][k] != dictionary[j][k]) count++;\\n                }\\n                if(count <= 2){\\n                    res.push_back(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365934,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        int n = queries[0].size() ;\\n        vector<string>ret ;\\n        for(auto& s : queries){\\n            for(auto& t :\\u3000dictionary){\\n                int edit = 0 ;\\n                for(int i = 0; i < n; i++){\\n                    if(s[i] != t[i]){\\n                        edit++ ;\\n                        if(edit > 2)\\n                            break ;\\n                    }\\n                }\\n                if(edit <= 2){\\n                    ret.push_back(s) ;\\n                    break ;\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        int n = queries[0].size() ;\\n        vector<string>ret ;\\n        for(auto& s : queries){\\n            for(auto& t :\\u3000dictionary){\\n                int edit = 0 ;\\n                for(int i = 0; i < n; i++){\\n                    if(s[i] != t[i]){\\n                        edit++ ;\\n                        if(edit > 2)\\n                            break ;\\n                    }\\n                }\\n                if(edit <= 2){\\n                    ret.push_back(s) ;\\n                    break ;\\n                }\\n            }\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363993,
                "title": "the-best-python-solution-with-beats-98-and-runtime-49",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(Q * N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(Q)\\n\\n# Code\\n```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        result = []\\n\\n        def helper(dictionary, qr_word, result):\\n            for id_dict, dict_word in enumerate(dictionary):\\n                counter = 0\\n                for i, char in enumerate(qr_word):\\n                    if dict_word[i] != char:\\n                        counter += 1\\n                        if counter > 2:\\n                            break\\n                if counter <= 2 and qr_word not in result:\\n                    return True\\n            return False\\n\\n        for id_qr, qr_word in enumerate(queries):\\n            if qr_word in dictionary:\\n                result.append(qr_word)\\n                continue\\n            if helper(dictionary, qr_word, result):\\n                result.append(qr_word)\\n\\n        return result if result else []\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        result = []\\n\\n        def helper(dictionary, qr_word, result):\\n            for id_dict, dict_word in enumerate(dictionary):\\n                counter = 0\\n                for i, char in enumerate(qr_word):\\n                    if dict_word[i] != char:\\n                        counter += 1\\n                        if counter > 2:\\n                            break\\n                if counter <= 2 and qr_word not in result:\\n                    return True\\n            return False\\n\\n        for id_qr, qr_word in enumerate(queries):\\n            if qr_word in dictionary:\\n                result.append(qr_word)\\n                continue\\n            if helper(dictionary, qr_word, result):\\n                result.append(qr_word)\\n\\n        return result if result else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363958,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        result = []\\n        for id_qr, qr_word in enumerate(queries):\\n            if qr_word in dictionary:\\n                result.append(qr_word)\\n                continue\\n            for id_dict, dict_word in enumerate(dictionary):\\n                counter = 0\\n                for i, char in enumerate(qr_word):\\n                    if dict_word[i] != char:\\n                        counter += 1\\n                        if counter > 2:\\n                            break\\n                if counter <= 2 and qr_word not in result:\\n                    result.append(qr_word)\\n\\n        return result if result else []\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        result = []\\n        for id_qr, qr_word in enumerate(queries):\\n            if qr_word in dictionary:\\n                result.append(qr_word)\\n                continue\\n            for id_dict, dict_word in enumerate(dictionary):\\n                counter = 0\\n                for i, char in enumerate(qr_word):\\n                    if dict_word[i] != char:\\n                        counter += 1\\n                        if counter > 2:\\n                            break\\n                if counter <= 2 and qr_word not in result:\\n                    result.append(qr_word)\\n\\n        return result if result else []\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351877,
                "title": "python-3-zip-and-sum",
                "content": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        words = []\\n\\n        for source in queries:\\n            for target in dictionary:\\n                if sum(a != b for a,b in zip(source, target)) <= 2:\\n                    words.append(source)\\n                    break\\n\\n        return words\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        words = []\\n\\n        for source in queries:\\n            for target in dictionary:\\n                if sum(a != b for a,b in zip(source, target)) <= 2:\\n                    words.append(source)\\n                    break\\n\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348830,
                "title": "worst-approach-ever-must-see",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] q, String[] d) {\\n        ArrayList<String> list=new ArrayList<>();\\n        for(int i=0;i<q.length;i++){\\n            boolean b=false;\\n            for(int j=0;j<d.length;j++){\\n                int count=0;\\n                for(int k=0;k<d[j].length();k++){\\n                    if(q[i].charAt(k)!=d[j].charAt(k)){\\n                        count++;\\n                    }\\n                }\\n                if(count<=2){\\n                    b=true;\\n                    break;\\n                }\\n            }\\n            if(b==true){\\n                list.add(q[i]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] q, String[] d) {\\n        ArrayList<String> list=new ArrayList<>();\\n        for(int i=0;i<q.length;i++){\\n            boolean b=false;\\n            for(int j=0;j<d.length;j++){\\n                int count=0;\\n                for(int k=0;k<d[j].length();k++){\\n                    if(q[i].charAt(k)!=d[j].charAt(k)){\\n                        count++;\\n                    }\\n                }\\n                if(count<=2){\\n                    b=true;\\n                    break;\\n                }\\n            }\\n            if(b==true){\\n                list.add(q[i]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348541,
                "title": "c-without-trie-simplest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool compare (string s , string p )\\n{\\n    if(s==p)\\n    return true;\\n    int count = 0 ;\\n    for(int i = 0; i<s.size();i++)\\n    {\\n        if(s[i]!=p[i])\\n        count++ ; \\n        if(count>3)\\n        return false; \\n    }\\n    if(count<=2)\\n    return true ; \\n    else return false; \\n}\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dict) \\n    {\\n        vector<string> res ; \\n        for(int i = 0; i<queries.size();i++)\\n        { \\n           \\n            bool check = false; \\n            for(int j = 0; j<dict.size();j++)\\n            {\\n             \\n             if(compare(queries[i],dict[j]))\\n             {   check = true; \\n                 break;\\n             }\\n\\n            }\\n            if(check)\\n            res.push_back(queries[i]);\\n\\n        }\\n\\n\\n        return res; \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool compare (string s , string p )\\n{\\n    if(s==p)\\n    return true;\\n    int count = 0 ;\\n    for(int i = 0; i<s.size();i++)\\n    {\\n        if(s[i]!=p[i])\\n        count++ ; \\n        if(count>3)\\n        return false; \\n    }\\n    if(count<=2)\\n    return true ; \\n    else return false; \\n}\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dict) \\n    {\\n        vector<string> res ; \\n        for(int i = 0; i<queries.size();i++)\\n        { \\n           \\n            bool check = false; \\n            for(int j = 0; j<dict.size();j++)\\n            {\\n             \\n             if(compare(queries[i],dict[j]))\\n             {   check = true; \\n                 break;\\n             }\\n\\n            }\\n            if(check)\\n            res.push_back(queries[i]);\\n\\n        }\\n\\n\\n        return res; \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347488,
                "title": "easy-java-solution",
                "content": "![upvote.jpeg](https://assets.leetcode.com/users/images/f18272d9-12f8-4c78-a662-edd54cad2890_1679917852.0128975.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String>ans=new ArrayList<>();\\n        HashSet<String>set=new HashSet<>();\\n        for(String s:dictionary)set.add(s);\\n        for(String l:queries){\\n            if(set.contains(l)){\\n                ans.add(l);\\n                continue;\\n            }\\n            else{\\n                int count=find(l,set);\\n                if(count<=2)ans.add(l);\\n            }\\n        }\\n        return ans;\\n    }\\n    public int find(String s,HashSet<String>set){\\n        int ans=0;\\n        for(String key:set){\\n            int count=0;\\n            int i=0;\\n            while(i<s.length()){\\n                if(s.charAt(i)!=key.charAt(i))count++;\\n                i++;\\n            }\\n            if(count<=2){\\n                ans=count;\\n                break;\\n        }\\n        }\\n        return ans==0?3:ans;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String>ans=new ArrayList<>();\\n        HashSet<String>set=new HashSet<>();\\n        for(String s:dictionary)set.add(s);\\n        for(String l:queries){\\n            if(set.contains(l)){\\n                ans.add(l);\\n                continue;\\n            }\\n            else{\\n                int count=find(l,set);\\n                if(count<=2)ans.add(l);\\n            }\\n        }\\n        return ans;\\n    }\\n    public int find(String s,HashSet<String>set){\\n        int ans=0;\\n        for(String key:set){\\n            int count=0;\\n            int i=0;\\n            while(i<s.length()){\\n                if(s.charAt(i)!=key.charAt(i))count++;\\n                i++;\\n            }\\n            if(count<=2){\\n                ans=count;\\n                break;\\n        }\\n        }\\n        return ans==0?3:ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333840,
                "title": "c-brutal-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(queries.size() * dictionary.size() * word_length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(queries.size())\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        std::vector<string> res;\\n        for (auto &query: queries) {\\n            if (matchDict(query, dictionary)) {\\n                res.push_back(query);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    bool matchDict(std::string query, vector<string>& dictionary) {\\n        for (auto& dict : dictionary) {\\n            int sum = 0;\\n            for (int i = 0; i < query.size(); i++) {\\n                if (query[i] != dict[i]) sum++;\\n            }\\n            if (sum <= 2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        std::vector<string> res;\\n        for (auto &query: queries) {\\n            if (matchDict(query, dictionary)) {\\n                res.push_back(query);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    bool matchDict(std::string query, vector<string>& dictionary) {\\n        for (auto& dict : dictionary) {\\n            int sum = 0;\\n            for (int i = 0; i < query.size(); i++) {\\n                if (query[i] != dict[i]) sum++;\\n            }\\n            if (sum <= 2) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306814,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func twoEditWords(_ q: [String], _ d: [String]) -> [String] {\\n        \\n        func ok(_ w: String) -> Bool {\\n            \\n            func ok(_ w: String, _ q: String) -> Bool {\\n                guard w.count == q.count else { return false }\\n\\n                var i = w.startIndex\\n                var d = 0\\n\\n                while i != w.endIndex, d < 3 {\\n                    if w[i] != q[i] { d += 1 }\\n                    i = w.index(after: i)\\n                }\\n\\n                return d < 3\\n            }\\n\\n            return d.contains { ok(w, $0) }\\n        }\\n\\n        return q.filter(ok)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func twoEditWords(_ q: [String], _ d: [String]) -> [String] {\\n        \\n        func ok(_ w: String) -> Bool {\\n            \\n            func ok(_ w: String, _ q: String) -> Bool {\\n                guard w.count == q.count else { return false }\\n\\n                var i = w.startIndex\\n                var d = 0\\n\\n                while i != w.endIndex, d < 3 {\\n                    if w[i] != q[i] { d += 1 }\\n                    i = w.index(after: i)\\n                }\\n\\n                return d < 3\\n            }\\n\\n            return d.contains { ok(w, $0) }\\n        }\\n\\n        return q.filter(ok)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303416,
                "title": "beats-95-detailed-solution-based-on-the-given-hints-simple-and-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        // Get size of queries and dictionary vector\\n        int n_q = queries.size(), n_d = dictionary.size();\\n\\n        // Result vector to store results\\n        vector<string> result;\\n\\n        // Iterate over queries vector\\n        for(int i = 0; i < n_q; i++){\\n            // Iterate over dictionary vector\\n            for(int j = 0; j < n_d; j++){    \\n                // Check if ith queries is equal to jth dictionary\\n                if(queries[i] == dictionary[j]){\\n                    result.push_back(queries[i]);\\n                    break;\\n                }else {\\n                    // Variable to count no of different letters in queries and dictionary\\n                    int count = 0;\\n\\n                    // Get size of ith and jth word in queries and dictionary\\n                    int n_qword = queries[i].size(), n_dword = dictionary[j].size();\\n\\n                    // Compare each letter from both the words only if both have equal sizes\\n                    if(n_qword == n_dword){\\n                    // Iterate over letters of words from queries and dictionary\\n                    for(int k = 0; k < n_qword && k < n_dword; k++){\\n                        // Increment the difference counter if letters don\\'t match\\n                        if(queries[i][k] != dictionary[j][k]){\\n                            count++;\\n                            // If difference exceeds 2, then break the loop\\n                            if(count > 2)\\n                                break;\\n                         }   \\n                    }\\n                    // If  the differences is less than equal to then, insert the ith word from queries into the result vector\\n                    if(count <= 2){\\n                        result.push_back(queries[i]);\\n                        break;\\n                    } \\n                    }\\n                }\\n            }\\n            \\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        // Get size of queries and dictionary vector\\n        int n_q = queries.size(), n_d = dictionary.size();\\n\\n        // Result vector to store results\\n        vector<string> result;\\n\\n        // Iterate over queries vector\\n        for(int i = 0; i < n_q; i++){\\n            // Iterate over dictionary vector\\n            for(int j = 0; j < n_d; j++){    \\n                // Check if ith queries is equal to jth dictionary\\n                if(queries[i] == dictionary[j]){\\n                    result.push_back(queries[i]);\\n                    break;\\n                }else {\\n                    // Variable to count no of different letters in queries and dictionary\\n                    int count = 0;\\n\\n                    // Get size of ith and jth word in queries and dictionary\\n                    int n_qword = queries[i].size(), n_dword = dictionary[j].size();\\n\\n                    // Compare each letter from both the words only if both have equal sizes\\n                    if(n_qword == n_dword){\\n                    // Iterate over letters of words from queries and dictionary\\n                    for(int k = 0; k < n_qword && k < n_dword; k++){\\n                        // Increment the difference counter if letters don\\'t match\\n                        if(queries[i][k] != dictionary[j][k]){\\n                            count++;\\n                            // If difference exceeds 2, then break the loop\\n                            if(count > 2)\\n                                break;\\n                         }   \\n                    }\\n                    // If  the differences is less than equal to then, insert the ith word from queries into the result vector\\n                    if(count <= 2){\\n                        result.push_back(queries[i]);\\n                        break;\\n                    } \\n                    }\\n                }\\n            }\\n            \\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289974,
                "title": "c-clean-code",
                "content": "\\'\\'\\'\\n\\n    bool diff(string& q, string& d) {\\n        int nums=0;\\n        for (int i=0; i<q.size(); i++) {\\n            if (q[i] != d[i]) {\\n                ++nums;\\n            }\\n            if (nums > 2) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> res;\\n        for (auto q : queries) {\\n            for (auto d : dictionary) {\\n                if (diff(q, d)) {\\n                    res.push_back(q);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n    bool diff(string& q, string& d) {\\n        int nums=0;\\n        for (int i=0; i<q.size(); i++) {\\n            if (q[i] != d[i]) {\\n                ++nums;\\n            }\\n            if (nums > 2) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> res;\\n        for (auto q : queries) {\\n            for (auto d : dictionary) {\\n                if (diff(q, d)) {\\n                    res.push_back(q);\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 3280070,
                "title": "c-solution-calculating-number-of-differences-o-1-space-complexity",
                "content": "# Intuition\\nFor Each Query Check if number of differences with each letter of dictioanry is less than equal to 2.\\nif YES push into answer and break;\\n\\n\\n# Complexity\\n- Time complexity: O( queries_length * dictionary_length * wordLength )\\n- Space complexity: O( length of answer array )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n\\n        set<string> bank; for(auto x: dictionary) bank.insert(x);\\n\\n        int l=queries[0].length();\\n\\n        vector<string> ans;\\n\\n        for(auto query:queries)\\n        {\\n           string s=query;\\n\\n           for(auto x: dictionary)\\n           {\\n               int count=0;\\n               for(int i=0;i<l;i++)\\n               {\\n                   if(s[i]!=x[i]) count++;\\n               }\\n               if(count<=2)\\n               {\\n                   ans.push_back(s);\\n                   break;\\n               }\\n           }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n\\n        set<string> bank; for(auto x: dictionary) bank.insert(x);\\n\\n        int l=queries[0].length();\\n\\n        vector<string> ans;\\n\\n        for(auto query:queries)\\n        {\\n           string s=query;\\n\\n           for(auto x: dictionary)\\n           {\\n               int count=0;\\n               for(int i=0;i<l;i++)\\n               {\\n                   if(s[i]!=x[i]) count++;\\n               }\\n               if(count<=2)\\n               {\\n                   ans.push_back(s);\\n                   break;\\n               }\\n           }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280064,
                "title": "c-solution-calculating-number-of-differences-o-1-space-complexity",
                "content": "# Intuition\\nFor Each Query Check if number of differences with each letter of dictioanry is less than equal to 2.\\nif YES push into answer and break;\\n\\n\\n# Complexity\\n- Time complexity: O( queries_length * dictionary_length )\\n- Space complexity: O( length of answer array )\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n\\n        set<string> bank; for(auto x: dictionary) bank.insert(x);\\n\\n        int l=queries[0].length();\\n\\n        vector<string> ans;\\n\\n        for(auto query:queries)\\n        {\\n           string s=query;\\n\\n           for(auto x: dictionary)\\n           {\\n               int count=0;\\n               for(int i=0;i<l;i++)\\n               {\\n                   if(s[i]!=x[i]) count++;\\n               }\\n               if(count<=2)\\n               {\\n                   ans.push_back(s);\\n                   break;\\n               }\\n           }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n\\n        set<string> bank; for(auto x: dictionary) bank.insert(x);\\n\\n        int l=queries[0].length();\\n\\n        vector<string> ans;\\n\\n        for(auto query:queries)\\n        {\\n           string s=query;\\n\\n           for(auto x: dictionary)\\n           {\\n               int count=0;\\n               for(int i=0;i<l;i++)\\n               {\\n                   if(s[i]!=x[i]) count++;\\n               }\\n               if(count<=2)\\n               {\\n                   ans.push_back(s);\\n                   break;\\n               }\\n           }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263927,
                "title": "4-liner-very-simple-code-cpp-faster-than-80-percent",
                "content": "# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        for(auto &i : queries)for(auto &j : dictionary){\\n            int c = 0;\\n            for(int k=0;k<i.length();k++) if(i[k] != j[k]) c++;\\n            if(c <= 2){ans.push_back(i) ; break;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        for(auto &i : queries)for(auto &j : dictionary){\\n            int c = 0;\\n            for(int k=0;k<i.length();k++) if(i[k] != j[k]) c++;\\n            if(c <= 2){ans.push_back(i) ; break;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246639,
                "title": "java-soln-faster-than-95",
                "content": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] a, String[] b) {\\n        List<String>ans=new ArrayList<>();\\n        for(int i=0;i<a.length;i++){\\n             String s1=a[i];\\n            for(int j=0;j<b.length;j++){\\n                String s2=b[j];\\n                if(diff(s1,s2)){\\n                    ans.add(s1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public static boolean diff(String s1,String s2){\\n        int c=0;\\n        for(int i=0;i<s1.length();i++){\\n            if(s1.charAt(i)!=s2.charAt(i)){\\n                c++;\\n                if(c>2)return false;\\n            }\\n        }\\n        return true;\\n    }\\n}```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] a, String[] b) {\\n        List<String>ans=new ArrayList<>();\\n        for(int i=0;i<a.length;i++){\\n             String s1=a[i];\\n            for(int j=0;j<b.length;j++){\\n                String s2=b[j];\\n                if(diff(s1,s2)){\\n                    ans.add(s1);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public static boolean diff(String s1,String s2){\\n        int c=0;\\n        for(int i=0;i<s1.length();i++){\\n            if(s1.charAt(i)!=s2.charAt(i)){\\n                c++;\\n                if(c>2)return false;\\n            }\\n        }\\n        return true;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3228003,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        temp = []\\n        for q in queries:\\n            for d in dictionary:\\n                con = self.check_word(q, d)\\n                if con <= 2:\\n                    temp.append((q,con))\\n                    break\\n\\n        res = [ t[0] for t in temp]\\n\\n        return res\\n\\n    def check_word(self, word_a, word_b):\\n        count = 0\\n        for char_a, char_b in zip(word_a, word_b):\\n            if char_a != char_b:\\n                count = count + 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        temp = []\\n        for q in queries:\\n            for d in dictionary:\\n                con = self.check_word(q, d)\\n                if con <= 2:\\n                    temp.append((q,con))\\n                    break\\n\\n        res = [ t[0] for t in temp]\\n\\n        return res\\n\\n    def check_word(self, word_a, word_b):\\n        count = 0\\n        for char_a, char_b in zip(word_a, word_b):\\n            if char_a != char_b:\\n                count = count + 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220648,
                "title": "python-solution",
                "content": "# Intuition\\n![Screenshot 2023-02-23 at 06.25.50.png](https://assets.leetcode.com/users/images/e06aed2f-93d8-44cc-8448-d3b404b4c7e3_1677133633.703286.png)\\n\\n# Approach\\nThe function first defines two helper functions isMatch and isTwoEditMatch, which check whether two strings are a match (i.e., equal or differ by only one character) or can be made a match with at most two edits. These helper functions are used to compare each word in queries with each word in dictionary.\\n\\nThe function then creates a set of words in dictionary for faster lookup. It loops over each word in queries and checks if it is already in the set of words in dictionary. If it is, then it is added to the results list. If it is not, then the function loops over each word in the set of words in dictionary and checks if the two words are a match or can be made a match with at most two edits. If they are, then the word in queries is added to the results list and the loop over words in dictionary is broken to move on to the next word in queries.\\n\\nFinally, the function returns the results list containing the words in queries that match with some word from dictionary after a maximum of two edits.\\n# Complexity\\n- Time complexity:\\n    - The function first creates a set of words in dictionary, which takes O(n) time, where n is the number of words in dictionary.\\n    - The function then loops over each word in queries and for each word, it loops over each word in the set of words in dictionary, which takes O(m * n) time, where m is the number of words in queries.\\n    - Within the loop, the function calls the helper functions isMatch and isTwoEditMatch, which take O(k) time, where k is the length of the words in queries and dictionary.\\n    -Therefore, the overall time complexity of the function is O(m * n * k). So it\\'s O(n^2).\\nSpace complexity:\\n\\n- Space complexity:\\n    - The function creates a set of words in dictionary, which takes O(n) space.\\n    - The function also creates a list results to store the matching words, which takes O(m) space, where m is the number of words in queries.\\n    - Therefore, the overall space complexity of the function is O(n + m). So it\\'s O(n^2).\\n    - \\n# More \\nMore of my LeetCode solutions at https://github.com/aurimas13/Solutions-To-Problems.\\n\\n# Code\\n```\\nfrom typing import List\\n\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        def isMatch(s1: str, s2: str) -> bool:\\n            if s1 == s2:\\n                return True\\n            if len(s1) != len(s2):\\n                return False\\n            count = 0\\n            for i in range(len(s1)):\\n                if s1[i] != s2[i]:\\n                    count += 1\\n                    if count > 1:\\n                        return False\\n            return True\\n\\n        def isTwoEditMatch(s1: str, s2: str) -> bool:\\n            if s1 == s2:\\n                return True\\n            if len(s1) != len(s2):\\n                return False\\n            count = 0\\n            for i in range(len(s1)):\\n                if s1[i] != s2[i]:\\n                    count += 1\\n            return count == 2\\n\\n        wordSet = set(dictionary)\\n        results = []\\n        for query in queries:\\n            if query in wordSet:\\n                results.append(query)\\n            else:\\n                for word in wordSet:\\n                    if isMatch(query, word) or isTwoEditMatch(query, word):\\n                        results.append(query)\\n                        break\\n        return results\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nfrom typing import List\\n\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        def isMatch(s1: str, s2: str) -> bool:\\n            if s1 == s2:\\n                return True\\n            if len(s1) != len(s2):\\n                return False\\n            count = 0\\n            for i in range(len(s1)):\\n                if s1[i] != s2[i]:\\n                    count += 1\\n                    if count > 1:\\n                        return False\\n            return True\\n\\n        def isTwoEditMatch(s1: str, s2: str) -> bool:\\n            if s1 == s2:\\n                return True\\n            if len(s1) != len(s2):\\n                return False\\n            count = 0\\n            for i in range(len(s1)):\\n                if s1[i] != s2[i]:\\n                    count += 1\\n            return count == 2\\n\\n        wordSet = set(dictionary)\\n        results = []\\n        for query in queries:\\n            if query in wordSet:\\n                results.append(query)\\n            else:\\n                for word in wordSet:\\n                    if isMatch(query, word) or isTwoEditMatch(query, word):\\n                        results.append(query)\\n                        break\\n        return results\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214044,
                "title": "simple-python-iterative-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n\\n        ans = []\\n        for w in queries:\\n            for d in dictionary:\\n                l = len(w)\\n                i , move = 0 , 2\\n                while i < l and move >= 0:\\n                    if w[i] != d[i] :\\n                        move -= 1\\n                    i += 1\\n                if i == l and move >= 0 :# to ckeck if at last index move is within range or not\\n                    ans.append(w)\\n                    break\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n\\n        ans = []\\n        for w in queries:\\n            for d in dictionary:\\n                l = len(w)\\n                i , move = 0 , 2\\n                while i < l and move >= 0:\\n                    if w[i] != d[i] :\\n                        move -= 1\\n                    i += 1\\n                if i == l and move >= 0 :# to ckeck if at last index move is within range or not\\n                    ans.append(w)\\n                    break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206815,
                "title": "beats-100-easiest-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    boolean check(String one,String two){\\n\\n    int count=0;\\n\\n    for(int i=0;i<one.length();i++){\\n        if(one.charAt(i)!=two.charAt(i))count++;\\n        if(count>2)return false;\\n    }\\n\\n    return true;\\n\\n    }\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        \\n    List<String>ans=new ArrayList<>();\\n\\n    for(int i=0;i<queries.length;i++){  \\n        for(int j=0;j<dictionary.length;j++){\\n            if(check(queries[i],dictionary[j])){\\n                ans.add(queries[i]);\\n                break;\\n            }\\n        }\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    boolean check(String one,String two){\\n\\n    int count=0;\\n\\n    for(int i=0;i<one.length();i++){\\n        if(one.charAt(i)!=two.charAt(i))count++;\\n        if(count>2)return false;\\n    }\\n\\n    return true;\\n\\n    }\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        \\n    List<String>ans=new ArrayList<>();\\n\\n    for(int i=0;i<queries.length;i++){  \\n        for(int j=0;j<dictionary.length;j++){\\n            if(check(queries[i],dictionary[j])){\\n                ans.add(queries[i]);\\n                break;\\n            }\\n        }\\n    }\\n\\n    return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169965,
                "title": "java",
                "content": "# Intuition\\n//If u tihnk this post helpful,plz upvote it,ty\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n\\n   HashSet<String>ss ;\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n\\n        List<String>list = new ArrayList<>();\\n\\n        ss = new HashSet<>();\\n\\n        for(String s: dictionary){\\n\\n            ss.add(s);\\n        }\\n\\n        for(String s : queries){\\n\\n            if(ss.contains(s)||isValid(s)){\\n\\n                list.add(s);\\n            }\\n        }\\n\\n        return list;\\n    }\\n\\n    public boolean isValid(String t){\\n\\n        for(String s:ss){\\n\\n            if(twoEdit(s,t)){\\n\\n                return true;\\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n\\n    public boolean twoEdit(String s1,String s2){\\n\\n        int req = 0;\\n\\n        for(int i =0;i<s1.length();i++){\\n\\n            if(s1.charAt(i)!=s2.charAt(i)){\\n\\n                req++;\\n            }\\n\\n            if(req>2){\\n\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n\\n\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n   HashSet<String>ss ;\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n\\n        List<String>list = new ArrayList<>();\\n\\n        ss = new HashSet<>();\\n\\n        for(String s: dictionary){\\n\\n            ss.add(s);\\n        }\\n\\n        for(String s : queries){\\n\\n            if(ss.contains(s)||isValid(s)){\\n\\n                list.add(s);\\n            }\\n        }\\n\\n        return list;\\n    }\\n\\n    public boolean isValid(String t){\\n\\n        for(String s:ss){\\n\\n            if(twoEdit(s,t)){\\n\\n                return true;\\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n\\n    public boolean twoEdit(String s1,String s2){\\n\\n        int req = 0;\\n\\n        for(int i =0;i<s1.length();i++){\\n\\n            if(s1.charAt(i)!=s2.charAt(i)){\\n\\n                req++;\\n            }\\n\\n            if(req>2){\\n\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n\\n\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169845,
                "title": "python-200ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def twoEditWords(self, que: List[str], dic: List[str]) -> List[str]:\\n        res=[]\\n        for i in que:\\n           \\n            for j in dic:\\n                count=0\\n                for a,b in zip(i,j):\\n                    if not a==b:\\n                        count+=1\\n                if count<=2 :\\n                    res.append(i)\\n                    break\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, que: List[str], dic: List[str]) -> List[str]:\\n        res=[]\\n        for i in que:\\n           \\n            for j in dic:\\n                count=0\\n                for a,b in zip(i,j):\\n                    if not a==b:\\n                        count+=1\\n                if count<=2 :\\n                    res.append(i)\\n                    break\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156706,
                "title": "c-golang",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        for(string query: queries) {\\n            for(string dict: dictionary) {\\n                int count = 0;\\n                for(int i = 0; i < query.size(); i++) {\\n                    count += (query[i] != dict[i]);\\n                }\\n                if(count <= 2) {\\n                    ans.push_back(query);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc twoEditWords(queries []string, dictionary []string) []string {\\n    ans := []string{}\\n    for _, query := range queries {\\n        for _, dict := range dictionary {\\n            var count int = 0\\n            for i := 0; i < len(query); i++ {\\n                if query[i] != dict[i] {count++}\\n            }\\n            if count <= 2 {\\n                ans = append(ans, query)\\n                break\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        for(string query: queries) {\\n            for(string dict: dictionary) {\\n                int count = 0;\\n                for(int i = 0; i < query.size(); i++) {\\n                    count += (query[i] != dict[i]);\\n                }\\n                if(count <= 2) {\\n                    ans.push_back(query);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc twoEditWords(queries []string, dictionary []string) []string {\\n    ans := []string{}\\n    for _, query := range queries {\\n        for _, dict := range dictionary {\\n            var count int = 0\\n            for i := 0; i < len(query); i++ {\\n                if query[i] != dict[i] {count++}\\n            }\\n            if count <= 2 {\\n                ans = append(ans, query)\\n                break\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154416,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(string& q, vector<string>& dict){\\n        for(auto d: dict){\\n            int c = 0;\\n            for(int i = 0; i < d.size(); ++i){\\n                if(q[i] != d[i]) c++;\\n            }\\n            if(c <= 2) return true;\\n        }\\n        return false;\\n    }\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dict) {\\n        vector<string> ans;\\n        for(auto q: queries){\\n            if(check(q, dict)) ans.push_back(q);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    bool check(string& q, vector<string>& dict){\\n        for(auto d: dict){\\n            int c = 0;\\n            for(int i = 0; i < d.size(); ++i){\\n                if(q[i] != d[i]) c++;\\n            }\\n            if(c <= 2) return true;\\n        }\\n        return false;\\n    }\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dict) {\\n        vector<string> ans;\\n        for(auto q: queries){\\n            if(check(q, dict)) ans.push_back(q);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152147,
                "title": "java-solution-faster-than-86-4ms-explanation",
                "content": "# Approach\\nTry all possible edits (max 2 edits) in each word from queries to check if it can be equal to dictionary word.\\nSince constraints are short it will be accepted! (100x100x100=1e6 max computation)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans=new ArrayList<>();\\n        for(String s: queries) {\\n            for(int i=0;i<dictionary.length;i++) {\\n                String cur=dictionary[i];\\n                int edits=0;\\n                boolean make=true;\\n                for(int j=0;j<s.length();j++) {\\n                    if(s.charAt(j)!=cur.charAt(j)) {\\n                        edits++;\\n                    }\\n                    if(edits>2) { \\n                        make=false;\\n                        break;\\n                    }\\n                }\\n                if(make) {\\n                    ans.add(s);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans=new ArrayList<>();\\n        for(String s: queries) {\\n            for(int i=0;i<dictionary.length;i++) {\\n                String cur=dictionary[i];\\n                int edits=0;\\n                boolean make=true;\\n                for(int j=0;j<s.length();j++) {\\n                    if(s.charAt(j)!=cur.charAt(j)) {\\n                        edits++;\\n                    }\\n                    if(edits>2) { \\n                        make=false;\\n                        break;\\n                    }\\n                }\\n                if(make) {\\n                    ans.add(s);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140750,
                "title": "java-soln-beats-98",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] q, String[] d) {\\n        int n=q.length;\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            int len=q[i].length();\\n            auto:\\n            for(int j=0;j<d.length;j++){\\n                String str1=q[i];\\n                String str2=d[j];\\n                int count=getCount(str1,str2);\\n                if(!(count>2)){\\n                    li.add(q[i]);\\n                    break auto;\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n    public static int getCount(String s,String e){\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(!(s.charAt(i)==e.charAt(i))){\\n                count++;\\n            }\\n            if(count>2) return count;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] q, String[] d) {\\n        int n=q.length;\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            int len=q[i].length();\\n            auto:\\n            for(int j=0;j<d.length;j++){\\n                String str1=q[i];\\n                String str2=d[j];\\n                int count=getCount(str1,str2);\\n                if(!(count>2)){\\n                    li.add(q[i]);\\n                    break auto;\\n                }\\n            }\\n        }\\n        return li;\\n    }\\n    public static int getCount(String s,String e){\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            if(!(s.charAt(i)==e.charAt(i))){\\n                count++;\\n            }\\n            if(count>2) return count;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108380,
                "title": "java-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for(int i = 0; i < queries.length; i++){\\n            String str = queries[i];\\n            \\n            for(int j = 0; j < dictionary.length; j++){\\n                String s = dictionary[j];\\n                int count = 0;\\n                for(int k = 0; k < s.length(); k++){\\n                    if(str.charAt(k) != s.charAt(k)){\\n                        count++;\\n                    }\\n                    if(count > 2){\\n                        break;\\n                    }\\n                }\\n                if(count <= 2){\\n                    ans.add(str);\\n                    break;\\n                }\\n                count = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for(int i = 0; i < queries.length; i++){\\n            String str = queries[i];\\n            \\n            for(int j = 0; j < dictionary.length; j++){\\n                String s = dictionary[j];\\n                int count = 0;\\n                for(int k = 0; k < s.length(); k++){\\n                    if(str.charAt(k) != s.charAt(k)){\\n                        count++;\\n                    }\\n                    if(count > 2){\\n                        break;\\n                    }\\n                }\\n                if(count <= 2){\\n                    ans.add(str);\\n                    break;\\n                }\\n                count = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101757,
                "title": "simple-c-solution",
                "content": "# Intuition\\n\\nSimply Compare each characters of one from qurey and dictionary array if maximum difference is 2 then add it to ans vector.\\n\\nRepeate the above step for each word in qurey vector.\\n\\nAtlast return ans.\\n\\n\\n# Complexity\\n- Time complexity: O(N*M*K)\\n   N = Number of strings in quries\\n   M = Number of strings in dictionary\\n   K = length of string in either qurie or dictionary\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        vector<string>ans;\\n        for(int i=0;i<q.size();++i){\\n            for(int j=0;j<d.size();++j){\\n                int cnt=0;\\n                for(int k=0;k<d[j].size();++k){\\n                    if(q[i][k]!=d[j][k]){\\n                        cnt++;\\n                        if(cnt>2){ \\n                            break;\\n                        }  \\n                    }\\n                }\\n                if(cnt<=2){\\n                    ans.push_back(q[i]);\\n                    break;\\n                }  \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        vector<string>ans;\\n        for(int i=0;i<q.size();++i){\\n            for(int j=0;j<d.size();++j){\\n                int cnt=0;\\n                for(int k=0;k<d[j].size();++k){\\n                    if(q[i][k]!=d[j][k]){\\n                        cnt++;\\n                        if(cnt>2){ \\n                            break;\\n                        }  \\n                    }\\n                }\\n                if(cnt<=2){\\n                    ans.push_back(q[i]);\\n                    break;\\n                }  \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095705,
                "title": "scala-brute-force-solution",
                "content": "# Code\\n```\\nobject Solution {\\n  def twoEditWords(queries: Array[String], dictionary: Array[String]): List[String] = {\\n    def compare(a: Seq[Char], b: Seq[Char], edits: Int): Boolean = {\\n      if(edits < 0) false\\n      else if(a.isEmpty) true\\n      else if(a.head == b.head) compare(a.tail,b.tail, edits)\\n      else compare(a.tail,b.tail, edits-1)\\n    }\\n    queries.toList.filter{w => dictionary.exists{d => compare(w,d,2)}}\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def twoEditWords(queries: Array[String], dictionary: Array[String]): List[String] = {\\n    def compare(a: Seq[Char], b: Seq[Char], edits: Int): Boolean = {\\n      if(edits < 0) false\\n      else if(a.isEmpty) true\\n      else if(a.head == b.head) compare(a.tail,b.tail, edits)\\n      else compare(a.tail,b.tail, edits-1)\\n    }\\n    queries.toList.filter{w => dictionary.exists{d => compare(w,d,2)}}\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3091950,
                "title": "python3-simple-solution-explained",
                "content": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n\\n        answer = []\\n\\n        # Iterates through the words in queries\\n        for querie in queries:\\n\\n            # Iterates through the words in dictionary\\n            for word in dictionary:\\n\\n                # Count difference between two words\\n                nb_difference = 0\\n                for q,w in zip(querie, word):\\n\\n                    if q != w:\\n                        nb_difference += 1\\n                \\n                # If the letter difference is less than 2\\n                # the word will be in answer and we can break the\\n                # for-loop\\n                if nb_difference <= 2:\\n                    answer.append(querie)\\n                    break\\n        \\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n\\n        answer = []\\n\\n        # Iterates through the words in queries\\n        for querie in queries:\\n\\n            # Iterates through the words in dictionary\\n            for word in dictionary:\\n\\n                # Count difference between two words\\n                nb_difference = 0\\n                for q,w in zip(querie, word):\\n\\n                    if q != w:\\n                        nb_difference += 1\\n                \\n                # If the letter difference is less than 2\\n                # the word will be in answer and we can break the\\n                # for-loop\\n                if nb_difference <= 2:\\n                    answer.append(querie)\\n                    break\\n        \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082328,
                "title": "very-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string s, string d) {\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++) {\\n            if(s[i]!=d[i]) {\\n                count++;\\n            }\\n            if(count>2) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        vector<string> ans;\\n        for(int i=0; i<q.size(); i++) {\\n            for(int j=0; j<d.size(); j++) {\\n                if(check(q[i],d[j])) {\\n                    ans.push_back(q[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s, string d) {\\n        int count = 0;\\n        for(int i=0; i<s.size(); i++) {\\n            if(s[i]!=d[i]) {\\n                count++;\\n            }\\n            if(count>2) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        vector<string> ans;\\n        for(int i=0; i<q.size(); i++) {\\n            for(int j=0; j<d.size(); j++) {\\n                if(check(q[i],d[j])) {\\n                    ans.push_back(q[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075644,
                "title": "c-simple-solution-by-brute-forcing",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> TwoEditWords(string[] queries, string[] dictionary) {\\n        List<string> list = new List<string>();\\n\\t\\t\\n\\t\\tfor(int i=0;i<queries.Length;i++){\\n\\t\\t\\tfor(int j=0;j<dictionary.Length;j++){\\n\\t\\t\\t\\tif(canBeTwoEdits(queries[i],dictionary[j])){\\n\\t\\t\\t\\t\\tlist.Add(queries[i]);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\t\\t\\t\\t\\n\\t\\treturn list;\\n    }\\n\\n\\tpublic bool canBeTwoEdits(string queryStr, string dictStr){\\n\\t\\tint diffCnt=0;\\n\\t\\tfor(int i=0;i<queryStr.Length;i++){\\n\\t\\t\\tif(queryStr[i]!=dictStr[i]){\\n\\t\\t\\t\\tdiffCnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn diffCnt>2?false:true;\\n\\t}\\n\\t\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> TwoEditWords(string[] queries, string[] dictionary) {\\n        List<string> list = new List<string>();\\n\\t\\t\\n\\t\\tfor(int i=0;i<queries.Length;i++){\\n\\t\\t\\tfor(int j=0;j<dictionary.Length;j++){\\n\\t\\t\\t\\tif(canBeTwoEdits(queries[i],dictionary[j])){\\n\\t\\t\\t\\t\\tlist.Add(queries[i]);\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\t\\t\\t\\t\\n\\t\\treturn list;\\n    }\\n\\n\\tpublic bool canBeTwoEdits(string queryStr, string dictStr){\\n\\t\\tint diffCnt=0;\\n\\t\\tfor(int i=0;i<queryStr.Length;i++){\\n\\t\\t\\tif(queryStr[i]!=dictStr[i]){\\n\\t\\t\\t\\tdiffCnt++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn diffCnt>2?false:true;\\n\\t}\\n\\t\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064414,
                "title": "c-trie",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public class Trie\\n    {\\n        public char current;\\n        public Dictionary<char, Trie> children;\\n\\n        public Trie(char ch)\\n        {\\n            this.current = ch;\\n            children = new Dictionary<char, Trie>();\\n        }\\n    }\\n\\n    public IList<string> TwoEditWords(string[] queries, string[] dictionary) \\n    {\\n        var root = new Trie(\\' \\');\\n\\n        foreach(var toAdd in dictionary)\\n        {\\n            var temp = root;\\n            foreach(var ch in toAdd)\\n            {\\n                if(!temp.children.ContainsKey(ch))\\n                {\\n                    temp.children.Add(ch, new Trie(ch));\\n                }\\n                temp = temp.children[ch];\\n            }\\n        }\\n\\n        var result = new List<string>();\\n        foreach(var word in queries)\\n        {\\n            var totalExceptions = 0;\\n\\n            var toVisit = new List<(Trie, int)>();\\n\\n            toVisit.Add((root, 0));\\n            var index = 0;\\n            while(toVisit.Count > 0 && index < word.Length)\\n            {\\n                var newToVisit = new List<(Trie, int)>();\\n\\n                foreach(var (candidate, errorsSoFar) in toVisit)\\n                {\\n                    if(candidate.children.ContainsKey(word[index]))\\n                    {\\n                        newToVisit.Add( (candidate.children[word[index]], errorsSoFar));\\n                    }\\n                    \\n                    if(errorsSoFar <= 1)\\n                    {\\n                        foreach(var (ch, child) in candidate.children)\\n                        {\\n                            newToVisit.Add((child, errorsSoFar + 1));\\n                        }\\n                    }\\n                }\\n\\n                toVisit = newToVisit;    \\n                if(newToVisit.Count() > 0)\\n                {\\n                    ++index;\\n                }\\n            }\\n\\n            if(index == word.Length)\\n            {\\n                result.Add(word);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public class Trie\\n    {\\n        public char current;\\n        public Dictionary<char, Trie> children;\\n\\n        public Trie(char ch)\\n        {\\n            this.current = ch;\\n            children = new Dictionary<char, Trie>();\\n        }\\n    }\\n\\n    public IList<string> TwoEditWords(string[] queries, string[] dictionary) \\n    {\\n        var root = new Trie(\\' \\');\\n\\n        foreach(var toAdd in dictionary)\\n        {\\n            var temp = root;\\n            foreach(var ch in toAdd)\\n            {\\n                if(!temp.children.ContainsKey(ch))\\n                {\\n                    temp.children.Add(ch, new Trie(ch));\\n                }\\n                temp = temp.children[ch];\\n            }\\n        }\\n\\n        var result = new List<string>();\\n        foreach(var word in queries)\\n        {\\n            var totalExceptions = 0;\\n\\n            var toVisit = new List<(Trie, int)>();\\n\\n            toVisit.Add((root, 0));\\n            var index = 0;\\n            while(toVisit.Count > 0 && index < word.Length)\\n            {\\n                var newToVisit = new List<(Trie, int)>();\\n\\n                foreach(var (candidate, errorsSoFar) in toVisit)\\n                {\\n                    if(candidate.children.ContainsKey(word[index]))\\n                    {\\n                        newToVisit.Add( (candidate.children[word[index]], errorsSoFar));\\n                    }\\n                    \\n                    if(errorsSoFar <= 1)\\n                    {\\n                        foreach(var (ch, child) in candidate.children)\\n                        {\\n                            newToVisit.Add((child, errorsSoFar + 1));\\n                        }\\n                    }\\n                }\\n\\n                toVisit = newToVisit;    \\n                if(newToVisit.Count() > 0)\\n                {\\n                    ++index;\\n                }\\n            }\\n\\n            if(index == word.Length)\\n            {\\n                result.Add(word);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063449,
                "title": "brute-force-approach",
                "content": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        def compare_word(query):\\n            for word in dictionary:\\n                not_matching = 0\\n                for char1, char2 in zip(word, query):\\n                    if char1 != char2:\\n                        not_matching+=1\\n                if not_matching <= 2:\\n                    return True\\n\\n        ans = []\\n        for query in queries:\\n            if compare_word(query):\\n                ans.append(query)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        def compare_word(query):\\n            for word in dictionary:\\n                not_matching = 0\\n                for char1, char2 in zip(word, query):\\n                    if char1 != char2:\\n                        not_matching+=1\\n                if not_matching <= 2:\\n                    return True\\n\\n        ans = []\\n        for query in queries:\\n            if compare_word(query):\\n                ans.append(query)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050072,
                "title": "java-count-differences-solution",
                "content": "\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> result = new LinkedList<>();\\n        int wordsLen = queries[0].length();\\n        outer:\\n        for (String q : queries) {\\n            char[] qchars = q.toCharArray();\\n            for (String d : dictionary) {\\n                char[] dchars = d.toCharArray();\\n                int diffs = 0;\\n                for(int i = 0; i < wordsLen; i++) {\\n                    if (qchars[i] != dchars[i])\\n                        diffs++;\\n                }\\n                if (diffs <= 2) {\\n                    result.add(q);\\n                    continue outer;      \\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> result = new LinkedList<>();\\n        int wordsLen = queries[0].length();\\n        outer:\\n        for (String q : queries) {\\n            char[] qchars = q.toCharArray();\\n            for (String d : dictionary) {\\n                char[] dchars = d.toCharArray();\\n                int diffs = 0;\\n                for(int i = 0; i < wordsLen; i++) {\\n                    if (qchars[i] != dchars[i])\\n                        diffs++;\\n                }\\n                if (diffs <= 2) {\\n                    result.add(q);\\n                    continue outer;      \\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016295,
                "title": "python-dfs-in-trie",
                "content": "```python\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        trie = {}\\n\\n        def insert(s):\\n            p = trie\\n            for c in s:\\n                if c not in p:\\n                    p[c] = {}\\n                p = p[c]\\n            p[\\'-\\'] = True\\n\\n        def has(s, diff=2, p=trie):\\n            if diff < 0:\\n                return False\\n            for nxt in p:\\n                if nxt == \\'-\\':\\n                    return True\\n                if nxt == s[0]:\\n                    if has(s[1:], diff, p[nxt]):\\n                        return True\\n                else:\\n                    if has(s[1:], diff - 1, p[nxt]):\\n                        return True\\n            return False\\n\\n        for w in dictionary:\\n            insert(w)\\n        \\n        return filter(lambda x: has(x), queries)\\n            \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Trie"
                ],
                "code": "```python\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        trie = {}\\n\\n        def insert(s):\\n            p = trie\\n            for c in s:\\n                if c not in p:\\n                    p[c] = {}\\n                p = p[c]\\n            p[\\'-\\'] = True\\n\\n        def has(s, diff=2, p=trie):\\n            if diff < 0:\\n                return False\\n            for nxt in p:\\n                if nxt == \\'-\\':\\n                    return True\\n                if nxt == s[0]:\\n                    if has(s[1:], diff, p[nxt]):\\n                        return True\\n                else:\\n                    if has(s[1:], diff - 1, p[nxt]):\\n                        return True\\n            return False\\n\\n        for w in dictionary:\\n            insert(w)\\n        \\n        return filter(lambda x: has(x), queries)\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008593,
                "title": "0ms-cpp-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        unordered_map<string, bool> ss;\\n        vector<string> result;\\n        auto can_make_it = [&](string& a, string& b) -> bool{\\n            int n = a.size();\\n            int counter = 0;\\n            for(int i = 0; i < n  ; ++i){\\n                if(a[i] != b[i]){\\n                    counter++;\\n                    if(counter > 2){\\n                        return false;\\n                    }\\n                }\\n            }\\n            return true;\\n        };\\n        for(string& q: queries){\\n            if (ss[q]){\\n                result.push_back(q);\\n            }else{\\n                for(string& word: dictionary){\\n                    if (can_make_it(q, word)){\\n                        result.push_back(q);\\n                        ss.insert({q, true});\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        unordered_map<string, bool> ss;\\n        vector<string> result;\\n        auto can_make_it = [&](string& a, string& b) -> bool{\\n            int n = a.size();\\n            int counter = 0;\\n            for(int i = 0; i < n  ; ++i){\\n                if(a[i] != b[i]){\\n                    counter++;\\n                    if(counter > 2){\\n                        return false;\\n                    }\\n                }\\n            }\\n            return true;\\n        };\\n        for(string& q: queries){\\n            if (ss[q]){\\n                result.push_back(q);\\n            }else{\\n                for(string& word: dictionary){\\n                    if (can_make_it(q, word)){\\n                        result.push_back(q);\\n                        ss.insert({q, true});\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999434,
                "title": "javascript-short-solution",
                "content": "```\\nconst twoEditWords = (q, d) =>\\n  q.reduce((a, c) => {\\n    for (let i = 0; i < d.length; i++) {\\n      let dif = 0;\\n      for (let j = 0; j < d[i].length; j++) {\\n        if (c[j] !== d[i][j]) dif++;\\n        if (dif > 2) break;\\n      }\\n      if (dif <= 2) {\\n        a.push(c);\\n        break;\\n      }\\n    }\\n    return a;\\n  }, []);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst twoEditWords = (q, d) =>\\n  q.reduce((a, c) => {\\n    for (let i = 0; i < d.length; i++) {\\n      let dif = 0;\\n      for (let j = 0; j < d[i].length; j++) {\\n        if (c[j] !== d[i][j]) dif++;\\n        if (dif > 2) break;\\n      }\\n      if (dif <= 2) {\\n        a.push(c);\\n        break;\\n      }\\n    }\\n    return a;\\n  }, []);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2972128,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        \\n        List<String> list = new ArrayList<>() ; \\n\\n        for( int i = 0 ; i < queries.length ; i++)\\n        {\\n            boolean temp = check(queries[i] , dictionary) ; \\n            if( temp == true)\\n            list.add(queries[i]) ; \\n        }\\n      \\n      return list ; \\n    }\\n    public boolean check (String s , String[] dictionary)\\n    {\\n          for ( int i  =  0 ; i < dictionary.length; i++)\\n          {\\n             String t = dictionary[i] ; \\n             int j = 0 ; \\n             int count = 0 ; \\n             while( j < t.length())\\n             {\\n                if(s.charAt(j) == t.charAt(j))\\n                j++ ; \\n                else\\n                {\\n                    count++ ; \\n                    j++ ; \\n                }\\n             }\\n\\n             if( count <= 2 )\\n              return true ; \\n             \\n          }\\n\\n          return false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        \\n        List<String> list = new ArrayList<>() ; \\n\\n        for( int i = 0 ; i < queries.length ; i++)\\n        {\\n            boolean temp = check(queries[i] , dictionary) ; \\n            if( temp == true)\\n            list.add(queries[i]) ; \\n        }\\n      \\n      return list ; \\n    }\\n    public boolean check (String s , String[] dictionary)\\n    {\\n          for ( int i  =  0 ; i < dictionary.length; i++)\\n          {\\n             String t = dictionary[i] ; \\n             int j = 0 ; \\n             int count = 0 ; \\n             while( j < t.length())\\n             {\\n                if(s.charAt(j) == t.charAt(j))\\n                j++ ; \\n                else\\n                {\\n                    count++ ; \\n                    j++ ; \\n                }\\n             }\\n\\n             if( count <= 2 )\\n              return true ; \\n             \\n          }\\n\\n          return false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969399,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& dict) {\\n        unordered_set<string> s;\\n        for(int i=0;i<dict.size();i++)\\n        {\\n            string str=dict[i];\\n            for(int j=0;j<q.size();j++)\\n            {\\n                int curr=0;\\n                \\n                for(int k=0;k<q[j].length();k++)\\n                {\\n                    if(str[k]!=q[j][k])\\n                        curr++;\\n                }\\n                if(curr<=2)\\n                    s.insert(q[j]);\\n            }\\n        }\\n        \\n        vector<string> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            if(s.find(q[i])!=s.end())\\n            {\\n                ans.push_back(q[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& dict) {\\n        unordered_set<string> s;\\n        for(int i=0;i<dict.size();i++)\\n        {\\n            string str=dict[i];\\n            for(int j=0;j<q.size();j++)\\n            {\\n                int curr=0;\\n                \\n                for(int k=0;k<q[j].length();k++)\\n                {\\n                    if(str[k]!=q[j][k])\\n                        curr++;\\n                }\\n                if(curr<=2)\\n                    s.insert(q[j]);\\n            }\\n        }\\n        \\n        vector<string> ans;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            if(s.find(q[i])!=s.end())\\n            {\\n                ans.push_back(q[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960379,
                "title": "optimized-python-solution",
                "content": "# Intuition\\nFor each word in queries, check if any of the words in dictionary have less than 2 differences from that word.\\n\\n\\n# Approach\\nFirst, I made a list ans to store the words in query which met the requirements. At first you may assume you have to check every word in dictionary, but there are a couple optimizations you can make. For each query/dictionary matchup, I created a variable to store the amount of differences. If this surpasses 2, you can move onto the next word in the dictionary. If this stays at 2 or under, you can append the query to the answer and move onto the next word in queries.\\n\\n# Complexity\\n- Time complexity:\\nn = length of queries\\nm = length of dictionary\\nl = length of each word\\nWorst: $$O(n*m*l)$$\\nBest (If every q in queries is less than 2 from dictionary[0]): $$O(n*l)$$ \\n\\n\\n- Space complexity:\\nn = length of queries\\n$$O(n)$$\\n\\n# Runtime/Memory\\n![Screenshot_20221227_051546.png](https://assets.leetcode.com/users/images/df516759-058a-4009-b700-a246cddfedbe_1672182986.9843326.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        ans = []\\n        n = len(queries[0])\\n        for q in queries:\\n            for d in dictionary:\\n                diff = 0\\n                for i in range(n):\\n                    if q[i] != d[i]:\\n                        diff += 1\\n                    if diff > 2:\\n                        break\\n                if diff <= 2:\\n                    ans.append(q)\\n                    break\\n        return ans\\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        ans = []\\n        n = len(queries[0])\\n        for q in queries:\\n            for d in dictionary:\\n                diff = 0\\n                for i in range(n):\\n                    if q[i] != d[i]:\\n                        diff += 1\\n                    if diff > 2:\\n                        break\\n                if diff <= 2:\\n                    ans.append(q)\\n                    break\\n        return ans\\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941059,
                "title": "o-n3-works-fine",
                "content": "# Code\\n```\\npublic class Solution {\\n    public IList<string> TwoEditWords(string[] queries, string[] dictionary) \\n    {\\n        var ls = new List<string>();\\n        for(var i=0; i<queries.Length;i++)\\n        {\\n            for(var j=0;j<dictionary.Length;j++)\\n            {\\n                if(queries[i].Length!=dictionary[j].Length) continue;\\n                int count=0;\\n                for(var k=0;k<queries[i].Length;k++)\\n                {\\n                    if(queries[i][k]!=dictionary[j][k]) count++;\\n                }\\n                if(count<=2)\\n                {\\n                    ls.Add(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ls;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> TwoEditWords(string[] queries, string[] dictionary) \\n    {\\n        var ls = new List<string>();\\n        for(var i=0; i<queries.Length;i++)\\n        {\\n            for(var j=0;j<dictionary.Length;j++)\\n            {\\n                if(queries[i].Length!=dictionary[j].Length) continue;\\n                int count=0;\\n                for(var k=0;k<queries[i].Length;k++)\\n                {\\n                    if(queries[i][k]!=dictionary[j][k]) count++;\\n                }\\n                if(count<=2)\\n                {\\n                    ls.Add(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ls;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2934160,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn two_edit_words(queries: Vec<String>, dictionary: Vec<String>) -> Vec<String> {\\n        queries\\n            .into_iter()\\n            .filter(|q| {\\n                let f = |d: &String| q.bytes().zip(d.bytes()).filter(|(c1, c2)| c1 != c2).count() <= 2;\\n                dictionary.iter().any(f)\\n            })\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn two_edit_words(queries: Vec<String>, dictionary: Vec<String>) -> Vec<String> {\\n        queries\\n            .into_iter()\\n            .filter(|q| {\\n                let f = |d: &String| q.bytes().zip(d.bytes()).filter(|(c1, c2)| c1 != c2).count() <= 2;\\n                dictionary.iter().any(f)\\n            })\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2925502,
                "title": "ja-over-the-top-va",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> res = new ArrayList<>();\\n        for(String query : queries){\\n            for(String dict : dictionary){\\n                if(isWithinDistance2(query,dict)){\\n                    res.add(query);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private boolean isWithinDistance2(String word1, String word2){\\n        int x = 0, i = 0;\\n        while(x<=2 && i<word1.length()){\\n            if(word1.charAt(i)!=word2.charAt(i)){\\n                x++;\\n            }\\n            i++;\\n        }\\n        return x<=2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> res = new ArrayList<>();\\n        for(String query : queries){\\n            for(String dict : dictionary){\\n                if(isWithinDistance2(query,dict)){\\n                    res.add(query);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private boolean isWithinDistance2(String word1, String word2){\\n        int x = 0, i = 0;\\n        while(x<=2 && i<word1.length()){\\n            if(word1.charAt(i)!=word2.charAt(i)){\\n                x++;\\n            }\\n            i++;\\n        }\\n        return x<=2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918467,
                "title": "very-easy-solution-in-java",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] q, String[] d) {\\n        List<String> temp=new ArrayList<>();\\n        for(int i=0; i<q.length; i++){\\n               String str=q[i];\\n            for(int j=0; j<d.length; j++){\\n                String str2=d[j];\\n                int count=0;\\n               for(int k=0; k<str.length(); k++){\\n                   if(str.charAt(k)!=str2.charAt(k)) count++;\\n               }\\n               if(count<3){\\n                   temp.add(str);\\n                   break;\\n               } \\n            }\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] q, String[] d) {\\n        List<String> temp=new ArrayList<>();\\n        for(int i=0; i<q.length; i++){\\n               String str=q[i];\\n            for(int j=0; j<d.length; j++){\\n                String str2=d[j];\\n                int count=0;\\n               for(int k=0; k<str.length(); k++){\\n                   if(str.charAt(k)!=str2.charAt(k)) count++;\\n               }\\n               if(count<3){\\n                   temp.add(str);\\n                   break;\\n               } \\n            }\\n        }\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916449,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        for (auto& q : queries) {\\n            for (auto& d : dictionary) {\\n                if (solve(q, d) < 3) {\\n                    ans.emplace_back(q);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    int solve(const string& l, const string& r) {\\n        int ans = 0, n = l.length();\\n        for (int i = 0; i < n && ans < 3; ++i) {\\n            if (l[i] != r[i]) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        for (auto& q : queries) {\\n            for (auto& d : dictionary) {\\n                if (solve(q, d) < 3) {\\n                    ans.emplace_back(q);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    int solve(const string& l, const string& r) {\\n        int ans = 0, n = l.length();\\n        for (int i = 0; i < n && ans < 3; ++i) {\\n            if (l[i] != r[i]) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910630,
                "title": "simple-and-fast-bruteforce",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple way: we take word from queries one by one and check each dictionary element for mismatched characters.\\n# Complexity\\n- Time complexity: O(n*k), where n - words in queries and k - words in dictionary\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> result = new ArrayList();\\n        for (int i = 0; i < queries.length; ++i) {\\n            for (int j = 0; j < dictionary.length; ++j) {\\n                if (checkSymbols(queries[i], dictionary[j]) <= 2) {\\n                    result.add(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    private int checkSymbols(String q, String d) {\\n        int counter = 0;\\n        for (int i = 0; i < q.length(); ++i) {\\n            if (q.charAt(i) != d.charAt(i))\\n                counter++;\\n            if (counter > 2) return 3;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> result = new ArrayList();\\n        for (int i = 0; i < queries.length; ++i) {\\n            for (int j = 0; j < dictionary.length; ++j) {\\n                if (checkSymbols(queries[i], dictionary[j]) <= 2) {\\n                    result.add(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    private int checkSymbols(String q, String d) {\\n        int counter = 0;\\n        for (int i = 0; i < q.length(); ++i) {\\n            if (q.charAt(i) != d.charAt(i))\\n                counter++;\\n            if (counter > 2) return 3;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910355,
                "title": "c-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute force\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust check all possible pairs\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n#define MAX_LEN 101\\n\\nbool valid(const char *word1, const char * word2)\\n{\\n    int n = strlen(word1);\\n    int diff = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (word1[i] != word2[i]) {\\n            diff++;\\n        }\\n    }\\n    return diff <= 2;\\n}\\n\\nchar ** twoEditWords(char ** queries, int queriesSize, char ** dictionary, int dictionarySize, int* returnSize){\\n    char **res = (char **)malloc(sizeof(char *) * queriesSize);\\n    memset(res, 0, sizeof(char *) * queriesSize);\\n    int index = 0;\\n\\n    for (int i = 0; i < queriesSize; i++) {\\n        for (int j = 0; j < dictionarySize; j++) {\\n            if (valid(queries[i], dictionary[j])) {\\n\\n                res[index] = (char *)malloc(sizeof(char) * MAX_LEN);\\n                memset(res[index], 0, sizeof(char) * MAX_LEN);\\n\\n                //     res[index] = queries[i];\\n                strcpy(res[index], queries[i]);\\n                index++;\\n                break;\\n            }\\n        }\\n    }\\n    *returnSize = index;\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\n#define MAX_LEN 101\\n\\nbool valid(const char *word1, const char * word2)\\n{\\n    int n = strlen(word1);\\n    int diff = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (word1[i] != word2[i]) {\\n            diff++;\\n        }\\n    }\\n    return diff <= 2;\\n}\\n\\nchar ** twoEditWords(char ** queries, int queriesSize, char ** dictionary, int dictionarySize, int* returnSize){\\n    char **res = (char **)malloc(sizeof(char *) * queriesSize);\\n    memset(res, 0, sizeof(char *) * queriesSize);\\n    int index = 0;\\n\\n    for (int i = 0; i < queriesSize; i++) {\\n        for (int j = 0; j < dictionarySize; j++) {\\n            if (valid(queries[i], dictionary[j])) {\\n\\n                res[index] = (char *)malloc(sizeof(char) * MAX_LEN);\\n                memset(res[index], 0, sizeof(char) * MAX_LEN);\\n\\n                //     res[index] = queries[i];\\n                strcpy(res[index], queries[i]);\\n                index++;\\n                break;\\n            }\\n        }\\n    }\\n    *returnSize = index;\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2903018,
                "title": "java-hamming-distance",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for (String query : queries) {\\n            for (String word : dictionary) {\\n                if (isHammingDistanceLessThat2(query, word)) {\\n                    ans.add(query);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean isHammingDistanceLessThat2(String word1, String word2) {\\n        int diff = 0;\\n        for (int i = 0; i < word1.length(); i++) {\\n            if (word1.charAt(i) != word2.charAt(i)) {\\n                diff++;\\n                if (diff > 2) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for (String query : queries) {\\n            for (String word : dictionary) {\\n                if (isHammingDistanceLessThat2(query, word)) {\\n                    ans.add(query);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private boolean isHammingDistanceLessThat2(String word1, String word2) {\\n        int diff = 0;\\n        for (int i = 0; i < word1.length(); i++) {\\n            if (word1.charAt(i) != word2.charAt(i)) {\\n                diff++;\\n                if (diff > 2) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900872,
                "title": "java-brute-force-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for(String element: queries){\\n            for (String s : dictionary) {\\n                if (diffBtwWords(element,s)) {\\n                    ans.add(element);\\n                    break;\\n                }\\n            }\\n        } return ans;\\n    }\\n\\n    public boolean diffBtwWords(String str1, String str2){\\n        char [] ch1 = str1.toCharArray();\\n        char [] ch2 = str2.toCharArray();\\n        int count = 0;\\n        for(int i = 0; i < ch1.length; i++){\\n            if(ch1[i] != ch2[i]){\\n                count++;\\n            }\\n        } return count <= 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for(String element: queries){\\n            for (String s : dictionary) {\\n                if (diffBtwWords(element,s)) {\\n                    ans.add(element);\\n                    break;\\n                }\\n            }\\n        } return ans;\\n    }\\n\\n    public boolean diffBtwWords(String str1, String str2){\\n        char [] ch1 = str1.toCharArray();\\n        char [] ch2 = str2.toCharArray();\\n        int count = 0;\\n        for(int i = 0; i < ch1.length; i++){\\n            if(ch1[i] != ch2[i]){\\n                count++;\\n            }\\n        } return count <= 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889354,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst though came to mind is the checking all the dictionary if it less than difference of the two word we will break the loop and append it to our result .\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n       int i,j,k=0;\\n       vector<string>res;\\n       string g=\"\";\\n       for(i=0;i<queries.size();i++)\\n       {\\n        \\n           for(j=0;j<dictionary.size();j++)\\n           {\\n               k=0;\\n               for(int y=0;y<dictionary[j].size();y++)\\n               {\\n                   if(queries[i][y]!=dictionary[j][y])\\n                        k++;\\n               }\\n               if(k<=2)\\n               {\\n                   res.push_back(queries[i]);\\n                   break;\\n               }\\n           }\\n       } \\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n       int i,j,k=0;\\n       vector<string>res;\\n       string g=\"\";\\n       for(i=0;i<queries.size();i++)\\n       {\\n        \\n           for(j=0;j<dictionary.size();j++)\\n           {\\n               k=0;\\n               for(int y=0;y<dictionary[j].size();y++)\\n               {\\n                   if(queries[i][y]!=dictionary[j][y])\\n                        k++;\\n               }\\n               if(k<=2)\\n               {\\n                   res.push_back(queries[i]);\\n                   break;\\n               }\\n           }\\n       } \\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2887282,
                "title": "cpp-easy-to-understand-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dict) \\n\\t{\\n\\t\\t  vector<string>ans;\\n          for(int i=0;i<queries.size();i++)\\n\\t\\t  {\\n\\t\\t\\t   for(int j=0;j<dict.size();j++)\\n\\t\\t\\t   {\\n                   int diff = 0;\\n\\t\\t\\t   \\t    int len = dict[j].length();\\n\\t\\t\\t   \\t    for(int k = 0; k < len ; k++)\\n\\t\\t\\t   \\t    {\\n\\t\\t\\t   \\t    \\tif(queries[i][k]!=dict[j][k])\\n                        {\\n                               diff++;\\n                        }\\n\\t\\t            }\\n                    if(diff<=2)\\n\\t\\t\\t        {\\n\\t\\t\\t           ans.push_back(queries[i]);\\t\\n                       break;\\n\\t\\t            }\\t\\n\\t\\t\\t   }\\n\\t\\t  }    \\n\\t\\t  return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dict) \\n\\t{\\n\\t\\t  vector<string>ans;\\n          for(int i=0;i<queries.size();i++)\\n\\t\\t  {\\n\\t\\t\\t   for(int j=0;j<dict.size();j++)\\n\\t\\t\\t   {\\n                   int diff = 0;\\n\\t\\t\\t   \\t    int len = dict[j].length();\\n\\t\\t\\t   \\t    for(int k = 0; k < len ; k++)\\n\\t\\t\\t   \\t    {\\n\\t\\t\\t   \\t    \\tif(queries[i][k]!=dict[j][k])\\n                        {\\n                               diff++;\\n                        }\\n\\t\\t            }\\n                    if(diff<=2)\\n\\t\\t\\t        {\\n\\t\\t\\t           ans.push_back(queries[i]);\\t\\n                       break;\\n\\t\\t            }\\t\\n\\t\\t\\t   }\\n\\t\\t  }    \\n\\t\\t  return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886782,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        vector<string>ans;\\n       // unordered<string>st;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            for(int j=0;j<d.size();j++)\\n            {\\n                string str=fun(q[i],d[j]);\\n                if(str!=\"\")\\n                {\\n                    ans.push_back(str);\\n                    q[i]=\"\";\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    string fun(string &s1,string &s2)\\n    {\\n        int edits=2;\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(s1[i]!=s2[i])\\n            {\\n                if(edits==0)\\n                {\\n                    return \"\";\\n                }\\n                edits--;\\n            }\\n        }\\n        return s1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& q, vector<string>& d) {\\n        vector<string>ans;\\n       // unordered<string>st;\\n        for(int i=0;i<q.size();i++)\\n        {\\n            for(int j=0;j<d.size();j++)\\n            {\\n                string str=fun(q[i],d[j]);\\n                if(str!=\"\")\\n                {\\n                    ans.push_back(str);\\n                    q[i]=\"\";\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    string fun(string &s1,string &s2)\\n    {\\n        int edits=2;\\n        for(int i=0;i<s1.length();i++)\\n        {\\n            if(s1[i]!=s2[i])\\n            {\\n                if(edits==0)\\n                {\\n                    return \"\";\\n                }\\n                edits--;\\n            }\\n        }\\n        return s1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854120,
                "title": "easy-to-understand-java-solution-brute-force-faster-than-80",
                "content": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for(String s:queries)\\n            for(String d:dictionary)  \\n                if(compare(s,d)) //  checking if current query can be convert into any dict. word or not\\n                {\\n                    ans.add(s);\\n                    break;    // if yes then no need to check more\\n                }\\n        return ans;\\n    }\\n    boolean compare(String a,String b)\\n    {\\n        int size = a.length();\\n        int count = 0;\\n        for(int i = 0;i<size && count<=2;i++)    //if count will be greater than 2 then it will return false anyway. so no need to check more\\n            if(a.charAt(i)!=b.charAt(i))\\n                count++;\\n        return count<=2;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for(String s:queries)\\n            for(String d:dictionary)  \\n                if(compare(s,d)) //  checking if current query can be convert into any dict. word or not\\n                {\\n                    ans.add(s);\\n                    break;    // if yes then no need to check more\\n                }\\n        return ans;\\n    }\\n    boolean compare(String a,String b)\\n    {\\n        int size = a.length();\\n        int count = 0;\\n        for(int i = 0;i<size && count<=2;i++)    //if count will be greater than 2 then it will return false anyway. so no need to check more\\n            if(a.charAt(i)!=b.charAt(i))\\n                count++;\\n        return count<=2;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845796,
                "title": "c-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        for(string w1:queries){\\n            int n = w1.length();\\n            for(string w2: dictionary){\\n                int m = w2.length();\\n                if(n==m){\\n                    int diff=0;\\n                    int l=0;\\n                    while(l<m){\\n                        if(w1[l]!=w2[l]) ++diff;\\n                        l++;\\n                    }\\n                    if(diff<=2){\\n                        ans.push_back(w1);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n        vector<string> ans;\\n        for(string w1:queries){\\n            int n = w1.length();\\n            for(string w2: dictionary){\\n                int m = w2.length();\\n                if(n==m){\\n                    int diff=0;\\n                    int l=0;\\n                    while(l<m){\\n                        if(w1[l]!=w2[l]) ++diff;\\n                        l++;\\n                    }\\n                    if(diff<=2){\\n                        ans.push_back(w1);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845373,
                "title": "python3-readable-trie-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we want to find words in our dictionary that are similar to our word, we can implement a trie.\\n\\nA [trie](https://de.wikipedia.org/wiki/Trie) is a directed graph/tree where every node shows all possible next characters given a certain prefix. Google it, if you are interested and/or confused.\\n\\nUnfortunately, it would blow up the solution if I explained a tree within here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe bult thre Trie using a dict and then traverse it with the queries. At each split we can decide to edit the given letter. Therefore we follow all our children until our edits are exhausted or we reached the end of the word.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI\\'m actually not sure....maybe someone can help me?\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*k) worst case where N is the amount of words if all words start with a different letter and have the length k.\\n\\n# Code\\n```\\nclass TrieNode:\\n    def __init__(self, word: str = None):\\n        self.word = word\\n        self.children = {}\\n\\nclass Trie:\\n    def __init__(self, dictionary: List[str]):\\n\\n        # keep a root node\\n        self.root = TrieNode()\\n\\n        # put in the words\\n        for word in dictionary:\\n\\n            # start at the root node\\n            node = self.root\\n\\n            # go through the characters\\n            for ch in word:\\n\\n                # create child if not already there\\n                if ch not in node.children:\\n                    new_node = TrieNode()\\n                    node.children[ch] = new_node\\n                \\n                # go deeper\\n                node = node.children[ch]\\n\\n            # attach finished word to the last node\\n            node.word = word\\n\\n    def find_word_with_edits(self, word: str, edits: int) -> bool:\\n        return self._find_word_with_edits(self.root, word, 0, edits)\\n    \\n    # internal recursive function\\n    def _find_word_with_edits(self, node: TrieNode, word: str, pointer: int, edits: int):\\n\\n        # check whether we are at the end of the trie or have no edits left\\n        if not node or edits < 0:\\n            return False\\n        \\n        # check if we are at the end of our word\\n        if pointer == len(word) and node.word is not None:\\n            return True\\n        \\n        # we go deeper check whether and edit is necessary\\n        was_found = False\\n        for key, child in node.children.items():\\n            was_found = self._find_word_with_edits(child, word, pointer+1, edits-int(key != word[pointer]))\\n            if was_found: break\\n        return was_found\\n\\n\\n\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        # build the trie\\n        trie = Trie(dictionary)\\n        return [query for query in queries if trie.find_word_with_edits(query, 2)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self, word: str = None):\\n        self.word = word\\n        self.children = {}\\n\\nclass Trie:\\n    def __init__(self, dictionary: List[str]):\\n\\n        # keep a root node\\n        self.root = TrieNode()\\n\\n        # put in the words\\n        for word in dictionary:\\n\\n            # start at the root node\\n            node = self.root\\n\\n            # go through the characters\\n            for ch in word:\\n\\n                # create child if not already there\\n                if ch not in node.children:\\n                    new_node = TrieNode()\\n                    node.children[ch] = new_node\\n                \\n                # go deeper\\n                node = node.children[ch]\\n\\n            # attach finished word to the last node\\n            node.word = word\\n\\n    def find_word_with_edits(self, word: str, edits: int) -> bool:\\n        return self._find_word_with_edits(self.root, word, 0, edits)\\n    \\n    # internal recursive function\\n    def _find_word_with_edits(self, node: TrieNode, word: str, pointer: int, edits: int):\\n\\n        # check whether we are at the end of the trie or have no edits left\\n        if not node or edits < 0:\\n            return False\\n        \\n        # check if we are at the end of our word\\n        if pointer == len(word) and node.word is not None:\\n            return True\\n        \\n        # we go deeper check whether and edit is necessary\\n        was_found = False\\n        for key, child in node.children.items():\\n            was_found = self._find_word_with_edits(child, word, pointer+1, edits-int(key != word[pointer]))\\n            if was_found: break\\n        return was_found\\n\\n\\n\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        # build the trie\\n        trie = Trie(dictionary)\\n        return [query for query in queries if trie.find_word_with_edits(query, 2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842778,
                "title": "c-solution",
                "content": "```\\nvector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n\\n\\tvector<string> valid{};\\n\\t\\n\\t\\n\\tint limit{ 3 };\\n\\n\\tfor (int i{}; i < queries.size(); i++) {\\n\\t\\tfor (int j{}; j < dictionary.size(); j++) {\\n\\t\\t\\tint differences{ 0 };\\n\\t\\t\\tfor (int k{ 0 }; k < queries[i].length() || k < dictionary[j].length(); k++) {\\n\\t\\t\\t\\tif (differences == limit) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (queries[i][k] != dictionary[j][k]) {\\n\\t\\t\\t\\t\\tdifferences++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (differences < limit) {\\n\\t\\t\\t\\tvalid.push_back(queries[i]);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\n\\n\\t}\\n\\treturn valid;\\n\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<string> twoEditWords(vector<string>& queries, vector<string>& dictionary) {\\n\\n\\tvector<string> valid{};\\n\\t\\n\\t\\n\\tint limit{ 3 };\\n\\n\\tfor (int i{}; i < queries.size(); i++) {\\n\\t\\tfor (int j{}; j < dictionary.size(); j++) {\\n\\t\\t\\tint differences{ 0 };\\n\\t\\t\\tfor (int k{ 0 }; k < queries[i].length() || k < dictionary[j].length(); k++) {\\n\\t\\t\\t\\tif (differences == limit) {\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (queries[i][k] != dictionary[j][k]) {\\n\\t\\t\\t\\t\\tdifferences++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (differences < limit) {\\n\\t\\t\\t\\tvalid.push_back(queries[i]);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\n\\n\\t}\\n\\treturn valid;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2837550,
                "title": "php",
                "content": "![Screen Shot 2022-11-21 at 6.47.59 PM.png](https://assets.leetcode.com/users/images/882227bd-151e-45be-aabf-8b62ec870e6f_1669074494.8364475.png)\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\n\\n  /**\\n   * @param String[] $queries\\n   * @param String[] $dictionary\\n   * @return String[]\\n   */\\n  function twoEditWords($queries, $dictionary)\\n  {\\n\\n    $ans = [];\\n    foreach ($queries as $key => $q_word) {\\n      $q_word_parts = str_split($q_word);\\n\\n      foreach ($dictionary as $d_word) {\\n        $d_word_parts = str_split($d_word);\\n        $word_diff = array_diff_assoc($q_word_parts, $d_word_parts);\\n        if (count($word_diff) < 3) {\\n          $ans[] = $q_word;\\n          break;\\n        }\\n      }\\n    }\\n  return $ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n  /**\\n   * @param String[] $queries\\n   * @param String[] $dictionary\\n   * @return String[]\\n   */\\n  function twoEditWords($queries, $dictionary)\\n  {\\n\\n    $ans = [];\\n    foreach ($queries as $key => $q_word) {\\n      $q_word_parts = str_split($q_word);\\n\\n      foreach ($dictionary as $d_word) {\\n        $d_word_parts = str_split($d_word);\\n        $word_diff = array_diff_assoc($q_word_parts, $d_word_parts);\\n        if (count($word_diff) < 3) {\\n          $ans[] = $q_word;\\n          break;\\n        }\\n      }\\n    }\\n  return $ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832227,
                "title": "simplest-solution-in-python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        ans = []\\n        for index,q in enumerate(queries):\\n            add = False\\n            for d in dictionary:\\n                p = 0\\n                flag = False\\n                for i,j in zip(q,d):\\n                    if i!=j:\\n                        p += 1\\n                    if p>2:\\n                        flag = True\\n                        break\\n                if not flag:\\n                    ans.append(queries[index])\\n                    add = True\\n                if add:\\n                    break\\n        return ans\\n             \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        ans = []\\n        for index,q in enumerate(queries):\\n            add = False\\n            for d in dictionary:\\n                p = 0\\n                flag = False\\n                for i,j in zip(q,d):\\n                    if i!=j:\\n                        p += 1\\n                    if p>2:\\n                        flag = True\\n                        break\\n                if not flag:\\n                    ans.append(queries[index])\\n                    add = True\\n                if add:\\n                    break\\n        return ans\\n             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821473,
                "title": "brute-force-java-solution-java",
                "content": "```\\n// if you found my solution usefull please upvote it\\nclass Solution \\n{\\n    public boolean fun(String a,String b)\\n    {\\n        int cnt=0;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(a.charAt(i)!=b.charAt(i))  cnt++;\\n        }\\n        return cnt<=2;\\n    }\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) \\n    {\\n        List<String> ans=new ArrayList();\\n        for(int i=0;i<queries.length;i++)\\n        {\\n            for(int j=0;j<dictionary.length;j++)\\n            {\\n                if(fun(queries[i],dictionary[j]))\\n                {\\n                    ans.add(queries[i]);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution \\n{\\n    public boolean fun(String a,String b)\\n    {\\n        int cnt=0;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(a.charAt(i)!=b.charAt(i))  cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2820461,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::cmp::Ordering;\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn two_edit_words(queries: Vec<String>, dictionary: Vec<String>) -> Vec<String> {\\n    let mut set = HashSet::new();\\n    for v in &dictionary {\\n      set.insert(v.clone());\\n    }\\n\\n    let n = queries.len();\\n    let m = dictionary.len();\\n    let mut result = vec![];\\n    for i in 0..n {\\n      let v = &queries[i];\\n      if set.contains(v) {\\n        result.push(v.clone());\\n      } else {\\n        \\n        let s1 = v.chars().collect::<Vec<char>>();\\n        for j in 0..m {\\n          let s2 = &dictionary[j].chars().collect::<Vec<char>>();\\n          let mut temp = 0;\\n          for i in 0..v.len() {\\n            if s1[i] != s2[i] {\\n              temp += 1;\\n            }\\n          }\\n\\n          if temp <= 2 {\\n            result.push(v.clone());\\n            break\\n          }\\n        }\\n      }\\n    }\\n   result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Ordering;\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn two_edit_words(queries: Vec<String>, dictionary: Vec<String>) -> Vec<String> {\\n    let mut set = HashSet::new();\\n    for v in &dictionary {\\n      set.insert(v.clone());\\n    }\\n\\n    let n = queries.len();\\n    let m = dictionary.len();\\n    let mut result = vec![];\\n    for i in 0..n {\\n      let v = &queries[i];\\n      if set.contains(v) {\\n        result.push(v.clone());\\n      } else {\\n        \\n        let s1 = v.chars().collect::<Vec<char>>();\\n        for j in 0..m {\\n          let s2 = &dictionary[j].chars().collect::<Vec<char>>();\\n          let mut temp = 0;\\n          for i in 0..v.len() {\\n            if s1[i] != s2[i] {\\n              temp += 1;\\n            }\\n          }\\n\\n          if temp <= 2 {\\n            result.push(v.clone());\\n            break\\n          }\\n        }\\n      }\\n    }\\n   result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2809179,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for (String q : queries) {\\n            for (String d : dictionary) {\\n                int temp = diff(q, d);\\n                if (temp < 3) {\\n                    ans.add(q);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public int diff(String a, String b) {\\n        int count = 0;\\n        for (int i = 0; i < a.length(); i++) {\\n            if (a.charAt(i) != b.charAt(i)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> twoEditWords(String[] queries, String[] dictionary) {\\n        List<String> ans = new ArrayList<>();\\n        for (String q : queries) {\\n            for (String d : dictionary) {\\n                int temp = diff(q, d);\\n                if (temp < 3) {\\n                    ans.add(q);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public int diff(String a, String b) {\\n        int count = 0;\\n        for (int i = 0; i < a.length(); i++) {\\n            if (a.charAt(i) != b.charAt(i)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802532,
                "title": "python-brute-force-with-a-little-bit-optimization",
                "content": "```\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        visit = set()\\n        res = []\\n        for w1 in queries:\\n            if w1 in visit:\\n                res.append(w1)\\n                continue\\n            ok = False\\n            for w2 in dictionary:\\n                mismatch = 0\\n                for c1, c2 in zip(w1,w2):\\n                    if c1!=c2:\\n                        mismatch +=1\\n                    if mismatch>2:\\n                        break\\n                else:\\n                    ok = True\\n                if ok:\\n                    res.append(w1)\\n                    visit.add(w1)\\n                    break\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def twoEditWords(self, queries: List[str], dictionary: List[str]) -> List[str]:\\n        visit = set()\\n        res = []\\n        for w1 in queries:\\n            if w1 in visit:\\n                res.append(w1)\\n                continue\\n            ok = False\\n            for w2 in dictionary:\\n                mismatch = 0\\n                for c1, c2 in zip(w1,w2):\\n                    if c1!=c2:\\n                        mismatch +=1\\n                    if mismatch>2:\\n                        break\\n                else:\\n                    ok = True\\n                if ok:\\n                    res.append(w1)\\n                    visit.add(w1)\\n                    break\\n\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2801529,
                "title": "simple-python-solution",
                "content": "```\\ndef twoEditWords(self, q: List[str], d: List[str]) -> List[str]:\\n        re=[]\\n        for ele in q:\\n            for dic in d:\\n                dif=0\\n                for i in range(len(dic)):\\n                    if ele[i] != dic[i]:\\n                        dif+=1\\n                        if dif > 2:\\n                            break\\n                if dif < 3:\\n                    re.append(ele)\\n                    break\\n        return re\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef twoEditWords(self, q: List[str], d: List[str]) -> List[str]:\\n        re=[]\\n        for ele in q:\\n            for dic in d:\\n                dif=0\\n                for i in range(len(dic)):\\n                    if ele[i] != dic[i]:\\n                        dif+=1\\n                        if dif > 2:\\n                            break\\n                if dif < 3:\\n                    re.append(ele)\\n                    break\\n        return re\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2801421,
                "title": "declarative-beautiful-and-slow-ruby-one-liner",
                "content": "```\\n# @param {String[]} queries\\n# @param {String[]} dictionary\\n# @return {String[]}\\ndef two_edit_words(queries, dictionary)\\n  queries.filter { |q| dictionary.any? { |w| w.bytes.zip(q.bytes).count { _1 != _2 } <= 2 } }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String[]} queries\\n# @param {String[]} dictionary\\n# @return {String[]}\\ndef two_edit_words(queries, dictionary)\\n  queries.filter { |q| dictionary.any? { |w| w.bytes.zip(q.bytes).count { _1 != _2 } <= 2 } }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2797299,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def twoEditWords(self, queries, dictionary):\\n        n, ans = len(queries[0]), []\\n\\n        for i in queries:\\n            for j in dictionary:\\n                if sum(i[k] != j[k] for k in range(n)) < 3:\\n                    ans.append(i)\\n                    break\\n\\n        return ans\\n\\n\\n\\n\\n\\n        \\n\\n        \\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def twoEditWords(self, queries, dictionary):\\n        n, ans = len(queries[0]), []\\n\\n        for i in queries:\\n            for j in dictionary:\\n                if sum(i[k] != j[k] for k in range(n)) < 3:\\n                    ans.append(i)\\n                    break\\n\\n        return ans\\n\\n\\n\\n\\n\\n        \\n\\n        \\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1678315,
                "content": [
                    {
                        "username": "PhilipSmith",
                        "content": "Question should probably be marked Easy."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**Time Complexity : O(query.length * dict.length * constant_word_length)**\\n**Space Complexity : O(queries.length)**\\n\\nAre these the best possible complexities :("
                    },
                    {
                        "username": "jaiyadav",
                        "content": "this question just require some basic thinking"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "Is cubic the best we can do here for most solutions?"
                    }
                ]
            },
            {
                "id": 1934453,
                "content": [
                    {
                        "username": "PhilipSmith",
                        "content": "Question should probably be marked Easy."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**Time Complexity : O(query.length * dict.length * constant_word_length)**\\n**Space Complexity : O(queries.length)**\\n\\nAre these the best possible complexities :("
                    },
                    {
                        "username": "jaiyadav",
                        "content": "this question just require some basic thinking"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "Is cubic the best we can do here for most solutions?"
                    }
                ]
            },
            {
                "id": 1807346,
                "content": [
                    {
                        "username": "PhilipSmith",
                        "content": "Question should probably be marked Easy."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**Time Complexity : O(query.length * dict.length * constant_word_length)**\\n**Space Complexity : O(queries.length)**\\n\\nAre these the best possible complexities :("
                    },
                    {
                        "username": "jaiyadav",
                        "content": "this question just require some basic thinking"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "Is cubic the best we can do here for most solutions?"
                    }
                ]
            },
            {
                "id": 1711159,
                "content": [
                    {
                        "username": "PhilipSmith",
                        "content": "Question should probably be marked Easy."
                    },
                    {
                        "username": "Aman__Bhardwaj",
                        "content": "**Time Complexity : O(query.length * dict.length * constant_word_length)**\\n**Space Complexity : O(queries.length)**\\n\\nAre these the best possible complexities :("
                    },
                    {
                        "username": "jaiyadav",
                        "content": "this question just require some basic thinking"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "Is cubic the best we can do here for most solutions?"
                    }
                ]
            }
        ]
    }
]