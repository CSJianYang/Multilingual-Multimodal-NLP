[
    {
        "title": "Find All Good Indices",
        "question_content": "You are given a 0-indexed integer array nums of size n and a positive integer k.\nWe call an index i in the range k <= i < n - k good if the following conditions are satisfied:\n\n\tThe k elements that are just before the index i are in non-increasing order.\n\tThe k elements that are just after the index i are in non-decreasing order.\n\nReturn an array of all good indices sorted in increasing order.\n&nbsp;\nExample 1:\n\nInput: nums = [2,1,1,1,3,4,1], k = 2\nOutput: [2,3]\nExplanation: There are two good indices in the array:\n- Index 2. The subarray [2,1] is in non-increasing order, and the subarray [1,3] is in non-decreasing order.\n- Index 3. The subarray [1,1] is in non-increasing order, and the subarray [3,4] is in non-decreasing order.\nNote that the index 4 is not good because [4,1] is not non-decreasing.\nExample 2:\n\nInput: nums = [2,1,1,2], k = 2\nOutput: []\nExplanation: There are no good indices in this array.\n\n&nbsp;\nConstraints:\n\n\tn == nums.length\n\t3 <= n <= 105\n\t1 <= nums[i] <= 106\n\t1 <= k <= n / 2",
        "solutions": [
            {
                "id": 2620565,
                "title": "dp-c-java-python-intuition",
                "content": "+ **Intuition**:\\n  - Computing increasing and decreasing length for every index might give TLE.\\n\\n+ **Thought Process & Algorithm**:\\n   + If we precompute the length of decreasing till every from **left**.\\n   + If we precompute the length of increasing till every from **right**.\\n   + Then we can easily collect indexes in range **[k , n-k-1]** which have atleast **k elements** `before` and `after` both with the help of the length precomputed in above steps.\\n\\n+ **By precomputation what technique comes in our mind??**\\n  - Its `Dynamic Programming` also known as `prefix` or `suffix`.\\n\\n+ **Conclusion:**\\n  -  Whenever precomputation i.e some parameter calculation is required till every index, then we should think of **Dynamic Programming(Prefix / Suffix)**\\n\\n+ **Similar Question** :\\n  - [2100. Find Good Days to Rob the Bank](https://leetcode.com/problems/find-good-days-to-rob-the-bank/#:~:text=The%20ith%20day%20is,after%20i%20are%20non%2Ddecreasing.)\\n  -  [1800. Maximum Ascending Subarray Sum](https://leetcode.com/problems/maximum-ascending-subarray-sum/)\\n\\n<iframe src=\"https://leetcode.com/playground/42CgRuaw/shared\" frameBorder=\"0\" width=\"700\" height=\"500\"></iframe>\\n\\n\\n**Time** - O(n)\\n**Space** - O(n)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "+ **Intuition**:\\n  - Computing increasing and decreasing length for every index might give TLE.\\n\\n+ **Thought Process & Algorithm**:\\n   + If we precompute the length of decreasing till every from **left**.\\n   + If we precompute the length of increasing till every from **right**.\\n   + Then we can easily collect indexes in range **[k , n-k-1]** which have atleast **k elements** `before` and `after` both with the help of the length precomputed in above steps.\\n\\n+ **By precomputation what technique comes in our mind??**\\n  - Its `Dynamic Programming` also known as `prefix` or `suffix`.\\n\\n+ **Conclusion:**\\n  -  Whenever precomputation i.e some parameter calculation is required till every index, then we should think of **Dynamic Programming(Prefix / Suffix)**\\n\\n+ **Similar Question** :\\n  - [2100. Find Good Days to Rob the Bank](https://leetcode.com/problems/find-good-days-to-rob-the-bank/#:~:text=The%20ith%20day%20is,after%20i%20are%20non%2Ddecreasing.)\\n  -  [1800. Maximum Ascending Subarray Sum](https://leetcode.com/problems/maximum-ascending-subarray-sum/)\\n\\n<iframe src=\"https://leetcode.com/playground/42CgRuaw/shared\" frameBorder=\"0\" width=\"700\" height=\"500\"></iframe>\\n\\n\\n**Time** - O(n)\\n**Space** - O(n)",
                "codeTag": "Unknown"
            },
            {
                "id": 2620645,
                "title": "c-prefix-sum-dp-related-problems",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n\\n        int N = nums.size();\\n        vector<int> decreasing(N, 1), increasing(N, 1);\\n\\n        for (int i = 1; i < N; i++) {\\n            if (nums[i] <= nums[i - 1]) {\\n                decreasing[i] = 1 + decreasing[i - 1];\\n            }\\n        }\\n\\n        for (int i = N - 2; i >= 0; i--) {\\n            if (nums[i] <= nums[i + 1]) {\\n                increasing[i] = 1 + increasing[i + 1];\\n            }\\n        }\\n\\n        vector<int> ans;\\n\\n        for(int i = k; i < N - k; i++) {\\n            if (increasing[i + 1] >= k && decreasing[i - 1] >= k) {\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n**Related Problems**\\n[1. Range Sum Query - Immutable](https://leetcode.com/problems/range-sum-query-immutable/)\\n[2. Running Sum of 2D Array](https://leetcode.com/problems/running-sum-of-1d-array/)",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n\\n        int N = nums.size();\\n        vector<int> decreasing(N, 1), increasing(N, 1);\\n\\n        for (int i = 1; i < N; i++) {\\n            if (nums[i] <= nums[i - 1]) {\\n                decreasing[i] = 1 + decreasing[i - 1];\\n            }\\n        }\\n\\n        for (int i = N - 2; i >= 0; i--) {\\n            if (nums[i] <= nums[i + 1]) {\\n                increasing[i] = 1 + increasing[i + 1];\\n            }\\n        }\\n\\n        vector<int> ans;\\n\\n        for(int i = k; i < N - k; i++) {\\n            if (increasing[i + 1] >= k && decreasing[i - 1] >= k) {\\n                ans.push_back(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620637,
                "title": "python3-two-passes-o-n-with-line-by-line-comments",
                "content": "To solve the problem, we will need to traverse the array left to right and then right to left. From left to right, at each index i, we will compute how many elements that are just before the index i are in non-increasing order. To do this, we will use a non-increasing stack to store the elements before i, at each step we just check if the length of the stack is greater or equal to k and if it is, this index i is True for the forward pass. Doing the simillar thing from right to left, this time, we will check if the length of the stack is greater or equal to k and also if the forward[i] is Ture, if it is, add this index to the result. If you are doing left to right and then right to left like I did, you will need to return result in the reversed order.\\n\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        ### forward pass.\\n        forward = [False]*len(nums) ### For the forward pass, store if index i is good or not.\\n        stack = []\\n        for i in range(len(nums)):\\n        \\t### if the leangth of stack is greater or equal to k, it means this index is good.\\n            if len(stack)>=k:\\n                forward[i] = True\\n            ### if the stack is empty, just add the current number to it.\\n            if not stack:\\n                stack.append(nums[i])\\n            ### check to see if the current number is smaller or equal to the last number in stack, if it is not, put this number into the stack.\\n            else:\\n                if nums[i]<=stack[-1]:\\n                    stack.append(nums[i])\\n                else:\\n                    stack = [nums[i]]\\n        ### backward pass\\n        res = []\\n        stack = []\\n        for i in reversed(range(len(nums))):\\n        \\t### Check to see if the length of stack is greater or equal to k and also check if the forward pass at this index is Ture.\\n            if len(stack)>=k and forward[i]:\\n                res.append(i)\\n            if not stack:\\n                stack.append(nums[i])\\n            else:\\n                if nums[i]<=stack[-1]:\\n                    stack.append(nums[i])\\n                else:\\n                    stack = [nums[i]]\\n        return res[::-1]\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        ### forward pass.\\n        forward = [False]*len(nums) ### For the forward pass, store if index i is good or not.\\n        stack = []\\n        for i in range(len(nums)):\\n        \\t### if the leangth of stack is greater or equal to k, it means this index is good.\\n            if len(stack)>=k:\\n                forward[i] = True\\n            ### if the stack is empty, just add the current number to it.\\n            if not stack:\\n                stack.append(nums[i])\\n            ### check to see if the current number is smaller or equal to the last number in stack, if it is not, put this number into the stack.\\n            else:\\n                if nums[i]<=stack[-1]:\\n                    stack.append(nums[i])\\n                else:\\n                    stack = [nums[i]]\\n        ### backward pass\\n        res = []\\n        stack = []\\n        for i in reversed(range(len(nums))):\\n        \\t### Check to see if the length of stack is greater or equal to k and also check if the forward pass at this index is Ture.\\n            if len(stack)>=k and forward[i]:\\n                res.append(i)\\n            if not stack:\\n                stack.append(nums[i])\\n            else:\\n                if nums[i]<=stack[-1]:\\n                    stack.append(nums[i])\\n                else:\\n                    stack = [nums[i]]\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620555,
                "title": "two-prefix-array",
                "content": "* store two prefix array one for decreasing elements and one for increasing element \\n\\n* then simple check if dec[i-1]>=k && inc[i+k]>=k then this is valid index\\n\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n=nums.length;\\n        int dec[]=new int[n],inc[]=new int[n];\\n        List<Integer> ans=new ArrayList<Integer>();\\n        \\n        int start=nums[0],end=nums[0];\\n        int len=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<=start) len++;\\n            else len=1;\\n            start=nums[i];\\n            dec[i]=len;\\n        }\\n        len=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]>=end) len++;\\n            else len=1;\\n            end=nums[i];\\n            inc[i]=len;\\n        }\\n        \\n        for(int i=k; i<n-k; i++){\\n            if(dec[i-1]>=k && inc[i+k]>=k) ans.add(i);\\n        }        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n=nums.length;\\n        int dec[]=new int[n],inc[]=new int[n];\\n        List<Integer> ans=new ArrayList<Integer>();\\n        \\n        int start=nums[0],end=nums[0];\\n        int len=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<=start) len++;\\n            else len=1;\\n            start=nums[i];\\n            dec[i]=len;\\n        }\\n        len=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]>=end) len++;\\n            else len=1;\\n            end=nums[i];\\n            inc[i]=len;\\n        }\\n        \\n        for(int i=k; i<n-k; i++){\\n            if(dec[i-1]>=k && inc[i+k]>=k) ans.add(i);\\n        }        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620472,
                "title": "java-python-3-compute-the-increase-decrease-array-w-analysis-and-similar-problems",
                "content": "**Similar Problems:**\\n[Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/)  \\n[Range Sum Query - Immutable](https://leetcode.com/problems/range-sum-query-immutable/)  \\n[Running Sum of 2D Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1800. Maximum Ascending Subarray Sum](https://leetcode.com/problems/maximum-ascending-subarray-sum/)\\n[2100. Find Good Days to Rob the Bank](https://leetcode.com/problems/find-good-days-to-rob-the-bank/)\\n\\n----\\n\\nCompute the consecutively non-decreasing and non-increasing arrays respectively, then traverse the indices to confirm if each is good.\\n\\n```java\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] non_dec = new int[n], non_inc = new int[n];\\n        Arrays.fill(non_dec, 1);\\n        Arrays.fill(non_inc, 1);\\n        for (int i = 1; i < n; ++i) {\\n            if (nums[i] <= nums[i - 1]) {\\n                non_inc[i] = non_inc[i - 1] + 1;\\n            }\\n            if (nums[i] >= nums[i - 1]) {\\n                non_dec[i] = non_dec[i - 1] + 1;\\n            }\\n        }\\n        List<Integer> good = new ArrayList<>();\\n        for (int i = k; i < n - k; ++i) {\\n            if (non_inc[i - 1] >= k && non_dec[i + k] >= k) {\\n                good.add(i);\\n            }\\n        }\\n        return good;\\n    }\\n```\\n```python\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        non_dec, non_inc = [1] * n, [1] * n\\n        for i in range(1, n):\\n            if nums[i] <= nums[i - 1]:\\n                non_inc[i] = non_inc[i - 1] + 1\\n            if nums[i] >= nums[i - 1]:    \\n                non_dec[i] = non_dec[i - 1] + 1\\n        return [i for i in range(k, n - k) if non_inc[i - 1] >= k and non_dec[i + k] >= k]      \\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`.",
                "solutionTags": [],
                "code": "```java\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] non_dec = new int[n], non_inc = new int[n];\\n        Arrays.fill(non_dec, 1);\\n        Arrays.fill(non_inc, 1);\\n        for (int i = 1; i < n; ++i) {\\n            if (nums[i] <= nums[i - 1]) {\\n                non_inc[i] = non_inc[i - 1] + 1;\\n            }\\n            if (nums[i] >= nums[i - 1]) {\\n                non_dec[i] = non_dec[i - 1] + 1;\\n            }\\n        }\\n        List<Integer> good = new ArrayList<>();\\n        for (int i = k; i < n - k; ++i) {\\n            if (non_inc[i - 1] >= k && non_dec[i + k] >= k) {\\n                good.add(i);\\n            }\\n        }\\n        return good;\\n    }\\n```\n```python\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        non_dec, non_inc = [1] * n, [1] * n\\n        for i in range(1, n):\\n            if nums[i] <= nums[i - 1]:\\n                non_inc[i] = non_inc[i - 1] + 1\\n            if nums[i] >= nums[i - 1]:    \\n                non_dec[i] = non_dec[i - 1] + 1\\n        return [i for i in range(k, n - k) if non_inc[i - 1] >= k and non_dec[i + k] >= k]      \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2620479,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> left(n,0) , right(n,0);\\n        \\n        for(int i = 1; i < n ; i++){\\n            if(nums[i] <= nums[i-1]){\\n                left[i] = left[i-1]+1;\\n            }\\n        }\\n        for(int i = n-2 ; i>= 0 ; i--){\\n            if(nums[i] <= nums[i+1]){\\n                right[i] = right[i+1]+1;\\n            }\\n        }\\n        vector<int> ans;\\n        \\n        for(int i = k ; i< n-k ; i++){\\n            if(min(left[i-1],right[i+1]) >= k-1){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int> left(n,0) , right(n,0);\\n        \\n        for(int i = 1; i < n ; i++){\\n            if(nums[i] <= nums[i-1]){\\n                left[i] = left[i-1]+1;\\n            }\\n        }\\n        for(int i = n-2 ; i>= 0 ; i--){\\n            if(nums[i] <= nums[i+1]){\\n                right[i] = right[i+1]+1;\\n            }\\n        }\\n        vector<int> ans;\\n        \\n        for(int i = k ; i< n-k ; i++){\\n            if(min(left[i-1],right[i+1]) >= k-1){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620816,
                "title": "o-1-space-without-dp-single-pass-5ms-o-n-100-java",
                "content": "The intuition is simple, check if the k elements before and k elements after the current element satisfy the codition. Store the last indexes of the non-increasing  and non-decreasing order elements already checked in a variable. We store the indexes, since we have already checked the indexes upto that point and do not need to check again.\\n```\\npublic List<Integer> goodIndices(int[] nums, int k) {\\n        \\n        List<Integer> res = new ArrayList<>();\\n        int before = 0, after = 0;\\n        \\n        first:\\n        for(int i = k; i < nums.length - k; i++){\\n            \\n\\t\\t\\t//check the k elements before\\n            int j = Math.max(before, i - k);\\n            while(j < i - 1){\\n                if(nums[j] < nums[j + 1]){\\n                    i = j + k ; continue first;\\n                }\\n                j++;\\n            }\\n            \\n\\t\\t\\t//check the k elements after\\n            j = Math.max(after, i + 1);\\n            while(j < k + i){\\n                if(nums[j] > nums[j + 1]){\\n                    i = j - 1; continue first;\\n                }\\n                j++;\\n            }\\n            \\n\\t\\t\\t//since both conditions satisfied, update before and after variables and add current index to result\\n            before = i - 1; after = i + k - 1;\\n            res.add(i);\\n        }\\n        \\n        return res;\\n    }\\n```\\t\\nTime - O(n)\\nSpace - O(1)",
                "solutionTags": [],
                "code": "```\\npublic List<Integer> goodIndices(int[] nums, int k) {\\n        \\n        List<Integer> res = new ArrayList<>();\\n        int before = 0, after = 0;\\n        \\n        first:\\n        for(int i = k; i < nums.length - k; i++){\\n            \\n\\t\\t\\t//check the k elements before\\n            int j = Math.max(before, i - k);\\n            while(j < i - 1){\\n                if(nums[j] < nums[j + 1]){\\n                    i = j + k ; continue first;\\n                }\\n                j++;\\n            }\\n            \\n\\t\\t\\t//check the k elements after\\n            j = Math.max(after, i + 1);\\n            while(j < k + i){\\n                if(nums[j] > nums[j + 1]){\\n                    i = j - 1; continue first;\\n                }\\n                j++;\\n            }\\n            \\n\\t\\t\\t//since both conditions satisfied, update before and after variables and add current index to result\\n            before = i - 1; after = i + k - 1;\\n            res.add(i);\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621069,
                "title": "probably-the-easiest-solution-two-pass-o-n-without-dp-cpp",
                "content": "**Logic - FInd all the indexes which have k non increasing elements before them. Similarly find the indexes which have k non increasing elements after them. Find the common indexes between these two.**\\n\\n```\\n\\t\\t// Store the indexes which have k non increasing elements before them\\n\\t\\tvector<int> nonInc;\\n        int cnt = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(i==0 || nums[i]<=nums[i-1]){\\n                cnt++;\\n            }\\n            else{\\n                cnt = 1;\\n            }\\n\\t\\t\\t// count equals k means we have seen k non increasing elements till now, so the element next to current element will have k non increasing elements before it.\\n            if(cnt >= k){\\n                nonInc.push_back(i+1);\\n            }\\n        }\\n\\t\\t// Store the indexes which have k non decreasing elements before them\\n        vector<int> nonDec;\\n        cnt = 0;\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            if(i==nums.size()-1 || nums[i]<=nums[i+1]){\\n                cnt++;\\n            }\\n            else{\\n                cnt = 1;\\n            }\\n            if(cnt >= k){\\n                nonDec.push_back(i-1);\\n            }\\n        }\\n\\t\\t// The vector nonInc will be sorted in increasing order while nonDec will be sorted in decreasing order.\\n        vector<int> ans;\\n        for(auto it : nonDec){\\n\\t\\t// Checking if current value is present in nonInc vector or not.\\n            if(binary_search(nonInc.begin(), nonInc.end(), it)){\\n\\t\\t\\t// If it is present this means, the element is present in both the vectors and hence is a solution.\\n                ans.push_back(it);\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n```\\n\\n***Do upvote if you liked the solution.***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\t\\t// Store the indexes which have k non increasing elements before them\\n\\t\\tvector<int> nonInc;\\n        int cnt = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(i==0 || nums[i]<=nums[i-1]){\\n                cnt++;\\n            }\\n            else{\\n                cnt = 1;\\n            }\\n\\t\\t\\t// count equals k means we have seen k non increasing elements till now, so the element next to current element will have k non increasing elements before it.\\n            if(cnt >= k){\\n                nonInc.push_back(i+1);\\n            }\\n        }\\n\\t\\t// Store the indexes which have k non decreasing elements before them\\n        vector<int> nonDec;\\n        cnt = 0;\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            if(i==nums.size()-1 || nums[i]<=nums[i+1]){\\n                cnt++;\\n            }\\n            else{\\n                cnt = 1;\\n            }\\n            if(cnt >= k){\\n                nonDec.push_back(i-1);\\n            }\\n        }\\n\\t\\t// The vector nonInc will be sorted in increasing order while nonDec will be sorted in decreasing order.\\n        vector<int> ans;\\n        for(auto it : nonDec){\\n\\t\\t// Checking if current value is present in nonInc vector or not.\\n            if(binary_search(nonInc.begin(), nonInc.end(), it)){\\n\\t\\t\\t// If it is present this means, the element is present in both the vectors and hence is a solution.\\n                ans.push_back(it);\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620563,
                "title": "dp-vs-set-intersection",
                "content": "#### DP\\nGo right-to-left, storing the count of non-decreasing elements after `i` in `after[i]`. \\n\\nThen go left to right, count the number of non-increasing elements in `before`.\\n\\nIf the number `before` and `after[i]` is at least `k`, add `i` to the result.\\n\\n**C++**\\n```cpp\\nvector<int> goodIndices(vector<int>& nums, int k) {\\n    int before = 1, sz = nums.size();\\n    vector<int> after(sz, 1), res;\\n    for (int i = sz - 2; i > 0; --i)\\n        after[i - 1] = nums[i] > nums[i + 1] ? 1 : after[i] + 1;\\n    for (int i = 1; i < sz - 1; ++i) {\\n        if (min(before, after[i]) >= k)\\n            res.push_back(i);\\n        before = nums[i] > nums[i - 1] ? 1 : before + 1;\\n    }\\n    return res;\\n}\\n```\\n\\n#### Set Intersection\\nGo left-to-right, and right-to-left, collecting candidates.\\n\\nUse set_intersection to return only candidates that matches two conditions.\\n\\n**C++**\\n```cpp\\nvector<int> goodIndices(vector<int>& nums, int k) {\\n    int before_cnt = 1, after_cnt = 1, sz = nums.size();\\n    vector<int> bid, aid;\\n    for (int i = 1; i < sz; ++i) {\\n        if (before_cnt >= k)\\n            bid.push_back(i);\\n        if (after_cnt >= k)\\n            aid.push_back(sz - i - 1);\\n        before_cnt = nums[i] > nums[i - 1] ? 1 : before_cnt + 1;\\n        after_cnt = nums[sz - i - 1] > nums[sz - i] ? 1 : after_cnt + 1;\\n    }\\n    auto it = set_intersection(begin(bid), end(bid), rbegin(aid), rend(aid), begin(bid));\\n    return vector<int>(begin(bid), it);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> goodIndices(vector<int>& nums, int k) {\\n    int before = 1, sz = nums.size();\\n    vector<int> after(sz, 1), res;\\n    for (int i = sz - 2; i > 0; --i)\\n        after[i - 1] = nums[i] > nums[i + 1] ? 1 : after[i] + 1;\\n    for (int i = 1; i < sz - 1; ++i) {\\n        if (min(before, after[i]) >= k)\\n            res.push_back(i);\\n        before = nums[i] > nums[i - 1] ? 1 : before + 1;\\n    }\\n    return res;\\n}\\n```\n```cpp\\nvector<int> goodIndices(vector<int>& nums, int k) {\\n    int before_cnt = 1, after_cnt = 1, sz = nums.size();\\n    vector<int> bid, aid;\\n    for (int i = 1; i < sz; ++i) {\\n        if (before_cnt >= k)\\n            bid.push_back(i);\\n        if (after_cnt >= k)\\n            aid.push_back(sz - i - 1);\\n        before_cnt = nums[i] > nums[i - 1] ? 1 : before_cnt + 1;\\n        after_cnt = nums[sz - i - 1] > nums[sz - i] ? 1 : after_cnt + 1;\\n    }\\n    auto it = set_intersection(begin(bid), end(bid), rbegin(aid), rend(aid), begin(bid));\\n    return vector<int>(begin(bid), it);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620502,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        \\n        int n = nums.length;\\n        int[] pre = new int[n];\\n        int[] suf = new int[n];\\n        \\n    \\n        suf[n-1] = 1;\\n        pre[0] = 1;\\n        for( int i = 1 ; i < n; i++) {\\n            if(nums[i] <= nums[i -1]) {\\n               pre[i] = pre[i-1] + 1 ;\\n            } else {\\n                pre[i] = 1;\\n            }\\n        }\\n        \\n       \\n         for( int i = n-2 ; i >= 0; i--) {\\n            if(nums[i] <= nums[i + 1]) {\\n               suf[i] = suf[i+ 1] + 1 ;\\n            } else {\\n                suf[i] = 1;\\n            }\\n        }\\n        \\n        List<Integer> out = new ArrayList();\\n        for( int i = k  ; i < n - k  ; i++) {\\n            if(suf[i+1] >= k && pre[i - 1] >= k) {\\n                out.add(i);\\n            }\\n        }\\n        return out;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        \\n        int n = nums.length;\\n        int[] pre = new int[n];\\n        int[] suf = new int[n];\\n        \\n    \\n        suf[n-1] = 1;\\n        pre[0] = 1;\\n        for( int i = 1 ; i < n; i++) {\\n            if(nums[i] <= nums[i -1]) {\\n               pre[i] = pre[i-1] + 1 ;\\n            } else {\\n                pre[i] = 1;\\n            }\\n        }\\n        \\n       \\n         for( int i = n-2 ; i >= 0; i--) {\\n            if(nums[i] <= nums[i + 1]) {\\n               suf[i] = suf[i+ 1] + 1 ;\\n            } else {\\n                suf[i] = 1;\\n            }\\n        }\\n        \\n        List<Integer> out = new ArrayList();\\n        for( int i = k  ; i < n - k  ; i++) {\\n            if(suf[i+1] >= k && pre[i - 1] >= k) {\\n                out.add(i);\\n            }\\n        }\\n        return out;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620480,
                "title": "c-easy-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> pref(n,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]<=nums[i-1]) // for checking  non increasing order\\n                pref[i]+=pref[i-1];\\n        }\\n        vector<int> suff(n,1);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])// for checking non decreasing order\\n                suff[i]+=suff[i+1];\\n        }\\n        vector<int> ans;\\n        for(int i=1;i<n-k;i++)\\n        {\\n            if(pref[i-1]>=k and suff[i+1]>=k) //for keeping track of length on both sides greater than equal to k\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> pref(n,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]<=nums[i-1]) // for checking  non increasing order\\n                pref[i]+=pref[i-1];\\n        }\\n        vector<int> suff(n,1);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])// for checking non decreasing order\\n                suff[i]+=suff[i+1];\\n        }\\n        vector<int> ans;\\n        for(int i=1;i<n-k;i++)\\n        {\\n            if(pref[i-1]>=k and suff[i+1]>=k) //for keeping track of length on both sides greater than equal to k\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620469,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i-1]>=nums[i])\\n            {\\n                left[i]+=left[i-1];\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            {\\n                right[i]+=right[i+1];\\n            }\\n        }\\n       \\n        vector<int>ans;\\n        for(int i=k;i<n-k;i++)\\n        {\\n            if(left[i-1]>=k&&k<=right[i+1])\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i-1]>=nums[i])\\n            {\\n                left[i]+=left[i-1];\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            {\\n                right[i]+=right[i+1];\\n            }\\n        }\\n       \\n        vector<int>ans;\\n        for(int i=k;i<n-k;i++)\\n        {\\n            if(left[i-1]>=k&&k<=right[i+1])\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636206,
                "title": "java-solution-o-n-explanation",
                "content": "For this approach, we will be finding the **prefix and suffix value for every element** in the array.\\nPrefix array will maintain the number of elements that are just before the index i, which are in non-increasing order.\\nSuffix array will maintain the number of elements that are just after the index i, which are in non-decreasing order.\\n\\nWe know the base case.\\nFor `nums[0]`, number of elements before it which are in non-increasing order is 0. Hence **`prefix[0]` will be 0**.\\nFor `nums[1]`, number of elements before it which are in non-increasing order is 1. Hence **`prefix[0]` will be 1**.\\n\\nSimilarly,\\nFor `nums[n-1]`, number of elements after it which are in non-decreasing order is 0. Hence **`suffix[0]` will be 0**.\\nFor `nums[n-2]`, number of elements after it which are in non-decreasing order is 1. Hence **`suffix[0]` will be 1**.\\n\\nWe start from here, and continue finding the prefix and suffix value for each element.\\nConsider the fact that if the condition `nums[i-1] <= nums[i - 2]` is true, `prefix[i]` will be **1 more than `prefix[i-1]`**. Else, `prefix[i]` will be equal to 1.\\nSimilarly, if the condition `nums[i + 1] <= nums[i + 2]` is true, `suffix[i]` will be **1 more than `suffix[i + 1]`**. Else, `suffix[i]` will be equal to 1.\\n\\nOnce we have our suffix and prefix arrays ready, we can traverse through them and check if the condition `prefix[i] >= k && suffix[i] >= k` holds true. In that case, we can add the index to our answer list.\\n\\nHere is the entire code for reference:\\n\\n\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] prefix = new int[n]; // number of elements that are just before the index i, which are in non-increasing order\\n        int[] suffix = new int[n]; // number of elements that are just after the index i, which are in non-decreasing order\\n        \\n        List<Integer> ans = new ArrayList<Integer>(); // List to store all good indices\\n        \\n        prefix[0] = 0; prefix[1] = 1; // Base condition for prefixes\\n\\t\\t// Loop to calculate prefix for all other elements\\n        for (int i = 2; i < n; i++) {\\n          if (nums[i-1] <= nums[i - 2])\\n            prefix[i] = prefix[i - 1] + 1;\\n          else\\n            prefix[i] = 1;\\n        }\\n\\n        suffix[n - 1] = 0; suffix[n - 2] = 1; // Base condition for suffixes\\n\\t\\t// Loop to calculate suffix for all other elements\\n        for (int i = n - 3; i >= 0; i--) {\\n          if (nums[i + 1] <= nums[i + 2])\\n            suffix[i] = suffix[i + 1] + 1;\\n          else\\n            suffix[i] = 1;\\n        }\\n\\t\\t\\n\\t\\t// Loop to check if k elements before and after nums[i] satisfy the required condition \\n        for (int i = 0; i < n; i++) {\\n            if (prefix[i] >= k && suffix[i] >= k)\\n                ans.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] prefix = new int[n]; // number of elements that are just before the index i, which are in non-increasing order\\n        int[] suffix = new int[n]; // number of elements that are just after the index i, which are in non-decreasing order\\n        \\n        List<Integer> ans = new ArrayList<Integer>(); // List to store all good indices\\n        \\n        prefix[0] = 0; prefix[1] = 1; // Base condition for prefixes\\n\\t\\t// Loop to calculate prefix for all other elements\\n        for (int i = 2; i < n; i++) {\\n          if (nums[i-1] <= nums[i - 2])\\n            prefix[i] = prefix[i - 1] + 1;\\n          else\\n            prefix[i] = 1;\\n        }\\n\\n        suffix[n - 1] = 0; suffix[n - 2] = 1; // Base condition for suffixes\\n\\t\\t// Loop to calculate suffix for all other elements\\n        for (int i = n - 3; i >= 0; i--) {\\n          if (nums[i + 1] <= nums[i + 2])\\n            suffix[i] = suffix[i + 1] + 1;\\n          else\\n            suffix[i] = 1;\\n        }\\n\\t\\t\\n\\t\\t// Loop to check if k elements before and after nums[i] satisfy the required condition \\n        for (int i = 0; i < n; i++) {\\n            if (prefix[i] >= k && suffix[i] >= k)\\n                ans.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620858,
                "title": "c-o-n-sliding-window-solution",
                "content": "For each index from [k , n-k-1], find its left window is non-decreasing or not. If non decreasing put v[i] = 1 , else 0.\\nDo same for right window\\nIf left and right window both giving 1 then add it to answer.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int>solve(vector<int>&nums , int k){              \\n        int n = nums.size();\\n        vector<int>v(n , 0);\\n        queue<int>idx;\\n        for(int i=1; i<k; i++){\\n            if(nums[i] > nums[i-1])\\n                idx.push(i);\\n        }\\n        \\n        for(int i=k; i<n-k ; i++){\\n            while(idx.size() && idx.front() <= i-k)\\n                idx.pop();\\n            \\n            if(idx.size() == 0) {\\n                v[i] = 1;\\n            }\\n            if(nums[i] > nums[i-1])\\n                idx.push(i);\\n        }\\n        \\n        return v;\\n    }\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int>inc = solve(nums , k);\\n        reverse(nums.begin() , nums.end());\\n        \\n        vector<int>dec = solve(nums , k);\\n        reverse(dec.begin() , dec.end());\\n        \\n        vector<int>ans;\\n        for(int i=k ;i<n-k;i++){\\n            if(inc[i] == 1 && dec[i] == 1)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int>solve(vector<int>&nums , int k){              \\n        int n = nums.size();\\n        vector<int>v(n , 0);\\n        queue<int>idx;\\n        for(int i=1; i<k; i++){\\n            if(nums[i] > nums[i-1])\\n                idx.push(i);\\n        }\\n        \\n        for(int i=k; i<n-k ; i++){\\n            while(idx.size() && idx.front() <= i-k)\\n                idx.pop();\\n            \\n            if(idx.size() == 0) {\\n                v[i] = 1;\\n            }\\n            if(nums[i] > nums[i-1])\\n                idx.push(i);\\n        }\\n        \\n        return v;\\n    }\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        vector<int>inc = solve(nums , k);\\n        reverse(nums.begin() , nums.end());\\n        \\n        vector<int>dec = solve(nums , k);\\n        reverse(dec.begin() , dec.end());\\n        \\n        vector<int>ans;\\n        for(int i=k ;i<n-k;i++){\\n            if(inc[i] == 1 && dec[i] == 1)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620543,
                "title": "kotlin-easy-prefix-suffix-solution",
                "content": "```\\nclass Solution {\\n    fun goodIndices(nums: IntArray, k: Int): List<Int> {\\n        if (k.toLong() == Math.round(nums.size / 2.0)) return listOf()\\n        var streakD = Array<Int>(nums.size) { 0 }\\n        var streakI = Array<Int>(nums.size) { 0 }\\n        var curr = 0\\n        var prev = Integer.MAX_VALUE\\n        for (i in nums.indices) {\\n            if (nums[i] <= prev) curr++\\n            else curr = 1\\n            prev = nums[i]\\n            streakD[i] = curr\\n        }\\n        prev = 0\\n        curr = 0\\n        for (i in nums.size - 1 downTo 0) {\\n            if (nums[i] <= prev) curr++\\n            else curr = 1\\n            prev = nums[i]\\n            streakI[i] = curr\\n        }\\n        val result = mutableListOf<Int>()\\n        for (i in k until nums.size - k) {\\n            if (streakD[i - 1] >= k && streakI[i + 1] >= k) {\\n                result.add(i)\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    fun goodIndices(nums: IntArray, k: Int): List<Int> {\\n        if (k.toLong() == Math.round(nums.size / 2.0)) return listOf()\\n        var streakD = Array<Int>(nums.size) { 0 }\\n        var streakI = Array<Int>(nums.size) { 0 }\\n        var curr = 0\\n        var prev = Integer.MAX_VALUE\\n        for (i in nums.indices) {\\n            if (nums[i] <= prev) curr++\\n            else curr = 1\\n            prev = nums[i]\\n            streakD[i] = curr\\n        }\\n        prev = 0\\n        curr = 0\\n        for (i in nums.size - 1 downTo 0) {\\n            if (nums[i] <= prev) curr++\\n            else curr = 1\\n            prev = nums[i]\\n            streakI[i] = curr\\n        }\\n        val result = mutableListOf<Int>()\\n        for (i in k until nums.size - k) {\\n            if (streakD[i - 1] >= k && streakI[i + 1] >= k) {\\n                result.add(i)\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620536,
                "title": "python-3-simple-10-lines-solution-with-explanation",
                "content": "\\n#### Explanation\\n1. Write a helper function to calculate the length of non increasing subarray before each idx. For each number, if it is non-increasing campare to the previous number, we add one to the previous non-increasing subarray length, otherwise we set the current length to 1.\\n2.  It can be summarized in to a simple formula: `cur_subarr_length = prev_subarr_length * is_non_increasing + 1`.\\n3. Also, use this helper function to find non decreasing subarry after each idx by applying this on the reverse of `nums` array.\\n4. Loop through each index to find the result.\\n\\n#### Solution\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        def noninc_subarr_len(lis):\\n            l = [lis[i] <= lis[i-1] for i in range(1, len(lis))]\\n            res = [0, 1]\\n            for is_non_increasing in l[:-1]:\\n                res.append(res[-1] * is_non_increasing + 1)\\n            return res\\n        before, after = noninc_subarr_len(nums), noninc_subarr_len(nums[::-1])\\n        return [idx for idx in range(len(nums)) if min(before[idx], after[-1-idx]) >= k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        def noninc_subarr_len(lis):\\n            l = [lis[i] <= lis[i-1] for i in range(1, len(lis))]\\n            res = [0, 1]\\n            for is_non_increasing in l[:-1]:\\n                res.append(res[-1] * is_non_increasing + 1)\\n            return res\\n        before, after = noninc_subarr_len(nums), noninc_subarr_len(nums[::-1])\\n        return [idx for idx in range(len(nums)) if min(before[idx], after[-1-idx]) >= k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620518,
                "title": "prefix-suffix-array",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] cntG = new int[nums.length];\\n        int[] cntP = new int[nums.length];\\n        int cnt = 1;\\n        cntG[n-1] = 1;\\n        for(int i = n-2; i >=0; i--) {\\n            cntG[i] = cnt;\\n            if(nums[i]<=nums[i+1]) {\\n              cnt++;\\n            }else {\\n                cnt = 1;\\n            }\\n           \\n         \\n        }\\n        cnt = 1;\\n        cntP[0] = 1;\\n        for(int i = 1; i < nums.length; i++) {\\n            cntP[i] = cnt;\\n            if(nums[i]<=nums[i-1]) {\\n                cnt++;\\n            }else {\\n                cnt = 1;\\n            }\\n            \\n        }\\n         List<Integer> res = new ArrayList<>();\\n        for(int i = k; i < n-k; i++) {\\n            if(cntG[i]>=k && cntP[i]>=k) res.add(i);\\n        }\\n        return res;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] cntG = new int[nums.length];\\n        int[] cntP = new int[nums.length];\\n        int cnt = 1;\\n        cntG[n-1] = 1;\\n        for(int i = n-2; i >=0; i--) {\\n            cntG[i] = cnt;\\n            if(nums[i]<=nums[i+1]) {\\n              cnt++;\\n            }else {\\n                cnt = 1;\\n            }\\n           \\n         \\n        }\\n        cnt = 1;\\n        cntP[0] = 1;\\n        for(int i = 1; i < nums.length; i++) {\\n            cntP[i] = cnt;\\n            if(nums[i]<=nums[i-1]) {\\n                cnt++;\\n            }else {\\n                cnt = 1;\\n            }\\n            \\n        }\\n         List<Integer> res = new ArrayList<>();\\n        for(int i = k; i < n-k; i++) {\\n            if(cntG[i]>=k && cntP[i]>=k) res.add(i);\\n        }\\n        return res;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820306,
                "title": "prefix-sum-c-beats-100-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is very Simple, **store pre-calculated numbers, non-increasing and non-decreasing numbers at each ith position**.\\n\\nHere i use **left vector to store the non-increasing numbers at each ith position and right Vector to store the non-decreasing numbers at ith position**.\\n\\nNow we can easily find out the number of Good Indexes.\\n\\n```\\nFor Ex: Array = [2,1,1,3,4,5]  K = 2\\n\\nnon-increasing Numbers(left side) at each ith position:- \\n               left = [1,2,3,1,1,1]   \\nleft[0] = 1,non-increasing numbers on left side [2].\\nleft[1] = 2,non-increasing numbers on left side [2,1].\\nleft[2] = 3,non-increasing numbers on left side [2,1,1]\\nleft[3] = 1,non-increasing numbers on left side [3]\\nleft[4] = 1,non-increasing numbers on left side [4]\\nleft[5] = 1,non-increasing numbers on left side [5]\\n\\nnon-decreasing numbers(right side) at each ith position:-\\n                right = [1,5,4,3,2,1]\\nright[0] = 1,non-decreasing numbers on right side [2]\\nright[1] = 5,non-decreasing numbers on right side [1,1,3,4,5]\\nright[2] = 4,non-decreasing numbers on right side [1,3,4,5]\\nright[3] = 3,non-decreasing numbers on right side [3,4,5]\\nright[4] = 2,non-decreasing numbers on right side [4,5]\\nright[5] = 1,non-decreasing numbers on right side [5]\\n\\nNow for Each Index check, how many numbers are non-increasing on the left \\nside and how many numbers are non-decreasing on the right side. if the \\nindex satisfies the given condition then that will be a good index\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& arr, int k) {\\n        int n = arr.size(),cnt = 1;\\n        vector<int> left(n,1),right(n,1),ans;\\n        for(int i = 1;i<n;i++)\\n        {\\n           if(arr[i]<=arr[i-1]) cnt++;\\n           else cnt = 1;\\n           left[i] = cnt;\\n        }\\n        cnt = 1;\\n        for(int i = n-2;i>=0;i--)\\n        {\\n            if(arr[i]<=arr[i+1]) cnt++;\\n            else cnt = 1;\\n            right[i] = cnt;\\n        }\\n        for(int i = k;i<n-k;i++)\\n        if(left[i-1]>=k && right[i+1]>=k) ans.push_back(i);\\n        return ans;  \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/a356e3c1-3436-454f-8d27-5382426385c7_1690392499.655233.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nFor Ex: Array = [2,1,1,3,4,5]  K = 2\\n\\nnon-increasing Numbers(left side) at each ith position:- \\n               left = [1,2,3,1,1,1]   \\nleft[0] = 1,non-increasing numbers on left side [2].\\nleft[1] = 2,non-increasing numbers on left side [2,1].\\nleft[2] = 3,non-increasing numbers on left side [2,1,1]\\nleft[3] = 1,non-increasing numbers on left side [3]\\nleft[4] = 1,non-increasing numbers on left side [4]\\nleft[5] = 1,non-increasing numbers on left side [5]\\n\\nnon-decreasing numbers(right side) at each ith position:-\\n                right = [1,5,4,3,2,1]\\nright[0] = 1,non-decreasing numbers on right side [2]\\nright[1] = 5,non-decreasing numbers on right side [1,1,3,4,5]\\nright[2] = 4,non-decreasing numbers on right side [1,3,4,5]\\nright[3] = 3,non-decreasing numbers on right side [3,4,5]\\nright[4] = 2,non-decreasing numbers on right side [4,5]\\nright[5] = 1,non-decreasing numbers on right side [5]\\n\\nNow for Each Index check, how many numbers are non-increasing on the left \\nside and how many numbers are non-decreasing on the right side. if the \\nindex satisfies the given condition then that will be a good index\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& arr, int k) {\\n        int n = arr.size(),cnt = 1;\\n        vector<int> left(n,1),right(n,1),ans;\\n        for(int i = 1;i<n;i++)\\n        {\\n           if(arr[i]<=arr[i-1]) cnt++;\\n           else cnt = 1;\\n           left[i] = cnt;\\n        }\\n        cnt = 1;\\n        for(int i = n-2;i>=0;i--)\\n        {\\n            if(arr[i]<=arr[i+1]) cnt++;\\n            else cnt = 1;\\n            right[i] = cnt;\\n        }\\n        for(int i = k;i<n-k;i++)\\n        if(left[i-1]>=k && right[i+1]>=k) ans.push_back(i);\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635632,
                "title": "javascript-commented-and-explained",
                "content": "I\\'ll be happy if you can upvote <3\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar goodIndices = function(nums, k) {\\n    \\n    // We define a result for our indices and the length of the array.\\n    const res = [];\\n    const n = nums.length;\\n\\n    // We loop in the area that i is allowed to be in.\\n    for(let i = k; i < n - k; i++) {\\n        \\n        // We define two pointers. Left that will indicate the subarray before the i and right which will indicate the subarray after the i and a flag that will tell us when to add the indices to the array.\\n        let left = i - k + 1;\\n        let right = i + k - 1;\\n        let add = true;\\n        \\n        // We run while the left pointer is less than the right pointer.\\n        while(left < right) {\\n            \\n            // If the number in the left pointer is bigger than its previous, this is not a non-decreasing order.\\n            // Also, if the number in the right pointer is bigger than its number afterward, it is not a non-decreasing order.\\n            // So we will set the add boolean to false, because we can\\'t add the indices if they are non in non-decreasing order.\\n            if(nums[left] > nums[left - 1] || nums[right] > nums[right + 1]) {\\n                add = false;\\n                break;\\n            }\\n            \\n            // We also increment the left pointer and decrement the right because we want to keep moving to not get a TLE.\\n            left++;\\n            right--;\\n        }\\n        \\n        // If we can add the indices, we push them to our res array.\\n        if(add) res.push(i);\\n    }   \\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar goodIndices = function(nums, k) {\\n    \\n    // We define a result for our indices and the length of the array.\\n    const res = [];\\n    const n = nums.length;\\n\\n    // We loop in the area that i is allowed to be in.\\n    for(let i = k; i < n - k; i++) {\\n        \\n        // We define two pointers. Left that will indicate the subarray before the i and right which will indicate the subarray after the i and a flag that will tell us when to add the indices to the array.\\n        let left = i - k + 1;\\n        let right = i + k - 1;\\n        let add = true;\\n        \\n        // We run while the left pointer is less than the right pointer.\\n        while(left < right) {\\n            \\n            // If the number in the left pointer is bigger than its previous, this is not a non-decreasing order.\\n            // Also, if the number in the right pointer is bigger than its number afterward, it is not a non-decreasing order.\\n            // So we will set the add boolean to false, because we can\\'t add the indices if they are non in non-decreasing order.\\n            if(nums[left] > nums[left - 1] || nums[right] > nums[right + 1]) {\\n                add = false;\\n                break;\\n            }\\n            \\n            // We also increment the left pointer and decrement the right because we want to keep moving to not get a TLE.\\n            left++;\\n            right--;\\n        }\\n        \\n        // If we can add the indices, we push them to our res array.\\n        if(add) res.push(i);\\n    }   \\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2628263,
                "title": "python-2420-find-all-good-indices-6-lines-t-m-53-65",
                "content": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n\\n        n, down, up = len(nums), deque([1]), deque([1])\\n\\n        for i in range(1, n):\\n                down.append(1+ down[-1]*(nums[i] <= nums[i-1))\\n                up.appendleft(1+ up[0]*(nums[n-i-1] <= nums[n-i]))\\n     \\n        return [i for i in range(k, n-k) if down[i-1]>=k and up[i+1]>=k]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n\\n        n, down, up = len(nums), deque([1]), deque([1])\\n\\n        for i in range(1, n):\\n                down.append(1+ down[-1]*(nums[i] <= nums[i-1))\\n                up.appendleft(1+ up[0]*(nums[n-i-1] <= nums[n-i]))\\n     \\n        return [i for i in range(k, n-k) if down[i-1]>=k and up[i+1]>=k]",
                "codeTag": "Java"
            },
            {
                "id": 2622778,
                "title": "c-prefix-and-suffix-o-n",
                "content": "* Make two array left and right , ***initialise both array with 1*** as **array of one elements is always increasing and decreasing**\\n* left[i-1] will denote the no of elements that are **decreasing** **till index  i-1**\\n* Right[i+1] will denote no of elements that are **increasing starting from index i+1**\\n* since **index i is not included** in calculating increasing and decreasing so left[i-1] and right[i+1] is used\\n* we require **both left[i-1] and right[i+1] should be greater than k** (mentioned in question that in the left side k element should be equal or increasing and in the right side k element should be equal or increasing)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n                left[i]=left[i-1]+1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n                right[i]=right[i+1]+1;\\n        }\\n        for(int i=k;i<n-k;i++)\\n        {\\n            if(left[i-1]>=k && right[i+1]>=k)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>ans;\\n        vector<int>left(n,1),right(n,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n                left[i]=left[i-1]+1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n                right[i]=right[i+1]+1;\\n        }\\n        for(int i=k;i<n-k;i++)\\n        {\\n            if(left[i-1]>=k && right[i+1]>=k)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621573,
                "title": "c-prefix-suffix-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> left(n,1), right(n,1);\\n        for(int i = 1; i<n;++i){\\n            if(nums[i]<=nums[i-1]) left[i] = left[i-1]+1;\\n        }\\n        for(int i = n-2; i>=0;i--){\\n            if(nums[i]<=nums[i+1]) right[i] = right[i+1]+1;\\n        }\\n        vector<int> re;\\n        for(int i = k; i<n-k;++i){\\n            if(left[i-1]>=k && right[i+1]>=k) re.push_back(i);\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> left(n,1), right(n,1);\\n        for(int i = 1; i<n;++i){\\n            if(nums[i]<=nums[i-1]) left[i] = left[i-1]+1;\\n        }\\n        for(int i = n-2; i>=0;i--){\\n            if(nums[i]<=nums[i+1]) right[i] = right[i+1]+1;\\n        }\\n        vector<int> re;\\n        for(int i = k; i<n-k;++i){\\n            if(left[i-1]>=k && right[i+1]>=k) re.push_back(i);\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620807,
                "title": "c-prefix-suffix-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>pref(n,1),suff(n,1); //storing the lengths of how many elements are non-decreasing and non-increasing\\n        int cnt=1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<=nums[i-1]){\\n                pref[i]=++cnt;\\n            }\\n            else{\\n                cnt=1;\\n                pref[i]=cnt;\\n            }\\n        }\\n        cnt=1;\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]<=nums[i+1]){\\n                suff[i]=++cnt;\\n            }\\n            else{\\n                cnt=1;\\n                suff[i]=cnt;\\n            }\\n        }\\n\\n        vector<int>ans;\\n        for(int i=k;i<n-k;i++){\\n            if(pref[i-1]>=k && suff[i+1]>=k){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>pref(n,1),suff(n,1); //storing the lengths of how many elements are non-decreasing and non-increasing\\n        int cnt=1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<=nums[i-1]){\\n                pref[i]=++cnt;\\n            }\\n            else{\\n                cnt=1;\\n                pref[i]=cnt;\\n            }\\n        }\\n        cnt=1;\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]<=nums[i+1]){\\n                suff[i]=++cnt;\\n            }\\n            else{\\n                cnt=1;\\n                suff[i]=cnt;\\n            }\\n        }\\n\\n        vector<int>ans;\\n        for(int i=k;i<n-k;i++){\\n            if(pref[i-1]>=k && suff[i+1]>=k){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620556,
                "title": "c-o-n-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int a = 1,n=nums.size(),b=1;\\n        if(n%2==0 && k==n/2){\\n            return {};\\n        }\\n        for(int i=0;i<k-1;++i){\\n            if(nums[i]>=nums[i+1]){\\n                a++;\\n            }\\n        }   \\n        for(int i=k+1;i<2*k;++i){\\n            if(nums[i]<=nums[i+1]){\\n                b++;\\n            }\\n        }  \\n        vector<int> v;\\n        for(int i=k;i<n-k;++i){\\n            if(a==k && b==k){\\n                v.push_back(i);\\n            }\\n            if(nums[i-k]>=nums[i-k+1]){\\n                a--;\\n            }\\n            if(nums[i-1]>=nums[i]){\\n                a++;\\n            }\\n            if((k!=1 || i!=n-k-1) && nums[i+1]<=nums[i+2]){\\n                b--;\\n            }\\n            if(i!=n-k-1 && nums[i+k]<=nums[i+k+1]){\\n                b++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int a = 1,n=nums.size(),b=1;\\n        if(n%2==0 && k==n/2){\\n            return {};\\n        }\\n        for(int i=0;i<k-1;++i){\\n            if(nums[i]>=nums[i+1]){\\n                a++;\\n            }\\n        }   \\n        for(int i=k+1;i<2*k;++i){\\n            if(nums[i]<=nums[i+1]){\\n                b++;\\n            }\\n        }  \\n        vector<int> v;\\n        for(int i=k;i<n-k;++i){\\n            if(a==k && b==k){\\n                v.push_back(i);\\n            }\\n            if(nums[i-k]>=nums[i-k+1]){\\n                a--;\\n            }\\n            if(nums[i-1]>=nums[i]){\\n                a++;\\n            }\\n            if((k!=1 || i!=n-k-1) && nums[i+1]<=nums[i+2]){\\n                b--;\\n            }\\n            if(i!=n-k-1 && nums[i+k]<=nums[i+k+1]){\\n                b++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620522,
                "title": "python-2-pass-solution-o-n",
                "content": "```\\ndef goodIndices(self, nums: List[int], k: int) -> List[int]:\\n\\tnon_i = [1]\\n\\tfor i in range(len(nums)-1):\\n\\t\\tif nums[i]>=nums[i+1]:\\n\\t\\t\\tnon_i.append(non_i[-1]+1)\\n\\t\\telse:\\n\\t\\t\\tnon_i.append(1)\\n\\n\\tnon_d = [1]\\n\\tnums = nums[::-1]\\n\\tfor i in range(len(nums)-1):\\n\\t\\tif nums[i]>=nums[i+1]:\\n\\t\\t\\tnon_d.append(non_d[-1]+1)\\n\\t\\telse:\\n\\t\\t\\tnon_d.append(1)\\n\\tnon_d = non_d[::-1]\\n\\n\\tans = []\\n\\tfor i in range(1, len(nums)-1):\\n\\t\\tif non_i[i-1]>=k and non_d[i+1]>=k:\\n\\t\\t\\tans.append(i)\\n\\treturn ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef goodIndices(self, nums: List[int], k: int) -> List[int]:\\n\\tnon_i = [1]\\n\\tfor i in range(len(nums)-1):\\n\\t\\tif nums[i]>=nums[i+1]:\\n\\t\\t\\tnon_i.append(non_i[-1]+1)\\n\\t\\telse:\\n\\t\\t\\tnon_i.append(1)\\n\\n\\tnon_d = [1]\\n\\tnums = nums[::-1]\\n\\tfor i in range(len(nums)-1):\\n\\t\\tif nums[i]>=nums[i+1]:\\n\\t\\t\\tnon_d.append(non_d[-1]+1)\\n\\t\\telse:\\n\\t\\t\\tnon_d.append(1)\\n\\tnon_d = non_d[::-1]\\n\\n\\tans = []\\n\\tfor i in range(1, len(nums)-1):\\n\\t\\tif non_i[i-1]>=k and non_d[i+1]>=k:\\n\\t\\t\\tans.append(i)\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2620466,
                "title": "very-easy-solution-c",
                "content": "left[i]->stores maxL of non-increasing subarr ending at i-1;\\nright[i]->stores maxL of non-decrasing subarr starting at i+1;\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n       vector<int>left(n,0),right(n,0);\\n        int len=1;\\n        left[0]=0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n           left[i]=len;\\n            \\n            if(nums[i]<=nums[i-1])\\n                len++;\\n            else len=1;\\n        }\\n        \\n        right[n-1]=0;\\n        len=1;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            right[i]=len;\\n            if(nums[i]<=nums[i+1])\\n                len++;\\n            else len=1;\\n        }\\n        \\n        vector<int>ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if((left[i]>=k)&&(right[i]>=k))\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n        \\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n       vector<int>left(n,0),right(n,0);\\n        int len=1;\\n        left[0]=0;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n           left[i]=len;\\n            \\n            if(nums[i]<=nums[i-1])\\n                len++;\\n            else len=1;\\n        }\\n        \\n        right[n-1]=0;\\n        len=1;\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            right[i]=len;\\n            if(nums[i]<=nums[i+1])\\n                len++;\\n            else len=1;\\n        }\\n        \\n        vector<int>ans;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if((left[i]>=k)&&(right[i]>=k))\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n        \\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740576,
                "title": "dp-two-passes-o-n-solution",
                "content": "This solution takes an input vector nums and an integer k. It finds good indices, which are indices where there is an increasing subsequence of length at least k to the left of the index and a decreasing subsequence of length at least k to the right of the index.\\n\\nThe algorithm utilizes two additional vectors, inc and dec, to keep track of the increasing and decreasing sequences respectively. It iterates through the nums vector to populate these vectors based on the lengths of the sequences.\\n\\nFinally, the algorithm compares the corresponding elements in inc and dec vectors to identify the good indices. The indices that satisfy both conditions are stored in the res vector, which is then returned as the output of the function.\\n\\n```\\nvector<int> goodIndices(vector<int>& nums, int k) {\\n        \\n        vector<int> inc(nums.size(),0), dec(nums.size(),0) ; \\n        vector<int> res; \\n        //increasing sequence\\n        int n = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(n>=k) inc[i]=1;\\n            if(nums[i]<=nums[i-1]) n++;\\n            else n=1;\\n        }\\n       // decreasing sequence \\n        n=1;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            if(n>=k) dec[i]=1;\\n            if(nums[i]<=nums[i+1]) n++;\\n            else  n=1;\\n        }\\n        // comparision \\n        for(int i=k;i<nums.size()-k;i++)\\n            if(inc[i]==1 && dec[i]==1)res.push_back(i);\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Dynamic Programming",
                    "Iterator",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<int> goodIndices(vector<int>& nums, int k) {\\n        \\n        vector<int> inc(nums.size(),0), dec(nums.size(),0) ; \\n        vector<int> res; \\n        //increasing sequence\\n        int n = 1;\\n        for(int i=1;i<nums.size();i++){\\n            if(n>=k) inc[i]=1;\\n            if(nums[i]<=nums[i-1]) n++;\\n            else n=1;\\n        }\\n       // decreasing sequence \\n        n=1;\\n        for(int i=nums.size()-2;i>=0;i--){\\n            if(n>=k) dec[i]=1;\\n            if(nums[i]<=nums[i+1]) n++;\\n            else  n=1;\\n        }\\n        // comparision \\n        for(int i=k;i<nums.size()-k;i++)\\n            if(inc[i]==1 && dec[i]==1)res.push_back(i);\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3303754,
                "title": "c-simple-prefix-suffix",
                "content": "**Intuition**\\n- For each index, we calclute the number of non-increasing elements on left and non-decreasing elements on right in separate array `pre` and `post`\\n- Then, simply check for index `i`  if `pre` and `post` has value greater than `k` \\n\\n**Code**\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> pre(n, 1), post(n, 1);\\n        \\n        for (auto i = 1; i < n; i++)\\n            if (nums[i - 1] < nums[i]) pre[i] = 1; \\n            else pre[i] = pre[i - 1] + 1;\\n        \\n        for (auto i = n - 2; i >= 0; i--)\\n            if (nums[i + 1] < nums[i]) post[i] = 1; \\n            else post[i] = post[i + 1] + 1;\\n        \\n        vector<int> res;\\n        for (int i = k; i < n - k; i++) \\n            if (pre[i - 1] >= k && post[i + 1] >= k) \\n                res.push_back(i);\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> pre(n, 1), post(n, 1);\\n        \\n        for (auto i = 1; i < n; i++)\\n            if (nums[i - 1] < nums[i]) pre[i] = 1; \\n            else pre[i] = pre[i - 1] + 1;\\n        \\n        for (auto i = n - 2; i >= 0; i--)\\n            if (nums[i + 1] < nums[i]) post[i] = 1; \\n            else post[i] = post[i + 1] + 1;\\n        \\n        vector<int> res;\\n        for (int i = k; i < n - k; i++) \\n            if (pre[i - 1] >= k && post[i + 1] >= k) \\n                res.push_back(i);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299206,
                "title": "must-see-easy-to-understand-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) \\n    {\\n        //making the dec and inc array\\n        vector<int>dec(nums.size(),-1);\\n        vector<int>inc(nums.size(),-1);\\n\\n        //preprocessing the dec array\\n        dec[0] = 1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i] <= nums[i-1])\\n            {\\n                dec[i] = dec[i-1] + 1;\\n            }\\n            else\\n            {\\n                dec[i] = 1;\\n            }\\n        }\\n\\n        //preprocessing the inc array\\n        inc[inc.size()-1] = 1;\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            if(nums[i] <= nums[i+1])\\n            {\\n                inc[i] = inc[i+1] + 1;\\n            }\\n            else\\n            {\\n                inc[i] = 1;\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=k;i<(nums.size()-k);i++)\\n        {\\n            if(dec[i-1] >=k and inc[i+1]>=k)\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) \\n    {\\n        //making the dec and inc array\\n        vector<int>dec(nums.size(),-1);\\n        vector<int>inc(nums.size(),-1);\\n\\n        //preprocessing the dec array\\n        dec[0] = 1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i] <= nums[i-1])\\n            {\\n                dec[i] = dec[i-1] + 1;\\n            }\\n            else\\n            {\\n                dec[i] = 1;\\n            }\\n        }\\n\\n        //preprocessing the inc array\\n        inc[inc.size()-1] = 1;\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            if(nums[i] <= nums[i+1])\\n            {\\n                inc[i] = inc[i+1] + 1;\\n            }\\n            else\\n            {\\n                inc[i] = 1;\\n            }\\n        }\\n        vector<int>ans;\\n        for(int i=k;i<(nums.size()-k);i++)\\n        {\\n            if(dec[i-1] >=k and inc[i+1]>=k)\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635110,
                "title": "prefix-count-java-solution-with-o-n-memory",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> nm=new ArrayList<>();\\n        int p=nums.length;\\n        int a[]=new int[p];\\n        a[0]=1;\\n        for(int i=1;i<p;i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            {\\n                a[i]=a[i-1]+1;\\n            }\\n            else\\n            {\\n                a[i]=1;\\n            }\\n        }\\n        int b[]=new int[p];\\n        b[p-1]=1;\\n        for(int i=p-2;i>=0;i--)\\n        {\\n            if(nums[i+1]>=nums[i])\\n            {\\n                b[i]=b[i+1]+1;\\n            }\\n            else\\n            {\\n                b[i]=1;;\\n            }\\n        }\\n        for(int i=k;i<p-k;i++)\\n        {\\n            if(k<=a[i-1]&&k<=b[i+1])\\n                nm.add(i);\\n        }\\n        return nm;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> nm=new ArrayList<>();\\n        int p=nums.length;\\n        int a[]=new int[p];\\n        a[0]=1;\\n        for(int i=1;i<p;i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            {\\n                a[i]=a[i-1]+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2623881,
                "title": "java-sliding-window-o-1-space-complexity",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        boolean l = true, r = true;\\n        List<Integer> res = new ArrayList<>();\\n        if(k == 1){\\n            for(int i=1; i<nums.length-1; i++)\\n                res.add(i);\\n            return res;\\n        }\\n        if(k+k+1 > nums.length)\\n            return res;\\n        \\n        int badl = -1, badr = -1;\\n        for(int i=0; i<k-1; i++){\\n            if(nums[i] < nums[i+1]){\\n                l = false;\\n                badl = i;\\n            }\\n            if(nums[i+k+1] > nums[i+k+2]){\\n                r = false;\\n                badr = i+k+1;\\n            }\\n        }\\n        \\n        if(l && r)\\n            res.add(k);\\n        \\n        for(int i=k+1; i<nums.length-k; i++){\\n            if(nums[i-2] < nums[i-1]){\\n                l = false;\\n                badl = i-2;\\n            }else{\\n                if(!l){\\n                    int last = i-k;\\n                    if(last > badl){\\n                        l = true;\\n                    }\\n                }\\n            }\\n            \\n            if(nums[i+k] < nums[i+k-1]){\\n                r = false;\\n                badr = i+k-1;\\n            }else{\\n                if(!r){\\n                    if(i >= badr){\\n                        r = true;\\n                    }\\n                }\\n            }\\n            if(l && r)\\n                res.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        boolean l = true, r = true;\\n        List<Integer> res = new ArrayList<>();\\n        if(k == 1){\\n            for(int i=1; i<nums.length-1; i++)\\n                res.add(i);\\n            return res;\\n        }\\n        if(k+k+1 > nums.length)\\n            return res;\\n        \\n        int badl = -1, badr = -1;\\n        for(int i=0; i<k-1; i++){\\n            if(nums[i] < nums[i+1]){\\n                l = false;\\n                badl = i;\\n            }\\n            if(nums[i+k+1] > nums[i+k+2]){\\n                r = false;\\n                badr = i+k+1;\\n            }\\n        }\\n        \\n        if(l && r)\\n            res.add(k);\\n        \\n        for(int i=k+1; i<nums.length-k; i++){\\n            if(nums[i-2] < nums[i-1]){\\n                l = false;\\n                badl = i-2;\\n            }else{\\n                if(!l){\\n                    int last = i-k;\\n                    if(last > badl){\\n                        l = true;\\n                    }\\n                }\\n            }\\n            \\n            if(nums[i+k] < nums[i+k-1]){\\n                r = false;\\n                badr = i+k-1;\\n            }else{\\n                if(!r){\\n                    if(i >= badr){\\n                        r = true;\\n                    }\\n                }\\n            }\\n            if(l && r)\\n                res.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621738,
                "title": "java-brute-force-and-optimal-solutions",
                "content": "### *Please Upvote !!!* **(\\u25E0\\u203F\\u25E0)**\\n##### 1. Brute force approach (TLE)\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for (int i = k; i < nums.length - k; i++) {\\n            if (isValid(nums, k, i)) {\\n                ans.add(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public boolean isValid(int[] nums, int k, int idx){\\n        boolean before  = true;\\n        boolean after = true;\\n\\n        for (int i = idx - k + 1; i < idx ; i++) {\\n            if(nums[i] > nums[i - 1]) {\\n                before = false;\\n                break;\\n            }\\n        }\\n\\n        for (int i = idx + 1; i - k < idx; i++) {\\n            if (nums[i] > nums[i + 1]){\\n                after = false;\\n                break;\\n            }\\n        }\\n\\n        return before && after;\\n    }\\n}\\n\\n// TC: O(n * (n + n)) => O(n ^ 2)\\n// SC: O(1) - ignoring the output array\\n```\\n\\n##### 2. Optimal approach:\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n\\n        int[] p = new int[n];       // prefix array\\n        int[] s = new int[n];       // suffix array\\n\\n        p[0] = s[n - 1] = 1;\\n\\n        // precomputing for the left\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] <= nums[i - 1]) {\\n                p[i] = p[i - 1] + 1;\\n            }\\n            else p[i] = 1;\\n        }\\n\\n        // precomputing for the right\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (nums[i] <= nums[i + 1]) {\\n                s[i] = s[i + 1] + 1;\\n            }\\n            else s[i] = 1;\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for (int i = k; i < n - k; i++) {\\n            if (p[i - 1] >= k && s[i + 1] >= k) {\\n                ans.add(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n) + O(n) + O(n) => O(n)\\n// SC: O(n) + O(n) => O(n) - Ignoring the output array\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for (int i = k; i < nums.length - k; i++) {\\n            if (isValid(nums, k, i)) {\\n                ans.add(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public boolean isValid(int[] nums, int k, int idx){\\n        boolean before  = true;\\n        boolean after = true;\\n\\n        for (int i = idx - k + 1; i < idx ; i++) {\\n            if(nums[i] > nums[i - 1]) {\\n                before = false;\\n                break;\\n            }\\n        }\\n\\n        for (int i = idx + 1; i - k < idx; i++) {\\n            if (nums[i] > nums[i + 1]){\\n                after = false;\\n                break;\\n            }\\n        }\\n\\n        return before && after;\\n    }\\n}\\n\\n// TC: O(n * (n + n)) => O(n ^ 2)\\n// SC: O(1) - ignoring the output array\\n```\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n\\n        int[] p = new int[n];       // prefix array\\n        int[] s = new int[n];       // suffix array\\n\\n        p[0] = s[n - 1] = 1;\\n\\n        // precomputing for the left\\n        for (int i = 1; i < n; i++) {\\n            if (nums[i] <= nums[i - 1]) {\\n                p[i] = p[i - 1] + 1;\\n            }\\n            else p[i] = 1;\\n        }\\n\\n        // precomputing for the right\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (nums[i] <= nums[i + 1]) {\\n                s[i] = s[i + 1] + 1;\\n            }\\n            else s[i] = 1;\\n        }\\n\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for (int i = k; i < n - k; i++) {\\n            if (p[i - 1] >= k && s[i + 1] >= k) {\\n                ans.add(i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n) + O(n) + O(n) => O(n)\\n// SC: O(n) + O(n) => O(n) - Ignoring the output array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621719,
                "title": "java-solution-100-faster-using-prefix-sum",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        ArrayList<Integer> ans = new ArrayList();\\n        int n = nums.length;\\n        int suff[]=new int[n];\\n        int pre[]=new int[n];\\n        pre[0] = 1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>=nums[i-1]) pre[i] = pre[i-1] + 1;\\n            else pre[i] = 1;\\n        }\\n        suff[n-1] = 1;\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>=nums[i+1]) suff[i] = suff[i+1] + 1;\\n            else suff[i] = 1;\\n        }\\n        for(int i = k;i < n-k;i++){\\n            if(pre[i+k] >= k && suff[i-k] >= k) ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        ArrayList<Integer> ans = new ArrayList();\\n        int n = nums.length;\\n        int suff[]=new int[n];\\n        int pre[]=new int[n];\\n        pre[0] = 1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]>=nums[i-1]) pre[i] = pre[i-1] + 1;\\n            else pre[i] = 1;\\n        }\\n        suff[n-1] = 1;\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]>=nums[i+1]) suff[i] = suff[i+1] + 1;\\n            else suff[i] = 1;\\n        }\\n        for(int i = k;i < n-k;i++){\\n            if(pre[i+k] >= k && suff[i-k] >= k) ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621324,
                "title": "c-array-approach-explanation",
                "content": "\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int L=0, n = nums.size();\\n        vector<int> NI = vector<int>(n+1,1); //NI[i] is non-increasing number  with index i\\n        vector<int> ND = vector<int>(n+1,1);//ND[i] is non-descreasing number with index i\\n        nums.push_back(INT_MIN); //last element is put for processing dummy \\n\\t\\t//Step 1. figure out non-increasing number array and non-descreasing number array\\n        for(int i = 1; i<n+1;i++) {\\n            if(nums[i-1]>=nums[i]) NI[i] = NI[i-1]+1;\\n            if(nums[i-1]<=nums[i]) {\\n                ND[i] = ND[i-1]+1;\\n            } else {\\n                for(int j = L;j<=i-1;j++) ND[j] = ND[i-1] - ND[j] + 1;\\n                L = i;\\n            }\\n        }\\n\\t\\t//Step 2. Use NI & DI to collect the index that satisfy our problem.\\n        vector<int> ans;\\n        for(int i = k; i<n-k;i++) \\n            if(NI[i-1]>=k && ND[i+1]>=k) ans.push_back(i);    \\n        return ans;   \\n    }\\n};\\n```\\n\\nTime Complexity O(N)\\nSpace Complexity O(N)",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int L=0, n = nums.size();\\n        vector<int> NI = vector<int>(n+1,1); //NI[i] is non-increasing number  with index i\\n        vector<int> ND = vector<int>(n+1,1);//ND[i] is non-descreasing number with index i\\n        nums.push_back(INT_MIN); //last element is put for processing dummy \\n\\t\\t//Step 1. figure out non-increasing number array and non-descreasing number array\\n        for(int i = 1; i<n+1;i++) {\\n            if(nums[i-1]>=nums[i]) NI[i] = NI[i-1]+1;\\n            if(nums[i-1]<=nums[i]) {\\n                ND[i] = ND[i-1]+1;\\n            } else {\\n                for(int j = L;j<=i-1;j++) ND[j] = ND[i-1] - ND[j] + 1;\\n                L = i;\\n            }\\n        }\\n\\t\\t//Step 2. Use NI & DI to collect the index that satisfy our problem.\\n        vector<int> ans;\\n        for(int i = k; i<n-k;i++) \\n            if(NI[i-1]>=k && ND[i+1]>=k) ans.push_back(i);    \\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621019,
                "title": "c-easy-solutiion",
                "content": "For array - `nums = [2,1,1,1,3,4,1], k = 2`\\nFirst for every index `i` check whether `nums[i]` is greater than equal to or less than  equal to `nums[i + 1]`.\\nIt\\'ll be 1 if its true and 0 otherwise.\\n\\n```\\n\\t\\tFor non - increasing :- [1,1,1,0,0,1]\\n\\t\\tFor non - decreasing :- [0,1,1,1,1,0]\\n```\\n\\nThen calculate the continuous lengths of non - increasing substrings from left to right and for non - decreasing substrings from right to left, which will be - \\n\\n```\\n\\t\\tFor non - increasing :- [1,2,3,0,0,1]\\n\\t\\tFor non - decreasing :- [0,4,3,2,1,0]\\n```\\n\\nThen for every `i` we can check if its atleast k elements just before it are non - increasing or not and k elements just after it are non - decreasing or not.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        if (k == 1) {\\n            vector<int> ans;\\n            for (int i = 1; i < nums.size() - 1; i++)\\n                ans.push_back(i);\\n            return ans;\\n        }\\n        int n = nums.size();\\n        vector<int> nonInc(n), nonDec(n);\\n        for (int i = 0; i < n - 1; i++) {\\n            if (nums[i] >= nums[i + 1]) nonInc[i] = 1;\\n            if (nums[i] <= nums[i + 1]) nonDec[i] = 1;\\n        }\\n        \\n        for (int i = 1; i < n - 1; i++)\\n            if (nonInc[i]) nonInc[i] += nonInc[i - 1];\\n        \\n        for (int i = n - 3; i >= 0; i--)\\n            if (nonDec[i]) nonDec[i] += nonDec[i + 1];\\n        \\n        vector<int> ans;\\n        for (int i = k; i < n - k; i++)\\n            if (nonInc[i - 2] >= k - 1 and nonDec[i + 1] >= k - 1) \\n                ans.push_back(i);\\n            \\n        return ans;\\n    }\\n};\\n```\\nIf you have any doubts feel free to ask : )",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\t\\tFor non - increasing :- [1,1,1,0,0,1]\\n\\t\\tFor non - decreasing :- [0,1,1,1,1,0]\\n```\n```\\n\\t\\tFor non - increasing :- [1,2,3,0,0,1]\\n\\t\\tFor non - decreasing :- [0,4,3,2,1,0]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        if (k == 1) {\\n            vector<int> ans;\\n            for (int i = 1; i < nums.size() - 1; i++)\\n                ans.push_back(i);\\n            return ans;\\n        }\\n        int n = nums.size();\\n        vector<int> nonInc(n), nonDec(n);\\n        for (int i = 0; i < n - 1; i++) {\\n            if (nums[i] >= nums[i + 1]) nonInc[i] = 1;\\n            if (nums[i] <= nums[i + 1]) nonDec[i] = 1;\\n        }\\n        \\n        for (int i = 1; i < n - 1; i++)\\n            if (nonInc[i]) nonInc[i] += nonInc[i - 1];\\n        \\n        for (int i = n - 3; i >= 0; i--)\\n            if (nonDec[i]) nonDec[i] += nonDec[i + 1];\\n        \\n        vector<int> ans;\\n        for (int i = k; i < n - k; i++)\\n            if (nonInc[i - 2] >= k - 1 and nonDec[i + 1] >= k - 1) \\n                ans.push_back(i);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620865,
                "title": "java-sliding-window-intutive-queue",
                "content": "Time  O(N)\\nSpace O(N)\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> ls = new ArrayList<>();\\n        int n = nums.length;\\n        if (nums.length < k * 2 + 1) {\\n            return ls;\\n        }\\n        if (k == 1) {\\n            for (int i = 1; i < nums.length - 1; i++) {\\n                ls.add(i);\\n            }\\n            return ls;\\n        }\\n        \\n        //storing indices of the elements which are increasing\\n        Queue<Integer> lf = new LinkedList<>();\\n        //storing indices of the elements which are decreasing\\n        Queue<Integer> rg = new LinkedList<>();\\n        \\n        \\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            //adding the left element\\n            if (nums[i] < nums[i + 1]) {\\n                lf.add(i);\\n            }\\n            //adding the right element \\n            if (nums[i] > nums[i + 1]) {\\n                rg.add(i + 1);\\n            }\\n        }\\n        for (int idx = k; idx <= n - k - 1; idx++) {\\n            // removing elements which are not inside the window\\n            while(lf.isEmpty() == false && lf.peek() < idx - k) {\\n                lf.poll();\\n            }while(rg.isEmpty() == false && rg.peek() <= idx + 1) {\\n                rg.poll();\\n            }\\n            \\n            if((lf.isEmpty() || lf.peek() >= idx - 1) && (rg.isEmpty() || rg.peek() > idx + k)) ls.add(idx);\\n            \\n        }\\n        return ls;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> ls = new ArrayList<>();\\n        int n = nums.length;\\n        if (nums.length < k * 2 + 1) {\\n            return ls;\\n        }\\n        if (k == 1) {\\n            for (int i = 1; i < nums.length - 1; i++) {\\n                ls.add(i);\\n            }\\n            return ls;\\n        }\\n        \\n        //storing indices of the elements which are increasing\\n        Queue<Integer> lf = new LinkedList<>();\\n        //storing indices of the elements which are decreasing\\n        Queue<Integer> rg = new LinkedList<>();\\n        \\n        \\n        \\n        for (int i = 0; i < n - 1; i++) {\\n            //adding the left element\\n            if (nums[i] < nums[i + 1]) {\\n                lf.add(i);\\n            }\\n            //adding the right element \\n            if (nums[i] > nums[i + 1]) {\\n                rg.add(i + 1);\\n            }\\n        }\\n        for (int idx = k; idx <= n - k - 1; idx++) {\\n            // removing elements which are not inside the window\\n            while(lf.isEmpty() == false && lf.peek() < idx - k) {\\n                lf.poll();\\n            }while(rg.isEmpty() == false && rg.peek() <= idx + 1) {\\n                rg.poll();\\n            }\\n            \\n            if((lf.isEmpty() || lf.peek() >= idx - 1) && (rg.isEmpty() || rg.peek() > idx + k)) ls.add(idx);\\n            \\n        }\\n        return ls;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620841,
                "title": "o-n-solution-beginner-friendly",
                "content": "```cpp\\nclass Solution {\\npublic:\\n\\tvector<int> goodIndices(vector<int> &nums, int k) {\\n\\t\\tint n = nums.size();\\n\\t\\tvector<int> res, left(n), right(n);\\n\\t\\tleft[n - 1] = 1, right[0] = 1;\\n\\t\\tfor (int i = n - 2; i >= 0; i--) {\\n\\t\\t\\tif (nums[i] > nums[i + 1]) left[i] = 1;\\n\\t\\t\\telse left[i] = left[i + 1] + 1;\\n\\t\\t}\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tif (nums[i] > nums[i - 1]) right[i] = 1;\\n\\t\\t\\telse right[i] = right[i - 1] + 1;\\n\\t\\t}\\n\\t\\tfor (int i = 1; i < n - 1; i++) {\\n\\t\\t\\tif (left[i + 1] >= k && right[i - 1] >= k) {\\n\\t\\t\\t\\tres.push_back(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```\\n\\nDo consider upvoting and sharing.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n\\tvector<int> goodIndices(vector<int> &nums, int k) {\\n\\t\\tint n = nums.size();\\n\\t\\tvector<int> res, left(n), right(n);\\n\\t\\tleft[n - 1] = 1, right[0] = 1;\\n\\t\\tfor (int i = n - 2; i >= 0; i--) {\\n\\t\\t\\tif (nums[i] > nums[i + 1]) left[i] = 1;\\n\\t\\t\\telse left[i] = left[i + 1] + 1;\\n\\t\\t}\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tif (nums[i] > nums[i - 1]) right[i] = 1;\\n\\t\\t\\telse right[i] = right[i - 1] + 1;\\n\\t\\t}\\n\\t\\tfor (int i = 1; i < n - 1; i++) {\\n\\t\\t\\tif (left[i + 1] >= k && right[i - 1] >= k) {\\n\\t\\t\\t\\tres.push_back(i);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620814,
                "title": "java-solution-for-beginners",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int start[] =new int[nums.length];\\n        int end[]=new int[nums.length];\\n        start[nums.length-1]=1;\\n        for(int i=nums.length-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            {\\n                start[i]=start[i+1]+1;\\n            }\\n            else{\\n                start[i]=1;\\n            }\\n        }\\n        end[0]=1;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            {\\n                end[i]=end[i-1]+1;\\n            }\\n            else end[i]=1;\\n        }\\n        List<Integer> list=new ArrayList<>();\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            if(start[i+1]>=k && end[i-1]>=k )\\n                list.add(i);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int start[] =new int[nums.length];\\n        int end[]=new int[nums.length];\\n        start[nums.length-1]=1;\\n        for(int i=nums.length-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            {\\n                start[i]=start[i+1]+1;\\n            }\\n            else{\\n                start[i]=1;\\n            }\\n        }\\n        end[0]=1;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            {\\n                end[i]=end[i-1]+1;\\n            }\\n            else end[i]=1;\\n        }\\n        List<Integer> list=new ArrayList<>();\\n        for(int i=1;i<nums.length-1;i++)\\n        {\\n            if(start[i+1]>=k && end[i-1]>=k )\\n                list.add(i);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620709,
                "title": "easy-java-solution",
                "content": "# Find All Good Indices\\n# Easy Java Solution\\n\\n**Approach:**\\n\\n1.) We need to find if the index-k upto index is non-decreasing and index upto index+k is non-increasing\\n2.) Here, I have check these inside the for loop itself because creating different functions takes stack space and consumes time and was giving TLE\\n3.) You need to include one edge case where all elements are equal otherwise it gives a TLE\\n\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> ans=new ArrayList<Integer>();\\n        boolean flag1=true;\\n        boolean flag2=true;\\n        //If all elements are equal the return nums.length-2*k \\n        HashSet<Integer> set=new HashSet<Integer>();\\n        List<Integer> res=new ArrayList<Integer>();\\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n            if(i>=k && i<nums.length-k){\\n                res.add(i);\\n            }\\n        }\\n        if(set.size()==1){\\n            return res;\\n        }\\n        for(int i=k;i<nums.length-k;i++){\\n            flag1=true;\\n            flag2=true;\\n            //Check if index-k upto index is non-increasing\\n            for(int j=i-k;j<i-1;j++){\\n                if(nums[j]-nums[j+1]<0){\\n                    flag1=false;\\n                    break;\\n                }\\n            }\\n            //Check if index upto index+k is non-decreasing\\n            if(flag1){\\n                for(int j=i+1;j<i+k;j++){\\n                    if(nums[j]-nums[j+1]>0){\\n                        flag2=false;\\n                        break;\\n                    }\\n                }   \\n            }\\n            //If condition satisfis then add the index in list\\n            if(flag1 && flag2){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> ans=new ArrayList<Integer>();\\n        boolean flag1=true;\\n        boolean flag2=true;\\n        //If all elements are equal the return nums.length-2*k \\n        HashSet<Integer> set=new HashSet<Integer>();\\n        List<Integer> res=new ArrayList<Integer>();\\n        for(int i=0;i<nums.length;i++){\\n            set.add(nums[i]);\\n            if(i>=k && i<nums.length-k){\\n                res.add(i);\\n            }\\n        }\\n        if(set.size()==1){\\n            return res;\\n        }\\n        for(int i=k;i<nums.length-k;i++){\\n            flag1=true;\\n            flag2=true;\\n            //Check if index-k upto index is non-increasing\\n            for(int j=i-k;j<i-1;j++){\\n                if(nums[j]-nums[j+1]<0){\\n                    flag1=false;\\n                    break;\\n                }\\n            }\\n            //Check if index upto index+k is non-decreasing\\n            if(flag1){\\n                for(int j=i+1;j<i+k;j++){\\n                    if(nums[j]-nums[j+1]>0){\\n                        flag2=false;\\n                        break;\\n                    }\\n                }   \\n            }\\n            //If condition satisfis then add the index in list\\n            if(flag1 && flag2){\\n                ans.add(i);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620703,
                "title": "clean-array-reverse-solution",
                "content": "```\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        def f(left):\\n            cur = [nums[0]]\\n            left = [0 for i in range(len(nums))]\\n            for i in range(1, len(nums)):\\n                left[i] &= (len(cur) >= k)\\n                if nums[i] > cur[-1]: cur = []\\n                cur.append(nums[i])\\n\\n        left = [1 for i in range(len(nums))]\\n        f(left)\\n        nums.reverse()\\n        f(left)\\n        \\n        return [i for i in range(len(nums)) if left[i]]\\n```",
                "solutionTags": [],
                "code": "```\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        def f(left):\\n            cur = [nums[0]]\\n            left = [0 for i in range(len(nums))]\\n            for i in range(1, len(nums)):\\n                left[i] &= (len(cur) >= k)\\n                if nums[i] > cur[-1]: cur = []\\n                cur.append(nums[i])\\n\\n        left = [1 for i in range(len(nums))]\\n        f(left)\\n        nums.reverse()\\n        f(left)\\n        \\n        return [i for i in range(len(nums)) if left[i]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2620535,
                "title": "c-monotonic-stack-o-n-solution",
                "content": "/*\\nIntuition:\\nUse monotonic stack to get the next Non-increasing index and next Non-decreasing index for each element\\nThen do a loop i from k to size - k, add all index that satisify: nextNonDec[i - k] >= i && nextNonInc[i + 1] > i + k\\n*/\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        // Mono-stack\\n        int size = nums.size();\\n        vector<int> nextNonInc(size, size);\\n        vector<int> nextNonDec(size, size);\\n        \\n        stack<int> stNonInc, stNonDec;\\n        for (int i = 0; i < size; i++) {\\n            if (!stNonInc.empty() && nums[i] < nums[stNonInc.top()]) {\\n                while (!stNonInc.empty()) {\\n                    nextNonInc[stNonInc.top()] = i;\\n                    stNonInc.pop();\\n                }\\n            }\\n            stNonInc.push(i);\\n            \\n            if (!stNonDec.empty() && nums[i] > nums[stNonDec.top()]) {\\n                while (!stNonDec.empty()) {\\n                    nextNonDec[stNonDec.top()] = i;\\n                    stNonDec.pop();\\n                }\\n            }\\n            stNonDec.push(i);\\n        }\\n\\n        vector<int> ret;\\n        for (int i = k; i < size - k; i++) {\\n            if (nextNonDec[i - k] >= i && nextNonInc[i + 1] > i + k) {\\n                ret.push_back(i);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        // Mono-stack\\n        int size = nums.size();\\n        vector<int> nextNonInc(size, size);\\n        vector<int> nextNonDec(size, size);\\n        \\n        stack<int> stNonInc, stNonDec;\\n        for (int i = 0; i < size; i++) {\\n            if (!stNonInc.empty() && nums[i] < nums[stNonInc.top()]) {\\n                while (!stNonInc.empty()) {\\n                    nextNonInc[stNonInc.top()] = i;\\n                    stNonInc.pop();\\n                }\\n            }\\n            stNonInc.push(i);\\n            \\n            if (!stNonDec.empty() && nums[i] > nums[stNonDec.top()]) {\\n                while (!stNonDec.empty()) {\\n                    nextNonDec[stNonDec.top()] = i;\\n                    stNonDec.pop();\\n                }\\n            }\\n            stNonDec.push(i);\\n        }\\n\\n        vector<int> ret;\\n        for (int i = k; i < size - k; i++) {\\n            if (nextNonDec[i - k] >= i && nextNonInc[i + 1] > i + k) {\\n                ret.push_back(i);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620496,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    bool bs(const vi(ll)&v, ll i, ll j){\\n        ll l=0, r=v.size()-1;\\n        while(l<=r){\\n            ll m=l+((r-l)>>1);\\n            if(v[m]>=i && v[m]<=j){\\n                return true;\\n            }\\n            if(v[m]<i){\\n                l=m+1;\\n            }\\n            else{\\n                r=m-1;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<int> goodIndices(vector<int>&v, int k) {\\n        ll n=v.size();\\n        vi(ll)left, right;\\n        for(ll i=1;i<n;++i){\\n            if(v[i]>v[i-1]){\\n                left.pb(i);\\n            }\\n            if(v[i]<v[i-1]){\\n                right.pb(i);\\n            }\\n        }\\n        vi(int)ans;\\n        for(ll i=k;i<n-k;++i){\\n            if(!(bs(left, i-k+1, i-1) || bs(right, i+2, i+k))){\\n                ans.pb(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    bool bs(const vi(ll)&v, ll i, ll j){\\n        ll l=0, r=v.size()-1;\\n        while(l<=r){\\n            ll m=l+((r-l)>>1);\\n            if(v[m]>=i && v[m]<=j){\\n                return true;\\n            }\\n            if(v[m]<i){\\n                l=m+1;\\n            }\\n            else{\\n                r=m-1;\\n            }\\n        }\\n        return false;\\n    }\\n    vector<int> goodIndices(vector<int>&v, int k) {\\n        ll n=v.size();\\n        vi(ll)left, right;\\n        for(ll i=1;i<n;++i){\\n            if(v[i]>v[i-1]){\\n                left.pb(i);\\n            }\\n            if(v[i]<v[i-1]){\\n                right.pb(i);\\n            }\\n        }\\n        vi(int)ans;\\n        for(ll i=k;i<n-k;++i){\\n            if(!(bs(left, i-k+1, i-1) || bs(right, i+2, i+k))){\\n                ans.pb(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620458,
                "title": "java-simple-dp-solution",
                "content": "Count non-increasing order from left to right.\\nCount non-decreasing order from right to left.\\n\\nTime: O(N)\\nSpace: O(N)\\n\\n```\\nclass Solution {\\n  public List<Integer> goodIndices(int[] nums, int k) {\\n    final int n = nums.length;\\n    int[] prefix = new int[n];\\n    prefix[0] = 1;\\n    for (int i = 1; i < n; i++) {\\n      if (nums[i] <= nums[i - 1]) {\\n        prefix[i] = prefix[i - 1] + 1;\\n      } else {\\n        prefix[i] = 1;\\n      }\\n    }\\n\\n    int[] suffix = new int[n];\\n    suffix[n - 1] = 1;\\n    for (int i = n - 2; i >= 0; i--) {\\n      if (nums[i] <= nums[i + 1]) {\\n        suffix[i] = suffix[i + 1] + 1;\\n      } else {\\n        suffix[i] = 1;\\n      }\\n    }\\n\\n    List<Integer> result = new ArrayList<>();\\n    for (int i = k; i < n - k; i++) {\\n      if (prefix[i - 1] >= k && suffix[i + 1] >= k) {\\n        result.add(i);\\n      }\\n    }\\n    return result;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public List<Integer> goodIndices(int[] nums, int k) {\\n    final int n = nums.length;\\n    int[] prefix = new int[n];\\n    prefix[0] = 1;\\n    for (int i = 1; i < n; i++) {\\n      if (nums[i] <= nums[i - 1]) {\\n        prefix[i] = prefix[i - 1] + 1;\\n      } else {\\n        prefix[i] = 1;\\n      }\\n    }\\n\\n    int[] suffix = new int[n];\\n    suffix[n - 1] = 1;\\n    for (int i = n - 2; i >= 0; i--) {\\n      if (nums[i] <= nums[i + 1]) {\\n        suffix[i] = suffix[i + 1] + 1;\\n      } else {\\n        suffix[i] = 1;\\n      }\\n    }\\n\\n    List<Integer> result = new ArrayList<>();\\n    for (int i = k; i < n - k; i++) {\\n      if (prefix[i - 1] >= k && suffix[i + 1] >= k) {\\n        result.add(i);\\n      }\\n    }\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908617,
                "title": "c-simple-o-n-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k)\\n    {\\n        int n = nums.size();\\n        if(n%2==0 && 2*k==n){return {};}\\n        vector<int> l(n,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]<=nums[i-1]){l[i]=l[i-1]+1;}\\n            else{l[i]=1;}\\n        }\\n        vector<int> r(n,1);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1]){r[i]=r[i+1]+1;}\\n            else{r[i]=1;}\\n        }\\n        vector<int> ans;\\n        for(int i=k;i<n-k;i++)\\n        {\\n            if(l[i-1]>=k && r[i+1]>=k){ans.push_back(i);}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k)\\n    {\\n        int n = nums.size();\\n        if(n%2==0 && 2*k==n){return {};}\\n        vector<int> l(n,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]<=nums[i-1]){l[i]=l[i-1]+1;}\\n            else{l[i]=1;}\\n        }\\n        vector<int> r(n,1);\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1]){r[i]=r[i+1]+1;}\\n            else{r[i]=1;}\\n        }\\n        vector<int> ans;\\n        for(int i=k;i<n-k;i++)\\n        {\\n            if(l[i-1]>=k && r[i+1]>=k){ans.push_back(i);}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620150,
                "title": "python3-clean-two-sum-style",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimilar to using a $$Hashmap$$ in to store \"target num & current num\", we store all the length \"target INC index & current DEC index\".\\n\\n1. store all `k` length INC index, eg. if `k = 2`, and index[0:1] is INC, store {3: 0} in $$Hashmap$$, because you would need 2 as valley, and DEC index starting at 3\\n2. find all `k` length DEC index, eg. if index[3:4] is DEC, see if 3 is in $$Hashmap$$, if so, append index 2 to `ans[]`\\n\\n# Complexity\\n- Time complexity:\\n- \\u2705\\u231B Time complexity: $$O(N)$$\\u231B --> When k is small, you go through the `nums` list twice.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        if k == 1: \\n            return list(range(1,len(nums)-1))\\n\\n        decMap = {}\\n        decCurrInd = 0\\n        incCurrInd = k+1\\n        ans = []\\n        \\n        <!-- Save hashmap[target INC index] = DEC index -->\\n        for i in range(1, len(nums) - k - 1):\\n            if nums[i] > nums[i-1]:\\n                decCurrInd = i\\n            if i - decCurrInd + 1== k:\\n                decMap[decCurrInd+k+1] = decCurrInd\\n                decCurrInd += 1\\n\\n        <!-- Check if [target INC index] in the hashmap -->\\n        for i in range(k+2,len(nums)):\\n            if nums[i] < nums[i-1]:\\n                incCurrInd = i\\n            if i - incCurrInd + 1 == k:\\n                <!-- Append the \"valley index\" to ans -->\\n                if incCurrInd in decMap:\\n                    ans.append(incCurrInd - 1)\\n                incCurrInd += 1\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        if k == 1: \\n            return list(range(1,len(nums)-1))\\n\\n        decMap = {}\\n        decCurrInd = 0\\n        incCurrInd = k+1\\n        ans = []\\n        \\n        <!-- Save hashmap[target INC index] = DEC index -->\\n        for i in range(1, len(nums) - k - 1):\\n            if nums[i] > nums[i-1]:\\n                decCurrInd = i\\n            if i - decCurrInd + 1== k:\\n                decMap[decCurrInd+k+1] = decCurrInd\\n                decCurrInd += 1\\n\\n        <!-- Check if [target INC index] in the hashmap -->\\n        for i in range(k+2,len(nums)):\\n            if nums[i] < nums[i-1]:\\n                incCurrInd = i\\n            if i - incCurrInd + 1 == k:\\n                <!-- Append the \"valley index\" to ans -->\\n                if incCurrInd in decMap:\\n                    ans.append(incCurrInd - 1)\\n                incCurrInd += 1\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258060,
                "title": "three-pass-python-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        leftIndices=[]\\n        rightIndices=collections.deque()\\n        ref = float(\\'inf\\')\\n        init=0\\n        for i in range(0,len(nums)):\\n            if nums[i]<=ref:\\n                leftIndices.append(init)\\n            else:\\n                init=i\\n                leftIndices.append(init)\\n            ref=nums[i]\\n\\n        ref = -float(\\'inf\\')\\n        init=len(nums)-1\\n        #print(leftIndices)\\n        for i in range(len(nums)-1,-1,-1):\\n\\n            if nums[i]>ref:\\n                init=i\\n                rightIndices.appendleft(init)\\n            else:\\n                rightIndices.appendleft(init)\\n            ref = nums[i]\\n        #print(rightIndices)\\n        ans=[]\\n        for i in range(0+k,len(nums)-k):\\n            if leftIndices[i-1]<=i-k and rightIndices[i+1]>=i+k:\\n                ans.append(i)\\n\\n\\n        return ans\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        leftIndices=[]\\n        rightIndices=collections.deque()\\n        ref = float(\\'inf\\')\\n        init=0\\n        for i in range(0,len(nums)):\\n            if nums[i]<=ref:\\n                leftIndices.append(init)\\n            else:\\n                init=i\\n                leftIndices.append(init)\\n            ref=nums[i]\\n\\n        ref = -float(\\'inf\\')\\n        init=len(nums)-1\\n        #print(leftIndices)\\n        for i in range(len(nums)-1,-1,-1):\\n\\n            if nums[i]>ref:\\n                init=i\\n                rightIndices.appendleft(init)\\n            else:\\n                rightIndices.appendleft(init)\\n            ref = nums[i]\\n        #print(rightIndices)\\n        ans=[]\\n        for i in range(0+k,len(nums)-k):\\n            if leftIndices[i-1]<=i-k and rightIndices[i+1]>=i+k:\\n                ans.append(i)\\n\\n\\n        return ans\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047401,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        stack = []\\n        decre = [False] * n\\n        incre = [False] * n\\n        ans = []\\n        for i in range(n):\\n            if len(stack) >= k:\\n                decre[i] = True   \\n\\n            if not stack:\\n                stack.append(nums[i])\\n\\n            else:\\n                if nums[i] <= stack[-1]:\\n                    stack.append(nums[i])\\n                else:\\n                    stack = [nums[i]]\\n\\n        stack = []\\n        for i in range(n-1,-1,-1):\\n            if len(stack) >= k and decre[i]:\\n                ans.append(i)\\n\\n            if not stack:\\n                stack.append(nums[i])\\n\\n            else:\\n                if nums[i] <= stack[-1]:\\n                    stack.append(nums[i])\\n                else:\\n                    stack = [nums[i]]\\n        return ans[::-1]                        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        stack = []\\n        decre = [False] * n\\n        incre = [False] * n\\n        ans = []\\n        for i in range(n):\\n            if len(stack) >= k:\\n                decre[i] = True   \\n\\n            if not stack:\\n                stack.append(nums[i])\\n\\n            else:\\n                if nums[i] <= stack[-1]:\\n                    stack.append(nums[i])\\n                else:\\n                    stack = [nums[i]]\\n\\n        stack = []\\n        for i in range(n-1,-1,-1):\\n            if len(stack) >= k and decre[i]:\\n                ans.append(i)\\n\\n            if not stack:\\n                stack.append(nums[i])\\n\\n            else:\\n                if nums[i] <= stack[-1]:\\n                    stack.append(nums[i])\\n                else:\\n                    stack = [nums[i]]\\n        return ans[::-1]                        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2915311,
                "title": "easy-cpp-o-n-solution-beats-97-tc-and-90-sc",
                "content": "# Intuition\\nIt is always possible to store truth value of indices that meet the conditions of the left side and then compare them with the truth values of indices that satisfy the condition on the right side.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a bollean array \"eligible\" of size nums with all values false.\\n2. Initialize and Set p=0(p points at the index after which nums[i-1]>nums[i]).\\n3. Start iteration from i=1 to i=n-1.\\n4. Now if we find that array is following condition nums[i-1]>=nums[i] and there are atleast k elements between i and p (p inclusive but not i inclusive) then eligible[i]=true.\\n5. if nums[i-1]<nums[i] then we increment i until nums[i-1]>=nums[i] and then update p=i.\\n6. Now we traverse the array in reverse in reverse in the same way and find indices which follow the right side condition and are also true in the eligble array(good indices) and add them to ans vector.\\n7. We then return the reverse of answer vector as we need the answer in increasing order.\\n8. We have to manage edge case k==1 where all indices except 0 and n-1 are good indices.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) as we are traversing the array on the left side.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) as we are storing the truth values of indices on a array of size n.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int p=0;\\n        vector<bool> eligible(nums.size(),false);\\n        int n=nums.size();\\n        vector<int> ans;\\n        //Managing Edge case\\n        if(k==1)\\n        {\\n            for(int i=1;i<n-1;i++)ans.push_back(i);\\n            return(ans);\\n        }\\n        stack<int> temp;\\n\\n        //Iterating nums to find elements satisfying left condition\\n        for(int i=1;i<n;i++)\\n        {\\n            if(i-p>=k)eligible[i]=true;\\n            while(nums[i-1]<nums[i])\\n            {\\n                p=i;\\n                i++;\\n                if(i>=n-1)break;\\n            }\\n            \\n        }\\n        p=n-1;\\n\\n        //iterating nums in reverse to find good indices\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(p-i>=k and eligible[i])temp.push(i);\\n            while(nums[i+1]<nums[i])\\n            {\\n                p=i;\\n                i--;\\n                if(i<=0)break;\\n            }\\n        }\\n        \\n        //formatting the ans in increasing order\\n        while(!temp.empty())\\n        {\\n            ans.push_back(temp.top());\\n            temp.pop();\\n        }\\n        return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int p=0;\\n        vector<bool> eligible(nums.size(),false);\\n        int n=nums.size();\\n        vector<int> ans;\\n        //Managing Edge case\\n        if(k==1)\\n        {\\n            for(int i=1;i<n-1;i++)ans.push_back(i);\\n            return(ans);\\n        }\\n        stack<int> temp;\\n\\n        //Iterating nums to find elements satisfying left condition\\n        for(int i=1;i<n;i++)\\n        {\\n            if(i-p>=k)eligible[i]=true;\\n            while(nums[i-1]<nums[i])\\n            {\\n                p=i;\\n                i++;\\n                if(i>=n-1)break;\\n            }\\n            \\n        }\\n        p=n-1;\\n\\n        //iterating nums in reverse to find good indices\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(p-i>=k and eligible[i])temp.push(i);\\n            while(nums[i+1]<nums[i])\\n            {\\n                p=i;\\n                i--;\\n                if(i<=0)break;\\n            }\\n        }\\n        \\n        //formatting the ans in increasing order\\n        while(!temp.empty())\\n        {\\n            ans.push_back(temp.top());\\n            temp.pop();\\n        }\\n        return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730697,
                "title": "sliding-window-o-n-time-o-1-space-java",
                "content": "For each i satisfying `k <= i < n - k`, keep track of number of elements which do not satisfy before and after condition.\\n\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> res = new ArrayList<>();\\n        if(2 * k >= nums.length) return res;\\n\\n        int beforeWindowStart = 0, beforeWindowEnd = k - 1, afterWindowStart = k + 1, afterWindowEnd = k + k;\\n        int beforeCount = 0, afterCount = 0;\\n        for(int i=beforeWindowStart+1; i<=beforeWindowEnd; i++) {\\n            //keep track of number of indices which do not satisfy before condition i.e. must be non-increasing\\n            if(nums[i] > nums[i - 1]) {\\n                beforeCount++;\\n            }\\n        }\\n\\n        for(int i=afterWindowStart+1; i<=afterWindowEnd; i++) {\\n            //keep track of number of indices which do not satisfy after condition i.e. must be non-decreasing\\n            if(nums[i] < nums[i-1]) {\\n                afterCount++;\\n            }\\n        }\\n\\n        int curr = k;\\n        while (curr < nums.length - k) {\\n            // count = 0 means all elements in the respective windows meet the requirement\\n            if(beforeCount == 0 && afterCount == 0) {\\n                res.add(curr);\\n            }\\n\\n            if(curr == nums.length - k - 1) {\\n                break;\\n            }\\n\\n            /*\\n                Update before window.\\n                If element being deleted from window didn\\'t satisfy before condition decrement beforeCount.\\n                If element being added to the window doesn\\'t satisfy before condition increment beforeCount.\\n             */\\n            if(nums[beforeWindowStart + 1] > nums[beforeWindowStart]) {\\n                beforeCount--;\\n            }\\n            beforeWindowStart++;\\n\\n            if(nums[beforeWindowEnd + 1] > nums[beforeWindowEnd]) {\\n                beforeCount++;\\n            }\\n            beforeWindowEnd++;\\n\\n\\n            /*\\n                Update after window.\\n                If element being deleted from window didn\\'t satisfy after condition decrement afterCount.\\n                If element being added to the window doesn\\'t satisfy after condition increment afterCount.\\n             */\\n            if(nums[afterWindowStart + 1] < nums[afterWindowStart]) {\\n                afterCount--;\\n            }\\n            afterWindowStart++;\\n\\n            if(nums[afterWindowEnd + 1] < nums[afterWindowEnd]) {\\n                afterCount++;\\n            }\\n            afterWindowEnd++;\\n\\n            curr++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> res = new ArrayList<>();\\n        if(2 * k >= nums.length) return res;\\n\\n        int beforeWindowStart = 0, beforeWindowEnd = k - 1, afterWindowStart = k + 1, afterWindowEnd = k + k;\\n        int beforeCount = 0, afterCount = 0;\\n        for(int i=beforeWindowStart+1; i<=beforeWindowEnd; i++) {\\n            //keep track of number of indices which do not satisfy before condition i.e. must be non-increasing\\n            if(nums[i] > nums[i - 1]) {\\n                beforeCount++;\\n            }\\n        }\\n\\n        for(int i=afterWindowStart+1; i<=afterWindowEnd; i++) {\\n            //keep track of number of indices which do not satisfy after condition i.e. must be non-decreasing\\n            if(nums[i] < nums[i-1]) {\\n                afterCount++;\\n            }\\n        }\\n\\n        int curr = k;\\n        while (curr < nums.length - k) {\\n            // count = 0 means all elements in the respective windows meet the requirement\\n            if(beforeCount == 0 && afterCount == 0) {\\n                res.add(curr);\\n            }\\n\\n            if(curr == nums.length - k - 1) {\\n                break;\\n            }\\n\\n            /*\\n                Update before window.\\n                If element being deleted from window didn\\'t satisfy before condition decrement beforeCount.\\n                If element being added to the window doesn\\'t satisfy before condition increment beforeCount.\\n             */\\n            if(nums[beforeWindowStart + 1] > nums[beforeWindowStart]) {\\n                beforeCount--;\\n            }\\n            beforeWindowStart++;\\n\\n            if(nums[beforeWindowEnd + 1] > nums[beforeWindowEnd]) {\\n                beforeCount++;\\n            }\\n            beforeWindowEnd++;\\n\\n\\n            /*\\n                Update after window.\\n                If element being deleted from window didn\\'t satisfy after condition decrement afterCount.\\n                If element being added to the window doesn\\'t satisfy after condition increment afterCount.\\n             */\\n            if(nums[afterWindowStart + 1] < nums[afterWindowStart]) {\\n                afterCount--;\\n            }\\n            afterWindowStart++;\\n\\n            if(nums[afterWindowEnd + 1] < nums[afterWindowEnd]) {\\n                afterCount++;\\n            }\\n            afterWindowEnd++;\\n\\n            curr++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660081,
                "title": "dp-approach-java-solution",
                "content": "# Brute force (TLE)\\n```java\\nclass Solution {\\n    boolean isValid(int nums[],int idx,int k){\\n        for(int i = idx - k + 1;i < idx;i++){\\n            if(nums[i] > nums[i - 1]) return false;\\n        }\\n        for(int i = idx + 2;i < idx + k + 1;i++){\\n            if(nums[i] < nums[i - 1]) return false;\\n        }\\n        return true;\\n    }\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        if(nums.length < 2 * k + 1) return new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = k;i < nums.length - k;i++){\\n            if(isValid(nums,i,k)) ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n# DP (Accepted)\\n```java\\npublic List<Integer> goodIndices(int[] nums, int k) {\\n        if(nums.length < 2 * k + 1) return new ArrayList<>();\\n        int dp_ni[] = new int[nums.length];\\n        dp_ni[0] = 1;\\n        for(int i = 1;i < nums.length;i++){\\n            if(nums[i] <= nums[i - 1]) dp_ni[i] = dp_ni[i - 1] + 1;\\n            else dp_ni[i] = 1;\\n        }\\n        \\n        int dp_nd[] = new int[nums.length];\\n        dp_nd[nums.length - 1] = 1;\\n        for(int i = nums.length - 2;i >= 0;--i){\\n            if(nums[i] <= nums[i + 1]) dp_nd[i] = dp_nd[i + 1] + 1;\\n            else dp_nd[i] = 1;\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = k;i < nums.length - k;i++){\\n            if(dp_ni[i - 1] >= k && dp_nd[i + 1] >= k) ans.add(i);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nclass Solution {\\n    boolean isValid(int nums[],int idx,int k){\\n        for(int i = idx - k + 1;i < idx;i++){\\n            if(nums[i] > nums[i - 1]) return false;\\n        }\\n        for(int i = idx + 2;i < idx + k + 1;i++){\\n            if(nums[i] < nums[i - 1]) return false;\\n        }\\n        return true;\\n    }\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        if(nums.length < 2 * k + 1) return new ArrayList<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = k;i < nums.length - k;i++){\\n            if(isValid(nums,i,k)) ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\npublic List<Integer> goodIndices(int[] nums, int k) {\\n        if(nums.length < 2 * k + 1) return new ArrayList<>();\\n        int dp_ni[] = new int[nums.length];\\n        dp_ni[0] = 1;\\n        for(int i = 1;i < nums.length;i++){\\n            if(nums[i] <= nums[i - 1]) dp_ni[i] = dp_ni[i - 1] + 1;\\n            else dp_ni[i] = 1;\\n        }\\n        \\n        int dp_nd[] = new int[nums.length];\\n        dp_nd[nums.length - 1] = 1;\\n        for(int i = nums.length - 2;i >= 0;--i){\\n            if(nums[i] <= nums[i + 1]) dp_nd[i] = dp_nd[i + 1] + 1;\\n            else dp_nd[i] = 1;\\n        }\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        for(int i = k;i < nums.length - k;i++){\\n            if(dp_ni[i - 1] >= k && dp_nd[i + 1] >= k) ans.add(i);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642747,
                "title": "python-o-n-simple-solution-using-two-lists",
                "content": "```\\ndef goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        \\n        prefix, suffix = [1] * len(nums), [1] * len(nums)\\n        \\n        for i in range(1, len(prefix)):\\n            prefix[i] = prefix[i-1] + 1 if nums[i] <= nums[i-1] else 1\\n        \\n        for i in range(len(suffix)-2, -1, -1):\\n            suffix[i] = suffix[i+1] + 1 if nums[i] <= nums[i+1] else 1\\n        \\n        res = [i for i in range(k, len(nums)-k) if prefix[i-1] >= k and suffix[i+1] >= k]\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        \\n        prefix, suffix = [1] * len(nums), [1] * len(nums)\\n        \\n        for i in range(1, len(prefix)):\\n            prefix[i] = prefix[i-1] + 1 if nums[i] <= nums[i-1] else 1\\n        \\n        for i in range(len(suffix)-2, -1, -1):\\n            suffix[i] = suffix[i+1] + 1 if nums[i] <= nums[i+1] else 1\\n        \\n        res = [i for i in range(k, len(nums)-k) if prefix[i-1] >= k and suffix[i+1] >= k]\\n        \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2638875,
                "title": "python-o-n-using-prefix-and-suffix-arrays",
                "content": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        sz, res = len(nums), []\\n        prefix, suffix = [0] * sz, [0] * sz\\n        prefix[0], suffix[sz - 1] = 1, 1\\n        for i in range(1, sz):\\n            if nums[i] <= nums[i - 1]:\\n                prefix[i] = prefix[i - 1] + 1\\n            else:\\n                prefix[i] = 1\\n        for i in range(sz - 2, -1, -1):\\n            if nums[i] <= nums[i + 1]:\\n                suffix[i] = suffix[i + 1] + 1\\n            else:\\n                suffix[i] = 1\\n        for i in range(k, sz - k):\\n            if prefix[i - 1] >= k and suffix[i + 1] >= k:\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        sz, res = len(nums), []\\n        prefix, suffix = [0] * sz, [0] * sz\\n        prefix[0], suffix[sz - 1] = 1, 1\\n        for i in range(1, sz):\\n            if nums[i] <= nums[i - 1]:\\n                prefix[i] = prefix[i - 1] + 1\\n            else:\\n                prefix[i] = 1\\n        for i in range(sz - 2, -1, -1):\\n            if nums[i] <= nums[i + 1]:\\n                suffix[i] = suffix[i + 1] + 1\\n            else:\\n                suffix[i] = 1\\n        for i in range(k, sz - k):\\n            if prefix[i - 1] >= k and suffix[i + 1] >= k:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630666,
                "title": "rust-17-ms-fastest-100-solution-symmetric-iterators-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/809785306/) employs symmetric (from left&right) iterators (using dynamic dispatch) to invalidate bad indices in two passes. It demonstrated **17 ms runtime (100.00%)** and used **3.5 MB memory (88.89%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    // [a] this function is used to check both conditions:\\n    // - non-increasing from the left\\n    // - non-increasing from the right (i.e., non-decreasing from the left)\\n    pub fn filter_indices(nums: &Vec<i32>, idx_status: &mut Vec<bool>, k: i32, rev: bool)\\n    {\\n        let mut prev_num = 100000;\\n        let mut counter = 0;\\n        \\n        // [b] normal and reverse iterators in Rust have different\\n        //     static types, thus, we use dynamic dispatch\\n        let it: Box<dyn Iterator<Item=(usize,&i32)>> = \\n            if rev { Box::new(nums.iter().enumerate().rev()) }\\n            else   { Box::new(nums.iter().enumerate()) };\\n        \\n        // [c] iterate from either of ends and count length\\n        //     of good sequences in order to drop bad indices\\n        for (i, &n) in it\\n        {\\n            if counter < k { idx_status[i] = false; }\\n            \\n            if n <= prev_num { counter += 1; }\\n            else             { counter = 1; }\\n            \\n            prev_num = n;\\n        }\\n    }\\n    \\n    pub fn good_indices(nums: Vec<i32>, k: i32) -> Vec<i32> \\n    {\\n        // [0] trivial case\\n        if k == 1 { return (1..nums.len() as i32 - 1).collect(); }\\n        \\n        // [1] initialize with all indices being good\\n        let mut idx_status = vec![true;nums.len()];\\n        \\n        // [2] first, filter \\'good non-increasing\\' indices\\n        Solution::filter_indices(&nums, &mut idx_status, k, false);\\n\\n        // [3] second, filter \\'good non-decrasing\\' indices\\n        Solution::filter_indices(&nums, &mut idx_status, k, true);\\n        \\n        // [4] return only good indices\\n        idx_status.iter()\\n            .enumerate()\\n            .filter(|&x| *x.1)\\n            .map(|x| x.0 as i32)\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    // [a] this function is used to check both conditions:\\n    // - non-increasing from the left\\n    // - non-increasing from the right (i.e., non-decreasing from the left)\\n    pub fn filter_indices(nums: &Vec<i32>, idx_status: &mut Vec<bool>, k: i32, rev: bool)\\n    {\\n        let mut prev_num = 100000;\\n        let mut counter = 0;\\n        \\n        // [b] normal and reverse iterators in Rust have different\\n        //     static types, thus, we use dynamic dispatch\\n        let it: Box<dyn Iterator<Item=(usize,&i32)>> = \\n            if rev { Box::new(nums.iter().enumerate().rev()) }\\n            else   { Box::new(nums.iter().enumerate()) };\\n        \\n        // [c] iterate from either of ends and count length\\n        //     of good sequences in order to drop bad indices\\n        for (i, &n) in it\\n        {\\n            if counter < k { idx_status[i] = false; }\\n            \\n            if n <= prev_num { counter += 1; }\\n            else             { counter = 1; }\\n            \\n            prev_num = n;\\n        }\\n    }\\n    \\n    pub fn good_indices(nums: Vec<i32>, k: i32) -> Vec<i32> \\n    {\\n        // [0] trivial case\\n        if k == 1 { return (1..nums.len() as i32 - 1).collect(); }\\n        \\n        // [1] initialize with all indices being good\\n        let mut idx_status = vec![true;nums.len()];\\n        \\n        // [2] first, filter \\'good non-increasing\\' indices\\n        Solution::filter_indices(&nums, &mut idx_status, k, false);\\n\\n        // [3] second, filter \\'good non-decrasing\\' indices\\n        Solution::filter_indices(&nums, &mut idx_status, k, true);\\n        \\n        // [4] return only good indices\\n        idx_status.iter()\\n            .enumerate()\\n            .filter(|&x| *x.1)\\n            .map(|x| x.0 as i32)\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2626720,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Precalculation***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // left[i] will store the length of increasing subarray starting from nums[i] on left side\\n        \\n        vector<int> left(n, 1);\\n        \\n        // fill left array\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] <= nums[i - 1])\\n            {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n        \\n        // right[i] will store the length of increasing subarray starting from nums[i] on right side\\n        \\n        vector<int> right(n, 1);\\n        \\n        // fill right array\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            if(nums[i] <= nums[i + 1])\\n            {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n        \\n        // find the possible res\\n        \\n        vector<int> res;\\n        \\n        for(int i = k; i <= n - k - 1; i++)\\n        {\\n            if(left[i - 1] >= k && right[i + 1] >= k)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // left[i] will store the length of increasing subarray starting from nums[i] on left side\\n        \\n        vector<int> left(n, 1);\\n        \\n        // fill left array\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] <= nums[i - 1])\\n            {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n        \\n        // right[i] will store the length of increasing subarray starting from nums[i] on right side\\n        \\n        vector<int> right(n, 1);\\n        \\n        // fill right array\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            if(nums[i] <= nums[i + 1])\\n            {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n        \\n        // find the possible res\\n        \\n        vector<int> res;\\n        \\n        for(int i = k; i <= n - k - 1; i++)\\n        {\\n            if(left[i - 1] >= k && right[i + 1] >= k)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625625,
                "title": "implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    void f(vector<int> &nums, int k, int res[], int n, int flag) {\\n        int st = 0;\\n        int i=1;\\n         while(i < nums.size()) {\\n            if(i >= st+k) {\\n                int z = flag ? n-1-i : i;\\n                res[z]+=1;\\n            }\\n            if(nums[i] > nums[i-1]) {\\n                st = i;\\n            }\\n            i++;\\n        }\\n    }\\n    \\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int res[n+1];\\n        memset(res,0,sizeof(res));\\n        f(nums, k, res, n, 0);\\n        reverse(nums.begin(), nums.end());\\n        f(nums, k, res, n, 1);\\n        vector<int> ss;\\n        for(int i=0;i<n;++i){\\n            if(res[i]==2)ss.push_back(i);\\n        }\\n        return ss;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(vector<int> &nums, int k, int res[], int n, int flag) {\\n        int st = 0;\\n        int i=1;\\n         while(i < nums.size()) {\\n            if(i >= st+k) {\\n                int z = flag ? n-1-i : i;\\n                res[z]+=1;\\n            }\\n            if(nums[i] > nums[i-1]) {\\n                st = i;\\n            }\\n            i++;\\n        }\\n    }\\n    \\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int res[n+1];\\n        memset(res,0,sizeof(res));\\n        f(nums, k, res, n, 0);\\n        reverse(nums.begin(), nums.end());\\n        f(nums, k, res, n, 1);\\n        vector<int> ss;\\n        for(int i=0;i<n;++i){\\n            if(res[i]==2)ss.push_back(i);\\n        }\\n        return ss;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624350,
                "title": "python-prefix",
                "content": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        non_inc, non_des = [1]*n, [1]*n\\n        for i in range(1, n):\\n            if nums[i]<=nums[i-1]:\\n                non_inc[i] = non_inc[i-1]+1\\n            if nums[n-i-1]<=nums[n-i]:\\n                non_des[n-i-1] = non_des[n-i]+1\\n        return [i for i in range(k, n-k) if non_inc[i-1]>=k and non_des[i+1]>=k]",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        non_inc, non_des = [1]*n, [1]*n\\n        for i in range(1, n):\\n            if nums[i]<=nums[i-1]:\\n                non_inc[i] = non_inc[i-1]+1\\n            if nums[n-i-1]<=nums[n-i]:\\n                non_des[n-i-1] = non_des[n-i]+1\\n        return [i for i in range(k, n-k) if non_inc[i-1]>=k and non_des[i+1]>=k]",
                "codeTag": "Java"
            },
            {
                "id": 2624145,
                "title": "o-n-tc-o-1-space-no-dp-sliding-window-2-pointers-java",
                "content": "Maintain 2 pointers:-\\n1. left_breaker:- record the first index on the left (within the window) that breakes the property\\n2. right_breaker:- record the rightmost index (within the window) that breaks the property.\\n\\nJust slide through the window & update the breaker pointers. If no breaker pointers within the window, its a good index. Add it to the solution.\\n\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        \\n        int left_breaker=-1;\\n        int right_breaker=nums.length;\\n        List<Integer> good=new ArrayList<Integer>();\\n        if(nums.length< 2*k +1)\\n            return good;\\n        for(int i=k-1;i>0;i--){\\n            if(nums[i-1]<nums[i]){\\n                left_breaker=i;\\n                i=-1;\\n            }\\n         }\\n        int count=1;\\n        for(int i=k+1;count<k && i<nums.length;i++,count++){\\n            if(nums[i]>nums[i+1]){\\n                right_breaker=i;\\n            }\\n        }\\n        \\n        if(left_breaker==-1 && right_breaker==nums.length )\\n            good.add(k);\\n        \\n        for(int i=k+1;i<nums.length-k;i++){\\n            if(k==1){\\n                good.add(i);\\n                continue;\\n            }\\n                \\n            if(nums[i-2]<nums[i-1])\\n                left_breaker=i-1;\\n             if(nums[i+k-1]>nums[i+k])\\n                right_breaker=i+k-1;\\n            if(left_breaker> i-k || (right_breaker< i+k && right_breaker>i ))\\n                continue;\\n            right_breaker=nums.length;\\n            left_breaker=-1;\\n            good.add(i);\\n            \\n        }\\n        return good;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        \\n        int left_breaker=-1;\\n        int right_breaker=nums.length;\\n        List<Integer> good=new ArrayList<Integer>();\\n        if(nums.length< 2*k +1)\\n            return good;\\n        for(int i=k-1;i>0;i--){\\n            if(nums[i-1]<nums[i]){\\n                left_breaker=i;\\n                i=-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2623795,
                "title": "python-3-sliding-window-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        if k + k == n:\\n            return []\\n\\n        notGoodBefore = notGoodAfter = 0\\n        for i in range(k - 1):\\n            if nums[i] < nums[i + 1]:\\n                notGoodBefore += 1\\n        \\n        for i in range(k + 1, k + k):\\n            if nums[i] > nums[i + 1]:\\n                notGoodAfter += 1\\n        \\n        res = []\\n        if (not notGoodBefore) and (not notGoodAfter):\\n            res.append(k)\\n\\n        for i in range(k + 1, n - k):\\n            if nums[i - k - 1] < nums[i - k]:\\n                notGoodBefore -= 1\\n            if nums[i - 2] < nums[i - 1]:\\n                notGoodBefore += 1\\n            if nums[i] > nums[i + 1]:\\n                notGoodAfter -= 1\\n            if nums[i + k - 1] > nums[i + k]:\\n                notGoodAfter += 1\\n            \\n            if (not notGoodBefore) and (not notGoodAfter):\\n                res.append(i)\\n            \\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        if k + k == n:\\n            return []\\n\\n        notGoodBefore = notGoodAfter = 0\\n        for i in range(k - 1):\\n            if nums[i] < nums[i + 1]:\\n                notGoodBefore += 1\\n        \\n        for i in range(k + 1, k + k):\\n            if nums[i] > nums[i + 1]:\\n                notGoodAfter += 1\\n        \\n        res = []\\n        if (not notGoodBefore) and (not notGoodAfter):\\n            res.append(k)\\n\\n        for i in range(k + 1, n - k):\\n            if nums[i - k - 1] < nums[i - k]:\\n                notGoodBefore -= 1\\n            if nums[i - 2] < nums[i - 1]:\\n                notGoodBefore += 1\\n            if nums[i] > nums[i + 1]:\\n                notGoodAfter -= 1\\n            if nums[i + k - 1] > nums[i + k]:\\n                notGoodAfter += 1\\n            \\n            if (not notGoodBefore) and (not notGoodAfter):\\n                res.append(i)\\n            \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2623334,
                "title": "python-prefix-and-suffix-o-n",
                "content": "\\n\\n    def goodIndices(self, nums, k):\\n\\t\\n        n = len(nums)\\n        if k*2+1 > n : return []\\n        else :\\n            ans = [] \\n            nonde = [0 for _ in range(n)]\\n            nonin = [0 for _ in range(n)]\\n            cur = nums[0]\\n            nonde[0] = 1 \\n            for i in range(1,n-k) :\\n                if cur >= nums[i] :\\n                    nonde[i] = nonde[i-1]+1\\n        \\n                else :\\n                    nonde[i] = 1 \\n                cur = nums[i]\\n                    \\n            cur = nums[n-1]\\n            nonin[n-1] = 1 \\n            for i in range(n-2,k,-1) :\\n                if cur >= nums[i] :\\n                    nonin[i] = nonin[i+1]+1\\n                else :\\n                    nonin[i] = 1 \\n                cur = nums[i]\\n            \\n       \\n            \\n            for i in range(k,n-k) :\\n                \\n                if nonde[i-1] >= k and nonin[i+1] >= k : \\n                    ans += [i]\\n            return ans",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\\n\\n    def goodIndices(self, nums, k):\\n\\t\\n        n = len(nums)\\n        if k*2+1 > n : return []\\n        else :\\n            ans = [] \\n            nonde = [0 for _ in range(n)]\\n            nonin = [0 for _ in range(n)]\\n            cur = nums[0]\\n            nonde[0] = 1 \\n            for i in range(1,n-k) :\\n                if cur >= nums[i] :\\n                    nonde[i] = nonde[i-1]+1\\n        \\n                else :\\n                    nonde[i] = 1 \\n                cur = nums[i]\\n                    \\n            cur = nums[n-1]\\n            nonin[n-1] = 1 \\n            for i in range(n-2,k,-1) :\\n                if cur >= nums[i] :\\n                    nonin[i] = nonin[i+1]+1\\n                else :\\n                    nonin[i] = 1 \\n                cur = nums[i]\\n            \\n       \\n            \\n            for i in range(k,n-k) :\\n                \\n                if nonde[i-1] >= k and nonin[i+1] >= k : \\n                    ans += [i]\\n            return ans",
                "codeTag": "Python3"
            },
            {
                "id": 2623110,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) preprocess the input to reduce the asymptotic bounds to O(1) per `i`<sup>th</sup> index candidate in the range `K` inclusive to `N - K` non-incusive, ie. we track the \"run length\" of adjacent values of the input array `A` in non-strictly descending and ascending order from `L`eft-to-right and `R`ight-to-left correspondingly.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun goodIndices(A: IntArray, K: Int): List<Int> {\\n        var N = A.size\\n        var L = IntArray(N) { 1 }\\n        var R = IntArray(N) { 1 }\\n        for (i in 1 until N)\\n            L[i] = 1 + if (A[i - 1] >= A[i]) L[i - 1] else 0\\n        for (j in N - 2 downTo 0)\\n            R[j] = 1 + if (A[j] <= A[j + 1]) R[j + 1] else 0\\n        return IntArray(N - 2 * K){ it }.map{ it + K }.filter{ K <= L[it - 1] && K <= R[it + 1] }\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet goodIndices = (A, K, N = A.length, L = Array(N).fill(1), R = Array(N).fill(1)) => {\\n    for (let i = 1; i < N; ++i)\\n        L[i] = 1 + (A[i - 1] >= A[i] ? L[i - 1] : 0);\\n    for (let j = N - 2; 0 <= j; --j)\\n        R[j] = 1 + (A[j] <= A[j + 1] ? R[j + 1] : 0);\\n    return [...Array(N - 2 * K).keys()].map(i => i + K).filter(i => K <= L[i - 1] && K <= R[i + 1]);\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def goodIndices(self, A: List[int], K: int) -> List[int]:\\n        ans = []\\n        N = len(A)\\n        L = [1] * N\\n        R = [1] * N\\n        for i in range(1, N):\\n            L[i] = 1 + (L[i - 1] if A[i - 1] >= A[i] else 0)\\n        for j in range(N - 2, -1, -1):\\n            R[j] = 1 + (R[j + 1] if A[j] <= A[j + 1] else 0)\\n        return [i for i in range(K, N - K) if K <= L[i - 1] and K <= R[i + 1]]\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn good_indices(A: VI, K: i32) -> VI {\\n        let N = A.len();\\n        let K = K as usize;\\n        let mut L = vec![1; N];\\n        let mut R = vec![1; N];\\n        for i in 1..N {\\n            L[i] = 1 + if A[i - 1] >= A[i] { L[i - 1] } else { 0 };\\n        }\\n        for j in (0..N - 1).rev() {\\n            R[j] = 1 + if A[j] <= A[j + 1] { R[j + 1] } else { 0 };\\n        }\\n        (K..N - K).filter(|i| K <= L[i - 1] && K <= R[i + 1]).map(|i| i as i32).collect::<VI>()\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI goodIndices(VI& A, int K, VI ans = {}) {\\n        int N = A.size();\\n        VI L(N, 1),\\n           R(N, 1);\\n        for (auto i{ 1 }; i < N; ++i)\\n            L[i] = 1 + (A[i - 1] >= A[i] ? L[i - 1] : 0);\\n        for (auto j{ N - 2 }; 0 <= j; --j)\\n            R[j] = 1 + (A[j] <= A[j + 1] ? R[j + 1] : 0);\\n        for (auto i{ K }; i < N - K; ++i)\\n            if (K <= L[i - 1] && K <= R[i + 1])\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun goodIndices(A: IntArray, K: Int): List<Int> {\\n        var N = A.size\\n        var L = IntArray(N) { 1 }\\n        var R = IntArray(N) { 1 }\\n        for (i in 1 until N)\\n            L[i] = 1 + if (A[i - 1] >= A[i]) L[i - 1] else 0\\n        for (j in N - 2 downTo 0)\\n            R[j] = 1 + if (A[j] <= A[j + 1]) R[j + 1] else 0\\n        return IntArray(N - 2 * K){ it }.map{ it + K }.filter{ K <= L[it - 1] && K <= R[it + 1] }\\n    }\\n}\\n```\n```\\nlet goodIndices = (A, K, N = A.length, L = Array(N).fill(1), R = Array(N).fill(1)) => {\\n    for (let i = 1; i < N; ++i)\\n        L[i] = 1 + (A[i - 1] >= A[i] ? L[i - 1] : 0);\\n    for (let j = N - 2; 0 <= j; --j)\\n        R[j] = 1 + (A[j] <= A[j + 1] ? R[j + 1] : 0);\\n    return [...Array(N - 2 * K).keys()].map(i => i + K).filter(i => K <= L[i - 1] && K <= R[i + 1]);\\n};\\n```\n```\\nclass Solution:\\n    def goodIndices(self, A: List[int], K: int) -> List[int]:\\n        ans = []\\n        N = len(A)\\n        L = [1] * N\\n        R = [1] * N\\n        for i in range(1, N):\\n            L[i] = 1 + (L[i - 1] if A[i - 1] >= A[i] else 0)\\n        for j in range(N - 2, -1, -1):\\n            R[j] = 1 + (R[j + 1] if A[j] <= A[j + 1] else 0)\\n        return [i for i in range(K, N - K) if K <= L[i - 1] and K <= R[i + 1]]\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn good_indices(A: VI, K: i32) -> VI {\\n        let N = A.len();\\n        let K = K as usize;\\n        let mut L = vec![1; N];\\n        let mut R = vec![1; N];\\n        for i in 1..N {\\n            L[i] = 1 + if A[i - 1] >= A[i] { L[i - 1] } else { 0 };\\n        }\\n        for j in (0..N - 1).rev() {\\n            R[j] = 1 + if A[j] <= A[j + 1] { R[j + 1] } else { 0 };\\n        }\\n        (K..N - K).filter(|i| K <= L[i - 1] && K <= R[i + 1]).map(|i| i as i32).collect::<VI>()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI goodIndices(VI& A, int K, VI ans = {}) {\\n        int N = A.size();\\n        VI L(N, 1),\\n           R(N, 1);\\n        for (auto i{ 1 }; i < N; ++i)\\n            L[i] = 1 + (A[i - 1] >= A[i] ? L[i - 1] : 0);\\n        for (auto j{ N - 2 }; 0 <= j; --j)\\n            R[j] = 1 + (A[j] <= A[j + 1] ? R[j + 1] : 0);\\n        for (auto i{ K }; i < N - K; ++i)\\n            if (K <= L[i - 1] && K <= R[i + 1])\\n                ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622866,
                "title": "javascript-prefix-sum-array",
                "content": "```\\nvar goodIndices = function(nums, k) {\\n    const N = nums.length;\\n    const nonIncreasing = Array(N).fill(1);\\n    for(let i = 1; i < N; i++) {\\n        if(nums[i] <= nums[i-1]) {\\n            nonIncreasing[i] = 1 + nonIncreasing[i-1];\\n        }\\n    }\\n    \\n    const nonDecreasing = Array(N).fill(1);\\n    for(let i = N-2; i >= 0; i--) {\\n        if(nums[i] <= nums[i+1]) {\\n            nonDecreasing[i] = 1 + nonDecreasing[i+1];\\n        }\\n    }\\n\\n    const result = [];\\n    for(let i = k; i <= N - k; i++) {\\n        if(nonIncreasing[i-1] >= k && nonDecreasing[i+1] >= k) {\\n            result.push(i);\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar goodIndices = function(nums, k) {\\n    const N = nums.length;\\n    const nonIncreasing = Array(N).fill(1);\\n    for(let i = 1; i < N; i++) {\\n        if(nums[i] <= nums[i-1]) {\\n            nonIncreasing[i] = 1 + nonIncreasing[i-1];\\n        }\\n    }\\n    \\n    const nonDecreasing = Array(N).fill(1);\\n    for(let i = N-2; i >= 0; i--) {\\n        if(nums[i] <= nums[i+1]) {\\n            nonDecreasing[i] = 1 + nonDecreasing[i+1];\\n        }\\n    }\\n\\n    const result = [];\\n    for(let i = k; i <= N - k; i++) {\\n        if(nonIncreasing[i-1] >= k && nonDecreasing[i+1] >= k) {\\n            result.push(i);\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2622313,
                "title": "javascript-dynamic-programming",
                "content": "**Solution: Dynamic Programming**\\n\\nCompare adjacent numbers and populate `left` and `right`, where\\n  `left[i] = length of non-increasing subarray ending at index i`\\n  `right[i] = length of non-decreasing subarray starting at index i`\\n\\nGood indices have `left[i - 1] >= k` and `right[i + 1] >= k`.\\n\\nTime Complexity: `O(n)` 272ms\\nSpace Complexity: `O(n)` 62.6MB\\n```\\nvar goodIndices = function(nums, k) {\\n  let n = nums.length, left = Array(n).fill(1);\\n  for (let i = 1; i < n; i++) {\\n    if (nums[i] <= nums[i - 1]) {\\n      left[i] += left[i - 1];\\n    }\\n  }\\n  let right = Array(n).fill(1);\\n  for (let i = n - 2; i >= 0; i--) {\\n    if (nums[i] <= nums[i + 1]) {\\n      right[i] += right[i + 1];\\n    }\\n  }\\n  \\n  let goodIndices = [];\\n  for (let i = k; i < n - k; i++) {\\n    if (left[i - 1] >= k && right[i + 1] >= k) {\\n      goodIndices.push(i);\\n    }\\n  }\\n  return goodIndices;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar goodIndices = function(nums, k) {\\n  let n = nums.length, left = Array(n).fill(1);\\n  for (let i = 1; i < n; i++) {\\n    if (nums[i] <= nums[i - 1]) {\\n      left[i] += left[i - 1];\\n    }\\n  }\\n  let right = Array(n).fill(1);\\n  for (let i = n - 2; i >= 0; i--) {\\n    if (nums[i] <= nums[i + 1]) {\\n      right[i] += right[i + 1];\\n    }\\n  }\\n  \\n  let goodIndices = [];\\n  for (let i = k; i < n - k; i++) {\\n    if (left[i - 1] >= k && right[i + 1] >= k) {\\n      goodIndices.push(i);\\n    }\\n  }\\n  return goodIndices;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621583,
                "title": "python3-two-o-n-passes-to-build-the-candidate-sets-and-find-intersection",
                "content": "The basic idea is figuring out which element meets the condition going from left and going from right and construct two sets to save them separately, then the final result is the intersection of these two sets. We have a variable to count how many non-increasing/non-decreasing elements before we meet each element. If this variable is larger than or equal to k, we add the current element to the set. \\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        if n < 2*k+1: return []\\n        \\n\\t\\t# Non-increasing set from left\\n        dcur = 1\\n        dcands = set()\\n        for i in range(1, n-k):\\n            if dcur >= k:\\n                dcands.add(i)\\n            if nums[i] <= nums[i-1]:\\n                dcur += 1\\n            else:\\n                dcur = 1\\n\\n\\t\\t# Non-decreasing set from right\\n        icur = 1\\n        icands = set()\\n        for i in range(n-2, k-1, -1):\\n            if icur >= k:\\n                icands.add(i)\\n            if nums[i] <= nums[i+1]:\\n                icur += 1\\n            else:\\n                icur = 1\\n                \\n        res = list(dcands.intersection(icands))\\n        \\n        res.sort()\\n        \\n        return res",
                "solutionTags": [],
                "code": "The basic idea is figuring out which element meets the condition going from left and going from right and construct two sets to save them separately, then the final result is the intersection of these two sets. We have a variable to count how many non-increasing/non-decreasing elements before we meet each element. If this variable is larger than or equal to k, we add the current element to the set. \\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        if n < 2*k+1: return []\\n        \\n\\t\\t# Non-increasing set from left\\n        dcur = 1\\n        dcands = set()\\n        for i in range(1, n-k):\\n            if dcur >= k:\\n                dcands.add(i)\\n            if nums[i] <= nums[i-1]:\\n                dcur += 1\\n            else:\\n                dcur = 1\\n\\n\\t\\t# Non-decreasing set from right\\n        icur = 1\\n        icands = set()\\n        for i in range(n-2, k-1, -1):\\n            if icur >= k:\\n                icands.add(i)\\n            if nums[i] <= nums[i+1]:\\n                icur += 1\\n            else:\\n                icur = 1\\n                \\n        res = list(dcands.intersection(icands))\\n        \\n        res.sort()\\n        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2621430,
                "title": "easy-c-sliding-window-and-dp-approaches-solutions",
                "content": "**Sliding window Solution :**\\n```\\nvector<int> goodIndices(vector<int>& a, int k) {\\n        int n=a.size();\\n        int lpos=k,rpos=k;\\n        vector<int>ans;\\n        if(n<=2*k)\\n            return ans;\\n        if(k==1){\\n            for(int i=k;i<n-k;i++){\\n                ans.push_back(i);\\n            }\\n            return ans;\\n        }\\n        for(int i=1;i<k;i++){\\n            if(a[i]>a[i-1]){\\n                lpos=i+k;\\n            }\\n        }\\n        \\n        for(int i=k+1;i<=k+k;i++){\\n            if(a[i]<a[i-1]){\\n                rpos=i-1;\\n            }\\n        }\\n        if(rpos<=k&&lpos<=k){\\n            ans.push_back(k);\\n        }\\n        for(int i=k+1;i<n-k;i++){\\n            if(a[i-1]>a[i-2]){\\n                lpos=i-1+k;\\n            }\\n            if(a[i+k]<a[i+k-1]){\\n                rpos=i+k-1;\\n            }\\n            if(lpos<=i&&rpos<=i){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n**DP Solution Using Prefix And Suffix**\\n\\n```\\nvector<int> goodIndices(vector<int>& a, int k) {\\n        int n=a.size();\\n        vector<int>prefix(n,0),suffix(n,0),ans;\\n        prefix[0]=1;\\n        suffix[n-1]=1;\\n        for(int i=1;i<n;i++){\\n            if(a[i-1]>=a[i]){\\n                prefix[i]=prefix[i-1]+1;\\n            }\\n            else{\\n                prefix[i]=1;\\n            }\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(a[i]<=a[i+1]){\\n                suffix[i]=suffix[i+1]+1;\\n            }\\n            else{\\n                suffix[i]=1;\\n            }\\n        }\\n        for(int i=k;i<n-k;i++){\\n            if(prefix[i-1]>=k&&suffix[i+1]>=k)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n\\t\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Sliding Window",
                    "Suffix Array"
                ],
                "code": "```\\nvector<int> goodIndices(vector<int>& a, int k) {\\n        int n=a.size();\\n        int lpos=k,rpos=k;\\n        vector<int>ans;\\n        if(n<=2*k)\\n            return ans;\\n        if(k==1){\\n            for(int i=k;i<n-k;i++){\\n                ans.push_back(i);\\n            }\\n            return ans;\\n        }\\n        for(int i=1;i<k;i++){\\n            if(a[i]>a[i-1]){\\n                lpos=i+k;\\n            }\\n        }\\n        \\n        for(int i=k+1;i<=k+k;i++){\\n            if(a[i]<a[i-1]){\\n                rpos=i-1;\\n            }\\n        }\\n        if(rpos<=k&&lpos<=k){\\n            ans.push_back(k);\\n        }\\n        for(int i=k+1;i<n-k;i++){\\n            if(a[i-1]>a[i-2]){\\n                lpos=i-1+k;\\n            }\\n            if(a[i+k]<a[i+k-1]){\\n                rpos=i+k-1;\\n            }\\n            if(lpos<=i&&rpos<=i){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2621177,
                "title": "prefix-sum-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int> v1(nums.size(),1),v2(nums.size(),1);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1]>=nums[i])\\n            {\\n                v1[i]=v1[i-1]+1;\\n            }\\n        }\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            if(nums[i+1]>=nums[i])\\n            {\\n                v2[i]=v2[i+1]+1;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=k;i<nums.size()-k;i++)\\n        {\\n            if(v1[i-1]>=k&&v2[i+1]>=k)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int> v1(nums.size(),1),v2(nums.size(),1);\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i-1]>=nums[i])\\n            {\\n                v1[i]=v1[i-1]+1;\\n            }\\n        }\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            if(nums[i+1]>=nums[i])\\n            {\\n                v2[i]=v2[i+1]+1;\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i=k;i<nums.size()-k;i++)\\n        {\\n            if(v1[i-1]>=k&&v2[i+1]>=k)\\n            {\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621070,
                "title": "fix-size-sliding-window-easy-solution-c-constant-space-one-scan",
                "content": "This is sliding window problem .\\nComplexity O(N);\\nspace complexity O(1)\\nComment if there is something  wrong or to improve this solution \\nPlease Vote my solution if it is helpful to you\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        // n is size of array \\n        int win=k+k+1;\\n        // win is tatol window size that we need to cover to answer the index because there should be k\\n\\t\\t//element in left of index and k element in right of index\\n        //there are two part of window  left part from p1 to p2 and right part from f1 to f2\\n\\t\\t// if left part is correct and right part is correct then this window is valid \\n        if(win>n) return {};\\n        // if(win>n) this is the case where no of element in array is less than window size the we needed\\n        // so return empty array \\n        int p1=0,p2=0,f1=k+1,f2=k+1;\\n        // p1 is 1st pointer of left window p2 is last pointer of left window same for f1,f2 for right window\\n        vector<int> ans;\\n        // if k ==1 this is kind of base case where we have to push all value of i from k to n-k\\n        if(k==1)\\n        {\\n            for(int i=k;i<n-k;i++)\\n            {\\n                ans.push_back(i);\\n            }\\n            return ans;\\n        }\\n        \\n        while(f2<n)\\n        {\\n           \\n             if(f2-p1+1==win)\\n            {\\n            // here window size is full \\n               if(nums[p2-1]>=nums[p2] && nums[f2-1]<=nums[f2])\\n                {\\n                    // here we get ans anwer \\n                    ans.push_back(p2+1);\\n                    p1++;f1++;\\n                    \\n                }\\n                else\\n                {\\n                    // window size is full but conditions not satisfied so need to shrink window by moving p1,f1 pointer \\n                    if(nums[p2-1]<nums[p2])\\n                    {\\n                        //if this is the case means problem in left part \\n                        p1=p2;\\n                        f1=f2;\\n                    }\\n                    else\\n                    {\\n                        // problem in right part so shrink the window \\n                        f1=f2;\\n                        p1=p2;\\n                    }\\n                }\\n                 p2++,f2++;\\n                \\n            }\\n            else\\n            {\\n                if(p2==0)\\n                {\\n                    // here means we are on 1st element of array so no need to check at p2-1 because this the 1st element to increase window\\n                }\\n                else if(nums[p2-1]>=nums[p2] && nums[f2-1]<=nums[f2])\\n                {\\n                    // conditions satisfied so incease window size only \\n                }\\n                else\\n                { \\n                    // here coditions fails so move p1,f1 as well \\n                    if(nums[p2-1]<nums[p2])\\n                    {\\n                        p1=p2;\\n                        f1=f2;\\n                    }\\n                    else\\n                    {\\n                        f1=f2;\\n                        p1=p2;\\n                    }\\n                }\\n                 p2++,f2++;\\n                \\n            }\\n           \\n            \\n          \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\nPlease Vote \\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        // n is size of array \\n        int win=k+k+1;\\n        // win is tatol window size that we need to cover to answer the index because there should be k\\n\\t\\t//element in left of index and k element in right of index\\n        //there are two part of window  left part from p1 to p2 and right part from f1 to f2\\n\\t\\t// if left part is correct and right part is correct then this window is valid \\n        if(win>n) return {};\\n        // if(win>n) this is the case where no of element in array is less than window size the we needed\\n        // so return empty array \\n        int p1=0,p2=0,f1=k+1,f2=k+1;\\n        // p1 is 1st pointer of left window p2 is last pointer of left window same for f1,f2 for right window\\n        vector<int> ans;\\n        // if k ==1 this is kind of base case where we have to push all value of i from k to n-k\\n        if(k==1)\\n        {\\n            for(int i=k;i<n-k;i++)\\n            {\\n                ans.push_back(i);\\n            }\\n            return ans;\\n        }\\n        \\n        while(f2<n)\\n        {\\n           \\n             if(f2-p1+1==win)\\n            {\\n            // here window size is full \\n               if(nums[p2-1]>=nums[p2] && nums[f2-1]<=nums[f2])\\n                {\\n                    // here we get ans anwer \\n                    ans.push_back(p2+1);\\n                    p1++;f1++;\\n                    \\n                }\\n                else\\n                {\\n                    // window size is full but conditions not satisfied so need to shrink window by moving p1,f1 pointer \\n                    if(nums[p2-1]<nums[p2])\\n                    {\\n                        //if this is the case means problem in left part \\n                        p1=p2;\\n                        f1=f2;\\n                    }\\n                    else\\n                    {\\n                        // problem in right part so shrink the window \\n                        f1=f2;\\n                        p1=p2;\\n                    }\\n                }\\n                 p2++,f2++;\\n                \\n            }\\n            else\\n            {\\n                if(p2==0)\\n                {\\n                    // here means we are on 1st element of array so no need to check at p2-1 because this the 1st element to increase window\\n                }\\n                else if(nums[p2-1]>=nums[p2] && nums[f2-1]<=nums[f2])\\n                {\\n                    // conditions satisfied so incease window size only \\n                }\\n                else\\n                { \\n                    // here coditions fails so move p1,f1 as well \\n                    if(nums[p2-1]<nums[p2])\\n                    {\\n                        p1=p2;\\n                        f1=f2;\\n                    }\\n                    else\\n                    {\\n                        f1=f2;\\n                        p1=p2;\\n                    }\\n                }\\n                 p2++,f2++;\\n                \\n            }\\n           \\n            \\n          \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620962,
                "title": "2420-find-all-good-indices",
                "content": "**Go through the code very easy to understand**\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n       int n=nums.size(); \\n\\t   // left and right array to store window size of decreasing arrays\\n        vector<int>left(n),right(n); \\n//  Example -> 2,1,1,1,3,4,1\\n//  left ->        1,2,3,4,1,1,2     from start\\n//  right->       1,1,2,3,4,5,1    from back\\n\\n        left[0]=1; \\n        for(int i=1;i<nums.size();i++){ \\n            if(nums[i]<=nums[i-1]){ \\n                left[i]=left[i-1]+1; \\n            }else{ \\n                left[i]=1; \\n            } \\n        } \\n        \\n        right[n-1] = 1; \\n        for(int i=nums.size()-2;i>=0;i--){ \\n            if(nums[i]<=nums[i+1]){ \\n                right[i]=right[i+1]+1; \\n            }else{ \\n                right[i]=1; \\n            } \\n        } \\n        \\n        vector<int>ans; \\n        for(int i=1;i<nums.size()-1;i++){ \\n\\t\\t// if greater than>=k of both left and right include in ans\\n            if(right[i+1]>=k && left[i-1]>=k){ \\n                ans.push_back(i); \\n            } \\n        } \\n        return ans; \\n    }\\n};\\n```\\n**Upvote and give your feedback**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n       int n=nums.size(); \\n\\t   // left and right array to store window size of decreasing arrays\\n        vector<int>left(n),right(n); \\n//  Example -> 2,1,1,1,3,4,1\\n//  left ->        1,2,3,4,1,1,2     from start\\n//  right->       1,1,2,3,4,5,1    from back\\n\\n        left[0]=1; \\n        for(int i=1;i<nums.size();i++){ \\n            if(nums[i]<=nums[i-1]){ \\n                left[i]=left[i-1]+1; \\n            }else{ \\n                left[i]=1; \\n            } \\n        } \\n        \\n        right[n-1] = 1; \\n        for(int i=nums.size()-2;i>=0;i--){ \\n            if(nums[i]<=nums[i+1]){ \\n                right[i]=right[i+1]+1; \\n            }else{ \\n                right[i]=1; \\n            } \\n        } \\n        \\n        vector<int>ans; \\n        for(int i=1;i<nums.size()-1;i++){ \\n\\t\\t// if greater than>=k of both left and right include in ans\\n            if(right[i+1]>=k && left[i-1]>=k){ \\n                ans.push_back(i); \\n            } \\n        } \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620916,
                "title": "easy-o-n-prefex-suffix-based-python-solution",
                "content": "At every index we want to know if the number of descending prefix elements >= k and number of ascending suffix elements >= k. So we preprocess this info and use it to find the correct indices.\\n\\nUpvote if you like the logic :)\\n\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        if len(nums) <= 2 * k:\\n            return []\\n\\n        pref = [0] * len(nums)\\n        suff = [0] * len(nums)\\n        count = 0\\n\\t\\t\\n\\t\\t# descending order\\n        for i in range(len(nums)):\\n            pref[i] = count\\n            if i != 0 and nums[i] <= nums[i - 1]:\\n                count += 1\\n            else:\\n                count = 1\\n\\n        count = 0\\n\\t\\t# ascending order\\n        for j in range(len(nums) - 1, -1, -1):\\n            suff[j] = count\\n            if j != len(nums) - 1 and nums[j] <= nums[j + 1]:\\n                count += 1\\n            else:\\n                count = 1\\n\\n        ans = []\\n\\n        for i in range(len(suff)):\\n            if pref[i] >= k and suff[i] >= k:\\n                ans.append(i)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        if len(nums) <= 2 * k:\\n            return []\\n\\n        pref = [0] * len(nums)\\n        suff = [0] * len(nums)\\n        count = 0\\n\\t\\t\\n\\t\\t# descending order\\n        for i in range(len(nums)):\\n            pref[i] = count\\n            if i != 0 and nums[i] <= nums[i - 1]:\\n                count += 1\\n            else:\\n                count = 1\\n\\n        count = 0\\n\\t\\t# ascending order\\n        for j in range(len(nums) - 1, -1, -1):\\n            suff[j] = count\\n            if j != len(nums) - 1 and nums[j] <= nums[j + 1]:\\n                count += 1\\n            else:\\n                count = 1\\n\\n        ans = []\\n\\n        for i in range(len(suff)):\\n            if pref[i] >= k and suff[i] >= k:\\n                ans.append(i)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620911,
                "title": "one-pass-with-monotonic-queue-java",
                "content": "Maintain two monotonic queues containing indices of nums such that: For the iteration of i-th element in array, we have:\\n1. left queue contains index j in range [i - k, i - 1], and the correspoinding value in  in left queue is non-increasing\\n2. right queue contains index j\\' in range [i + 1, i + k], and the correspoinding value in right queue is non-decreasing\\n3. check if the sizes of both left and right queues equal to k\\n\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> result = new ArrayList<>();\\n        if (2 * k >= nums.length) return result;\\n        \\n        ArrayDeque<Integer> left = new ArrayDeque<>();\\n        ArrayDeque<Integer> right = new ArrayDeque<>();\\n        \\n        // construct left queue\\n        for (int i = 0; i < k; i++) {\\n            while (left.size() > 0 && nums[left.peekLast()] < nums[i]) {\\n                left.pollLast();\\n            }\\n            left.addLast(i);\\n        }\\n        \\n        // construct right queue\\n        for (int i = k + 1; i < 2 * k + 1; i++) {\\n            while (right.size() > 0 && nums[right.peekLast()] > nums[i]) {\\n                right.pollLast();\\n            }\\n            right.addLast(i);\\n        }\\n        \\n        \\n        for (int i = k; i < nums.length - k; i++) {\\n            if (left.size() == k && right.size() == k) {\\n                result.add(i);\\n            }\\n            if (left.size() > 0 && left.peekFirst() == i - k) left.pollFirst();\\n            while (left.size() > 0 && nums[left.peekLast()] < nums[i]) {\\n                left.pollLast();\\n            }\\n            left.addLast(i);\\n            \\n            if (i + k + 1 < nums.length) {\\n                if (right.size() > 0 && right.peekFirst() == i + 1) right.pollFirst();\\n                while (right.size() > 0 && nums[right.peekLast()] > nums[i + k + 1]) {\\n                    right.pollLast();\\n                }\\n                right.addLast(i + k + 1);    \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> result = new ArrayList<>();\\n        if (2 * k >= nums.length) return result;\\n        \\n        ArrayDeque<Integer> left = new ArrayDeque<>();\\n        ArrayDeque<Integer> right = new ArrayDeque<>();\\n        \\n        // construct left queue\\n        for (int i = 0; i < k; i++) {\\n            while (left.size() > 0 && nums[left.peekLast()] < nums[i]) {\\n                left.pollLast();\\n            }\\n            left.addLast(i);\\n        }\\n        \\n        // construct right queue\\n        for (int i = k + 1; i < 2 * k + 1; i++) {\\n            while (right.size() > 0 && nums[right.peekLast()] > nums[i]) {\\n                right.pollLast();\\n            }\\n            right.addLast(i);\\n        }\\n        \\n        \\n        for (int i = k; i < nums.length - k; i++) {\\n            if (left.size() == k && right.size() == k) {\\n                result.add(i);\\n            }\\n            if (left.size() > 0 && left.peekFirst() == i - k) left.pollFirst();\\n            while (left.size() > 0 && nums[left.peekLast()] < nums[i]) {\\n                left.pollLast();\\n            }\\n            left.addLast(i);\\n            \\n            if (i + k + 1 < nums.length) {\\n                if (right.size() > 0 && right.peekFirst() == i + 1) right.pollFirst();\\n                while (right.size() > 0 && nums[right.peekLast()] > nums[i + k + 1]) {\\n                    right.pollLast();\\n                }\\n                right.addLast(i + k + 1);    \\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620828,
                "title": "java-easy-prefix-array-suffix-array-with-explanation",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int prefix[]=new int[nums.length];\\n        int suffix[]=new int[nums.length];\\n        prefix[0]=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<=nums[i-1]) /*Here we are scanning from left to right and we are checking \\n\\t\\t\\t                         if the current element is smaller than or equal to the previous element then \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t we are updating prefix array count of that element to previous element longest \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t decreasing +1 .  If its the first longest decreasing then we update it to 1 in prefix array.*/\\n                prefix[i]=prefix[i-1]+1;\\n            else\\n                prefix[i]=1;\\n        }\\n        suffix[nums.length-1]=1;\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i+1]>=nums[i]) /*Here we are scanning from right to left and we are checking \\n\\t\\t\\t                         if the next element is greater than or equal to the current element then \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t we are updating suffix array count of that element to previous element \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t longest increasing +1 . If its the first longest increasing then we update it \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t to 1 in suffix array.*/\\n                suffix[i]=suffix[i+1]+1;\\n            else\\n                suffix[i]=1;\\n        }\\n        List<Integer> li=new ArrayList<>();\\n        for(int i=k;i<nums.length-k;i++){\\n            if(prefix[i-1]>=k && suffix[i+1]>=k)\\n                li.add(i);\\n        }\\n        return li;\\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int prefix[]=new int[nums.length];\\n        int suffix[]=new int[nums.length];\\n        prefix[0]=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<=nums[i-1]) /*Here we are scanning from left to right and we are checking \\n\\t\\t\\t                         if the current element is smaller than or equal to the previous element then \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t we are updating prefix array count of that element to previous element longest \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t decreasing +1 .  If its the first longest decreasing then we update it to 1 in prefix array.*/\\n                prefix[i]=prefix[i-1]+1;\\n            else\\n                prefix[i]=1;\\n        }\\n        suffix[nums.length-1]=1;\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i+1]>=nums[i]) /*Here we are scanning from right to left and we are checking \\n\\t\\t\\t                         if the next element is greater than or equal to the current element then \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t we are updating suffix array count of that element to previous element \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t longest increasing +1 . If its the first longest increasing then we update it \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t to 1 in suffix array.*/\\n                suffix[i]=suffix[i+1]+1;\\n            else\\n                suffix[i]=1;\\n        }\\n        List<Integer> li=new ArrayList<>();\\n        for(int i=k;i<nums.length-k;i++){\\n            if(prefix[i-1]>=k && suffix[i+1]>=k)\\n                li.add(i);\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620727,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n        int len = nums.length;\\n        int[] fwd = new int[len];\\n        int[] back = new int[len];\\n        fwd[0] = 1;\\n        back[len-1]=1;\\n        for(int i=1;i<len;i++) {\\n            if(nums[i] > nums[i-1])\\n                fwd[i] = 1;\\n            else\\n                fwd[i] = fwd[i-1] + 1;\\n        }\\n        \\n        for(int i=len-2;i>=0;i--) {\\n            if(nums[i+1] < nums[i])\\n                back[i] = 1;\\n            else\\n                back[i] = back[i+1] + 1;\\n        }\\n\\n        for(int i=k;i<len-k;i++) {\\n            if(fwd[i-1] >=k && back[i+1] >=k)\\n                ans.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> ans = new ArrayList<>();\\n        int len = nums.length;\\n        int[] fwd = new int[len];\\n        int[] back = new int[len];\\n        fwd[0] = 1;\\n        back[len-1]=1;\\n        for(int i=1;i<len;i++) {\\n            if(nums[i] > nums[i-1])\\n                fwd[i] = 1;\\n            else\\n                fwd[i] = fwd[i-1] + 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2620679,
                "title": "c-prefix-suffix",
                "content": "```\\n    public IList<int> GoodIndices(int[] nums, int k) \\n    {\\n        int n = nums.Length;\\n\\n        int[] leftDecreasing = new int[n];\\n        int[] rightIcreasing = new int[n];\\n        leftDecreasing[0] = 1;\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (nums[i] <= nums[i - 1])\\n                leftDecreasing[i] = leftDecreasing[i - 1] + 1;\\n            else\\n                leftDecreasing[i] = 1;\\n        }\\n\\n        rightIcreasing[n - 1] = 1;\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            if (nums[i] <= nums[i + 1])\\n                rightIcreasing[i] = rightIcreasing[i + 1] + 1;\\n            else\\n                rightIcreasing[i] = 1;\\n        }\\n\\n        IList<int> result = new List<int>();\\n        for (int i = 1; i < n - 1; i++)\\n        {\\n            if (leftDecreasing[i - 1] >= k && rightIcreasing[i + 1] >= k)\\n            {\\n                result.Add(i);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<int> GoodIndices(int[] nums, int k) \\n    {\\n        int n = nums.Length;\\n\\n        int[] leftDecreasing = new int[n];\\n        int[] rightIcreasing = new int[n];\\n        leftDecreasing[0] = 1;\\n        for (int i = 1; i < n; i++)\\n        {\\n            if (nums[i] <= nums[i - 1])\\n                leftDecreasing[i] = leftDecreasing[i - 1] + 1;\\n            else\\n                leftDecreasing[i] = 1;\\n        }\\n\\n        rightIcreasing[n - 1] = 1;\\n        for (int i = n - 2; i >= 0; i--)\\n        {\\n            if (nums[i] <= nums[i + 1])\\n                rightIcreasing[i] = rightIcreasing[i + 1] + 1;\\n            else\\n                rightIcreasing[i] = 1;\\n        }\\n\\n        IList<int> result = new List<int>();\\n        for (int i = 1; i < n - 1; i++)\\n        {\\n            if (leftDecreasing[i - 1] >= k && rightIcreasing[i + 1] >= k)\\n            {\\n                result.Add(i);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620673,
                "title": "index-of-non-increasing-and-non-decreasing",
                "content": "1. Find the ending index of non-increasing subarray of length k : ```inc```\\n1. Find the starting index of non-decreasing subarray of length k: ```dec```\\n1. traverse from range(k,n-k): \\n\\tif ```i-1``` in ```inc``` and ```i+1``` in ```dec```:\\n\\t\\tadd ```i``` to your ```res```\\n\\treturn ```res```\\n\\t\\n```\\nclass Solution:\\n    def goodIndices(self, A: List[int], k: int) -> List[int]:\\n        \\n        if k==1:\\n            return [i for i in range(1,len(A)-1)]\\n        n = len(A)\\n        c = 1\\n        inc = []\\n        for i in range(1,n):\\n            if A[i-1]>=A[i]:\\n                c += 1\\n            else:\\n                c = 1\\n            if c>=k:\\n                inc.append(i)\\n        dec =[]\\n        for i in range(1,n)[::-1]:\\n            if A[i-1]<=A[i]:\\n                c += 1\\n            else:\\n                c = 1\\n            if c>=k:\\n                dec.append(i-1) \\n        dec = set(dec) \\n        inc = set(inc) \\n        # print(inc) \\n        # print(dec)\\n        res =[]\\n        for i in range(k,n-k):\\n            if i-1 in inc and i+1 in dec:\\n                res.append(i)\\n        return res\\n```\\n\\n\\n**UPVOTE FOR HUSTLE CODING**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```inc```\n```dec```\n```i-1```\n```inc```\n```i+1```\n```dec```\n```i```\n```res```\n```res```\n```\\nclass Solution:\\n    def goodIndices(self, A: List[int], k: int) -> List[int]:\\n        \\n        if k==1:\\n            return [i for i in range(1,len(A)-1)]\\n        n = len(A)\\n        c = 1\\n        inc = []\\n        for i in range(1,n):\\n            if A[i-1]>=A[i]:\\n                c += 1\\n            else:\\n                c = 1\\n            if c>=k:\\n                inc.append(i)\\n        dec =[]\\n        for i in range(1,n)[::-1]:\\n            if A[i-1]<=A[i]:\\n                c += 1\\n            else:\\n                c = 1\\n            if c>=k:\\n                dec.append(i-1) \\n        dec = set(dec) \\n        inc = set(inc) \\n        # print(inc) \\n        # print(dec)\\n        res =[]\\n        for i in range(k,n-k):\\n            if i-1 in inc and i+1 in dec:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620638,
                "title": "c-beginner-friendly-easy-approach-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int>leftmx(n), rightmx(n);\\n        rightmx[n - 1] = 1;\\n        leftmx[0] = 1;\\n        for(int i = n - 2; i >=0; i--){\\n            if(nums[i] <= nums[i + 1])\\n                rightmx[i] = rightmx[i + 1] + 1;\\n            else rightmx[i] = 1; \\n        }\\n        for(int i = 1; i < n - 1; i++){\\n            if(nums[i] <= nums[i - 1])\\n                leftmx[i] = leftmx[i - 1] + 1;\\n            else leftmx[i] = 1;\\n        }\\n        vector<int>ans;\\n        for(int i = 1; i < n - 1; i++){\\n            if(i >= k){\\n                if(rightmx[i + 1]>=k and leftmx[i - 1] >= k)\\n                    ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int>leftmx(n), rightmx(n);\\n        rightmx[n - 1] = 1;\\n        leftmx[0] = 1;\\n        for(int i = n - 2; i >=0; i--){\\n            if(nums[i] <= nums[i + 1])\\n                rightmx[i] = rightmx[i + 1] + 1;\\n            else rightmx[i] = 1; \\n        }\\n        for(int i = 1; i < n - 1; i++){\\n            if(nums[i] <= nums[i - 1])\\n                leftmx[i] = leftmx[i - 1] + 1;\\n            else leftmx[i] = 1;\\n        }\\n        vector<int>ans;\\n        for(int i = 1; i < n - 1; i++){\\n            if(i >= k){\\n                if(rightmx[i + 1]>=k and leftmx[i - 1] >= k)\\n                    ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620624,
                "title": "python-sliding-window-tle-dp-ac",
                "content": "### Sliding Window (TLE) \\n### Time: O(n*k)\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        if len(nums) < (2*k) + 1: return []\\n        if k == 1:\\n            return [i for i in range(1,len(nums)-1)]\\n        \\n        length = (2*k)+1\\n        res = []\\n        \\n        for i in range(len(nums)-length+1):\\n            left = i\\n            right = left + length - 1\\n            isValid = True\\n            \\n            for j in range(k-1):\\n                if nums[left] >= nums[left+1] and nums[right] >= nums[right-1]:\\n                    left += 1\\n                    right -= 1\\n                else:\\n                    isValid = False \\n                    break\\n            \\n            if isValid:\\n                res.append(i+k)\\n        \\n        return res\\n```\\n### Dynamic Programming  \\n### Time: O(n)\\n```\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        if len(nums) < (2*k) + 1: return []\\n        if k == 1:\\n            return [i for i in range(1,len(nums)-1)]\\n        \\n        inc, dec = [1] * len(nums), [1] * len(nums)\\n        res = []\\n        \\n        for i in range(1, len(nums)):\\n            if nums[i] <= nums[i-1]:\\n                dec[i] = dec[i-1] + 1\\n        \\n        for i in range(len(nums)-2, -1, -1):\\n            if nums[i] <= nums[i+1]:\\n                inc[i] = inc[i+1] + 1\\n        \\n        for i in range(1, len(nums)-1):\\n            if dec[i-1] >= k and inc[i+1] >= k:\\n                res.append(i)\\n                \\n        return res",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        if len(nums) < (2*k) + 1: return []\\n        if k == 1:\\n            return [i for i in range(1,len(nums)-1)]\\n        \\n        length = (2*k)+1\\n        res = []\\n        \\n        for i in range(len(nums)-length+1):\\n            left = i\\n            right = left + length - 1\\n            isValid = True\\n            \\n            for j in range(k-1):\\n                if nums[left] >= nums[left+1] and nums[right] >= nums[right-1]:\\n                    left += 1\\n                    right -= 1\\n                else:\\n                    isValid = False \\n                    break\\n            \\n            if isValid:\\n                res.append(i+k)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620607,
                "title": "c-prefix-suffix-array-clean-code-video-solution",
                "content": "**Video Solution :** \\n\\nhttps://www.youtube.com/watch?v=ERjqE8VJbvg\\n\\n**Code :** \\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        vector<int>l(n,1),r(n,1);\\n        int i;\\n        for(i=1;i<=n-1;i++)\\n        {\\n            if(nums[i-1]>=nums[i])\\n                l[i]+=l[i-1];\\n        }\\n        for(i=n-1;i>=1;i--)\\n        {\\n            if(nums[i-1]<=nums[i])\\n                r[i-1]+=r[i];\\n        }\\n        vector<int>res;\\n        for(i=k;i<n-k;i++)\\n        {\\n            if(l[i-1]>=k and r[i+1]>=k)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        vector<int>l(n,1),r(n,1);\\n        int i;\\n        for(i=1;i<=n-1;i++)\\n        {\\n            if(nums[i-1]>=nums[i])\\n                l[i]+=l[i-1];\\n        }\\n        for(i=n-1;i>=1;i--)\\n        {\\n            if(nums[i-1]<=nums[i])\\n                r[i-1]+=r[i];\\n        }\\n        vector<int>res;\\n        for(i=k;i<n-k;i++)\\n        {\\n            if(l[i-1]>=k and r[i+1]>=k)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620601,
                "title": "2-prefix-array-java",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        List<Integer> result = new LinkedList<>();\\n        int[] P1 = new int[n];\\n        int[] P2 = new int[n];\\n        Arrays.fill(P1, 1);\\n        Arrays.fill(P2, 1);\\n        \\n        for(int i = 1; i < n; i++)\\n            if(nums[i] <= nums[i-1])\\n                P1[i] = P1[i-1]+1;\\n        \\n        for(int i = n-2; i >= 0; i--)\\n            if(nums[i] <= nums[i+1])\\n                P2[i] = P2[i+1]+1;\\n        \\n        for(int i = k; i < n-k; i++) {\\n            if(P2[i+1] >= k && P1[i-1] >= k) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        List<Integer> result = new LinkedList<>();\\n        int[] P1 = new int[n];\\n        int[] P2 = new int[n];\\n        Arrays.fill(P1, 1);\\n        Arrays.fill(P2, 1);\\n        \\n        for(int i = 1; i < n; i++)\\n            if(nums[i] <= nums[i-1])\\n                P1[i] = P1[i-1]+1;\\n        \\n        for(int i = n-2; i >= 0; i--)\\n            if(nums[i] <= nums[i+1])\\n                P2[i] = P2[i+1]+1;\\n        \\n        for(int i = k; i < n-k; i++) {\\n            if(P2[i+1] >= k && P1[i-1] >= k) {\\n                result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620568,
                "title": "c-easy-approach-using-monotonic-stack-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int>d(nums.size(),1);\\n        vector<int>inc(nums.size(),1);\\n        vector<int>v;\\n        for(int i = 1;i<nums.size();i++){\\n            if(nums[i] <= nums[i-1])d[i] = d[i-1]+1;\\n        }\\n        \\n        for(int i = nums.size()-2;i>=0;i--){\\n            if(nums[i] <= nums[i+1])inc[i] =inc[i+1]+1; \\n        }\\n        \\n        for(int i = k;i<nums.size()-k;i++){\\n            // cout<<i<<\"->\"<<d[i]<<\"-\"<<inc[i]<<endl;\\n            if(d[i-1] >=k && inc[i+1] >= k)v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int>d(nums.size(),1);\\n        vector<int>inc(nums.size(),1);\\n        vector<int>v;\\n        for(int i = 1;i<nums.size();i++){\\n            if(nums[i] <= nums[i-1])d[i] = d[i-1]+1;\\n        }\\n        \\n        for(int i = nums.size()-2;i>=0;i--){\\n            if(nums[i] <= nums[i+1])inc[i] =inc[i+1]+1; \\n        }\\n        \\n        for(int i = k;i<nums.size()-k;i++){\\n            // cout<<i<<\"->\"<<d[i]<<\"-\"<<inc[i]<<endl;\\n            if(d[i-1] >=k && inc[i+1] >= k)v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2620525,
                "title": "python-queue-solution-two-passes",
                "content": "```\\n    def goodIndices(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k * 2 == len(nums):\\n            return []\\n        \\n        # check reverse validation\\n        cand = set()\\n        q = collections.deque()\\n        for i in reversed(range(len(nums))):\\n            if len(nums) - 1 - i >= k:\\n                if len(q) == k:\\n                    cand.add(i)\\n                    \\n            while q and q[0] - i >= k:\\n                q.popleft()\\n            \\n            while q and nums[q[-1]] < nums[i]:\\n                q.pop()\\n            q.append(i)\\n        \\n        # check forward validation\\n        res = []\\n        q = collections.deque()\\n        for i in range(len(nums)):\\n            if i >= k:\\n                if len(q) == k and i in cand:\\n                    res.append(i)\\n                    \\n            while q and i - q[0] >= k:\\n                q.popleft()\\n            \\n            while q and nums[q[-1]] < nums[i]:\\n                q.pop()\\n            q.append(i)\\n            \\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def goodIndices(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if k * 2 == len(nums):\\n            return []\\n        \\n        # check reverse validation\\n        cand = set()\\n        q = collections.deque()\\n        for i in reversed(range(len(nums))):\\n            if len(nums) - 1 - i >= k:\\n                if len(q) == k:\\n                    cand.add(i)\\n                    \\n            while q and q[0] - i >= k:\\n                q.popleft()\\n            \\n            while q and nums[q[-1]] < nums[i]:\\n                q.pop()\\n            q.append(i)\\n        \\n        # check forward validation\\n        res = []\\n        q = collections.deque()\\n        for i in range(len(nums)):\\n            if i >= k:\\n                if len(q) == k and i in cand:\\n                    res.append(i)\\n                    \\n            while q and i - q[0] >= k:\\n                q.popleft()\\n            \\n            while q and nums[q[-1]] < nums[i]:\\n                q.pop()\\n            q.append(i)\\n            \\n        return res\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2620523,
                "title": "easy-c-solution-short-code-8-lines",
                "content": "**Approach:** Search for increasing in left and decresing in right using two auxliary array than look for the condition `left[i+1]>=k and right[i-1] >=k` and `push(i)`\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k,vector<int> ans = {}) {\\n        int n =nums.size();\\n        vector<int> left(n),right(n);\\n        left[n-1] = right[0] = 1;\\n        for(int i = n-2;i>=0;i--)left[i] = nums[i] <= nums[i+1]?(left[i+1]+1):1;\\n        for(int i = 1;i<n;i++)right[i] = nums[i] <= nums[i-1]?(right[i-1]+1):1;\\n\\n        for(int i = 1;i<n-1;i++)\\n            if(left[i+1] >=k and right[i-1] >= k)ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k,vector<int> ans = {}) {\\n        int n =nums.size();\\n        vector<int> left(n),right(n);\\n        left[n-1] = right[0] = 1;\\n        for(int i = n-2;i>=0;i--)left[i] = nums[i] <= nums[i+1]?(left[i+1]+1):1;\\n        for(int i = 1;i<n;i++)right[i] = nums[i] <= nums[i-1]?(right[i-1]+1):1;\\n\\n        for(int i = 1;i<n-1;i++)\\n            if(left[i+1] >=k and right[i-1] >= k)ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620505,
                "title": "c-o-n-single-pass",
                "content": "```\\n/*\\nRun single pass keeping count of current length of healthy sequences\\n\\nif (i + k < i + k - 1) -> decreasing -> not healthy -> reset count\\nif (i - 1 > i - 2) -> increasing -> not healthy -> reset count\\n\\ncount -> the current length of healthy sequence (needs to be >= k to add i to answer vector)\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int count = 1;\\n        vector<int> ans;\\n        if (k == 1) {\\n            for (int i = 1; i < nums.size() - 1; i++) {\\n                ans.push_back(i);\\n            }\\n            return ans;\\n        }\\n        \\n        for (int i = 2; i < nums.size() - k; i++) {\\n            if (nums[i - 1] > nums[i - 2] || (nums[i + k] < nums[i + k - 1])) {\\n                count = 1;\\n            } else {\\n                count++;\\n            }\\n            if (count >= k) {\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nRun single pass keeping count of current length of healthy sequences\\n\\nif (i + k < i + k - 1) -> decreasing -> not healthy -> reset count\\nif (i - 1 > i - 2) -> increasing -> not healthy -> reset count\\n\\ncount -> the current length of healthy sequence (needs to be >= k to add i to answer vector)\\n*/\\n\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int count = 1;\\n        vector<int> ans;\\n        if (k == 1) {\\n            for (int i = 1; i < nums.size() - 1; i++) {\\n                ans.push_back(i);\\n            }\\n            return ans;\\n        }\\n        \\n        for (int i = 2; i < nums.size() - k; i++) {\\n            if (nums[i - 1] > nums[i - 2] || (nums[i + k] < nums[i + k - 1])) {\\n                count = 1;\\n            } else {\\n                count++;\\n            }\\n            if (count >= k) {\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088537,
                "title": "c-python-sliding-window-dp-solution-with-explanation",
                "content": "### sliding window\\nwe can traverse array from back to front and use sliding window to check if there has non-decreasing subarray of size k after each element, and then,\\ntraverse array forward, also use sliding window to check if there has non-decreasing subarray of size k before each element.\\n\\ntc is O(n), sc is O(n).\\n### python\\n```python\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        if len(nums) - 2 * k <= 0: return []\\n        n = len(nums)\\n        win = deque()\\n        aft = [False] * (n - 2 * k)\\n        for i in range(n-1, k-1, -1):\\n            if win and win[0] > i + k:\\n                win.popleft()\\n            if i < n - k and len(win) == k:\\n                aft[i-k] = True\\n            while win and nums[i] > nums[win[-1]]:\\n                win.pop()\\n            win.append(i)\\n        ans = []\\n        win.clear()\\n        for i in range(n - k):\\n            if win and win[0] < i - k:\\n                win.popleft()\\n            if i >= k and len(win) == k and aft[i-k]:\\n                ans.append(i)\\n            while win and nums[i] > nums[win[-1]]:\\n                win.pop()\\n            win.append(i)\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        if (nums.size() - 2 * k <= 0) return {};\\n        int n = nums.size();\\n        vector<bool> aft (n - 2 * k);\\n        deque<int> win;\\n        for (int i = n - 1; i >= k; i-=1) {\\n            if (!win.empty() && win[0] > i + k)\\n                win.pop_front();\\n            if (i < n - k && win.size() == k)\\n                aft[i-k] = true;\\n            while (!win.empty() && nums[i] > nums[win.back()])\\n                win.pop_back();\\n            win.emplace_back(i);\\n        }\\n        vector<int> ans;\\n        win.clear();\\n        for (int i = 0; i < n - k; i+=1) {\\n            if (!win.empty() && win[0] < i - k)\\n                win.pop_front();\\n            if (i < n - k && win.size() == k && aft[i-k])\\n                ans.emplace_back(i);\\n            while (!win.empty() && nums[i] > nums[win.back()])\\n                win.pop_back();\\n            win.emplace_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n### dp - length of longest non-decreasing/non-increasing subarray start/end at position i\\n\\nFirst,\\nwe can traverse array from back to front to calculate length of longest non-decreasing subarray start at position i,\\n\\nand then traverse array forward to calculate length of longest non-increasing subarray end at position i,\\n\\nif length of longest non-decreasing subarray start at position i + 1 >= k and length of longest non-increasing subarray end at position i - 1 >= k, position i is a good indice.\\n\\ntc is O(n), sc is O(n).\\n\\n\\n\\n### python\\n```python\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        if len(nums) - 2 * k <= 0: return []\\n        n = len(nums)\\n        aft = [1] * n # length of longest non-decreasing subarray start at position i\\n        for i in range(n-2, k, -1):\\n            if nums[i] <= nums[i+1]:\\n                aft[i] = 1 + aft[i+1]\\n        bef = 1 # length of longest non-increasing subarray end at position i\\n        ans = []\\n        for i in range(1, n-k):\\n            if bef >= k and aft[i+1] >= k:\\n                ans.append(i)\\n            if nums[i-1] >= nums[i]: \\n                bef += 1\\n            else: bef = 1\\n        return ans\\n```\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        if (nums.size() - 2 * k <= 0) return {};\\n        int n = nums.size();\\n        vector<int> aft (n, 1);\\n        for (int i = n - 2; i >= k; i-=1) {\\n            if (nums[i] <= nums[i+1])\\n                aft[i] = 1 + aft[i+1];\\n        }\\n        int bef = 1;\\n        vector<int> ans;\\n        for (int i = 1; i < n - k; i+=1) {\\n            if (bef >= k && aft[i+1] >= k)\\n                ans.emplace_back(i);\\n            if (nums[i-1] >= nums[i]) bef += 1;\\n            else bef = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        if len(nums) - 2 * k <= 0: return []\\n        n = len(nums)\\n        win = deque()\\n        aft = [False] * (n - 2 * k)\\n        for i in range(n-1, k-1, -1):\\n            if win and win[0] > i + k:\\n                win.popleft()\\n            if i < n - k and len(win) == k:\\n                aft[i-k] = True\\n            while win and nums[i] > nums[win[-1]]:\\n                win.pop()\\n            win.append(i)\\n        ans = []\\n        win.clear()\\n        for i in range(n - k):\\n            if win and win[0] < i - k:\\n                win.popleft()\\n            if i >= k and len(win) == k and aft[i-k]:\\n                ans.append(i)\\n            while win and nums[i] > nums[win[-1]]:\\n                win.pop()\\n            win.append(i)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        if (nums.size() - 2 * k <= 0) return {};\\n        int n = nums.size();\\n        vector<bool> aft (n - 2 * k);\\n        deque<int> win;\\n        for (int i = n - 1; i >= k; i-=1) {\\n            if (!win.empty() && win[0] > i + k)\\n                win.pop_front();\\n            if (i < n - k && win.size() == k)\\n                aft[i-k] = true;\\n            while (!win.empty() && nums[i] > nums[win.back()])\\n                win.pop_back();\\n            win.emplace_back(i);\\n        }\\n        vector<int> ans;\\n        win.clear();\\n        for (int i = 0; i < n - k; i+=1) {\\n            if (!win.empty() && win[0] < i - k)\\n                win.pop_front();\\n            if (i < n - k && win.size() == k && aft[i-k])\\n                ans.emplace_back(i);\\n            while (!win.empty() && nums[i] > nums[win.back()])\\n                win.pop_back();\\n            win.emplace_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        if len(nums) - 2 * k <= 0: return []\\n        n = len(nums)\\n        aft = [1] * n # length of longest non-decreasing subarray start at position i\\n        for i in range(n-2, k, -1):\\n            if nums[i] <= nums[i+1]:\\n                aft[i] = 1 + aft[i+1]\\n        bef = 1 # length of longest non-increasing subarray end at position i\\n        ans = []\\n        for i in range(1, n-k):\\n            if bef >= k and aft[i+1] >= k:\\n                ans.append(i)\\n            if nums[i-1] >= nums[i]: \\n                bef += 1\\n            else: bef = 1\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        if (nums.size() - 2 * k <= 0) return {};\\n        int n = nums.size();\\n        vector<int> aft (n, 1);\\n        for (int i = n - 2; i >= k; i-=1) {\\n            if (nums[i] <= nums[i+1])\\n                aft[i] = 1 + aft[i+1];\\n        }\\n        int bef = 1;\\n        vector<int> ans;\\n        for (int i = 1; i < n - k; i+=1) {\\n            if (bef >= k && aft[i+1] >= k)\\n                ans.emplace_back(i);\\n            if (nums[i-1] >= nums[i]) bef += 1;\\n            else bef = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941469,
                "title": "tc-o-n-sc-o-n-easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int> ans;  // To store the indices that satisfy the condition\\n        int n = nums.size();  // Size of the input array\\n        set<int> st;  // Set to store indices that have enough good numbers\\n        if (2 * k >= n) {\\n            return ans;  // If twice the k is greater or equal to n, no valid indices can be found\\n        }\\n        \\n        int cnt = 0;  // Counter to track consecutive good numbers\\n        for (int i = 0; i < n - k; i++) {\\n            if (cnt >= k) {\\n                st.insert(i);  // Insert index into the set if enough consecutive good numbers are encountered\\n            }\\n            if (i == 0 || nums[i - 1] >= nums[i]) {\\n                cnt++;\\n            } else {\\n                cnt = 1;  // Reset counter if the current number is not good\\n            }\\n        }\\n        \\n        cnt = 0;  // Reset the counter\\n        for (int i = n - 1; i >= k; i--) {\\n            if (cnt >= k) {\\n                if (st.find(i) != st.end()) {\\n                    ans.push_back(i);  // If index is in the set, add it to the answer\\n                }\\n            }\\n            if (i == n - 1 || nums[i + 1] >= nums[i]) {\\n                cnt++;\\n            } else {\\n                cnt = 1;  // Reset counter if the current number is not good\\n            }\\n        }\\n        \\n        reverse(ans.begin(), ans.end());  // Reverse the answer to get the indices in ascending order\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int> ans;  // To store the indices that satisfy the condition\\n        int n = nums.size();  // Size of the input array\\n        set<int> st;  // Set to store indices that have enough good numbers\\n        if (2 * k >= n) {\\n            return ans;  // If twice the k is greater or equal to n, no valid indices can be found\\n        }\\n        \\n        int cnt = 0;  // Counter to track consecutive good numbers\\n        for (int i = 0; i < n - k; i++) {\\n            if (cnt >= k) {\\n                st.insert(i);  // Insert index into the set if enough consecutive good numbers are encountered\\n            }\\n            if (i == 0 || nums[i - 1] >= nums[i]) {\\n                cnt++;\\n            } else {\\n                cnt = 1;  // Reset counter if the current number is not good\\n            }\\n        }\\n        \\n        cnt = 0;  // Reset the counter\\n        for (int i = n - 1; i >= k; i--) {\\n            if (cnt >= k) {\\n                if (st.find(i) != st.end()) {\\n                    ans.push_back(i);  // If index is in the set, add it to the answer\\n                }\\n            }\\n            if (i == n - 1 || nums[i + 1] >= nums[i]) {\\n                cnt++;\\n            } else {\\n                cnt = 1;  // Reset counter if the current number is not good\\n            }\\n        }\\n        \\n        reverse(ans.begin(), ans.end());  // Reverse the answer to get the indices in ascending order\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938402,
                "title": "c-two-cycles-explanation-very-optimized-runtime-beats-97-95-o-n",
                "content": "# Approach\\n\\nProblem states that at each point we need to ensure left and right `k` indices have correct values. To avoid recalculating them at each point we can first go along `n..0` and only save points where the right side is correct. So we do in the first cycle, storing them in `right` vector.\\n\\nThen we have second cycle where we only calculate the left-hand side. Since the right-hand side has been calculated, each time we find a valid left-handed point, we search for the point in the `right` vector and if it\\'s there then the point is valid both on left and right sides, so we add it to the `ret`.\\n\\nA few tricks are used:\\n\\n* It may be tempting to calculate left-hand side first. But we need to return vector with indices sorted in growing order, so calculating left-hand side last while adding valid points at the same time makes `ret` have the correct order right away.\\n* `right` is a vector and not a `set<size_t>` of indexes. In the 2-nd cycle such choice allows us to get state of a given index without having to call `right.find(i+1) != right.end()`, which is cleaner and marginally faster. Depending on the array I\\'d say there\\'s even a good change that the `vector<bool>` would take less memory because in C++ it\\'s stored as a bitset, so for a single `size_t` index you may have `8 * 8 = 64` points of a `vector<bool>`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(const vector<int>& nums, int k) {\\n        vector<bool> right(nums.size());\\n        size_t sz_appendix;\\n        for (size_t i_right = nums.size() - 1; i_right > k; --i_right) {\\n            sz_appendix = 1 + (i_right + 1 < nums.size() && nums[i_right] <= nums[i_right+1]? sz_appendix : 0);\\n            if (sz_appendix >= k)\\n                right[i_right-1] = true;\\n        }\\n        vector<int> ret;\\n        for (size_t i = 0; i < nums.size() - k; ++i) {\\n            sz_appendix = 1 + (i > 0 && nums[i-1] >= nums[i]? sz_appendix : 0);\\n            if (sz_appendix >= k && right[i+1])\\n                ret.push_back(i+1);\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\nhttps://leetcode.com/problems/find-all-good-indices/submissions/1027075186/",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(const vector<int>& nums, int k) {\\n        vector<bool> right(nums.size());\\n        size_t sz_appendix;\\n        for (size_t i_right = nums.size() - 1; i_right > k; --i_right) {\\n            sz_appendix = 1 + (i_right + 1 < nums.size() && nums[i_right] <= nums[i_right+1]? sz_appendix : 0);\\n            if (sz_appendix >= k)\\n                right[i_right-1] = true;\\n        }\\n        vector<int> ret;\\n        for (size_t i = 0; i < nums.size() - k; ++i) {\\n            sz_appendix = 1 + (i > 0 && nums[i-1] >= nums[i]? sz_appendix : 0);\\n            if (sz_appendix >= k && right[i+1])\\n                ret.push_back(i+1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936764,
                "title": "rust-solution-using-prefix-sum",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n  pub fn good_indices(nums: Vec<i32>, k: i32) -> Vec<i32> {\\n    let n = nums.len();\\n    let k = k as usize;\\n    let mut memo = vec![1;n]; // non-decreasing\\n    let mut memo2 = vec![1;n]; // non-increasing\\n\\n    for i in (0..n-1).rev() {\\n      if nums[i] <= nums[i+1] {\\n        memo[i] = memo[i+1]+1;\\n      }\\n    }\\n    for i in (0..n-1).rev() {\\n      if nums[i] >= nums[i+1] {\\n        memo2[i] = memo2[i+1]+1;\\n      }\\n    }\\n\\n    let mut result = vec![];\\n    for i in k..n-k {\\n      if k <= memo2[i-k] && k <= memo[i+1] {\\n        result.push(i as i32);\\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Prefix Sum"
                ],
                "code": "```\\nimpl Solution {\\n  pub fn good_indices(nums: Vec<i32>, k: i32) -> Vec<i32> {\\n    let n = nums.len();\\n    let k = k as usize;\\n    let mut memo = vec![1;n]; // non-decreasing\\n    let mut memo2 = vec![1;n]; // non-increasing\\n\\n    for i in (0..n-1).rev() {\\n      if nums[i] <= nums[i+1] {\\n        memo[i] = memo[i+1]+1;\\n      }\\n    }\\n    for i in (0..n-1).rev() {\\n      if nums[i] >= nums[i+1] {\\n        memo2[i] = memo2[i+1]+1;\\n      }\\n    }\\n\\n    let mut result = vec![];\\n    for i in k..n-k {\\n      if k <= memo2[i-k] && k <= memo[i+1] {\\n        result.push(i as i32);\\n      }\\n    }\\n\\n    result\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3913760,
                "title": "precomputing-longestsquenceafterindex-o-n",
                "content": "# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int N = nums.length; \\n\\n        int[] longestSquenceAfterI = new int[N];\\n\\n        int elemsInOrder = 1; \\n        for(int index = N-2; index >= 0; index--){\\n            longestSquenceAfterI[index] = elemsInOrder; \\n            if(nums[index] > nums[index+1]){\\n                elemsInOrder=0;\\n            }\\n            elemsInOrder++;\\n        }\\n\\n        List<Integer> goodIndices = new ArrayList<>(); \\n        elemsInOrder = 1; \\n        for(int index = 1; index < nums.length; index++){\\n            if(index>=k && elemsInOrder>=k && longestSquenceAfterI[index]>=k)\\n                goodIndices.add(index);\\n            if(nums[index] > nums[index-1])\\n                elemsInOrder=0; \\n            elemsInOrder++; \\n        }\\n        return goodIndices;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int N = nums.length; \\n\\n        int[] longestSquenceAfterI = new int[N];\\n\\n        int elemsInOrder = 1; \\n        for(int index = N-2; index >= 0; index--){\\n            longestSquenceAfterI[index] = elemsInOrder; \\n            if(nums[index] > nums[index+1]){\\n                elemsInOrder=0;\\n            }\\n            elemsInOrder++;\\n        }\\n\\n        List<Integer> goodIndices = new ArrayList<>(); \\n        elemsInOrder = 1; \\n        for(int index = 1; index < nums.length; index++){\\n            if(index>=k && elemsInOrder>=k && longestSquenceAfterI[index]>=k)\\n                goodIndices.add(index);\\n            if(nums[index] > nums[index-1])\\n                elemsInOrder=0; \\n            elemsInOrder++; \\n        }\\n        return goodIndices;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883523,
                "title": "python-beats-88-simple-left-right-looking-type-question",
                "content": "two pass solution.\\nbasically look at left longest  decreasing and right longest increasing by peaking at i+1 and i-1 and l,r array\\n\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        l,r = [1],[1]\\n        \\n        for i in range(1,n-1):\\n            \\n            if nums[i] <= nums[i-1]:l.append(l[-1]+1)\\n            else:l.append(1)\\n                \\n            if nums[n-1-i] <= nums[n-i]:r.append(r[-1]+1)\\n            else:r.append(1)\\n                \\n        return [i for i in range(1,n-1) if l[i-1] >=k and r[n-2-i] >=k ]",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "two pass solution.\\nbasically look at left longest  decreasing and right longest increasing by peaking at i+1 and i-1 and l,r array\\n\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        l,r = [1],[1]\\n        \\n        for i in range(1,n-1):\\n            \\n            if nums[i] <= nums[i-1]:l.append(l[-1]+1)\\n            else:l.append(1)\\n                \\n            if nums[n-1-i] <= nums[n-i]:r.append(r[-1]+1)\\n            else:r.append(1)\\n                \\n        return [i for i in range(1,n-1) if l[i-1] >=k and r[n-2-i] >=k ]",
                "codeTag": "Java"
            },
            {
                "id": 3832872,
                "title": "only-one-additional-array-and-two-passes",
                "content": "# Intuition\\n        \\u0421\\u043D\\u0430\\u0447\\u0430\\u043B\\u0430 \\u0441\\u0434\\u0435\\u043B\\u0430\\u043B \\u0431\\u0435\\u0437 \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u043D\\u0438\\u044F \\u0434\\u043E\\u043F\\u043E\\u043B\\u043D\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0433\\u043E \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430,\\n\\u043D\\u043E \\u043D\\u0430 \\u043F\\u0440\\u043E\\u0433\\u043E\\u043D\\u0435 \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u043B \\u043F\\u043B\\u043E\\u0445\\u043E\\u0439 \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442 \\u043F\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u043D\\u0438\\u044E \\u043F\\u0430\\u043C\\u044F\\u0442\\u0438. \\u0422\\u0430\\u043A \\u0438 \\u043D\\u0435 \\u0440\\u0430\\u0437\\u043E\\u0431\\u0440\\u0430\\u043B\\u0441\\u044F, \\u043F\\u043E\\u0447\\u0435\\u043C\\u0443 \\u0442\\u0430\\u043A \\u043F\\u043E\\u043B\\u0443\\u0447\\u0438\\u043B\\u043E\\u0441\\u044C - \\u043F\\u043E\\u0442\\u043E\\u043C \\u044F \\u0432\\u0438\\u0434\\u0435\\u043B \\u0432\\u0430\\u0440\\u0438\\u0430\\u0442\\u044B \\u0441 \\u0434\\u0432\\u0443\\u043C\\u044F \\u0432\\u0441\\u043F\\u043E\\u043C\\u043E\\u0433\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u044B\\u043C\\u0438 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430\\u043C\\u0438, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0435 \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u043B\\u0438 \\u043F\\u0430\\u043C\\u044F\\u0442\\u044C \\u0442\\u0430\\u043A \\u0436\\u0435, \\u043A\\u0430\\u043A \\u0438 \\u043C\\u043E\\u0439 \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442. \\u0415\\u0441\\u0442\\u044C \\u043F\\u043E\\u0434\\u043E\\u0437\\u0440\\u0435\\u043D\\u0438\\u0435, \\u0447\\u0442\\u043E \\u0443 \\u0441\\u0438\\u0441\\u0442\\u0435\\u043C\\u044B \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u043E\\u0431\\u043B\\u0435\\u043C\\u0430 \\u0441 \\u043F\\u043E\\u0434\\u0441\\u0447\\u0435\\u0442\\u043E\\u043C \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u0435\\u043C\\u043E\\u0439 \\u043F\\u0430\\u043C\\u044F\\u0442\\u0438.\\n        \\u041A \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u043C\\u0443 \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044E \\u043F\\u0440\\u0438\\u0448\\u0435\\u043B, \\u0438\\u0437\\u0443\\u0447\\u0438\\u0432 \\u0441\\u0430\\u043C\\u044B\\u0439 \\u0440\\u0430\\u0441\\u043F\\u0440\\u043E\\u0441\\u0442\\u0440\\u0430\\u043D\\u0435\\u043D\\u043D\\u044B\\u0439 \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C, \\u0438\\u0437 \\u0442\\u0435\\u0445, \\u0447\\u0442\\u043E \\u043F\\u0440\\u0438\\u043C\\u0435\\u043D\\u044F\\u043B\\u0438\\u0441\\u044C \\u0434\\u0440\\u0443\\u0433\\u0438\\u043C\\u0438 \\u0430\\u0432\\u0442\\u043E\\u0440\\u0430\\u043C\\u0438. \\u0421\\u043D\\u0430\\u0447\\u0430\\u043B\\u0430 \\u0440\\u0430\\u0437\\u043E\\u0431\\u0440\\u0430\\u043B\\u0441\\u044F, \\u043A\\u0430\\u043A \\u044D\\u0442\\u043E \\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u0435\\u0442, \\u0430 \\u043F\\u043E\\u0442\\u043E\\u043C \\u043D\\u0435\\u043C\\u043D\\u043E\\u0433\\u043E \\u043E\\u043F\\u0442\\u0438\\u043C\\u0438\\u0437\\u0438\\u0440\\u043E\\u0432\\u0430\\u043B.\\n\\n# Approach\\n        \\n        1. \\u041F\\u0440\\u043E\\u0445\\u043E\\u0434\\u0438\\u043C \\u0441 \\u043A\\u043E\\u043D\\u0446\\u0430 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430, \\u0438 \\u0434\\u043B\\u044F \\u043A\\u0430\\u0436\\u0434\\u043E\\u0433\\u043E \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430 \\u043F\\u043E\\u0434\\u0441\\u0447\\u0438\\u0442\\u044B\\u0432\\u0430\\u0435\\u043C \\u0434\\u043B\\u0438\\u043D\\u044B \\u043D\\u0435\\u0443\\u0431\\u044B\\u0432\\u0430\\u044E\\u0449\\u0438\\u0445 \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043E\\u0432\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439 \\u0441\\u043F\\u0440\\u0430\\u0432\\u0430 \\u043E\\u0442 \\u043D\\u0435\\u0433\\u043E.\\n        \\u0414\\u043B\\u0438\\u043D\\u0443 \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043E\\u0432\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u0438 \\u0441\\u043E\\u0445\\u0440\\u0430\\u043D\\u044F\\u0435\\u043C \\u0432 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0435, \\u0440\\u0430\\u0437\\u043C\\u0435\\u0440 \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0433\\u043E \\u0440\\u0430\\u0432\\u0435\\u043D \\u0440\\u0430\\u0437\\u043C\\u0435\\u0440\\u0443 \\u0438\\u0441\\u0445\\u043E\\u0434\\u043D\\u043E\\u0433\\u043E \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430.\\n        2. \\u0417\\u0430\\u0442\\u0435\\u043C \\u043F\\u0440\\u043E\\u0445\\u043E\\u0434\\u0438\\u043C \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432 \\u0441 \\u043D\\u0430\\u0447\\u0430\\u043B\\u0430 \\u0438 \\u0434\\u043B\\u044F \\u043A\\u0430\\u0436\\u0434\\u043E\\u0433\\u043E \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430 \\u043F\\u043E\\u0434\\u0441\\u0447\\u0438\\u0442\\u044B\\u0432\\u0430\\u0435\\u043C \\u0434\\u043B\\u0438\\u043D\\u044B \\u043D\\u0435\\u0432\\u043E\\u0437\\u0440\\u0430\\u0441\\u0442\\u0430\\u044E\\u0449\\u0438\\u0445 \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043E\\u0432\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439 \\u0441\\u043B\\u0435\\u0432\\u0430 \\u043E\\u0442 \\u043D\\u0435\\u0433\\u043E.\\n        \\u0415\\u0441\\u043B\\u0438 \\u0434\\u043B\\u0438\\u043D\\u0430 \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043E\\u0432\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u0438 \\u0441\\u043B\\u0435\\u0432\\u0430 \\u043E\\u0442 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0433\\u043E \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430 >= k \\n        \\u0438 \\u0434\\u043B\\u0438\\u043D\\u0430 \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043E\\u0432\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u0438 \\u0441\\u043F\\u0440\\u0430\\u0432\\u0430 >= k (\\u0431\\u0435\\u0440\\u0435\\u043C \\u0438\\u0437 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430 \\u0434\\u043B\\u0438\\u043D \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043E\\u0432\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439, \\u0437\\u0430\\u043F\\u043E\\u043B\\u043D\\u0435\\u043D\\u043D\\u044B\\u0439 \\u043D\\u0430 \\u043F\\u0435\\u0440\\u0432\\u043E\\u043C \\u043F\\u0440\\u043E\\u0445\\u043E\\u0434\\u0435),\\n        \\u0442\\u043E \\u0434\\u043E\\u0431\\u0430\\u0432\\u043B\\u044F\\u0435\\u043C \\u043D\\u043E\\u043C\\u0435\\u0440 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430 \\u0432 \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0438\\u0440\\u0443\\u044E\\u0449\\u0438\\u0439 \\u0441\\u043F\\u0438\\u0441\\u043E\\u043A.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<int> GoodIndices(int[] nums, int k) \\n    {   \\n        const ushort MINIMAL_CHAIN_LENGTH = 1;\\n        const byte ZERO = (byte)0;\\n        const byte ONE = (byte)1;\\n\\n        int n = nums.Length;\\n        var result = new List<int>();\\n\\n        // \\u0417\\u0434\\u0435\\u0441\\u044C \\u0437\\u0430\\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u043C\\u043E\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432 bool, \\u043F\\u043E \\u0438\\u0434\\u0435\\u0435 \\u044D\\u0442\\u043E \\u0434\\u043E\\u043B\\u0436\\u043D\\u043E \\u0441\\u0438\\u043B\\u044C\\u043D\\u043E \\u0443\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u0442\\u044C \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043F\\u0430\\u043C\\u044F\\u0442\\u0438.\\n        // \\u041D\\u043E \\u043F\\u043E\\u0447\\u0435\\u043C\\u0443-\\u0442\\u043E \\u043F\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u0430\\u043C \\u043F\\u0440\\u043E\\u0433\\u043E\\u043D\\u0430 \\u0432 \\u0442\\u0430\\u043A\\u043E\\u043C \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442\\u0435 \\u043F\\u0430\\u043C\\u044F\\u0442\\u0438 \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u0435\\u0442\\u0441\\u044F \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435.\\n        // \\u041D\\u0435 \\u043C\\u043E\\u0433\\u0443 \\u043E\\u0431\\u044A\\u044F\\u0441\\u043D\\u0438\\u0442\\u044C \\u043F\\u043E\\u0447\\u0435\\u043C\\u0443. \\u041F\\u043E\\u0445\\u043E\\u0436\\u0435, \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u043E \\u0432 \\u043A\\u0430\\u043A\\u043E\\u043C-\\u0442\\u043E \\u0445\\u0438\\u0442\\u0440\\u043E\\u043C \\u0432\\u044B\\u0440\\u0430\\u0432\\u043D\\u0438\\u0432\\u0430\\u043D\\u0438\\u0438 \\u043D\\u0430 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u0443 \\u0441\\u043B\\u043E\\u0432\\u0430.\\n        int[] reverseChainLengths = new int[n];\\n\\n        reverseChainLengths[0] = 0;\\n        reverseChainLengths[1] = MINIMAL_CHAIN_LENGTH >= k ? ONE : ZERO;\\n        // \\u041F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u044F\\u044F \\u0446\\u0435\\u043F\\u043E\\u0447\\u043A\\u0430 \\u0432\\u0441\\u0435\\u0433\\u0434\\u0430 \\u0438\\u043C\\u0435\\u0435\\u0442 \\u043D\\u0443\\u043B\\u0435\\u0432\\u0443\\u044E \\u0434\\u043B\\u0438\\u043D\\u0443, \\u0442.\\u043A. \\u043F\\u043E\\u0441\\u043B\\u0435 \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u0435\\u0433\\u043E \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430 \\u0434\\u0440\\u0443\\u0433\\u0438\\u0445 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u043E\\u0432 \\u043D\\u0435\\u0442\\n        reverseChainLengths[n-1] = 0;\\n        // \\u041F\\u0440\\u0435\\u0434\\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u044F\\u044F \\u0446\\u0435\\u043F\\u043E\\u0447\\u043A\\u0430 \\u0432\\u0441\\u0435\\u0433\\u0434\\u0430 \\u0438\\u043C\\u0435\\u0435\\u0442 \\u0434\\u043B\\u0438\\u043D\\u0443 1.\\n        reverseChainLengths[n-2] = MINIMAL_CHAIN_LENGTH >= k ? ONE : ZERO;\\n\\n        // \\u042D\\u043A\\u043E\\u043D\\u043E\\u043C\\u0438\\u043C \\u043D\\u0430 \\u043E\\u0431\\u0440\\u0430\\u0449\\u0435\\u043D\\u0438\\u0438 \\u043A \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0443 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430, \\u0437\\u0430\\u043F\\u043E\\u043C\\u0438\\u043D\\u0430\\u044F \\u043F\\u0440\\u0435\\u0434\\u044B\\u0434\\u0443\\u0449\\u0435\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E.\\n        int nextNumber = nums[n-1];\\n\\n        int chainLength = MINIMAL_CHAIN_LENGTH;\\n\\n        // \\u041D\\u0430\\u0447\\u0438\\u043D\\u0430\\u0435\\u043C \\u043F\\u043E\\u0434\\u0441\\u0447\\u0451\\u0442 \\u0434\\u043B\\u0438\\u043D \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043E\\u0432\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439 \\u0441\\u043E \\u0442\\u0440\\u0435\\u0442\\u044C\\u0435\\u0433\\u043E \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430 \\u0441 \\u043A\\u043E\\u043D\\u0446\\u0430, \\n        // \\u0442.\\u043A. \\u0434\\u043B\\u044F \\u0434\\u0432\\u0443\\u0445 \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u0438\\u0445 \\u043E\\u043D\\u0438 \\u0443\\u0436\\u0435 \\u043F\\u043E\\u0434\\u0441\\u0447\\u0438\\u0442\\u0430\\u043D\\u044B\\n        for (int i=n-3; i >= k; i--)\\n        {\\n            int currentNumber = nums[i+1];\\n\\n            if (currentNumber <= nextNumber)\\n                chainLength++;\\n            else \\n                chainLength = MINIMAL_CHAIN_LENGTH;\\n            nextNumber = currentNumber;\\n\\n            reverseChainLengths[i] = chainLength >= k ? ONE : ZERO;\\n        }\\n\\n        // \\u0422\\u0430\\u043A \\u043A\\u0430\\u043A \\u0432 \\u0446\\u0438\\u043A\\u043B\\u0435 \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442 \\u043D\\u0435 \\u043F\\u0440\\u043E\\u0432\\u0435\\u0440\\u044F\\u0435\\u0442\\u0441\\u044F (\\u0438\\u0437-\\u0437\\u0430 \\u043F\\u0440\\u043E\\u0431\\u043B\\u0435\\u043C \\u0441 \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C), \\n        // \\u0434\\u043B\\u044F \\u043D\\u0435\\u0433\\u043E \\u043D\\u0443\\u0436\\u043D\\u0430 \\u043E\\u0442\\u0434\\u0435\\u043B\\u044C\\u043D\\u0430\\u044F \\u043F\\u0440\\u043E\\u0432\\u0435\\u0440\\u043A\\u0430.\\n        if (k == 1 && reverseChainLengths[1] == ONE) \\n            result.Add( 1 );\\n\\n        int prevNumber = nums[0];\\n        chainLength = MINIMAL_CHAIN_LENGTH;\\n\\n        // \\u041D\\u0430\\u0447\\u0438\\u043D\\u0430\\u0435\\u043C \\u043F\\u043E\\u0434\\u0441\\u0447\\u0451\\u0442 \\u0434\\u043B\\u0438\\u043D \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043E\\u0432\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439 \\u0441\\u043E \\u0442\\u0440\\u0435\\u0442\\u044C\\u0435\\u0433\\u043E \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430, \\n        // \\u0442.\\u043A. \\u0434\\u043B\\u044F \\u043F\\u0435\\u0440\\u0432\\u044B\\u0445 \\u0434\\u0432\\u0443\\u0445 \\u043E\\u043D\\u0438 \\u0443\\u0436\\u0435 \\u043F\\u043E\\u0434\\u0441\\u0447\\u0438\\u0442\\u0430\\u043D\\u044B.\\n        for (int i=2; i < n; i++)\\n        {\\n            int currentNumber = nums[i-1];\\n\\n            if (prevNumber >= currentNumber)\\n                chainLength++;\\n            else \\n                chainLength = MINIMAL_CHAIN_LENGTH;\\n            prevNumber = currentNumber;\\n\\n            if (reverseChainLengths[i] == ONE && chainLength >= k)\\n                result.Add( i );\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<int> GoodIndices(int[] nums, int k) \\n    {   \\n        const ushort MINIMAL_CHAIN_LENGTH = 1;\\n        const byte ZERO = (byte)0;\\n        const byte ONE = (byte)1;\\n\\n        int n = nums.Length;\\n        var result = new List<int>();\\n\\n        // \\u0417\\u0434\\u0435\\u0441\\u044C \\u0437\\u0430\\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u043C\\u043E\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432 bool, \\u043F\\u043E \\u0438\\u0434\\u0435\\u0435 \\u044D\\u0442\\u043E \\u0434\\u043E\\u043B\\u0436\\u043D\\u043E \\u0441\\u0438\\u043B\\u044C\\u043D\\u043E \\u0443\\u043C\\u0435\\u043D\\u044C\\u0448\\u0438\\u0442\\u044C \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u043D\\u0438\\u0435 \\u043F\\u0430\\u043C\\u044F\\u0442\\u0438.\\n        // \\u041D\\u043E \\u043F\\u043E\\u0447\\u0435\\u043C\\u0443-\\u0442\\u043E \\u043F\\u043E \\u0440\\u0435\\u0437\\u0443\\u043B\\u044C\\u0442\\u0430\\u0442\\u0430\\u043C \\u043F\\u0440\\u043E\\u0433\\u043E\\u043D\\u0430 \\u0432 \\u0442\\u0430\\u043A\\u043E\\u043C \\u0432\\u0430\\u0440\\u0438\\u0430\\u043D\\u0442\\u0435 \\u043F\\u0430\\u043C\\u044F\\u0442\\u0438 \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u0443\\u0435\\u0442\\u0441\\u044F \\u0431\\u043E\\u043B\\u044C\\u0448\\u0435.\\n        // \\u041D\\u0435 \\u043C\\u043E\\u0433\\u0443 \\u043E\\u0431\\u044A\\u044F\\u0441\\u043D\\u0438\\u0442\\u044C \\u043F\\u043E\\u0447\\u0435\\u043C\\u0443. \\u041F\\u043E\\u0445\\u043E\\u0436\\u0435, \\u0447\\u0442\\u043E \\u0434\\u0435\\u043B\\u043E \\u0432 \\u043A\\u0430\\u043A\\u043E\\u043C-\\u0442\\u043E \\u0445\\u0438\\u0442\\u0440\\u043E\\u043C \\u0432\\u044B\\u0440\\u0430\\u0432\\u043D\\u0438\\u0432\\u0430\\u043D\\u0438\\u0438 \\u043D\\u0430 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u0443 \\u0441\\u043B\\u043E\\u0432\\u0430.\\n        int[] reverseChainLengths = new int[n];\\n\\n        reverseChainLengths[0] = 0;\\n        reverseChainLengths[1] = MINIMAL_CHAIN_LENGTH >= k ? ONE : ZERO;\\n        // \\u041F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u044F\\u044F \\u0446\\u0435\\u043F\\u043E\\u0447\\u043A\\u0430 \\u0432\\u0441\\u0435\\u0433\\u0434\\u0430 \\u0438\\u043C\\u0435\\u0435\\u0442 \\u043D\\u0443\\u043B\\u0435\\u0432\\u0443\\u044E \\u0434\\u043B\\u0438\\u043D\\u0443, \\u0442.\\u043A. \\u043F\\u043E\\u0441\\u043B\\u0435 \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u0435\\u0433\\u043E \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430 \\u0434\\u0440\\u0443\\u0433\\u0438\\u0445 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u043E\\u0432 \\u043D\\u0435\\u0442\\n        reverseChainLengths[n-1] = 0;\\n        // \\u041F\\u0440\\u0435\\u0434\\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u044F\\u044F \\u0446\\u0435\\u043F\\u043E\\u0447\\u043A\\u0430 \\u0432\\u0441\\u0435\\u0433\\u0434\\u0430 \\u0438\\u043C\\u0435\\u0435\\u0442 \\u0434\\u043B\\u0438\\u043D\\u0443 1.\\n        reverseChainLengths[n-2] = MINIMAL_CHAIN_LENGTH >= k ? ONE : ZERO;\\n\\n        // \\u042D\\u043A\\u043E\\u043D\\u043E\\u043C\\u0438\\u043C \\u043D\\u0430 \\u043E\\u0431\\u0440\\u0430\\u0449\\u0435\\u043D\\u0438\\u0438 \\u043A \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0443 \\u043C\\u0430\\u0441\\u0441\\u0438\\u0432\\u0430, \\u0437\\u0430\\u043F\\u043E\\u043C\\u0438\\u043D\\u0430\\u044F \\u043F\\u0440\\u0435\\u0434\\u044B\\u0434\\u0443\\u0449\\u0435\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E.\\n        int nextNumber = nums[n-1];\\n\\n        int chainLength = MINIMAL_CHAIN_LENGTH;\\n\\n        // \\u041D\\u0430\\u0447\\u0438\\u043D\\u0430\\u0435\\u043C \\u043F\\u043E\\u0434\\u0441\\u0447\\u0451\\u0442 \\u0434\\u043B\\u0438\\u043D \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043E\\u0432\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439 \\u0441\\u043E \\u0442\\u0440\\u0435\\u0442\\u044C\\u0435\\u0433\\u043E \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430 \\u0441 \\u043A\\u043E\\u043D\\u0446\\u0430, \\n        // \\u0442.\\u043A. \\u0434\\u043B\\u044F \\u0434\\u0432\\u0443\\u0445 \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043D\\u0438\\u0445 \\u043E\\u043D\\u0438 \\u0443\\u0436\\u0435 \\u043F\\u043E\\u0434\\u0441\\u0447\\u0438\\u0442\\u0430\\u043D\\u044B\\n        for (int i=n-3; i >= k; i--)\\n        {\\n            int currentNumber = nums[i+1];\\n\\n            if (currentNumber <= nextNumber)\\n                chainLength++;\\n            else \\n                chainLength = MINIMAL_CHAIN_LENGTH;\\n            nextNumber = currentNumber;\\n\\n            reverseChainLengths[i] = chainLength >= k ? ONE : ZERO;\\n        }\\n\\n        // \\u0422\\u0430\\u043A \\u043A\\u0430\\u043A \\u0432 \\u0446\\u0438\\u043A\\u043B\\u0435 \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442 \\u043D\\u0435 \\u043F\\u0440\\u043E\\u0432\\u0435\\u0440\\u044F\\u0435\\u0442\\u0441\\u044F (\\u0438\\u0437-\\u0437\\u0430 \\u043F\\u0440\\u043E\\u0431\\u043B\\u0435\\u043C \\u0441 \\u0438\\u043D\\u0434\\u0435\\u043A\\u0441\\u043E\\u043C), \\n        // \\u0434\\u043B\\u044F \\u043D\\u0435\\u0433\\u043E \\u043D\\u0443\\u0436\\u043D\\u0430 \\u043E\\u0442\\u0434\\u0435\\u043B\\u044C\\u043D\\u0430\\u044F \\u043F\\u0440\\u043E\\u0432\\u0435\\u0440\\u043A\\u0430.\\n        if (k == 1 && reverseChainLengths[1] == ONE) \\n            result.Add( 1 );\\n\\n        int prevNumber = nums[0];\\n        chainLength = MINIMAL_CHAIN_LENGTH;\\n\\n        // \\u041D\\u0430\\u0447\\u0438\\u043D\\u0430\\u0435\\u043C \\u043F\\u043E\\u0434\\u0441\\u0447\\u0451\\u0442 \\u0434\\u043B\\u0438\\u043D \\u043F\\u043E\\u0441\\u043B\\u0435\\u0434\\u043E\\u0432\\u0430\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u0435\\u0439 \\u0441\\u043E \\u0442\\u0440\\u0435\\u0442\\u044C\\u0435\\u0433\\u043E \\u044D\\u043B\\u0435\\u043C\\u0435\\u043D\\u0442\\u0430, \\n        // \\u0442.\\u043A. \\u0434\\u043B\\u044F \\u043F\\u0435\\u0440\\u0432\\u044B\\u0445 \\u0434\\u0432\\u0443\\u0445 \\u043E\\u043D\\u0438 \\u0443\\u0436\\u0435 \\u043F\\u043E\\u0434\\u0441\\u0447\\u0438\\u0442\\u0430\\u043D\\u044B.\\n        for (int i=2; i < n; i++)\\n        {\\n            int currentNumber = nums[i-1];\\n\\n            if (prevNumber >= currentNumber)\\n                chainLength++;\\n            else \\n                chainLength = MINIMAL_CHAIN_LENGTH;\\n            prevNumber = currentNumber;\\n\\n            if (reverseChainLengths[i] == ONE && chainLength >= k)\\n                result.Add( i );\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831316,
                "title": "simple-clear-beats-100-w-comments",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar goodIndices = function(nums, k) {\\n    const n = nums.length;\\n    // Arrays to store the length of non-increasing subsequence ending and starting at each index.\\n    const dec = new Array(n).fill(1);\\n    const inc = new Array(n).fill(1);\\n    \\n    // Calculate the length of non-increasing subsequence ending at each index.\\n    for (let i = 1; i < n; i++) {\\n        if (nums[i - 1] >= nums[i]) {\\n            dec[i] = dec[i - 1] + 1;\\n        }\\n    }\\n\\n    // Calculate the length of non-decreasing subsequence starting at each index.\\n    for (let i = n - 2; i >= 0; i--) {\\n        if (nums[i] <= nums[i + 1]) {\\n            inc[i] = inc[i + 1] + 1;\\n        }\\n    }\\n\\n    const arr = [];\\n    // Check if the index i is good and add it to the array.\\n    for (let i = k; i < n - k; i++) {\\n        if (dec[i - 1] >= k && inc[i + 1] >= k) {\\n            arr.push(i);\\n        }\\n    }\\n\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar goodIndices = function(nums, k) {\\n    const n = nums.length;\\n    // Arrays to store the length of non-increasing subsequence ending and starting at each index.\\n    const dec = new Array(n).fill(1);\\n    const inc = new Array(n).fill(1);\\n    \\n    // Calculate the length of non-increasing subsequence ending at each index.\\n    for (let i = 1; i < n; i++) {\\n        if (nums[i - 1] >= nums[i]) {\\n            dec[i] = dec[i - 1] + 1;\\n        }\\n    }\\n\\n    // Calculate the length of non-decreasing subsequence starting at each index.\\n    for (let i = n - 2; i >= 0; i--) {\\n        if (nums[i] <= nums[i + 1]) {\\n            inc[i] = inc[i + 1] + 1;\\n        }\\n    }\\n\\n    const arr = [];\\n    // Check if the index i is good and add it to the array.\\n    for (let i = k; i < n - k; i++) {\\n        if (dec[i - 1] >= k && inc[i + 1] >= k) {\\n            arr.push(i);\\n        }\\n    }\\n\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3811842,
                "title": "two-pass-with-two-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int> dec(nums.size(), 1);\\n        vector<int> inc(nums.size(), 1);\\n        vector<int> output;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i - 1] >= nums[i]) {\\n                inc[i] += inc[i - 1];\\n            }\\n            if (nums[nums.size() - i] >= nums[nums.size() - i - 1]) {\\n                dec[nums.size() - i - 1] += dec[nums.size() - i];\\n            }\\n        }\\n        for (int i = 1; i < nums.size() - 1; ++i) {\\n            if (inc[i - 1] >= k && dec[i + 1] >= k) {\\n                output.push_back(i);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int> dec(nums.size(), 1);\\n        vector<int> inc(nums.size(), 1);\\n        vector<int> output;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            if (nums[i - 1] >= nums[i]) {\\n                inc[i] += inc[i - 1];\\n            }\\n            if (nums[nums.size() - i] >= nums[nums.size() - i - 1]) {\\n                dec[nums.size() - i - 1] += dec[nums.size() - i];\\n            }\\n        }\\n        for (int i = 1; i < nums.size() - 1; ++i) {\\n            if (inc[i - 1] >= k && dec[i + 1] >= k) {\\n                output.push_back(i);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800233,
                "title": "pre-computation-short-and-simple-solution",
                "content": "# Complexity\\n- Time complexity:. $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> left(n,1), right(n,1), ans;\\n\\n        for(int i=1; i<n; i++)\\n        {    //if prev element is larger than curr element, update left[i]\\n             left[i] = nums[i-1] >= nums[i] ?  1 + left[i-1] : 1;\\n        }\\n\\n        for(int i=n-2; i>=0; i--)\\n        {   //if curr element is smaller than next element, update right[i]\\n            right[i] = nums[i] <= nums[i+1] ? 1 + right[i+1] : 1;\\n        }\\n\\n        for(int i=k; i<n-k; i++) //good indices will be present in [k,n-k-1] range\\n        {\\n            if(left[i-1] >= k && right[i+1] >= k) //condition to check good index\\n              ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> left(n,1), right(n,1), ans;\\n\\n        for(int i=1; i<n; i++)\\n        {    //if prev element is larger than curr element, update left[i]\\n             left[i] = nums[i-1] >= nums[i] ?  1 + left[i-1] : 1;\\n        }\\n\\n        for(int i=n-2; i>=0; i--)\\n        {   //if curr element is smaller than next element, update right[i]\\n            right[i] = nums[i] <= nums[i+1] ? 1 + right[i+1] : 1;\\n        }\\n\\n        for(int i=k; i<n-k; i++) //good indices will be present in [k,n-k-1] range\\n        {\\n            if(left[i-1] >= k && right[i+1] >= k) //condition to check good index\\n              ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782334,
                "title": "dp-solution-easy-to-understand-c",
                "content": "# DP Solution \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n      vector<int> decr(nums.size(),0);\\n      decr[0]=0;\\n       decr[1]=1;\\n       vector<int> incr(nums.size(),0); \\n       incr[nums.size()-1]=0;\\n       incr[nums.size()-2]=1;\\n\\n\\n    for(int i=1;i<nums.size()-1;i++){\\n        if(nums[i-1]>=nums[i]){\\n            decr[i+1]=decr[i]+1;\\n        }\\n        else{\\n            decr[i+1]=1;\\n        }\\n    }\\n\\n     for(int i=nums.size()-2;i>=1;i--){\\n        if(nums[i+1]>=nums[i]){\\n            incr[i-1]=incr[i]+1;\\n        }\\n        else{\\n            incr[i-1]=1;\\n        }\\n    }\\n    vector<int> ans;\\n\\n    for(int i = k;i<nums.size()-k;i++){\\n        if(decr[i]>=k && incr[i]>=k){\\n            ans.push_back(i);\\n        }\\n    }\\n    \\n    \\n    \\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n      vector<int> decr(nums.size(),0);\\n      decr[0]=0;\\n       decr[1]=1;\\n       vector<int> incr(nums.size(),0); \\n       incr[nums.size()-1]=0;\\n       incr[nums.size()-2]=1;\\n\\n\\n    for(int i=1;i<nums.size()-1;i++){\\n        if(nums[i-1]>=nums[i]){\\n            decr[i+1]=decr[i]+1;\\n        }\\n        else{\\n            decr[i+1]=1;\\n        }\\n    }\\n\\n     for(int i=nums.size()-2;i>=1;i--){\\n        if(nums[i+1]>=nums[i]){\\n            incr[i-1]=incr[i]+1;\\n        }\\n        else{\\n            incr[i-1]=1;\\n        }\\n    }\\n    vector<int> ans;\\n\\n    for(int i = k;i<nums.size()-k;i++){\\n        if(decr[i]>=k && incr[i]>=k){\\n            ans.push_back(i);\\n        }\\n    }\\n    \\n    \\n    \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746089,
                "title": "100-beats-sliding-window-intuition-explained-one-pass-o-1-space",
                "content": "# Intuition\\nOk so let\\'s look at this. IF we are standing at a valid index i, we know there will be k elements to the left and k elements to the right of this index.\\nNow when we shift the index from i->i+1 what will happen? EXACTLY 1 element from the left window will go out and exactly 1 element will be added to the left window. Similarly for the right window. \\nSo if we track what indexes were invalid in the left and right window and update this as we shift(4 checks, 1 for idx going out of left window, 1 for idx coming to left window, 1 for idx going out of right window, and 1 idx for entering right window) we can always know when standing at index if it\\'s right and left window our valid or not.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1) (Not counting the result to return)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size(),linv=0,rinv=0;\\n        vector<int> res;\\n        if(n<2*k + 1)\\n            return res;\\n        //Calculate the invalid in the left window\\n        for(int i=0;i<k-1;i++)\\n            if(nums[i] - nums[i+1] < 0) ++linv;\\n        \\n        //Calculate the invalid in the right window\\n        for(int i=k+1;i<2*k;i++)\\n            if(nums[i] - nums[i+1] > 0) ++rinv;\\n        \\n        //Now whenenever we shift an index, our window will be shifted \\n        // by EXACTLY 1 place both in the left and the right side, so\\n        //do the following for both : Check if the index going out of the window \\n        //was invalid or not. Now check if the element being added to the\\n        //window is making it invalid or not.\\n        for(int i=k;i<n-k;i++){\\n            if(i>k){\\n                int lefti = i-k-1,righti = righti = i+k-1;\\n                //Check left window\\n                if(nums[lefti]-nums[lefti+1] < 0) --linv;\\n                if(nums[i-1-1]-nums[i-1] < 0) ++linv;\\n                //Check right window\\n                if(nums[righti] - nums[righti+1] > 0) ++rinv;\\n                if(nums[i] - nums[i+1] > 0) --rinv;\\n            }\\n            if(rinv==0 and linv==0)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size(),linv=0,rinv=0;\\n        vector<int> res;\\n        if(n<2*k + 1)\\n            return res;\\n        //Calculate the invalid in the left window\\n        for(int i=0;i<k-1;i++)\\n            if(nums[i] - nums[i+1] < 0) ++linv;\\n        \\n        //Calculate the invalid in the right window\\n        for(int i=k+1;i<2*k;i++)\\n            if(nums[i] - nums[i+1] > 0) ++rinv;\\n        \\n        //Now whenenever we shift an index, our window will be shifted \\n        // by EXACTLY 1 place both in the left and the right side, so\\n        //do the following for both : Check if the index going out of the window \\n        //was invalid or not. Now check if the element being added to the\\n        //window is making it invalid or not.\\n        for(int i=k;i<n-k;i++){\\n            if(i>k){\\n                int lefti = i-k-1,righti = righti = i+k-1;\\n                //Check left window\\n                if(nums[lefti]-nums[lefti+1] < 0) --linv;\\n                if(nums[i-1-1]-nums[i-1] < 0) ++linv;\\n                //Check right window\\n                if(nums[righti] - nums[righti+1] > 0) ++rinv;\\n                if(nums[i] - nums[i+1] > 0) --rinv;\\n            }\\n            if(rinv==0 and linv==0)\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706936,
                "title": "solution-driven-from-hint",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> LR(n),RL(n);\\n        LR[0]=0;\\n        LR[1]=1;\\n        for(int i=2;i<n;i++)\\n        {\\n            if(nums[i-2]>=nums[i-1])\\n            LR[i]=LR[i-1]+1;\\n            else\\n            LR[i]=1;\\n        }\\n        RL[n-1]=0;\\n        RL[n-2]=1;\\n        for(int i=n-3;i>=0;i--)\\n        {\\n            if(nums[i+2]>=nums[i+1])\\n            RL[i]=RL[i+1]+1;\\n            else\\n            RL[i]=1;\\n        }\\n        vector<int> ans;\\n        for(int i=k;i<n-k;i++)\\n        {\\n            if(LR[i]>=k&&RL[i]>=k)\\n            ans.push_back(i);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> LR(n),RL(n);\\n        LR[0]=0;\\n        LR[1]=1;\\n        for(int i=2;i<n;i++)\\n        {\\n            if(nums[i-2]>=nums[i-1])\\n            LR[i]=LR[i-1]+1;\\n            else\\n            LR[i]=1;\\n        }\\n        RL[n-1]=0;\\n        RL[n-2]=1;\\n        for(int i=n-3;i>=0;i--)\\n        {\\n            if(nums[i+2]>=nums[i+1])\\n            RL[i]=RL[i+1]+1;\\n            else\\n            RL[i]=1;\\n        }\\n        vector<int> ans;\\n        for(int i=k;i<n-k;i++)\\n        {\\n            if(LR[i]>=k&&RL[i]>=k)\\n            ans.push_back(i);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678785,
                "title": "intervals",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind out nonincreasing intervals and nondecreasing intervals.\\nFor an index i, i is good if [i-k, i] is in the nonincreasing list and [i+1, i+k+1] is in the nondecreasing list. \\n\\n# Code\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n\\n        if k == 1:\\n            return list(range(1, n-1))\\n\\n        nd = []\\n        ni = []\\n\\n        for i in range(1, n):\\n            if nums[i] > nums[i-1]:\\n                nd.append(i)\\n            elif nums[i] < nums[i-1]:\\n                ni.append(i)\\n            else:\\n                ni.append(i)\\n                nd.append(i)\\n\\n        ni.append(n+1)\\n        nd.append(n+1)\\n        prev = nd[0]\\n        L1 = []\\n        \\n        for i in range(1, len(nd)):\\n            if nd[i] - nd[i-1] > 1:\\n                L1.append((prev-1, nd[i-1]+1))\\n                prev = nd[i]\\n\\n        prev = ni[0]\\n        L2 = []\\n\\n        for i in range(1, len(ni)):\\n            if ni[i] - ni[i-1] > 1:\\n                L2.append((prev-1, ni[i-1]+1))\\n                prev = ni[i]\\n\\n        def contain(sl, sr, l, r):\\n            return sl >= l and sr <= r\\n\\n        ret = []\\n\\n        for i in range(k, n-k):\\n            if any(contain(i-k, i, l, r) for l, r in L2) and any(contain(i+1, i+k+1, l, r) for l, r in L1):\\n                ret.append(i)\\n        \\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n\\n        if k == 1:\\n            return list(range(1, n-1))\\n\\n        nd = []\\n        ni = []\\n\\n        for i in range(1, n):\\n            if nums[i] > nums[i-1]:\\n                nd.append(i)\\n            elif nums[i] < nums[i-1]:\\n                ni.append(i)\\n            else:\\n                ni.append(i)\\n                nd.append(i)\\n\\n        ni.append(n+1)\\n        nd.append(n+1)\\n        prev = nd[0]\\n        L1 = []\\n        \\n        for i in range(1, len(nd)):\\n            if nd[i] - nd[i-1] > 1:\\n                L1.append((prev-1, nd[i-1]+1))\\n                prev = nd[i]\\n\\n        prev = ni[0]\\n        L2 = []\\n\\n        for i in range(1, len(ni)):\\n            if ni[i] - ni[i-1] > 1:\\n                L2.append((prev-1, ni[i-1]+1))\\n                prev = ni[i]\\n\\n        def contain(sl, sr, l, r):\\n            return sl >= l and sr <= r\\n\\n        ret = []\\n\\n        for i in range(k, n-k):\\n            if any(contain(i-k, i, l, r) for l, r in L2) and any(contain(i+1, i+k+1, l, r) for l, r in L1):\\n                ret.append(i)\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605778,
                "title": "simple-o-n-solution-using-2-array-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSave the increasing and decreasing order and number of elements involved in array and then use it to find indexes which satisfy the given conditions .\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        if(k == 1){\\n            vector<int> ans;\\n            for(int i=1;i<nums.size()-1;i++) ans.push_back(i);\\n            return ans;\\n        }\\n        vector<int> inc(nums.size(),1) , dec(nums.size(),1);\\n        // now we will fill dec\\n        for(int i=1;i<nums.size();i++){\\n            dec[i] = (nums[i-1] >= nums[i] ? dec[i-1]+1 : 1);\\n        }\\n        // Now for increasing order but from behind\\n        for(int i=nums.size()-2;i>=0;i--){\\n            inc[i] = (nums[i] <= nums[i+1] ? inc[i+1]+1 : 1);\\n        }\\n        vector<int> ans;\\n        for(int i=k;i<nums.size()-k;i++){\\n            if(dec[i-1] >= k && inc[i+1] >= k) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        if(k == 1){\\n            vector<int> ans;\\n            for(int i=1;i<nums.size()-1;i++) ans.push_back(i);\\n            return ans;\\n        }\\n        vector<int> inc(nums.size(),1) , dec(nums.size(),1);\\n        // now we will fill dec\\n        for(int i=1;i<nums.size();i++){\\n            dec[i] = (nums[i-1] >= nums[i] ? dec[i-1]+1 : 1);\\n        }\\n        // Now for increasing order but from behind\\n        for(int i=nums.size()-2;i>=0;i--){\\n            inc[i] = (nums[i] <= nums[i+1] ? inc[i+1]+1 : 1);\\n        }\\n        vector<int> ans;\\n        for(int i=k;i<nums.size()-k;i++){\\n            if(dec[i-1] >= k && inc[i+1] >= k) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587543,
                "title": "c-solutiion-simple-easy-awesome",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstatic const auto io_sync_off = [](){\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution{\\npublic:\\n    vector<int> goodIndices(vector<int>& a, int k) {\\n        int n= size(a);\\n        vector<int> dp1(n+1,1),dp2(n+1,1),ans;\\n        \\n        for(int i=1;i<n;i++) \\n            if(a[i-1]>=a[i]) dp1[i]= dp1[i-1]+1;\\n        \\n        for(int i=n-2;i>=0;i--)  \\n            if(a[i]<=a[i+1]) dp2[i]= dp2[i+1]+1;\\n        \\n        for(int i=k;i<n-k;i++) \\n            if(dp1[i-1]>=k && dp2[i+1]>=k) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstatic const auto io_sync_off = [](){\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution{\\npublic:\\n    vector<int> goodIndices(vector<int>& a, int k) {\\n        int n= size(a);\\n        vector<int> dp1(n+1,1),dp2(n+1,1),ans;\\n        \\n        for(int i=1;i<n;i++) \\n            if(a[i-1]>=a[i]) dp1[i]= dp1[i-1]+1;\\n        \\n        for(int i=n-2;i>=0;i--)  \\n            if(a[i]<=a[i+1]) dp2[i]= dp2[i+1]+1;\\n        \\n        for(int i=k;i<n-k;i++) \\n            if(dp1[i-1]>=k && dp2[i+1]>=k) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578584,
                "title": "easiest-clean-code-in-c-prefixsum",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans,prefix_dec(n),prefix_inc(n);\\n        for(int i=1 ; i<n ; i++){    //Calculating decreasing order from left to right\\n            if(nums[i] <= nums[i-1])\\n                prefix_dec[i] = prefix_dec[i-1] + 1;\\n            else\\n                prefix_dec[i] = 0;\\n        }\\n        for(int i=1 ; i<n ; i++){    //Calculating increasing order from left to right\\n            if(nums[i] >= nums[i-1])\\n                prefix_inc[i] = prefix_inc[i-1] + 1;\\n            else\\n                prefix_inc[i] = 0;\\n        }\\n        for(int i=k ; i<n-k ; i++){\\n            if((prefix_dec[i-1] >= k-1) && (prefix_inc[i+k] >= k-1))\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans,prefix_dec(n),prefix_inc(n);\\n        for(int i=1 ; i<n ; i++){    //Calculating decreasing order from left to right\\n            if(nums[i] <= nums[i-1])\\n                prefix_dec[i] = prefix_dec[i-1] + 1;\\n            else\\n                prefix_dec[i] = 0;\\n        }\\n        for(int i=1 ; i<n ; i++){    //Calculating increasing order from left to right\\n            if(nums[i] >= nums[i-1])\\n                prefix_inc[i] = prefix_inc[i-1] + 1;\\n            else\\n                prefix_inc[i] = 0;\\n        }\\n        for(int i=k ; i<n-k ; i++){\\n            if((prefix_dec[i-1] >= k-1) && (prefix_inc[i+k] >= k-1))\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3571547,
                "title": "python3-very-easy-2-for-loops",
                "content": "# Code\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        left, right, res = [0] * (len(nums)), [len(nums) - 1] * (len(nums)), []\\n        for i in range(1, len(nums)):\\n            if nums[i - 1] >= nums[i]:\\n                left[i] = left[i - 1]\\n            else: left[i] = i\\n        for i in range(len(nums) - 2, -1, -1):\\n            if nums[i + 1] >= nums[i]:\\n                right[i] = right[i + 1]\\n            else: right[i] = i\\n        for i in range(k, len(nums) - k):\\n            if i - left[i - 1] >= k and right[i + 1] - i >= k:\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        left, right, res = [0] * (len(nums)), [len(nums) - 1] * (len(nums)), []\\n        for i in range(1, len(nums)):\\n            if nums[i - 1] >= nums[i]:\\n                left[i] = left[i - 1]\\n            else: left[i] = i\\n        for i in range(len(nums) - 2, -1, -1):\\n            if nums[i + 1] >= nums[i]:\\n                right[i] = right[i + 1]\\n            else: right[i] = i\\n        for i in range(k, len(nums) - k):\\n            if i - left[i - 1] >= k and right[i + 1] - i >= k:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541783,
                "title": "using-prefix-and-suffix-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find whether there is a sequence of >=k numbers before i which are in decresing order and therse is a sequence of >=k numbers which are in ascending order.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe just stored the length of descending order till ith index from the beginning and length of ascending order till ith index from the end.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> pref(n,1);\\n        vector<int> suf(n,1);\\n        vector<int> ans;\\n        for(int i=1; i<n; i++){\\n            if(nums[i]<=nums[i-1])\\n                pref[i] += pref[i-1];\\n            \\n        }\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] <= nums[i+1])\\n                suf[i] += suf[i+1];\\n        }\\n        for(int i=k; i<n-k; i++){\\n            if(pref[i-1]>=k && suf[i+1]>=k){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> pref(n,1);\\n        vector<int> suf(n,1);\\n        vector<int> ans;\\n        for(int i=1; i<n; i++){\\n            if(nums[i]<=nums[i-1])\\n                pref[i] += pref[i-1];\\n            \\n        }\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] <= nums[i+1])\\n                suf[i] += suf[i+1];\\n        }\\n        for(int i=k; i<n-k; i++){\\n            if(pref[i-1]>=k && suf[i+1]>=k){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526900,
                "title": "full-handwritten-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intution is that make 2 arrays that will consists of increasing elements and decreasing number of elements till the ith index and than find if there are elements with increasing and decreasing elementsgreater than k.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![WhatsApp Image 2023-05-15 at 16.42.08.jpeg](https://assets.leetcode.com/users/images/da075ab0-9449-4fa8-84db-058bf8e7401b_1684149149.1728332.jpeg)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n=nums.length;\\n        int dec[]=new int[n],inc[]=new int[n];\\n        List<Integer> ans=new ArrayList<Integer>();\\n        \\n        int start=nums[0],end=nums[0];\\n        int len=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<=start) len++;\\n            else len=1;\\n            start=nums[i];\\n            dec[i]=len;\\n        }\\n        len=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]>=end) len++;\\n            else len=1;\\n            end=nums[i];\\n            inc[i]=len;\\n        }\\n        \\n        for(int i=k; i<n-k; i++){\\n            if(dec[i-1]>=k && inc[i+k]>=k) ans.add(i);\\n        }        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n=nums.length;\\n        int dec[]=new int[n],inc[]=new int[n];\\n        List<Integer> ans=new ArrayList<Integer>();\\n        \\n        int start=nums[0],end=nums[0];\\n        int len=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]<=start) len++;\\n            else len=1;\\n            start=nums[i];\\n            dec[i]=len;\\n        }\\n        len=0;\\n        for(int i=0; i<n; i++){\\n            if(nums[i]>=end) len++;\\n            else len=1;\\n            end=nums[i];\\n            inc[i]=len;\\n        }\\n        \\n        for(int i=k; i<n-k; i++){\\n            if(dec[i-1]>=k && inc[i+k]>=k) ans.add(i);\\n        }        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383848,
                "title": "clean-javascript-3-passes-o-n-time-space",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar goodIndices = function(nums, k) {    \\n    const dec = Array(nums.length).fill(1);\\n    const inc = Array(nums.length).fill(1);\\n    const ans = [];\\n    \\n    for(let i = 1; i < nums.length; i++) {\\n        if(nums[i] <= nums[i - 1]) {\\n            dec[i] = dec[i - 1] + 1;\\n        }\\n    }\\n    for(let i = nums.length - 2; i >= 0; i--) {\\n        if(nums[i] <= nums[i + 1]) {\\n            inc[i] = inc[i + 1] + 1;\\n        }\\n    }\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        const prev = dec[i - 1];\\n        const next = inc[i + 1];\\n        if(prev >= k\\xA0&& next >= k) ans.push(i);\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number[]}\\n */\\nvar goodIndices = function(nums, k) {    \\n    const dec = Array(nums.length).fill(1);\\n    const inc = Array(nums.length).fill(1);\\n    const ans = [];\\n    \\n    for(let i = 1; i < nums.length; i++) {\\n        if(nums[i] <= nums[i - 1]) {\\n            dec[i] = dec[i - 1] + 1;\\n        }\\n    }\\n    for(let i = nums.length - 2; i >= 0; i--) {\\n        if(nums[i] <= nums[i + 1]) {\\n            inc[i] = inc[i + 1] + 1;\\n        }\\n    }\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        const prev = dec[i - 1];\\n        const next = inc[i + 1];\\n        if(prev >= k\\xA0&& next >= k) ans.push(i);\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3345287,
                "title": "python3-dp-approach",
                "content": "# Intuition\\nWe could define for each index number of elements prior to it in non-increasing order, and number of elements past it in non-decreasing order. \\nAnd then we can just check for each index ``i`` if both of those numbers are at least ``k``\\n\\n# Approach\\n1. Initialize ``non_increasing`` and ``non_decreasing`` arrays with ones\\n2. Traverse ``nums`` forward and for each two consequence elements check if they maintain non-increasing order. If yes, then assing ``non_increasing[i] = non_increasing[i-1] + 1``.\\n3. Traverse ``num`` backwards to fill ``non_decreasing`` array in a similar way\\n4. For each index ``i`` check the condition mentioned above\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        non_increasing, non_decreasing = [1] * n, [1] * n\\n        for i in range(1, n):\\n            if nums[i-1] >= nums[i]:\\n                non_increasing[i] = non_increasing[i-1] + 1\\n        for i in range(n-2, 0, -1):\\n            if nums[i+1] >= nums[i]:\\n                non_decreasing[i] = non_decreasing[i+1] + 1\\n        return [i for i in range(1, n-1) if non_increasing[i-1] >= k and non_decreasing[i+1] >= k]\\n```\\n\\n\\nShall you have any questions - I would be glad to answer, \\nand if you like this approach please upvote! \\n\\nThanks!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        non_increasing, non_decreasing = [1] * n, [1] * n\\n        for i in range(1, n):\\n            if nums[i-1] >= nums[i]:\\n                non_increasing[i] = non_increasing[i-1] + 1\\n        for i in range(n-2, 0, -1):\\n            if nums[i+1] >= nums[i]:\\n                non_decreasing[i] = non_decreasing[i+1] + 1\\n        return [i for i in range(1, n-1) if non_increasing[i-1] >= k and non_decreasing[i+1] >= k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336319,
                "title": "c-prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        vector<int> pref(n);\\n        vector<int> suff(n);\\n        pref[0] = 1;\\n        suff[n-1] = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            pref[i] = pref[i-1]+1;\\n            else\\n            pref[i] = 1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            suff[i] = suff[i+1]+1;\\n            else\\n            suff[i] = 1;\\n        }\\n        for(int i=k;i<n-k;i++)\\n        {\\n            if(pref[i-1]>=k && suff[i+1]>=k)\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        vector<int> pref(n);\\n        vector<int> suff(n);\\n        pref[0] = 1;\\n        suff[n-1] = 1;\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]<=nums[i-1])\\n            pref[i] = pref[i-1]+1;\\n            else\\n            pref[i] = 1;\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<=nums[i+1])\\n            suff[i] = suff[i+1]+1;\\n            else\\n            suff[i] = 1;\\n        }\\n        for(int i=k;i<n-k;i++)\\n        {\\n            if(pref[i-1]>=k && suff[i+1]>=k)\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323265,
                "title": "compact-js-ts",
                "content": "# Intuition\\nI tried to solve it with stacks at first, but then realized they\\'re not needed? \\n\\n# Approach\\nCount the length of the valid intervals before and after. Check the current value against last known value. As we cross k iterations, we can check if the intervals are of at least k length. If we break the rule, the count is reset. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$? the result though could be $$O(n)$$ dunno\\n\\n# Code\\n```\\nfunction goodIndices(nums: number[], k: number): number[] {\\n    const res:number[] = []\\n    let [lpr,lpo,cpr,cpo] = [-Infinity,Infinity,0,0]\\n    for ( let i = 0 ; i < nums.length - k - 1 ; i ++ ) {\\n        const [prn,pon] = [nums[i],nums[i+k+1]]\\n        if(prn>lpr) cpr = 0\\n        if(pon<lpo) cpo = 0\\n        lpr = prn\\n        lpo = pon\\n        cpr++\\n        cpo++\\n        if(cpr>=k && cpo>=k) res.push(i+1)\\n    }\\n    return res\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction goodIndices(nums: number[], k: number): number[] {\\n    const res:number[] = []\\n    let [lpr,lpo,cpr,cpo] = [-Infinity,Infinity,0,0]\\n    for ( let i = 0 ; i < nums.length - k - 1 ; i ++ ) {\\n        const [prn,pon] = [nums[i],nums[i+k+1]]\\n        if(prn>lpr) cpr = 0\\n        if(pon<lpo) cpo = 0\\n        lpr = prn\\n        lpo = pon\\n        cpr++\\n        cpo++\\n        if(cpr>=k && cpo>=k) res.push(i+1)\\n    }\\n    return res\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3293044,
                "title": "precompute-dp-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> v;\\n        vector<int> dp1(n+1,1);\\n        vector<int> dp2(n+1,1);\\n        for(int i=1;i<n;i++)\\n        {\\n        if(nums[i-1] >= nums[i])\\n        {\\n            dp1[i]=dp1[i-1]+1;\\n        }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i] <= nums[i+1])\\n            {\\n            dp2[i]= dp2[i+1]+1;\\n            }\\n        }\\n        for(int i=k;i<n-k;i++)\\n        {\\n            if(dp1[i-1] >=k && dp2[i+1] >=k) v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> v;\\n        vector<int> dp1(n+1,1);\\n        vector<int> dp2(n+1,1);\\n        for(int i=1;i<n;i++)\\n        {\\n        if(nums[i-1] >= nums[i])\\n        {\\n            dp1[i]=dp1[i-1]+1;\\n        }\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            if(nums[i] <= nums[i+1])\\n            {\\n            dp2[i]= dp2[i+1]+1;\\n            }\\n        }\\n        for(int i=k;i<n-k;i++)\\n        {\\n            if(dp1[i-1] >=k && dp2[i+1] >=k) v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272810,
                "title": "intuitive-python3-o-n-solution",
                "content": "# Intuition\\nFor each index ```j```, keep track of the leftmost index ```i``` such that ```nums[i:j+1]``` is non increasing or non decreasing.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        non_inc_from = [i for i in range(n)]\\n        non_dec_from = [i for i in range(n)]\\n\\n        for i in range(1, n):\\n            if nums[i-1] >= nums[i]:\\n                non_inc_from[i] = min(i-1, non_inc_from[i-1])\\n            if nums[i-1] <= nums[i]:\\n                non_dec_from[i] = min(i-1, non_dec_from[i-1])\\n\\n        res = []\\n        for i in range(k, n-k):\\n            if non_inc_from[i-1] <= i-k and non_dec_from[i+k] <= i+1:\\n                res.append(i)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```j```\n```i```\n```nums[i:j+1]```\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        non_inc_from = [i for i in range(n)]\\n        non_dec_from = [i for i in range(n)]\\n\\n        for i in range(1, n):\\n            if nums[i-1] >= nums[i]:\\n                non_inc_from[i] = min(i-1, non_inc_from[i-1])\\n            if nums[i-1] <= nums[i]:\\n                non_dec_from[i] = min(i-1, non_dec_from[i-1])\\n\\n        res = []\\n        for i in range(k, n-k):\\n            if non_inc_from[i-1] <= i-k and non_dec_from[i+k] <= i+1:\\n                res.append(i)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271499,
                "title": "c-easy-to-understand-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> left(n,1);\\n        vector<int> right(n,1);\\n        int prev = nums[0];\\n        // keep tracking on running sequence of decreasing order left to right\\n        for (int i = 1; i < n; i++) {\\n            if (prev >= nums[i]) {\\n                left[i] += left[i-1];\\n            }\\n            prev = nums[i];\\n        }\\n        \\n        prev = nums[n-1];\\n        // keep tracking on running sequence of decreasing order right to left\\n        for (int i = n-2; i >= 0 ; i--) {\\n            if (prev >= nums[i]) {\\n                right[i] += right[i+1];\\n            }\\n            prev = nums[i];\\n        }\\n        \\n        // For each index compute the result\\n        vector<int> result;\\n        for (int i = k; i < (n-k); i++) {\\n            if ((left[i-1] >= k) && (right[i+1] >= k))\\n                result.push_back(i);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> left(n,1);\\n        vector<int> right(n,1);\\n        int prev = nums[0];\\n        // keep tracking on running sequence of decreasing order left to right\\n        for (int i = 1; i < n; i++) {\\n            if (prev >= nums[i]) {\\n                left[i] += left[i-1];\\n            }\\n            prev = nums[i];\\n        }\\n        \\n        prev = nums[n-1];\\n        // keep tracking on running sequence of decreasing order right to left\\n        for (int i = n-2; i >= 0 ; i--) {\\n            if (prev >= nums[i]) {\\n                right[i] += right[i+1];\\n            }\\n            prev = nums[i];\\n        }\\n        \\n        // For each index compute the result\\n        vector<int> result;\\n        for (int i = k; i < (n-k); i++) {\\n            if ((left[i-1] >= k) && (right[i+1] >= k))\\n                result.push_back(i);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3264230,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> result = new ArrayList<>();\\n\\n        for(int i = 1; i < nums.length-1; i++) {\\n            if(k <= i && i < nums.length-k) {\\n                if(k == 1) {\\n                    result.add(i);\\n                } else if(result.size() > 0 && result.get(result.size()-1) == i-1) {\\n                    if(i+k < nums.length && nums[i+k-1] <= nums[i+k]\\n                        && nums[i-2] >= nums[i-1]) {\\n                            result.add(i);\\n                    }\\n                } else if(isNonIncreasing(nums,i-k ,i-1 ) && isNonDecreasing(nums, i+1, i+k)) {\\n                    result.add(i);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    boolean isNonIncreasing(int[] arr, int si, int ei) {\\n        if(si < 0 || ei >= arr.length) {\\n            return false;\\n        }\\n        for(int i = si+1; i <= ei; i++) {\\n            if(arr[i-1] < arr[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    boolean isNonDecreasing(int[] arr, int si, int ei) {\\n        if(si < 0 || ei >= arr.length) {\\n            return false;\\n        }\\n        for(int i = si+1; i <= ei; i++) {\\n            if(arr[i-1] > arr[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        List<Integer> result = new ArrayList<>();\\n\\n        for(int i = 1; i < nums.length-1; i++) {\\n            if(k <= i && i < nums.length-k) {\\n                if(k == 1) {\\n                    result.add(i);\\n                } else if(result.size() > 0 && result.get(result.size()-1) == i-1) {\\n                    if(i+k < nums.length && nums[i+k-1] <= nums[i+k]\\n                        && nums[i-2] >= nums[i-1]) {\\n                            result.add(i);\\n                    }\\n                } else if(isNonIncreasing(nums,i-k ,i-1 ) && isNonDecreasing(nums, i+1, i+k)) {\\n                    result.add(i);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n\\n    boolean isNonIncreasing(int[] arr, int si, int ei) {\\n        if(si < 0 || ei >= arr.length) {\\n            return false;\\n        }\\n        for(int i = si+1; i <= ei; i++) {\\n            if(arr[i-1] < arr[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    boolean isNonDecreasing(int[] arr, int si, int ei) {\\n        if(si < 0 || ei >= arr.length) {\\n            return false;\\n        }\\n        for(int i = si+1; i <= ei; i++) {\\n            if(arr[i-1] > arr[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246091,
                "title": "c-easy-dp",
                "content": "\\n\\n# Code\\n```\\nstatic const auto io_sync_off = [](){\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution{\\npublic:\\n    vector<int> goodIndices(vector<int>& a, int k) {\\n        int n= size(a);\\n        vector<int> dp1(n+1,1),dp2(n+1,1),ans;\\n        \\n        for(int i=1;i<n;i++) \\n            if(a[i-1]>=a[i]) dp1[i]= dp1[i-1]+1;\\n        \\n        for(int i=n-2;i>=0;i--)  \\n            if(a[i]<=a[i+1]) dp2[i]= dp2[i+1]+1;\\n        \\n        for(int i=k;i<n-k;i++) \\n            if(dp1[i-1]>=k && dp2[i+1]>=k) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstatic const auto io_sync_off = [](){\\n    std::ios::sync_with_stdio(false);\\n    std::cin.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution{\\npublic:\\n    vector<int> goodIndices(vector<int>& a, int k) {\\n        int n= size(a);\\n        vector<int> dp1(n+1,1),dp2(n+1,1),ans;\\n        \\n        for(int i=1;i<n;i++) \\n            if(a[i-1]>=a[i]) dp1[i]= dp1[i-1]+1;\\n        \\n        for(int i=n-2;i>=0;i--)  \\n            if(a[i]<=a[i+1]) dp2[i]= dp2[i+1]+1;\\n        \\n        for(int i=k;i<n-k;i++) \\n            if(dp1[i-1]>=k && dp2[i+1]>=k) ans.push_back(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221272,
                "title": "python-simplified-one-pass-dp-with-explanation",
                "content": "# Intuition\\nInstead of pre-computing the non-increasing and non-decreasing subarray lengths using 2 passes, we can keep track of the lengths of the longest non-increasing subarray that ends at each previous index (`ni`) and the length of the longest non-decreasing subarray that ends at the current index (`non_decreasing`) in a single forward pass. If a non-decreasing subarray ends at a certain index `i` with length greater than or equal to `k`, index `i-k` is a possible solution. If the length of the longest non-increasing subarray ending one index to the left of index `i-k` (`ni[i-(k+1)]`) is greater than or equal to `k`, then index `i-k` is indeed a solution.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Compute the longest non-increasing and non-decreasing subarray lengths that end at the current index (`non_increasing` and `non_decreasing`)\\n2. Store the length of the current longest non-increasing subarray `non_increasing` in array `ni` so we can check it later when finding an index with `non_decreasing >= k`\\n3. If index `i` is the end of a non-decreasing subarray with length greater than or equal to `k` (`non-decreasing >= k`), then index `i-k` is a possible solution. If the length of the non-increasing subarray ending 1 index to the left of index `i-k` is greater than or equal to `k` (`ni[i-(k+1)] >= k`), then index `i-k` is a solution.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def goodIndices(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        ni = [1]\\n        non_increasing = 1\\n        non_decreasing = 1\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] == nums[i-1]:\\n                non_increasing += 1\\n                non_decreasing += 1\\n            elif nums[i] < nums[i-1]:\\n                non_increasing += 1\\n                non_decreasing = 1\\n            else:\\n                non_decreasing += 1\\n                non_increasing = 1\\n            ni.append(non_increasing)\\n\\n            if i > k*2-1:\\n                if ni[i-(k+1)] >= k and non_decreasing >= k:\\n                    res.append(i-k)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution(object):\\n    def goodIndices(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        res = []\\n        ni = [1]\\n        non_increasing = 1\\n        non_decreasing = 1\\n\\n        for i in range(1, len(nums)):\\n            if nums[i] == nums[i-1]:\\n                non_increasing += 1\\n                non_decreasing += 1\\n            elif nums[i] < nums[i-1]:\\n                non_increasing += 1\\n                non_decreasing = 1\\n            else:\\n                non_decreasing += 1\\n                non_increasing = 1\\n            ni.append(non_increasing)\\n\\n            if i > k*2-1:\\n                if ni[i-(k+1)] >= k and non_decreasing >= k:\\n                    res.append(i-k)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188464,
                "title": "simple-c-pre-computing-left-and-right-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& a, int k) {\\n        int n=a.size(),i;\\n        vector<long long>left(n,1);\\n        vector<int>ans;\\n        vector<long long>right(n,1);\\n        for(i=1;i<n;i++){\\n            if(a[i]<=a[i-1]) left[i]+=left[i-1];\\n        }\\n        for(i=n-2;i>=0;i--){\\n            if(a[i]<=a[i+1]) right[i]+=right[i+1];\\n        }\\n        for(i=k;i<n-k;i++){\\n            if(left[i-1]>=k&&right[i+1]>=k) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& a, int k) {\\n        int n=a.size(),i;\\n        vector<long long>left(n,1);\\n        vector<int>ans;\\n        vector<long long>right(n,1);\\n        for(i=1;i<n;i++){\\n            if(a[i]<=a[i-1]) left[i]+=left[i-1];\\n        }\\n        for(i=n-2;i>=0;i--){\\n            if(a[i]<=a[i+1]) right[i]+=right[i+1];\\n        }\\n        for(i=k;i<n-k;i++){\\n            if(left[i-1]>=k&&right[i+1]>=k) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186125,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        int [] left = new int[n];\\n        int [] right = new int[n];\\n\\n        left[0] = 1;\\n\\n        for(int i = 1; i < n; i++){\\n            if(nums[i - 1] < nums[i]){\\n                left[i] = 1;\\n            } else {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n\\n        right[n - 1] = 1;\\n        for(int i = n - 2; i >= 0; i--){\\n            if(nums[i + 1] < nums[i]){\\n                right[i] = 1;\\n            } else {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n        List<Integer> al = new ArrayList<>();\\n        for(int i = k; i < n - k; i++){\\n            if(left[i - 1] >= k && right[i + 1] >= k){\\n                al.add(i);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        int [] left = new int[n];\\n        int [] right = new int[n];\\n\\n        left[0] = 1;\\n\\n        for(int i = 1; i < n; i++){\\n            if(nums[i - 1] < nums[i]){\\n                left[i] = 1;\\n            } else {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n\\n        right[n - 1] = 1;\\n        for(int i = n - 2; i >= 0; i--){\\n            if(nums[i + 1] < nums[i]){\\n                right[i] = 1;\\n            } else {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n        List<Integer> al = new ArrayList<>();\\n        for(int i = k; i < n - k; i++){\\n            if(left[i - 1] >= k && right[i + 1] >= k){\\n                al.add(i);\\n            }\\n        }\\n        return al;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165683,
                "title": "c-two-pass-o-n-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe object is to find i such that k elements before are non-increasing, and k elements after are non-decreasing. We can find all index that have at least k elements before are non-increasing. And find all index that have at least k elements after are non-decreasing. The intersection will be the answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWrite a function to find all index that has at least k preceding non-inceasing. And another function to find the non-decreasing. Then return the intersection.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTotally two passes are done.\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        auto fall = falling(nums, k);\\n        auto rise = rising(nums, k);\\n        vector<int> res;\\n        for(int i = 0; i< nums.size(); ++i){\\n            if(fall[i] && rise[i])\\n                res.emplace_back(i);\\n        }\\n        return res;\\n    }\\n\\n    vector<int> falling(vector<int>& num, int k){\\n        vector<int> res(num.size(),0);\\n        int falling_count = 1;\\n        for(int i = 1; i< num.size(); ++i){\\n            if(falling_count >= k) res[i] = 1;\\n            if(num[i]<=num[i-1]) falling_count++;\\n            else falling_count = 1;\\n        }\\n        return res;\\n    }\\n    vector<int> rising(vector<int>& num, int k){\\n        vector<int> res(num.size(),0);\\n        int rising_count = 1;\\n        for(int i = num.size()-2; i>=0; --i){\\n            if(rising_count >= k) res[i] = 1;\\n            if(num[i]<=num[i+1]) rising_count++;\\n            else rising_count = 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        auto fall = falling(nums, k);\\n        auto rise = rising(nums, k);\\n        vector<int> res;\\n        for(int i = 0; i< nums.size(); ++i){\\n            if(fall[i] && rise[i])\\n                res.emplace_back(i);\\n        }\\n        return res;\\n    }\\n\\n    vector<int> falling(vector<int>& num, int k){\\n        vector<int> res(num.size(),0);\\n        int falling_count = 1;\\n        for(int i = 1; i< num.size(); ++i){\\n            if(falling_count >= k) res[i] = 1;\\n            if(num[i]<=num[i-1]) falling_count++;\\n            else falling_count = 1;\\n        }\\n        return res;\\n    }\\n    vector<int> rising(vector<int>& num, int k){\\n        vector<int> res(num.size(),0);\\n        int rising_count = 1;\\n        for(int i = num.size()-2; i>=0; --i){\\n            if(rising_count >= k) res[i] = 1;\\n            if(num[i]<=num[i+1]) rising_count++;\\n            else rising_count = 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164481,
                "title": "prefix-suffix-array-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nu, int k) {\\n        int n=nu.size();\\n        vector<int>l(n,0);\\n        vector<int>r(n,0);\\n        l[0]=1;\\n        r[n-1]=1;\\n        for(int i=1;i<n;i++){\\n            if(nu[i]<=nu[i-1])\\n            l[i]=1+l[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(nu[i]<=nu[i+1])\\n            r[i]=1+r[i+1];\\n        }\\n        vector<int>v;\\n        for(int i=k;i<n-k;i++){\\n            if(l[i-1]>=k-1 && r[i+1]>=k-1)\\n            v.push_back(i);\\n        }\\n        return v;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nu, int k) {\\n        int n=nu.size();\\n        vector<int>l(n,0);\\n        vector<int>r(n,0);\\n        l[0]=1;\\n        r[n-1]=1;\\n        for(int i=1;i<n;i++){\\n            if(nu[i]<=nu[i-1])\\n            l[i]=1+l[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            if(nu[i]<=nu[i+1])\\n            r[i]=1+r[i+1];\\n        }\\n        vector<int>v;\\n        for(int i=k;i<n-k;i++){\\n            if(l[i-1]>=k-1 && r[i+1]>=k-1)\\n            v.push_back(i);\\n        }\\n        return v;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153257,
                "title": "c-golang-dp-prefix-sum",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> DP(n, 1);\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(nums[i] <= nums[i + 1])\\n                DP[i] = DP[i + 1] + 1;\\n        }\\n        int count = 1;\\n        vector<int> ans;\\n        for(int i = 1; i < n - 1; i++) {\\n            if(count >= k && DP[i + 1] >= k) ans.push_back(i);\\n            if(nums[i] <= nums[i - 1]) \\n                count++;\\n            else\\n                count = 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Golang\\nfunc goodIndices(nums []int, k int) []int {\\n    var n int = len(nums)\\n    DP := make([]int, n)\\n    DP[n - 1] = 1\\n    for i := n - 2; i >= 0; i-- {\\n        if nums[i] <= nums[i + 1] {\\n            DP[i] = DP[i + 1] + 1\\n        } else {\\n            DP[i] = 1\\n        }\\n    }\\n    var count int = 1\\n    ans := []int{}\\n    for i := 1; i < n - 1; i++ {\\n        if count >= k && DP[i + 1] >= k {\\n            ans = append(ans, i)\\n        }\\n        if nums[i] <= nums[i - 1] {\\n            count++\\n        } else {\\n            count = 1\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> DP(n, 1);\\n        for(int i = n - 2; i >= 0; i--) {\\n            if(nums[i] <= nums[i + 1])\\n                DP[i] = DP[i + 1] + 1;\\n        }\\n        int count = 1;\\n        vector<int> ans;\\n        for(int i = 1; i < n - 1; i++) {\\n            if(count >= k && DP[i + 1] >= k) ans.push_back(i);\\n            if(nums[i] <= nums[i - 1]) \\n                count++;\\n            else\\n                count = 1;\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Golang\\nfunc goodIndices(nums []int, k int) []int {\\n    var n int = len(nums)\\n    DP := make([]int, n)\\n    DP[n - 1] = 1\\n    for i := n - 2; i >= 0; i-- {\\n        if nums[i] <= nums[i + 1] {\\n            DP[i] = DP[i + 1] + 1\\n        } else {\\n            DP[i] = 1\\n        }\\n    }\\n    var count int = 1\\n    ans := []int{}\\n    for i := 1; i < n - 1; i++ {\\n        if count >= k && DP[i + 1] >= k {\\n            ans = append(ans, i)\\n        }\\n        if nums[i] <= nums[i - 1] {\\n            count++\\n        } else {\\n            count = 1\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145419,
                "title": "c-using-two-prefix-sum-array-dp-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmake two dp array one for decreasing subarray and other for increasing subarray.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthink of prefix approach similar to caden\\'s algo.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& v, int k) {\\n        int n = v.size(),ct=1;    \\n        vector<int> v2(n,0),dec(n,1),inc(n,1),ans;\\n            v2[0] = v[0];\\n            for(int i=1;i<n;++i)\\n            {\\n                    v2[i] = v[i-1] - v[i];\\n            }\\n            for(int i=1;i<n;++i)\\n            {\\n                    if(v2[i]>=0)\\n                    {\\n                            ct++;\\n                            dec[i] = ct;  \\n                    }\\n                    else\\n                            ct=1;       \\n            }\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                    v2[i] = v[i] - v[i+1];\\n            }\\n            ct=1;\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                    if(v2[i]<=0)\\n                    {\\n                            ct++; inc[i] = ct;     \\n                    }\\n                    else\\n                            ct=1;      \\n            }\\n           \\n            for(int i=k;i<n-k;++i)\\n            {\\n                    if(inc[i+1]>=k && dec[i-1]>=k)\\n                            ans.push_back(i);\\n            }\\n            sort(ans.begin(),ans.end());\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& v, int k) {\\n        int n = v.size(),ct=1;    \\n        vector<int> v2(n,0),dec(n,1),inc(n,1),ans;\\n            v2[0] = v[0];\\n            for(int i=1;i<n;++i)\\n            {\\n                    v2[i] = v[i-1] - v[i];\\n            }\\n            for(int i=1;i<n;++i)\\n            {\\n                    if(v2[i]>=0)\\n                    {\\n                            ct++;\\n                            dec[i] = ct;  \\n                    }\\n                    else\\n                            ct=1;       \\n            }\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                    v2[i] = v[i] - v[i+1];\\n            }\\n            ct=1;\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                    if(v2[i]<=0)\\n                    {\\n                            ct++; inc[i] = ct;     \\n                    }\\n                    else\\n                            ct=1;      \\n            }\\n           \\n            for(int i=k;i<n-k;++i)\\n            {\\n                    if(inc[i+1]>=k && dec[i-1]>=k)\\n                            ans.push_back(i);\\n            }\\n            sort(ans.begin(),ans.end());\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132878,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        vector<int>l(n,1);\\n        vector<int>r(n,1);\\n        for (int i=1;i<n;i++)\\n        {\\n            if (nums[i-1]>=nums[i])\\n            {\\n                l[i]=l[i-1]+1;\\n            }\\n        }\\n        for (int i=n-2;i>=0;i--)\\n        {\\n            if (nums[i]<=nums[i+1])\\n            {\\n                r[i]=r[i+1]+1;\\n            }\\n        }\\n        vector<int>ans;\\n        \\n        for (int i=1;i<n-1;i++)\\n        {\\n            if (l[i-1]>=k && r[i+1]>=k)\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        vector<int>l(n,1);\\n        vector<int>r(n,1);\\n        for (int i=1;i<n;i++)\\n        {\\n            if (nums[i-1]>=nums[i])\\n            {\\n                l[i]=l[i-1]+1;\\n            }\\n        }\\n        for (int i=n-2;i>=0;i--)\\n        {\\n            if (nums[i]<=nums[i+1])\\n            {\\n                r[i]=r[i+1]+1;\\n            }\\n        }\\n        vector<int>ans;\\n        \\n        for (int i=1;i<n-1;i++)\\n        {\\n            if (l[i-1]>=k && r[i+1]>=k)\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056798,
                "title": "o-n-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int> pre(nums.size(), 0);\\n        vector<int> after(nums.size(), 0);\\n\\n        for(int i=0;i<nums.size();i++) {\\n            if(i>0 && nums[i]<=nums[i-1]) {\\n                pre[i] = pre[i-1]-1;\\n            }else {\\n                pre[i] = -1;\\n            }\\n        }\\n\\n        for(int i=nums.size()-1;i>=0;i--) {\\n            if(i!=nums.size()-1 && nums[i]<=nums[i+1]) {\\n                after[i] = after[i+1]-1;\\n            }else {\\n                after[i] = -1;\\n            }\\n        }\\n        vector<int> res;\\n        for(int i=k;i<nums.size()-k;i++) {\\n            if(abs(pre[i-1])>=k && abs(after[i+1])>=k) {\\n                res.push_back(i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int> pre(nums.size(), 0);\\n        vector<int> after(nums.size(), 0);\\n\\n        for(int i=0;i<nums.size();i++) {\\n            if(i>0 && nums[i]<=nums[i-1]) {\\n                pre[i] = pre[i-1]-1;\\n            }else {\\n                pre[i] = -1;\\n            }\\n        }\\n\\n        for(int i=nums.size()-1;i>=0;i--) {\\n            if(i!=nums.size()-1 && nums[i]<=nums[i+1]) {\\n                after[i] = after[i+1]-1;\\n            }else {\\n                after[i] = -1;\\n            }\\n        }\\n        vector<int> res;\\n        for(int i=k;i<nums.size()-k;i++) {\\n            if(abs(pre[i-1])>=k && abs(after[i+1])>=k) {\\n                res.push_back(i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994545,
                "title": "1-pass-solution-sliding-window",
                "content": "# Keypoint\\n1. Sliding window: slide the window `[i-k, i+k]`. If there is no increasing order before i and no decreasing order after i, then i is a good index.\\n2. count increasing-order before i and decreasing-order after i. When the window slides to right, we should update `#increasing` and `#decreasing` accordingly.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        if k == 1: return [i for i in range(1, n-1)]\\n        dec, inc = 0, 0\\n        ans = []\\n        for i in range(n):\\n            # newly added left order (i-2, i-1)\\n            if i -2 >= 0 and nums[i-2] < nums[i-1]: inc += 1\\n            # removed left most window edge (i-k-1, i-k)\\n            if i-k-1 >= 0 and nums[i-k-1] < nums[i-k]: inc -= 1\\n            # remove right order (i, i+1)\\n            if i >= k-1 and i + 1 < n and nums[i] > nums[i+1]: dec -= 1\\n            # add right most window edge (i+k-1, i+k)\\n            if i + k < n and nums[i+k-1] > nums[i+k]: dec += 1\\n            # print(inc, dec) \\n            if k <= i  and i < n - k and dec == 0 and inc == 0: ans.append(i)\\n\\n        return sorted(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        if k == 1: return [i for i in range(1, n-1)]\\n        dec, inc = 0, 0\\n        ans = []\\n        for i in range(n):\\n            # newly added left order (i-2, i-1)\\n            if i -2 >= 0 and nums[i-2] < nums[i-1]: inc += 1\\n            # removed left most window edge (i-k-1, i-k)\\n            if i-k-1 >= 0 and nums[i-k-1] < nums[i-k]: inc -= 1\\n            # remove right order (i, i+1)\\n            if i >= k-1 and i + 1 < n and nums[i] > nums[i+1]: dec -= 1\\n            # add right most window edge (i+k-1, i+k)\\n            if i + k < n and nums[i+k-1] > nums[i+k]: dec += 1\\n            # print(inc, dec) \\n            if k <= i  and i < n - k and dec == 0 and inc == 0: ans.append(i)\\n\\n        return sorted(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984052,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse prefix and sufix array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Prefix array stores the number of elements that are in decreasing order before it(Exclusive).\\n- Sufix array stores the number of elements that are in decreasing order after it(Exclusive).\\n- If pre[i]>=k and suf[i]>=k then we can add i to ans.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(2*n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n\\n        List<Integer>ans=new ArrayList<>();\\n        int n=nums.length;\\n\\n        int pre[]=new int[n];\\n        Arrays.fill(pre,1);\\n        pre[0]=0;\\n        int e=1;\\n        while(e<n)//loop for prefix array\\n        {\\n            int x=0;\\n            while(e<n&&nums[e]<=nums[e-1])\\n            {\\n                pre[e]=x+1;\\n                x++;\\n                e++;\\n            }\\n            if(e<n)\\n                pre[e]=x+1;\\n            e++;\\n        }\\n\\n\\n        int suf[]=new int[n];\\n        Arrays.fill(suf,1);\\n        suf[n-1]=0;\\n        e=n-2;\\n        while(e>=0)\\n        {\\n            int x=0;\\n            while(e>=0&&nums[e]<=nums[e+1])\\n            {\\n                suf[e]=x+1;\\n                x++;\\n                e--;\\n            }\\n            if(e>=0)\\n                suf[e]=x+1;\\n            e--;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(pre[i]>=k&&suf[i]>=k)\\n            ans.add(i);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n> Stay hungry ! Stay f00lish : )",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n\\n        List<Integer>ans=new ArrayList<>();\\n        int n=nums.length;\\n\\n        int pre[]=new int[n];\\n        Arrays.fill(pre,1);\\n        pre[0]=0;\\n        int e=1;\\n        while(e<n)//loop for prefix array\\n        {\\n            int x=0;\\n            while(e<n&&nums[e]<=nums[e-1])\\n            {\\n                pre[e]=x+1;\\n                x++;\\n                e++;\\n            }\\n            if(e<n)\\n                pre[e]=x+1;\\n            e++;\\n        }\\n\\n\\n        int suf[]=new int[n];\\n        Arrays.fill(suf,1);\\n        suf[n-1]=0;\\n        e=n-2;\\n        while(e>=0)\\n        {\\n            int x=0;\\n            while(e>=0&&nums[e]<=nums[e+1])\\n            {\\n                suf[e]=x+1;\\n                x++;\\n                e--;\\n            }\\n            if(e>=0)\\n                suf[e]=x+1;\\n            e--;\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(pre[i]>=k&&suf[i]>=k)\\n            ans.add(i);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958215,
                "title": "java-simple-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int[] left = new int[nums.length];\\n        left[0] = 1;\\n        \\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] <= nums[i-1])\\n                left[i] = left[i-1] + 1;\\n            else \\n                left[i] = 1;\\n        }\\n        \\n        int[] right = new int[nums.length];\\n        right[nums.length - 1] = 1;\\n        \\n        for(int i = nums.length - 2; i >= 0; i--){\\n            if(nums[i] <= nums[i+1])\\n                right[i] = right[i+1] + 1;\\n            else \\n                right[i] = 1;\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        for(int i = k; i < nums.length - k; i++){\\n            if(left[i-1] >= k && right[i+1] >= k)\\n                result.add(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int[] left = new int[nums.length];\\n        left[0] = 1;\\n        \\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] <= nums[i-1])\\n                left[i] = left[i-1] + 1;\\n            else \\n                left[i] = 1;\\n        }\\n        \\n        int[] right = new int[nums.length];\\n        right[nums.length - 1] = 1;\\n        \\n        for(int i = nums.length - 2; i >= 0; i--){\\n            if(nums[i] <= nums[i+1])\\n                right[i] = right[i+1] + 1;\\n            else \\n                right[i] = 1;\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        for(int i = k; i < nums.length - k; i++){\\n            if(left[i-1] >= k && right[i+1] >= k)\\n                result.add(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958072,
                "title": "c-simple-o-n-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTake two vectors and initialize to 1.\\n- First vector is to find out the non-decresing elements(ivec).\\n- Second vector is to find out the non-incresing elements (dvec).\\n\\nLets take one input array:\\n[878724,201541,179099,98437,35765,327555,475851,598885,849470,943442]\\n\\nElements of the array after the iteration\\nivec: 1 1 1 1 1 2 3 4 5 6 \\ndvec: 1 2 3 4 5 1 1 1 1 1 \\n\\nNow, we iterate from k to n-k and push the index into `result` vector if ivec and dvec has more than or equal to k elements.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dvec(n, 1);\\n        vector<int> ivec(n,1);\\n\\n        for (int i=1; i<n; i++) {\\n            if (nums[i-1]<= nums[i]) ivec[i] = ivec[i-1] + 1;\\n        }\\n        for (int i=1; i<n; i++) {\\n            if (nums[i-1]>=nums[i]) dvec[i] = dvec[i-1] + 1;\\n        }\\n        vector<int> ans;\\n        for (int i=k; i<n-k; i++) {\\n            if (ivec[i+k] >=k && dvec[i-1] >= k) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> dvec(n, 1);\\n        vector<int> ivec(n,1);\\n\\n        for (int i=1; i<n; i++) {\\n            if (nums[i-1]<= nums[i]) ivec[i] = ivec[i-1] + 1;\\n        }\\n        for (int i=1; i<n; i++) {\\n            if (nums[i-1]>=nums[i]) dvec[i] = dvec[i-1] + 1;\\n        }\\n        vector<int> ans;\\n        for (int i=k; i<n-k; i++) {\\n            if (ivec[i+k] >=k && dvec[i-1] >= k) ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944071,
                "title": "java-linear-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nMake an increasing(inc) array and decreasing(dec) array which will maintain the number of elements are increaing next to it and the number of elements are decreasing before to it respectively\\n\\n---\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt each index after k to nums.length - k, ckeck the condition of\\n\\n    dec[i - 1] >= k -  1 && inc[i + 1] >= k - 1\\n---\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n---\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n---\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int inc[] = new int[nums.length];\\n        int dec[] = new int[nums.length];\\n\\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] <= nums[i - 1]) dec[i] = dec[i - 1] + 1;\\n        }\\n\\n        for(int i = nums.length - 2; i >= 0; i--){\\n            if(nums[i] <= nums[i + 1]) inc[i] = inc[i + 1] + 1;\\n        }\\n\\n        List<Integer> res = new ArrayList<>(); \\n        for(int i = k; i < nums.length - k; i++){\\n            if(dec[i - 1] >= k -  1 && inc[i + 1] >= k - 1) res.add(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int inc[] = new int[nums.length];\\n        int dec[] = new int[nums.length];\\n\\n        for(int i = 1; i < nums.length; i++){\\n            if(nums[i] <= nums[i - 1]) dec[i] = dec[i - 1] + 1;\\n        }\\n\\n        for(int i = nums.length - 2; i >= 0; i--){\\n            if(nums[i] <= nums[i + 1]) inc[i] = inc[i + 1] + 1;\\n        }\\n\\n        List<Integer> res = new ArrayList<>(); \\n        for(int i = k; i < nums.length - k; i++){\\n            if(dec[i - 1] >= k -  1 && inc[i + 1] >= k - 1) res.add(i);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873873,
                "title": "simple-python-solution-with-o-n-time-and-o-n-space",
                "content": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        inc=[1]*len(nums)\\n        dic=[1]*len(nums)\\n        for i in range(1,len(nums)):\\n            if nums[i-1]>=nums[i]:\\n                inc[i]=(inc[i-1]+1)\\n        for i in range(len(nums)-2,-1,-1):    \\n            if nums[i+1]>=nums[i]:\\n                dic[i]=(dic[i+1]+1)\\n        result=[]\\n        for i in range(1,len(nums)-1):\\n            if inc[i-1]>=k and dic[i+1]>=k:\\n                result.append(i)\\n        return result\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        inc=[1]*len(nums)\\n        dic=[1]*len(nums)\\n        for i in range(1,len(nums)):\\n            if nums[i-1]>=nums[i]:\\n                inc[i]=(inc[i-1]+1)\\n        for i in range(len(nums)-2,-1,-1):    \\n            if nums[i+1]>=nums[i]:\\n                dic[i]=(dic[i+1]+1)\\n        result=[]\\n        for i in range(1,len(nums)-1):\\n            if inc[i-1]>=k and dic[i+1]>=k:\\n                result.append(i)\\n        return result\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845503,
                "title": "simple-prefix-array-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& a, int k) {\\n        int n=a.size();\\n        vector<int> nd(n,1),ni(n,1);\\n        for(int i=1;i<n;i++){\\n            if(a[i]<=a[i-1])\\n                ni[i]=ni[i-1]+1;\\n            if(a[i]>=a[i-1])\\n                nd[i]=nd[i-1]+1;\\n        }\\n        vector<int> ans;\\n        for(int i=k;i<(n-k);i++){\\n            if(ni[i-1]>=k and nd[i+k]>=k)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& a, int k) {\\n        int n=a.size();\\n        vector<int> nd(n,1),ni(n,1);\\n        for(int i=1;i<n;i++){\\n            if(a[i]<=a[i-1])\\n                ni[i]=ni[i-1]+1;\\n            if(a[i]>=a[i-1])\\n                nd[i]=nd[i-1]+1;\\n        }\\n        vector<int> ans;\\n        for(int i=k;i<(n-k);i++){\\n            if(ni[i-1]>=k and nd[i+k]>=k)\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845486,
                "title": "clean-fast-python3-prefix-suffix",
                "content": "Here we are first calculating the lengths of non-increasing prefixes of each index, as well as the lengths of non-decreasing suffixes of each index.\\n\\nNotice that we start with each prefix length as 1 (for that number itself), and if some `nums[i-1] >= nums[i]` (the number at `i` is greater than its predecessor), we can simply add on the previous result from `i-1` to the current one, `i`. \\nFor example, if the list is `[3, 2, 1, 1]` -> starting from index 1, `3 >= 2`, so add the prefix from index 0 to index 1\\'s prefix. Now index 1 has prefix of length 2. Then, we see `2 >= 1`, so we can add the prefix from index 1 to index 2\\'s prefix length, which would then be 3.\\n\\nThen, for each index, we can simply check if the lengths are greater than k on each side to determine if it is good.\\n\\nPlease upvote if it helps!\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        \\n        non_inc_prefix = [1] * n\\n        for i in range(1, n-1):\\n            if nums[i-1] >= nums[i]:\\n                non_inc_prefix[i] += non_inc_prefix[i-1]\\n                \\n        non_dec_suffix = [1] * n\\n        for i in range(n-2, 0, -1):\\n            if nums[i] <= nums[i+1]:\\n                non_dec_suffix[i] += non_dec_suffix[i+1]\\n\\n        good = []\\n        for i in range(k, n - k):\\n            if non_inc_prefix[i-1] >= k <= non_dec_suffix[i+1]:\\n                good.append(i)\\n        \\n        return good",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Here we are first calculating the lengths of non-increasing prefixes of each index, as well as the lengths of non-decreasing suffixes of each index.\\n\\nNotice that we start with each prefix length as 1 (for that number itself), and if some `nums[i-1] >= nums[i]` (the number at `i` is greater than its predecessor), we can simply add on the previous result from `i-1` to the current one, `i`. \\nFor example, if the list is `[3, 2, 1, 1]` -> starting from index 1, `3 >= 2`, so add the prefix from index 0 to index 1\\'s prefix. Now index 1 has prefix of length 2. Then, we see `2 >= 1`, so we can add the prefix from index 1 to index 2\\'s prefix length, which would then be 3.\\n\\nThen, for each index, we can simply check if the lengths are greater than k on each side to determine if it is good.\\n\\nPlease upvote if it helps!\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        \\n        non_inc_prefix = [1] * n\\n        for i in range(1, n-1):\\n            if nums[i-1] >= nums[i]:\\n                non_inc_prefix[i] += non_inc_prefix[i-1]\\n                \\n        non_dec_suffix = [1] * n\\n        for i in range(n-2, 0, -1):\\n            if nums[i] <= nums[i+1]:\\n                non_dec_suffix[i] += non_dec_suffix[i+1]\\n\\n        good = []\\n        for i in range(k, n - k):\\n            if non_inc_prefix[i-1] >= k <= non_dec_suffix[i+1]:\\n                good.append(i)\\n        \\n        return good",
                "codeTag": "Java"
            },
            {
                "id": 2841809,
                "title": "prefix-sum-java-10-lines-3-steps-explained",
                "content": "```\\n\\n// step 1: create left and right array of same size and fill it with 1 \\n//(why with 1 - we are assuming that this sequence has 1 number ) \\n\\n//step -2 iterate from left to right and check if prev element is greater than curr then if yes increase sequence length by adding prev+1;\\n// again same process but from right to left \\n\\n//step -3 check if left[i-1] and right[i+1] has greater value than k means that on left there is a non-increasing sequence and \\n//on right there is non-dreasing sequence\\n\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n=nums.length;\\n        int left[]=new int[n];  Arrays.fill(left,1);\\n        int right[]=new int[n]; Arrays.fill(right,1);\\n        \\n        for(int i=1;i<n;i++)    \\n            if(nums[i-1]>=nums[i])  left[i]=left[i-1]+1;\\n        \\n        for(int i=n-2;i>=0;i--) \\n            if(nums[i+1]>=nums[i])  right[i]=right[i+1]+1;\\n        \\n        List<Integer> li=new ArrayList<>();\\n        \\n        for(int i=k;i<n-k;i++)\\n            if(left[i-1]>=k && right[i+1]>=k)   li.add(i);\\n        \\n        return li;\\n    }\\n}\\n```\\n\\ntime-o(n)\\nspace-o(n)\\nsimilar problem- trapping rain water\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\n\\n// step 1: create left and right array of same size and fill it with 1 \\n//(why with 1 - we are assuming that this sequence has 1 number ) \\n\\n//step -2 iterate from left to right and check if prev element is greater than curr then if yes increase sequence length by adding prev+1;\\n// again same process but from right to left \\n\\n//step -3 check if left[i-1] and right[i+1] has greater value than k means that on left there is a non-increasing sequence and \\n//on right there is non-dreasing sequence\\n\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n=nums.length;\\n        int left[]=new int[n];  Arrays.fill(left,1);\\n        int right[]=new int[n]; Arrays.fill(right,1);\\n        \\n        for(int i=1;i<n;i++)    \\n            if(nums[i-1]>=nums[i])  left[i]=left[i-1]+1;\\n        \\n        for(int i=n-2;i>=0;i--) \\n            if(nums[i+1]>=nums[i])  right[i]=right[i+1]+1;\\n        \\n        List<Integer> li=new ArrayList<>();\\n        \\n        for(int i=k;i<n-k;i++)\\n            if(left[i-1]>=k && right[i+1]>=k)   li.add(i);\\n        \\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837426,
                "title": "video-walkthrough-3-line-solution-python",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/9Px5DlRyVpo)\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:       \\n        NI, ND = [1] * len(nums), [1] * len(nums)\\n        for i in range(1,len(nums)): NI[i], ND[i]  = NI[i] + NI[i-1] * int(nums[i] <= nums[i-1]),ND[i] + ND[i-1] * int(nums[i] >= nums[i-1])\\n        return [idx for idx in range(k,len(nums)-k) if NI[idx-1] >= k and ND[idx+k] >= k]\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:       \\n        NI, ND = [1] * len(nums), [1] * len(nums)\\n        for i in range(1,len(nums)): NI[i], ND[i]  = NI[i] + NI[i-1] * int(nums[i] <= nums[i-1]),ND[i] + ND[i-1] * int(nums[i] >= nums[i-1])\\n        return [idx for idx in range(k,len(nums)-k) if NI[idx-1] >= k and ND[idx+k] >= k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836594,
                "title": "python-simple-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def goodIndices(self, nums, k):\\n        n, res = len(nums), []\\n\\n        dec, inc = [1]*n, [1]*n\\n\\n        for i in range(1,n):\\n            if nums[i] <= nums[i-1]:\\n                dec[i] = dec[i-1] + 1\\n\\n        for i in range(n-2,-1,-1):\\n            if nums[i] <= nums[i+1]:\\n                inc[i] = inc[i+1] + 1\\n\\n        for i in range(k,n-k):\\n            if dec[i-1] >= k and inc[i+1] >= k:\\n                res.append(i)\\n\\n        return res\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums, k):\\n        n, res = len(nums), []\\n\\n        dec, inc = [1]*n, [1]*n\\n\\n        for i in range(1,n):\\n            if nums[i] <= nums[i-1]:\\n                dec[i] = dec[i-1] + 1\\n\\n        for i in range(n-2,-1,-1):\\n            if nums[i] <= nums[i+1]:\\n                inc[i] = inc[i+1] + 1\\n\\n        for i in range(k,n-k):\\n            if dec[i-1] >= k and inc[i+1] >= k:\\n                res.append(i)\\n\\n        return res\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832993,
                "title": "java-o-n-o-n",
                "content": "# Approach\\nStore Ascending Count From index First To last.\\nStore Descending Count From index last  To first.\\n\\nCheck all Indeies from First to last and check  given condition .If true then save in a List.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(3n)$$ => $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(2n)$$ => $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] n, int k) {  \\n\\n        int len= n.length;\\n\\n        int[] asc=new int[len];\\n        int[] desc=new int[len];\\n        List<Integer> res= new ArrayList<Integer>();\\n\\n        for(int i=len-2; i>=0 ;i--){\\n            if( n[i] <= n[i+1] ){\\n                desc[i]=desc[i+1]+1;   \\n            }\\n        }\\n        for(int i=1; i<len ;i++){\\n            if( n[i-1] >= n[i]  ){\\n                asc[i]=asc[i-1]+1;   \\n            }\\n        }\\n\\n        for(int i=0; i<len ;i++){\\n            if(i-1>=0 && asc[i-1]>=k-1 &&  i+1 < len && desc[i+1]>= k-1  ) res.add(i);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] n, int k) {  \\n\\n        int len= n.length;\\n\\n        int[] asc=new int[len];\\n        int[] desc=new int[len];\\n        List<Integer> res= new ArrayList<Integer>();\\n\\n        for(int i=len-2; i>=0 ;i--){\\n            if( n[i] <= n[i+1] ){\\n                desc[i]=desc[i+1]+1;   \\n            }\\n        }\\n        for(int i=1; i<len ;i++){\\n            if( n[i-1] >= n[i]  ){\\n                asc[i]=asc[i-1]+1;   \\n            }\\n        }\\n\\n        for(int i=0; i<len ;i++){\\n            if(i-1>=0 && asc[i-1]>=k-1 &&  i+1 < len && desc[i+1]>= k-1  ) res.add(i);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828840,
                "title": "beginners-logical-thinking-java",
                "content": "# Intuition\\nFor any index, calculate the continuous number of decreasing elements on the left, and continuous number of increasing elements on the right. If the count at an index is greater than k, we know there are atleast k increasing (on right) or decreasing (on left) elements from that index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo arrays and fill them as per logic above.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLeft: $$O(n)$$ Right: $$O(n)$$ verify: $$O(n)$$ Total: Left + Right + Verify = $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ for output.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] left = new int[n], right = new int[n];\\n\\n        int numDecreasingSoFar = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            left[i] = numDecreasingSoFar;\\n            if (i > 0) {\\n                if (nums[i] <= nums[i-1]) numDecreasingSoFar++;\\n                else numDecreasingSoFar = 1;\\n            }\\n        }\\n\\n        int numIncreasingSoFar = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            right[i] = numIncreasingSoFar;\\n            if (i < n-1) {\\n                if (nums[i] <= nums[i+1]) numIncreasingSoFar++;\\n                else numIncreasingSoFar = 1;\\n            }\\n        }\\n\\n        List<Integer> out = new LinkedList<>();\\n        for (int i = k; i < n - k; i++) {\\n            if (left[i] >= k && right[i] >= k) out.add(i);\\n        }\\n\\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        int[] left = new int[n], right = new int[n];\\n\\n        int numDecreasingSoFar = 1;\\n        for (int i = 0; i < nums.length; i++) {\\n            left[i] = numDecreasingSoFar;\\n            if (i > 0) {\\n                if (nums[i] <= nums[i-1]) numDecreasingSoFar++;\\n                else numDecreasingSoFar = 1;\\n            }\\n        }\\n\\n        int numIncreasingSoFar = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            right[i] = numIncreasingSoFar;\\n            if (i < n-1) {\\n                if (nums[i] <= nums[i+1]) numIncreasingSoFar++;\\n                else numIncreasingSoFar = 1;\\n            }\\n        }\\n\\n        List<Integer> out = new LinkedList<>();\\n        for (int i = k; i < n - k; i++) {\\n            if (left[i] >= k && right[i] >= k) out.add(i);\\n        }\\n\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815387,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> res;\\n        int c1 = 1, c2 = 1;\\n        for (int j=2; j<k; j++)\\n        {\\n            if (nums[j] >= nums[j-1])\\n                c2++;\\n            else\\n                c2 = 1;\\n        }\\n        int i = 0;\\n        while (i+k<n) \\n        {\\n            if (nums[i+k] >= nums[i+k-1])\\n                c2++;\\n            else\\n                c2 = 1;\\n            if (i>=2 && (nums[i-1] <= nums[i-2]))\\n                c1++;\\n            else\\n                c1 = 1;\\n            if (c1 >= k && c2 >=k && i >=k)\\n                res.push_back(i);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> res;\\n        int c1 = 1, c2 = 1;\\n        for (int j=2; j<k; j++)\\n        {\\n            if (nums[j] >= nums[j-1])\\n                c2++;\\n            else\\n                c2 = 1;\\n        }\\n        int i = 0;\\n        while (i+k<n) \\n        {\\n            if (nums[i+k] >= nums[i+k-1])\\n                c2++;\\n            else\\n                c2 = 1;\\n            if (i>=2 && (nums[i-1] <= nums[i-2]))\\n                c1++;\\n            else\\n                c1 = 1;\\n            if (c1 >= k && c2 >=k && i >=k)\\n                res.push_back(i);\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800988,
                "title": "c-solution-prefix-suffix-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int> left_rule(nums.size(),0);\\n        vector<int> right_rule(nums.size(),0);\\n        int count1 = 0; vector<int> answer;\\n        if(k==1){\\n             for(int i=1;i<nums.size()-1;i++){\\n                answer.push_back(i);\\n             }\\n             return answer;\\n        }\\n        for(int i=1;i<k;i++){\\n            if(nums[i]>nums[i-1]){\\n                count1++;\\n            }\\n        }\\n        if(count1==0) left_rule[k-1] = 1; int count2 =0;\\n        for(int i=nums.size()-2;i>nums.size()-1-k;i--){\\n            if(nums[i]>nums[i+1]){\\n                count2++;\\n            }\\n        }\\n        if(count2==0) right_rule[nums.size()-k] = 1;\\n        for(int i=k;i<nums.size();i++){\\n            if(nums[i]<=nums[i-1]){\\n                if(nums[i-k]<nums[i-k+1]) count1--;\\n                if(count1==0) left_rule[i] = 1;\\n            }else{\\n                if(nums[i-k]<nums[i-k+1]) count1--;\\n                count1++;\\n            }\\n        }\\n        for(int i=nums.size()-1-k;i>=0;i--){\\n            if(nums[i]<=nums[i+1]){\\n                if(nums[i+k]<nums[i+k-1]) count2--;\\n                if(count2==0) right_rule[i] = 1;\\n            }else{\\n                if(nums[i+k]<nums[i+k-1]) count2--;\\n                count2++;\\n            }\\n        }\\n        for(int i=k;i<nums.size()-k;i++){\\n            cout<<left_rule[i-1]<<\" \"<<right_rule[i+1]<<endl;\\n            if(left_rule[i-1]&&right_rule[i+1]) answer.push_back(i);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int> left_rule(nums.size(),0);\\n        vector<int> right_rule(nums.size(),0);\\n        int count1 = 0; vector<int> answer;\\n        if(k==1){\\n             for(int i=1;i<nums.size()-1;i++){\\n                answer.push_back(i);\\n             }\\n             return answer;\\n        }\\n        for(int i=1;i<k;i++){\\n            if(nums[i]>nums[i-1]){\\n                count1++;\\n            }\\n        }\\n        if(count1==0) left_rule[k-1] = 1; int count2 =0;\\n        for(int i=nums.size()-2;i>nums.size()-1-k;i--){\\n            if(nums[i]>nums[i+1]){\\n                count2++;\\n            }\\n        }\\n        if(count2==0) right_rule[nums.size()-k] = 1;\\n        for(int i=k;i<nums.size();i++){\\n            if(nums[i]<=nums[i-1]){\\n                if(nums[i-k]<nums[i-k+1]) count1--;\\n                if(count1==0) left_rule[i] = 1;\\n            }else{\\n                if(nums[i-k]<nums[i-k+1]) count1--;\\n                count1++;\\n            }\\n        }\\n        for(int i=nums.size()-1-k;i>=0;i--){\\n            if(nums[i]<=nums[i+1]){\\n                if(nums[i+k]<nums[i+k-1]) count2--;\\n                if(count2==0) right_rule[i] = 1;\\n            }else{\\n                if(nums[i+k]<nums[i+k-1]) count2--;\\n                count2++;\\n            }\\n        }\\n        for(int i=k;i<nums.size()-k;i++){\\n            cout<<left_rule[i-1]<<\" \"<<right_rule[i+1]<<endl;\\n            if(left_rule[i-1]&&right_rule[i+1]) answer.push_back(i);\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2781307,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> pre(n+5,1),suff(n+5,1);\\n        vector<int> ans;\\n\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<=nums[i-1]){\\n                pre[i]=pre[i-1]+1;\\n            }\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]<=nums[i+1]){\\n                suff[i]=suff[i+1]+1;\\n            }\\n        }\\n\\n        for(int i=k;i<n-k;i++){\\n            if(pre[i-1]>=k && suff[i+1]>=k) ans.push_back(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> pre(n+5,1),suff(n+5,1);\\n        vector<int> ans;\\n\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<=nums[i-1]){\\n                pre[i]=pre[i-1]+1;\\n            }\\n        }\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i]<=nums[i+1]){\\n                suff[i]=suff[i+1]+1;\\n            }\\n        }\\n\\n        for(int i=k;i<n-k;i++){\\n            if(pre[i-1]>=k && suff[i+1]>=k) ans.push_back(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762662,
                "title": "o-n-with-comments-prefix-sum-2-pass",
                "content": "```\\nvector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> inc(n, 1), dec(n, 1); // prefix arrays that keep count of numbers\\n\\t\\t                                  // that occur in non decreasing and non increasing \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // manner respectively\\n        for(int i = 1; i < n; i++) {\\n            if(nums[i - 1] == nums[i]) {       // if prev number is equal to current number we increase count in both arrays\\n                dec[i] += dec[i - 1];\\n                inc[i] += inc[i - 1];\\n            } else if(nums[i - 1] > nums[i]) { // increasing count in dec array only\\n                dec[i] += dec[i - 1];\\n            } else {                           // increasing count in inc array only\\n                inc[i] += inc[i - 1];\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i = k; i < n - k; i++) { \\n            if(dec[i - 1] >= k and inc[i + k] >= k) ans.push_back(i);  // check for given conditions\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nvector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> inc(n, 1), dec(n, 1); // prefix arrays that keep count of numbers\\n\\t\\t                                  // that occur in non decreasing and non increasing \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  // manner respectively\\n        for(int i = 1; i < n; i++) {\\n            if(nums[i - 1] == nums[i]) {       // if prev number is equal to current number we increase count in both arrays\\n                dec[i] += dec[i - 1];\\n                inc[i] += inc[i - 1];\\n            } else if(nums[i - 1] > nums[i]) { // increasing count in dec array only\\n                dec[i] += dec[i - 1];\\n            } else {                           // increasing count in inc array only\\n                inc[i] += inc[i - 1];\\n            }\\n        }\\n        vector<int> ans;\\n        for(int i = k; i < n - k; i++) { \\n            if(dec[i - 1] >= k and inc[i + k] >= k) ans.push_back(i);  // check for given conditions\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2741087,
                "title": "very-easy-solution-with-2-array",
                "content": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        left,right,ans = [],[],[]\\n        if k == 0:\\n            return [i for i in range(len(nums))]\\n        for i in range(len(nums)):\\n            if i == 0:\\n                left.append(1)\\n                continue\\n            if nums[i] <= nums[i-1]:\\n                left.append(left[-1]+1)\\n            else:\\n                left.append(1)\\n        for i in range(len(nums)-1,-1,-1):\\n            if i == len(nums)-1:\\n                right.append(1)\\n                continue\\n            if nums[i] <= nums[i+1]:\\n                right.append(right[-1]+1)\\n            else:\\n                right.append(1)\\n        right.reverse()\\n        for i in range(k, len(nums)-k):\\n            if left[i-1] >= k and right[i+1] >= k:\\n                ans.append(i)\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        left,right,ans = [],[],[]\\n        if k == 0:\\n            return [i for i in range(len(nums))]\\n        for i in range(len(nums)):\\n            if i == 0:\\n                left.append(1)\\n                continue\\n            if nums[i] <= nums[i-1]:\\n                left.append(left[-1]+1)\\n            else:\\n                left.append(1)\\n        for i in range(len(nums)-1,-1,-1):\\n            if i == len(nums)-1:\\n                right.append(1)\\n                continue\\n            if nums[i] <= nums[i+1]:\\n                right.append(right[-1]+1)\\n            else:\\n                right.append(1)\\n        right.reverse()\\n        for i in range(k, len(nums)-k):\\n            if left[i-1] >= k and right[i+1] >= k:\\n                ans.append(i)\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715102,
                "title": "easy-java-o-n-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        int left[] = new int[n];\\n        int right[] = new int[n];\\n        left[0] = 0;\\n        right[n-1] = n-1;\\n\\n        for(int i = 1;i<n;i++){\\n            if(nums[i]<=nums[i-1]) left[i] = left[i-1];\\n            else left[i] = i;\\n\\n            if(nums[n-i-1]<=nums[n-i]) right[n-i-1] = right[n-i];\\n            else right[n-i-1] = n-i-1;\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = k;i<n-k;i++){\\n            if(((i-1)-left[i-1]>=k-1) && (right[i+1]-(i+1)>=k-1)) res.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        int left[] = new int[n];\\n        int right[] = new int[n];\\n        left[0] = 0;\\n        right[n-1] = n-1;\\n\\n        for(int i = 1;i<n;i++){\\n            if(nums[i]<=nums[i-1]) left[i] = left[i-1];\\n            else left[i] = i;\\n\\n            if(nums[n-i-1]<=nums[n-i]) right[n-i-1] = right[n-i];\\n            else right[n-i-1] = n-i-1;\\n        }\\n        List<Integer> res = new ArrayList<>();\\n        for(int i = k;i<n-k;i++){\\n            if(((i-1)-left[i-1]>=k-1) && (right[i+1]-(i+1)>=k-1)) res.add(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712036,
                "title": "c-concise",
                "content": "```\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        const int n = nums.size();\\n        vector<int> vl(n,1), vr(n,1), res;\\n        for(int i=1, len=1;i<n;i++){\\n            nums[i] <= nums[i-1] ? len++ : len = 1;\\n            vl[i] = len;\\n        }\\n        for(int i=n-2, len=1; i>=0;i--){\\n            nums[i] <= nums[i+1] ? len++ : len = 1;\\n            vr[i] = len;\\n        }\\n        for(int i=k; i+k<n;i++){\\n            if(vl[i-1] >=k && vr[i+1] >= k) res.push_back(i);\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        const int n = nums.size();\\n        vector<int> vl(n,1), vr(n,1), res;\\n        for(int i=1, len=1;i<n;i++){\\n            nums[i] <= nums[i-1] ? len++ : len = 1;\\n            vl[i] = len;\\n        }\\n        for(int i=n-2, len=1; i>=0;i--){\\n            nums[i] <= nums[i+1] ? len++ : len = 1;\\n            vr[i] = len;\\n        }\\n        for(int i=k; i+k<n;i++){\\n            if(vl[i-1] >=k && vr[i+1] >= k) res.push_back(i);\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2705292,
                "title": "c-easy-logic",
                "content": "Completed within 15 minutes. Nonetheless, good question indeed.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> res = {};\\n    vector<bool> noni, nond;\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int len = nums.size();\\n        if (k == 1) {\\n            for (int i = 1; i < len - 1; i++) {\\n                res.push_back(i);\\n            }\\n            return res;\\n        }\\n        noni = vector<bool>(len, false);\\n        nond = vector<bool>(len, false);\\n        int pat = 0;\\n        for (int i = 1; i < k; i++) {\\n            if (nums[i - 1] >= nums[i]) {\\n                pat++;\\n            }\\n            else {\\n                pat = 0;\\n            }\\n        }\\n        int target = k - 1;\\n        for (int i = k; i < len; i++) {\\n            if (pat >= target) {\\n                noni[i] = true;\\n            }\\n            if (nums[i - 1] >= nums[i]) {\\n                pat++;\\n            }\\n            else {\\n                pat = 0;\\n            }\\n        }\\n        pat = 0;\\n        for (int i = len - 2; i >= (len - k); i--) {\\n            if (nums[i + 1] >= nums[i]) {\\n                pat++;\\n            }\\n            else {\\n                pat = 0;\\n            }\\n        }\\n        for (int i = len - k - 1; i >= 0; i--) {\\n            if (pat >= target) {\\n                nond[i] = true;\\n            }\\n            if (nums[i + 1] >= nums[i]) {\\n                pat++;\\n            }\\n            else {\\n                pat = 0;\\n            }\\n        }\\n        for (int i = k; i < len - k; i++) {\\n            if (nond[i] && noni[i]) {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> res = {};\\n    vector<bool> noni, nond;\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int len = nums.size();\\n        if (k == 1) {\\n            for (int i = 1; i < len - 1; i++) {\\n                res.push_back(i);\\n            }\\n            return res;\\n        }\\n        noni = vector<bool>(len, false);\\n        nond = vector<bool>(len, false);\\n        int pat = 0;\\n        for (int i = 1; i < k; i++) {\\n            if (nums[i - 1] >= nums[i]) {\\n                pat++;\\n            }\\n            else {\\n                pat = 0;\\n            }\\n        }\\n        int target = k - 1;\\n        for (int i = k; i < len; i++) {\\n            if (pat >= target) {\\n                noni[i] = true;\\n            }\\n            if (nums[i - 1] >= nums[i]) {\\n                pat++;\\n            }\\n            else {\\n                pat = 0;\\n            }\\n        }\\n        pat = 0;\\n        for (int i = len - 2; i >= (len - k); i--) {\\n            if (nums[i + 1] >= nums[i]) {\\n                pat++;\\n            }\\n            else {\\n                pat = 0;\\n            }\\n        }\\n        for (int i = len - k - 1; i >= 0; i--) {\\n            if (pat >= target) {\\n                nond[i] = true;\\n            }\\n            if (nums[i + 1] >= nums[i]) {\\n                pat++;\\n            }\\n            else {\\n                pat = 0;\\n            }\\n        }\\n        for (int i = k; i < len - k; i++) {\\n            if (nond[i] && noni[i]) {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700184,
                "title": "javascript",
                "content": "\\n```\\nconst goodIndices = (nums, k) => {\\n    const res = [];\\n    let start = 0;\\n\\n    for (let i = k; i < nums.length - k; i++) {\\n        let j = start;\\n\\n        while (j < k - 1\\n            && nums[i - k + j] >= nums[i - k + j + 1] // left side non-increasing\\n            && nums[i + j + 1] <= nums[i + j + 1 + 1] // right side non-decreasing\\n        ) j++;\\n\\n        if (j === k - 1) {\\n            res.push(i);\\n            start = k - 2;\\n        } else {\\n            i += j;\\n            start = 0;\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst goodIndices = (nums, k) => {\\n    const res = [];\\n    let start = 0;\\n\\n    for (let i = k; i < nums.length - k; i++) {\\n        let j = start;\\n\\n        while (j < k - 1\\n            && nums[i - k + j] >= nums[i - k + j + 1] // left side non-increasing\\n            && nums[i + j + 1] <= nums[i + j + 1 + 1] // right side non-decreasing\\n        ) j++;\\n\\n        if (j === k - 1) {\\n            res.push(i);\\n            start = k - 2;\\n        } else {\\n            i += j;\\n            start = 0;\\n        }\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2695657,
                "title": "c-89-faster-simple-approach-two-arrays",
                "content": "Calculate the **prefix arrays** for the **non-increasing** and **non-decreasing** values respectively.\\nPlease upvote if you find the solution good and concise.\\n***Thank You!!***\\n### Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> res, decreasing(n), increasing(n);\\n        for(int i=1;i<n;i++) {\\n            decreasing[i] = decreasing[i-1] + (nums[i] <= nums[i-1]);\\n            increasing[i] = increasing[i-1] + (nums[i] >= nums[i-1]);\\n        }\\n        for(int i=k;i<n-k;i++) {\\n            if((decreasing[i-1] - decreasing[i-k]) == k-1 and (increasing[i+k] - increasing[i+1] == k-1))\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> res, decreasing(n), increasing(n);\\n        for(int i=1;i<n;i++) {\\n            decreasing[i] = decreasing[i-1] + (nums[i] <= nums[i-1]);\\n            increasing[i] = increasing[i-1] + (nums[i] >= nums[i-1]);\\n        }\\n        for(int i=k;i<n-k;i++) {\\n            if((decreasing[i-1] - decreasing[i-k]) == k-1 and (increasing[i+k] - increasing[i+1] == k-1))\\n                res.push_back(i);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694730,
                "title": "c-kind-of-prefix-sum-easy-to-understand-solution-intuition-explained",
                "content": "**Approach Intuition: The intuition of the problem goes like we will calculate the length of increasing and decreasing subarray till each index in different array and then will perform a traversal to find the required good indices**\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int>beforearr(nums.size(),0), afterarr(nums.size(),0);\\n        int currsize = 0;\\n        int prev_ele = INT_MAX;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i]<=prev_ele){\\n                currsize++;\\n            }\\n            \\n            else{\\n                currsize = 1;\\n            }\\n            \\n            beforearr[i] = currsize;\\n            prev_ele = nums[i];\\n        }\\n        \\n        currsize = 0;\\n        prev_ele = INT_MAX;\\n        for(int i = nums.size()-1; i>=0; i--){\\n            if(nums[i]<=prev_ele){\\n                currsize++;\\n            }\\n            \\n            else{\\n                currsize = 1;\\n            }\\n            \\n            afterarr[i] = currsize;\\n            prev_ele = nums[i];\\n        }\\n        \\n        vector<int>ans;\\n        for(int i = k; i<nums.size()-k; i++){\\n            if(beforearr[i-1]>=k and afterarr[i+1]>=k){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int>beforearr(nums.size(),0), afterarr(nums.size(),0);\\n        int currsize = 0;\\n        int prev_ele = INT_MAX;\\n        for(int i = 0; i<nums.size(); i++){\\n            if(nums[i]<=prev_ele){\\n                currsize++;\\n            }\\n            \\n            else{\\n                currsize = 1;\\n            }\\n            \\n            beforearr[i] = currsize;\\n            prev_ele = nums[i];\\n        }\\n        \\n        currsize = 0;\\n        prev_ele = INT_MAX;\\n        for(int i = nums.size()-1; i>=0; i--){\\n            if(nums[i]<=prev_ele){\\n                currsize++;\\n            }\\n            \\n            else{\\n                currsize = 1;\\n            }\\n            \\n            afterarr[i] = currsize;\\n            prev_ele = nums[i];\\n        }\\n        \\n        vector<int>ans;\\n        for(int i = k; i<nums.size()-k; i++){\\n            if(beforearr[i-1]>=k and afterarr[i+1]>=k){\\n                ans.push_back(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689889,
                "title": "java-prefix-and-suffix-arrays-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        List<Integer> ans = new ArrayList();\\n        int[] pref = new int[n];\\n        int[] suff = new int[n];\\n        suff[n-1] = 1;\\n        pref[0] = 1;\\n        for(int i=1;i<n;++i){\\n            if(nums[i] <= nums[i-1])    pref[i] = pref[i-1] + 1 ;\\n            else   pref[i] = 1;\\n        }\\n        for(int i=n-2;i>=0;--i){\\n            if(nums[i] <= nums[i + 1])  suff[i] = suff[i+ 1] + 1 ;\\n            else    suff[i] = 1;\\n        }\\n        for(int i=k;i<n-k;++i){\\n            if(suff[i+1]>=k && pref[i-1]>=k)    ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```\\n*Kindly upvote if you find it helpful*",
                "solutionTags": [
                    "Java",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> goodIndices(int[] nums, int k) {\\n        int n = nums.length;\\n        List<Integer> ans = new ArrayList();\\n        int[] pref = new int[n];\\n        int[] suff = new int[n];\\n        suff[n-1] = 1;\\n        pref[0] = 1;\\n        for(int i=1;i<n;++i){\\n            if(nums[i] <= nums[i-1])    pref[i] = pref[i-1] + 1 ;\\n            else   pref[i] = 1;\\n        }\\n        for(int i=n-2;i>=0;--i){\\n            if(nums[i] <= nums[i + 1])  suff[i] = suff[i+ 1] + 1 ;\\n            else    suff[i] = 1;\\n        }\\n        for(int i=k;i<n-k;++i){\\n            if(suff[i+1]>=k && pref[i-1]>=k)    ans.add(i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665273,
                "title": "easy-explained-dp-solution-python",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def goodIndices(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dp_inc = [1] * len(nums)\\n        dp_dec = [1] * len(nums)\\n        answer = []\\n\\n        # for each index, increase the number of previous indices that followed the\\n        # non-increasing order by 1, else skip to restart from 1\\n        for i in range(1, len(nums)):\\n            if nums[i] <= nums[i - 1]:\\n                dp_dec[i] = dp_dec[i - 1] + 1\\n                \\n        # for each index, increase the number of ensuing indices that followed the\\n        # non-decreasing order by 1, else skip to restart from 1\\n        for i in range(len(nums)-2, -1, -1):\\n            if nums[i] <= nums[i + 1]:\\n                dp_inc[i] = dp_inc[i + 1] + 1\\n                \\n        # for eligible indices, check if the previous index followed the non-increasing,\\n        # and the next-index followed the non-decreasing, for at least k times,\\n        # then add this index to the answer\\n        for i in range(k, len(nums) - k):\\n            if dp_dec[i - 1] >= k and dp_inc[i + 1] >= k:\\n                answer.append(i)\\n\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def goodIndices(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dp_inc = [1] * len(nums)\\n        dp_dec = [1] * len(nums)\\n        answer = []\\n\\n        # for each index, increase the number of previous indices that followed the\\n        # non-increasing order by 1, else skip to restart from 1\\n        for i in range(1, len(nums)):\\n            if nums[i] <= nums[i - 1]:\\n                dp_dec[i] = dp_dec[i - 1] + 1\\n                \\n        # for each index, increase the number of ensuing indices that followed the\\n        # non-decreasing order by 1, else skip to restart from 1\\n        for i in range(len(nums)-2, -1, -1):\\n            if nums[i] <= nums[i + 1]:\\n                dp_inc[i] = dp_inc[i + 1] + 1\\n                \\n        # for eligible indices, check if the previous index followed the non-increasing,\\n        # and the next-index followed the non-decreasing, for at least k times,\\n        # then add this index to the answer\\n        for i in range(k, len(nums) - k):\\n            if dp_dec[i - 1] >= k and dp_inc[i + 1] >= k:\\n                answer.append(i)\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664321,
                "title": "rust-intuitive",
                "content": "```\\nimpl Solution {\\n    pub fn good_indices(nums: Vec<i32>, k: i32) -> Vec<i32> {\\n        let len = nums.len();\\n        let mut l2r = vec![false; len];\\n        \\n        let k = k as usize;\\n        \\n        let mut cur = nums[0];\\n        let mut non_inc = true;\\n        let mut window = 0;\\n        for (idx, &val) in nums.iter().enumerate() {\\n            if val <= cur {\\n                window += 1;\\n            } else {\\n                window = 1;\\n            }\\n            cur = val;\\n            \\n            if window >= k {\\n                l2r[idx] = true;\\n            }\\n        }\\n        \\n        let mut r2l = vec![false; len];\\n        \\n        let mut cur = nums[len - 1];\\n        let mut window = 0;\\n        \\n        for (idx, &val) in nums.iter().rev().enumerate() {\\n            if val <= cur {\\n                window += 1;\\n            } else {\\n                window = 1;\\n            }\\n            cur = val;\\n        \\n            if window >= k {\\n                r2l[len - 1 - idx] = true;\\n            }\\n        }\\n        \\n        let mut ret = Vec::<i32>::new();\\n        for idx in 1..len - 1 {\\n            if l2r[idx - 1] && r2l[idx + 1] {\\n                ret.push(idx as i32);\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn good_indices(nums: Vec<i32>, k: i32) -> Vec<i32> {\\n        let len = nums.len();\\n        let mut l2r = vec![false; len];\\n        \\n        let k = k as usize;\\n        \\n        let mut cur = nums[0];\\n        let mut non_inc = true;\\n        let mut window = 0;\\n        for (idx, &val) in nums.iter().enumerate() {\\n            if val <= cur {\\n                window += 1;\\n            } else {\\n                window = 1;\\n            }\\n            cur = val;\\n            \\n            if window >= k {\\n                l2r[idx] = true;\\n            }\\n        }\\n        \\n        let mut r2l = vec![false; len];\\n        \\n        let mut cur = nums[len - 1];\\n        let mut window = 0;\\n        \\n        for (idx, &val) in nums.iter().rev().enumerate() {\\n            if val <= cur {\\n                window += 1;\\n            } else {\\n                window = 1;\\n            }\\n            cur = val;\\n        \\n            if window >= k {\\n                r2l[len - 1 - idx] = true;\\n            }\\n        }\\n        \\n        let mut ret = Vec::<i32>::new();\\n        for idx in 1..len - 1 {\\n            if l2r[idx - 1] && r2l[idx + 1] {\\n                ret.push(idx as i32);\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2659790,
                "title": "c-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        for (int i = k, l = 0, r = 0; i+k < size(nums); ) {\\n            for (l = max(l, i-k+1); l < i && nums[l-1] >= nums[l]; l++);\\n            if (l != i) { i = l + k; continue; }\\n            for (r = max(r, i+2); r < i+k+1 && nums[r-1] <= nums[r]; r++);\\n            if (r != i+k+1) { i = r - 1; continue; }\\n            ans.push_back(i++);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        for (int i = k, l = 0, r = 0; i+k < size(nums); ) {\\n            for (l = max(l, i-k+1); l < i && nums[l-1] >= nums[l]; l++);\\n            if (l != i) { i = l + k; continue; }\\n            for (r = max(r, i+2); r < i+k+1 && nums[r-1] <= nums[r]; r++);\\n            if (r != i+k+1) { i = r - 1; continue; }\\n            ans.push_back(i++);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656655,
                "title": "c-fastest-submission-tabulation-dp",
                "content": "TC: O(N)\\nSC: O(N)\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>prefix(n),suffix(n),ans;\\n        prefix[0]=1;\\n        suffix[n-1]=1;\\n        \\n        //create prefix array and suffix array\\n        for(int i=1;i<n;i++){\\n             prefix[i]     =     1 + (nums[i]<=nums[i-1]?prefix[i-1]:0);\\n            suffix[n-i-1] =    1 + (nums[n-i-1]<=nums[n-i]?suffix[n-i]:0);\\n        }\\n        \\n        for(int i=k;i<n-k;i++)\\n            if(prefix[i-1]>=k && suffix[i+1]>=k)\\n                ans.push_back(i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>prefix(n),suffix(n),ans;\\n        prefix[0]=1;\\n        suffix[n-1]=1;\\n        \\n        //create prefix array and suffix array\\n        for(int i=1;i<n;i++){\\n             prefix[i]     =     1 + (nums[i]<=nums[i-1]?prefix[i-1]:0);\\n            suffix[n-i-1] =    1 + (nums[n-i-1]<=nums[n-i]?suffix[n-i]:0);\\n        }\\n        \\n        for(int i=k;i<n-k;i++)\\n            if(prefix[i-1]>=k && suffix[i+1]>=k)\\n                ans.push_back(i);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653742,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        left = [1]*n\\n        right = [1]*n\\n        for i in range(1,n):\\n            if nums[i-1]>=nums[i]:\\n                left[i] = left[i-1]+1\\n        for i in range(n-1):\\n            if nums[i+1]>=nums[i]:\\n                right[i+1] = right[i]+1\\n        res=[]\\n        for i in range(n):\\n            l = i-1\\n            r = i + k \\n            if 0<=l<n and 0<=r<n:\\n                lval = left[l]\\n                rval = right[r]\\n                if lval >=k and rval>=k:\\n                    res.append(i)\\n        return res\\n\\t\\t\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        left = [1]*n\\n        right = [1]*n\\n        for i in range(1,n):\\n            if nums[i-1]>=nums[i]:\\n                left[i] = left[i-1]+1\\n        for i in range(n-1):\\n            if nums[i+1]>=nums[i]:\\n                right[i+1] = right[i]+1\\n        res=[]\\n        for i in range(n):\\n            l = i-1\\n            r = i + k \\n            if 0<=l<n and 0<=r<n:\\n                lval = left[l]\\n                rval = right[r]\\n                if lval >=k and rval>=k:\\n                    res.append(i)\\n        return res\\n\\t\\t\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2644864,
                "title": "cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int len=nums.size();\\n        int inc[100005]={0};\\n        int dec[100005]={0};\\n        \\n        int ci=0;\\n        int cd=0;\\n        for(int i=1;i<len;i++)\\n        {\\n            if(i<len&&nums[i]>=nums[i-1])\\n            {\\n                ci++;\\n                inc[i]=ci;\\n            }\\n            else{\\n                inc[i]=0;\\n                ci=0;\\n            }\\n            \\n            if(i<len&&nums[i]<=nums[i-1])\\n            {\\n                cd++;\\n                dec[i]=cd;\\n                \\n            }else{\\n                dec[i]=0;\\n                cd=0;\\n            }\\n        }\\n         \\n        \\n        vector<int>res;\\n        for(int i=k;i<=len-1;i++)\\n        {\\n            if(i-k>=0&&i+k<len)\\n            {\\n         if(dec[i-1]-dec[i-k]+1==k&&inc[i+k]-inc[i+1]+1==k)\\n                {\\n                    res.push_back(i);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> goodIndices(vector<int>& nums, int k) {\\n        int len=nums.size();\\n        int inc[100005]={0};\\n        int dec[100005]={0};\\n        \\n        int ci=0;\\n        int cd=0;\\n        for(int i=1;i<len;i++)\\n        {\\n            if(i<len&&nums[i]>=nums[i-1])\\n            {\\n                ci++;\\n                inc[i]=ci;\\n            }\\n            else{\\n                inc[i]=0;\\n                ci=0;\\n            }\\n            \\n            if(i<len&&nums[i]<=nums[i-1])\\n            {\\n                cd++;\\n                dec[i]=cd;\\n                \\n            }else{\\n                dec[i]=0;\\n                cd=0;\\n            }\\n        }\\n         \\n        \\n        vector<int>res;\\n        for(int i=k;i<=len-1;i++)\\n        {\\n            if(i-k>=0&&i+k<len)\\n            {\\n         if(dec[i-1]-dec[i-k]+1==k&&inc[i+k]-inc[i+1]+1==k)\\n                {\\n                    res.push_back(i);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1768506,
                "content": [
                    {
                        "username": "jaspier",
                        "content": "I keep wondering if using words \"increasing\" and \"decreasing\" would be better than \"non-decreasing\" and \"non-increasing\"... It would make the description to read better, IMO"
                    },
                    {
                        "username": "RayanYI",
                        "content": "I think it\\'s because increasing mean\\'s > and non-decreasing >="
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is Same as `2100. Find Good Days to Rob the Bank` ! \\uD83E\\uDD72 \\n"
                    },
                    {
                        "username": "deleted_user_",
                        "content": "Oh, right! Just as I was thinking \"Haven\\'t I solved this problem already\\u2026?\""
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Leetcode can you please add more meaningful testcases,, these test cases are not even giving the idea of \"non-increasing\" from the index i to 0 or from index 0 to i."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE \\uD83D\\uDE22"
                    },
                    {
                        "username": "phoenix_qwerty",
                        "content": "//getting wrong ans //plz help\\n\\nclass Solution {\\npublic:\\n\\nbool checkBefore(vector<int> temp, int k)\\n{\\n    int l=temp.size();\\n    for(int i=0; i<l-k+1; i++)\\n    {\\n        if(temp[i]<temp[i+1])\\n        {\\n            return false;\\n        }\\n\\n    }\\n    return true;\\n    //==or all decrease// nor increase any how\\n}\\nbool checkAfter(vector<int> temp, int k)\\n{\\n     int l=temp.size();\\n    for(int i=0; i<l-k+1; i++)\\n    {\\n        if(temp[i]>temp[i+1])\\n        {\\n            return false;\\n        }\\n\\n    }\\n    return true;\\n    //and decrease\\n}\\n\\nvector<int> goodIndices(vector<int>& nums, int k) \\n {\\n    vector<int> arr1;\\n     int l=nums.size();\\n     int count=0;\\n     for(int i=k; i<l-2; i++)\\n     {\\n          vector<int> temp1;\\n          vector<int> temp2;\\n         bool k=true;\\n         temp1.assign(nums.begin()+i-k, nums.begin()+i-1);\\n         k=checkBefore(temp1,k);\\n         if(k==true)\\n           {\\n            temp2.assign(nums.begin()+i+1, nums.begin()+i+k);\\n            k=checkAfter(temp2,k);\\n            if(k==true)\\n            arr1.push_back(i);\\n            else return arr1;\\n            }\\n     }\\n  return arr1;\\n        \\n }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 2004576,
                "content": [
                    {
                        "username": "jaspier",
                        "content": "I keep wondering if using words \"increasing\" and \"decreasing\" would be better than \"non-decreasing\" and \"non-increasing\"... It would make the description to read better, IMO"
                    },
                    {
                        "username": "RayanYI",
                        "content": "I think it\\'s because increasing mean\\'s > and non-decreasing >="
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is Same as `2100. Find Good Days to Rob the Bank` ! \\uD83E\\uDD72 \\n"
                    },
                    {
                        "username": "deleted_user_",
                        "content": "Oh, right! Just as I was thinking \"Haven\\'t I solved this problem already\\u2026?\""
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Leetcode can you please add more meaningful testcases,, these test cases are not even giving the idea of \"non-increasing\" from the index i to 0 or from index 0 to i."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE \\uD83D\\uDE22"
                    },
                    {
                        "username": "phoenix_qwerty",
                        "content": "//getting wrong ans //plz help\\n\\nclass Solution {\\npublic:\\n\\nbool checkBefore(vector<int> temp, int k)\\n{\\n    int l=temp.size();\\n    for(int i=0; i<l-k+1; i++)\\n    {\\n        if(temp[i]<temp[i+1])\\n        {\\n            return false;\\n        }\\n\\n    }\\n    return true;\\n    //==or all decrease// nor increase any how\\n}\\nbool checkAfter(vector<int> temp, int k)\\n{\\n     int l=temp.size();\\n    for(int i=0; i<l-k+1; i++)\\n    {\\n        if(temp[i]>temp[i+1])\\n        {\\n            return false;\\n        }\\n\\n    }\\n    return true;\\n    //and decrease\\n}\\n\\nvector<int> goodIndices(vector<int>& nums, int k) \\n {\\n    vector<int> arr1;\\n     int l=nums.size();\\n     int count=0;\\n     for(int i=k; i<l-2; i++)\\n     {\\n          vector<int> temp1;\\n          vector<int> temp2;\\n         bool k=true;\\n         temp1.assign(nums.begin()+i-k, nums.begin()+i-1);\\n         k=checkBefore(temp1,k);\\n         if(k==true)\\n           {\\n            temp2.assign(nums.begin()+i+1, nums.begin()+i+k);\\n            k=checkAfter(temp2,k);\\n            if(k==true)\\n            arr1.push_back(i);\\n            else return arr1;\\n            }\\n     }\\n  return arr1;\\n        \\n }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1923234,
                "content": [
                    {
                        "username": "jaspier",
                        "content": "I keep wondering if using words \"increasing\" and \"decreasing\" would be better than \"non-decreasing\" and \"non-increasing\"... It would make the description to read better, IMO"
                    },
                    {
                        "username": "RayanYI",
                        "content": "I think it\\'s because increasing mean\\'s > and non-decreasing >="
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is Same as `2100. Find Good Days to Rob the Bank` ! \\uD83E\\uDD72 \\n"
                    },
                    {
                        "username": "deleted_user_",
                        "content": "Oh, right! Just as I was thinking \"Haven\\'t I solved this problem already\\u2026?\""
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Leetcode can you please add more meaningful testcases,, these test cases are not even giving the idea of \"non-increasing\" from the index i to 0 or from index 0 to i."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE \\uD83D\\uDE22"
                    },
                    {
                        "username": "phoenix_qwerty",
                        "content": "//getting wrong ans //plz help\\n\\nclass Solution {\\npublic:\\n\\nbool checkBefore(vector<int> temp, int k)\\n{\\n    int l=temp.size();\\n    for(int i=0; i<l-k+1; i++)\\n    {\\n        if(temp[i]<temp[i+1])\\n        {\\n            return false;\\n        }\\n\\n    }\\n    return true;\\n    //==or all decrease// nor increase any how\\n}\\nbool checkAfter(vector<int> temp, int k)\\n{\\n     int l=temp.size();\\n    for(int i=0; i<l-k+1; i++)\\n    {\\n        if(temp[i]>temp[i+1])\\n        {\\n            return false;\\n        }\\n\\n    }\\n    return true;\\n    //and decrease\\n}\\n\\nvector<int> goodIndices(vector<int>& nums, int k) \\n {\\n    vector<int> arr1;\\n     int l=nums.size();\\n     int count=0;\\n     for(int i=k; i<l-2; i++)\\n     {\\n          vector<int> temp1;\\n          vector<int> temp2;\\n         bool k=true;\\n         temp1.assign(nums.begin()+i-k, nums.begin()+i-1);\\n         k=checkBefore(temp1,k);\\n         if(k==true)\\n           {\\n            temp2.assign(nums.begin()+i+1, nums.begin()+i+k);\\n            k=checkAfter(temp2,k);\\n            if(k==true)\\n            arr1.push_back(i);\\n            else return arr1;\\n            }\\n     }\\n  return arr1;\\n        \\n }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1952328,
                "content": [
                    {
                        "username": "jaspier",
                        "content": "I keep wondering if using words \"increasing\" and \"decreasing\" would be better than \"non-decreasing\" and \"non-increasing\"... It would make the description to read better, IMO"
                    },
                    {
                        "username": "RayanYI",
                        "content": "I think it\\'s because increasing mean\\'s > and non-decreasing >="
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is Same as `2100. Find Good Days to Rob the Bank` ! \\uD83E\\uDD72 \\n"
                    },
                    {
                        "username": "deleted_user_",
                        "content": "Oh, right! Just as I was thinking \"Haven\\'t I solved this problem already\\u2026?\""
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Leetcode can you please add more meaningful testcases,, these test cases are not even giving the idea of \"non-increasing\" from the index i to 0 or from index 0 to i."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE \\uD83D\\uDE22"
                    },
                    {
                        "username": "phoenix_qwerty",
                        "content": "//getting wrong ans //plz help\\n\\nclass Solution {\\npublic:\\n\\nbool checkBefore(vector<int> temp, int k)\\n{\\n    int l=temp.size();\\n    for(int i=0; i<l-k+1; i++)\\n    {\\n        if(temp[i]<temp[i+1])\\n        {\\n            return false;\\n        }\\n\\n    }\\n    return true;\\n    //==or all decrease// nor increase any how\\n}\\nbool checkAfter(vector<int> temp, int k)\\n{\\n     int l=temp.size();\\n    for(int i=0; i<l-k+1; i++)\\n    {\\n        if(temp[i]>temp[i+1])\\n        {\\n            return false;\\n        }\\n\\n    }\\n    return true;\\n    //and decrease\\n}\\n\\nvector<int> goodIndices(vector<int>& nums, int k) \\n {\\n    vector<int> arr1;\\n     int l=nums.size();\\n     int count=0;\\n     for(int i=k; i<l-2; i++)\\n     {\\n          vector<int> temp1;\\n          vector<int> temp2;\\n         bool k=true;\\n         temp1.assign(nums.begin()+i-k, nums.begin()+i-1);\\n         k=checkBefore(temp1,k);\\n         if(k==true)\\n           {\\n            temp2.assign(nums.begin()+i+1, nums.begin()+i+k);\\n            k=checkAfter(temp2,k);\\n            if(k==true)\\n            arr1.push_back(i);\\n            else return arr1;\\n            }\\n     }\\n  return arr1;\\n        \\n }\\n};\\n\\n"
                    }
                ]
            },
            {
                "id": 1640016,
                "content": [
                    {
                        "username": "jaspier",
                        "content": "I keep wondering if using words \"increasing\" and \"decreasing\" would be better than \"non-decreasing\" and \"non-increasing\"... It would make the description to read better, IMO"
                    },
                    {
                        "username": "RayanYI",
                        "content": "I think it\\'s because increasing mean\\'s > and non-decreasing >="
                    },
                    {
                        "username": "ayyush_sharma",
                        "content": "This Question is Same as `2100. Find Good Days to Rob the Bank` ! \\uD83E\\uDD72 \\n"
                    },
                    {
                        "username": "deleted_user_",
                        "content": "Oh, right! Just as I was thinking \"Haven\\'t I solved this problem already\\u2026?\""
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "Leetcode can you please add more meaningful testcases,, these test cases are not even giving the idea of \"non-increasing\" from the index i to 0 or from index 0 to i."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "TLE \\uD83D\\uDE22"
                    },
                    {
                        "username": "phoenix_qwerty",
                        "content": "//getting wrong ans //plz help\\n\\nclass Solution {\\npublic:\\n\\nbool checkBefore(vector<int> temp, int k)\\n{\\n    int l=temp.size();\\n    for(int i=0; i<l-k+1; i++)\\n    {\\n        if(temp[i]<temp[i+1])\\n        {\\n            return false;\\n        }\\n\\n    }\\n    return true;\\n    //==or all decrease// nor increase any how\\n}\\nbool checkAfter(vector<int> temp, int k)\\n{\\n     int l=temp.size();\\n    for(int i=0; i<l-k+1; i++)\\n    {\\n        if(temp[i]>temp[i+1])\\n        {\\n            return false;\\n        }\\n\\n    }\\n    return true;\\n    //and decrease\\n}\\n\\nvector<int> goodIndices(vector<int>& nums, int k) \\n {\\n    vector<int> arr1;\\n     int l=nums.size();\\n     int count=0;\\n     for(int i=k; i<l-2; i++)\\n     {\\n          vector<int> temp1;\\n          vector<int> temp2;\\n         bool k=true;\\n         temp1.assign(nums.begin()+i-k, nums.begin()+i-1);\\n         k=checkBefore(temp1,k);\\n         if(k==true)\\n           {\\n            temp2.assign(nums.begin()+i+1, nums.begin()+i+k);\\n            k=checkAfter(temp2,k);\\n            if(k==true)\\n            arr1.push_back(i);\\n            else return arr1;\\n            }\\n     }\\n  return arr1;\\n        \\n }\\n};\\n\\n"
                    }
                ]
            }
        ]
    }
]