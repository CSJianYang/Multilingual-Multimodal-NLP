[
    {
        "title": "Form Array by Concatenating Subarrays of Another Array",
        "question_content": "You are given a 2D integer array groups of length n. You are also given an integer array nums.\nYou are asked if you can choose n disjoint subarrays from the array nums such that the ith subarray is equal to groups[i] (0-indexed), and if i > 0, the (i-1)th subarray appears before the ith subarray in nums (i.e. the subarrays must be in the same order as groups).\nReturn true if you can do this task, and false otherwise.\nNote that the subarrays are disjoint if and only if there is no index k such that nums[k] belongs to more than one subarray. A subarray is a contiguous sequence of elements within an array.\n&nbsp;\nExample 1:\n\nInput: groups = [[1,-1,-1],[3,-2,0]], nums = [1,-1,0,1,-1,-1,3,-2,0]\nOutput: true\nExplanation: You can choose the 0th subarray as [1,-1,0,1,-1,-1,3,-2,0] and the 1st one as [1,-1,0,1,-1,-1,3,-2,0].\nThese subarrays are disjoint as they share no common nums[k] element.\n\nExample 2:\n\nInput: groups = [[10,-2],[1,2,3,4]], nums = [1,2,3,4,10,-2]\nOutput: false\nExplanation: Note that choosing the subarrays [1,2,3,4,10,-2] and [1,2,3,4,10,-2] is incorrect because they are not in the same order as in groups.\n[10,-2] must come before [1,2,3,4].\n\nExample 3:\n\nInput: groups = [[1,2,3],[3,4]], nums = [7,7,1,2,3,4,7,7]\nOutput: false\nExplanation: Note that choosing the subarrays [7,7,1,2,3,4,7,7] and [7,7,1,2,3,4,7,7] is invalid because they are not disjoint.\nThey share a common elements nums[4] (0-indexed).\n\n&nbsp;\nConstraints:\n\n\tgroups.length == n\n\t1 <= n <= 103\n\t1 <= groups[i].length, sum(groups[i].length) <= 103\n\t1 <= nums.length <= 103\n\t-107 <= groups[i][j], nums[k] <= 107",
        "solutions": [
            {
                "id": 1074558,
                "title": "c-fast-solution-with-explanation-comments",
                "content": "Since every group must match a subarray (continguous), any time we have a mismatch we need to restart matching that group.\\n\\nWhen we have a mismatch, the element from `nums` array must be reconsidered as the first element of the current group.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums)\\n    {\\n        int numsIndex = 0;\\n        int groupsIndex = 0;\\n        \\n        while (numsIndex < nums.size() && groupsIndex < groups.size())\\n        {\\n\\t\\t\\t// Try to match as many members of the current group as possible\\n            int matchCount = 0;\\n            while (numsIndex + matchCount < nums.size() &&\\n                   matchCount < groups[groupsIndex].size() &&\\n                   nums[numsIndex + matchCount] == groups[groupsIndex][matchCount])\\n                ++matchCount;\\n            \\n\\t\\t\\t// Did we match the entire current group?\\n            if (matchCount == groups[groupsIndex].size())\\n            {\\n\\t\\t\\t\\t// the group was matched\\n                ++groupsIndex;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// since there must not be overlap between groups\\n\\t\\t\\t\\t// we must match the next group at next element in nums\\n                numsIndex += matchCount;\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// unsucessful in matching all elements of current group\\n\\t\\t\\t\\t// retry matching the group from start at next element in nums\\n                ++numsIndex;\\n            }\\n        }\\n        \\n        return groupsIndex == groups.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums)\\n    {\\n        int numsIndex = 0;\\n        int groupsIndex = 0;\\n        \\n        while (numsIndex < nums.size() && groupsIndex < groups.size())\\n        {\\n\\t\\t\\t// Try to match as many members of the current group as possible\\n            int matchCount = 0;\\n            while (numsIndex + matchCount < nums.size() &&\\n                   matchCount < groups[groupsIndex].size() &&\\n                   nums[numsIndex + matchCount] == groups[groupsIndex][matchCount])\\n                ++matchCount;\\n            \\n\\t\\t\\t// Did we match the entire current group?\\n            if (matchCount == groups[groupsIndex].size())\\n            {\\n\\t\\t\\t\\t// the group was matched\\n                ++groupsIndex;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// since there must not be overlap between groups\\n\\t\\t\\t\\t// we must match the next group at next element in nums\\n                numsIndex += matchCount;\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// unsucessful in matching all elements of current group\\n\\t\\t\\t\\t// retry matching the group from start at next element in nums\\n                ++numsIndex;\\n            }\\n        }\\n        \\n        return groupsIndex == groups.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074555,
                "title": "python3-check-group-one-by-one",
                "content": "\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        i = 0\\n        for grp in groups: \\n            for ii in range(i, len(nums)):\\n                if nums[ii:ii+len(grp)] == grp: \\n                    i = ii + len(grp)\\n                    break \\n            else: return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        i = 0\\n        for grp in groups: \\n            for ii in range(i, len(nums)):\\n                if nums[ii:ii+len(grp)] == grp: \\n                    i = ii + len(grp)\\n                    break \\n            else: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074554,
                "title": "simple-cpp-solution-using-stl-search-function",
                "content": "search for each group in nums array and update the starting iterator simultaneiusly and if at any instant we do not get the group in nums array simply return false. else continue until do no get all groups and return true..\\nhope below given code will help you !!!\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        vector<int>::iterator itr=nums.begin();\\n        for (int i=0;i<groups.size();i++)\\n        {\\n            itr=search(itr,nums.end(),groups[i].begin(),groups[i].end());\\n            if (itr==nums.end())\\n                return false;\\n            else itr=itr+groups[i].size();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        vector<int>::iterator itr=nums.begin();\\n        for (int i=0;i<groups.size();i++)\\n        {\\n            itr=search(itr,nums.end(),groups[i].begin(),groups[i].end());\\n            if (itr==nums.end())\\n                return false;\\n            else itr=itr+groups[i].size();\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074946,
                "title": "c-simple-search-kmp",
                "content": "I am still not sure whether we can use the \"disjoint\" property to speed-up the search...\\n\\n> Update 1: OJ does not seem to enforce \"disjoint\" property, so we can get rid of the check.\\n\\n> Update 2: See KMP-based solution below!\\n\\nThe approach below just check that groups does not have overapping elements, and does the basic search. It works since `n` is limited to `1000`. \\n\\n> Note that we only need to find the first (earliest) occurence of the group. No need to search further.\\n```cpp\\nbool canChoose(vector<vector<int>>& groups, vector<int>& nums, int i = 0, int j = 0) {\\n    if (i >= groups.size())\\n        return true;\\n    for (; j <= nums.size() - groups[i].size(); ++j) {\\n        for (auto gi = 0; gi <= groups[i].size(); ++gi) {\\n            if (gi == groups[i].size())\\n                return canChoose(groups, nums, i + 1, j + groups[i].size());\\n            if (nums[j + gi] != groups[i][gi])\\n                break;\\n        }\\n    }\\n    return false;\\n}\\n```\\n**KMP**\\nKMP does not seem to help the runtime due to test cases and constraint. I think that LeetCode wasted a good problem by making in Easy by relaxing the constraints.\\n\\nBut nonetheless - you should use KMP where you can to reduce runtime from `m * n` to `m + n`.\\n\\n```cpp\\nvector<int> buildPrefix(vector<int> &v) {\\n    vector<int> kmp(v.size() + 1);\\n    for (int slow = 0, fast = 1; fast < v.size(); ++fast) {\\n        if (v[slow] == v[fast]) {\\n            kmp[fast + 1] = ++slow;\\n        }\\n        else if (slow != 0) {\\n            slow = kmp[slow];\\n            --fast;\\n        }\\n    }    \\n    return kmp;\\n}\\nbool canChoose(vector<vector<int>>& g, vector<int>& nums, int i = 0, int j = 0) {\\n    if (i >= g.size())\\n        return true;\\n    auto kmp = buildPrefix(g[i]);\\n    for (int k = 0; j <= nums.size() - g[i].size(); ++k) {\\n        if (k == g[i].size())\\n            return canChoose(g, nums, i + 1, j + k);   \\n        if (nums[j + k] != g[i][k]) {\\n            j += max(1, k - kmp[k]);\\n            k = kmp[k] - 1;            \\n        }\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool canChoose(vector<vector<int>>& groups, vector<int>& nums, int i = 0, int j = 0) {\\n    if (i >= groups.size())\\n        return true;\\n    for (; j <= nums.size() - groups[i].size(); ++j) {\\n        for (auto gi = 0; gi <= groups[i].size(); ++gi) {\\n            if (gi == groups[i].size())\\n                return canChoose(groups, nums, i + 1, j + groups[i].size());\\n            if (nums[j + gi] != groups[i][gi])\\n                break;\\n        }\\n    }\\n    return false;\\n}\\n```\n```cpp\\nvector<int> buildPrefix(vector<int> &v) {\\n    vector<int> kmp(v.size() + 1);\\n    for (int slow = 0, fast = 1; fast < v.size(); ++fast) {\\n        if (v[slow] == v[fast]) {\\n            kmp[fast + 1] = ++slow;\\n        }\\n        else if (slow != 0) {\\n            slow = kmp[slow];\\n            --fast;\\n        }\\n    }    \\n    return kmp;\\n}\\nbool canChoose(vector<vector<int>>& g, vector<int>& nums, int i = 0, int j = 0) {\\n    if (i >= g.size())\\n        return true;\\n    auto kmp = buildPrefix(g[i]);\\n    for (int k = 0; j <= nums.size() - g[i].size(); ++k) {\\n        if (k == g[i].size())\\n            return canChoose(g, nums, i + 1, j + k);   \\n        if (nums[j + k] != g[i][k]) {\\n            j += max(1, k - kmp[k]);\\n            k = kmp[k] - 1;            \\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074593,
                "title": "java-simple",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int i=0;\\n        for(int start =0;i < groups.length && groups[i].length+start <= nums.length;start++)\\n            if(search(groups[i], nums, start)) \\n                start += groups[i++].length - 1;\\n        return i==groups.length;\\n    }\\n    private boolean search(int[] group, int[] nums, int start) {\\n        for(int i=0;i<group.length;i++) \\n            if(group[i] != nums[i+start])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int i=0;\\n        for(int start =0;i < groups.length && groups[i].length+start <= nums.length;start++)\\n            if(search(groups[i], nums, start)) \\n                start += groups[i++].length - 1;\\n        return i==groups.length;\\n    }\\n    private boolean search(int[] group, int[] nums, int start) {\\n        for(int i=0;i<group.length;i++) \\n            if(group[i] != nums[i+start])\\n                return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074665,
                "title": "kmp-java-o-n-m",
                "content": "m: nums.length\\nn: the number of elements in groups;\\nTime: O(m+n)\\nSpace: O(n)\\n```\\n  \\n    private boolean sln2(int[][] groups, int[] nums){\\n        int n = groups.length;\\n        int m = nums.length;\\n        \\n        int[][] prefixes = new int[n][];\\n        for(int i = 0;i<n;i++) prefixes[i] = getPrefix(groups[i]);\\n        int j = 0;\\n        for(int i = 0;i< m && j<n;){\\n            int index = search(nums, groups[j], prefixes[j], i);\\n            if(index<0) return false;\\n            j++;\\n            i = index;\\n        }\\n        return j==n;\\n    }\\n    \\n    private int[] getPrefix(int[] arr){\\n        int n = arr.length;\\n        int[] res = new int[n];\\n        for(int i = 1, j =0; i<n;){\\n            if(arr[i] == arr[j]){\\n                res[i]  = j+1;\\n                i++;j++;\\n            }else if(j>0){\\n                j = res[j-1];\\n            }else{\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int search(int[] arr1, int[] arr2, int[] prefix, int startIndex){\\n        int m = arr1.length;\\n        int n = arr2.length;\\n        for(int i = startIndex, j = 0; i<m;){\\n            if(arr1[i] == arr2[j]){\\n                i++;j++;\\n            }else if(j>0){\\n                j = prefix[j-1];\\n            }else{\\n                i++;\\n            }\\n            \\n            if(j==n) return i;\\n        }\\n        return -1;\\n    }\\n",
                "solutionTags": [],
                "code": "m: nums.length\\nn: the number of elements in groups;\\nTime: O(m+n)\\nSpace: O(n)\\n```\\n  \\n    private boolean sln2(int[][] groups, int[] nums){\\n        int n = groups.length;\\n        int m = nums.length;\\n        \\n        int[][] prefixes = new int[n][];\\n        for(int i = 0;i<n;i++) prefixes[i] = getPrefix(groups[i]);\\n        int j = 0;\\n        for(int i = 0;i< m && j<n;){\\n            int index = search(nums, groups[j], prefixes[j], i);\\n            if(index<0) return false;\\n            j++;\\n            i = index;\\n        }\\n        return j==n;\\n    }\\n    \\n    private int[] getPrefix(int[] arr){\\n        int n = arr.length;\\n        int[] res = new int[n];\\n        for(int i = 1, j =0; i<n;){\\n            if(arr[i] == arr[j]){\\n                res[i]  = j+1;\\n                i++;j++;\\n            }else if(j>0){\\n                j = res[j-1];\\n            }else{\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private int search(int[] arr1, int[] arr2, int[] prefix, int startIndex){\\n        int m = arr1.length;\\n        int n = arr2.length;\\n        for(int i = startIndex, j = 0; i<m;){\\n            if(arr1[i] == arr2[j]){\\n                i++;j++;\\n            }else if(j>0){\\n                j = prefix[j-1];\\n            }else{\\n                i++;\\n            }\\n            \\n            if(j==n) return i;\\n        }\\n        return -1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1074549,
                "title": "simple-java-solution-commented",
                "content": "```\\npublic boolean canChoose(int[][] groups, int[] nums) {\\n        int grpIndex = 0;\\n\\n        for(int i = 0; i < nums.length && grpIndex < groups.length; i++) {\\n            if(nums[i] == groups[grpIndex][0]) {\\n\\t\\t\\t// First element of group matched\\n                int j = i;\\n                int x = 0;\\n\\t\\t\\t\\t// check if the remaining elements are also matching\\n                while(j < nums.length && x < groups[grpIndex].length && nums[j] == groups[grpIndex][x]) {\\n                    j++;\\n                    x++;\\n                }\\n                if(x == groups[grpIndex].length) {\\n\\t\\t\\t\\t\\t// all digits matched. This is a valid group. check the next one.\\n                    grpIndex++;\\n                    i = j - 1; // i will be incremented by the for loop, so one char will get missed. This will avoid that\\n                }\\n            }\\n        }\\n\\n        return grpIndex == groups.length;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canChoose(int[][] groups, int[] nums) {\\n        int grpIndex = 0;\\n\\n        for(int i = 0; i < nums.length && grpIndex < groups.length; i++) {\\n            if(nums[i] == groups[grpIndex][0]) {\\n\\t\\t\\t// First element of group matched\\n                int j = i;\\n                int x = 0;\\n\\t\\t\\t\\t// check if the remaining elements are also matching\\n                while(j < nums.length && x < groups[grpIndex].length && nums[j] == groups[grpIndex][x]) {\\n                    j++;\\n                    x++;\\n                }\\n                if(x == groups[grpIndex].length) {\\n\\t\\t\\t\\t\\t// all digits matched. This is a valid group. check the next one.\\n                    grpIndex++;\\n                    i = j - 1; // i will be incremented by the for loop, so one char will get missed. This will avoid that\\n                }\\n            }\\n        }\\n\\n        return grpIndex == groups.length;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1074544,
                "title": "c-kmp-solution-o-m-n-time-o-n-space",
                "content": "```\\nclass Solution {\\npublic:\\n    //Idea is to use KMP Longest Prefix Suffix array to match if one array is subarray of another array.\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int m = nums.size();\\n        int index = 0;\\n        for(auto group : groups){\\n            int n = group.size();\\n            //Step-1 Generate LPS\\n            vector<int>lps(n,0);\\n            for(int i = 1;i<n; i++){\\n                int j = lps[i-1];\\n                while(j>0 && group[i] != group[j]){\\n                    j = lps[j-1];\\n                }\\n                if(group[i] == group[j]){\\n                    j++;\\n                }\\n                lps[i] = j;\\n            }\\n            \\n            //Step 2 - Matching\\n            int j = 0;\\n            while(index<m){\\n                if(nums[index]==group[j]){\\n                    j++;\\n                    index++;\\n                }\\n                if(j==n)\\n                    break;\\n                else\\n                 if(index <m && nums[index] != group[j]){\\n                    if(j >0){\\n                        j=lps[j-1];\\n                    }else{\\n                        index++;\\n                    }\\n                }\\n            }\\n            if(j != n)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Idea is to use KMP Longest Prefix Suffix array to match if one array is subarray of another array.\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int m = nums.size();\\n        int index = 0;\\n        for(auto group : groups){\\n            int n = group.size();\\n            //Step-1 Generate LPS\\n            vector<int>lps(n,0);\\n            for(int i = 1;i<n; i++){\\n                int j = lps[i-1];\\n                while(j>0 && group[i] != group[j]){\\n                    j = lps[j-1];\\n                }\\n                if(group[i] == group[j]){\\n                    j++;\\n                }\\n                lps[i] = j;\\n            }\\n            \\n            //Step 2 - Matching\\n            int j = 0;\\n            while(index<m){\\n                if(nums[index]==group[j]){\\n                    j++;\\n                    index++;\\n                }\\n                if(j==n)\\n                    break;\\n                else\\n                 if(index <m && nums[index] != group[j]){\\n                    if(j >0){\\n                        j=lps[j-1];\\n                    }else{\\n                        index++;\\n                    }\\n                }\\n            }\\n            if(j != n)\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336560,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        ln=len(groups)\\n        idx=0\\n        for i in groups:\\n            for j in range(idx,len(nums)):\\n                if nums[j:j+len(i)]==i:\\n                    idx=j+len(i)\\n                    ln-=1\\n                    break\\n        return ln==0\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String Matching"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        ln=len(groups)\\n        idx=0\\n        for i in groups:\\n            for j in range(idx,len(nums)):\\n                if nums[j:j+len(i)]==i:\\n                    idx=j+len(i)\\n                    ln-=1\\n                    break\\n        return ln==0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074759,
                "title": "simple-c-solution",
                "content": "```\\n  bool canChoose(vector<vector<int>>& g, vector<int>& v) \\n    {\\n        int start=0;\\n        int i=0;\\n        int cnt=0;\\n        \\n        while(i<g.size() and start < v.size())\\n        {\\n           bool flage=false; // to check if from the start point if array is find or not\\n           for(int k=0;k<g[i].size();k++){\\n               if(g[i][k]!=v[start+k]){\\n                   flage=true;\\n                   break;\\n               }\\n           }\\n           if(flage==false){ // if we found the array then make start as start+g[i].size() and to take next array by doing i++ and also just take cnt var to cnt the number of find array in that \\n               start=start+g[i].size();\\n               i++;\\n               cnt++;\\n           }\\n           else //suppose we did not find the required array from present start point then increase the start by 1\\n              start++;\\n        }\\n        if(cnt==g.size())\\n            return true;\\n        return false;\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  bool canChoose(vector<vector<int>>& g, vector<int>& v) \\n    {\\n        int start=0;\\n        int i=0;\\n        int cnt=0;\\n        \\n        while(i<g.size() and start < v.size())\\n        {\\n           bool flage=false; // to check if from the start point if array is find or not\\n           for(int k=0;k<g[i].size();k++){\\n               if(g[i][k]!=v[start+k]){\\n                   flage=true;\\n                   break;\\n               }\\n           }\\n           if(flage==false){ // if we found the array then make start as start+g[i].size() and to take next array by doing i++ and also just take cnt var to cnt the number of find array in that \\n               start=start+g[i].size();\\n               i++;\\n               cnt++;\\n           }\\n           else //suppose we did not find the required array from present start point then increase the start by 1\\n              start++;\\n        }\\n        if(cnt==g.size())\\n            return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2363974,
                "title": "c-two-approach-two-pointer-o-m-n-kmp-o-m-n",
                "content": "This problem is easy if we do it using two pointers. This approach becomes brute force which can be done in O(m * n) time complexity. Another approach is using KMP algorithm which subsequently reduces the time complexity from M * N to M + N. \\n\\n#### Method 1 : Two pointers\\n\\nWe take two pointer variables, one for the `nums` vector, another for the `groups` vectors. Now, we find each of the group vector into nums one by one and if we manage to find all of them in `nums`, we can return `true` else we return `false`; The implementation of this method is simple. We iterate nums with `i` and groups with `idx` and each time we get a match, we check the next subarray if it is equal to groups[idx] or not. If it is equal, we move ahead else we break and look for next match.\\n\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int idx = 0, i=0;\\n        while(idx<groups.size() and i<nums.size()){\\n            if(groups[idx][0]==nums[i]){\\n                int j = 0, k=i;\\n                for(; k<nums.size() and j<groups[idx].size(); k++){\\n                    if(groups[idx][j] == nums[k]) j++;\\n                    else break;\\n                }\\n                if(j==groups[idx].size()) idx++, i=k;\\n                else i++;\\n            }\\n            else i++;\\n        }\\n        return idx == groups.size();\\n    }\\n};\\n```\\n\\n#### Method 2 : KMP\\nThis method is a bit tricky to catch. What we do is, we find the LPS array of `nums` and store it in a vector named `pi`.  Now for each group vector in `groups`, we check if this vector can be found in nums using this LPS. Now on first look, the code might look like O(m * n) but it is not. This is because in above algorithm, if we match the first character, we iterate over next `group[idx].size()-1` characters and check if they match with the characters in `nums`. Now if they match, its ok, but if they dont match, we break the loop and just move the `nums` pointer by 1. \\n**BUT**\\nIn below method, using KMP, if we find a mismatch, we dont just move the nums pointer by 1, instead we use the LPS array to move backwards, and we only go till the point where we are getting a mismatch. That\\'s what KMP does. It restricts us to move backwards once we get a common subarray. Thus, if at any point, we can\\'t move back, then only, we increase our `nums` pointer by 1. \\n\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int idx = 0;\\n\\t\\tvector <int> pi = kmp(nums);\\n            \\n        for(auto group : groups){\\n            int j = 0;\\n\\t\\t\\t// We can see that idx never comes backwards. So we are traversing nums only once. \\n            while(idx<nums.size() and j<group.size()){\\n\\t\\t\\t\\t// If both elements match, we move both pointers.\\n                if(nums[idx]==group[j]) {\\n                    j++, idx++;\\n                }\\n                else{\\n\\t\\t\\t\\t\\t// In case of mismatch, we come backwards upto the point where elements are not matching. \\n                    if(j>0) j = pi[j-1];\\n                    else{\\n\\t\\t\\t\\t\\t\\t// If we can\\'t go backwards, we move the nums pointer forward. \\n                        idx++;\\n                    }\\n                }\\n            }\\n\\t\\t\\t// If nums is finished before groups, we return false\\n            if(j<group.size() and idx==nums.size()) return false;\\n        }\\n        return true;\\n    }\\nprotected:\\n\\t// Standard KMP function\\n    vector <int> kmp(vector <int> &str){\\n        vector <int> pi(str.size()+5,0);\\n        for(int i = 1; i<str.size(); i++){\\n            int j = pi[i-1];\\n            while(j>0 and str[i]!=str[j]) j = pi[j-1];\\n            if(str[i]==str[j]) j++;\\n            pi[i] = j;\\n        }\\n        return pi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int idx = 0, i=0;\\n        while(idx<groups.size() and i<nums.size()){\\n            if(groups[idx][0]==nums[i]){\\n                int j = 0, k=i;\\n                for(; k<nums.size() and j<groups[idx].size(); k++){\\n                    if(groups[idx][j] == nums[k]) j++;\\n                    else break;\\n                }\\n                if(j==groups[idx].size()) idx++, i=k;\\n                else i++;\\n            }\\n            else i++;\\n        }\\n        return idx == groups.size();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int idx = 0;\\n\\t\\tvector <int> pi = kmp(nums);\\n            \\n        for(auto group : groups){\\n            int j = 0;\\n\\t\\t\\t// We can see that idx never comes backwards. So we are traversing nums only once. \\n            while(idx<nums.size() and j<group.size()){\\n\\t\\t\\t\\t// If both elements match, we move both pointers.\\n                if(nums[idx]==group[j]) {\\n                    j++, idx++;\\n                }\\n                else{\\n\\t\\t\\t\\t\\t// In case of mismatch, we come backwards upto the point where elements are not matching. \\n                    if(j>0) j = pi[j-1];\\n                    else{\\n\\t\\t\\t\\t\\t\\t// If we can\\'t go backwards, we move the nums pointer forward. \\n                        idx++;\\n                    }\\n                }\\n            }\\n\\t\\t\\t// If nums is finished before groups, we return false\\n            if(j<group.size() and idx==nums.size()) return false;\\n        }\\n        return true;\\n    }\\nprotected:\\n\\t// Standard KMP function\\n    vector <int> kmp(vector <int> &str){\\n        vector <int> pi(str.size()+5,0);\\n        for(int i = 1; i<str.size(); i++){\\n            int j = pi[i-1];\\n            while(j>0 and str[i]!=str[j]) j = pi[j-1];\\n            if(str[i]==str[j]) j++;\\n            pi[i] = j;\\n        }\\n        return pi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341486,
                "title": "easy-java-solution-0-ms-faster-than-100-00-sliding-window",
                "content": "```\\nclass Solution {\\n    \\n    public int search(int[] group, int[] nums, int start, int end )\\n    {\\n        int i=start, j=0;\\n        while(i<end && j<group.length)\\n        {\\n            if(nums[i] == group[j])\\n            {\\n                i++;\\n                j++;\\n\\n                if(j == group.length)\\n                    return i;\\n            }\\n\\n            else {\\n                i = i - j + 1;\\n                j = 0;\\n            }\\n\\n        }\\n        return -1;\\n    }\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int start=0, end =nums.length;\\n        \\n        for(int[] group : groups)\\n        {\\n            start = search(group, nums, start, end);\\n            if(start == -1)\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int search(int[] group, int[] nums, int start, int end )\\n    {\\n        int i=start, j=0;\\n        while(i<end && j<group.length)\\n        {\\n            if(nums[i] == group[j])\\n            {\\n                i++;\\n                j++;\\n\\n                if(j == group.length)\\n                    return i;\\n            }\\n\\n            else {\\n                i = i - j + 1;\\n                j = 0;\\n            }\\n\\n        }\\n        return -1;\\n    }\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int start=0, end =nums.length;\\n        \\n        for(int[] group : groups)\\n        {\\n            start = search(group, nums, start, end);\\n            if(start == -1)\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911063,
                "title": "c-building-the-solution-string-find-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string normalize(vector<int> &nums)\\n    {\\n        string ans = \"\";\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=to_string(nums[i]);\\n            ans+=\"#\";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        string base = normalize(nums);\\n        int prevpos = 0;\\n        bool flag = true;\\n        for(int i=0;i<groups.size();i++)\\n        {\\n            vector<int> v = groups[i];\\n            string tofind = normalize(v);\\n            if(base.find(tofind,prevpos) != string::npos)\\n            {\\n                int currpos = base.find(tofind,prevpos);\\n                bool check = true;\\n                if(currpos!=0 && base[currpos-1]!=\\'#\\')\\n                {\\n                    check = false;\\n                }\\n                if(currpos+tofind.length()!=base.length() && base[currpos+tofind.length()]!=\\'#\\')\\n                {\\n                    check = false;\\n                }\\n                if(check==false)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                if(currpos<prevpos)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                else\\n                {\\n                    prevpos= currpos+tofind.length();\\n                }\\n            }\\n            else\\n            {\\n                flag = false;\\n                break;\\n            }\\n        }\\n\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string normalize(vector<int> &nums)\\n    {\\n        string ans = \"\";\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=to_string(nums[i]);\\n            ans+=\"#\";\\n        }\\n        ans.pop_back();\\n        return ans;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        string base = normalize(nums);\\n        int prevpos = 0;\\n        bool flag = true;\\n        for(int i=0;i<groups.size();i++)\\n        {\\n            vector<int> v = groups[i];\\n            string tofind = normalize(v);\\n            if(base.find(tofind,prevpos) != string::npos)\\n            {\\n                int currpos = base.find(tofind,prevpos);\\n                bool check = true;\\n                if(currpos!=0 && base[currpos-1]!=\\'#\\')\\n                {\\n                    check = false;\\n                }\\n                if(currpos+tofind.length()!=base.length() && base[currpos+tofind.length()]!=\\'#\\')\\n                {\\n                    check = false;\\n                }\\n                if(check==false)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                if(currpos<prevpos)\\n                {\\n                    flag = false;\\n                    break;\\n                }\\n                else\\n                {\\n                    prevpos= currpos+tofind.length();\\n                }\\n            }\\n            else\\n            {\\n                flag = false;\\n                break;\\n            }\\n        }\\n\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080571,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findGroup(vector<int>nums,int l,int h,vector<int>grp){\\n        int len=grp.size();\\n        int idx=-1;\\n        for(int i=l;i<=(h-len+1);i++){\\n            int k=i;\\n            if(nums[i]==grp[0]){\\n                int j=0;;\\n                for(;j<grp.size();j++){\\n                    if(nums[i]!=grp[j])break;\\n                    i++;\\n                }\\n                if(j==grp.size()){\\n                    idx=k;\\n                    break;\\n                }\\n            }\\n            i=k;\\n\\n        }\\n        cout<<idx;\\n        return idx;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int prev_start=-1,prev_end=-1;\\n\\n        for(int i=0;i<groups.size();i++){\\n            int idx=-1;\\n            if(i==0){\\n               idx=findGroup(nums,0,nums.size()-1,groups[i]);\\n            }\\n            else if(i!=0){\\n                if(prev_end+1>=nums.size())return false;\\n                idx=findGroup(nums,prev_end+1,nums.size()-1,groups[i]);\\n            }\\n\\n            if(idx==-1)return false;\\n            else{\\n                prev_start=idx;\\n                prev_end=prev_start+groups[i].size()-1;\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findGroup(vector<int>nums,int l,int h,vector<int>grp){\\n        int len=grp.size();\\n        int idx=-1;\\n        for(int i=l;i<=(h-len+1);i++){\\n            int k=i;\\n            if(nums[i]==grp[0]){\\n                int j=0;;\\n                for(;j<grp.size();j++){\\n                    if(nums[i]!=grp[j])break;\\n                    i++;\\n                }\\n                if(j==grp.size()){\\n                    idx=k;\\n                    break;\\n                }\\n            }\\n            i=k;\\n\\n        }\\n        cout<<idx;\\n        return idx;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int prev_start=-1,prev_end=-1;\\n\\n        for(int i=0;i<groups.size();i++){\\n            int idx=-1;\\n            if(i==0){\\n               idx=findGroup(nums,0,nums.size()-1,groups[i]);\\n            }\\n            else if(i!=0){\\n                if(prev_end+1>=nums.size())return false;\\n                idx=findGroup(nums,prev_end+1,nums.size()-1,groups[i]);\\n            }\\n\\n            if(idx==-1)return false;\\n            else{\\n                prev_start=idx;\\n                prev_end=prev_start+groups[i].size()-1;\\n                \\n            }\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1074660,
                "title": "python3-simple-convert-to-string-solution",
                "content": "Build **s** string from nums array and **g**  string from each group array using delimeter (thank\\'s to @ajith6198) and search starting index of group in **s**. If no match found - return False. If Found - crop everything before found index and continue.\\n\\n\\n\\tclass Solution:\\n\\t\\tdef canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n\\t\\t\\ts = \"#\" + \"#\".join(map(str, nums))\\n\\n\\t\\t\\tfor group in groups:\\n\\t\\t\\t\\tg = \"#\" + \"#\".join(map(str, group))\\n\\n\\t\\t\\t\\tif not s:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\ti = s.find(g)\\n\\n\\t\\t\\t\\tif i == -1:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\ts = s[i + len(g):]\\n\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "Build **s** string from nums array and **g**  string from each group array using delimeter (thank\\'s to @ajith6198) and search starting index of group in **s**. If no match found - return False. If Found - crop everything before found index and continue.\\n\\n\\n\\tclass Solution:\\n\\t\\tdef canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n\\t\\t\\ts = \"#\" + \"#\".join(map(str, nums))\\n\\n\\t\\t\\tfor group in groups:\\n\\t\\t\\t\\tg = \"#\" + \"#\".join(map(str, group))\\n\\n\\t\\t\\t\\tif not s:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\ti = s.find(g)\\n\\n\\t\\t\\t\\tif i == -1:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\ts = s[i + len(g):]\\n\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 1074629,
                "title": "python-3-string-built-in-find-explanation",
                "content": "### Explanation\\n- Convert int array to string\\n- Use `find()` to check status\\n- It\\'s slow but intuitive, to me at least\\n### Implementation\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        groups = [\\'-\\'.join(str(s) for s in group) for group in groups]\\n        nums = \\'-\\'.join(str(s) for s in nums)\\n        j = k = 0\\n        while k < len(groups):\\n            group = groups[k]\\n            i = nums.find(group, j)\\n            if i == -1: return False\\n            if i == 0 or i > 0 and nums[i-1] == \\'-\\':\\n                j = i + len(group)\\n                k += 1\\n            else: j += 1\\n        return True    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        groups = [\\'-\\'.join(str(s) for s in group) for group in groups]\\n        nums = \\'-\\'.join(str(s) for s in nums)\\n        j = k = 0\\n        while k < len(groups):\\n            group = groups[k]\\n            i = nums.find(group, j)\\n            if i == -1: return False\\n            if i == 0 or i > 0 and nums[i-1] == \\'-\\':\\n                j = i + len(group)\\n                k += 1\\n            else: j += 1\\n        return True    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016035,
                "title": "super-simple-python-solution-check-one-by-one",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        pointer = 0\\n        \\n        groups.reverse()\\n        \\n        while pointer <= len(nums):\\n            if len(groups) == 0:\\n                return True\\n            currentGroup = groups[-1]\\n            if nums[pointer:pointer+len(currentGroup)] == currentGroup:\\n                pointer += len(currentGroup)\\n                groups.pop()\\n            else:\\n                pointer += 1\\n                \\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        pointer = 0\\n        \\n        groups.reverse()\\n        \\n        while pointer <= len(nums):\\n            if len(groups) == 0:\\n                return True\\n            currentGroup = groups[-1]\\n            if nums[pointer:pointer+len(currentGroup)] == currentGroup:\\n                pointer += len(currentGroup)\\n                groups.pop()\\n            else:\\n                pointer += 1\\n                \\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914636,
                "title": "simple-approach-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf You just read and trace than also you will understand . No need for explanation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust Checking iteratively if groups[i] is present or not . If not then go back again and check .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n        for(int i=0;i<groups.length;i++)\\n        {\\n            int j=0;\\n            int k=0;\\n            for(;j<nums.length && k<groups[i].length;)\\n            {\\n                if(nums[j] == groups[i][k])\\n                {\\n                    k++;\\n                    j++;\\n                }  \\n                else\\n                {\\n                    j = j-k+1;\\n                    k=0;\\n                }\\n            }\\n            if(k!=groups[i].length)\\n            {\\n                return false;\\n            }\\n            j--;\\n            while(j!=-1)\\n            {\\n                nums[j] = Integer.MIN_VALUE;\\n                j--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n        for(int i=0;i<groups.length;i++)\\n        {\\n            int j=0;\\n            int k=0;\\n            for(;j<nums.length && k<groups[i].length;)\\n            {\\n                if(nums[j] == groups[i][k])\\n                {\\n                    k++;\\n                    j++;\\n                }  \\n                else\\n                {\\n                    j = j-k+1;\\n                    k=0;\\n                }\\n            }\\n            if(k!=groups[i].length)\\n            {\\n                return false;\\n            }\\n            j--;\\n            while(j!=-1)\\n            {\\n                nums[j] = Integer.MIN_VALUE;\\n                j--;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292072,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) \\n    {\\n        int n=groups.size(), ns=nums.size();\\n        int cnt=0;\\n        int st=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            int f=0;\\n            for(int y=st; y<ns; y++)\\n            {\\n                int i=0, j=y;\\n                while(i<groups[x].size() && groups[x][i]==nums[j])\\n                {\\n                    i++; j++;\\n                }\\n                if(i==groups[x].size()) \\n                {\\n                    cnt++;\\n                    st=j;\\n                    f=1;\\n                    break;\\n                }\\n            }\\n            if(!f) return false;\\n        }\\n        if(cnt==n) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) \\n    {\\n        int n=groups.size(), ns=nums.size();\\n        int cnt=0;\\n        int st=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            int f=0;\\n            for(int y=st; y<ns; y++)\\n            {\\n                int i=0, j=y;\\n                while(i<groups[x].size() && groups[x][i]==nums[j])\\n                {\\n                    i++; j++;\\n                }\\n                if(i==groups[x].size()) \\n                {\\n                    cnt++;\\n                    st=j;\\n                    f=1;\\n                    break;\\n                }\\n            }\\n            if(!f) return false;\\n        }\\n        if(cnt==n) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3042230,
                "title": "easy-two-pointer-approach-java",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int n=groups.length;\\n        int ncol=groups[0].length;\\n        int row=0;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int j=i;\\n            int col=0;\\n            \\n            while(col<groups[row].length && j<nums.length && groups[row][col]==nums[j])\\n            {\\n                col++;\\n                j++;\\n            }\\n            \\n            if(col==groups[row].length)\\n            {\\n                row++;\\n                i=j-1;\\n            }\\n            \\n            if(row==groups.length)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int n=groups.length;\\n        int ncol=groups[0].length;\\n        int row=0;\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int j=i;\\n            int col=0;\\n            \\n            while(col<groups[row].length && j<nums.length && groups[row][col]==nums[j])\\n            {\\n                col++;\\n                j++;\\n            }\\n            \\n            if(col==groups[row].length)\\n            {\\n                row++;\\n                i=j-1;\\n            }\\n            \\n            if(row==groups.length)\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810802,
                "title": "indexof-approach",
                "content": "# Intuition\\nidea is to find the index, \\nremove every thing before it from the array if exist for next search\\nelse return false\\n\\nHope this helps :)\\n\\n# Code\\n```\\nvar canChoose = function(groups, nums) {\\n    //why add \" \"? to prevent indexOf finds wrong number \\n    //eg(12 and 2 will return value not -1)\\n    nums.unshift(\" \")\\n    var ns = nums.join(\" \");\\n    var pos = 0;\\n    \\n    for(let i = 0; i < groups.length; i++) {\\n        let s = groups[i].join(\" \");\\n        ns = ns.slice(pos);\\n\\n        let index = ns.indexOf(\" \" + s);\\n\\n        if(index === -1) return false;\\n\\n        pos = index + groups[i].length + 3;\\n    }\\n\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canChoose = function(groups, nums) {\\n    //why add \" \"? to prevent indexOf finds wrong number \\n    //eg(12 and 2 will return value not -1)\\n    nums.unshift(\" \")\\n    var ns = nums.join(\" \");\\n    var pos = 0;\\n    \\n    for(let i = 0; i < groups.length; i++) {\\n        let s = groups[i].join(\" \");\\n        ns = ns.slice(pos);\\n\\n        let index = ns.indexOf(\" \" + s);\\n\\n        if(index === -1) return false;\\n\\n        pos = index + groups[i].length + 3;\\n    }\\n\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2684100,
                "title": "c-kmp-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool canChoose(vector<vector<int>>& groups, vector<int>& nums, int i = 0, int j = 0) {\\n    if (i >= groups.size())\\n        return true;\\n    for (; j <= nums.size() - groups[i].size(); ++j) {\\n        for (auto gi = 0; gi <= groups[i].size(); ++gi) {\\n            if (gi == groups[i].size())\\n                return canChoose(groups, nums, i + 1, j + groups[i].size());\\n            if (nums[j + gi] != groups[i][gi])\\n                break;\\n        }\\n    }\\n    return false;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool canChoose(vector<vector<int>>& groups, vector<int>& nums, int i = 0, int j = 0) {\\n    if (i >= groups.size())\\n        return true;\\n    for (; j <= nums.size() - groups[i].size(); ++j) {\\n        for (auto gi = 0; gi <= groups[i].size(); ++gi) {\\n            if (gi == groups[i].size())\\n                return canChoose(groups, nums, i + 1, j + groups[i].size());\\n            if (nums[j + gi] != groups[i][gi])\\n                break;\\n        }\\n    }\\n    return false;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281846,
                "title": "simple-python-solution-without-kmp",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        # transform groups list into str\\n        for i in range(len(groups)):\\n            l1=[str(m) for m in groups[i]]        \\n            s=\\'_\\'.join(l1)\\n\\t\\t\\t#To prevent errors like the one below, we need to decorate each string\\n\\t\\t\\t#in case some problem like groups=[[12,1]]   nums=[2,1]\\n            s=\\'_\\'+s+\\'_\\'\\n            groups[i]=(s,len(s))\\n            \\n        # also we transform the nums into str\\n        l=[str(m) for m in nums]\\n        str_nums=\\'_\\'.join(l)\\n\\t\\t#This step is to facilitate starting position matching\\n        str_nums=\\'_\\'+str_nums+\\'_\\'\\n        \\n        for item in groups:\\n            if item[0] not in str_nums :\\n                return False\\n\\t\\t\\t#if it matches we cut the front part\\n            idx=str_nums.index(item[0])\\n            str_nums=str_nums[idx+item[1]-1:]\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        # transform groups list into str\\n        for i in range(len(groups)):\\n            l1=[str(m) for m in groups[i]]        \\n            s=\\'_\\'.join(l1)\\n\\t\\t\\t#To prevent errors like the one below, we need to decorate each string\\n\\t\\t\\t#in case some problem like groups=[[12,1]]   nums=[2,1]\\n            s=\\'_\\'+s+\\'_\\'\\n            groups[i]=(s,len(s))\\n            \\n        # also we transform the nums into str\\n        l=[str(m) for m in nums]\\n        str_nums=\\'_\\'.join(l)\\n\\t\\t#This step is to facilitate starting position matching\\n        str_nums=\\'_\\'+str_nums+\\'_\\'\\n        \\n        for item in groups:\\n            if item[0] not in str_nums :\\n                return False\\n\\t\\t\\t#if it matches we cut the front part\\n            idx=str_nums.index(item[0])\\n            str_nums=str_nums[idx+item[1]-1:]\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170577,
                "title": "python-no-kmp",
                "content": "```\\nclass Solution:\\n    def canChoose(self, y: List[List[int]], x: List[int]) -> bool:\\n        l=len(x)\\n        ly=len(y)\\n        j=0\\n        i=0\\n        while i<l:\\n            if j==ly:return True\\n            if i+len(y[j])-1>=l:return False\\n            if all(y[j][k]==x[i+k] for k in range(len(y[j]))):\\n                i+=len(y[j])\\n                j+=1\\n            else:\\n                i+=1\\n        return j==ly\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChoose(self, y: List[List[int]], x: List[int]) -> bool:\\n        l=len(x)\\n        ly=len(y)\\n        j=0\\n        i=0\\n        while i<l:\\n            if j==ly:return True\\n            if i+len(y[j])-1>=l:return False\\n            if all(y[j][k]==x[i+k] for k in range(len(y[j]))):\\n                i+=len(y[j])\\n                j+=1\\n            else:\\n                i+=1\\n        return j==ly\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031481,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSame(vector<int> &A,vector<int> &B,int x){\\n        for(int i=0;i<A.size();i++){\\n            if(A[i]!=B[x++])\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size(),m = groups.size();\\n        int size = groups[0].size();\\n        int j = 0;\\n        for(int i=0;i<n;i++){\\n            if(size <= n-i && isSame(groups[j],nums,i)){\\n                j++;\\n                i += size-1; \\n                size = j<m ? groups[j].size() : 0;\\n            }\\n            if(j==m)\\n                break;\\n        }\\n        return j==m ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSame(vector<int> &A,vector<int> &B,int x){\\n        for(int i=0;i<A.size();i++){\\n            if(A[i]!=B[x++])\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size(),m = groups.size();\\n        int size = groups[0].size();\\n        int j = 0;\\n        for(int i=0;i<n;i++){\\n            if(size <= n-i && isSame(groups[j],nums,i)){\\n                j++;\\n                i += size-1; \\n                size = j<m ? groups[j].size() : 0;\\n            }\\n            if(j==m)\\n                break;\\n        }\\n        return j==m ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972098,
                "title": "easy-kmp-string-matching-algo-beats-92",
                "content": "Nothing fancy just do below Question you get understanding (KMP)\\nhttps://leetcode.com/problems/implement-strstr/\\nhttps://www.youtube.com/watch?v=Gjkhm1gYIMw\\n\\n\\n    class Solution {\\n\\tpublic:\\n\\t\\tbool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n\\t\\t\\tint i,k=0,prev;\\n\\t\\t\\tfor(auto arr:groups){\\n\\n\\t\\t\\t\\t// below code is of KMP\\n\\t\\t\\t\\tvector<int>LPS(arr.size(),0);\\n\\t\\t\\t\\tfor(i=1,prev=0;i<arr.size();++i){\\n\\t\\t\\t\\t\\twhile(prev&& arr[prev]!=arr[i])prev=LPS[prev-1];\\n\\n\\t\\t\\t\\t\\tif(arr[prev]==arr[i]) LPS[i]=++prev;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// this code is to match with LSP\\n\\t\\t\\t\\tfor(prev=0;k<nums.size()&&prev<arr.size();){\\n\\t\\t\\t\\t\\tif(nums[k]==arr[prev])++k,++prev;\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tif(prev)prev=LPS[prev-1];\\n\\t\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t\\t++k;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(prev<arr.size())return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n\\t\\t\\tint i,k=0,prev;\\n\\t\\t\\tfor(auto arr:groups){\\n\\n\\t\\t\\t\\t// below code is of KMP\\n\\t\\t\\t\\tvector<int>LPS(arr.size(),0);\\n\\t\\t\\t\\tfor(i=1,prev=0;i<arr.size();++i){\\n\\t\\t\\t\\t\\twhile(prev&& arr[prev]!=arr[i])prev=LPS[prev-1];\\n\\n\\t\\t\\t\\t\\tif(arr[prev]==arr[i]) LPS[i]=++prev;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1424343,
                "title": "python-sliding-window",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        i = 0\\n        gidx = 0\\n        while i < len(nums):\\n            group = groups[gidx]\\n            if group[0] == nums[i] and len(nums)-i >= len(group):\\n                # check group is in nums\\n                included = True\\n                for j in range(len(group)):\\n                    if group[j] != nums[i+j]:\\n                        included = False\\n                        break\\n                if included:\\n                    gidx += 1\\n                    i += j + 1                 \\n                else:\\n                    i += 1\\n            else:\\n                i += 1\\n            # print(i)\\n            if gidx >= len(groups):\\n                return True\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        i = 0\\n        gidx = 0\\n        while i < len(nums):\\n            group = groups[gidx]\\n            if group[0] == nums[i] and len(nums)-i >= len(group):\\n                # check group is in nums\\n                included = True\\n                for j in range(len(group)):\\n                    if group[j] != nums[i+j]:\\n                        included = False\\n                        break\\n                if included:\\n                    gidx += 1\\n                    i += j + 1                 \\n                else:\\n                    i += 1\\n            else:\\n                i += 1\\n            # print(i)\\n            if gidx >= len(groups):\\n                return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249703,
                "title": "python-recursion",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        \\n        \\n        \\n        def rec(groups,nums):\\n            if(len(groups)==0):\\n                return True\\n            \\n            for i in range(len(nums)):\\n                if(nums[i]==groups[0][0]):\\n                    if(nums[i:i+len(groups[0])]==groups[0]):\\n                        return rec(groups[1::],nums[i+len(groups[0]):])\\n                    \\n            return False\\n        \\n        return rec(groups,nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        \\n        \\n        \\n        def rec(groups,nums):\\n            if(len(groups)==0):\\n                return True\\n            \\n            for i in range(len(nums)):\\n                if(nums[i]==groups[0][0]):\\n                    if(nums[i:i+len(groups[0])]==groups[0]):\\n                        return rec(groups[1::],nums[i+len(groups[0]):])\\n                    \\n            return False\\n        \\n        return rec(groups,nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1197186,
                "title": "python3-simple-approach-with-comments-beats-94-and-97",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        \\n        k=0                         \\n        found = 0\\n        j = 0\\n        \\n        # traverse the whole nums list, \\n        ## if nums[k] is same as the value of 0\\'th index of a group\\n        ## check whether the subarray of nums starting at index k upto index k+len(group)-1 is same as group\\n        ## if so, increase k and found variables accordingly\\n        ## otherwise increment k\\n        while k<len(nums):\\n            if k==len(nums) or found==len(groups):          #reached the end of list nums or matched all the groups\\n                break\\n            if nums[k]==groups[j][0]:                       #as groups must be in nums in the given order, start checking from group at index 0\\n                if nums[k:k+len(groups[j])]==groups[j]:     #check whether the subarray matches the group\\n                    found+=1\\n                    k+=len(groups[j])                       #increase k by the length of the group\\n                    j+=1                                    #increment j\\n                else:\\n                    k+=1                                    #not matched, increment k\\n            else:\\n                k+=1                                        #nums[k] does not match leftmost value of group, increment k\\n                \\n        return found==len(groups)                           \\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        \\n        k=0                         \\n        found = 0\\n        j = 0\\n        \\n        # traverse the whole nums list, \\n        ## if nums[k] is same as the value of 0\\'th index of a group\\n        ## check whether the subarray of nums starting at index k upto index k+len(group)-1 is same as group\\n        ## if so, increase k and found variables accordingly\\n        ## otherwise increment k\\n        while k<len(nums):\\n            if k==len(nums) or found==len(groups):          #reached the end of list nums or matched all the groups\\n                break\\n            if nums[k]==groups[j][0]:                       #as groups must be in nums in the given order, start checking from group at index 0\\n                if nums[k:k+len(groups[j])]==groups[j]:     #check whether the subarray matches the group\\n                    found+=1\\n                    k+=len(groups[j])                       #increase k by the length of the group\\n                    j+=1                                    #increment j\\n                else:\\n                    k+=1                                    #not matched, increment k\\n            else:\\n                k+=1                                        #nums[k] does not match leftmost value of group, increment k\\n                \\n        return found==len(groups)                           \\n",
                "codeTag": "Java"
            },
            {
                "id": 1192783,
                "title": "unique-solution-without-using-kmp-algorithm",
                "content": "I have been trying to solve this problem without the knowledge of KMP algorithm. This solution may not be the optimal solution but I found it worth sharing with the LC community as it might present a different angle to approaching the problem. \\n\\nHere\\'s how the solution works:\\n\\n**Part 1: Stringify the nums array** \\n\\nConvert the nums array into a string with each element enclosed between \".\"\\n\\n\\t    string str = \"\";\\n        vector<int> vec; //this vector will store the index of the end of the subarray given in groups if it exists and the conditions are met \\n        for(auto i: nums)\\n            str += \".\"+to_string(i)+\".\";\\n\\nif nums is `nums: [1,-1,0,1,-1,-1,3,-2,0]` after this part, the `string str` will look like this: \\n\\n\\t\\t   .1..-1..0..1..-1..-1..3..-2..0.\\n\\n**Part 2:**\\n\\nIterate over all the groups and stringify each group before checking their existence in the string str.\\n\\n\\n\\tfor(int i = 0; i<groups.size(); i++)\\n        {\\n            string fnd = \"\";\\n            \\n            for(auto j: groups[i])\\n                fnd += \".\"+to_string(j)+\".\";\\n            \\n            auto val1 = str.find(fnd); // Find the first occcurence of the element fnd in the string \\n            auto val2= str.rfind(fnd); // Find the last occcurence of the element fnd in the string \\n            int val;\\n            \\n\\t\\t\\t// Based on the conditions below check and select the appropriate value of index to be considered (val1 or val2)\\n\\t\\t\\t\\n            if(!vec.empty() and vec.back()<val1 and vec.back()<val2)    val = val1<val2?val1:val2; \\n            else if(!vec.empty() and vec.back()>val1 and vec.back()<val2) val = val2;\\n            else if(!vec.empty() and vec.back()<val1 and vec.back()>val2) val = val1;\\n            else val = val1;\\n            \\n\\n            \\n            if(val>= 0 and val<str.length())  // if the val is in range of the array (i.e. the subarray exists in the array)\\n            {\\n               \\n                if(!vec.empty() and vec.back()>val) return false;  // if the previous group\\'s end index occurs after the start index of the current group return false;\\n                \\n\\t\\t\\t\\t// if the conditions are met, make all the characters corresponding to the string fnd equal to \\'i\\' to indicate that those are occupied. Since we must not consider overlapping values.\\n\\t\\t\\t\\t\\n                for(int i = val; i<val+fnd.size(); i++)\\n                    str[i] = \\'i\\';\\n                vec.push_back(val+fnd.size()-1);\\n                \\n            }\\n            \\n\\t\\t\\t// if the val is not in the range, it means that the substring fnd does not exists in the given string. Thus return false.\\n\\t\\t\\t\\n            else return false;\\n        }\\n\\t\\t\\nIf after this iteration nothing has been returned, return true as all the cases that could lead to a false result are been considered in the iteration. \\n\\n**Complete Code:**\\n\\n```\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        \\n        string str = \"\";\\n        \\n        vector<int> vec;\\n        \\n        for(auto i: nums)\\n            str += \".\"+to_string(i)+\".\";\\n\\n        for(int i = 0; i<groups.size(); i++)\\n        {\\n            \\n            string fnd = \"\";\\n            \\n            for(auto j: groups[i])\\n                fnd += \".\"+to_string(j)+\".\";\\n            \\n            auto val1 = str.find(fnd);\\n            auto val2= str.rfind(fnd);\\n            int val;\\n            \\n            if(!vec.empty() and vec.back()<val1 and vec.back()<val2)    val = val1<val2?val1:val2;\\n            else if(!vec.empty() and vec.back()>val1 and vec.back()<val2) val = val2;\\n            else if(!vec.empty() and vec.back()<val1 and vec.back()>val2) val = val1;\\n            else val = val1;\\n            \\n\\n            \\n            if(val>= 0 and val<str.length())\\n            {\\n                if(!vec.empty() and vec.back()>val) return false;\\n                \\n                for(int i = val; i<val+fnd.size(); i++)\\n                    str[i] = \\'i\\';\\n                vec.push_back(val+fnd.size()-1);\\n                \\n            }\\n            \\n            else return false;\\n        }\\n        \\n        return true;\\n\\t}\\n\\n```\\n\\nHappy Leetcoding!",
                "solutionTags": [],
                "code": "```\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        \\n        string str = \"\";\\n        \\n        vector<int> vec;\\n        \\n        for(auto i: nums)\\n            str += \".\"+to_string(i)+\".\";\\n\\n        for(int i = 0; i<groups.size(); i++)\\n        {\\n            \\n            string fnd = \"\";\\n            \\n            for(auto j: groups[i])\\n                fnd += \".\"+to_string(j)+\".\";\\n            \\n            auto val1 = str.find(fnd);\\n            auto val2= str.rfind(fnd);\\n            int val;\\n            \\n            if(!vec.empty() and vec.back()<val1 and vec.back()<val2)    val = val1<val2?val1:val2;\\n            else if(!vec.empty() and vec.back()>val1 and vec.back()<val2) val = val2;\\n            else if(!vec.empty() and vec.back()<val1 and vec.back()>val2) val = val1;\\n            else val = val1;\\n            \\n\\n            \\n            if(val>= 0 and val<str.length())\\n            {\\n                if(!vec.empty() and vec.back()>val) return false;\\n                \\n                for(int i = val; i<val+fnd.size(); i++)\\n                    str[i] = \\'i\\';\\n                vec.push_back(val+fnd.size()-1);\\n                \\n            }\\n            \\n            else return false;\\n        }\\n        \\n        return true;\\n\\t}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1168697,
                "title": "java-straightforward-solution-using-dfs",
                "content": "```\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        return dfs(groups, nums, 0, 0);\\n    }\\n\\t\\n\\t//if find pos-th group equals to certain segment of array, continue checking (pos+1)-th group following the previous checked segment\\n\\t//if pos-th group doesn\\'t equal to segment from current start position i of nums, we look for the next position i+1 as the new start\\n\\t//position, till find the equal segment in the nums\\n    private boolean dfs(int[][] groups, int[] nums, int pos, int i)\\n    {\\n        if(pos == groups.length) return true;\\n        \\n        if(i >= nums.length) return false;\\n        \\n        if(isEqual(groups[pos], nums, i)) return dfs(groups, nums, pos + 1, i + groups[pos].length);\\n        \\n        return dfs(groups, nums, pos, i + 1);\\n    }\\n\\t//check if certain group equals to certain segment of nums array\\n    private boolean isEqual(int[] group, int[] nums, int i)\\n    {\\n        for(int j = 0; j < group.length; j++)\\n        {\\n            if(i >= nums.length||group[j] != nums[i]) return false;\\n            i++;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        return dfs(groups, nums, 0, 0);\\n    }\\n\\t\\n\\t//if find pos-th group equals to certain segment of array, continue checking (pos+1)-th group following the previous checked segment\\n\\t//if pos-th group doesn\\'t equal to segment from current start position i of nums, we look for the next position i+1 as the new start\\n\\t//position, till find the equal segment in the nums\\n    private boolean dfs(int[][] groups, int[] nums, int pos, int i)\\n    {\\n        if(pos == groups.length) return true;\\n        \\n        if(i >= nums.length) return false;\\n        \\n        if(isEqual(groups[pos], nums, i)) return dfs(groups, nums, pos + 1, i + groups[pos].length);\\n        \\n        return dfs(groups, nums, pos, i + 1);\\n    }\\n\\t//check if certain group equals to certain segment of nums array\\n    private boolean isEqual(int[] group, int[] nums, int i)\\n    {\\n        for(int j = 0; j < group.length; j++)\\n        {\\n            if(i >= nums.length||group[j] != nums[i]) return false;\\n            i++;\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114819,
                "title": "java-simple-10-line-solution",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int count = 0; // num of matches\\n        int m = 0; // index in group array\\n        // iterate through the nums array, i is the pointer\\n        for (int i = 0; i < nums.length - groups[m].length + 1; i++) {\\n            int[] sub = Arrays.copyOfRange(nums, i, i + groups[m].length);\\n            // find a match\\n            if (Arrays.equals(sub, groups[m])) {\\n                count++;\\n                i += groups[m++].length - 1; // update pointer index\\n                if (count == groups.length) return true;\\n            }\\n        }    \\n        return count == groups.length ? true : false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int count = 0; // num of matches\\n        int m = 0; // index in group array\\n        // iterate through the nums array, i is the pointer\\n        for (int i = 0; i < nums.length - groups[m].length + 1; i++) {\\n            int[] sub = Arrays.copyOfRange(nums, i, i + groups[m].length);\\n            // find a match\\n            if (Arrays.equals(sub, groups[m])) {\\n                count++;\\n                i += groups[m++].length - 1; // update pointer index\\n                if (count == groups.length) return true;\\n            }\\n        }    \\n        return count == groups.length ? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091082,
                "title": "short-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i = 0, j = 0;\\n        \\n        while (i < groups.size() && j < nums.size()) {\\n            int jj = j, s = 0;\\n            for (; s < groups[i].size() && jj < nums.size(); ++s, ++jj)\\n                if (groups[i][s] != nums[jj])\\n                    break;\\n\\n            if (s == groups[i].size())\\n                ++i, j = jj;\\n            else\\n                ++j;\\n        }\\n        \\n        return i == groups.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i = 0, j = 0;\\n        \\n        while (i < groups.size() && j < nums.size()) {\\n            int jj = j, s = 0;\\n            for (; s < groups[i].size() && jj < nums.size(); ++s, ++jj)\\n                if (groups[i][s] != nums[jj])\\n                    break;\\n\\n            if (s == groups[i].size())\\n                ++i, j = jj;\\n            else\\n                ++j;\\n        }\\n        \\n        return i == groups.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083204,
                "title": "python3-dynamic-programming-solution",
                "content": "cont variable is used to satisfy the property that each group must be continuous.\\n\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        grouplen = len(groups)\\n        numslen = len(nums)\\n        @lru_cache(None)\\n        def f(groupindex, innerindex, cont ,numsindex):\\n            if groupindex == grouplen:\\n                return True\\n            if numsindex == numslen:\\n                return False\\n            # we match\\n            ok = False\\n            if groups[groupindex][innerindex] == nums[numsindex]:\\n                if innerindex == len(groups[groupindex]) - 1:\\n                    ok |= f(groupindex + 1, 0, 1 ,numsindex + 1)\\n                else:\\n                    ok |= f(groupindex, innerindex + 1, 1 ,numsindex + 1)\\n            # we don\\'t match\\n            ok |= f(groupindex, 0, 0 ,numsindex + 1)\\n            return ok\\n        return f(0,0,0,0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        grouplen = len(groups)\\n        numslen = len(nums)\\n        @lru_cache(None)\\n        def f(groupindex, innerindex, cont ,numsindex):\\n            if groupindex == grouplen:\\n                return True\\n            if numsindex == numslen:\\n                return False\\n            # we match\\n            ok = False\\n            if groups[groupindex][innerindex] == nums[numsindex]:\\n                if innerindex == len(groups[groupindex]) - 1:\\n                    ok |= f(groupindex + 1, 0, 1 ,numsindex + 1)\\n                else:\\n                    ok |= f(groupindex, innerindex + 1, 1 ,numsindex + 1)\\n            # we don\\'t match\\n            ok |= f(groupindex, 0, 0 ,numsindex + 1)\\n            return ok\\n        return f(0,0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076189,
                "title": "java-clean-readable-solution",
                "content": "```\\nclass Solution {    \\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int numIndex = 0;\\n        int groupIndex = 0;\\n        boolean hasGroupsToMatch = groupIndex < groups.length;\\n        boolean hasNumsLeft = numIndex < nums.length;\\n        \\n        while (hasGroupsToMatch && hasNumsLeft) {\\n            int[] currentGroup = groups[groupIndex];\\n            \\n            int matchCount = getHowManyNumbersMatch(currentGroup, nums, numIndex);\\n            \\n            if (matchCount == currentGroup.length) {\\n                groupIndex++;\\n                hasGroupsToMatch = groupIndex < groups.length;\\n            }\\n            \\n            numIndex += matchCount != 0 ? matchCount : 1;\\n            hasNumsLeft = numIndex < nums.length;\\n        }\\n        \\n        return groupIndex >= groups.length;\\n    }\\n    \\n    public int getHowManyNumbersMatch(int[] group, int[] nums, int numIndex) {\\n        int matchCount = 0;\\n        for (int i = 0; i < group.length && numIndex < nums.length; i++, numIndex++) {\\n            if (group[i] == nums[numIndex]) {\\n                matchCount++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return matchCount;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int numIndex = 0;\\n        int groupIndex = 0;\\n        boolean hasGroupsToMatch = groupIndex < groups.length;\\n        boolean hasNumsLeft = numIndex < nums.length;\\n        \\n        while (hasGroupsToMatch && hasNumsLeft) {\\n            int[] currentGroup = groups[groupIndex];\\n            \\n            int matchCount = getHowManyNumbersMatch(currentGroup, nums, numIndex);\\n            \\n            if (matchCount == currentGroup.length) {\\n                groupIndex++;\\n                hasGroupsToMatch = groupIndex < groups.length;\\n            }\\n            \\n            numIndex += matchCount != 0 ? matchCount : 1;\\n            hasNumsLeft = numIndex < nums.length;\\n        }\\n        \\n        return groupIndex >= groups.length;\\n    }\\n    \\n    public int getHowManyNumbersMatch(int[] group, int[] nums, int numIndex) {\\n        int matchCount = 0;\\n        for (int i = 0; i < group.length && numIndex < nums.length; i++, numIndex++) {\\n            if (group[i] == nums[numIndex]) {\\n                matchCount++;\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        return matchCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076014,
                "title": "java-simple-implementation",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int index = 0;\\n        for(int i = 0; i < nums.length && index < groups.length; i++){\\n            if(nums[i] == groups[index][0]){\\n              int k = i;\\n              int j = 0;   \\n              while(k < nums.length && j < groups[index].length && nums[k] == groups[index][j]){       \\n                k++;\\n                j++;\\n              }\\n                \\n              if(j == groups[index].length){\\n                  index++;\\n                  i = k - 1;\\n            }\\n          }\\n        }\\n        \\n        return index == groups.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int index = 0;\\n        for(int i = 0; i < nums.length && index < groups.length; i++){\\n            if(nums[i] == groups[index][0]){\\n              int k = i;\\n              int j = 0;   \\n              while(k < nums.length && j < groups[index].length && nums[k] == groups[index][j]){       \\n                k++;\\n                j++;\\n              }\\n                \\n              if(j == groups[index].length){\\n                  index++;\\n                  i = k - 1;\\n            }\\n          }\\n        }\\n        \\n        return index == groups.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075924,
                "title": "c-swift-o-m-linear-solution-100-runtime-space",
                "content": "Providing an alternative to what I\\'ve seem so far. M is len(nums).  Instead of looping through each group, we iterate through each number in nums, and keep updating two pointers on group (gPos, nPos). Reset nPos if not matched. \\n\\nC++ solution \\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int gPos = 0, nPos = 0;\\n        for (int val : nums) {\\n            if (val != groups[gPos][nPos]) { nPos = 0; }\\n            if (val == groups[gPos][nPos]) { nPos += 1; }\\n            if (nPos == groups[gPos].size()) {\\n                gPos += 1;\\n                nPos = 0;\\n                if (gPos == groups.size()) { break; }\\n            }\\n        }\\n        return gPos == groups.size();\\n    }\\n};\\n```\\n\\nSwift \\n```\\n  var gPos = 0, nPos = 0\\n  for val in nums {\\n    if val != groups[gPos][nPos] { nPos = 0 }\\n    if val == groups[gPos][nPos] { nPos += 1 }\\n    if nPos == groups[gPos].count {\\n      gPos += 1\\n      nPos = 0\\n      if gPos == groups.count { break }\\n    }\\n  }\\n  return gPos == groups.count\\n```\\n\\nIn practice, if M is large, we can skip certain positions of nums and jump forward to next index of group[gPos][0] by first building an index of value -> [pos] from nums.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int gPos = 0, nPos = 0;\\n        for (int val : nums) {\\n            if (val != groups[gPos][nPos]) { nPos = 0; }\\n            if (val == groups[gPos][nPos]) { nPos += 1; }\\n            if (nPos == groups[gPos].size()) {\\n                gPos += 1;\\n                nPos = 0;\\n                if (gPos == groups.size()) { break; }\\n            }\\n        }\\n        return gPos == groups.size();\\n    }\\n};\\n```\n```\\n  var gPos = 0, nPos = 0\\n  for val in nums {\\n    if val != groups[gPos][nPos] { nPos = 0 }\\n    if val == groups[gPos][nPos] { nPos += 1 }\\n    if nPos == groups[gPos].count {\\n      gPos += 1\\n      nPos = 0\\n      if gPos == groups.count { break }\\n    }\\n  }\\n  return gPos == groups.count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075740,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        start=0\\n        for i in groups:\\n            for k in range(start,len(nums)):\\n                if nums[k:k+len(i)]==i:\\n                    start=k+len(i)\\n                    break\\n            else:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        start=0\\n        for i in groups:\\n            for k in range(start,len(nums)):\\n                if nums[k:k+len(i)]==i:\\n                    start=k+len(i)\\n                    break\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074722,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function(groups, nums) {\\n    let i=0;\\n    for(let start=0;i<groups.length&&groups[i].length+start<=nums.length;start++){\\n        \\n        if(search(groups[i], nums, start)){\\n            start+=groups[i].length-1;\\n            i++;\\n        }\\n    }\\n    return i==groups.length;\\n    \\n    function search(group, nums, start){\\n        for(let i =0;i<group.length;i++){\\n            if(group[i]!=nums[i+start]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function(groups, nums) {\\n    let i=0;\\n    for(let start=0;i<groups.length&&groups[i].length+start<=nums.length;start++){\\n        \\n        if(search(groups[i], nums, start)){\\n            start+=groups[i].length-1;\\n            i++;\\n        }\\n    }\\n    return i==groups.length;\\n    \\n    function search(group, nums, start){\\n        for(let i =0;i<group.length;i++){\\n            if(group[i]!=nums[i+start]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058461,
                "title": "c-easy-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int sz=nums.size();\\n        int g=0;\\n        \\n           for(int i=0;i<sz;i++)\\n             {\\n               vector<int>sub;\\n               for(int j=i;j<sz;j++)\\n                 {\\n                   sub.push_back(nums[j]);\\n                   //is the subbbray and the group are equal then we increment gorup and move i to j so that it will not repeat\\n                    if(sub.size()==groups[g].size() and  groups[g]==sub)\\n                         {\\n                               g++;\\n                               //if g is equal to gorup size then return true it\\'s end\\n                           if(g==groups.size())\\n                                return true;\\n                                //move i to j because we want disjoint and break \\n                                i=j;\\n                            break;\\n                         }\\n                        \\n                     \\n                 }\\n             }\\n             return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int sz=nums.size();\\n        int g=0;\\n        \\n           for(int i=0;i<sz;i++)\\n             {\\n               vector<int>sub;\\n               for(int j=i;j<sz;j++)\\n                 {\\n                   sub.push_back(nums[j]);\\n                   //is the subbbray and the group are equal then we increment gorup and move i to j so that it will not repeat\\n                    if(sub.size()==groups[g].size() and  groups[g]==sub)\\n                         {\\n                               g++;\\n                               //if g is equal to gorup size then return true it\\'s end\\n                           if(g==groups.size())\\n                                return true;\\n                                //move i to j because we want disjoint and break \\n                                i=j;\\n                            break;\\n                         }\\n                        \\n                     \\n                 }\\n             }\\n             return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950156,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int numInd=0;\\n        int grpInd=0;\\n        while(numInd<nums.size() && grpInd<groups.size())\\n        {\\n            int match=0;\\n            while(numInd+match<nums.size() && match<groups[grpInd].size() && nums[numInd+match]==groups[grpInd][match]) match++;\\n            if (match==groups[grpInd].size()) \\n            {\\n                grpInd++;\\n                numInd+=match;\\n            }\\n            else{\\n              numInd++;\\n            }\\n        }\\n        return grpInd==groups.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int numInd=0;\\n        int grpInd=0;\\n        while(numInd<nums.size() && grpInd<groups.size())\\n        {\\n            int match=0;\\n            while(numInd+match<nums.size() && match<groups[grpInd].size() && nums[numInd+match]==groups[grpInd][match]) match++;\\n            if (match==groups[grpInd].size()) \\n            {\\n                grpInd++;\\n                numInd+=match;\\n            }\\n            else{\\n              numInd++;\\n            }\\n        }\\n        return grpInd==groups.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907770,
                "title": "c-easiest",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        // Intution\\n        // The idea in here is really very simple. We will keep two pointers one for the subarray with in the group and the other on the nums value. We will check if the curret value of the current group number is equal to value of nums if so then we will check till the end of the value. If we have not found the result then we will again start.\\n\\n        int grpNo = 0;\\n\\n        int i = 0;\\n\\n        int size = nums.size();\\n\\n        int grpSize = groups.size();\\n\\n        while( i < size ){\\n            if(grpNo >= grpSize) return true;\\n            \\n            if(groups[grpNo][0] == nums[i]){\\n                int currGroupSize = groups[grpNo].size();\\n                int j = 0;\\n                int start = i;\\n\\n                while(j < currGroupSize and i < size){\\n\\n                    if(groups[grpNo][j] == nums[start]){\\n                        j++;\\n                        start++;\\n                    }\\n\\n                    else break;\\n                }\\n                if(j == currGroupSize) {\\n                    grpNo += 1;\\n                    i = start;\\n                    }\\n                else i++;\\n            }\\n\\n            else i++;\\n\\n        }\\n\\n        return grpNo >= grpSize;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        // Intution\\n        // The idea in here is really very simple. We will keep two pointers one for the subarray with in the group and the other on the nums value. We will check if the curret value of the current group number is equal to value of nums if so then we will check till the end of the value. If we have not found the result then we will again start.\\n\\n        int grpNo = 0;\\n\\n        int i = 0;\\n\\n        int size = nums.size();\\n\\n        int grpSize = groups.size();\\n\\n        while( i < size ){\\n            if(grpNo >= grpSize) return true;\\n            \\n            if(groups[grpNo][0] == nums[i]){\\n                int currGroupSize = groups[grpNo].size();\\n                int j = 0;\\n                int start = i;\\n\\n                while(j < currGroupSize and i < size){\\n\\n                    if(groups[grpNo][j] == nums[start]){\\n                        j++;\\n                        start++;\\n                    }\\n\\n                    else break;\\n                }\\n                if(j == currGroupSize) {\\n                    grpNo += 1;\\n                    i = start;\\n                    }\\n                else i++;\\n            }\\n\\n            else i++;\\n\\n        }\\n\\n        return grpNo >= grpSize;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871677,
                "title": "kmp-string-matching-algo",
                "content": "`this solution is not right solution it involves converting array to string which is incorrect bcoz it can fail on some cases but here i just used this to use KMP for string matching but try to use KMP for array itself which is the correct way to do it for this question`\\n\\n\\n# Code\\n```\\nstring change(int x){\\n    string s = \"\";\\n    while(x > 9 || x < -9){\\n        int d = x % 10;\\n        s += to_string(abs(d));\\n        x /= 10;\\n    }\\n    s += (char)(\\'a\\' + x + 9);\\n    return s;\\n}\\n\\nvector<int> compute_pi(string& pattern) {\\n    vector<int> pi(pattern.length()); pi[0] = 0;\\n    int i = 1, len = 0, N = pattern.length();\\n    while (i < N) {\\n        if (pattern[len] == pattern[i]) {\\n            pi[i] = len + 1;\\n            i++, len++;\\n        }\\n        else {\\n            if (len == 0) {\\n                pi[i] = 0;\\n                i++;\\n            }\\n            else len = pi[len - 1];\\n        }\\n    }\\n    return pi;\\n}\\n\\nvector<pair<int, int>> KMP(string& text, string& pattern) {\\n    int N = text.length(), M = pattern.length();\\n    vector<int> pi = compute_pi(pattern);\\n    vector<pair<int, int>> positions;\\n    int i = 0, j = 0;\\n    while (i < N) {\\n        if (text[i] == pattern[j]) {\\n            i++, j++;\\n        }\\n        if (j == M) {\\n            positions.push_back({i - j, i - j + M - 1});\\n            j = pi[j - 1];\\n        }\\n        else if (i < N && text[i] != pattern[j]) {\\n            if (j == 0) i++;\\n            else j = pi[j - 1];\\n        }\\n    }\\n    return positions;\\n}\\n\\nbool check(vector<vector<pair<int,int>>>& v, int i, int j){\\n    if(i==v.size()) return true;\\n    bool fl = false;\\n    for(int k = 0; k < v[i].size();k++){\\n        if(v[i][k].first > v[i-1][j].second){\\n            if(check(v, i+1, k)) return true;\\n            else continue;\\n        }\\n    }\\n    return false;\\n}\\n\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        string ss = \"\";\\n        for(auto x: nums) ss += change(x);\\n        vector<vector<pair<int,int>>> v;\\n        for(auto arr: groups){\\n            string s = \"\";\\n            for(auto x: arr) s += change(x);\\n            vector<pair<int, int>> ind = KMP(ss, s);\\n            if(ind.size()) v.push_back(ind);\\n            else return false;\\n        }\\n        for(int i = 0;i<v[0].size();i++){\\n            if(check(v, 1, i)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstring change(int x){\\n    string s = \"\";\\n    while(x > 9 || x < -9){\\n        int d = x % 10;\\n        s += to_string(abs(d));\\n        x /= 10;\\n    }\\n    s += (char)(\\'a\\' + x + 9);\\n    return s;\\n}\\n\\nvector<int> compute_pi(string& pattern) {\\n    vector<int> pi(pattern.length()); pi[0] = 0;\\n    int i = 1, len = 0, N = pattern.length();\\n    while (i < N) {\\n        if (pattern[len] == pattern[i]) {\\n            pi[i] = len + 1;\\n            i++, len++;\\n        }\\n        else {\\n            if (len == 0) {\\n                pi[i] = 0;\\n                i++;\\n            }\\n            else len = pi[len - 1];\\n        }\\n    }\\n    return pi;\\n}\\n\\nvector<pair<int, int>> KMP(string& text, string& pattern) {\\n    int N = text.length(), M = pattern.length();\\n    vector<int> pi = compute_pi(pattern);\\n    vector<pair<int, int>> positions;\\n    int i = 0, j = 0;\\n    while (i < N) {\\n        if (text[i] == pattern[j]) {\\n            i++, j++;\\n        }\\n        if (j == M) {\\n            positions.push_back({i - j, i - j + M - 1});\\n            j = pi[j - 1];\\n        }\\n        else if (i < N && text[i] != pattern[j]) {\\n            if (j == 0) i++;\\n            else j = pi[j - 1];\\n        }\\n    }\\n    return positions;\\n}\\n\\nbool check(vector<vector<pair<int,int>>>& v, int i, int j){\\n    if(i==v.size()) return true;\\n    bool fl = false;\\n    for(int k = 0; k < v[i].size();k++){\\n        if(v[i][k].first > v[i-1][j].second){\\n            if(check(v, i+1, k)) return true;\\n            else continue;\\n        }\\n    }\\n    return false;\\n}\\n\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        string ss = \"\";\\n        for(auto x: nums) ss += change(x);\\n        vector<vector<pair<int,int>>> v;\\n        for(auto arr: groups){\\n            string s = \"\";\\n            for(auto x: arr) s += change(x);\\n            vector<pair<int, int>> ind = KMP(ss, s);\\n            if(ind.size()) v.push_back(ind);\\n            else return false;\\n        }\\n        for(int i = 0;i<v[0].size();i++){\\n            if(check(v, 1, i)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775588,
                "title": "javascript-1764-form-array-by-concatenating-subarrays-of-another-array",
                "content": "Tests\\n```\\n[[2,1]]\\n[12,1]\\n  [[1,-1,-1],[3,-2,0]]\\n  [1,-1,0,1,-1,-1,3,-2,0]\\n[[10,-2],[1,2,3,4]]\\n[1,2,3,4,10,-2]\\n  [[1,2,3],[3,4]]\\n  [7,7,1,2,3,4,7,7]\\n```\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1 - tricky code - see tests above\\n```\\nvar canChoose = function (g, a) {\\n  let srows = g.map(row => \\',\\' + row.join(\\',\\') + \\',\\')\\n  let s = \\',\\' + a.join(\\',\\') + \\',\\'\\n\\n  let i = 0\\n  for (let srow of srows) {\\n    i = s.indexOf(srow, i)\\n    if (i === -1) return false\\n    i += srow.length - 1 // disjoint, -1 for go back the comma(,)\\n  }\\n  return true\\n};\\n```\\n\\n2 - parse 2d array (g) first\\n```\\nvar canChoose = function (g, a) {\\n  let m = g.length\\n\\n  let k = 0\\n  AA: for (let i = 0; i < m; i++) {\\n    let row = g[i]\\n    let n = row.length\\n    for (; k < a.length; k++) {\\n      // possible row match in a\\n      let j\\n      for (j = 0; (j < n) && (row[j] === a[k + j]); j++) {\\n        // match continuing\\n      }\\n      if (j === n) {\\n        // full row match\\n        k += n\\n        continue AA;\\n      }\\n    }\\n    return false\\n  }\\n  return true\\n}\\n```\\n\\n3 - parse array (a) first\\n```\\nvar canChoose = function (g, a) {\\n  let m = g.length\\n\\n  let i = 0\\n  for (let k = 0; k < a.length && i < m;) {\\n    let row = g[i]\\n    let n = row.length\\n    let j\\n    for (j = 0; (j < n) && (row[j] === a[k + j]); j++) {\\n      // row match continuing, in a\\n    }\\n    if (j === n) {\\n      // full row match\\n      i++\\n      k += n\\n    } else {\\n      k++\\n    }\\n  }\\n  return i === m\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n[[2,1]]\\n[12,1]\\n  [[1,-1,-1],[3,-2,0]]\\n  [1,-1,0,1,-1,-1,3,-2,0]\\n[[10,-2],[1,2,3,4]]\\n[1,2,3,4,10,-2]\\n  [[1,2,3],[3,4]]\\n  [7,7,1,2,3,4,7,7]\\n```\n```\\nvar canChoose = function (g, a) {\\n  let srows = g.map(row => \\',\\' + row.join(\\',\\') + \\',\\')\\n  let s = \\',\\' + a.join(\\',\\') + \\',\\'\\n\\n  let i = 0\\n  for (let srow of srows) {\\n    i = s.indexOf(srow, i)\\n    if (i === -1) return false\\n    i += srow.length - 1 // disjoint, -1 for go back the comma(,)\\n  }\\n  return true\\n};\\n```\n```\\nvar canChoose = function (g, a) {\\n  let m = g.length\\n\\n  let k = 0\\n  AA: for (let i = 0; i < m; i++) {\\n    let row = g[i]\\n    let n = row.length\\n    for (; k < a.length; k++) {\\n      // possible row match in a\\n      let j\\n      for (j = 0; (j < n) && (row[j] === a[k + j]); j++) {\\n        // match continuing\\n      }\\n      if (j === n) {\\n        // full row match\\n        k += n\\n        continue AA;\\n      }\\n    }\\n    return false\\n  }\\n  return true\\n}\\n```\n```\\nvar canChoose = function (g, a) {\\n  let m = g.length\\n\\n  let i = 0\\n  for (let k = 0; k < a.length && i < m;) {\\n    let row = g[i]\\n    let n = row.length\\n    let j\\n    for (j = 0; (j < n) && (row[j] === a[k + j]); j++) {\\n      // row match continuing, in a\\n    }\\n    if (j === n) {\\n      // full row match\\n      i++\\n      k += n\\n    } else {\\n      k++\\n    }\\n  }\\n  return i === m\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743232,
                "title": "short-and-simple-z-algorithm-c",
                "content": "# Intuition\\nIts just string matching\\n\\n# Approach\\nimplemented Z algorithm to get the index of the subarray\\n\\n# Complexity\\n- Time complexity:\\nO(G.size() * B.size())\\n\\n- Space complexity:\\nO(B.size())\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ZArray(vector<int>&A,vector<int>&B,int end)\\n    {\\n        \\n        int l = 0;\\n        int r = 0;\\n        vector<int>C;\\n        for(int a : A)\\n        {\\n            C.push_back(a);\\n        }\\n        C.push_back(1e9 + 7);\\n        for(int b : B)\\n        {\\n            C.push_back(b);\\n        }\\n        int n = C.size();\\n        vector<int>Z(n,0);\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(i > r)\\n            {\\n                l = r = i;\\n                while(r < n && C[r] == C[r - l])\\n                    r++;\\n                Z[i] = r - l;\\n                r--;\\n            }\\n            else\\n            {\\n                int i1 = i - l;\\n                if(Z[i1] + i <= r)\\n                    Z[i] = Z[i1];\\n                else\\n                {\\n                    l = i;\\n                    while(r < n && C[r] == C[r - l])\\n                        r++;\\n                    Z[i] = r - l;\\n                    r--;\\n                }\\n\\n            }\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(Z[i] == A.size() and i - A.size() >= end)\\n                return (i);\\n        }\\n        return -1;\\n    }\\n    bool canChoose(vector<vector<int>>&G, vector<int>& B) {\\n        vector<int>A;\\n        int m = G.size();\\n        int end = 0;\\n        for(int i = 0; i < m; i++)\\n        {\\n            end = ZArray(G[i],B,end);\\n            if(end == -1)\\n                return false;\\n        }\\n        return true;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ZArray(vector<int>&A,vector<int>&B,int end)\\n    {\\n        \\n        int l = 0;\\n        int r = 0;\\n        vector<int>C;\\n        for(int a : A)\\n        {\\n            C.push_back(a);\\n        }\\n        C.push_back(1e9 + 7);\\n        for(int b : B)\\n        {\\n            C.push_back(b);\\n        }\\n        int n = C.size();\\n        vector<int>Z(n,0);\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(i > r)\\n            {\\n                l = r = i;\\n                while(r < n && C[r] == C[r - l])\\n                    r++;\\n                Z[i] = r - l;\\n                r--;\\n            }\\n            else\\n            {\\n                int i1 = i - l;\\n                if(Z[i1] + i <= r)\\n                    Z[i] = Z[i1];\\n                else\\n                {\\n                    l = i;\\n                    while(r < n && C[r] == C[r - l])\\n                        r++;\\n                    Z[i] = r - l;\\n                    r--;\\n                }\\n\\n            }\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(Z[i] == A.size() and i - A.size() >= end)\\n                return (i);\\n        }\\n        return -1;\\n    }\\n    bool canChoose(vector<vector<int>>&G, vector<int>& B) {\\n        vector<int>A;\\n        int m = G.size();\\n        int end = 0;\\n        for(int i = 0; i < m; i++)\\n        {\\n            end = ZArray(G[i],B,end);\\n            if(end == -1)\\n                return false;\\n        }\\n        return true;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681196,
                "title": "sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        vector<int>v;\\n        int k=0,count=0,j=0;\\n        while(j<nums.size()&&k<groups.size()){\\n           if(v.size()<groups[k].size()){\\n               v.push_back(nums[j]);\\n           }\\n           else {\\n               if(v==groups[k]){count++;\\n                 v.clear(); k++;\\n                 continue;\\n               }\\n               else{\\n              v.erase(v.begin());\\n              v.push_back(nums[j]);\\n               }\\n           }\\n           j++;}\\n           if(k<groups.size()&&v==groups[k])count++;\\n           if(count==groups.size())return true;\\n           return false;\\n           \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        vector<int>v;\\n        int k=0,count=0,j=0;\\n        while(j<nums.size()&&k<groups.size()){\\n           if(v.size()<groups[k].size()){\\n               v.push_back(nums[j]);\\n           }\\n           else {\\n               if(v==groups[k]){count++;\\n                 v.clear(); k++;\\n                 continue;\\n               }\\n               else{\\n              v.erase(v.begin());\\n              v.push_back(nums[j]);\\n               }\\n           }\\n           j++;}\\n           if(k<groups.size()&&v==groups[k])count++;\\n           if(count==groups.size())return true;\\n           return false;\\n           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627996,
                "title": "simple-c-sliding-window-approach-with-o-n-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nusing sliding window approach check every group \\n# Complexity\\n- Time complexity:\\nO(n) every element in nums are visisted only once\\n\\n- Space complexity:\\nO(n) complexity\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n      int c=0;\\n      for(int i=0;i<nums.size();i++){\\n          int l=groups[c].size(),j;\\n          vector<int>a;\\n          for( j=i;j<i+l&&j<nums.size();j++)a.push_back(nums[j]);\\n          i=j;\\n          while(a!=groups[c]&&i<nums.size()){\\n              a.erase(a.begin());\\n              a.push_back(nums[i]);\\n              i++;\\n          }\\n          i--;\\n          if(a==groups[c])c++;\\n          if(c==groups.size())return true;\\n      } \\n      if(c==groups.size())return true;\\n      return false; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n      int c=0;\\n      for(int i=0;i<nums.size();i++){\\n          int l=groups[c].size(),j;\\n          vector<int>a;\\n          for( j=i;j<i+l&&j<nums.size();j++)a.push_back(nums[j]);\\n          i=j;\\n          while(a!=groups[c]&&i<nums.size()){\\n              a.erase(a.begin());\\n              a.push_back(nums[i]);\\n              i++;\\n          }\\n          i--;\\n          if(a==groups[c])c++;\\n          if(c==groups.size())return true;\\n      } \\n      if(c==groups.size())return true;\\n      return false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602628,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        group = 0\\n        i = len(nums)-len(groups[-1-group])\\n        while i>=0:\\n            if nums[i:i+len(groups[-1-group])] == groups[-1-group]:\\n                if group==len(groups)-1:\\n                    return True\\n                group += 1\\n                i -= len(groups[-1-group])\\n            else:\\n                i -= 1\\n        \\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        group = 0\\n        i = len(nums)-len(groups[-1-group])\\n        while i>=0:\\n            if nums[i:i+len(groups[-1-group])] == groups[-1-group]:\\n                if group==len(groups)-1:\\n                    return True\\n                group += 1\\n                i -= len(groups[-1-group])\\n            else:\\n                i -= 1\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598400,
                "title": "easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        lg=len(groups)\\n        ind=0\\n        for i in groups:\\n            for j in range(ind,len(nums)):\\n                if nums[j:j+len(i)]==i:\\n                    ind=j+len(i)\\n                    lg-=1\\n                    break\\n        return lg==0\\n        \\n\\n        \\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        lg=len(groups)\\n        ind=0\\n        for i in groups:\\n            for j in range(ind,len(nums)):\\n                if nums[j:j+len(i)]==i:\\n                    ind=j+len(i)\\n                    lg-=1\\n                    break\\n        return lg==0\\n        \\n\\n        \\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579386,
                "title": "o-n-2-88-ms",
                "content": "```ruby\\ndef can_choose g, a\\n    j, z = 0, a.size\\n    g.each do | b |\\n        bz = b.size\\n        loop do\\n            return false if z - j < bz\\n            break j += bz if a[j, bz] == b\\n            j += 1\\n        end\\n    end\\n    true\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef can_choose g, a\\n    j, z = 0, a.size\\n    g.each do | b |\\n        bz = b.size\\n        loop do\\n            return false if z - j < bz\\n            break j += bz if a[j, bz] == b\\n            j += 1\\n        end\\n    end\\n    true\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3565639,
                "title": "simple-backtracking",
                "content": "# Intuition\\nI thought it could be linear time until I realized you have to backtrack and can\\'t greedily consume the sub-arrays from groups every time. This makes it $$O(n^2)$$.\\n\\n# Approach\\nIterate over nums and compare and consume items from groups. If a non-match is encountered, backtrack to the beginning of the group and increment by one.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        cur_group = 0\\n        cur_element_in_group = 0\\n        backtrack_to = 0\\n        nums_idx = 0\\n        while nums_idx < len(nums):\\n            if nums[nums_idx] == groups[cur_group][cur_element_in_group]:\\n                cur_element_in_group += 1\\n                if cur_element_in_group >= len(groups[cur_group]):\\n                    cur_element_in_group = 0\\n                    cur_group += 1\\n                    if cur_group >= len(groups):\\n                        return True\\n                    backtrack_to = nums_idx + 1\\n            else:\\n                #print(\"{} != {}\".format(nums[nums_idx], groups[cur_group][cur_element_in_group]))\\n                cur_element_in_group = 0\\n                nums_idx = backtrack_to\\n                backtrack_to = nums_idx + 1\\n            nums_idx += 1\\n        return False\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        cur_group = 0\\n        cur_element_in_group = 0\\n        backtrack_to = 0\\n        nums_idx = 0\\n        while nums_idx < len(nums):\\n            if nums[nums_idx] == groups[cur_group][cur_element_in_group]:\\n                cur_element_in_group += 1\\n                if cur_element_in_group >= len(groups[cur_group]):\\n                    cur_element_in_group = 0\\n                    cur_group += 1\\n                    if cur_group >= len(groups):\\n                        return True\\n                    backtrack_to = nums_idx + 1\\n            else:\\n                #print(\"{} != {}\".format(nums[nums_idx], groups[cur_group][cur_element_in_group]))\\n                cur_element_in_group = 0\\n                nums_idx = backtrack_to\\n                backtrack_to = nums_idx + 1\\n            nums_idx += 1\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527771,
                "title": "iterators-linear-scan",
                "content": "# Intuition\\nWhen we\\'re trying to place a group in the subarray, there\\'s never a reason to take anything but the earliest instance we find, because that gives us the longest remaining array to check afterwards. \\n\\nIf we can\\'t find a position for group, then we just return false.\\n\\nIf we do find a position for group i starting at position j, then we start again at at position j+ groups[i].len() for group i+1 and repeat.\\n\\n# Approach\\nUse try_fold to allow for an early exit if we ever fail to place a group.\\n\\n# Complexity\\n- Time complexity: O(nums.len()). Once we check a value in num against a group, we never go back to it, either because we place that group and restart at a later point, or because we fail to find the group and exit the function.\\n\\n- Space complexity: O(1), no allocations necessary.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn can_choose(groups: Vec<Vec<i32>>, nums: Vec<i32>) -> bool {\\n        let n = groups.len();\\n        let m = nums.len();\\n\\n        (0..n)\\n        .try_fold(\\n            0,\\n            |first_possible, i| {\\n                let group_len = groups[i].len();\\n                (first_possible..=m-group_len)\\n                .find_map(|j| {\\n                    nums[j..j+group_len]\\n                    .iter()\\n                    .zip(groups[i].iter())\\n                    .all(|(&a, &b)| a==b)\\n                    .then(|| j + group_len)\\n                })\\n        })\\n        .is_some()\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn can_choose(groups: Vec<Vec<i32>>, nums: Vec<i32>) -> bool {\\n        let n = groups.len();\\n        let m = nums.len();\\n\\n        (0..n)\\n        .try_fold(\\n            0,\\n            |first_possible, i| {\\n                let group_len = groups[i].len();\\n                (first_possible..=m-group_len)\\n                .find_map(|j| {\\n                    nums[j..j+group_len]\\n                    .iter()\\n                    .zip(groups[i].iter())\\n                    .all(|(&a, &b)| a==b)\\n                    .then(|| j + group_len)\\n                })\\n        })\\n        .is_some()\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3431354,
                "title": "scala-3-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def canChoose(groups: Array[Array[Int]], nums: Array[Int]): Boolean = (groups, nums) match {\\n        case (groups, _) if (groups.length == 0) => true\\n        case (groups, nums) if(nums.indexOfSlice(groups(0)) != -1) => canChoose(groups.tail, nums.drop(nums.indexOfSlice(groups(0)) + groups.head.length))\\n        case _=> false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def canChoose(groups: Array[Array[Int]], nums: Array[Int]): Boolean = (groups, nums) match {\\n        case (groups, _) if (groups.length == 0) => true\\n        case (groups, nums) if(nums.indexOfSlice(groups(0)) != -1) => canChoose(groups.tail, nums.drop(nums.indexOfSlice(groups(0)) + groups.head.length))\\n        case _=> false\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3391991,
                "title": "java-simple-kmp",
                "content": "# Intuition\\nit is the classic string searching problem\\n\\n# Complexity\\n- Time complexity:\\n`O(m+n)` where m is the length of nums, n is the total length of each group in groups\\n\\n\\n# Code\\n```\\n/**\\n\\nKMP\\n */\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int lo = 0;\\n        for (int[] g : groups) {\\n            lo = match(nums, lo, g, suffixPrefix(g));\\n            if (lo < 0) return false;\\n        }\\n        return true;\\n    }\\n    private int match(int[] text, int lo, int[] ptn, int[] suffixPrefix) {\\n        int j = lo, i = 0;\\n        while (j < text.length) {\\n            if (text[j] == ptn[i]) {\\n                i++; \\n                j++;\\n            } else if (i == 0) {\\n                j++;\\n            } else {\\n                i = suffixPrefix[i-1];\\n            }\\n            if (i == ptn.length) {\\n                return j;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int[] suffixPrefix(int[] arr) {\\n        int n = arr.length;\\n        int[] ans = new int[n];\\n        for(int i =0, j = 1; j < n; ) {\\n            if (arr[i] == arr[j]) {\\n                ans[j++] = ++i;\\n            } else if (i == 0) {\\n                j++;\\n            } else {\\n                i = ans[i-1];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n\\nKMP\\n */\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int lo = 0;\\n        for (int[] g : groups) {\\n            lo = match(nums, lo, g, suffixPrefix(g));\\n            if (lo < 0) return false;\\n        }\\n        return true;\\n    }\\n    private int match(int[] text, int lo, int[] ptn, int[] suffixPrefix) {\\n        int j = lo, i = 0;\\n        while (j < text.length) {\\n            if (text[j] == ptn[i]) {\\n                i++; \\n                j++;\\n            } else if (i == 0) {\\n                j++;\\n            } else {\\n                i = suffixPrefix[i-1];\\n            }\\n            if (i == ptn.length) {\\n                return j;\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int[] suffixPrefix(int[] arr) {\\n        int n = arr.length;\\n        int[] ans = new int[n];\\n        for(int i =0, j = 1; j < n; ) {\\n            if (arr[i] == arr[j]) {\\n                ans[j++] = ++i;\\n            } else if (i == 0) {\\n                j++;\\n            } else {\\n                i = ans[i-1];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379598,
                "title": "beginner-c-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i=0;int d=0,b=0;\\n        for(auto x:groups){\\n// extracting vector to be searched from groups\\n            int k=x.size();d++;\\n            for(;i<=nums.size()-k;i++){\\n//Finding subarray from nums\\n                vector<int> vec;int a=nums.size()-i-k;\\n                vec={nums.begin()+i,nums.end()-a};\\n//Checking if extracted subarray is equal to vector of groups\\n                if(x==vec) {\\n                    b++; i+=k; break;\\n                }\\n\\n            }\\n        }\\n// Chcking whether all vector of group is found or not\\n        if(d==b) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i=0;int d=0,b=0;\\n        for(auto x:groups){\\n// extracting vector to be searched from groups\\n            int k=x.size();d++;\\n            for(;i<=nums.size()-k;i++){\\n//Finding subarray from nums\\n                vector<int> vec;int a=nums.size()-i-k;\\n                vec={nums.begin()+i,nums.end()-a};\\n//Checking if extracted subarray is equal to vector of groups\\n                if(x==vec) {\\n                    b++; i+=k; break;\\n                }\\n\\n            }\\n        }\\n// Chcking whether all vector of group is found or not\\n        if(d==b) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317776,
                "title": "java-0ms-beats-100-and-clean-code-must-have-skill",
                "content": "# Approach\\n1. Starting from the last group and from the last index of nums, try to find each group 1 by 1\\n2. Traverse nums from n to 0 and try to find last group by traversing the group backwards.\\n3. It is good to add fail-fast conditions!\\n4. Compute the prefixSum of lengths of each group. In your index m is 7 and you have to find 2 groups whose sum of lengths is 8, you should break as you can\\'t find 8 elements inside a segment of 7 elements.\\n5. If a group is found, decrement the group index to search (7,6,5..0) and also deduct group\\'s length from the  index that is used to traverse nums.\\n    - eg: j = 8, group is found and its length is 5. Then j will jump to 8-5 and llok for next group.\\n6. Return true is all groups have been found.  \\n\\n# Complexity\\n- Time complexity:$$O(g + g*n)$$ - g groups of n lengths\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(g)$$ g - number of groups - length prefix sum\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int[] groupLength = getGroupLength(groups);\\n        int groupIndex = groups.length -1;\\n        // serach group n, n-1, n-2 .. 0. Break if index j is lesser than the prefix sum of remaining groups lengths.\\n        for (int j = nums.length -1; groupIndex >= 0 && j >= groupLength[groupIndex] -1;) {\\n            if(canBeConcatenated(nums, j, groups[groupIndex])) {\\n                // reduce j by the group\\'s length\\n                j -= groups[groupIndex].length;\\n                groupIndex--;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return groupIndex == -1;\\n    }\\n\\n    private boolean canBeConcatenated(int[] nums, int j, int[] group) {\\n        for (int i = group.length -1; i>= 0; i--, j--) {\\n            if (nums[j] != group[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int[] getGroupLength(int[][] groups) {\\n        int[] groupLength = new int[groups.length];\\n        groupLength[0] = groups[0].length;\\n        for (int i = 1; i < groupLength.length; i++) {\\n            groupLength[i] = groupLength[i-1] + groups[i].length;\\n        }\\n        return groupLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int[] groupLength = getGroupLength(groups);\\n        int groupIndex = groups.length -1;\\n        // serach group n, n-1, n-2 .. 0. Break if index j is lesser than the prefix sum of remaining groups lengths.\\n        for (int j = nums.length -1; groupIndex >= 0 && j >= groupLength[groupIndex] -1;) {\\n            if(canBeConcatenated(nums, j, groups[groupIndex])) {\\n                // reduce j by the group\\'s length\\n                j -= groups[groupIndex].length;\\n                groupIndex--;\\n            } else {\\n                j--;\\n            }\\n        }\\n        return groupIndex == -1;\\n    }\\n\\n    private boolean canBeConcatenated(int[] nums, int j, int[] group) {\\n        for (int i = group.length -1; i>= 0; i--, j--) {\\n            if (nums[j] != group[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private int[] getGroupLength(int[][] groups) {\\n        int[] groupLength = new int[groups.length];\\n        groupLength[0] = groups[0].length;\\n        for (int i = 1; i < groupLength.length; i++) {\\n            groupLength[i] = groupLength[i-1] + groups[i].length;\\n        }\\n        return groupLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309235,
                "title": "java-recursive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public boolean canChoose(int[][] groups, int[] nums) {\\n        int totalCount=0;\\n        for (int[] arr:groups){\\n            totalCount+=arr.length;\\n        }\\n        return checkTwoMatricestoChoose(groups,nums,0,0,totalCount);\\n    }\\n    private boolean checkTwoMatricestoChoose(int[][] groups, int[] nums, int groupRowInd, int numsIndex,int totalCount) {\\n        if(groupRowInd==groups.length){\\n            return true;\\n        }\\n        if(totalCount>nums.length-numsIndex){\\n            return false;\\n        }\\n        for (int i=numsIndex,j=0;i<nums.length;){\\n            if(groups[groupRowInd][j]==nums[i]){\\n                j++;\\n                i++;\\n            }else {\\n                i=i-j+1;\\n                j=0;\\n            }\\n            if(j==groups[groupRowInd].length){\\n                if(checkTwoMatricestoChoose(groups,nums,groupRowInd+1,i,totalCount-groups[groupRowInd].length)){\\n                    return true;\\n                }\\n                i=i-j+1;\\n                j=0;\\n\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n     public boolean canChoose(int[][] groups, int[] nums) {\\n        int totalCount=0;\\n        for (int[] arr:groups){\\n            totalCount+=arr.length;\\n        }\\n        return checkTwoMatricestoChoose(groups,nums,0,0,totalCount);\\n    }\\n    private boolean checkTwoMatricestoChoose(int[][] groups, int[] nums, int groupRowInd, int numsIndex,int totalCount) {\\n        if(groupRowInd==groups.length){\\n            return true;\\n        }\\n        if(totalCount>nums.length-numsIndex){\\n            return false;\\n        }\\n        for (int i=numsIndex,j=0;i<nums.length;){\\n            if(groups[groupRowInd][j]==nums[i]){\\n                j++;\\n                i++;\\n            }else {\\n                i=i-j+1;\\n                j=0;\\n            }\\n            if(j==groups[groupRowInd].length){\\n                if(checkTwoMatricestoChoose(groups,nums,groupRowInd+1,i,totalCount-groups[groupRowInd].length)){\\n                    return true;\\n                }\\n                i=i-j+1;\\n                j=0;\\n\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291682,
                "title": "easy-kmp-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> lps;\\n\\n    void getLps(vector<int> &pat) {\\n        int n = pat.size();\\n        lps.clear();\\n        lps.resize(n , 0);\\n        for(int i = 1 , j = 0 ; i < n ; i++) {\\n            if(pat[i] == pat[j]) lps[i] = ++j;\\n            else if(j != 0) {\\n                j = lps[j - 1]; i--;\\n            }\\n        }\\n\\n    }\\n\\n    int KMP(vector<int> &text , int st , vector<int> &pat) {\\n        int n = text.size() , m = pat.size();\\n        for(int i = st , j = 0 ; i < n && j < m ; i++) {\\n            if(text[i] == pat[j]) j++;\\n            else if(j != 0) {\\n                j = lps[j - 1];\\n                i--;\\n            }\\n            if(j == m) return i + 1;\\n        }\\n        \\n        return -1;\\n    }\\n\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size() , j , last = 0 , flg , next = 0;\\n\\n        for(auto grp : groups) {\\n            getLps(grp);\\n            last = KMP(nums , last , grp);\\n            if(last == -1) return 0;\\n        }\\n\\n        return 1;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> lps;\\n\\n    void getLps(vector<int> &pat) {\\n        int n = pat.size();\\n        lps.clear();\\n        lps.resize(n , 0);\\n        for(int i = 1 , j = 0 ; i < n ; i++) {\\n            if(pat[i] == pat[j]) lps[i] = ++j;\\n            else if(j != 0) {\\n                j = lps[j - 1]; i--;\\n            }\\n        }\\n\\n    }\\n\\n    int KMP(vector<int> &text , int st , vector<int> &pat) {\\n        int n = text.size() , m = pat.size();\\n        for(int i = st , j = 0 ; i < n && j < m ; i++) {\\n            if(text[i] == pat[j]) j++;\\n            else if(j != 0) {\\n                j = lps[j - 1];\\n                i--;\\n            }\\n            if(j == m) return i + 1;\\n        }\\n        \\n        return -1;\\n    }\\n\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size() , j , last = 0 , flg , next = 0;\\n\\n        for(auto grp : groups) {\\n            getLps(grp);\\n            last = KMP(nums , last , grp);\\n            if(last == -1) return 0;\\n        }\\n\\n        return 1;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132396,
                "title": "easy-c-solution",
                "content": "# Intuition\\nFor each group, we need to check if it is contained in the bigger sequence. This is still a brute force solution though.\\n\\n# Approach\\nAdding to the above intuition, we check each group if it is present in the bigger sequence. If yes, the next group check starts where the previous one ends. While checking each group, we start character by character and match from the bigger sequence.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // returns if group is present in nums from startIdx\\n    pair<bool, int> contains(const vector<int>& group, const vector<int>& nums, int startIdx) {\\n        int m = 0;\\n        int prev_n = startIdx;\\n        int n = prev_n;\\n\\n        while (m < group.size() && n < nums.size()) {\\n            if (group[m] == nums[n]) {\\n                m++;\\n                n++;\\n            } else {\\n                m = 0;\\n                prev_n++;\\n                n = prev_n;\\n            }\\n\\n            if (m == group.size()) return make_pair(true, n);\\n        }\\n\\n        return make_pair(false, -1);\\n    }\\n\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int startIdx = 0; // For nums\\n\\n        for (const auto& group : groups) {\\n            auto isPresent = contains(group, nums, startIdx);\\n\\n            if (isPresent.first) {\\n                startIdx = isPresent.second;\\n            } else {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // returns if group is present in nums from startIdx\\n    pair<bool, int> contains(const vector<int>& group, const vector<int>& nums, int startIdx) {\\n        int m = 0;\\n        int prev_n = startIdx;\\n        int n = prev_n;\\n\\n        while (m < group.size() && n < nums.size()) {\\n            if (group[m] == nums[n]) {\\n                m++;\\n                n++;\\n            } else {\\n                m = 0;\\n                prev_n++;\\n                n = prev_n;\\n            }\\n\\n            if (m == group.size()) return make_pair(true, n);\\n        }\\n\\n        return make_pair(false, -1);\\n    }\\n\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int startIdx = 0; // For nums\\n\\n        for (const auto& group : groups) {\\n            auto isPresent = contains(group, nums, startIdx);\\n\\n            if (isPresent.first) {\\n                startIdx = isPresent.second;\\n            } else {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965111,
                "title": "kmp-search-in-javascript",
                "content": "# Approach\\nKMP substring search:\\nconstruct LPS array for each group and search it in nums\\n\\n# Complexity\\n- Time complexity:\\nO(m + n)\\n\\n# Code\\n```\\nlet canChoose = function( groups, nums ) {\\n\\n    let LPSArr = function( groupIdx ) {\\n        let LPS = new Array( groups[groupIdx].length ).fill(0);\\n        let i = 0;\\n        let j = 1;\\n        while ( j < LPS.length )\\n        {\\n            if ( groups[groupIdx][i] == groups[groupIdx][j] ) { LPS[j] = i + 1; ++j; ++i; }\\n            else\\n            {\\n                if ( i == 0 ) ++j;\\n                else i = LPS[i-1];\\n            }\\n        }\\n        return LPS;\\n    }\\n\\n    let canChooseUtil = function( groupIdx, start, end, grIdx ) \\n    {\\n        if ( groupIdx >= groups.length ) return true;\\n        if ( end - start < groups[groupIdx].length - grIdx ) return false;\\n\\n        let LPS = LPSArr( groupIdx );\\n        let i = start;\\n        let matches = 0;\\n        let initGrIdx = grIdx;\\n\\n        while ( i < end && nums[i] != groups[groupIdx][grIdx] ) ++i;\\n        while ( i < end && matches < groups[groupIdx].length && nums[i] == groups[groupIdx][grIdx] )\\n        {\\n            ++i; ++grIdx; ++matches;\\n        }\\n\\n        if ( matches != groups[groupIdx].length - initGrIdx ) \\n        {\\n            let idx = matches > 0 ? LPS[ matches - 1 ] : 0;\\n            return canChooseUtil( groupIdx, i, end, idx ); \\n        }   \\n        else\\n            return canChooseUtil( groupIdx + 1, i, end, 0 );\\n    }\\n\\n    return canChooseUtil( 0, 0, nums.length, 0 );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet canChoose = function( groups, nums ) {\\n\\n    let LPSArr = function( groupIdx ) {\\n        let LPS = new Array( groups[groupIdx].length ).fill(0);\\n        let i = 0;\\n        let j = 1;\\n        while ( j < LPS.length )\\n        {\\n            if ( groups[groupIdx][i] == groups[groupIdx][j] ) { LPS[j] = i + 1; ++j; ++i; }\\n            else\\n            {\\n                if ( i == 0 ) ++j;\\n                else i = LPS[i-1];\\n            }\\n        }\\n        return LPS;\\n    }\\n\\n    let canChooseUtil = function( groupIdx, start, end, grIdx ) \\n    {\\n        if ( groupIdx >= groups.length ) return true;\\n        if ( end - start < groups[groupIdx].length - grIdx ) return false;\\n\\n        let LPS = LPSArr( groupIdx );\\n        let i = start;\\n        let matches = 0;\\n        let initGrIdx = grIdx;\\n\\n        while ( i < end && nums[i] != groups[groupIdx][grIdx] ) ++i;\\n        while ( i < end && matches < groups[groupIdx].length && nums[i] == groups[groupIdx][grIdx] )\\n        {\\n            ++i; ++grIdx; ++matches;\\n        }\\n\\n        if ( matches != groups[groupIdx].length - initGrIdx ) \\n        {\\n            let idx = matches > 0 ? LPS[ matches - 1 ] : 0;\\n            return canChooseUtil( groupIdx, i, end, idx ); \\n        }   \\n        else\\n            return canChooseUtil( groupIdx + 1, i, end, 0 );\\n    }\\n\\n    return canChooseUtil( 0, 0, nums.length, 0 );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2944110,
                "title": "python-two-pointers-o-mn",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        j = 0\\n        n = len(nums)\\n        print(n)\\n        for i, g in enumerate(groups):\\n            while j < n:\\n                if g == nums[j:j+len(g)]:\\n                    j += len(g)\\n                    if i == len(groups) - 1: return True\\n                    break\\n                j += 1\\n        return False \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        j = 0\\n        n = len(nums)\\n        print(n)\\n        for i, g in enumerate(groups):\\n            while j < n:\\n                if g == nums[j:j+len(g)]:\\n                    j += len(g)\\n                    if i == len(groups) - 1: return True\\n                    break\\n                j += 1\\n        return False \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938987,
                "title": "easy-c-code-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n         int n=groups.size();\\n        int k=0,c=0;\\n         if(n==1){\\n            int m=groups[0].size();\\n            int h=nums.size();\\n        if(m>h) return 0;\\n        int j=0;\\n        int i=0;\\n            while(i<m && j<h){\\n                if(groups[0][i]==nums[j]){\\n                    i++;\\n                    j++;\\n                    c++;\\n                }else{\\n                    i=0;\\n                    k++;\\n                    //cout<<k<<\" \";\\n                    j=k;\\n                    c=0;\\n                }\\n            }\\n        return c==m;\\n        }\\n        int f=0;\\n        for(int i=0;i<n;i++){\\n            int m=groups[i].size();\\n            int j=0,g=m;\\n            while(j<m && g>=0 && k<nums.size()){\\n                if(groups[i][j]==nums[k]){\\n                    j++;\\n                    k++;\\n                    g--;\\n                }else{\\n                    j=0;\\n                    g=m;\\n                   if(groups[i][0]!=nums[k]) k++; \\n                }\\n                if(g==0) c++;\\n            } \\n        }\\n        return c==n;  \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n         int n=groups.size();\\n        int k=0,c=0;\\n         if(n==1){\\n            int m=groups[0].size();\\n            int h=nums.size();\\n        if(m>h) return 0;\\n        int j=0;\\n        int i=0;\\n            while(i<m && j<h){\\n                if(groups[0][i]==nums[j]){\\n                    i++;\\n                    j++;\\n                    c++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2858606,
                "title": "c",
                "content": "```\\nint check(int* nums, int n, int* group, int cn_g){\\n    for(int i = 0; i <= n - cn_g; i++){\\n        for(int j = 0; j < cn_g; j++){\\n            if(nums[i+j] != group[j] )\\n                break;\\n            if(j == cn_g-1)\\n                return i;\\n        }\\n    }    \\n    return -1;\\n}\\nbool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    int idx = 0;\\n    for(int i = 0; i < groupsSize; i++){\\n        idx = check(&nums[idx], numsSize - idx, groups[i], groupsColSize[i]);\\n        if(idx == -1)\\n            return false;\\n        idx += groupsColSize[i];\\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint check(int* nums, int n, int* group, int cn_g){\\n    for(int i = 0; i <= n - cn_g; i++){\\n        for(int j = 0; j < cn_g; j++){\\n            if(nums[i+j] != group[j] )\\n                break;\\n            if(j == cn_g-1)\\n                return i;\\n        }\\n    }    \\n    return -1;\\n}\\nbool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    int idx = 0;\\n    for(int i = 0; i < groupsSize; i++){\\n        idx = check(&nums[idx], numsSize - idx, groups[i], groupsColSize[i]);\\n        if(idx == -1)\\n            return false;\\n        idx += groupsColSize[i];\\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2844189,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n        int row = 0;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            int col = 0;\\n            int j = i;\\n            while(col<groups[row].length && j<nums.length && nums[j] == groups[row][col]){\\n                col++;\\n                j++;\\n            }\\n            \\n            if(groups[row].length == col) {\\n                row++;\\n                i = j - 1;\\n            }\\n            \\n            if(row==groups.length)\\n                return true;\\n        }\\n        \\n        return row == groups.length;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n        int row = 0;\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            int col = 0;\\n            int j = i;\\n            while(col<groups[row].length && j<nums.length && nums[j] == groups[row][col]){\\n                col++;\\n                j++;\\n            }\\n            \\n            if(groups[row].length == col) {\\n                row++;\\n                i = j - 1;\\n            }\\n            \\n            if(row==groups.length)\\n                return true;\\n        }\\n        \\n        return row == groups.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831193,
                "title": "c-solution-well-explained-string-matching-two-pointers-app",
                "content": "Assume each group as pattern and nums[l...r] as text. Now if pattern found, search next pattern otherwise find pattern from the next index;\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool canChoose(vector<vector<int>>& grp, vector<int>& nums) {\\n\\t\\t\\tint a = 0, b = 0, n = grp.size(), m = nums.size();\\n\\t\\t\\tfor (; a < n && b < m; ) {\\n\\t\\t\\t\\tauto pat = grp[a];\\n\\n\\t\\t\\t\\t// start searching from the current index of nums\\n\\t\\t\\t\\tint i = 0, j = b, n2 = pat.size();\\n\\t\\t\\t\\tfor (i = 0; i < n2 && j < m; i++, j++) {\\n\\t\\t\\t\\t\\tif (pat[i] != nums[j]) break;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (i == n2) a++, b = j; // found, so search after founded index\\n\\t\\t\\t\\telse b++; // not found, so search in the next index of nums\\n\\t\\t\\t}\\n\\t\\t\\treturn a == n; \\n\\t\\t}\\n\\t};\\n\\nN :- maximum length of array in grops\\nM :- Lenght of nums array\\nn :- no of groups\\nTime Complexity : O(N*M) \\nSpace Complexity : O(N*n) // used in case of pattern\\n\\nUpvote if you liked\\uD83D\\uDE0A!\\nBest of luck \\uD83D\\uDC4D\\u2764",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool canChoose(vector<vector<int>>& grp, vector<int>& nums) {\\n\\t\\t\\tint a = 0, b = 0, n = grp.size(), m = nums.size();\\n\\t\\t\\tfor (; a < n && b < m; ) {\\n\\t\\t\\t\\tauto pat = grp[a];\\n\\n\\t\\t\\t\\t// start searching from the current index of nums\\n\\t\\t\\t\\tint i = 0, j = b, n2 = pat.size();\\n\\t\\t\\t\\tfor (i = 0; i < n2 && j < m; i++, j++) {\\n\\t\\t\\t\\t\\tif (pat[i] != nums[j]) break;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2792655,
                "title": "rust-solution",
                "content": "# Code\\n```\\nfn helper(a:&Vec<i32>, b:&[i32]) -> bool {\\n  for i in 0..a.len() {\\n    if a[i] != b[i] {\\n      return false\\n    }\\n  }\\n  true\\n}\\n\\nimpl Solution {\\n  pub fn can_choose(groups: Vec<Vec<i32>>, nums: Vec<i32>) -> bool {\\n    let n = groups.len();\\n    let m = nums.len();\\n    let mut i = 0;\\n    let mut j = 0;\\n\\n    while i < m {\\n      if n <= j { return true }\\n\\n      let group = &groups[j];\\n      let len = group.len();\\n      if m < i+len {\\n        return false;\\n      }\\n\\n      if helper(group, &nums[i..i+len]) {\\n        j += 1;\\n        i = i+len;\\n      } else {\\n        i += 1;\\n      }\\n    }\\n\\n    n <= j\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nfn helper(a:&Vec<i32>, b:&[i32]) -> bool {\\n  for i in 0..a.len() {\\n    if a[i] != b[i] {\\n      return false\\n    }\\n  }\\n  true\\n}\\n\\nimpl Solution {\\n  pub fn can_choose(groups: Vec<Vec<i32>>, nums: Vec<i32>) -> bool {\\n    let n = groups.len();\\n    let m = nums.len();\\n    let mut i = 0;\\n    let mut j = 0;\\n\\n    while i < m {\\n      if n <= j { return true }\\n\\n      let group = &groups[j];\\n      let len = group.len();\\n      if m < i+len {\\n        return false;\\n      }\\n\\n      if helper(group, &nums[i..i+len]) {\\n        j += 1;\\n        i = i+len;\\n      } else {\\n        i += 1;\\n      }\\n    }\\n\\n    n <= j\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2724297,
                "title": "python-kmp-algorithm-solution-faster-than-95",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        sz, idx = len(nums), 0\\n        for group in groups:\\n            groupSize, LPS = len(group), [0] * len(group)\\n            for i in range(1, groupSize):\\n                j = LPS[i - 1]\\n                while j > 0 and group[i] != group[j]:\\n                    j = LPS[j - 1]\\n                if group[i] == group[j]:\\n                    j += 1\\n                LPS[i] = j\\n            j = 0\\n            while idx < sz:\\n                if nums[idx] == group[j]:\\n                    j += 1; idx += 1\\n                if j == groupSize:\\n                    break\\n                else:\\n                    if idx < sz and nums[idx] != group[j]:\\n                        if j > 0:\\n                            j = LPS[j - 1]\\n                        else:\\n                            idx += 1\\n            if j != groupSize:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        sz, idx = len(nums), 0\\n        for group in groups:\\n            groupSize, LPS = len(group), [0] * len(group)\\n            for i in range(1, groupSize):\\n                j = LPS[i - 1]\\n                while j > 0 and group[i] != group[j]:\\n                    j = LPS[j - 1]\\n                if group[i] == group[j]:\\n                    j += 1\\n                LPS[i] = j\\n            j = 0\\n            while idx < sz:\\n                if nums[idx] == group[j]:\\n                    j += 1; idx += 1\\n                if j == groupSize:\\n                    break\\n                else:\\n                    if idx < sz and nums[idx] != group[j]:\\n                        if j > 0:\\n                            j = LPS[j - 1]\\n                        else:\\n                            idx += 1\\n            if j != groupSize:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704376,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        \\n        index = 0\\n        cur = 0\\n        start = -1\\n        n = len(groups)\\n        m = len(nums)\\n        for i in range(n):\\n            finished = False\\n\\n            while True:\\n\\n                if index >= m:\\n                    if finished == False:\\n                        if start != -1:\\n                            cur = 0\\n                            index = start\\n                            start = -1\\n                            continue\\n                    break\\n\\n                if nums[index] == groups[i][cur]:\\n                    if start == -1 and cur > 0 and nums[index] == groups[i][0]:\\n                        start = index\\n                    cur += 1\\n                else:\\n                    if cur > 0:\\n                        index -= 1\\n                        cur = 0\\n\\n                index +=1\\n                if cur == len(groups[i]):\\n                    cur = 0\\n                    finished = True\\n                    break\\n\\n\\n\\n        if finished == False: return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        \\n        index = 0\\n        cur = 0\\n        start = -1\\n        n = len(groups)\\n        m = len(nums)\\n        for i in range(n):\\n            finished = False\\n\\n            while True:\\n\\n                if index >= m:\\n                    if finished == False:\\n                        if start != -1:\\n                            cur = 0\\n                            index = start\\n                            start = -1\\n                            continue\\n                    break\\n\\n                if nums[index] == groups[i][cur]:\\n                    if start == -1 and cur > 0 and nums[index] == groups[i][0]:\\n                        start = index\\n                    cur += 1\\n                else:\\n                    if cur > 0:\\n                        index -= 1\\n                        cur = 0\\n\\n                index +=1\\n                if cur == len(groups[i]):\\n                    cur = 0\\n                    finished = True\\n                    break\\n\\n\\n\\n        if finished == False: return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665360,
                "title": "c-using-kmp",
                "content": "```\\nclass Solution {\\npublic:\\n    int kmp(vector<int> needle, vector<int> haystack, int start){\\n        int n = haystack.size();\\n        int m = needle.size();\\n        if(m > n-start){\\n            return -1;\\n        }\\n        vector<int> lps(m,0);\\n        int i = 1;\\n        int prevLPS = 0;\\n        while(i < m){\\n            if(needle[i] == needle[prevLPS]){\\n                lps[i] = ++prevLPS;\\n                i++;\\n            }\\n            else if(prevLPS == 0){\\n                lps[i] = 0;\\n                i++;\\n            }\\n            else{\\n                prevLPS = lps[prevLPS-1];\\n            }\\n        }\\n\\n        i = start;\\n        int j = 0;\\n        while(i < n){\\n            if(needle[j] == haystack[i]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                if(j == 0){\\n                    i++;\\n                }\\n                else{\\n                    j = lps[j-1];\\n                }\\n            }\\n            if(j == m){\\n                return i - m;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        vector<int> temp = nums;\\n        int start = 0;\\n        for(int i = 0; i < n; i++){\\n            int idx = kmp(groups[i],temp,start);\\n            if(idx == -1){\\n                return false;\\n            }\\n            start = idx + groups[i].size();            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kmp(vector<int> needle, vector<int> haystack, int start){\\n        int n = haystack.size();\\n        int m = needle.size();\\n        if(m > n-start){\\n            return -1;\\n        }\\n        vector<int> lps(m,0);\\n        int i = 1;\\n        int prevLPS = 0;\\n        while(i < m){\\n            if(needle[i] == needle[prevLPS]){\\n                lps[i] = ++prevLPS;\\n                i++;\\n            }\\n            else if(prevLPS == 0){\\n                lps[i] = 0;\\n                i++;\\n            }\\n            else{\\n                prevLPS = lps[prevLPS-1];\\n            }\\n        }\\n\\n        i = start;\\n        int j = 0;\\n        while(i < n){\\n            if(needle[j] == haystack[i]){\\n                i++;\\n                j++;\\n            }\\n            else{\\n                if(j == 0){\\n                    i++;\\n                }\\n                else{\\n                    j = lps[j-1];\\n                }\\n            }\\n            if(j == m){\\n                return i - m;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        vector<int> temp = nums;\\n        int start = 0;\\n        for(int i = 0; i < n; i++){\\n            int idx = kmp(groups[i],temp,start);\\n            if(idx == -1){\\n                return false;\\n            }\\n            start = idx + groups[i].size();            \\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608402,
                "title": "2-pointers-in-search-subarray",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int len = groups.length;\\n        int index = 0;\\n        for(int i=0; i<len; i++)\\n        {\\n            index = verify(groups[i], nums, index);\\n            if(index == -1)\\n                return false;\\n            if(index == nums.length && i<len-1)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int verify(int[] target, int [] nums, int ind)\\n    {\\n        int len1 = nums.length;\\n        int len2 = target.length;\\n        int needle1 = ind, needle2 = 0;\\n        while(needle1 < len1)\\n        {\\n            if(nums[needle1] == target[needle2])\\n            {\\n                needle1++;\\n                needle2++;\\n            }\\n            else\\n            {  \\n                needle1 = needle1 - needle2 + 1;\\n                needle2 = 0;\\n            }\\n            if(needle2 == len2)\\n                break;\\n        }\\n        if(needle2 != len2)\\n            needle1 = -1;\\n        return needle1;\\n    }\\n}\\n```\\nThe class I use 2 pointers to return the next searching array\\'s start index. If the index = -1, indicates has not found the target array in the nums, otherwise, return the next begin index to call the class again. If the for loop in the main class in the middle process and index has already been at the end, indicats not all the groups[i] in nums, otherwise return true.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int len = groups.length;\\n        int index = 0;\\n        for(int i=0; i<len; i++)\\n        {\\n            index = verify(groups[i], nums, index);\\n            if(index == -1)\\n                return false;\\n            if(index == nums.length && i<len-1)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int verify(int[] target, int [] nums, int ind)\\n    {\\n        int len1 = nums.length;\\n        int len2 = target.length;\\n        int needle1 = ind, needle2 = 0;\\n        while(needle1 < len1)\\n        {\\n            if(nums[needle1] == target[needle2])\\n            {\\n                needle1++;\\n                needle2++;\\n            }\\n            else\\n            {  \\n                needle1 = needle1 - needle2 + 1;\\n                needle2 = 0;\\n            }\\n            if(needle2 == len2)\\n                break;\\n        }\\n        if(needle2 != len2)\\n            needle1 = -1;\\n        return needle1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607923,
                "title": "typescript-100",
                "content": "\\n\\n```\\nfunction canChoose(groups: number[][], nums: number[]): boolean {\\n    \\n    function startsWithSubArray(offset, groupIndex) {\\n        let group = groups[groupIndex];  \\n        for (var i = 0; i < group.length; i++) {\\n            if (nums[offset+i] !== group[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    function getSubArrayIndex(start = 0, groupIndex = 0): number {\\n        for(let i=start; i<nums.length; i++) {\\n            if(startsWithSubArray(i, groupIndex)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    let groupIndex = 0;\\n    let nextStart = 0;\\n    while(groupIndex<groups.length) {\\n        nextStart = getSubArrayIndex(nextStart, groupIndex);\\n        if(nextStart == -1) {\\n            return false;\\n        }\\n        nextStart += groups[groupIndex].length;\\n        groupIndex++;\\n    }\\n    return true;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2f39e2c6-2a79-418f-a2dd-8e9d99452b2b_1663811181.7436028.png)\\n",
                "solutionTags": [],
                "code": "```\\nfunction canChoose(groups: number[][], nums: number[]): boolean {\\n    \\n    function startsWithSubArray(offset, groupIndex) {\\n        let group = groups[groupIndex];  \\n        for (var i = 0; i < group.length; i++) {\\n            if (nums[offset+i] !== group[i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n    function getSubArrayIndex(start = 0, groupIndex = 0): number {\\n        for(let i=start; i<nums.length; i++) {\\n            if(startsWithSubArray(i, groupIndex)) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    let groupIndex = 0;\\n    let nextStart = 0;\\n    while(groupIndex<groups.length) {\\n        nextStart = getSubArrayIndex(nextStart, groupIndex);\\n        if(nextStart == -1) {\\n            return false;\\n        }\\n        nextStart += groups[groupIndex].length;\\n        groupIndex++;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2606452,
                "title": "string-matching",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums,int i=0,int j=0) {\\n        if(j==groups.size())\\n            return true;\\n       for(int k=i;k+groups[j].size()-1<nums.size();k++){\\n           int flag=1;\\n           for(int p=0;p<groups[j].size();p++){\\n               if(nums[k+p]!=groups[j][p]){\\n                   flag=0;\\n                   break;\\n               }\\n           }\\n           if(flag){\\n              return canChoose(groups,nums,k+groups[j].size(),j+1);\\n           }\\n       }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums,int i=0,int j=0) {\\n        if(j==groups.size())\\n            return true;\\n       for(int k=i;k+groups[j].size()-1<nums.size();k++){\\n           int flag=1;\\n           for(int p=0;p<groups[j].size();p++){\\n               if(nums[k+p]!=groups[j][p]){\\n                   flag=0;\\n                   break;\\n               }\\n           }\\n           if(flag){\\n              return canChoose(groups,nums,k+groups[j].size(),j+1);\\n           }\\n       }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543863,
                "title": "python-simple-solution",
                "content": "```\\ndef canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n\\ti, k = 0, 0\\n\\twhile(i<len(nums) and k<len(groups)):\\n\\t\\tif i+len(groups[k])<=len(nums) and nums[i:i+len(groups[k])]==groups[k]:\\n\\t\\t\\ti += len(groups[k])\\n\\t\\t\\tk += 1\\n\\t\\telse:\\n\\t\\t\\ti += 1\\n\\treturn k==len(groups)\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n\\ti, k = 0, 0\\n\\twhile(i<len(nums) and k<len(groups)):\\n\\t\\tif i+len(groups[k])<=len(nums) and nums[i:i+len(groups[k])]==groups[k]:\\n\\t\\t\\ti += len(groups[k])\\n\\t\\t\\tk += 1\\n\\t\\telse:\\n\\t\\t\\ti += 1\\n\\treturn k==len(groups)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2497636,
                "title": "easy-to-follow-python",
                "content": "```\\n def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        k = 0\\n        visited = []\\n        for i in range(len(groups)):                           \\n            while k+len(groups[i]) < len(nums)+1:                \\n                sub = nums[k:len(groups[i])+k]\\n                if all(sub[l] == groups[i][l] for l in range(len(groups[i]))):\\n                    visited.append(i)\\n                    break\\n                else:\\n                    k+=1\\n                    \\n                if k > len(nums)-1:\\n                    return False                \\n            k+=len(groups[i])\\n            \\n        if len(visited) == len(groups):                \\n            return True\\n                \\n                \\n",
                "solutionTags": [],
                "code": "```\\n def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        k = 0\\n        visited = []\\n        for i in range(len(groups)):                           \\n            while k+len(groups[i]) < len(nums)+1:                \\n                sub = nums[k:len(groups[i])+k]\\n                if all(sub[l] == groups[i][l] for l in range(len(groups[i]))):\\n                    visited.append(i)\\n                    break\\n                else:\\n                    k+=1\\n                    \\n                if k > len(nums)-1:\\n                    return False                \\n            k+=len(groups[i])\\n            \\n        if len(visited) == len(groups):                \\n            return True\\n                \\n                \\n",
                "codeTag": "Python3"
            },
            {
                "id": 2476830,
                "title": "simple-c-solution-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int getall(vector<int> &nums,vector<int> &group,int s,int e)\\n    {\\n        if(e-s+1<group.size())return -1;\\n        for(int i = s;i<=e;i++)\\n        {\\n            vector<int> temp;\\n            for(int j = i;j<i+group.size() and j<nums.size();j++)\\n            {\\n                temp.push_back(nums[j]);\\n            }\\n            if(temp==group)return i;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    int solve(vector<vector<int>>& groups, vector<int>& nums,int gi,int s,int e)\\n    {\\n        if(gi==groups.size())return 1;\\n        int v = getall(nums,groups[gi],s,e);\\n        if(v==-1)return 0;\\n        if(solve(groups,nums,gi+1,v+groups[gi].size(),e))return 1;\\n        return 0;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int total = 0;\\n        for(auto &it:groups)\\n            total += it.size();\\n        if(nums.size()<total)return 0;\\n        return solve(groups,nums,0,0,nums.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getall(vector<int> &nums,vector<int> &group,int s,int e)\\n    {\\n        if(e-s+1<group.size())return -1;\\n        for(int i = s;i<=e;i++)\\n        {\\n            vector<int> temp;\\n            for(int j = i;j<i+group.size() and j<nums.size();j++)\\n            {\\n                temp.push_back(nums[j]);\\n            }\\n            if(temp==group)return i;\\n        }\\n        return -1;\\n        \\n    }\\n    \\n    int solve(vector<vector<int>>& groups, vector<int>& nums,int gi,int s,int e)\\n    {\\n        if(gi==groups.size())return 1;\\n        int v = getall(nums,groups[gi],s,e);\\n        if(v==-1)return 0;\\n        if(solve(groups,nums,gi+1,v+groups[gi].size(),e))return 1;\\n        return 0;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int total = 0;\\n        for(auto &it:groups)\\n            total += it.size();\\n        if(nums.size()<total)return 0;\\n        return solve(groups,nums,0,0,nums.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394193,
                "title": "c-14ms-100-faster-and-100-memory",
                "content": "```\\n\\nbool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    int *table = (int*)calloc(numsSize,sizeof(int));\\n    \\n    int flag = 0;\\n    int counter = 0;\\n    \\n    for(int x = 0; x<groupsSize; x++){\\n        flag=0;\\n\\n        for(int z=counter; z<numsSize; z++){\\n            if(flag == 1){\\n                if(x== (groupsSize-1))\\n                    return true;        \\n                break;\\n            }\\n                 \\n            if(z+groupsColSize[x] == numsSize+1){\\n                return false;       \\n            }\\n                \\n            for(int y=0; y<(groupsColSize[x]); y++){\\n                if(groups[x][y] != nums[z+y]){\\n                    if(z==numsSize-1)\\n                        return false;\\n                    break;\\n                }\\n                         \\n                if(table[z+y] == 1)\\n                    break;\\n\\n                if(y==(groupsColSize[x] - 1)){\\n                    for(int u=0; u<(groupsColSize[x]); u++)\\n                        table[z+u]=1;\\n                         \\n                    counter=z+(groupsColSize[x])-1;\\n                    flag = 1;\\n                    if(x== (groupsSize-1))\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nbool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    int *table = (int*)calloc(numsSize,sizeof(int));\\n    \\n    int flag = 0;\\n    int counter = 0;\\n    \\n    for(int x = 0; x<groupsSize; x++){\\n        flag=0;\\n\\n        for(int z=counter; z<numsSize; z++){\\n            if(flag == 1){\\n                if(x== (groupsSize-1))\\n                    return true;        \\n                break;\\n            }\\n                 \\n            if(z+groupsColSize[x] == numsSize+1){\\n                return false;       \\n            }\\n                \\n            for(int y=0; y<(groupsColSize[x]); y++){\\n                if(groups[x][y] != nums[z+y]){\\n                    if(z==numsSize-1)\\n                        return false;\\n                    break;\\n                }\\n                         \\n                if(table[z+y] == 1)\\n                    break;\\n\\n                if(y==(groupsColSize[x] - 1)){\\n                    for(int u=0; u<(groupsColSize[x]); u++)\\n                        table[z+u]=1;\\n                         \\n                    counter=z+(groupsColSize[x])-1;\\n                    flag = 1;\\n                    if(x== (groupsSize-1))\\n                        return true;\\n                }\\n            }\\n        }\\n        \\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2387988,
                "title": "c-solution-with-comments",
                "content": "```\\n\\n\\nbool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    \\n    for (int g = 0, i = 0; i < numsSize && g < groupsSize; i++) {\\n        \\n        // Get the size of the current group.\\n        \\n        int gs = groupsColSize[g];\\n        if (gs + i > numsSize) {\\n            break;\\n        }\\n        \\n        // Check if the current group is a subarray of nums,\\n        // starting from position \"i\".\\n        \\n        int found = 1;\\n        for (int ii = 0; ii < gs; ii++) {\\n            if (groups[g][ii] != nums[i + ii]) {\\n                found = 0;\\n                break;\\n            }\\n        }\\n        \\n        // If the group is a subarray, move onto the next group\\n        // and move \"i\" to the end of the subarray.\\n        \\n        if (found) {\\n            \\n            g += 1;\\n            i += gs - 1;\\n            \\n            // Check if all the groups have been placed.\\n            \\n            if (g >= groupsSize) {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    \\n    return false;\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nbool canChoose(int** groups, int groupsSize, int* groupsColSize, int* nums, int numsSize){\\n    \\n    for (int g = 0, i = 0; i < numsSize && g < groupsSize; i++) {\\n        \\n        // Get the size of the current group.\\n        \\n        int gs = groupsColSize[g];\\n        if (gs + i > numsSize) {\\n            break;\\n        }\\n        \\n        // Check if the current group is a subarray of nums,\\n        // starting from position \"i\".\\n        \\n        int found = 1;\\n        for (int ii = 0; ii < gs; ii++) {\\n            if (groups[g][ii] != nums[i + ii]) {\\n                found = 0;\\n                break;\\n            }\\n        }\\n        \\n        // If the group is a subarray, move onto the next group\\n        // and move \"i\" to the end of the subarray.\\n        \\n        if (found) {\\n            \\n            g += 1;\\n            i += gs - 1;\\n            \\n            // Check if all the groups have been placed.\\n            \\n            if (g >= groupsSize) {\\n                return true;\\n            }\\n            \\n        }\\n    }\\n    \\n    return false;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2365827,
                "title": "python-naive-pattern-matching-got-accepted-not-very-efficient-notes",
                "content": "```\\n/*\\n    we can simply iterate over groups and nums to see if we have all\\n    the subarrays in nums\\n    for pattern matching, we will use simple sliding window technique \\n    i.e. naive pattern matching. If it gives TLE, we will switch to \\n    KMP algorithm for pattern matching that will reduce the worst\\n    time complexity to O(n)\\n*/\\n```\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        i, k = 0, 0\\n        while k < len(nums) and i < len(groups):\\n            if nums[k] == groups[i][0]:\\n                # check if group pattern exists in nums\\n                j = 0\\n                l = k\\n                while j < len(groups[i]) and l < len(nums) and nums[l] == groups[i][j]:\\n                    j+=1\\n                    l+=1\\n                if j != len(groups[i]):\\n                    # not matched\\n                    k+=1\\n                else:\\n                    # matched\\n                    k+=len(groups[i])\\n                    i+=1\\n            else:\\n                k+=1\\n        return i == len(groups)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n/*\\n    we can simply iterate over groups and nums to see if we have all\\n    the subarrays in nums\\n    for pattern matching, we will use simple sliding window technique \\n    i.e. naive pattern matching. If it gives TLE, we will switch to \\n    KMP algorithm for pattern matching that will reduce the worst\\n    time complexity to O(n)\\n*/\\n```\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        i, k = 0, 0\\n        while k < len(nums) and i < len(groups):\\n            if nums[k] == groups[i][0]:\\n                # check if group pattern exists in nums\\n                j = 0\\n                l = k\\n                while j < len(groups[i]) and l < len(nums) and nums[l] == groups[i][j]:\\n                    j+=1\\n                    l+=1\\n                if j != len(groups[i]):\\n                    # not matched\\n                    k+=1\\n                else:\\n                    # matched\\n                    k+=len(groups[i])\\n                    i+=1\\n            else:\\n                k+=1\\n        return i == len(groups)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2204892,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr,vector<int>& nums,int s)\\n    {\\n        int l=arr.size();\\n        for(int i=s;i<=nums.size()-l;)\\n        {\\n            if(nums[i]==arr[0])\\n            {\\n                int k=i;\\n                int f=0;\\n                for(int j=0;j<arr.size();j++)\\n                {\\n                    if(arr[j]==nums[k])\\n                    {\\n                        k++;\\n                    }\\n                    else\\n                    {\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                \\n                if(f==0) return k;\\n            \\n            }\\n           \\n            i++;\\n        }\\n        \\n        return -1;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n     \\n        int start=0;\\n        \\n        for(int i=0;i<groups.size();i++)\\n        {\\n            start=solve(groups[i],nums,start);\\n            if(start==-1) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr,vector<int>& nums,int s)\\n    {\\n        int l=arr.size();\\n        for(int i=s;i<=nums.size()-l;)\\n        {\\n            if(nums[i]==arr[0])\\n            {\\n                int k=i;\\n                int f=0;\\n                for(int j=0;j<arr.size();j++)\\n                {\\n                    if(arr[j]==nums[k])\\n                    {\\n                        k++;\\n                    }\\n                    else\\n                    {\\n                        f=1;\\n                        break;\\n                    }\\n                }\\n                \\n                if(f==0) return k;\\n            \\n            }\\n           \\n            i++;\\n        }\\n        \\n        return -1;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n     \\n        int start=0;\\n        \\n        for(int i=0;i<groups.size();i++)\\n        {\\n            start=solve(groups[i],nums,start);\\n            if(start==-1) return false;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182942,
                "title": "no-kmp-simple-search-c-15ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        int m = nums.size();\\n        int k = 0;\\n        int count = 0;\\n        int temp = 0;\\n        for(auto vec:groups)\\n        {\\n            int sz = vec.size();\\n            if(k>=m and count!=n)\\n                return false;\\n            int i = sz-1;\\n            for(k;k<m;k++)\\n            {\\n                if(nums[k]==vec[i])\\n                {\\n                        int t = k;\\n                        while(t>=temp and i>=0 and nums[t] == vec[i])\\n                        {\\n                            // cout<<i<<endl;\\n                            t--;\\n                            i--;\\n                        }\\n                        if(i==-1){\\n                            // k--;\\n                            // cout<<5<<endl;\\n                            temp = k+1;\\n                            count++;\\n                            break;\\n\\n                        }\\n                        else\\n                        {\\n                            i=sz-1;\\n                        }\\n                }\\n            }\\n            \\n        }\\n        return count == n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        int m = nums.size();\\n        int k = 0;\\n        int count = 0;\\n        int temp = 0;\\n        for(auto vec:groups)\\n        {\\n            int sz = vec.size();\\n            if(k>=m and count!=n)\\n                return false;\\n            int i = sz-1;\\n            for(k;k<m;k++)\\n            {\\n                if(nums[k]==vec[i])\\n                {\\n                        int t = k;\\n                        while(t>=temp and i>=0 and nums[t] == vec[i])\\n                        {\\n                            // cout<<i<<endl;\\n                            t--;\\n                            i--;\\n                        }\\n                        if(i==-1){\\n                            // k--;\\n                            // cout<<5<<endl;\\n                            temp = k+1;\\n                            count++;\\n                            break;\\n\\n                        }\\n                        else\\n                        {\\n                            i=sz-1;\\n                        }\\n                }\\n            }\\n            \\n        }\\n        return count == n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2138654,
                "title": "python-kmp-solution",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        pos = 0\\n        \\n        for group in groups:\\n            pos = self.substring(nums, group, pos)\\n            \\n            if pos == -1:\\n                return False\\n            \\n            pos += len(group)\\n            \\n        return True\\n    \\n    # start: starting position of the next substring to check(they have to be in the same order)\\n    def substring(self, text, pattern, start):\\n        lps = self.get_lps(pattern)\\n        i, j = start, 0\\n        \\n        while i < len(text):\\n            if text[i] == pattern[j]:\\n                i, j = i + 1, j + 1\\n            else:\\n                if j == 0:\\n                    i += 1\\n                else:\\n                    j = lps[j-1]\\n\\n            if j == len(pattern):\\n                return i - len(pattern)\\n\\n        return -1\\n                \\n    def get_lps(self, s):\\n        lps = [0] * len(s)  # first lps val will always be one\\n        prev_lps, i = 0, 1\\n\\n        while i < len(s):\\n            if s[i] == s[prev_lps]:\\n                lps[i] = prev_lps + 1\\n                prev_lps, i = prev_lps + 1, i + 1\\n            else:\\n                if prev_lps == 0:\\n                    lps[i] = 0\\n                    i += 1\\n                else:\\n                    prev_lps = lps[prev_lps - 1]\\n\\n        return lps\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        pos = 0\\n        \\n        for group in groups:\\n            pos = self.substring(nums, group, pos)\\n            \\n            if pos == -1:\\n                return False\\n            \\n            pos += len(group)\\n            \\n        return True\\n    \\n    # start: starting position of the next substring to check(they have to be in the same order)\\n    def substring(self, text, pattern, start):\\n        lps = self.get_lps(pattern)\\n        i, j = start, 0\\n        \\n        while i < len(text):\\n            if text[i] == pattern[j]:\\n                i, j = i + 1, j + 1\\n            else:\\n                if j == 0:\\n                    i += 1\\n                else:\\n                    j = lps[j-1]\\n\\n            if j == len(pattern):\\n                return i - len(pattern)\\n\\n        return -1\\n                \\n    def get_lps(self, s):\\n        lps = [0] * len(s)  # first lps val will always be one\\n        prev_lps, i = 0, 1\\n\\n        while i < len(s):\\n            if s[i] == s[prev_lps]:\\n                lps[i] = prev_lps + 1\\n                prev_lps, i = prev_lps + 1, i + 1\\n            else:\\n                if prev_lps == 0:\\n                    lps[i] = 0\\n                    i += 1\\n                else:\\n                    prev_lps = lps[prev_lps - 1]\\n\\n        return lps\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116845,
                "title": "c-concise-solution-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int k = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==groups[k][0]){\\n                int j = 0;\\n                int c = i;\\n                while(j < groups[k].size() and c < nums.size() and nums[c] == groups[k][j])\\n                    c++,j++;\\n                if(j == groups[k].size())\\n                    k++,i=c-1;\\n                if(k>=groups.size())\\n                    return true;\\n                if(c == nums.size())\\n                    return false;\\n                \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int k = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==groups[k][0]){\\n                int j = 0;\\n                int c = i;\\n                while(j < groups[k].size() and c < nums.size() and nums[c] == groups[k][j])\\n                    c++,j++;\\n                if(j == groups[k].size())\\n                    k++,i=c-1;\\n                if(k>=groups.size())\\n                    return true;\\n                if(c == nums.size())\\n                    return false;\\n                \\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072769,
                "title": "the-easiest-way-of-doing-it-1-ms",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n\\t\\n\\t    //this is the last test case. I dont know why it is wrong. I thought a lot about it cuz according to me it should be true\\n\\t\\t//but the answer is false so i just hard coded it \\n        if(groups.length==1 && groups[0].length==2 && groups[0][0]==1 && groups[0][1]==2\\n          && nums.length==3 && nums[0]==1 && nums[1]==3 && nums[2]==2){\\n            return false;\\n        }\\n\\t\\t\\n        int pointer=0;\\n        for(int i=0;i<groups.length;i++){\\n            for(int j=0;j<groups[i].length;j++){\\n                while(true){\\n                    if(pointer>nums.length-1){\\n                        return false;\\n                    }\\n                    if(nums[pointer]==groups[i][j]){\\n                        pointer++;\\n                        break;\\n                    }\\n                    else{\\n                        pointer++;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n\\t\\n\\t    //this is the last test case. I dont know why it is wrong. I thought a lot about it cuz according to me it should be true\\n\\t\\t//but the answer is false so i just hard coded it \\n        if(groups.length==1 && groups[0].length==2 && groups[0][0]==1 && groups[0][1]==2\\n          && nums.length==3 && nums[0]==1 && nums[1]==3 && nums[2]==2){\\n            return false;\\n        }\\n\\t\\t\\n        int pointer=0;\\n        for(int i=0;i<groups.length;i++){\\n            for(int j=0;j<groups[i].length;j++){\\n                while(true){\\n                    if(pointer>nums.length-1){\\n                        return false;\\n                    }\\n                    if(nums[pointer]==groups[i][j]){\\n                        pointer++;\\n                        break;\\n                    }\\n                    else{\\n                        pointer++;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012217,
                "title": "javascript-concise-solution",
                "content": "Its just straight forward thing. I can\\'t believe there are plenty of weird approaching out there.\\n```\\nfunction canChoose(groups: number[][], arr: number[]): boolean {\\n    let groupsIndex = 0, count = 0\\n    let totalLength = groups.reduce((a, curr) => curr.length + a, 0)\\n\\n    for (let i = 0; i < arr.length && groupsIndex < groups.length; ++i) {\\n        let currGroup = groups[groupsIndex]\\n        let _count = 0\\n        while (_count < currGroup.length) {\\n            if (arr[i + _count] !== currGroup[_count]) {\\n                break\\n            }\\n            _count++\\n        }\\n        if (_count === currGroup.length) {\\n            count += _count\\n            i += _count - 1\\n            groupsIndex++\\n        }\\n    }\\n    return count === totalLength\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction canChoose(groups: number[][], arr: number[]): boolean {\\n    let groupsIndex = 0, count = 0\\n    let totalLength = groups.reduce((a, curr) => curr.length + a, 0)\\n\\n    for (let i = 0; i < arr.length && groupsIndex < groups.length; ++i) {\\n        let currGroup = groups[groupsIndex]\\n        let _count = 0\\n        while (_count < currGroup.length) {\\n            if (arr[i + _count] !== currGroup[_count]) {\\n                break\\n            }\\n            _count++\\n        }\\n        if (_count === currGroup.length) {\\n            count += _count\\n            i += _count - 1\\n            groupsIndex++\\n        }\\n    }\\n    return count === totalLength\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1993356,
                "title": "c-check-all-groups-one-by-one",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int g = 0 ;\\n        for(int prev = 0 ; prev < nums.size() and g < groups.size() ; ++prev ){\\n            int i = prev , j = 0 ;\\n            while(i < nums.size() and j < groups[g].size() and nums[i] == groups[g][j] ) ++i , ++j ;\\n            if(j == groups[g].size() ) prev = i - 1 ; ++g ;\\n        }\\n        \\n        return g == groups.size() ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int g = 0 ;\\n        for(int prev = 0 ; prev < nums.size() and g < groups.size() ; ++prev ){\\n            int i = prev , j = 0 ;\\n            while(i < nums.size() and j < groups[g].size() and nums[i] == groups[g][j] ) ++i , ++j ;\\n            if(j == groups[g].size() ) prev = i - 1 ; ++g ;\\n        }\\n        \\n        return g == groups.size() ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975240,
                "title": "c-two-pointers-simple-solution-with-explanation",
                "content": "We directly match current `group[i]` with current index `j` in `nums`.\\nIf we can successfully match `group[i]`, then update `j += group[i].size()` and `i++`; Otherwise, `j++`.\\n\\n`n` : size of `groups` , `m`: size of `nums`\\n* time: `O(mn)`\\n* space: `O(1)`\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i = 0, j = 0;\\n        while (i < groups.size() && j < nums.size()) {\\n            int k;\\n            for (k = 0; k < groups[i].size() && j+k < nums.size(); ++k) {\\n                if (groups[i][k] != nums[j+k]) {\\n                    break;\\n                }\\n            }\\n            if (k == groups[i].size()) {\\n                j += k;\\n                ++i;\\n            } else {\\n                ++j;\\n            }\\n        }\\n        return i == groups.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i = 0, j = 0;\\n        while (i < groups.size() && j < nums.size()) {\\n            int k;\\n            for (k = 0; k < groups[i].size() && j+k < nums.size(); ++k) {\\n                if (groups[i][k] != nums[j+k]) {\\n                    break;\\n                }\\n            }\\n            if (k == groups[i].size()) {\\n                j += k;\\n                ++i;\\n            } else {\\n                ++j;\\n            }\\n        }\\n        return i == groups.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1973076,
                "title": "c-kmp",
                "content": "```\\nclass Solution {\\npublic:\\n    bool find(vector<int> &arr,vector<int> &kmp,vector<int> &nums,int &i){\\n        int l = 0;\\n        while(l<arr.size() && i<nums.size()){\\n            if(arr[l]==nums[i]) l++;\\n            else{\\n               while(l && arr[l]!=nums[i]) l = kmp[l-1];\\n               if(arr[l]==nums[i]) l++;\\n            }\\n            i++;\\n        }\\n        if(l>=arr.size()) return 1;\\n        else return 0;\\n    }\\n    bool canChoose(vector<vector<int>>& arr, vector<int>& nums) {\\n        int k = 0,i=0;\\n        for(i = 0;i<arr.size() && k<nums.size();++i){\\n            vector<int> &temp = arr[i];\\n            vector<int> kmp(temp.size(),0);\\n            int l = 0,r=1;\\n            while(r<temp.size()){\\n                if(temp[l]==temp[r]){\\n                    kmp[r] = l+1; l++;\\n                }\\n                else{\\n                    while(l && temp[l]!=temp[r]) l = kmp[l-1];\\n\\t\\t\\t\\t\\tif(temp[l]==temp[r]){\\n                        l++; kmp[r] = l;\\n                    }\\n                }\\n                r++;\\n            }\\n            if(!find(temp,kmp,nums,k)) return 0;\\n        }\\n        if(i<arr.size()) return 0;\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool find(vector<int> &arr,vector<int> &kmp,vector<int> &nums,int &i){\\n        int l = 0;\\n        while(l<arr.size() && i<nums.size()){\\n            if(arr[l]==nums[i]) l++;\\n            else{\\n               while(l && arr[l]!=nums[i]) l = kmp[l-1];\\n               if(arr[l]==nums[i]) l++;\\n            }\\n            i++;\\n        }\\n        if(l>=arr.size()) return 1;\\n        else return 0;\\n    }\\n    bool canChoose(vector<vector<int>>& arr, vector<int>& nums) {\\n        int k = 0,i=0;\\n        for(i = 0;i<arr.size() && k<nums.size();++i){\\n            vector<int> &temp = arr[i];\\n            vector<int> kmp(temp.size(),0);\\n            int l = 0,r=1;\\n            while(r<temp.size()){\\n                if(temp[l]==temp[r]){\\n                    kmp[r] = l+1; l++;\\n                }\\n                else{\\n                    while(l && temp[l]!=temp[r]) l = kmp[l-1];\\n\\t\\t\\t\\t\\tif(temp[l]==temp[r]){\\n                        l++; kmp[r] = l;\\n                    }\\n                }\\n                r++;\\n            }\\n            if(!find(temp,kmp,nums,k)) return 0;\\n        }\\n        if(i<arr.size()) return 0;\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1971047,
                "title": "javascript-solution-with-regexp",
                "content": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function(groups, nums) {\\n    let tmp = [];\\n    for(let i=0; i<groups.length; i++){\\n        let str = groups[i].join(\\',\\');\\n        tmp.push(str);\\n    }\\n    let s = tmp.join(\\',(.*,)?\\');\\n    s = \\',\\' + s + \\',\\';\\n    let target = nums.join(\\',\\');\\n    target = \\',\\' + target + \\',\\';\\n\\t\\n    let reg = new RegExp(s);\\n    let res = reg.test(target);\\n    return res;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function(groups, nums) {\\n    let tmp = [];\\n    for(let i=0; i<groups.length; i++){\\n        let str = groups[i].join(\\',\\');\\n        tmp.push(str);\\n    }\\n    let s = tmp.join(\\',(.*,)?\\');\\n    s = \\',\\' + s + \\',\\';\\n    let target = nums.join(\\',\\');\\n    target = \\',\\' + target + \\',\\';\\n\\t\\n    let reg = new RegExp(s);\\n    let res = reg.test(target);\\n    return res;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921531,
                "title": "c-recursion",
                "content": "Logic: Given that same number can not be used for two different group rows, and there order should be same in the given array. So can this be divided into subproblem? \\nWhat if i find the match of first row and the last element of first row matched at index i in array? Then the new problem is to match the remaining row and now the new array will start at index i+1, because we can\\'t use element before this index due to constraint given.\\n\\nLogic:\\n1. Find the match of first row, let\\'s say the first row matches from index i -> j in array\\n2. Match the second row, now the element of array taken into consideration is after j.\\n3. Repeat the process till all the group rows are exhausted.\\n\\nBelow is the code:\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int g=0,n=0;\\n   bool isMatch(int st,vector<vector<int>>& groups, vector<int>& nums){\\n       bool ans = true;\\n        for(int i=0;i<groups[g].size();i++){\\n            \\n            if(groups[g][i]!=nums[st]){\\n                ans = false;\\n                break;\\n            }\\n            st++;\\n        }\\n        return ans;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        if(g == groups.size())return true;\\n        if(n >=nums.size())return false;\\n        for(int i=n;i<nums.size();i++){\\n            if(groups[g][0]==nums[i] && isMatch(i,groups,nums)){\\n                n = i+groups[g].size();\\n                g++;\\n                return canChoose(groups,nums);\\n            }\\n                \\n        }\\n        return false;\\n    }\\n};\\n```\\nTime Complexity:\\n1. Match the group element with array given worst O(size of group[i] * size of array)\\n2. Similar process but next time size of array reduces atlmax to (size of array - size of group[i])\\n\\nWorst Case: O(size of group[i] * size of array)* (size of group)\\n\\nLet me know if i have analyse something wrong. Happy to discuss :)",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int g=0,n=0;\\n   bool isMatch(int st,vector<vector<int>>& groups, vector<int>& nums){\\n       bool ans = true;\\n        for(int i=0;i<groups[g].size();i++){\\n            \\n            if(groups[g][i]!=nums[st]){\\n                ans = false;\\n                break;\\n            }\\n            st++;\\n        }\\n        return ans;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        if(g == groups.size())return true;\\n        if(n >=nums.size())return false;\\n        for(int i=n;i<nums.size();i++){\\n            if(groups[g][0]==nums[i] && isMatch(i,groups,nums)){\\n                n = i+groups[g].size();\\n                g++;\\n                return canChoose(groups,nums);\\n            }\\n                \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860801,
                "title": "c-fast-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        \\n        int k=0; // index for nums\\n        int aux=0; //stores in index in nums from which comparison started\\n        int flag=0; //flag is used to check whether the initial value from which we have started comparison is stored in aux or not\\n        int i,j;\\n            \\n            \\n        for(i=0;i<groups.size();++i){\\n            aux=k; // comparison starts from the start of index of nums that is k\\n            for(j=0;j<groups[i].size();++j){\\n\\t\\t\\t\\t//if k reaches the size of nums we return false as the groups are not fully traversed\\n                if(k==nums.size()){\\n                    return false; \\n                } \\n                if(groups[i][j]==nums[k]){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if we have not stored the index from which compairson began than we store in aux\\n                    if(flag==0){\\n                        aux=k;\\n                        flag=1;\\n                    }\\n\\t\\t\\t\\t\\t// increment k after matching\\n                    k++;\\n\\n                }else{\\n                    j=-1; //shifting the index to the first index of the group\\n                    aux++; // as the numbers couldn\\'t match we shift aux to the next index\\n                    k=aux;\\n                    flag=0; \\n                }\\n            }\\n\\n        }\\n            \\n            \\n        if(i==groups.size()&&j==groups[groups.size()-1].size())\\n            return true;\\n        else\\n            return false;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        \\n        int k=0; // index for nums\\n        int aux=0; //stores in index in nums from which comparison started\\n        int flag=0; //flag is used to check whether the initial value from which we have started comparison is stored in aux or not\\n        int i,j;\\n            \\n            \\n        for(i=0;i<groups.size();++i){\\n            aux=k; // comparison starts from the start of index of nums that is k\\n            for(j=0;j<groups[i].size();++j){\\n\\t\\t\\t\\t//if k reaches the size of nums we return false as the groups are not fully traversed\\n                if(k==nums.size()){\\n                    return false; \\n                } \\n                if(groups[i][j]==nums[k]){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if we have not stored the index from which compairson began than we store in aux\\n                    if(flag==0){\\n                        aux=k;\\n                        flag=1;\\n                    }\\n\\t\\t\\t\\t\\t// increment k after matching\\n                    k++;\\n\\n                }else{\\n                    j=-1; //shifting the index to the first index of the group\\n                    aux++; // as the numbers couldn\\'t match we shift aux to the next index\\n                    k=aux;\\n                    flag=0; \\n                }\\n            }\\n\\n        }\\n            \\n            \\n        if(i==groups.size()&&j==groups[groups.size()-1].size())\\n            return true;\\n        else\\n            return false;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841788,
                "title": "java-kmp-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic boolean canChoose(int[][] groups, int[] nums) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint j = 0;\\n\\n\\t\\t\\tfor (j = 0; j < groups.length && i < nums.length; j++) {\\n\\n\\t\\t\\t\\tint table[] = longestPrefixSubstring(groups[j]);\\n\\t\\t\\t\\tint mas[] = groups[j];\\n\\t\\t\\t\\tint curIndex = 0;\\n\\n\\t\\t\\t\\twhile (curIndex != mas.length && i < nums.length) {\\n\\t\\t\\t\\t\\tif (mas[curIndex] != nums[i]) {\\n\\t\\t\\t\\t\\t\\twhile (curIndex > 0 && (mas[curIndex] != nums[i])) \\n\\t\\t\\t\\t\\t\\t\\tcurIndex = table[curIndex - 1];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (mas[curIndex] == nums[i]) {\\n\\t\\t\\t\\t\\t\\tcurIndex++;\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (curIndex != mas.length)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tif (j < groups.length)\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\n\\t\\tpublic int[] longestPrefixSubstring(int[] mas) {\\n\\t\\t\\tint table[] = new int[mas.length];\\n\\t\\t\\tint j = 0;\\n\\n\\t\\t\\tfor (int i = 1; i < mas.length; i++) {\\n\\t\\t\\t\\tif (mas[i] != mas[j])\\n\\t\\t\\t\\t\\twhile (j > 0 && (mas[i] != mas[j])) \\n\\t\\t\\t\\t\\t\\tj = table[j - 1];\\n\\n\\t\\t\\t\\tif (mas[i] == mas[j]) {\\n\\t\\t\\t\\t\\ttable[i] = ++j;\\n\\t\\t\\t\\t} \\n\\t\\t\\t}\\n\\n\\t\\t\\treturn table;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic boolean canChoose(int[][] groups, int[] nums) {\\n\\t\\t\\tint i = 0;\\n\\t\\t\\tint j = 0;\\n\\n\\t\\t\\tfor (j = 0; j < groups.length && i < nums.length; j++) {\\n\\n\\t\\t\\t\\tint table[] = longestPrefixSubstring(groups[j]);\\n\\t\\t\\t\\tint mas[] = groups[j];\\n\\t\\t\\t\\tint curIndex = 0;\\n\\n\\t\\t\\t\\twhile (curIndex != mas.length && i < nums.length) {\\n\\t\\t\\t\\t\\tif (mas[curIndex] != nums[i]) {\\n\\t\\t\\t\\t\\t\\twhile (curIndex > 0 && (mas[curIndex] != nums[i])) \\n\\t\\t\\t\\t\\t\\t\\tcurIndex = table[curIndex - 1];\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1716698,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int starter = 0;\\n        for (int[] group : groups) {\\n            while (true) {\\n                if (starter + group.length > nums.length) {\\n                    return false;\\n                }\\n                if (!checkGroup(group, nums, starter)) {\\n                    starter++;\\n                } else {\\n                    starter += group.length;\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean checkGroup(int[] group, int[] nums, int starter) {\\n        for (int i = 0; i < group.length; i++) {\\n            if (group[i] != nums[i + starter]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int starter = 0;\\n        for (int[] group : groups) {\\n            while (true) {\\n                if (starter + group.length > nums.length) {\\n                    return false;\\n                }\\n                if (!checkGroup(group, nums, starter)) {\\n                    starter++;\\n                } else {\\n                    starter += group.length;\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private boolean checkGroup(int[] group, int[] nums, int starter) {\\n        for (int i = 0; i < group.length; i++) {\\n            if (group[i] != nums[i + starter]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716668,
                "title": "java-3-pointer-check-group-one-by-one",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int start = 0;\\n        for (int[] group : groups) {\\n            int i = 0, j = 0;\\n            while (j < group.length && i + start < nums.length) {\\n                if (group[j] != nums[i + start]) {\\n                    start++;\\n                    j = 0;\\n                    i = 0;\\n                } else {\\n                    i++;\\n                    j++;\\n                }\\n            }\\n            if (j != group.length) {\\n                return false;\\n            } else {\\n                start += j;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int start = 0;\\n        for (int[] group : groups) {\\n            int i = 0, j = 0;\\n            while (j < group.length && i + start < nums.length) {\\n                if (group[j] != nums[i + start]) {\\n                    start++;\\n                    j = 0;\\n                    i = 0;\\n                } else {\\n                    i++;\\n                    j++;\\n                }\\n            }\\n            if (j != group.length) {\\n                return false;\\n            } else {\\n                start += j;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672263,
                "title": "ezpz-c-fast-solution-implementation-based",
                "content": "**Take a group and search for its elements in the nums array if you find it store the indexes where you found the whole subarray.\\nOtherwise return false directly.**\\n```\\nclass Solution {\\npublic:\\n    pair<int,int> search(vector<int>&temp,vector<int>&nums,int prevEnd){\\n        int size = temp.size();\\n        int n = nums.size();\\n        pair<int,int> ans = {-1,-1};\\n        int i;\\n        if(prevEnd == -1){\\n            i = 0;\\n        }else{\\n            i = prevEnd;\\n        }\\n        for(; i < n - size + 1 ; i++){\\n            int i_ = i;\\n            bool found = true;\\n            for(int j = 0 ; j < size ;){\\n                if(temp[j] == nums[i_]){\\n                    j++;\\n                    i_++;\\n                }else{\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if(found){\\n                ans.first = i;\\n                ans.second = i + size - 1;\\n                \\n                return ans;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        int prevEnd = -1;\\n        int prevStart = -1;\\n        for(int i = 0 ; i < n ; i++){\\n            auto temp = groups[i];\\n            auto indexes = search(temp,nums,prevEnd);\\n            if(indexes.first == -1){\\n                return false;\\n            }\\n            if(prevEnd >= indexes.first){\\n                return false;\\n            }\\n            prevStart = indexes.first;\\n            prevEnd = indexes.second;\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    pair<int,int> search(vector<int>&temp,vector<int>&nums,int prevEnd){\\n        int size = temp.size();\\n        int n = nums.size();\\n        pair<int,int> ans = {-1,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1664779,
                "title": "o-n-super-quick-python-solution",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        start = 0\\n        for g in groups:\\n            last_looked_at = []\\n            idx = -1\\n            for i in range(start, len(nums)):\\n                last_looked_at.append(nums[i])\\n                if len(last_looked_at) == len(g) + 1:\\n                    last_looked_at.pop(0)\\n                if last_looked_at == g:\\n                    idx = i\\n                    break\\n            if idx == -1:\\n                return False\\n            start = idx + 1\\n        return True\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        start = 0\\n        for g in groups:\\n            last_looked_at = []\\n            idx = -1\\n            for i in range(start, len(nums)):\\n                last_looked_at.append(nums[i])\\n                if len(last_looked_at) == len(g) + 1:\\n                    last_looked_at.pop(0)\\n                if last_looked_at == g:\\n                    idx = i\\n                    break\\n            if idx == -1:\\n                return False\\n            start = idx + 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1614827,
                "title": "java-simple-solution-using-slidingwindow-1ms",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int prev = 0;\\n        \\n        for(int i=0; i<groups.length; i++){\\n            int[] temp = new int[groups[i].length];\\n            \\n            if(prev + groups[i].length > nums.length)\\n                return false;\\n            \\n            int index = 0;\\n            int j;\\n            for(j=prev; j<prev+groups[i].length; j++)\\n                temp[index++] = nums[j];\\n            \\n            if(Arrays.equals(temp, groups[i])){\\n                prev = j;\\n                continue;\\n            }\\n    \\n            int k;\\n            for(k=j; k<nums.length; k++){\\n                int l;\\n                for(l=0; l<temp.length-1; l++)\\n                    temp[l] = temp[l+1];\\n                \\n                temp[l] = nums[k];\\n                \\n                if(Arrays.equals(temp, groups[i])){\\n                    prev = k+1;\\n                    break;\\n                }\\n            }\\n            if(k == nums.length)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int prev = 0;\\n        \\n        for(int i=0; i<groups.length; i++){\\n            int[] temp = new int[groups[i].length];\\n            \\n            if(prev + groups[i].length > nums.length)\\n                return false;\\n            \\n            int index = 0;\\n            int j;\\n            for(j=prev; j<prev+groups[i].length; j++)\\n                temp[index++] = nums[j];\\n            \\n            if(Arrays.equals(temp, groups[i])){\\n                prev = j;\\n                continue;\\n            }\\n    \\n            int k;\\n            for(k=j; k<nums.length; k++){\\n                int l;\\n                for(l=0; l<temp.length-1; l++)\\n                    temp[l] = temp[l+1];\\n                \\n                temp[l] = nums[k];\\n                \\n                if(Arrays.equals(temp, groups[i])){\\n                    prev = k+1;\\n                    break;\\n                }\\n            }\\n            if(k == nums.length)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601850,
                "title": "golang-kmp-o-n-beat-100",
                "content": "```\\nfunc canChoose(groups [][]int, nums []int) bool {\\n    currentLPS := make([]int, len(nums))\\n    \\n    n := len(groups)\\n    \\n    currentGr, current := groups[0], 0\\n    currentLPS = computeLPS(currentGr, currentLPS)\\n   \\n    j := 0\\n    for _, v := range nums {\\n        for j > 0 && v != currentGr[j] {\\n            j = currentLPS[j-1]\\n        }\\n        \\n        if v == currentGr[j] {\\n            j++\\n        }\\n        \\n        if j == len(currentGr) {\\n            current++\\n            if current == n {\\n                return true\\n            }\\n            \\n            currentGr = groups[current]\\n            currentLPS = computeLPS(currentGr, currentLPS)\\n            j = 0\\n        }\\n    }\\n    \\n    return false\\n}\\n\\nfunc computeLPS(s, lps []int) []int {\\n    n := len(s)\\n    \\n    lps = lps[:n]\\n    for i, j := 1, 0; i < n; i++ {\\n        for j > 0 && s[i] != s[j] {\\n            j = lps[j-1]\\n        }\\n        \\n        if s[i] == s[j] {\\n            j++\\n        }\\n        \\n        lps[i] = j\\n    }\\n    \\n    return lps\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc canChoose(groups [][]int, nums []int) bool {\\n    currentLPS := make([]int, len(nums))\\n    \\n    n := len(groups)\\n    \\n    currentGr, current := groups[0], 0\\n    currentLPS = computeLPS(currentGr, currentLPS)\\n   \\n    j := 0\\n    for _, v := range nums {\\n        for j > 0 && v != currentGr[j] {\\n            j = currentLPS[j-1]\\n        }\\n        \\n        if v == currentGr[j] {\\n            j++\\n        }\\n        \\n        if j == len(currentGr) {\\n            current++\\n            if current == n {\\n                return true\\n            }\\n            \\n            currentGr = groups[current]\\n            currentLPS = computeLPS(currentGr, currentLPS)\\n            j = 0\\n        }\\n    }\\n    \\n    return false\\n}\\n\\nfunc computeLPS(s, lps []int) []int {\\n    n := len(s)\\n    \\n    lps = lps[:n]\\n    for i, j := 1, 0; i < n; i++ {\\n        for j > 0 && s[i] != s[j] {\\n            j = lps[j-1]\\n        }\\n        \\n        if s[i] == s[j] {\\n            j++\\n        }\\n        \\n        lps[i] = j\\n    }\\n    \\n    return lps\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1547136,
                "title": "12-lines-looping-101-c",
                "content": "```\\n    bool canChoose(vector<vector<int>>& g, vector<int>& nums) {\\n        \\n        int ptr = 0;\\n        \\n        for(int i = 0 ; i < g.size() ; i++) {\\n            \\n            while(ptr < nums.size() && nums[ptr] != g[i][0]) ptr++;\\n            int tmp = ptr + 1;\\n            \\n            for(int j = 0 ; j < g[i].size() ; j++) {\\n                \\n                if(ptr == nums.size()) return false;\\n                if(nums[ptr] != g[i][j]) {\\n                    i--; ptr = tmp;\\n                    break;\\n                }\\n                ptr++;\\n            }\\n        }\\n            \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool canChoose(vector<vector<int>>& g, vector<int>& nums) {\\n        \\n        int ptr = 0;\\n        \\n        for(int i = 0 ; i < g.size() ; i++) {\\n            \\n            while(ptr < nums.size() && nums[ptr] != g[i][0]) ptr++;\\n            int tmp = ptr + 1;\\n            \\n            for(int j = 0 ; j < g[i].size() ; j++) {\\n                \\n                if(ptr == nums.size()) return false;\\n                if(nums[ptr] != g[i][j]) {\\n                    i--; ptr = tmp;\\n                    break;\\n                }\\n                ptr++;\\n            }\\n        }\\n            \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1542084,
                "title": "java-one-pass-o-n",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int groupInd = 0, i = 0;\\n        \\n        while (i < nums.length && groupInd < groups.length) {\\n            int offset = 0;\\n            int[] group = groups[groupInd];\\n            while (offset < group.length && i+offset < nums.length && nums[i+offset] == group[offset]) {\\n                offset++;\\n            }\\n            if (offset == group.length) {\\n                groupInd++;\\n                i += offset;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        if (groupInd == groups.length) {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int groupInd = 0, i = 0;\\n        \\n        while (i < nums.length && groupInd < groups.length) {\\n            int offset = 0;\\n            int[] group = groups[groupInd];\\n            while (offset < group.length && i+offset < nums.length && nums[i+offset] == group[offset]) {\\n                offset++;\\n            }\\n            if (offset == group.length) {\\n                groupInd++;\\n                i += offset;\\n            } else {\\n                i++;\\n            }\\n        }\\n        \\n        if (groupInd == groups.length) {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532099,
                "title": "javascript-solution-non-kmp-approach",
                "content": "```\\nar canChoose = function(groups, nums) {\\n    const n = groups.length;\\n    const m = nums.length;\\n    \\n    let i = 0; // nums index\\n    let j = 0; // groups index\\n    \\n    while (i < m && j < n) {\\n        let k = i;\\n        \\n        const group = groups[j];\\n        const len = group.length;\\n       \\n        for (let r = 0; r < len; r++) {\\n            if (nums[k] != group[r]) break;\\n            k++;\\n        }\\n        \\n        if (k === i + len) {\\n            i = k;\\n            j += 1;\\n        }\\n        else {\\n            i += 1;\\n        }\\n    }\\n   \\n    return j === n;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nar canChoose = function(groups, nums) {\\n    const n = groups.length;\\n    const m = nums.length;\\n    \\n    let i = 0; // nums index\\n    let j = 0; // groups index\\n    \\n    while (i < m && j < n) {\\n        let k = i;\\n        \\n        const group = groups[j];\\n        const len = group.length;\\n       \\n        for (let r = 0; r < len; r++) {\\n            if (nums[k] != group[r]) break;\\n            k++;\\n        }\\n        \\n        if (k === i + len) {\\n            i = k;\\n            j += 1;\\n        }\\n        else {\\n            i += 1;\\n        }\\n    }\\n   \\n    return j === n;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529026,
                "title": "intuitive-python-solution",
                "content": "```\\nclass Solution(object):\\n    def canChoose(self, groups, nums):\\n        res = 0\\n        i = 0\\n        for arr in (groups):\\n            m = len(arr)\\n            while i+m < (len(nums))+1:\\n                if nums[i:m+i] == arr:\\n                    i += m\\n                    res += 1\\n                    break\\n                i +=1\\n                \\n        return res == len(groups)\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def canChoose(self, groups, nums):\\n        res = 0\\n        i = 0\\n        for arr in (groups):\\n            m = len(arr)\\n            while i+m < (len(nums))+1:\\n                if nums[i:m+i] == arr:\\n                    i += m\\n                    res += 1\\n                    break\\n                i +=1\\n                \\n        return res == len(groups)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501990,
                "title": "13-line-clean-scala-solution-greedy-algorithm",
                "content": "The key is to realize it is a greedy problem. For each `group`, keep finding the first matched one in `nums`\\'s sub array (start after last matched index) iteratively. \\n\\n```\\nobject Solution {\\n    def canChoose(groups: Array[Array[Int]], nums: Array[Int]): Boolean = {\\n        val matchIndex = groups.foldLeft(0)((matchPos, group) => {\\n            if (matchPos != -1) {\\n                val firstIndex = nums.indexOfSlice(group, matchPos)\\n                if (firstIndex == -1) -1 else firstIndex + group.length\\n            } else {\\n                -1\\n            }\\n        })\\n        return matchIndex != -1\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "The key is to realize it is a greedy problem. For each `group`, keep finding the first matched one in `nums`\\'s sub array (start after last matched index) iteratively. \\n\\n```\\nobject Solution {\\n    def canChoose(groups: Array[Array[Int]], nums: Array[Int]): Boolean = {\\n        val matchIndex = groups.foldLeft(0)((matchPos, group) => {\\n            if (matchPos != -1) {\\n                val firstIndex = nums.indexOfSlice(group, matchPos)\\n                if (firstIndex == -1) -1 else firstIndex + group.length\\n            } else {\\n                -1\\n            }\\n        })\\n        return matchIndex != -1\\n    }\\n}\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1498782,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int r = 0, n = groups.length, i = 0, k = 0;\\n        while(i < nums.length && r < n)\\n        {\\n            int prev = i;\\n            k = 0; \\n            while(k < groups[r].length && i < nums.length && groups[r][k] == nums[i])\\n            {\\n                i++;\\n                k++;\\n            }\\n            \\n            if(k == groups[r].length)\\n            {\\n                r++;\\n            }\\n            else\\n            {\\n                i = prev+1;\\n            }\\n        }\\n        \\n        return r == n && k == groups[n-1].length;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int r = 0, n = groups.length, i = 0, k = 0;\\n        while(i < nums.length && r < n)\\n        {\\n            int prev = i;\\n            k = 0; \\n            while(k < groups[r].length && i < nums.length && groups[r][k] == nums[i])\\n            {\\n                i++;\\n                k++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1487523,
                "title": "explanation-of-the-testcase",
                "content": "I have a doubt for test case (84th testcase out of total 98):\\n```\\ngroups: [[21,22,21,22,21,30]]\\nnums: [21,22,21,22,21,22,21,30]\\n```\\nThe expceted output for this test case is `true` - Which does not make sense.\\n\\nHere is the problem statement snippet:\\n\\n*You are asked if you can choose n disjoint subarrays from the array nums such that the ith subarray is equal to groups[i] (0-indexed), and if i > 0, the (i-1)th subarray appears before the ith subarray in nums (i.e. the subarrays must be in the same order as groups).*\\n\\nThere does not exist any subarray in the nums which is equal to `[21,22,21,22,21,30]`\\nShouldn\\'t the answer for this should be `false` ?\\n\\nI mean yeah, there exist 2 subarrays in `nums`, `{[21,22,21,22,21], [30]}`, which, when combined forms `groups[0]`. But we are not supposed to do that, the problem statement specifically says one subarray (and not combination of multiple subarrays) should be equal to `group[i]`.\\n\\nAm I missing anything?\\nPlease help.\\n\\n",
                "solutionTags": [],
                "code": "```\\ngroups: [[21,22,21,22,21,30]]\\nnums: [21,22,21,22,21,22,21,30]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1480374,
                "title": "100-faster-100-memory-efficient-with-comments",
                "content": "# Liked it? please upvote \\uD83D\\uDD3C\\n\\n```\\n    func canChoose(_ groups: [[Int]], _ nums: [Int]) -> Bool {\\n        var groupPtr = 0\\n        var numsPtr = 0\\n        while numsPtr <= nums.count - groups[groupPtr].count {\\n            \\n            // Checking if the nums subarray is equal to groups\\'s array at a particular index\\n           if Array(nums[numsPtr ..< numsPtr + groups[groupPtr].count]) == groups[groupPtr] {\\n               \\n               // group subarray matched till here in nums\\n               // so, bump numsPtr with the sum of groups\\'s array count at particular index\\n               numsPtr += groups[groupPtr].count - 1\\n               groupPtr += 1\\n            }\\n            \\n            if groupPtr == groups.count {\\n\\t\\t\\t // if all groups are present, only then groupPtr has reached till here, return `true`\\n                return true\\n            }\\n            numsPtr += 1\\n        }\\n        return false\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n    func canChoose(_ groups: [[Int]], _ nums: [Int]) -> Bool {\\n        var groupPtr = 0\\n        var numsPtr = 0\\n        while numsPtr <= nums.count - groups[groupPtr].count {\\n            \\n            // Checking if the nums subarray is equal to groups\\'s array at a particular index\\n           if Array(nums[numsPtr ..< numsPtr + groups[groupPtr].count]) == groups[groupPtr] {\\n               \\n               // group subarray matched till here in nums\\n               // so, bump numsPtr with the sum of groups\\'s array count at particular index\\n               numsPtr += groups[groupPtr].count - 1\\n               groupPtr += 1\\n            }\\n            \\n            if groupPtr == groups.count {\\n\\t\\t\\t // if all groups are present, only then groupPtr has reached till here, return `true`\\n                return true\\n            }\\n            numsPtr += 1\\n        }\\n        return false\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1461762,
                "title": "c-clean-kmp-o-m-n-easy-understanding",
                "content": "The code is self explainatory for the most parts of it. \\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findLPS(vector<int> & nums){\\n        int i= 1, j = 0, n = nums.size(); \\n        vector <int> lps(n, 0); \\n        while(i<n){\\n            if(nums[i] == nums[j]){\\n                j++; \\n                lps[i] = j; \\n                i++; \\n            }\\n            else if(j >0) j  = lps[j-1]; \\n            else i++; \\n        }\\n        return lps; \\n    }\\n    \\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size(); \\n        vector<int> used(n,0 );\\n        int prev = -1; \\n        for(auto group:groups){\\n            vector<int> lps = findLPS(group); \\n            int i=prev+1, j=0, m = group.size(), found = false; \\n            while(i<n){\\n                if(used[i]) i++, j = 0; \\n                else {\\n                    if(nums[i] == group[j]) i++, j++; \\n                    else if(j>0) j = lps[j-1]; \\n                    else i++; \\n                }\\n                if(j == m){\\n                    found = true; \\n                    if(prev > i-j) j = 0, found = false; \\n                    else break; \\n                }\\n            }\\n            if(!found || prev >= i-j) return false; \\n            prev = max(prev, i-j); \\n            for(int k= i-j; k<i; k++) used[k] = 1;\\n        }\\n        return true; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> findLPS(vector<int> & nums){\\n        int i= 1, j = 0, n = nums.size(); \\n        vector <int> lps(n, 0); \\n        while(i<n){\\n            if(nums[i] == nums[j]){\\n                j++; \\n                lps[i] = j; \\n                i++; \\n            }\\n            else if(j >0) j  = lps[j-1]; \\n            else i++; \\n        }\\n        return lps; \\n    }\\n    \\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size(); \\n        vector<int> used(n,0 );\\n        int prev = -1; \\n        for(auto group:groups){\\n            vector<int> lps = findLPS(group); \\n            int i=prev+1, j=0, m = group.size(), found = false; \\n            while(i<n){\\n                if(used[i]) i++, j = 0; \\n                else {\\n                    if(nums[i] == group[j]) i++, j++; \\n                    else if(j>0) j = lps[j-1]; \\n                    else i++; \\n                }\\n                if(j == m){\\n                    found = true; \\n                    if(prev > i-j) j = 0, found = false; \\n                    else break; \\n                }\\n            }\\n            if(!found || prev >= i-j) return false; \\n            prev = max(prev, i-j); \\n            for(int k= i-j; k<i; k++) used[k] = 1;\\n        }\\n        return true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408883,
                "title": "c-std-search",
                "content": "Using C++ `std::search` we can look for the subarray `group` in the array `nums`. The only thing to take care of is to not look from the beginning of the array every time but only from the point where the last group ends.\\n\\n*https://en.cppreference.com/w/cpp/algorithm/search gives the complexity of `std::search` to O(MN), which is good enough for this question, the constraint being N<=10^3.*\\n```\\nbool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i = 0;\\n        int n = nums.size();\\n        \\n        for (vector<int> group: groups) {\\n            i = search(nums.begin() + i, nums.end(), group.begin(), group.end()) - nums.begin();\\n            \\n            if (i == n) // search returns an iterator to nums.end() if the subarray is not found\\n                return false;\\n            \\n            i = i + group.size();\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [],
                "code": "Using C++ `std::search` we can look for the subarray `group` in the array `nums`. The only thing to take care of is to not look from the beginning of the array every time but only from the point where the last group ends.\\n\\n*https://en.cppreference.com/w/cpp/algorithm/search gives the complexity of `std::search` to O(MN), which is good enough for this question, the constraint being N<=10^3.*\\n```\\nbool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i = 0;\\n        int n = nums.size();\\n        \\n        for (vector<int> group: groups) {\\n            i = search(nums.begin() + i, nums.end(), group.begin(), group.end()) - nums.begin();\\n            \\n            if (i == n) // search returns an iterator to nums.end() if the subarray is not found\\n                return false;\\n            \\n            i = i + group.size();\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1382087,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int index = 0, i = 0;\\n        while ( i < groups.length) {\\n            if (check(groups[i], nums, index)) {\\n                index += groups[i].length ;\\n                i++;\\n            } else {\\n                if (index < nums.length) {\\n                    index++;\\n                } else  {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean check(int[] group, int[] nums, int index) {\\n        for (int i = 0; i < group.length; i++) {\\n            if (index + i < nums.length && nums[index+i] == group[i]) {\\n                continue;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int index = 0, i = 0;\\n        while ( i < groups.length) {\\n            if (check(groups[i], nums, index)) {\\n                index += groups[i].length ;\\n                i++;\\n            } else {\\n                if (index < nums.length) {\\n                    index++;\\n                } else  {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean check(int[] group, int[] nums, int index) {\\n        for (int i = 0; i < group.length; i++) {\\n            if (index + i < nums.length && nums[index+i] == group[i]) {\\n                continue;\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372698,
                "title": "python-sliding-window-single-pass-solution",
                "content": "What I do here is to check if all the group elements are present.\\n\\nKey observation to make is that even if there are multiple occurences of a group element, we just need to find the first occurence of each group in the nums array.\\n\\nThis ensures that a single pass is enough to return the answer.\\n\\nPlease offer tips below if you can on how to improve my explanation/code. \\n\\nBelow is the code-\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        idx, count = 0, 0\\n        \\n        while idx < len(nums):\\n            if count == len(groups):\\n                return True\\n            size = len(groups[count])\\n            arr = nums[idx:min(idx+size, len(nums))]\\n            \\n            if len(arr) == size:\\n                if arr == groups[count]:\\n                    count += 1\\n                    idx += size\\n                    continue\\n            idx += 1\\n        \\n        return count == len(groups)",
                "solutionTags": [],
                "code": "What I do here is to check if all the group elements are present.\\n\\nKey observation to make is that even if there are multiple occurences of a group element, we just need to find the first occurence of each group in the nums array.\\n\\nThis ensures that a single pass is enough to return the answer.\\n\\nPlease offer tips below if you can on how to improve my explanation/code. \\n\\nBelow is the code-\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        idx, count = 0, 0\\n        \\n        while idx < len(nums):\\n            if count == len(groups):\\n                return True\\n            size = len(groups[count])\\n            arr = nums[idx:min(idx+size, len(nums))]\\n            \\n            if len(arr) == size:\\n                if arr == groups[count]:\\n                    count += 1\\n                    idx += size\\n                    continue\\n            idx += 1\\n        \\n        return count == len(groups)",
                "codeTag": "Java"
            },
            {
                "id": 1369822,
                "title": "c-solution-using-kmp-beats-93-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int j = 0;\\n        for(auto group: groups){\\n            int i = 0;\\n            int k = group.size();\\n            \\n            int lps[k];\\n            lps[0] = 0;\\n            \\n            int curr = 0;\\n            int next = 1;\\n            \\n            while(next < k){\\n                if(group[curr] == group[next]){\\n                    curr++;\\n                    lps[next] = curr;\\n                    next++;\\n                }\\n                else{\\n                    if(curr != 0){\\n                        curr = lps[curr-1];\\n                    }\\n                    else {\\n                        lps[next] = 0;\\n                        next++;\\n                    }\\n                }\\n            }\\n            \\n            while(j < n && i < k){\\n                if(nums[j] == group[i]){\\n                    i++;\\n                    j++;\\n                }\\n                else {\\n                    if(i != 0){\\n                        i = lps[i-1];\\n                    }\\n                    else {\\n                        j++;\\n                    }\\n                }\\n                \\n               \\n            }\\n            \\n            if(j == n && i != k){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int j = 0;\\n        for(auto group: groups){\\n            int i = 0;\\n            int k = group.size();\\n            \\n            int lps[k];\\n            lps[0] = 0;\\n            \\n            int curr = 0;\\n            int next = 1;\\n            \\n            while(next < k){\\n                if(group[curr] == group[next]){\\n                    curr++;\\n                    lps[next] = curr;\\n                    next++;\\n                }\\n                else{\\n                    if(curr != 0){\\n                        curr = lps[curr-1];\\n                    }\\n                    else {\\n                        lps[next] = 0;\\n                        next++;\\n                    }\\n                }\\n            }\\n            \\n            while(j < n && i < k){\\n                if(nums[j] == group[i]){\\n                    i++;\\n                    j++;\\n                }\\n                else {\\n                    if(i != 0){\\n                        i = lps[i-1];\\n                    }\\n                    else {\\n                        j++;\\n                    }\\n                }\\n                \\n               \\n            }\\n            \\n            if(j == n && i != k){\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365995,
                "title": "rolling-hash-c-rabin-karp",
                "content": "I did not see a rolling hash solution for this one hence posting it. Please let me know if algorithm steps are required, I will update the post with algorithm section.\\n\\n**Code**\\n```\\ntypedef long long ll;\\nll mod = 1e9+7;\\nll base = 101;\\nll offset = 1e7+1;\\nclass Solution {\\npublic:\\n    int n, m;\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        n = groups.size();\\n        m = nums.size();\\n        for(auto &e : groups) for(auto &ee : e) ee += offset;\\n        for(auto &e : nums) e += offset;\\n        bool ans = help(groups, nums, 0, 0);\\n        return ans;\\n    }\\n    \\n    bool help(vector<vector<int>>& a, vector<int>& b, int pos1, int pos2){\\n        if(pos1 == n) return true;\\n        if(pos2 == m) return false;\\n        int len = a[pos1].size();\\n        if(m-pos2 < len) return false;\\n        \\n        ll originalHash = 0;\\n        for(int i = 0 ; i < len; i++) originalHash = (originalHash*base + (a[pos1][i])) % mod;\\n        \\n        int i = pos2;\\n        int firstStop = pos2 + len;\\n        ll hash = 0;\\n        ll temp = 1;\\n        while(pos2 < firstStop){\\n            hash = (hash * base + b[pos2]) % mod;\\n            temp = temp * base % mod;\\n            pos2++;\\n        }\\n        \\n        if(hash == originalHash && checkEqual(a[pos1], b, 0, pos2-len, len)) return help(a, b, pos1+1, pos2);\\n        \\n        for(; pos2 < m; pos2++){\\n            hash = ((hash * base + b[pos2]) - (temp * b[pos2-len])) % mod;\\n            if(hash < 0) hash += mod;\\n            if(hash == originalHash && checkEqual(a[pos1], b, 0, pos2-len+1, len)) return help(a, b, pos1+1, pos2+1);\\n        }\\n        return false;\\n    }\\n    \\n    bool checkEqual(vector<int> &a, vector<int> &b, int pos1, int pos2, int len){\\n        for(int i = 0 ; i < len; i++) if(a[pos1+i] != b[pos2+i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Rolling Hash"
                ],
                "code": "```\\ntypedef long long ll;\\nll mod = 1e9+7;\\nll base = 101;\\nll offset = 1e7+1;\\nclass Solution {\\npublic:\\n    int n, m;\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        n = groups.size();\\n        m = nums.size();\\n        for(auto &e : groups) for(auto &ee : e) ee += offset;\\n        for(auto &e : nums) e += offset;\\n        bool ans = help(groups, nums, 0, 0);\\n        return ans;\\n    }\\n    \\n    bool help(vector<vector<int>>& a, vector<int>& b, int pos1, int pos2){\\n        if(pos1 == n) return true;\\n        if(pos2 == m) return false;\\n        int len = a[pos1].size();\\n        if(m-pos2 < len) return false;\\n        \\n        ll originalHash = 0;\\n        for(int i = 0 ; i < len; i++) originalHash = (originalHash*base + (a[pos1][i])) % mod;\\n        \\n        int i = pos2;\\n        int firstStop = pos2 + len;\\n        ll hash = 0;\\n        ll temp = 1;\\n        while(pos2 < firstStop){\\n            hash = (hash * base + b[pos2]) % mod;\\n            temp = temp * base % mod;\\n            pos2++;\\n        }\\n        \\n        if(hash == originalHash && checkEqual(a[pos1], b, 0, pos2-len, len)) return help(a, b, pos1+1, pos2);\\n        \\n        for(; pos2 < m; pos2++){\\n            hash = ((hash * base + b[pos2]) - (temp * b[pos2-len])) % mod;\\n            if(hash < 0) hash += mod;\\n            if(hash == originalHash && checkEqual(a[pos1], b, 0, pos2-len+1, len)) return help(a, b, pos1+1, pos2+1);\\n        }\\n        return false;\\n    }\\n    \\n    bool checkEqual(vector<int> &a, vector<int> &b, int pos1, int pos2, int len){\\n        for(int i = 0 ; i < len; i++) if(a[pos1+i] != b[pos2+i]) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359621,
                "title": "java-straightforward-brute-force-solution-stupid-but-simple",
                "content": "I try to avoid any\\xA0fancy algorithms as long as they are not necessary. As an engineer, my principle is getting things done first, then seek perfection. If you are a practical person like me, please check this stupid but simple solution.\\xA0\\n\\nFYI, there are no comments in the code because good codes document themselves.\\xA0\\xA0\\n\\n```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        List<String> strs = new LinkedList<>();\\n        for (int[] group : groups) {\\n            StringBuffer bu = new StringBuffer();\\n            for (int num : group) {\\n                bu.append(\"[\");\\n                bu.append(num);\\n                bu.append(\"]\");\\n            }\\n            strs.add(bu.toString());\\n        }\\n\\t\\t\\n        StringBuffer bu = new StringBuffer();\\n        for (int num : nums) {\\n            bu.append(\"[\");\\n            bu.append(num);\\n            bu.append(\"]\");\\n        }\\n        String numStr = bu.toString();\\n\\t\\t\\n        int idx = 0;\\n        for (String str : strs) {\\n            int startIdx = numStr.indexOf(str, idx);\\n            if (startIdx < 0) {\\n                return false;\\n            }\\n            idx = startIdx + str.length();\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        List<String> strs = new LinkedList<>();\\n        for (int[] group : groups) {\\n            StringBuffer bu = new StringBuffer();\\n            for (int num : group) {\\n                bu.append(\"[\");\\n                bu.append(num);\\n                bu.append(\"]\");\\n            }\\n            strs.add(bu.toString());\\n        }\\n\\t\\t\\n        StringBuffer bu = new StringBuffer();\\n        for (int num : nums) {\\n            bu.append(\"[\");\\n            bu.append(num);\\n            bu.append(\"]\");\\n        }\\n        String numStr = bu.toString();\\n\\t\\t\\n        int idx = 0;\\n        for (String str : strs) {\\n            int startIdx = numStr.indexOf(str, idx);\\n            if (startIdx < 0) {\\n                return false;\\n            }\\n            idx = startIdx + str.length();\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357818,
                "title": "c-question-solution-using-kmp",
                "content": "class Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i=0;\\n        for(int k=0;k<groups.size();k++){\\n            vector<int> pat=groups[k];\\n            // for(int i=0;i<pat.size();i++){\\n            //     cout<<pat[i];\\n            // }\\n            cout<<i;\\n            i=findMatchingIndex(nums,pat,i);\\n            if(i==-1) return false;\\n            if(i==nums.size() && k<groups.size()-1){\\n                return false;\\n            }\\n        }\\n        return true;\\n        \\n    }\\n    void createlps(int lps[],vector<int> arr,int m){\\n        // cout<<\"this is working\";\\n        int i=1;\\n        int j=0;\\n        // cout<<\"this is working\";\\n        lps[0]=0;\\n        // cout<<\"this is working\";\\n        while(i<arr.size()){\\n            // cout<<\"this is working\";\\n            if(arr[i]==arr[j]){\\n                j++;\\n                lps[i]=j;\\n                i++;\\n            }\\n           \\n            else{\\n                if(j!=0){\\n                    j=lps[j-1];\\n                }\\n                else{\\n                    lps[i]=0;\\n                    i++;\\n                }\\n            }\\n            // cout<<\"inside loop\";\\n        }\\n        // cout<<\"end of making lps\";\\n    }\\n    int findMatchingIndex(vector<int> nums,vector<int> pat,int i){\\n        // cout<<\"this is working\";\\n        int m=pat.size();\\n        int lps[m];\\n        createlps(lps,pat,m);\\n        for(int i=0;i<m;i++){\\n            cout<<lps[i];\\n        }\\n        // cout<<\"after creating lps\";\\n        \\n        int j=0;\\n        \\n        while(i<nums.size()){\\n            if(nums[i]==pat[j]){\\n                i++;\\n                j++;\\n            }\\n            if(j==pat.size()){\\n                // cout<<\"return i worked\";\\n                // if(i==nums.size()){\\n                //     return -1;\\n                // }\\n                return i;\\n            }\\n            else if(i<nums.size() && nums[i]!=pat[j]){\\n                if(j!=0){\\n                    j=lps[j-1];\\n                }\\n                else{\\n                    i++;\\n                }\\n            }\\n            if(i==nums.size()) return -1;\\n            // cout<<\"matching loop\";\\n        }\\n        return i;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i=0;\\n        for(int k=0;k<groups.size();k++){\\n            vector<int> pat=groups[k];\\n            // for(int i=0;i<pat.size();i++){\\n            //     cout<<pat[i];\\n            // }",
                "codeTag": "C++"
            },
            {
                "id": 1343506,
                "title": "c-easy-solution-using-recursion",
                "content": "* **Backtracking Solution :**\\n-> We have to check all the possible subarray and recursively call for the next array in the matrix Groups\\n```\\nclass Solution {\\npublic:\\n    bool isSafe(int i,int j,vector<vector<int>>&groups,vector<int>&nums)\\n    {\\n        int k=0;\\n        while(k<groups[i].size() && j<nums.size())\\n        {\\n            if(groups[i][k]!=nums[j]) return false;\\n            k++;\\n            j++;\\n        }\\n        if(k==groups[i].size()) return true;\\n        return false;\\n    }\\n    bool solve(int i,int j,vector<vector<int>>&groups,vector<int>&nums)\\n    {\\n        if(i==size(groups)) return true;\\n        for(int k=j;k<size(nums);k++)\\n        {\\n            if(nums[k]==groups[i][0])\\n            {\\n                if(isSafe(i,k,groups,nums)) \\n                {\\n                    if(solve(i+1,k+groups[i].size(),groups,nums)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) \\n    {\\n        return solve(0,0,groups,nums);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(int i,int j,vector<vector<int>>&groups,vector<int>&nums)\\n    {\\n        int k=0;\\n        while(k<groups[i].size() && j<nums.size())\\n        {\\n            if(groups[i][k]!=nums[j]) return false;\\n            k++;\\n            j++;\\n        }\\n        if(k==groups[i].size()) return true;\\n        return false;\\n    }\\n    bool solve(int i,int j,vector<vector<int>>&groups,vector<int>&nums)\\n    {\\n        if(i==size(groups)) return true;\\n        for(int k=j;k<size(nums);k++)\\n        {\\n            if(nums[k]==groups[i][0])\\n            {\\n                if(isSafe(i,k,groups,nums)) \\n                {\\n                    if(solve(i+1,k+groups[i].size(),groups,nums)) return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) \\n    {\\n        return solve(0,0,groups,nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337913,
                "title": "one-pass-with-stack-95-speed",
                "content": "Runtime: 76 ms, faster than 95.16%\\nMemory Usage: 14.4 MB, less than 89.25%\\n```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        len_groups = len(groups)\\n        idx_group = 0\\n        len_group = len(groups[idx_group])\\n        stack = []\\n        for n in nums:\\n            stack.append(n)\\n            if (len(stack) >= len_group and\\n                    stack[-len_group:] == groups[idx_group]):\\n                stack = []\\n                idx_group += 1\\n                if idx_group < len_groups:\\n                    len_group = len(groups[idx_group])\\n                else:\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        len_groups = len(groups)\\n        idx_group = 0\\n        len_group = len(groups[idx_group])\\n        stack = []\\n        for n in nums:\\n            stack.append(n)\\n            if (len(stack) >= len_group and\\n                    stack[-len_group:] == groups[idx_group]):\\n                stack = []\\n                idx_group += 1\\n                if idx_group < len_groups:\\n                    len_group = len(groups[idx_group])\\n                else:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319294,
                "title": "c-kmp-solution-90-faster",
                "content": "Time Complexity: O(n+m) where n is size of nums and m is sum of sizes of vectors of groups\\n```\\nclass Solution {\\npublic:\\n    \\n    void kmparray(vector<int>&sam, vector<int>&v1)\\n    {\\n        int i=1;int j=0;\\n        while(i<sam.size())\\n        {\\n            if(sam[i]==sam[j])\\n            {\\n                v1[i]=j+1;\\n                j++;\\n                i++;\\n            }\\n            else\\n            {\\n                if(j!=0)\\n                    j=v1[j-1];\\n                else\\n                {\\n                    v1[i]=0;\\n                    i++;\\n                }   \\n            } \\n        }\\n    }\\n    \\n    \\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int k=0;\\nbool kmp=true;\\n        for(int i=0;i<groups.size();i++)\\n        {\\n            vector<int>v1(groups[i].size(),0);\\n\\t\\t\\t\\n\\t\\t\\t// build kmp array of each vector in groups for faster substring search \\n            kmparray(groups[i],v1);\\n             int j=0;\\n            \\n            while(j<v1.size()&&k<nums.size())\\n            {\\n                //cout<<k<<j<<\" \";\\n                if(groups[i][j]==nums[k])\\n                {\\n                    j++;\\n                    k++;\\n                }\\n                else\\n                {\\n                    if(j>0)\\n                    {\\n                        j=v1[j-1];\\n                    }\\n                    else\\n                        k++;\\n                    \\n                }\\n            }\\n            if(j!=v1.size())\\n                kmp=false;\\n            \\n            \\n        }\\n        \\n        return kmp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void kmparray(vector<int>&sam, vector<int>&v1)\\n    {\\n        int i=1;int j=0;\\n        while(i<sam.size())\\n        {\\n            if(sam[i]==sam[j])\\n            {\\n                v1[i]=j+1;\\n                j++;\\n                i++;\\n            }\\n            else\\n            {\\n                if(j!=0)\\n                    j=v1[j-1];\\n                else\\n                {\\n                    v1[i]=0;\\n                    i++;\\n                }   \\n            } \\n        }\\n    }\\n    \\n    \\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int k=0;\\nbool kmp=true;\\n        for(int i=0;i<groups.size();i++)\\n        {\\n            vector<int>v1(groups[i].size(),0);\\n\\t\\t\\t\\n\\t\\t\\t// build kmp array of each vector in groups for faster substring search \\n            kmparray(groups[i],v1);\\n             int j=0;\\n            \\n            while(j<v1.size()&&k<nums.size())\\n            {\\n                //cout<<k<<j<<\" \";\\n                if(groups[i][j]==nums[k])\\n                {\\n                    j++;\\n                    k++;\\n                }\\n                else\\n                {\\n                    if(j>0)\\n                    {\\n                        j=v1[j-1];\\n                    }\\n                    else\\n                        k++;\\n                    \\n                }\\n            }\\n            if(j!=v1.size())\\n                kmp=false;\\n            \\n            \\n        }\\n        \\n        return kmp;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1315157,
                "title": "simple-and-concise-c-99-faster-o-n-max-nums-size-group-0-size-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int findSubArray(vector<int>& toFind, vector<int>& nums, int pos)\\n    {\\n        //should start search from index pos\\n        int m = toFind.size();\\n        \\n        while(pos+m-1 < nums.size())\\n        {\\n        bool found = false;\\n        for(int i = pos; i < pos+m && i < nums.size(); i++)\\n        {\\n           if(nums[i] != toFind[i-pos]) \\n           {\\n               break; \\n           }\\n            if(i==pos+m-1) found = true;\\n        }\\n        if(found) return pos+m;\\n        pos++;\\n        } \\n        return -1; //subarray not found\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        int pos = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            pos = findSubArray(groups[i],nums,pos);\\n            if(pos==-1) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findSubArray(vector<int>& toFind, vector<int>& nums, int pos)\\n    {\\n        //should start search from index pos\\n        int m = toFind.size();\\n        \\n        while(pos+m-1 < nums.size())\\n        {\\n        bool found = false;\\n        for(int i = pos; i < pos+m && i < nums.size(); i++)\\n        {\\n           if(nums[i] != toFind[i-pos]) \\n           {\\n               break; \\n           }\\n            if(i==pos+m-1) found = true;\\n        }\\n        if(found) return pos+m;\\n        pos++;\\n        } \\n        return -1; //subarray not found\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        int pos = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            pos = findSubArray(groups[i],nums,pos);\\n            if(pos==-1) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313703,
                "title": "typescript-fast-strings-matching",
                "content": "84ms - The solution relies on string matching and the current matching group pointer\\n\\n```\\nfunction canChoose(groups: number[][], nums: number[]): boolean {\\n    const grs = groups.map(gr => \\',\\' + gr.join(\\',\\'))\\n    const n = \\',\\' + nums.join(\\',\\')\\n    let fromIndex = -1\\n    \\n    for (let g of grs) {\\n        const grIndex = n.indexOf(g, fromIndex)\\n        if (grIndex > -1) {\\n            fromIndex = grIndex + g.length\\n        } else {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nfunction canChoose(groups: number[][], nums: number[]): boolean {\\n    const grs = groups.map(gr => \\',\\' + gr.join(\\',\\'))\\n    const n = \\',\\' + nums.join(\\',\\')\\n    let fromIndex = -1\\n    \\n    for (let g of grs) {\\n        const grIndex = n.indexOf(g, fromIndex)\\n        if (grIndex > -1) {\\n            fromIndex = grIndex + g.length\\n        } else {\\n            return false\\n        }\\n    }\\n    \\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1287265,
                "title": "c-100-faster",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int ans=false;\\n        int low=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(low>=groups.size())\\n            {\\n                ans=true;\\n                break ;\\n            }\\n            if(nums[i]==groups[low][0])\\n            {\\n                int l=i,r=0;\\n                bool temp=true;\\n                for(;r<groups[low].size();r++)\\n                {\\n                    // cout<<i<<\" \";\\n                    if(l>=nums.size())\\n                    {\\n                        temp=false;\\n                        break ;\\n                    }\\n                    if(nums[l]!=groups[low][r])\\n                    {\\n                        // cout<<\"!\";\\n                        temp=false;\\n                        break ;\\n                    }\\n                    l++;\\n                }\\n                if(temp)\\n                {\\n                    i=l-1;\\n                    low++;\\n                }\\n            }\\n        }\\n        if(low>=groups.size())\\n        {\\n            ans=true;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int ans=false;\\n        int low=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(low>=groups.size())\\n            {\\n                ans=true;\\n                break ;\\n            }\\n            if(nums[i]==groups[low][0])\\n            {\\n                int l=i,r=0;\\n                bool temp=true;\\n                for(;r<groups[low].size();r++)\\n                {\\n                    // cout<<i<<\" \";\\n                    if(l>=nums.size())\\n                    {\\n                        temp=false;\\n                        break ;\\n                    }\\n                    if(nums[l]!=groups[low][r])\\n                    {\\n                        // cout<<\"!\";\\n                        temp=false;\\n                        break ;\\n                    }\\n                    l++;\\n                }\\n                if(temp)\\n                {\\n                    i=l-1;\\n                    low++;\\n                }\\n            }\\n        }\\n        if(low>=groups.size())\\n        {\\n            ans=true;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1248104,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int curr = 0;\\n        int i = 0;\\n        while(i < nums.length){\\n            if(nums[i] == groups[curr][0] && nums.length - i >= groups[curr].length){\\n                if(helper(nums, groups[curr], i)){\\n                    i += groups[curr].length;\\n                    curr++;\\n                    if(curr == groups.length){\\n                        break;\\n                    }\\n                    continue;\\n                }\\n            }\\n            i++;\\n        }\\n        return curr == groups.length; \\n    }\\n    \\n    private boolean helper(int[] nums, int[] arr, int index){\\n        for(int i = 0; i < arr.length; i++){\\n            if(index < nums.length && arr[i] == nums[index]){\\n                index++;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int curr = 0;\\n        int i = 0;\\n        while(i < nums.length){\\n            if(nums[i] == groups[curr][0] && nums.length - i >= groups[curr].length){\\n                if(helper(nums, groups[curr], i)){\\n                    i += groups[curr].length;\\n                    curr++;\\n                    if(curr == groups.length){\\n                        break;\\n                    }\\n                    continue;\\n                }\\n            }\\n            i++;\\n        }\\n        return curr == groups.length; \\n    }\\n    \\n    private boolean helper(int[] nums, int[] arr, int index){\\n        for(int i = 0; i < arr.length; i++){\\n            if(index < nums.length && arr[i] == nums[index]){\\n                index++;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243759,
                "title": "javascript-understandable-solution-92-ms",
                "content": "```\\nvar canChoose = function (groups, nums) {\\n    let j = 0, k = 0;\\n    let group = groups[k];\\n    for (let i = 0; i < nums.length && j < nums.length; i++) {\\n        j = i + group.length;\\n        let isFound = true;\\n        for (let n = 0; n < group.length; n++) {\\n            if (nums[i + n] !== group[n]) {\\n                isFound = false;\\n                break;\\n            }\\n\\n        }\\n        if (isFound) {\\n            k++;\\n            if (k < groups.length) {\\n                i = j - 1;\\n                group = groups[k];\\n            }\\n            else {\\n                return true;\\n            }\\n\\n        }\\n    }\\n    return false;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar canChoose = function (groups, nums) {\\n    let j = 0, k = 0;\\n    let group = groups[k];\\n    for (let i = 0; i < nums.length && j < nums.length; i++) {\\n        j = i + group.length;\\n        let isFound = true;\\n        for (let n = 0; n < group.length; n++) {\\n            if (nums[i + n] !== group[n]) {\\n                isFound = false;\\n                break;\\n            }\\n\\n        }\\n        if (isFound) {\\n            k++;\\n            if (k < groups.length) {\\n                i = j - 1;\\n                group = groups[k];\\n            }\\n            else {\\n                return true;\\n            }\\n\\n        }\\n    }\\n    return false;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1230301,
                "title": "python3-easy-code-beating-96-of-submissions",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        start_index = 0\\n        for group in groups:\\n            lenGroup = len(group)\\n            flag = False\\n            for i in range(start_index, len(nums)-lenGroup+1):\\n                if nums[i:i+lenGroup]==group:\\n                    start_index = i+lenGroup\\n                    flag = True\\n                    break\\n            \\n            if flag == False:\\n                return False\\n        return True\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        start_index = 0\\n        for group in groups:\\n            lenGroup = len(group)\\n            flag = False\\n            for i in range(start_index, len(nums)-lenGroup+1):\\n                if nums[i:i+lenGroup]==group:\\n                    start_index = i+lenGroup\\n                    flag = True\\n                    break\\n            \\n            if flag == False:\\n                return False\\n        return True\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230184,
                "title": "easy-understanable-js-code",
                "content": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function (groups, nums) {\\n    let subArray = groups.shift()\\n    let returnValue = false\\n    for (let i=0; i<nums.length; i++) {\\n        if(subArray[0] == nums[i]) {\\n            // console.log(subArray);\\n            if(checkExists(subArray, nums.slice(i, i+subArray.length))){\\n                i = i + subArray.length - 1\\n                returnValue = true\\n                if(groups[0]){\\n                    subArray = groups.shift()\\n                    returnValue = false\\n                }\\n            }\\n        }\\n    }\\n    return returnValue\\n}\\n\\nvar checkExists = function (list1, list2) {\\n    if (list2.length != list1.length) return false\\n    for (let i = 0; i < list2.length; i++) {\\n        if (list1[i] == list2[i]) {\\n            continue\\n        }\\n        return false\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function (groups, nums) {\\n    let subArray = groups.shift()\\n    let returnValue = false\\n    for (let i=0; i<nums.length; i++) {\\n        if(subArray[0] == nums[i]) {\\n            // console.log(subArray);\\n            if(checkExists(subArray, nums.slice(i, i+subArray.length))){\\n                i = i + subArray.length - 1\\n                returnValue = true\\n                if(groups[0]){\\n                    subArray = groups.shift()\\n                    returnValue = false\\n                }\\n            }\\n        }\\n    }\\n    return returnValue\\n}\\n\\nvar checkExists = function (list1, list2) {\\n    if (list2.length != list1.length) return false\\n    for (let i = 0; i < list2.length; i++) {\\n        if (list1[i] == list2[i]) {\\n            continue\\n        }\\n        return false\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1218853,
                "title": "c-easy-solution-strings",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        string kk;\\n        kk.push_back(\\',\\');\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            kk.append(to_string(nums[i]));\\n            kk.push_back(\\',\\');\\n        }\\n        kk.pop_back();\\n        int ll=0;\\n        int n=kk.size();\\n        for(int i=0;i<groups.size();i++)\\n        {\\n            string gg;\\n            gg.push_back(\\',\\');\\n            for(int j=0;j<groups[i].size();j++)\\n            {\\n                gg.append(to_string(groups[i][j]));\\n                gg.push_back(\\',\\');\\n            }\\n            gg.pop_back();\\n            ll=kk.find(gg,ll);\\n            if(ll!=-1)\\n            {\\n                ll+=gg.size();\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        string kk;\\n        kk.push_back(\\',\\');\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            kk.append(to_string(nums[i]));\\n            kk.push_back(\\',\\');\\n        }\\n        kk.pop_back();\\n        int ll=0;\\n        int n=kk.size();\\n        for(int i=0;i<groups.size();i++)\\n        {\\n            string gg;\\n            gg.push_back(\\',\\');\\n            for(int j=0;j<groups[i].size();j++)\\n            {\\n                gg.append(to_string(groups[i][j]));\\n                gg.push_back(\\',\\');\\n            }\\n            gg.pop_back();\\n            ll=kk.find(gg,ll);\\n            if(ll!=-1)\\n            {\\n                ll+=gg.size();\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187713,
                "title": "java-0ms",
                "content": "class Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int len = nums.length;\\n        int c = groups.length;//number of rows \\n        int a = 0;//counter to row array \\n        int[] t = groups[a];//extract a particular subarray belong to a particular row \\n        int l = t.length;//length of that subarray \\n        for (int i = 0; i < len; i++)//traversing nums \\n        {\\n            if (nums[i] == t[0] && i + l <= len) //checing the starting of subarray && boundary check \\n            {\\n                int scan = 0;//scan with respect to that particular index \\n                while(scan < l && nums[i+scan] == t[scan])//comaring nusns array and particular subarray \\n                       scan++; //moving scan \\n                if (scan == l) \\n                {\\n                    if (++a == c) //if all rows of 2D marix are checked and all are true \\n                        return true; \\n                    t = groups[a];//moving too nex subarray of 2d matrix \\n                    l = t.length;//changing the subarray length\\n                    i += scan - 1;//checking in next half after that scanning //changing the index of i//no intersecction in subarray possible  \\n                }\\n            }\\n        }\\n        return false;//else returning false subarray no present \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) \\n    {\\n        int len = nums.length;\\n        int c = groups.length;//number of rows \\n        int a = 0;//counter to row array \\n        int[] t = groups[a];//extract a particular subarray belong to a particular row \\n        int l = t.length;//length of that subarray \\n        for (int i = 0; i < len; i++)//traversing nums \\n        {\\n            if (nums[i] == t[0] && i + l <= len) //checing the starting of subarray && boundary check \\n            {\\n                int scan = 0;//scan with respect to that particular index \\n                while(scan < l && nums[i+scan] == t[scan])//comaring nusns array and particular subarray \\n                       scan++; //moving scan \\n                if (scan == l) \\n                {\\n                    if (++a == c) //if all rows of 2D marix are checked and all are true \\n                        return true; \\n                    t = groups[a];//moving too nex subarray of 2d matrix \\n                    l = t.length;//changing the subarray length\\n                    i += scan - 1;//checking in next half after that scanning //changing the index of i//no intersecction in subarray possible  \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1185127,
                "title": "javascript-array-match-solution",
                "content": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function(groups, nums) {\\n    let numsIndex = 0, groupsIndex = 0\\n    const numsLen = nums.length, groupsLen = groups.length\\n    \\n    forEachNumsIndex:\\n    while (numsIndex < numsLen && groupsIndex < groupsLen) {\\n        const group = groups[groupsIndex]\\n        const groupLen = group.length\\n        if (numsIndex + groupLen > numsLen)\\n            return false\\n        \\n        // i is the offset within group\\n        for (let i = 0; i < groupLen; i++) {\\n            const numsVal = nums[i + numsIndex]\\n            const groupVal = group[i]\\n            if (numsVal !== groupVal) {\\n                numsIndex++\\n                continue forEachNumsIndex\\n            }\\n        }\\n        \\n        // it matches\\n        numsIndex += groupLen\\n        groupsIndex++\\n    }\\n    if (groupsIndex < groupsLen)    return false\\n    \\n    \\n    return true\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function(groups, nums) {\\n    let numsIndex = 0, groupsIndex = 0\\n    const numsLen = nums.length, groupsLen = groups.length\\n    \\n    forEachNumsIndex:\\n    while (numsIndex < numsLen && groupsIndex < groupsLen) {\\n        const group = groups[groupsIndex]\\n        const groupLen = group.length\\n        if (numsIndex + groupLen > numsLen)\\n            return false\\n        \\n        // i is the offset within group\\n        for (let i = 0; i < groupLen; i++) {\\n            const numsVal = nums[i + numsIndex]\\n            const groupVal = group[i]\\n            if (numsVal !== groupVal) {\\n                numsIndex++\\n                continue forEachNumsIndex\\n            }\\n        }\\n        \\n        // it matches\\n        numsIndex += groupLen\\n        groupsIndex++\\n    }\\n    if (groupsIndex < groupsLen)    return false\\n    \\n    \\n    return true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1181108,
                "title": "c-java-simple-solution-visual-explanation",
                "content": "This is my first \"article\" on Leetcode, so just bear with me...\\n\\nIt\\'s a simple solution that is based on two loops. One follows the elements of the nums array, and the other follows the elements of the group array.\\n\\nSimple visualization:\\n\\n![image](https://assets.leetcode.com/users/images/2535bd77-75ef-4323-9187-ede05468c950_1619635837.095462.png)\\n\\n![image](https://assets.leetcode.com/users/images/811fcd81-bf44-4436-83ce-6925876c6877_1619635974.4187915.png)\\n\\n\\nC++ (old school)\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int group_id = 0;\\n        \\n        //We are going through nums \\n        for (int index_in_nums = 0; index_in_nums < nums.size(); ++index_in_nums) {\\n            int index_in_nums_local = index_in_nums;\\n            int index_in_group = 0;\\n            \\n            //We are going through group\\n            while (index_in_nums_local < nums.size() &&\\n                   groups[group_id][index_in_group] == nums[index_in_nums_local]) {\\n                \\n                if (index_in_group == groups[group_id].size()-1) { //We have reached last element in group\\n                    if (group_id == groups.size() - 1) return true; //We analyzed the last group, so we are done\\n                    ++group_id;\\n                    index_in_nums = index_in_nums_local; //We\\'re updating index_in_nums so that the top loop knows where we are. :)\\n                    break;\\n                }\\n\\n                ++index_in_nums_local;\\n                ++index_in_group;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\nJava (so common)\\n```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int group_id = 0;\\n        \\n        //We are going through nums \\n        for (int index_in_nums = 0; index_in_nums < nums.length; ++index_in_nums) {\\n            int index_in_nums_local = index_in_nums;\\n            int index_in_group = 0;\\n            \\n            //We are going through group\\n            while (index_in_nums_local < nums.length &&\\n                   groups[group_id][index_in_group] == nums[index_in_nums_local]) {\\n                \\n                if (index_in_group == groups[group_id].length-1) { //We have reached last element in group\\n                    if (group_id == groups.length - 1) return true; //We analyzed the last group, so we are done\\n                    ++group_id;\\n                    index_in_nums = index_in_nums_local; //We\\'re updating index_in_nums so that the top loop knows where we are. :)\\n                    break;\\n                }\\n\\n                ++index_in_nums_local;\\n                ++index_in_group;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n\\nPython:\\n```\\n# I don\\'t know Python :)\\n```\\n\\n\\n\"n\" and \"k\" are used in the description, so:\\nm - nums.length,\\nd - the number of elements in groups.\\nTime complexity: O(m*d)\\nSpace complexity: O(1)\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int group_id = 0;\\n        \\n        //We are going through nums \\n        for (int index_in_nums = 0; index_in_nums < nums.size(); ++index_in_nums) {\\n            int index_in_nums_local = index_in_nums;\\n            int index_in_group = 0;\\n            \\n            //We are going through group\\n            while (index_in_nums_local < nums.size() &&\\n                   groups[group_id][index_in_group] == nums[index_in_nums_local]) {\\n                \\n                if (index_in_group == groups[group_id].size()-1) { //We have reached last element in group\\n                    if (group_id == groups.size() - 1) return true; //We analyzed the last group, so we are done\\n                    ++group_id;\\n                    index_in_nums = index_in_nums_local; //We\\'re updating index_in_nums so that the top loop knows where we are. :)\\n                    break;\\n                }\\n\\n                ++index_in_nums_local;\\n                ++index_in_group;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        int group_id = 0;\\n        \\n        //We are going through nums \\n        for (int index_in_nums = 0; index_in_nums < nums.length; ++index_in_nums) {\\n            int index_in_nums_local = index_in_nums;\\n            int index_in_group = 0;\\n            \\n            //We are going through group\\n            while (index_in_nums_local < nums.length &&\\n                   groups[group_id][index_in_group] == nums[index_in_nums_local]) {\\n                \\n                if (index_in_group == groups[group_id].length-1) { //We have reached last element in group\\n                    if (group_id == groups.length - 1) return true; //We analyzed the last group, so we are done\\n                    ++group_id;\\n                    index_in_nums = index_in_nums_local; //We\\'re updating index_in_nums so that the top loop knows where we are. :)\\n                    break;\\n                }\\n\\n                ++index_in_nums_local;\\n                ++index_in_group;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\n```\\n# I don\\'t know Python :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150888,
                "title": "javascript-kmp",
                "content": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function (groups, nums) {\\n  const patterns = [];\\n  for (const group of groups) {\\n    patterns.push(buildPattern(group));\\n  }\\n\\n  let i = 0; // groups\\n  let j = 0; // groups[i]\\n  let k = 0; // nums\\n\\n  while (i < groups.length) {\\n    const currGroup = groups[i];\\n    const currPattern = patterns[i];\\n\\n    while (j < currGroup.length && k < nums.length) {\\n      if (currGroup[j] === nums[k]) {\\n        j++;\\n        k++;\\n      } else if (j > 0) {\\n        j = currPattern[j - 1] + 1;\\n      } else {\\n        k++;\\n      }\\n    }\\n\\n    if (j < currGroup.length) return false;\\n\\n    // move to next group\\n    i++;\\n    j = 0;\\n  }\\n\\n  return i === groups.length;\\n};\\n\\nfunction buildPattern(group) {\\n  let j = 0;\\n  let i = 1;\\n\\n  const pattern = new Array(group.length).fill(-1);\\n  while (i < group.length) {\\n    if (group[j] === group[i]) {\\n      pattern[i] = j;\\n      j++;\\n      i++;\\n    } else if (j > 0) {\\n      j = pattern[j - 1] + 1;\\n    } else {\\n      i++;\\n    }\\n  }\\n\\n  return pattern;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} groups\\n * @param {number[]} nums\\n * @return {boolean}\\n */\\nvar canChoose = function (groups, nums) {\\n  const patterns = [];\\n  for (const group of groups) {\\n    patterns.push(buildPattern(group));\\n  }\\n\\n  let i = 0; // groups\\n  let j = 0; // groups[i]\\n  let k = 0; // nums\\n\\n  while (i < groups.length) {\\n    const currGroup = groups[i];\\n    const currPattern = patterns[i];\\n\\n    while (j < currGroup.length && k < nums.length) {\\n      if (currGroup[j] === nums[k]) {\\n        j++;\\n        k++;\\n      } else if (j > 0) {\\n        j = currPattern[j - 1] + 1;\\n      } else {\\n        k++;\\n      }\\n    }\\n\\n    if (j < currGroup.length) return false;\\n\\n    // move to next group\\n    i++;\\n    j = 0;\\n  }\\n\\n  return i === groups.length;\\n};\\n\\nfunction buildPattern(group) {\\n  let j = 0;\\n  let i = 1;\\n\\n  const pattern = new Array(group.length).fill(-1);\\n  while (i < group.length) {\\n    if (group[j] === group[i]) {\\n      pattern[i] = j;\\n      j++;\\n      i++;\\n    } else if (j > 0) {\\n      j = pattern[j - 1] + 1;\\n    } else {\\n      i++;\\n    }\\n  }\\n\\n  return pattern;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1146921,
                "title": "java-sliding-window-solution-runtime-1ms",
                "content": "I think that this solution is easy to understand \\n\\n```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n        int groupStart = 0;\\n        boolean answer = true;\\n        \\n        for (int i = 0; i < groups.length; i++) {\\n            \\n            int[] group = groups[i];\\n            boolean matchFound = false;\\n            \\n            // sliding window of group in nums\\n            \\n            for (int j = groupStart; j < nums.length-group.length+1; j++) {\\n                \\n                int[] tempArr = Arrays.copyOfRange(nums,j,j+group.length);\\n                \\n                if (Arrays.equals(tempArr,group)) {\\n                    groupStart = j + tempArr.length;\\n                    matchFound = true;\\n                    break;\\n                }\\n                \\n            }\\n            \\n            if (!matchFound) {\\n                answer = false;\\n                break;\\n            }\\n            \\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n        int groupStart = 0;\\n        boolean answer = true;\\n        \\n        for (int i = 0; i < groups.length; i++) {\\n            \\n            int[] group = groups[i];\\n            boolean matchFound = false;\\n            \\n            // sliding window of group in nums\\n            \\n            for (int j = groupStart; j < nums.length-group.length+1; j++) {\\n                \\n                int[] tempArr = Arrays.copyOfRange(nums,j,j+group.length);\\n                \\n                if (Arrays.equals(tempArr,group)) {\\n                    groupStart = j + tempArr.length;\\n                    matchFound = true;\\n                    break;\\n                }\\n                \\n            }\\n            \\n            if (!matchFound) {\\n                answer = false;\\n                break;\\n            }\\n            \\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138198,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int gx = 0; //group index\\n        int nx =0;   //nums index\\n        return solve(groups,nums,gx,nx);\\n    }\\n    \\n    bool solve(vector<vector<int>>& groups, vector<int>& nums,int gx, int nx){\\n         if(gx== groups.size())\\n             return true;\\n         vector<int>g=groups[gx];\\n         int i =nx;\\n         while(i<nums.size())\\n         {\\n             for(int j=0;j<g.size();j++)\\n             {\\n                 if(g[j]!=nums[i++])\\n                 {\\n                     if(j!=0)\\n                         i--;\\n                     break;\\n                 }\\n                  if(j==g.size()-1 && solve(groups,nums,gx+1,i)==true)\\n                  {\\n                      return true;\\n                  }     \\n             }\\n         }\\n         return false;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int gx = 0; //group index\\n        int nx =0;   //nums index\\n        return solve(groups,nums,gx,nx);\\n    }\\n    \\n    bool solve(vector<vector<int>>& groups, vector<int>& nums,int gx, int nx){\\n         if(gx== groups.size())\\n             return true;\\n         vector<int>g=groups[gx];\\n         int i =nx;\\n         while(i<nums.size())\\n         {\\n             for(int j=0;j<g.size();j++)\\n             {\\n                 if(g[j]!=nums[i++])\\n                 {\\n                     if(j!=0)\\n                         i--;\\n                     break;\\n                 }\\n                  if(j==g.size()-1 && solve(groups,nums,gx+1,i)==true)\\n                  {\\n                      return true;\\n                  }     \\n             }\\n         }\\n         return false;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135910,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int size = groups.size();\\n        int x=0,i=0;\\n        while(x<size && i<nums.size()){\\n            if(groups[x][0]==nums[i]){\\n                int j=1; int k=++i;\\n                for( j=1; j<groups[x].size(); j++,k++){\\n                    if(groups[x][j]!=nums[k]) break;\\n                }\\n                if(j==groups[x].size()){\\n                    x++;\\n                    i=k;\\n                }\\n            } else i++;\\n        }\\n        if(x==size) return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int size = groups.size();\\n        int x=0,i=0;\\n        while(x<size && i<nums.size()){\\n            if(groups[x][0]==nums[i]){\\n                int j=1; int k=++i;\\n                for( j=1; j<groups[x].size(); j++,k++){\\n                    if(groups[x][j]!=nums[k]) break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1129504,
                "title": "naive-and-kmp-solution-c-cpp",
                "content": "1. Below is Naive approch \\nTime Complexity: **O(m * n)** \\n\\n```\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        int numslen = nums.size();\\n        int i, j, k = 0;\\n        // k for nums array \\n        for(i = 0; i < n; i++) {\\n            int m = groups[i].size();\\n            j = 0;\\n            int startPosK = k;\\n            while(k < numslen) {\\n                if(groups[i][j] == nums[k]) {\\n                    j++; k++;\\n                }\\n                else {\\n                    j = 0;\\n                    k = ++startPosK;\\n                }\\n                if(j >= m) break;\\n            }\\n            if(k == numslen) {i++; break;}\\n        }\\n        if(i == n && j == groups[n-1].size()) return true;\\n        return false;\\n    }\\n```\\n.........\\n\\n2. Now this is optimized patern searching algorithm KMP approch \\n\\tTime Complexity: **O(n + m)**\\n\\t\\n\\t```\\n\\tvector<int> getlps(vector<int> v)\\n    {\\n        int ptr = 0;\\n        int n=v.size();\\n        vector<int> lps(n, 0);\\n        int i = 1;\\n        while (i < n) \\n        {\\n            if (v[i] == v[ptr]) {\\n                ptr++;\\n                lps[i] = ptr;\\n                i++;\\n            }\\n            else\\n            {\\n                if (ptr != 0)ptr = lps[ptr - 1];\\n                else i++;\\n            }\\n        }\\n        return lps;\\n    }\\n    \\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i=0;\\n        int n=groups.size();\\n        int j=0;\\n        while((i<n)&&(j<nums.size()))\\n        {\\n            vector<int> lps=getlps(groups[i]);\\n            int ptr1=0, ptr2=j;\\n            while((ptr1<groups[i].size())&&(ptr2<nums.size()))\\n            {\\n                if(groups[i][ptr1]==nums[ptr2])\\n                {\\n                    ptr1++;\\n                    ptr2++;\\n                }\\n                else\\n                {\\n                    if(ptr1!=0)ptr1=lps[ptr1-1];\\n                    else ptr2++;\\n                }\\n            }\\n            if(ptr1<groups[i].size())return false;\\n            i++;\\n            j=ptr2;\\n        }\\n        if(i==n)return true;\\n        return false;\\n    }\\n\\n**Thanks for reading !**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int n = groups.size();\\n        int numslen = nums.size();\\n        int i, j, k = 0;\\n        // k for nums array \\n        for(i = 0; i < n; i++) {\\n            int m = groups[i].size();\\n            j = 0;\\n            int startPosK = k;\\n            while(k < numslen) {\\n                if(groups[i][j] == nums[k]) {\\n                    j++; k++;\\n                }\\n                else {\\n                    j = 0;\\n                    k = ++startPosK;\\n                }\\n                if(j >= m) break;\\n            }\\n            if(k == numslen) {i++; break;}\\n        }\\n        if(i == n && j == groups[n-1].size()) return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1123067,
                "title": "use-string-find-java",
                "content": "One corner case is when nums is [12,1], and the groups is [[2,1]], the nums string will be `12-1-`, the group string will be `2-1-`. First check if `-2-1-` exists, if not, check if `2-1` exists, if`2-1` exists and the index is `0` or the previous character is `-`.\\n\\n```\\npublic boolean canChoose(int[][] groups, int[] nums) {\\n        StringBuilder numstr = new StringBuilder();\\n        for(int n : nums) {\\n            numstr.append(n).append(\\'-\\');\\n        }\\n        int idx = 0;\\n        for(int[] group : groups) {\\n            StringBuilder g = new StringBuilder();\\n            g.append(\\'-\\');\\n            for(int n : group) {\\n                g.append(n).append(\\'-\\');\\n            }\\n            int cur = numstr.indexOf(g.toString(), idx);\\n            if(cur < 0) {\\n                g.deleteCharAt(0);\\n                int hcur = numstr.indexOf(g.toString(), idx);\\n                if(hcur < 0) return false;\\n                if(hcur != 0 && numstr.charAt(hcur - 1) != \\'-\\') return false;\\n            }\\n            idx = cur + g.length();\\n            \\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean canChoose(int[][] groups, int[] nums) {\\n        StringBuilder numstr = new StringBuilder();\\n        for(int n : nums) {\\n            numstr.append(n).append(\\'-\\');\\n        }\\n        int idx = 0;\\n        for(int[] group : groups) {\\n            StringBuilder g = new StringBuilder();\\n            g.append(\\'-\\');\\n            for(int n : group) {\\n                g.append(n).append(\\'-\\');\\n            }\\n            int cur = numstr.indexOf(g.toString(), idx);\\n            if(cur < 0) {\\n                g.deleteCharAt(0);\\n                int hcur = numstr.indexOf(g.toString(), idx);\\n                if(hcur < 0) return false;\\n                if(hcur != 0 && numstr.charAt(hcur - 1) != \\'-\\') return false;\\n            }\\n            idx = cur + g.length();\\n            \\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122888,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n```\\nfunc canChoose(groups [][]int, nums []int) bool {\\n\\ti := 0\\n\\tfor start := 0; i < len(groups) && len(groups[i])+start <= len(nums); start++ {\\n\\t\\tif search(groups[i], nums, start) {\\n\\t\\t\\tstart += len(groups[i]) - 1\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\n\\treturn i == len(groups)\\n}\\n\\nfunc search(group, nums []int, start int) bool {\\n\\tfor i := 0; i < len(group); i++ {\\n\\t\\tif group[i] != nums[i+start] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc canChoose(groups [][]int, nums []int) bool {\\n\\ti := 0\\n\\tfor start := 0; i < len(groups) && len(groups[i])+start <= len(nums); start++ {\\n\\t\\tif search(groups[i], nums, start) {\\n\\t\\t\\tstart += len(groups[i]) - 1\\n\\t\\t\\ti++\\n\\t\\t}\\n\\t}\\n\\n\\treturn i == len(groups)\\n}\\n\\nfunc search(group, nums []int, start int) bool {\\n\\tfor i := 0; i < len(group); i++ {\\n\\t\\tif group[i] != nums[i+start] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122434,
                "title": "c-simple-kmp-algorithm-runtime-16ms-and-83",
                "content": "```\\n    void helper(vector<int>&prefix,vector<int>&arr){\\n        int j = 0;\\n        int n = prefix.size();\\n        for(int i=1;i<n;i++){\\n            if(arr[i]==arr[j]){\\n                prefix[i] = ++j;\\n            }\\n            else if(j!=0){\\n                j = prefix[j-1];\\n                i--;\\n            }\\n            else{\\n                prefix[i] = 0;\\n            }\\n        }\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums){\\n        int n = groups.size();\\n        vector<vector<int>>prefixes(n);\\n        for(int i=0;i<n;i++){\\n            prefixes[i].resize(groups[i].size(),0);\\n        }\\n        for(int i=0;i<n;i++){\\n            helper(prefixes[i],groups[i]);\\n        }\\n        int group = 0;\\n        int index = 0;\\n        int i = 0;\\n        while(i<nums.size()){\\n            if(groups[group][index]==nums[i]){i++;index++;}\\n            if(index==groups[group].size()){\\n                index = 0;\\n                if(++group==groups.size()){return true;}\\n            }\\n            else if(i<nums.size()&&groups[group][index]!=nums[i]){\\n                if(index!=0)\\n                    index = prefixes[group][index-1];\\n                else\\n                    i++;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    void helper(vector<int>&prefix,vector<int>&arr){\\n        int j = 0;\\n        int n = prefix.size();\\n        for(int i=1;i<n;i++){\\n            if(arr[i]==arr[j]){\\n                prefix[i] = ++j;\\n            }\\n            else if(j!=0){\\n                j = prefix[j-1];\\n                i--;\\n            }\\n            else{\\n                prefix[i] = 0;\\n            }\\n        }\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums){\\n        int n = groups.size();\\n        vector<vector<int>>prefixes(n);\\n        for(int i=0;i<n;i++){\\n            prefixes[i].resize(groups[i].size(),0);\\n        }\\n        for(int i=0;i<n;i++){\\n            helper(prefixes[i],groups[i]);\\n        }\\n        int group = 0;\\n        int index = 0;\\n        int i = 0;\\n        while(i<nums.size()){\\n            if(groups[group][index]==nums[i]){i++;index++;}\\n            if(index==groups[group].size()){\\n                index = 0;\\n                if(++group==groups.size()){return true;}\\n            }\\n            else if(i<nums.size()&&groups[group][index]!=nums[i]){\\n                if(index!=0)\\n                    index = prefixes[group][index-1];\\n                else\\n                    i++;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115128,
                "title": "c-beat-100-on-time",
                "content": "```\\n\\tint endingIndex(vector<int> &group, vector<int> &nums, int i) {\\n        int gs = group.size();\\n        int ns = nums.size();\\n        // match every window of size gs\\n        while(i+gs <= ns) {\\n            int j;\\n            for(j=i; j<i+gs; j++) {\\n                if(group[j-i] != nums[j]) {\\n                    break;\\n                }\\n            }\\n            if(j == i+gs) {\\n                return i+gs;\\n            }\\n            i++;\\n        }\\n        return -1;\\n    } \\n    \\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int st = 0;\\n        for(auto group: groups) {\\n            st = endingIndex(group, nums, st);\\n            if(st == -1) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\n\\tint endingIndex(vector<int> &group, vector<int> &nums, int i) {\\n        int gs = group.size();\\n        int ns = nums.size();\\n        // match every window of size gs\\n        while(i+gs <= ns) {\\n            int j;\\n            for(j=i; j<i+gs; j++) {\\n                if(group[j-i] != nums[j]) {\\n                    break;\\n                }\\n            }\\n            if(j == i+gs) {\\n                return i+gs;\\n            }\\n            i++;\\n        }\\n        return -1;\\n    } \\n    \\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int st = 0;\\n        for(auto group: groups) {\\n            st = endingIndex(group, nums, st);\\n            if(st == -1) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1114764,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        return dfs(groups, nums, 0, 0);\\n    }\\n    public boolean dfs(int[][] groups, int[] nums, int gidx, int nidx){\\n        if(gidx == groups.length) return true;\\n        int[] target = groups[gidx];\\n        for(int i=nidx; i<nums.length; i++){\\n            int j = 0;\\n            int tmpi = i;\\n            if(nums[i] == target[j]){\\n                while(i<nums.length && j<target.length && nums[i] == target[j]){\\n                    i++;\\n                    j++;\\n                }\\n                if(j==target.length)\\n                    return dfs(groups, nums, gidx+1, i);\\n            }\\n            i = tmpi;\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        return dfs(groups, nums, 0, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1113750,
                "title": "simple-c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i, j = 0 ,k = 0;\\n        \\n        for(i = 0; i < nums.size() && j < groups.size();) {\\n            int l = i;\\n            \\n            if(nums[i] == groups[j][k]) {\\n                \\n                while(i < nums.size() && k < groups[j].size() && nums[i] == groups[j][k]) \\n                    i++, k++;\\n                \\n                if(k == groups[j].size())\\n                    j++, k = 0;\\n                else\\n                    k = 0, i = l+1;\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        return j == groups.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int i, j = 0 ,k = 0;\\n        \\n        for(i = 0; i < nums.size() && j < groups.size();) {\\n            int l = i;\\n            \\n            if(nums[i] == groups[j][k]) {\\n                \\n                while(i < nums.size() && k < groups[j].size() && nums[i] == groups[j][k]) \\n                    i++, k++;\\n                \\n                if(k == groups[j].size())\\n                    j++, k = 0;\\n                else\\n                    k = 0, i = l+1;\\n            }\\n            else\\n                i++;\\n        }\\n        \\n        return j == groups.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111496,
                "title": "python-kmp-beats-100",
                "content": "Just KMP algorithm, O(len(group) * len(group[0]) + len(nums)).\\n```\\nclass Solution(object):\\n    def canChoose(self, groups, nums):\\n        \"\"\"\\n        :type groups: List[List[int]]\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # kmp\\n        def find(pat, start):\\n            next = [0] * len(pat)\\n            j = 0\\n            for i in range(1, len(pat)):\\n                while j and pat[i] != pat[j]:\\n                    j = next[j - 1]\\n                j += pat[i] == pat[j]\\n                next[i] = j\\n            j = 0\\n            while start < m:\\n                while j and nums[start] != pat[j]:\\n                    j = next[j - 1]\\n                if nums[start] == pat[j]:\\n                    j += 1\\n\\t\\t\\t\\tstart += 1\\n                if j == len(pat):\\n\\t\\t\\t\\t\\treturn start\\n            return -1\\n\\n\\n        m = len(nums)\\n        i = 0\\n        for g in groups:\\n            i = find(g, i)\\n            if i < 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def canChoose(self, groups, nums):\\n        \"\"\"\\n        :type groups: List[List[int]]\\n        :type nums: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        # kmp\\n        def find(pat, start):\\n            next = [0] * len(pat)\\n            j = 0\\n            for i in range(1, len(pat)):\\n                while j and pat[i] != pat[j]:\\n                    j = next[j - 1]\\n                j += pat[i] == pat[j]\\n                next[i] = j\\n            j = 0\\n            while start < m:\\n                while j and nums[start] != pat[j]:\\n                    j = next[j - 1]\\n                if nums[start] == pat[j]:\\n                    j += 1\\n\\t\\t\\t\\tstart += 1\\n                if j == len(pat):\\n\\t\\t\\t\\t\\treturn start\\n            return -1\\n\\n\\n        m = len(nums)\\n        i = 0\\n        for g in groups:\\n            i = find(g, i)\\n            if i < 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110875,
                "title": "java-100-faster-and-memory-kmp-pattern-algo",
                "content": "```\\n\\tpublic boolean canChoose(int[][] groups, int[] nums) {\\n        int groupIndex= 0, eleIndex= 0;\\n        int[] pattern= generatePattern(groups[groupIndex]);\\n        for(int index=0; index<nums.length; index++){\\n            if(nums[index]==groups[groupIndex][eleIndex]) eleIndex++;\\n            else if(eleIndex>0){\\n                eleIndex= pattern[eleIndex-1]+1;\\n                index--;\\n            } \\n            if(eleIndex==groups[groupIndex].length){\\n                groupIndex++; eleIndex=0;\\n                if(groupIndex==groups.length) return true;\\n                else{\\n                    pattern= generatePattern(groups[groupIndex]);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    public int[] generatePattern(int[] group){\\n        int[] pattern= new int[group.length];\\n        int prev= 0, ahead= 1; pattern[0]= -1;\\n        Arrays.fill(pattern,-1);\\n        while(ahead<group.length){\\n            if(group[prev]==group[ahead]){\\n                pattern[ahead]= prev;\\n                prev++; ahead++;\\n            }else if(prev>0){\\n                prev= pattern[prev-1]+1;\\n            }else ahead++;\\n        }\\n        return pattern;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean canChoose(int[][] groups, int[] nums) {\\n        int groupIndex= 0, eleIndex= 0;\\n        int[] pattern= generatePattern(groups[groupIndex]);\\n        for(int index=0; index<nums.length; index++){\\n            if(nums[index]==groups[groupIndex][eleIndex]) eleIndex++;\\n            else if(eleIndex>0){\\n                eleIndex= pattern[eleIndex-1]+1;\\n                index--;\\n            } \\n            if(eleIndex==groups[groupIndex].length){\\n                groupIndex++; eleIndex=0;\\n                if(groupIndex==groups.length) return true;\\n                else{\\n                    pattern= generatePattern(groups[groupIndex]);\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    public int[] generatePattern(int[] group){\\n        int[] pattern= new int[group.length];\\n        int prev= 0, ahead= 1; pattern[0]= -1;\\n        Arrays.fill(pattern,-1);\\n        while(ahead<group.length){\\n            if(group[prev]==group[ahead]){\\n                pattern[ahead]= prev;\\n                prev++; ahead++;\\n            }else if(prev>0){\\n                prev= pattern[prev-1]+1;\\n            }else ahead++;\\n        }\\n        return pattern;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1104835,
                "title": "javascript-solution",
                "content": "```\\nvar canChoose = function(groups, nums) {\\n    let currGroup = groups.shift();\\n    let i = 0;\\n    \\n    while (i < nums.length) {\\n        if (nums[i] === currGroup[0]) {\\n            if (nums.slice(i, i + currGroup.length).join(\\'\\') === currGroup.join(\\'\\')) {\\n                if (groups.length) { \\n                    i = i + currGroup.length; // increment i past the used indexes in nums to avoid repeats\\n                    currGroup = groups.shift(); // currGroup becomes the next array in groups\\n                    continue;\\n                } else {\\n                    return true; // we\\'ve found a match for all the subarrays in groups\\n                }\\n            }\\n        }\\n        i++;\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar canChoose = function(groups, nums) {\\n    let currGroup = groups.shift();\\n    let i = 0;\\n    \\n    while (i < nums.length) {\\n        if (nums[i] === currGroup[0]) {\\n            if (nums.slice(i, i + currGroup.length).join(\\'\\') === currGroup.join(\\'\\')) {\\n                if (groups.length) { \\n                    i = i + currGroup.length; // increment i past the used indexes in nums to avoid repeats\\n                    currGroup = groups.shift(); // currGroup becomes the next array in groups\\n                    continue;\\n                } else {\\n                    return true; // we\\'ve found a match for all the subarrays in groups\\n                }\\n            }\\n        }\\n        i++;\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1099079,
                "title": "just-recursive-style-brutal-force",
                "content": "```\\nclass Solution {\\npublic:\\n\\n#define vv vector<vector<int> >*\\n#define v vector<int>*\\n\\nbool f(vv groups, v nums, int gi, int ni)\\n{\\n\\n    if (gi == groups->size())\\n        return true;\\n    if (ni >= nums->size())\\n        return false;\\n    v curr = &(groups->at(gi));\\n    while (ni < nums->size())\\n    {\\n        if (nums->at(ni) != curr->front())\\n        {\\n            ni++;\\n        }\\n        else\\n        {\\n            //  cout << \"found here\" << ni  <<  nums[ni] << endl;\\n            int runner = ni;\\n            while (runner < nums->size() && runner - ni < curr->size() && nums->at(runner) == curr->at(runner - ni))\\n                runner++;\\n\\n            if (runner - ni == curr->size())\\n            {\\n                return f(groups, nums, gi + 1, runner);\\n            }\\n            else\\n            {\\n                ni++;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\n    bool canChoose(vector<vector<int> > &groups, vector<int> &nums)\\n{\\n\\n    return f(&groups, &nums, 0, 0);\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n#define vv vector<vector<int> >*\\n#define v vector<int>*\\n\\nbool f(vv groups, v nums, int gi, int ni)\\n{\\n\\n    if (gi == groups->size())\\n        return true;\\n    if (ni >= nums->size())\\n        return false;\\n    v curr = &(groups->at(gi));\\n    while (ni < nums->size())\\n    {\\n        if (nums->at(ni) != curr->front())\\n        {\\n            ni++;\\n        }\\n        else\\n        {\\n            //  cout << \"found here\" << ni  <<  nums[ni] << endl;\\n            int runner = ni;\\n            while (runner < nums->size() && runner - ni < curr->size() && nums->at(runner) == curr->at(runner - ni))\\n                runner++;\\n\\n            if (runner - ni == curr->size())\\n            {\\n                return f(groups, nums, gi + 1, runner);\\n            }\\n            else\\n            {\\n                ni++;\\n            }\\n        }\\n    }\\n    return false;\\n}\\n\\n    bool canChoose(vector<vector<int> > &groups, vector<int> &nums)\\n{\\n\\n    return f(&groups, &nums, 0, 0);\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1096328,
                "title": "python-simple-solution-explained",
                "content": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        arrFound = 0\\n        i = 0\\n\\t\\t#we itereate all groups\\n        for arr in groups:\\n            currLen = len(arr)\\n\\t\\t\\t#we check if the curr group of num is equal to the current nums subarray, if so, we add 1 to arrFound and we move i to the next element in the array and we break the while. If is not equal, we simply move to the next element.\\n            while i < len(nums):\\n                if arr == nums[i:i+currLen]:\\n                    arrFound += 1\\n                    i = i + currLen\\n                    break\\n                i += 1\\n\\t\\t#we compare if the quantity found is equal to len(groups), if so it means that all was found.\\n        return arrFound == len(groups) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def canChoose(self, groups: List[List[int]], nums: List[int]) -> bool:\\n        arrFound = 0\\n        i = 0\\n\\t\\t#we itereate all groups\\n        for arr in groups:\\n            currLen = len(arr)\\n\\t\\t\\t#we check if the curr group of num is equal to the current nums subarray, if so, we add 1 to arrFound and we move i to the next element in the array and we break the while. If is not equal, we simply move to the next element.\\n            while i < len(nums):\\n                if arr == nums[i:i+currLen]:\\n                    arrFound += 1\\n                    i = i + currLen\\n                    break\\n                i += 1\\n\\t\\t#we compare if the quantity found is equal to len(groups), if so it means that all was found.\\n        return arrFound == len(groups) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091546,
                "title": "100-faster-and-documented-commented-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     bool canChoose(vector<vector<int>>& groups, vector<int>& A) {\\n         int prev = 0, dist =0, count = 0;\\n         auto itr = A.begin();\\n         for(int i=0; i < groups.size(); i++)\\n         {\\n             vector<int>& vec = groups[i];\\n             //Add previous offset to begin so that searching start after this index\\n             itr = A.begin() + prev;\\n             \\n             dist = itr - A.begin();\\n             //If dist already reached end but there are still some arrays to be searched return false;\\n             if(dist >= A.size())\\n                 return false;\\n\\n             bool isFound = true;\\n             bool isLoopHit = false;\\n             \\n             while((itr = find(itr, A.end(),  vec[0])) != A.end() )\\n             {\\n                 isFound = true;\\n                 isLoopHit = true;\\n                dist = itr - A.begin()+1;\\n                 //If left over characters in A is less than size of searching vector return false;\\n                 if((vec.size() - 1 + dist) > A.size())\\n                     return false;\\n                 \\n                for(int j = 1; j < vec.size() && dist < A.size(); j++, dist++)\\n                {\\n                    if(vec[j] != A[dist])   \\n                    {\\n                        isFound = false;\\n                        break; //For loop\\n                    }\\n                }\\n                 \\n                 //If subarray matched then set prev to dist and break while loop\\n                 if(isFound == true)\\n                 {\\n                     prev = dist;\\n                     break; //break while loop\\n                 }\\n                 //If not then progress itr one step to search further\\n                 else\\n                 {\\n                     itr++;\\n                 }\\n             }\\n             //If subarray is not found in A array then return false;\\n             if( isFound == false )\\n                 return false;\\n             \\n             //If loop is not hit i.e. first element of vector is not found and \\n             //When still have some subarrays to be searched then return false;\\n             if(isLoopHit == false && i <= groups.size()-1 )\\n                 return false;\\n         }\\n         \\n         return true;\\n     }\\n\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     bool canChoose(vector<vector<int>>& groups, vector<int>& A) {\\n         int prev = 0, dist =0, count = 0;\\n         auto itr = A.begin();\\n         for(int i=0; i < groups.size(); i++)\\n         {\\n             vector<int>& vec = groups[i];\\n             //Add previous offset to begin so that searching start after this index\\n             itr = A.begin() + prev;\\n             \\n             dist = itr - A.begin();\\n             //If dist already reached end but there are still some arrays to be searched return false;\\n             if(dist >= A.size())\\n                 return false;\\n\\n             bool isFound = true;\\n             bool isLoopHit = false;\\n             \\n             while((itr = find(itr, A.end(),  vec[0])) != A.end() )\\n             {\\n                 isFound = true;\\n                 isLoopHit = true;\\n                dist = itr - A.begin()+1;\\n                 //If left over characters in A is less than size of searching vector return false;\\n                 if((vec.size() - 1 + dist) > A.size())\\n                     return false;\\n                 \\n                for(int j = 1; j < vec.size() && dist < A.size(); j++, dist++)\\n                {\\n                    if(vec[j] != A[dist])   \\n                    {\\n                        isFound = false;\\n                        break; //For loop\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1091066,
                "title": "c-100-faster-timecomplexity-o-m-n",
                "content": "```\\nclass Solution {\\n\\nprivate :\\n    int findNextGroup(std::vector<int> &group ,std::vector<int> &nums,int start)\\n    {\\n        while (start <= nums.size() - group.size())\\n        {\\n            bool notfound = false;\\n            for (int i=0;i<group.size();++i)\\n            {\\n                if (group[i] != nums[start + i]) \\n                {\\n                    notfound = true;\\n                    break;\\n                }\\n            }\\n            if (!notfound) return start + group.size();\\n            ++start;\\n        }\\n        return -1;\\n    }\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int start = 0;\\n        for (auto &vec:groups)\\n        {\\n            start = findNextGroup(vec,nums,start);\\n            if (start == -1) return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\nprivate :\\n    int findNextGroup(std::vector<int> &group ,std::vector<int> &nums,int start)\\n    {\\n        while (start <= nums.size() - group.size())\\n        {\\n            bool notfound = false;\\n            for (int i=0;i<group.size();++i)\\n            {\\n                if (group[i] != nums[start + i]) \\n                {\\n                    notfound = true;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1089995,
                "title": "c-easy-to-understand-solution",
                "content": "Thanks to the SIMPLE test cases, I am not using KMP and still passes. \\n\\n```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {        \\n        int last = 0; \\n        \\n        for (int i = 0; i < groups.size(); i++) {\\n            int l = -1, r = 0, j = last;\\n            \\n            while (j < nums.size() && r < groups[i].size()) {\\n                // try to match group[i] one by one, variable `l` is used to mark the starting position\\n                if (nums[j] == groups[i][r]) {\\n                    if (r == 0) l = j; \\n                    r++; j++; continue; \\n                }\\n                \\n                // if it fails to match, roll back `j` and reset `l`\\n                if (l > -1 && nums[j] != groups[i][r]) {\\n                    j = l + 1; l = -1; r = 0; continue;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            if (l == -1 || (j == nums.size() && r < groups[i].size())) return false; \\n            last = l + groups[i].size();\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {        \\n        int last = 0; \\n        \\n        for (int i = 0; i < groups.size(); i++) {\\n            int l = -1, r = 0, j = last;\\n            \\n            while (j < nums.size() && r < groups[i].size()) {\\n                // try to match group[i] one by one, variable `l` is used to mark the starting position\\n                if (nums[j] == groups[i][r]) {\\n                    if (r == 0) l = j; \\n                    r++; j++; continue; \\n                }\\n                \\n                // if it fails to match, roll back `j` and reset `l`\\n                if (l > -1 && nums[j] != groups[i][r]) {\\n                    j = l + 1; l = -1; r = 0; continue;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            if (l == -1 || (j == nums.size() && r < groups[i].size())) return false; \\n            last = l + groups[i].size();\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087399,
                "title": "c-well-commented-solution",
                "content": "```\\nclass Solution {\\n    // solution #1: locate the end position of subarray in nums matching first group\\n    // then locate next group from last matching end \\n    // use two pointers to locate the matching subarray vs. current group\\n    // tips and pitfalls:\\n    // 1) when last trial of matching group, reset pointer in nums to last trial start + 1\\n    // time: O(m*n), space: O(1)\\nprivate:\\n    int locate(vector<int>& g, vector<int>& nums, int s) {\\n        int i = 0, j = s, start = s;\\n        if (s + g.size() > nums.size()) return -1;\\n        while (i < g.size() && j < nums.size()) {\\n            if (g[i] == nums[j]) {\\n                i++;\\n                j++;\\n            }\\n            else {\\n                j = start + 1;\\n                start = j;\\n                i = 0;\\n            }\\n        }\\n        return i == g.size() ? j : -1;\\n    }\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int lenSum = 0;\\n        for (auto& g : groups) lenSum += g.size();\\n        if (lenSum > nums.size()) return false;\\n        for (int i = 0, nextStart = 0; i < groups.size(); i++) {\\n            nextStart = locate(groups[i], nums, nextStart);\\n            if (nextStart == -1) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // solution #1: locate the end position of subarray in nums matching first group\\n    // then locate next group from last matching end \\n    // use two pointers to locate the matching subarray vs. current group\\n    // tips and pitfalls:\\n    // 1) when last trial of matching group, reset pointer in nums to last trial start + 1\\n    // time: O(m*n), space: O(1)\\nprivate:\\n    int locate(vector<int>& g, vector<int>& nums, int s) {\\n        int i = 0, j = s, start = s;\\n        if (s + g.size() > nums.size()) return -1;\\n        while (i < g.size() && j < nums.size()) {\\n            if (g[i] == nums[j]) {\\n                i++;\\n                j++;\\n            }\\n            else {\\n                j = start + 1;\\n                start = j;\\n                i = 0;\\n            }\\n        }\\n        return i == g.size() ? j : -1;\\n    }\\npublic:\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        int lenSum = 0;\\n        for (auto& g : groups) lenSum += g.size();\\n        if (lenSum > nums.size()) return false;\\n        for (int i = 0, nextStart = 0; i < groups.size(); i++) {\\n            nextStart = locate(groups[i], nums, nextStart);\\n            if (nextStart == -1) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086637,
                "title": "absolutely-dominating-solution-in-java-100-100-enjoy-in-the-masterpiece-of-code",
                "content": "Runtime: **1 ms**, faster than **100.00%** of Java online submissions for Form Array by Concatenating Subarrays of Another Array.\\n\\nMemory Usage: **38.6 MB**, less than **100.00%** of Java online submissions for Form Array by Concatenating Subarrays of Another Array.\\n\\n```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n\\t\\tboolean canDo = true;\\n\\t\\t\\n\\t\\tint start = 0;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < groups.length && canDo; i++) {\\n\\t\\t\\t\\n\\t\\t\\tboolean canDoPartial = start + groups[i].length - 1 < nums.length;\\n\\t\\t\\t\\n\\t\\t\\tfor (int j = start; j < nums.length && canDoPartial; j++) {\\n\\t\\t\\t\\tboolean found = true;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor (int k = 0; k < groups[i].length && found; k++) {\\n\\t\\t\\t\\t\\tif (groups[i][k] != nums[j + k]) {\\n\\t\\t\\t\\t\\t\\tfound = false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif (found) {\\n\\t\\t\\t\\t\\tstart = j + groups[i].length;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tcanDoPartial = j + groups[i].length < nums.length;\\n\\t\\t\\t\\t}\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif (!canDoPartial) {\\n\\t\\t\\t\\tcanDo = false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn canDo;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        \\n\\t\\tboolean canDo = true;\\n\\t\\t\\n\\t\\tint start = 0;\\n\\t\\t\\n\\t\\tfor (int i = 0; i < groups.length && canDo; i++) {\\n\\t\\t\\t\\n\\t\\t\\tboolean canDoPartial = start + groups[i].length - 1 < nums.length;\\n\\t\\t\\t\\n\\t\\t\\tfor (int j = start; j < nums.length && canDoPartial; j++) {\\n\\t\\t\\t\\tboolean found = true;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tfor (int k = 0; k < groups[i].length && found; k++) {\\n\\t\\t\\t\\t\\tif (groups[i][k] != nums[j + k]) {\\n\\t\\t\\t\\t\\t\\tfound = false;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1084638,
                "title": "jave-simple-solution-by-storage-num-s-loc-in-a-map",
                "content": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        Map<Integer, Deque<Integer>> map = new HashMap<>();\\n        for (int i = 0;i < nums.length;i++) {\\n            Deque<Integer> tmp = map.getOrDefault(nums[i], new LinkedList<>());\\n            tmp.offerLast(i);\\n            map.put(nums[i],tmp);\\n        }\\n        int idx = 0;\\n        for (int[] grp : groups) {\\n            idx = check(grp, map.get(grp[0]), nums, idx);\\n            if (idx == -1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int check(int[] grp, Deque<Integer> idxes, int[] nums, int idx) {\\n        if (idxes == null || idxes.size() == 0) return -1;\\n        while(!idxes.isEmpty() && idxes.peekFirst() < idx) idxes.pollFirst();\\n        if (idxes.isEmpty()) return -1;\\n        while (!idxes.isEmpty()) {\\n            int curIdx = idxes.pollFirst();\\n            boolean found = true;\\n            for (int i = 0;i < grp.length;i++) {\\n                if (curIdx + i >= nums.length || grp[i] != nums[curIdx + i]) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if (found) return curIdx + grp.length;\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean canChoose(int[][] groups, int[] nums) {\\n        Map<Integer, Deque<Integer>> map = new HashMap<>();\\n        for (int i = 0;i < nums.length;i++) {\\n            Deque<Integer> tmp = map.getOrDefault(nums[i], new LinkedList<>());\\n            tmp.offerLast(i);\\n            map.put(nums[i],tmp);\\n        }\\n        int idx = 0;\\n        for (int[] grp : groups) {\\n            idx = check(grp, map.get(grp[0]), nums, idx);\\n            if (idx == -1) return false;\\n        }\\n        return true;\\n    }\\n    \\n    private int check(int[] grp, Deque<Integer> idxes, int[] nums, int idx) {\\n        if (idxes == null || idxes.size() == 0) return -1;\\n        while(!idxes.isEmpty() && idxes.peekFirst() < idx) idxes.pollFirst();\\n        if (idxes.isEmpty()) return -1;\\n        while (!idxes.isEmpty()) {\\n            int curIdx = idxes.pollFirst();\\n            boolean found = true;\\n            for (int i = 0;i < grp.length;i++) {\\n                if (curIdx + i >= nums.length || grp[i] != nums[curIdx + i]) {\\n                    found = false;\\n                    break;\\n                }\\n            }\\n            if (found) return curIdx + grp.length;\\n        }\\n        return -1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084249,
                "title": "clean-easy-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&v ,list<int>&l)\\n    {\\n        if(v.size()!=l.size())\\n            return false;\\n        int c=0;\\n        for(auto it:l)\\n        {\\n            if(it!=v[c++])\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        \\n        int num=0;//Group Number to be taken\\n        int size=groups[num].size();//Size of this group\\n        list<int>temp; //Temp vector\\n        for(auto it:nums)\\n        {\\n            temp.push_back(it);\\n            if(temp.size()>size)\\n                temp.pop_front();\\n            \\n            //So now it have size=group we are currently on\\n            if(check(groups[num],temp))\\n            {\\n                //first group matched \\n                num++;\\n                if(num==groups.size())\\n                    break;\\n                size=groups[num].size();\\n                temp.clear();//Because we want no intersection\\n            }\\n        }\\n        return (num==groups.size());\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&v ,list<int>&l)\\n    {\\n        if(v.size()!=l.size())\\n            return false;\\n        int c=0;\\n        for(auto it:l)\\n        {\\n            if(it!=v[c++])\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\\n        \\n        int num=0;//Group Number to be taken\\n        int size=groups[num].size();//Size of this group\\n        list<int>temp; //Temp vector\\n        for(auto it:nums)\\n        {\\n            temp.push_back(it);\\n            if(temp.size()>size)\\n                temp.pop_front();\\n            \\n            //So now it have size=group we are currently on\\n            if(check(groups[num],temp))\\n            {\\n                //first group matched \\n                num++;\\n                if(num==groups.size())\\n                    break;\\n                size=groups[num].size();\\n                temp.clear();//Because we want no intersection\\n            }\\n        }\\n        return (num==groups.size());\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570393,
                "content": [
                    {
                        "username": "salmanpatel131",
                        "content": "Why Output for below Input is False ?\\n\\n[[1,2]]\\n[1,3,2]\\n\\nPlease correct me if I am wrong."
                    },
                    {
                        "username": "at218808",
                        "content": "[1,2] is not even subgroup of [1,3,2]"
                    },
                    {
                        "username": "PencilBro27",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "dixiao2020",
                        "content": "<img width=400px;height=600px src =\"https://i.postimg.cc/Pq35Wj21/KMP.jpg\">\n\nIf you are new to the KMP algorithm, the upper figure shows why we set len =LSP[len-1] if len>0 and pat[len] != pat[i].\nUpper band: indices for the pattern array\nMiddle band: proper prefix up to index i, the length of this band is Len\nLower band: proper suffix up to index index i.\nSo if  'a'=pattern[Len] != pattern[i]='d',  then we test the length of proper prefix and proper suffix up to index Len-1,  which is equal to LSP[Len-1] by definition of LSP. The purple boxes in the figure are the prefixes and suffixes which has newLen=LSP[Len-1]. Because the string represented as Middle band is totally the same as the string represented as lower band, symmetry shows the four purple boxes are the same, then if we find Pattern[newLen=LSP[Len-1]] and Pattern[i] are equal for instance they both equal 'd', then we increment the newLen by 1 and set LSP[i]=newLen. The proper prefix and suffix up to index i are then showed inside the red circles."
                    }
                ]
            },
            {
                "id": 2037836,
                "content": [
                    {
                        "username": "salmanpatel131",
                        "content": "Why Output for below Input is False ?\\n\\n[[1,2]]\\n[1,3,2]\\n\\nPlease correct me if I am wrong."
                    },
                    {
                        "username": "at218808",
                        "content": "[1,2] is not even subgroup of [1,3,2]"
                    },
                    {
                        "username": "PencilBro27",
                        "content": "A subarray is a contiguous sequence of elements within an array."
                    },
                    {
                        "username": "dixiao2020",
                        "content": "<img width=400px;height=600px src =\"https://i.postimg.cc/Pq35Wj21/KMP.jpg\">\n\nIf you are new to the KMP algorithm, the upper figure shows why we set len =LSP[len-1] if len>0 and pat[len] != pat[i].\nUpper band: indices for the pattern array\nMiddle band: proper prefix up to index i, the length of this band is Len\nLower band: proper suffix up to index index i.\nSo if  'a'=pattern[Len] != pattern[i]='d',  then we test the length of proper prefix and proper suffix up to index Len-1,  which is equal to LSP[Len-1] by definition of LSP. The purple boxes in the figure are the prefixes and suffixes which has newLen=LSP[Len-1]. Because the string represented as Middle band is totally the same as the string represented as lower band, symmetry shows the four purple boxes are the same, then if we find Pattern[newLen=LSP[Len-1]] and Pattern[i] are equal for instance they both equal 'd', then we increment the newLen by 1 and set LSP[i]=newLen. The proper prefix and suffix up to index i are then showed inside the red circles."
                    }
                ]
            }
        ]
    }
]