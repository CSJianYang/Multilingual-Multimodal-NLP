[
    {
        "title": "Difference Between Maximum and Minimum Price Sum",
        "question_content": "There exists an undirected and initially unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nThe tree can be rooted at any node root of your choice. The incurred cost after choosing root is the difference between the maximum and minimum price sum amongst all paths starting at root.\nReturn the maximum possible cost amongst all possible root choices.\n&nbsp;\nExample 1:\n\nInput: n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\nOutput: 24\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n- The first path contains nodes [2,1,3,4]: the prices are [7,8,6,10], and the sum of the prices is 31.\n- The second path contains the node [2] with the price [7].\nThe difference between the maximum and minimum price sum is 24. It can be proved that 24 is the maximum cost.\n\nExample 2:\n\nInput: n = 3, edges = [[0,1],[1,2]], price = [1,1,1]\nOutput: 2\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n- The first path contains nodes [0,1,2]: the prices are [1,1,1], and the sum of the prices is 3.\n- The second path contains node [0] with a price [1].\nThe difference between the maximum and minimum price sum is 2. It can be proved that 2 is the maximum cost.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 105\n\tedges.length == n - 1\n\t0 <= ai, bi <= n - 1\n\tedges represents a valid tree.\n\tprice.length == n\n\t1 <= price[i] <= 105",
        "solutions": [
            {
                "id": 3052596,
                "title": "re-rooting-o-n-explained",
                "content": "# Rerooting\\n*It is a technique where we solve a given problem for all roots.*\\n\\n**Steps**\\n1.  Arbitrary root the tree, lets take `node 0` for explanation.\\n2.  Solve the given problem as if it was rooted at `node 0`.\\n3.  Similarily solve the problem for all nodes\\n\\nEven if you have never heard of this term before, no problem it just **DFS**. In this post I will explain how to solve this particular question even if you have never done rerooting before. \\n\\nIf you want proper resources for learning/reading about re-rooting then refer these. \\n1. \\t[Re rooting](https://usaco.guide/gold/all-roots?lang=java)\\n2. \\t[Re rooting section of this book](https://dp-book.com/Dynamic_Programming.pdf)\\n\\n**Observation**\\n* Minimum Path sum is always equal to the value of root node. If we include any other vertex in our path we are going to increase the sum as all weights of nodes to greater than 1.\\n* Try to solve a **simpler problem** first. `Given a tree rooted at node 0 where each node has positive weights assigned. Calculate the maximum weight of a path starting from root node. `\\n\\nI will be using this tree. Note the node labels are node indices and not weights\\n![image](https://assets.leetcode.com/users/images/80c83cbe-c3b9-4bab-81bd-e886815efbb1_1673974523.1710196.png)\\n\\n\\n\\n**Solving Simpler Problem**\\nDo you see DP in this ?? \\nAt `node 1` we have two choices either take path from `subtree of node 3` or take from `subtree of node 4`. So we will chose the maximum path. Similarily we have 2 choices at `node 0`\\n\\n```\\nint[] subtree_sum = new int[n]; \\n//subtree_sum[i] = Maximum path weight starting from node i if the tree was rooted at node 0\\n```\\n\\n```\\nsubtree_sum[0] = max(subtree_sum[1],subtree[2]) + price[0];\\nsubtree_sum[1] = max(subtree_sum[3],subtree_sum[4]) + price[1];\\n```\\n\\nTo calculate this we will run a dfs to fill subtree_sum. and return subtree_sum[0]\\n\\nWell done we have solved **2/3** of the problem according to the steps of rerooting. But now comes the main part.\\n\\n**Solving for all roots**\\n Now we want to root the tree at node 1. how can we calculate the maximum path starting from `node 1`.  There are two options the path can go to one of the children `3,4` or go to its parent `0`\\n*  From `subtree_sum` we can find maximum paths in subtree of `3 and 4`.\\n*  To handle the maximum path from parent we will have a parameter in our dfs function `parent_contribution` which is equal to `price[parent] + max(maximum weighted child of parent, parent\\'s parent_contribution).` If the current node is the maximum weight child of parent then we need to chose the second most weighted child of parent. \\n* ` Maximum difference at node 1 = max(subtree_sum[3],subtree_sum[4],parent_contribtion) + price[1] - price[1] (minimum path)`\\n            = ``max(subtree_sum[3],subtree_sum[4],parent_contribtion)``\\n\\t\\t\\t\\nVisit all vertices in second dfs and find the maximum difference. \\n\\nTime Complexity O(N)\\nSpace Complexity O(N)\\n\\n```\\nclass Solution {\\n    private long[] subtree_sum; //Stores -> If the tree was rooted at node 0 what is the maximum sum we can get from subtree of i\\n    private long max_dif = 0L;\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        List<List<Integer>> tree = new ArrayList<>();\\n        for(int i=0;i<n;i++) tree.add(new ArrayList<>());\\n        for(int[] e: edges){\\n            tree.get(e[0]).add(e[1]);\\n            tree.get(e[1]).add(e[0]);\\n        }\\n        subtree_sum = new long[n];\\n        dfs(0,-1,tree,price);  //Fills the subtree_sum array\\n        dfs2(0,-1,tree,price,0);\\n        return max_dif;\\n    }\\n    private long dfs(int node, int parent, List<List<Integer>> tree, int[] price){\\n        long m = 0L; //We need the maximum contribution of children. \\n        for(int child: tree.get(node)){\\n            if(child == parent) continue;\\n            m  = Math.max(m, dfs(child,node,tree,price));\\n        }\\n        return subtree_sum[node] = price[node] + m;\\n    }\\n    private void dfs2(int node, int parent,List<List<Integer>> tree, int[] price, long parent_contribution){\\n        int c1=-1;\\n        long mc1=0,mc2=0;  //2 maximum contribution of children\\n        for(int child: tree.get(node)){\\n            if(child == parent) continue;\\n            if(subtree_sum[child]>mc1){\\n                mc2 = mc1;\\n                c1 = child;\\n                mc1 = subtree_sum[child];\\n            }\\n            else if(subtree_sum[child]>mc2){\\n                mc2 = subtree_sum[child];\\n            }\\n        }\\n        long path1 = mc1;\\n        long path2 = parent_contribution;\\n        max_dif = Math.max(max_dif,Math.max(path1,path2));\\n        for(int child: tree.get(node)){\\n            if(child == parent) continue;\\n/*\\nHow can a parent add a path to child?\\n1. Take a path from a siblling of child     (we want the maximum siblling)\\n2. Take a path from its parent\\n\\nThus the contribution of current node to its child c is maximum(maximum siblling ,node\\'s parent_contribution)\\n*/\\n            if(c1 == child) dfs2(child,node,tree,price,price[node]+Math.max(mc2,parent_contribution)); \\n            else dfs2(child,node,tree,price,price[node]+Math.max(mc1,parent_contribution));\\n        }\\n    }\\n}\\n```\\nFor similar problems have a look at comments\\n\\n@Leetcode please consider adding a spelling checker for posts..",
                "solutionTags": [],
                "code": "```\\nint[] subtree_sum = new int[n]; \\n//subtree_sum[i] = Maximum path weight starting from node i if the tree was rooted at node 0\\n```\n```\\nsubtree_sum[0] = max(subtree_sum[1],subtree[2]) + price[0];\\nsubtree_sum[1] = max(subtree_sum[3],subtree_sum[4]) + price[1];\\n```\n```\\nclass Solution {\\n    private long[] subtree_sum; //Stores -> If the tree was rooted at node 0 what is the maximum sum we can get from subtree of i\\n    private long max_dif = 0L;\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        List<List<Integer>> tree = new ArrayList<>();\\n        for(int i=0;i<n;i++) tree.add(new ArrayList<>());\\n        for(int[] e: edges){\\n            tree.get(e[0]).add(e[1]);\\n            tree.get(e[1]).add(e[0]);\\n        }\\n        subtree_sum = new long[n];\\n        dfs(0,-1,tree,price);  //Fills the subtree_sum array\\n        dfs2(0,-1,tree,price,0);\\n        return max_dif;\\n    }\\n    private long dfs(int node, int parent, List<List<Integer>> tree, int[] price){\\n        long m = 0L; //We need the maximum contribution of children. \\n        for(int child: tree.get(node)){\\n            if(child == parent) continue;\\n            m  = Math.max(m, dfs(child,node,tree,price));\\n        }\\n        return subtree_sum[node] = price[node] + m;\\n    }\\n    private void dfs2(int node, int parent,List<List<Integer>> tree, int[] price, long parent_contribution){\\n        int c1=-1;\\n        long mc1=0,mc2=0;  //2 maximum contribution of children\\n        for(int child: tree.get(node)){\\n            if(child == parent) continue;\\n            if(subtree_sum[child]>mc1){\\n                mc2 = mc1;\\n                c1 = child;\\n                mc1 = subtree_sum[child];\\n            }\\n            else if(subtree_sum[child]>mc2){\\n                mc2 = subtree_sum[child];\\n            }\\n        }\\n        long path1 = mc1;\\n        long path2 = parent_contribution;\\n        max_dif = Math.max(max_dif,Math.max(path1,path2));\\n        for(int child: tree.get(node)){\\n            if(child == parent) continue;\\n/*\\nHow can a parent add a path to child?\\n1. Take a path from a siblling of child     (we want the maximum siblling)\\n2. Take a path from its parent\\n\\nThus the contribution of current node to its child c is maximum(maximum siblling ,node\\'s parent_contribution)\\n*/\\n            if(c1 == child) dfs2(child,node,tree,price,price[node]+Math.max(mc2,parent_contribution)); \\n            else dfs2(child,node,tree,price,price[node]+Math.max(mc1,parent_contribution));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052985,
                "title": "c-dfs-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question is similar to [124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/) but a little different.  \\n   \\nThe difference between this question and 124. :  \\n1. Only positive value\\n2. Not a binary tree\\n3. The answer is not the maximum path but the path that minus the smaller end point.\\n-----\\n\\n1. Consider question 124 with only positive node : \\n   - The DFS returns the maximum path from current root to one of leaf node.\\n   - At each subtree, we update the final answer with left subtree return value (which is the max path sum) + current root node value + right subtree return value.\\n\\n2. We need to consider all subtrees instead of left and right.\\n3. Since we don\\'t know which side of end point is the minimum we should remove and if the path is still maximum after we remove the end point, we maintain another value which is the path sum from root to leaf but minus its leaf node and try both two cases.\\n\\n\\nIn the for loop we iterate all neighbors(subtrees) and update the answer with two cases:\\n1. Current max path sum from previous subtrees + path sum without leaf node from nei subtree\\n2. Current max path sum without leaf node from previous subtrees + path sum from nei subtree\\n\\nDesign DFS that returns two values:\\n1. maximum path sum\\n2. maximum (path sum - leaf node)\\n\\n# Complexity\\n- Time complexity: $$O(n + edge)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n + edge)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>> g(n);\\n        for(auto& e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        long long ans = 0;\\n        function<vector<long long>(int, int)> dfs = [&] (int now, int pre) ->vector<long long> {\\n            //cur_max[0] :max pathsum\\n            //cur_max[1] :max (pathsum - leaf node)\\n            vector<long long> cur_max = {price[now], 0};\\n            for(auto& nei : g[now]) {\\n                if(nei != pre) {\\n                    auto&& sub = dfs(nei, now);\\n                    ans = max(ans, cur_max[0] + sub[1]);\\n                    ans = max(ans, cur_max[1] + sub[0]);\\n                    cur_max[0] = max(cur_max[0], sub[0] + price[now]);\\n                    cur_max[1] = max(cur_max[1], sub[1] + price[now]);\\n                }\\n            }\\n            return cur_max;\\n        };\\n        dfs(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>> g(n);\\n        for(auto& e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        long long ans = 0;\\n        function<vector<long long>(int, int)> dfs = [&] (int now, int pre) ->vector<long long> {\\n            //cur_max[0] :max pathsum\\n            //cur_max[1] :max (pathsum - leaf node)\\n            vector<long long> cur_max = {price[now], 0};\\n            for(auto& nei : g[now]) {\\n                if(nei != pre) {\\n                    auto&& sub = dfs(nei, now);\\n                    ans = max(ans, cur_max[0] + sub[1]);\\n                    ans = max(ans, cur_max[1] + sub[0]);\\n                    cur_max[0] = max(cur_max[0], sub[0] + price[now]);\\n                    cur_max[1] = max(cur_max[1], sub[1] + price[now]);\\n                }\\n            }\\n            return cur_max;\\n        };\\n        dfs(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052569,
                "title": "template-for-tree-based-dp-problems-with-edges-inputs",
                "content": "Learned this trick from @yk000123 (https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/discuss/2198125/Python-O(n2)-Iterate-two-edges-with-caching\\uFF09\\n\\nFor tree-based dp problems that give you edges as inputs, below is the template\\n\\n1. store edges into an adjancent list\\n2. define a dfs function with two key parameters (cur, prev) to control the direction we will move along an edge between cur and prev\\n3. within dfs(cur,prev), the recursion is to call t(nxt,cur) for nxt in adj[cur]-{prev}\\n4. we add memorization (@cache) so that each edge between cur and prev will only be visited twice: one from cur to prev, one from prev to cur\\n5. we call dfs(i,-1) for i in range(n). -1 denotes no prev for i, so i is the root.\\n\\n        adj=collections.defaultdict(set)\\n        for i,j in edges:\\n            adj[i].add(j)\\n            adj[j].add(i)\\n                    \\n        @cache\\n        def dfs(cur,prev):    \\n            return price[cur]+max([dfs(nxt,cur) for nxt in adj[cur]-{prev}]+[0])\\n\\n        return max(dfs(i,-1)-price[i] for i in range(n)) \\n\\n\\nUsing this template, we can solve all the following problems with minor edits.\\n\\nhttps://leetcode.com/discuss/interview-question/2751188/Lucid-OA-new-grad-SWE\\n\\nhttps://leetcode.com/discuss/interview-question/1463104/Media.net-or-OA-or-Minimum-cost-to-buy-oranges\\n\\nhttps://leetcode.com/discuss/interview-question/2639890/Media.Net(Directi)-OA-On-campus-Questions-%3A)\\n\\nhttps://leetcode.com/problems/minimum-score-after-removals-on-a-tree/\\n\\nhttps://leetcode.com/discuss/interview-question/2788156/OA-2022-or-Pythagorean-Triplets\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Learned this trick from @yk000123 (https://leetcode.com/problems/minimum-score-after-removals-on-a-tree/discuss/2198125/Python-O(n2)-Iterate-two-edges-with-caching\\uFF09\\n\\nFor tree-based dp problems that give you edges as inputs, below is the template\\n\\n1. store edges into an adjancent list\\n2. define a dfs function with two key parameters (cur, prev) to control the direction we will move along an edge between cur and prev\\n3. within dfs(cur,prev), the recursion is to call t(nxt,cur) for nxt in adj[cur]-{prev}\\n4. we add memorization (@cache) so that each edge between cur and prev will only be visited twice: one from cur to prev, one from prev to cur\\n5. we call dfs(i,-1) for i in range(n). -1 denotes no prev for i, so i is the root.\\n\\n        adj=collections.defaultdict(set)\\n        for i,j in edges:\\n            adj[i].add(j)\\n            adj[j].add(i)\\n                    \\n        @cache\\n        def dfs(cur,prev):    \\n            return price[cur]+max([dfs(nxt,cur) for nxt in adj[cur]-{prev}]+[0])\\n\\n        return max(dfs(i,-1)-price[i] for i in range(n)) \\n\\n\\nUsing this template, we can solve all the following problems with minor edits.\\n\\nhttps://leetcode.com/discuss/interview-question/2751188/Lucid-OA-new-grad-SWE\\n\\nhttps://leetcode.com/discuss/interview-question/1463104/Media.net-or-OA-or-Minimum-cost-to-buy-oranges\\n\\nhttps://leetcode.com/discuss/interview-question/2639890/Media.Net(Directi)-OA-On-campus-Questions-%3A)\\n\\nhttps://leetcode.com/problems/minimum-score-after-removals-on-a-tree/\\n\\nhttps://leetcode.com/discuss/interview-question/2788156/OA-2022-or-Pythagorean-Triplets\\n\\n\\n\\n\\n\\n\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3052744,
                "title": "very-simple-python-dfs",
                "content": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        \"\"\"\\n            greedy way could be try each node as root, but it will be:\\n                O(N * N) \\n            \\n            we can use DP and suddle it down  dfs(node, parent) would give correct price from node to end\\n        \"\"\"\\n        \\n        g = defaultdict(set)\\n        \\n        for u, v in edges:\\n            g[u].add(v)\\n            g[v].add(u)\\n        \\n        @cache\\n        def dfs(node, parent):\\n            \\n            curr_price = price[node]\\n            m = 0 # find the max path from current node via dfs\\n            for v in g[node]:\\n                if v == parent: continue\\n                m = max(m, dfs(v, node))\\n\\n            return curr_price + m # return current_price + max_price_path\\n        \\n        m = 0\\n        for node in range(n):\\n            max_price = dfs(node, -1)\\n            min_price = price[node]\\n            m = max(m, max_price - min_price)\\n        \\n        return m\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        \"\"\"\\n            greedy way could be try each node as root, but it will be:\\n                O(N * N) \\n            \\n            we can use DP and suddle it down  dfs(node, parent) would give correct price from node to end\\n        \"\"\"\\n        \\n        g = defaultdict(set)\\n        \\n        for u, v in edges:\\n            g[u].add(v)\\n            g[v].add(u)\\n        \\n        @cache\\n        def dfs(node, parent):\\n            \\n            curr_price = price[node]\\n            m = 0 # find the max path from current node via dfs\\n            for v in g[node]:\\n                if v == parent: continue\\n                m = max(m, dfs(v, node))\\n\\n            return curr_price + m # return current_price + max_price_path\\n        \\n        m = 0\\n        for node in range(n):\\n            max_price = dfs(node, -1)\\n            min_price = price[node]\\n            m = max(m, max_price - min_price)\\n        \\n        return m\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083389,
                "title": "dfs-vs-bfs",
                "content": "A path with maximum cost will always span leaf-to-leaf.\\n\\nThe cost will be the prices of all nodes in the path, minus the smaller price of two leaves.\\n\\n#### DFS\\nWe can run DFS from each leaf, but it will be too slow.\\n\\nInstead, we can track and return two values from DFS: maximum costs with and without including a root in the path.\\n\\nIt was tricky for me to figure it out right away, and I initially came up with a BFS solution.\\n\\nIn the end, the logic turned out to be quite similar, though perhaps the BFS solution could be easier to follow for someone.\\n\\n**C++**\\n```cpp\\nlong long max_cost = 0;\\narray<long long, 2> dfs(int i, int p, vector<vector<int>> &al, vector<int>& price) {\\n    array<long long, 2> res({price[i], 0});\\n    for (int j : al[i])\\n        if (j != p) {\\n            auto res_j = dfs(j, i, al, price);\\n            max_cost = max({ max_cost, res[0] + res_j[1], res[1] + res_j[0] });\\n            res[0] = max(res[0], res_j[0] + price[i]);\\n            res[1] = max(res[1], res_j[1] + price[i]);\\n        }\\n    return i == 0 ? array<long long, 2>({max_cost, 0}) : res;\\n}\\nlong long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n    vector<vector<int>> al(n);\\n    for(auto& e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    return dfs(0, -1, al, price)[0];\\n}\\n```\\n\\n#### BFS\\nWe can do BFS starting from leaves. For node `i`, we track two values:\\n- `leaf[i]` - maximum cost so far to reach node `i`, including the price of starting leaf.\\n- `root[i]` - same as above, but excluding the price of starting node. \\n\\nWhen we reach node `j` from node `i`, we can form a path with cost `leat[i] + root[j]` or `root[i] + leaf[j]`.\\n\\nThis way, we maximize the cost by combining the best rooted and non-rooted path.\\n\\nWe track the edges for each node in `cnt`. When we reach a node `i`, we decrement `cnt[i]`. \\n\\nOnce the count reaches `1`, then all subtrees have converged at node `i`, and we can go further.\\n\\n**C++**\\n```cpp\\nlong long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n    long long res = 0;\\n    vector<vector<int>> al(n);\\n    vector<int> cnt(n), leaf(price), root(price), q;\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    for (int i = 0; i < n; ++i) \\n        if ((cnt[i] = al[i].size()) == 1) {\\n            q.push_back(i);\\n            root[i] -= price[i];\\n        }\\n    while (!q.empty()) {\\n        vector<int> q1;\\n        for (int i : q) {\\n            --cnt[i];\\n            for (int j : al[i])\\n                if (cnt[j] > 0) {\\n                    res = max({res, (long long)leaf[i] + root[j], (long long)root[i] + leaf[j]});\\n                    leaf[j] = max(leaf[i] + price[j], leaf[j]);\\n                    root[j] = max(root[i] + price[j], root[j]);\\n                    if (--cnt[j] == 1)\\n                        q1.push_back(j);\\n                }\\n        }\\n        swap(q, q1);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long max_cost = 0;\\narray<long long, 2> dfs(int i, int p, vector<vector<int>> &al, vector<int>& price) {\\n    array<long long, 2> res({price[i], 0});\\n    for (int j : al[i])\\n        if (j != p) {\\n            auto res_j = dfs(j, i, al, price);\\n            max_cost = max({ max_cost, res[0] + res_j[1], res[1] + res_j[0] });\\n            res[0] = max(res[0], res_j[0] + price[i]);\\n            res[1] = max(res[1], res_j[1] + price[i]);\\n        }\\n    return i == 0 ? array<long long, 2>({max_cost, 0}) : res;\\n}\\nlong long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n    vector<vector<int>> al(n);\\n    for(auto& e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    return dfs(0, -1, al, price)[0];\\n}\\n```\n```cpp\\nlong long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n    long long res = 0;\\n    vector<vector<int>> al(n);\\n    vector<int> cnt(n), leaf(price), root(price), q;\\n    for (auto &e : edges) {\\n        al[e[0]].push_back(e[1]);\\n        al[e[1]].push_back(e[0]);\\n    }\\n    for (int i = 0; i < n; ++i) \\n        if ((cnt[i] = al[i].size()) == 1) {\\n            q.push_back(i);\\n            root[i] -= price[i];\\n        }\\n    while (!q.empty()) {\\n        vector<int> q1;\\n        for (int i : q) {\\n            --cnt[i];\\n            for (int j : al[i])\\n                if (cnt[j] > 0) {\\n                    res = max({res, (long long)leaf[i] + root[j], (long long)root[i] + leaf[j]});\\n                    leaf[j] = max(leaf[i] + price[j], leaf[j]);\\n                    root[j] = max(root[i] + price[j], root[j]);\\n                    if (--cnt[j] == 1)\\n                        q1.push_back(j);\\n                }\\n        }\\n        swap(q, q1);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3074748,
                "title": "max-path-sum-one-pass-42ms-beats-100-java",
                "content": "# NOTE\\nthis solution was originally posted by [jason7708](https://leetcode.com/jason7708/), and was top voted, not sure why it was later removed, this is the simplest and fasting solution I know, so I am posting it again.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/description/)\\nThis is actually a leaf to leaf path sum problem, the caveat is, you have to remove one leaf (from either end), so you have to return more values.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), one pass after graph/tree created\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# [42ms](https://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/submissions/880271275/)\\n```java\\nclass Solution {\\n    long res = 0;\\n    List<Integer>[] g;\\n    int[] price;\\n\\n    record returnType(int withLeaf, int withoutLeaf) {}\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        this.price = price;\\n        \\n        // create adjacency list graph(tree)\\n        g = new List[n];\\n        for (int i = 0; i < n; i++) g[i] = new ArrayList<>();\\n        for (var e : edges) {\\n            g[e[0]].add(e[1]);\\n            g[e[1]].add(e[0]);\\n        }\\n\\n        dfs(0, -1); // you can start from any root doesn\\'t matter, as long as it exists\\n        return res;\\n    }\\n\\n    private returnType dfs(int cur, int pre) {\\n        int withLeaf = price[cur], withoutLeaf = 0;\\n        for (int child : g[cur]) if (child != pre) {\\n            var childMax = dfs(child, cur);\\n            res = Math.max(res, withLeaf + childMax.withoutLeaf);\\n            res = Math.max(res, withoutLeaf + childMax.withLeaf);\\n            withLeaf = Math.max(withLeaf, childMax.withLeaf + price[cur]);\\n            withoutLeaf = Math.max(withoutLeaf, childMax.withoutLeaf + price[cur]);\\n        }\\n\\n        return new returnType(withLeaf, withoutLeaf); // single leg\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    long res = 0;\\n    List<Integer>[] g;\\n    int[] price;\\n\\n    record returnType(int withLeaf, int withoutLeaf) {}\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        this.price = price;\\n        \\n        // create adjacency list graph(tree)\\n        g = new List[n];\\n        for (int i = 0; i < n; i++) g[i] = new ArrayList<>();\\n        for (var e : edges) {\\n            g[e[0]].add(e[1]);\\n            g[e[1]].add(e[0]);\\n        }\\n\\n        dfs(0, -1); // you can start from any root doesn\\'t matter, as long as it exists\\n        return res;\\n    }\\n\\n    private returnType dfs(int cur, int pre) {\\n        int withLeaf = price[cur], withoutLeaf = 0;\\n        for (int child : g[cur]) if (child != pre) {\\n            var childMax = dfs(child, cur);\\n            res = Math.max(res, withLeaf + childMax.withoutLeaf);\\n            res = Math.max(res, withoutLeaf + childMax.withLeaf);\\n            withLeaf = Math.max(withLeaf, childMax.withLeaf + price[cur]);\\n            withoutLeaf = Math.max(withoutLeaf, childMax.withoutLeaf + price[cur]);\\n        }\\n\\n        return new returnType(withLeaf, withoutLeaf); // single leg\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052821,
                "title": "java-using-dfs-weighted-directed-tree-with-comments",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe naive approach asks us to dfs the tree from node u, for every node in the tree.\\nThis results in a time complexity of O(n^2).\\n\\nIn order to reduce the time complexity to O(n), we need to try to update maximum paths information for every node in the tree while we are doing dfs for a particular node.\\n\\nThis can be achived by using a weighed directed tree. Here every weight from node u to node v gives us the length of the longest path starting from node u using the edge u-v.\\nTherefore, a directed weight from node u to v can be used to store results in order to avoid extra computations. This information can be used to calculate maximum path sum for other nodes, without having to do dfs again.\\n\\nThis means, the longest path for any node u, is the maximum value out of all the edges going out from node u.\\n\\nNote: the minimum path from any node u, is the node u itself as the given tree can\\'t contain nodes with negative values according to constraints.\\n\\nSo now that we have the minimum and maximum path from any given node of the tree(computed). In order to find the path with maximum difference, we just iterate over all the nodes and compute the maximum value and return it as the result\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ (worst case, it happens for a star graph)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(2 * n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        Map<Integer, Long>[] adjList = new Map[n];\\n        for (int i = 0; i < n; i++) {\\n            adjList[i] = new HashMap<>();\\n        }\\n        for (int[] edge : edges) {\\n            adjList[edge[0]].put(edge[1], 0L);\\n            adjList[edge[1]].put(edge[0], 0L);\\n        }\\n        // Above we simply construct the adjacency list for the given tree.\\n        long res = 0;\\n        // Below, we dfs every node of our tree,\\n        // but every iteration won\\'t be O(n),\\n        // because we use information from previous dfs iteration\\n        // to compute edge values.\\n        for (int i = 0; i < n; i++) {\\n            res = Math.max(res, dfs(adjList, price, i, -1) - price[i]);\\n        }\\n        return res;\\n    }\\n    \\n    private long dfs(Map<Integer, Long>[] tree, int[] price, int cur, int parent) {\\n        long maxPath = 0;\\n        for (int child : tree[cur].keySet()) {\\n            if (child != parent) {\\n                // get the weight of edge from node cur to node child.\\n                long temp = tree[cur].get(child);\\n\\n                // if the weight of the edge is not already computed,\\n                // then we compute by calling dfs for this\\n                // adjacent or child node.\\n                if (temp == 0) {\\n                    temp = dfs(tree, price, child, cur);\\n                    tree[cur].put(child, temp);\\n                }\\n                // maxPath starting from node cur is updated.\\n                maxPath = Math.max(maxPath, temp);\\n            }\\n        }\\n        // cost of including current path in previous\\n        // stack call is returned.\\n        return maxPath + price[cur];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        Map<Integer, Long>[] adjList = new Map[n];\\n        for (int i = 0; i < n; i++) {\\n            adjList[i] = new HashMap<>();\\n        }\\n        for (int[] edge : edges) {\\n            adjList[edge[0]].put(edge[1], 0L);\\n            adjList[edge[1]].put(edge[0], 0L);\\n        }\\n        // Above we simply construct the adjacency list for the given tree.\\n        long res = 0;\\n        // Below, we dfs every node of our tree,\\n        // but every iteration won\\'t be O(n),\\n        // because we use information from previous dfs iteration\\n        // to compute edge values.\\n        for (int i = 0; i < n; i++) {\\n            res = Math.max(res, dfs(adjList, price, i, -1) - price[i]);\\n        }\\n        return res;\\n    }\\n    \\n    private long dfs(Map<Integer, Long>[] tree, int[] price, int cur, int parent) {\\n        long maxPath = 0;\\n        for (int child : tree[cur].keySet()) {\\n            if (child != parent) {\\n                // get the weight of edge from node cur to node child.\\n                long temp = tree[cur].get(child);\\n\\n                // if the weight of the edge is not already computed,\\n                // then we compute by calling dfs for this\\n                // adjacent or child node.\\n                if (temp == 0) {\\n                    temp = dfs(tree, price, child, cur);\\n                    tree[cur].put(child, temp);\\n                }\\n                // maxPath starting from node cur is updated.\\n                maxPath = Math.max(maxPath, temp);\\n            }\\n        }\\n        // cost of including current path in previous\\n        // stack call is returned.\\n        return maxPath + price[cur];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053404,
                "title": "c-understandable-code-using-rerooting",
                "content": "```\\n\\n\\n// firstly i am precomputing the maximum path sum for each node (called sub) using dfs function assuming tree rooted at node 0.\\n// Now we are olny left with rerooting at all the nodes and get the maximum of all. I am storing it in dp \\n\\n//explanation of rerooting function\\nconsider the tree\\n           0\\n\\t\\t /   \\\\\\n      1       2\\n\\t/   \\\\    /  \\\\\\n 3      4  5    6\\n prices:= 1,2,3,4,5,6,7\\n \\n suppose we are at 0th node then we have to reroot at all the child of node 0 i.e.(1,2)\\n now suppose i go for node 2 then what i am doing that assume 2 is not a child of node 0 and calculate the maximum path sum for node 0.\\n \\n long long mx=0;\\n            for(auto it:g[v]){\\n                if(it==to)continue;\\n                mx=max(mx,sub[it]);\\n            }\\nnow it is quite simple that dp[2]=max(sub[2]-price[2],mx+price[2]);\\n dp[to]=max(sub[to]-price[to],mx+price[v]);\\n \\n //one thing to note that when we go gor node 2 the path sum value of node 0 (sub[0]) will change for that subtree that\\'s why i am doing\\n    sub[v]=mx+price[v];\\n\\t\\n\\tand after coming out of reroot call \\n\\tsetting it to the initial value(long long tmp=sub[v])\\n     sub[v]=tmp;\\n\\t \\n\\n\\nCODE:-\\n\\n  vector<long long>sub; \\nbool comp(int &i,int &j){\\n        return (sub[i]>sub[j]);\\n    }\\nclass Solution {\\npublic:\\n  \\n    \\n    long long solve(int v,int p,vector<int>g[],vector<int>&price){\\n        sub[v]=price[v];\\n        long long mx=0;\\n        for(auto to:g[v]){\\n            if(to==p)continue;\\n            mx=max(mx,solve(to,v,g,price));\\n        }\\n        sub[v]+=mx;\\n        return sub[v];\\n    }\\n    void reroot(int v,int p,vector<int>g[],vector<int>&price,long long &ans,vector<long long>&dp){\\n       long long tmp=sub[v];\\n    \\n        for(auto to:g[v]){\\n            if(to==p)continue;\\n           \\n            long long mx=0;\\n            int j=0;//to ensure we are checking just two childs\\n            for(auto it:g[v]){\\n                if(it==to){\\n                    continue;\\n              j++;}\\n                mx=max(mx,sub[it]);\\n                j++;\\n                if(j>2)break;\\n            }\\n            sub[v]=mx+price[v];\\n            dp[to]=max(sub[to]-price[to],mx+price[v]);\\n            reroot(to,v,g,price,ans,dp);\\n            sub[v]=tmp;\\n        }\\n       \\n    }\\n  \\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<int>g[n];\\n        \\n        for(auto it:edges){\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n        sub=vector<long long>(n);\\n        vector<long long>dp(n);// dpi denotes the answer if i is root\\n        solve(0,-1,g,price);\\n        \\n        for(int i=0;i<n;i++){\\n            sort(g[i].begin(),g[i].end(),comp);\\n        }\\n        \\n        long long ans=0;\\n        dp[0]=sub[0]-price[0];\\n        reroot(0,-1,g,price,ans,dp);\\n        \\n      for(int i=0;i<n;i++)ans=max(ans,dp[i]);\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n\\n// firstly i am precomputing the maximum path sum for each node (called sub) using dfs function assuming tree rooted at node 0.\\n// Now we are olny left with rerooting at all the nodes and get the maximum of all. I am storing it in dp \\n\\n//explanation of rerooting function\\nconsider the tree\\n           0\\n\\t\\t /   \\\\\\n      1       2\\n\\t/   \\\\    /  \\\\\\n 3      4  5    6\\n prices:= 1,2,3,4,5,6,7\\n \\n suppose we are at 0th node then we have to reroot at all the child of node 0 i.e.(1,2)\\n now suppose i go for node 2 then what i am doing that assume 2 is not a child of node 0 and calculate the maximum path sum for node 0.\\n \\n long long mx=0;\\n            for(auto it:g[v]){\\n                if(it==to)continue;\\n                mx=max(mx,sub[it]);\\n            }\\nnow it is quite simple that dp[2]=max(sub[2]-price[2],mx+price[2]);\\n dp[to]=max(sub[to]-price[to],mx+price[v]);\\n \\n //one thing to note that when we go gor node 2 the path sum value of node 0 (sub[0]) will change for that subtree that\\'s why i am doing\\n    sub[v]=mx+price[v];\\n\\t\\n\\tand after coming out of reroot call \\n\\tsetting it to the initial value(long long tmp=sub[v])\\n     sub[v]=tmp;\\n\\t \\n\\n\\nCODE:-\\n\\n  vector<long long>sub; \\nbool comp(int &i,int &j){\\n        return (sub[i]>sub[j]);\\n    }\\nclass Solution {\\npublic:\\n  \\n    \\n    long long solve(int v,int p,vector<int>g[],vector<int>&price){\\n        sub[v]=price[v];\\n        long long mx=0;\\n        for(auto to:g[v]){\\n            if(to==p)continue;\\n            mx=max(mx,solve(to,v,g,price));\\n        }\\n        sub[v]+=mx;\\n        return sub[v];\\n    }\\n    void reroot(int v,int p,vector<int>g[],vector<int>&price,long long &ans,vector<long long>&dp){\\n       long long tmp=sub[v];\\n    \\n        for(auto to:g[v]){\\n            if(to==p)continue;\\n           \\n            long long mx=0;\\n            int j=0;//to ensure we are checking just two childs\\n            for(auto it:g[v]){\\n                if(it==to){\\n                    continue;\\n              j++;}\\n                mx=max(mx,sub[it]);\\n                j++;\\n                if(j>2)break;\\n            }\\n            sub[v]=mx+price[v];\\n            dp[to]=max(sub[to]-price[to],mx+price[v]);\\n            reroot(to,v,g,price,ans,dp);\\n            sub[v]=tmp;\\n        }\\n       \\n    }\\n  \\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<int>g[n];\\n        \\n        for(auto it:edges){\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n        sub=vector<long long>(n);\\n        vector<long long>dp(n);// dpi denotes the answer if i is root\\n        solve(0,-1,g,price);\\n        \\n        for(int i=0;i<n;i++){\\n            sort(g[i].begin(),g[i].end(),comp);\\n        }\\n        \\n        long long ans=0;\\n        dp[0]=sub[0]-price[0];\\n        reroot(0,-1,g,price,ans,dp);\\n        \\n      for(int i=0;i<n;i++)ans=max(ans,dp[i]);\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053256,
                "title": "greatest-path-sum-problem-a-variation",
                "content": "**Observation**\\n`price` is positive integer, so:\\n1. max price sum path should be as long as possible => the path must go to a leaf, and the new root itself must also be qualified as a leaf\\n2. min price sum path must be only the new root, which is one end of the path\\n\\nFor (1), there is a boilerplate:\\n```\\nm = 0\\ndef rec(p):\\n\\tnonlocal m\\n\\ta = rec(p.left)\\n\\tb = rec(p.right)\\n\\tm = max(m, a + b + p.val)\\n\\treturn max(a, b) + p.val\\nrec(0)\\nreturn m\\n```\\nWe start from node `0` as the old root, get the values from sub-trees and try to combine them.  And then, instead of returning the combined value, we still return the max value while record the max of combined value all the way.\\n\\nNow, let\\'s take (2.) into account.  For each sub-tree, we need to return two values - \\n`a`. the max price sum, which means \"if the new root is not here\"\\n`b`. the max price sum minus a leaf price, which means \"if the new root is here\".\\n\\nWhen combining the values, we use `a + b + price[p]`, where `a` is from a sub-tree and `b` is from another sub-tree.  The path must go from one sub-tree to another sub-tree if there are two or more sub-trees.  It will not stop at anywhere because of Observation (1.).\\n\\n![image](https://assets.leetcode.com/users/images/4a013e57-ac2c-4941-a92c-aef68aacf574_1673853683.466824.png)\\n\\nWhat if a node has only one sub-tree?  In this case, the new root can be the current node `p`.  This is equivalent to have two sub-trees, one real, one fake, and let the fake sub-tree to have `b = -price[p]`.\\n\\nWritten in code, it would be like:\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        g = [[] for _ in range(n)]\\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n        \\n        m = 0\\n        def rec(p, pp):\\n            nonlocal m\\n            if len(g[p]) == 0:\\n                return (0, 0)\\n\\t\\t\\t# early return; not really necessary\\n            if len(g[p]) == 1 and pp == g[p][0]:\\n                return (price[p], 0)\\n            ma = 0\\n            mb = -price[p]\\n            for q in g[p]:\\n                if q == pp: continue\\n                a, b = rec(q, p)\\n                m = max(m, ma + b + price[p], mb + a + price[p])\\n                ma = max(ma, a)\\n                mb = max(mb, b)\\n            return (ma + price[p], mb + price[p])\\n        \\n        rec(0, 0)\\n        return m\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nm = 0\\ndef rec(p):\\n\\tnonlocal m\\n\\ta = rec(p.left)\\n\\tb = rec(p.right)\\n\\tm = max(m, a + b + p.val)\\n\\treturn max(a, b) + p.val\\nrec(0)\\nreturn m\\n```\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        g = [[] for _ in range(n)]\\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n        \\n        m = 0\\n        def rec(p, pp):\\n            nonlocal m\\n            if len(g[p]) == 0:\\n                return (0, 0)\\n\\t\\t\\t# early return; not really necessary\\n            if len(g[p]) == 1 and pp == g[p][0]:\\n                return (price[p], 0)\\n            ma = 0\\n            mb = -price[p]\\n            for q in g[p]:\\n                if q == pp: continue\\n                a, b = rec(q, p)\\n                m = max(m, ma + b + price[p], mb + a + price[p])\\n                ma = max(ma, a)\\n                mb = max(mb, b)\\n            return (ma + price[p], mb + price[p])\\n        \\n        rec(0, 0)\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052779,
                "title": "c-farthest-node-from-each-node-additional-practice-problems",
                "content": "# Difference Between Maximum and Minimum Price Sum\\n\\nThis is a standard tree problem where it is required find the farthest node from every node. At first glance, the problem seems difficult but with a few observations, it can be made simple. You can practice similar problems on CSES (check out [this](https://cses.fi/problemset/task/1131), [this](https://cses.fi/problemset/task/1132/) and [this](https://cses.fi/problemset/task/1133)). There are many that are similar in nature on Leetcode too.\\n\\n- For each node, we must find the distance to the farthest node.\\n- Start by finding the diameter of the tree. The diameter of a tree is the longest path between two leaf nodes. This can be done by starting a DFS/BFS at _any_ node and selecting the farthest node as a diameter endpoint. Let this node be `U`.\\n- Perform a DFS/BFS starting at node `U` and find the farthest node. This is the other diameter endpoint. Let this node be `V`.\\n- The farthest node from each node is the maximum distance from either of the diametric endpoints `U` or `V`. That is:\\n\\n```\\nmax_distance[i] = max(distance_from_diametric_endpoint_U[i], distance_from_diametric_endpoint_V[i])\\n```\\n\\n- We have to account for one more detail in this problem, and that is the minimum path sum which must be subtracted. This is simply a single node value (because more nodes have higher path sum). It must be a path endpoint (because you can\\'t remove a node in the middle of a path as it will no longer be a path) and there are two choices for each path (start and end nodes). Iterate over all nodes and find the maximum value by considering both path endpoints.\\n\\nTime Complexity: **O(n)**\\n\\nSpace Complexity: **O(n)**\\n\\n```cpp\\nclass Solution {\\n  public:\\n    long long maxOutput (int n, vector <vector <int>>& edges, vector <int>& price) {\\n      std::vector <std::vector <int>> graph (n);\\n      \\n      for (auto &e: edges) {\\n        graph[e[0]].push_back(e[1]);\\n        graph[e[1]].push_back(e[0]);\\n      }\\n      \\n      auto dfs = [&] (auto self, int u, std::vector <int64_t> &depth) -> void {\\n        for (int v: graph[u]) {\\n          if (depth[v] == -1) {\\n            depth[v] = depth[u] + price[v];\\n            self(self, v, depth);\\n          }\\n        }\\n      };\\n      \\n      std::vector <int64_t> depth_x (n, -1);\\n      depth_x[0] = price[0];\\n      dfs(dfs, 0, depth_x);\\n      \\n      auto u = std::max_element(depth_x.begin(), depth_x.end()) - depth_x.begin();\\n      \\n      std::vector <int64_t> depth_y (n, -1);\\n      depth_y[u] = price[u];\\n      dfs(dfs, u, depth_y);\\n      \\n      auto v = std::max_element(depth_y.begin(), depth_y.end()) - depth_y.begin();\\n      \\n      depth_x = std::vector <int64_t> (n, -1);\\n      depth_x[v] = price[v];\\n      dfs(dfs, v, depth_x);\\n      \\n      int64_t ans = 0;\\n      \\n      for (int i = 0; i < n; ++i) {\\n        ans = std::max(ans, depth_x[i] - price[i]);\\n        ans = std::max(ans, depth_y[i] - price[i]);\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nmax_distance[i] = max(distance_from_diametric_endpoint_U[i], distance_from_diametric_endpoint_V[i])\\n```\n```cpp\\nclass Solution {\\n  public:\\n    long long maxOutput (int n, vector <vector <int>>& edges, vector <int>& price) {\\n      std::vector <std::vector <int>> graph (n);\\n      \\n      for (auto &e: edges) {\\n        graph[e[0]].push_back(e[1]);\\n        graph[e[1]].push_back(e[0]);\\n      }\\n      \\n      auto dfs = [&] (auto self, int u, std::vector <int64_t> &depth) -> void {\\n        for (int v: graph[u]) {\\n          if (depth[v] == -1) {\\n            depth[v] = depth[u] + price[v];\\n            self(self, v, depth);\\n          }\\n        }\\n      };\\n      \\n      std::vector <int64_t> depth_x (n, -1);\\n      depth_x[0] = price[0];\\n      dfs(dfs, 0, depth_x);\\n      \\n      auto u = std::max_element(depth_x.begin(), depth_x.end()) - depth_x.begin();\\n      \\n      std::vector <int64_t> depth_y (n, -1);\\n      depth_y[u] = price[u];\\n      dfs(dfs, u, depth_y);\\n      \\n      auto v = std::max_element(depth_y.begin(), depth_y.end()) - depth_y.begin();\\n      \\n      depth_x = std::vector <int64_t> (n, -1);\\n      depth_x[v] = price[v];\\n      dfs(dfs, v, depth_x);\\n      \\n      int64_t ans = 0;\\n      \\n      for (int i = 0; i < n; ++i) {\\n        ans = std::max(ans, depth_x[i] - price[i]);\\n        ans = std::max(ans, depth_y[i] - price[i]);\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052773,
                "title": "c-dfs-memo",
                "content": "1. $O(n^2)$ Easy Solution (AC during contest)\\n```\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        using ll = long long;\\n        vector<vector<int>> adj(n);\\n        for (auto& e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<unordered_map<int, ll>> dp(n);\\n        ll ans = 0;\\n        function<ll(int, int)> dfs = [&] (int u, int p) {\\n            if (dp[u].count(p))\\n                return dp[u][p];\\n            ll ret = 0;\\n            for (int v: adj[u]) {\\n                if (v != p)\\n                    ret = max(ret, dfs(v, u));\\n            }\\n            return dp[u][p] = ret + price[u];\\n        };\\n        for (int i = 0; i < n; i++) {\\n            if (size(adj[i]) == 1)\\n                ans = max(ans, dfs(i, -1) - price[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n2. $O(n)$ Solution from [@jason7708](https://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/solutions/3052985/c-dfs-beats-100/)\\n```\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        using ll = long long;\\n        vector<vector<int>> adj(n);\\n        for (auto& e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        ll ans = 0;\\n        function<pair<ll, ll>(int, int)> dfs = [&] (int u, int p) {\\n            pair<ll, ll> ret = {price[u], 0};\\n            for (int v: adj[u]) {\\n                if (v != p) {\\n                    auto [a, b] = dfs(v, u);\\n                    ans = max(ans, max(ret.first + b, ret.second + a));\\n                    ret.first = max(ret.first, a + price[u]);\\n                    ret.second = max(ret.second, b + price[u]);\\n                }\\n            }\\n            return ret;\\n        };\\n        dfs(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        using ll = long long;\\n        vector<vector<int>> adj(n);\\n        for (auto& e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<unordered_map<int, ll>> dp(n);\\n        ll ans = 0;\\n        function<ll(int, int)> dfs = [&] (int u, int p) {\\n            if (dp[u].count(p))\\n                return dp[u][p];\\n            ll ret = 0;\\n            for (int v: adj[u]) {\\n                if (v != p)\\n                    ret = max(ret, dfs(v, u));\\n            }\\n            return dp[u][p] = ret + price[u];\\n        };\\n        for (int i = 0; i < n; i++) {\\n            if (size(adj[i]) == 1)\\n                ans = max(ans, dfs(i, -1) - price[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        using ll = long long;\\n        vector<vector<int>> adj(n);\\n        for (auto& e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        ll ans = 0;\\n        function<pair<ll, ll>(int, int)> dfs = [&] (int u, int p) {\\n            pair<ll, ll> ret = {price[u], 0};\\n            for (int v: adj[u]) {\\n                if (v != p) {\\n                    auto [a, b] = dfs(v, u);\\n                    ans = max(ans, max(ret.first + b, ret.second + a));\\n                    ret.first = max(ret.first, a + price[u]);\\n                    ret.second = max(ret.second, b + price[u]);\\n                }\\n            }\\n            return ret;\\n        };\\n        dfs(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052587,
                "title": "java-simple-dfs-memo",
                "content": "```Java\\nclass Solution {\\n\\tprivate long max;\\n\\tprivate ArrayList<Integer>[] tree;\\n\\tprivate int[] price;\\n\\tprivate long res;\\n\\tprivate boolean[] visited;\\n\\n\\n\\tpublic long maxOutput(int n, int[][] edges, int[] price) {\\n\\t\\tif (n == 1) return 0;\\n\\n\\t\\tthis.price = price;\\n\\t\\ttree = new ArrayList[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\ttree[i] = new ArrayList<>();\\n\\t\\t}\\n\\t\\tfor (int[] e : edges) {\\n\\t\\t\\ttree[e[0]].add(e[1]);\\n\\t\\t\\ttree[e[1]].add(e[0]);\\n\\t\\t}\\n\\n\\t\\tvisited = new boolean[n];\\n\\t\\tvisited[0] = true;\\n\\t\\tdfs(0);\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\t// return long[]{longest path with leaf, longest path without leaf}\\n\\tprivate long[] dfs(int node) {\\n\\t\\tif (tree[node].size() == 1 && node != 0) {\\n\\t\\t\\treturn new long[]{price[node], 0};\\n\\t\\t}\\n\\t\\tlong temp = res;\\n\\t\\tint i0 = -1, i1 = -1;   // child id of the longest path and path without leaf\\n\\t\\tlong l0 = 0, l1 = 0;    // the longest path with leaf and path without leaf\\n\\t\\tlong s0 = 0, s1 = 0;    // the 2nd longest\\n\\n\\t\\tfor (int child : tree[node]) {\\n\\t\\t\\tif (visited[child]) continue;\\n\\t\\t\\tvisited[child] = true;\\n\\t\\t\\tlong[] sub = dfs(child);\\n\\n\\t\\t\\tif (sub[0] >= l0) {\\n\\t\\t\\t\\ts0 = l0;\\n\\t\\t\\t\\tl0 = sub[0];\\n\\t\\t\\t\\ti0 = child;\\n\\t\\t\\t} else if (sub[0] > s0) {\\n\\t\\t\\t\\ts0 = sub[0];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (sub[1] >= l1) {\\n\\t\\t\\t\\ts1 = l1;\\n\\t\\t\\t\\tl1 = sub[1];\\n\\t\\t\\t\\ti1 = child;\\n\\t\\t\\t} else if (sub[1] > s1) {\\n\\t\\t\\t\\ts1 = sub[1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (s0 == 0) {\\n\\t\\t\\t// only one child. case: example 2\\n\\t\\t\\tres = Math.max(res, Math.max(l0, l1 + price[node]));\\n\\t\\t} else {\\n\\t\\t\\tlong path = i0 != i1 ? price[node] + l0 + l1 \\n\\t\\t\\t\\t: price[node] + Math.max(l0 + s1, s0 + l1);\\n\\t\\t\\tres = Math.max(res, path);\\n\\t\\t}\\n\\n\\t\\treturn new long[]{l0 + price[node], l1 + price[node]};\\n\\t}\\n}\\n/*\\n// this version is TLE after new test cases being added.\\nclass Solution {\\n    private long max;\\n    private ArrayList<Integer>[] tree;\\n    private int[] price;\\n    private HashMap<Long, Long> memo;\\n    \\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        this.price = price;\\n        memo = new HashMap<>();\\n        tree = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            tree[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            tree[e[0]].add(e[1]);\\n            tree[e[1]].add(e[0]);\\n        }\\n        \\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (tree[i].size() == 1) {\\n                long temp = dfs(-1, i);\\n                res = Math.max(res, temp - price[i]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n\\t//  return the length of the longest path on the subTree\\n    private long dfs(int parent, int node) {\\n        long key = (long)(parent + 1) * 1_000_000 + node;\\n        if (memo.containsKey(key)) return memo.get(key);\\n        \\n        long res = price[node];\\n        for (int child : tree[node]) {\\n            if (child != parent) {\\n                res = Math.max(res, price[node] + dfs(node, child));\\n            }\\n        }\\n        \\n        memo.put(key, res);\\n        return res;\\n    }\\n}\\n*/\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n\\tprivate long max;\\n\\tprivate ArrayList<Integer>[] tree;\\n\\tprivate int[] price;\\n\\tprivate long res;\\n\\tprivate boolean[] visited;\\n\\n\\n\\tpublic long maxOutput(int n, int[][] edges, int[] price) {\\n\\t\\tif (n == 1) return 0;\\n\\n\\t\\tthis.price = price;\\n\\t\\ttree = new ArrayList[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\ttree[i] = new ArrayList<>();\\n\\t\\t}\\n\\t\\tfor (int[] e : edges) {\\n\\t\\t\\ttree[e[0]].add(e[1]);\\n\\t\\t\\ttree[e[1]].add(e[0]);\\n\\t\\t}\\n\\n\\t\\tvisited = new boolean[n];\\n\\t\\tvisited[0] = true;\\n\\t\\tdfs(0);\\n\\n\\t\\treturn res;\\n\\t}\\n\\n\\t// return long[]{longest path with leaf, longest path without leaf}\\n\\tprivate long[] dfs(int node) {\\n\\t\\tif (tree[node].size() == 1 && node != 0) {\\n\\t\\t\\treturn new long[]{price[node], 0};\\n\\t\\t}\\n\\t\\tlong temp = res;\\n\\t\\tint i0 = -1, i1 = -1;   // child id of the longest path and path without leaf\\n\\t\\tlong l0 = 0, l1 = 0;    // the longest path with leaf and path without leaf\\n\\t\\tlong s0 = 0, s1 = 0;    // the 2nd longest\\n\\n\\t\\tfor (int child : tree[node]) {\\n\\t\\t\\tif (visited[child]) continue;\\n\\t\\t\\tvisited[child] = true;\\n\\t\\t\\tlong[] sub = dfs(child);\\n\\n\\t\\t\\tif (sub[0] >= l0) {\\n\\t\\t\\t\\ts0 = l0;\\n\\t\\t\\t\\tl0 = sub[0];\\n\\t\\t\\t\\ti0 = child;\\n\\t\\t\\t} else if (sub[0] > s0) {\\n\\t\\t\\t\\ts0 = sub[0];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (sub[1] >= l1) {\\n\\t\\t\\t\\ts1 = l1;\\n\\t\\t\\t\\tl1 = sub[1];\\n\\t\\t\\t\\ti1 = child;\\n\\t\\t\\t} else if (sub[1] > s1) {\\n\\t\\t\\t\\ts1 = sub[1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (s0 == 0) {\\n\\t\\t\\t// only one child. case: example 2\\n\\t\\t\\tres = Math.max(res, Math.max(l0, l1 + price[node]));\\n\\t\\t} else {\\n\\t\\t\\tlong path = i0 != i1 ? price[node] + l0 + l1 \\n\\t\\t\\t\\t: price[node] + Math.max(l0 + s1, s0 + l1);\\n\\t\\t\\tres = Math.max(res, path);\\n\\t\\t}\\n\\n\\t\\treturn new long[]{l0 + price[node], l1 + price[node]};\\n\\t}\\n}\\n/*\\n// this version is TLE after new test cases being added.\\nclass Solution {\\n    private long max;\\n    private ArrayList<Integer>[] tree;\\n    private int[] price;\\n    private HashMap<Long, Long> memo;\\n    \\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        this.price = price;\\n        memo = new HashMap<>();\\n        tree = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            tree[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            tree[e[0]].add(e[1]);\\n            tree[e[1]].add(e[0]);\\n        }\\n        \\n        long res = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (tree[i].size() == 1) {\\n                long temp = dfs(-1, i);\\n                res = Math.max(res, temp - price[i]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n\\t//  return the length of the longest path on the subTree\\n    private long dfs(int parent, int node) {\\n        long key = (long)(parent + 1) * 1_000_000 + node;\\n        if (memo.containsKey(key)) return memo.get(key);\\n        \\n        long res = price[node];\\n        for (int child : tree[node]) {\\n            if (child != parent) {\\n                res = Math.max(res, price[node] + dfs(node, child));\\n            }\\n        }\\n        \\n        memo.put(key, res);\\n        return res;\\n    }\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062470,
                "title": "python-3-14-lines-dfs-updated-t-m-90-100",
                "content": "My original submission was weak, and with the recently added test case, it went TLE. The comment below (thank you [@user7784J](/user7784J)) included a link from which I got the idea for a better way to approach the problem.\\n\\nWe assign a three-uple`state`to each node. the root and each leaf gets `(0,price,0)`, and each other link\\'s`state` is determined by the recurence relation in`dfs`. The figure below is for Example 1 in the problem\\'s description.\\n\\nBest way to figure it out is to trace it from the recurence relation.  The correct answer is`24`, which is `state[0]` for `node 1`. BTW, if you start from a root other than`0`, the `state` for some nodes may change, but the answer doesn\\'t.\\n\\n![Untitled 2.jpg](https://assets.leetcode.com/users/images/0ade3f2b-c683-486b-92c2-011aa1b77eb1_1674079396.9147189.jpeg)\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n\\n        g = defaultdict(list)\\n        for a, b in edges: g[a].append(b) ;  g[b].append(a)\\n\\n        def dfs(node1, node2 =-1):\\n            p = price[node1]\\n            state = (0, p, 0)\\n\\n            for n in g[node1]:\\n                if n == node2: continue\\n\\n                (a1, a2, a3), (b1, b2, b3) = state, dfs(n, node1)\\n                \\n                state = (max(a1, b1, a2 + b3, a3 + b2),\\n                         max(a2, b2 + p),\\n                         max(a3, b3 + p))\\n\\n            return state\\n\\n        if n <= 2: return sum(price) - min(price)\\n\\n        for node in range(n):\\n            if len(g[node]) > 1:\\n                return dfs(node)[0]\\n\\n```\\n[https://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/submissions/880805710/]()\\n```\\n```\\nOriginal post: \\n\\nI think this might be computing things twice (once each way); if so, I might work on it a little more later. Right now it barely squeaks through.\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        \\n        g = defaultdict(set)                            # construct the graph\\n        for a, b in edges: g[a].add(b) ;  g[b].add(a)\\n\\n        @lru_cache(None)\\n        def dfs(node1, node2):                          # recurse the tree node1 to node2\\n\\n            return max((dfs(n, node1) for n in g[node1]\\n                    if n != node2), default = 0) + price[node1]\\n\\n        return max(dfs(node, -1) - price[node] for node in range(n)) \\n                                                        # eval each node as root for max answer                                         \\n```\\n[https://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/submissions/878829009/](http://)\\n\\n\\n\\n\\n\\nI think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*), but I\\'m usually wrong when it comes to recursion.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n\\n        g = defaultdict(list)\\n        for a, b in edges: g[a].append(b) ;  g[b].append(a)\\n\\n        def dfs(node1, node2 =-1):\\n            p = price[node1]\\n            state = (0, p, 0)\\n\\n            for n in g[node1]:\\n                if n == node2: continue\\n\\n                (a1, a2, a3), (b1, b2, b3) = state, dfs(n, node1)\\n                \\n                state = (max(a1, b1, a2 + b3, a3 + b2),\\n                         max(a2, b2 + p),\\n                         max(a3, b3 + p))\\n\\n            return state\\n\\n        if n <= 2: return sum(price) - min(price)\\n\\n        for node in range(n):\\n            if len(g[node]) > 1:\\n                return dfs(node)[0]\\n\\n```\n```\\n```\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        \\n        g = defaultdict(set)                            # construct the graph\\n        for a, b in edges: g[a].add(b) ;  g[b].add(a)\\n\\n        @lru_cache(None)\\n        def dfs(node1, node2):                          # recurse the tree node1 to node2\\n\\n            return max((dfs(n, node1) for n in g[node1]\\n                    if n != node2), default = 0) + price[node1]\\n\\n        return max(dfs(node, -1) - price[node] for node in range(n)) \\n                                                        # eval each node as root for max answer                                         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055069,
                "title": "java-dfs-memoization-approach-complexities-explained",
                "content": "# Please Upvote :D\\n---\\n*This solution is inspired from **[shiva1718](https://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/solutions/3052821/java-using-dfs-weighted-directed-tree-with-comments/?orderBy=most_votes\\n)***\\n``` java []\\nclass Solution {\\n    // globally declaring data structure to store the adjacency\\n    private Map<Integer, Long>[] adj;\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        adj = new Map[n];   // initialising the adjacency map array\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new HashMap<>();\\n        }\\n        // populating the adjacency map array\\n        for (int[] e : edges) {\\n            adj[e[0]].put(e[1], 0L);\\n            adj[e[1]].put(e[0], 0L);\\n        }\\n\\n        long maxDiff = 0;   // to store the maximum difference\\n        // for each node from 0 -> n-1, check the maximum achievable difference\\n        for (int i = 0; i < n; i++) {\\n            long currDiff = dfs(i, -1, price) - price[i];   // difference between path sum and node price\\n            // our dfs will give us the maximum achievable sum of all possible paths as i (node) as our endpoint\\n            maxDiff = Math.max(maxDiff, currDiff);\\n        }\\n\\n        return maxDiff;     // return maximum difference\\n    }\\n\\n    private long dfs(int currNode, int parent, int[] price) {\\n        long maxPathSum = 0;    // to store the maximum path sum achieved at current node\\n        // check for child nodes connected to our current node (child are stores a key in the map)\\n        for (int child : adj[currNode].keySet()) {\\n            if (child == parent) {  // we don\\'t want to go back to our parent\\n                continue;           // so continue if condition is hit\\n            }\\n            // now we will check what is the maximum sum that has already been achieved at our child\\n            // map stores the node as key, and the maximum sum that is achievable at that node as an endpoint from every direction/path\\n            long maxSumFromChild = adj[currNode].get(child);\\n            if (maxSumFromChild == 0) {     // if that maximum child path sum was not already computed\\n                maxSumFromChild = dfs(child, currNode, price);  // we will computed it by calling dfs at that child node\\n                adj[currNode].put(child, maxSumFromChild);      // and we will put that maximum child sum by mapping it to the child node value\\n            }\\n\\n            // Now we will update the maxPathSum (of our current node) with the max sum from our current child\\n            // this updation will be done after fetching max child path sum for each child \\n            maxPathSum = Math.max(maxPathSum, maxSumFromChild);     \\n        }\\n        \\n        // finally we have the maximum acheivable child path sum from every child of our current node\\n        // so what is the max path sum for our current node? \\n        // it is the sum of the max child sum and price of our current node (which will be given by price[] array)\\n        return maxPathSum + price[currNode];    // return the maximum sum achieved from all directions as currentNode as our end point\\n        // it will also be utilised upon occasional backtracking (if child path sum is not already computed, dfs will be called otherwise not)\\n    }\\n}\\n```\\n---\\n### Time Complexity:\\nAt worst case it\\'d be $$O(n ^ 2)$$ but it is much better than that in general because we are not calling dfs for our node everytime. The call would be occasional, only when the sum of our node is not already computed we will call dfs. And as we will compute the node path sums, the requirement to call dfs for uncomputed node sums will decrease by a lot because we will have them already computed before. So the complexity kind of gets amotized to $$O(n)$$.\\n\\n---\\n### Space complexity: \\n$$O(n ^ 2)$$, because we are storing all the connected nodes attached to all the nodes of our graph.\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "``` java []\\nclass Solution {\\n    // globally declaring data structure to store the adjacency\\n    private Map<Integer, Long>[] adj;\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        adj = new Map[n];   // initialising the adjacency map array\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new HashMap<>();\\n        }\\n        // populating the adjacency map array\\n        for (int[] e : edges) {\\n            adj[e[0]].put(e[1], 0L);\\n            adj[e[1]].put(e[0], 0L);\\n        }\\n\\n        long maxDiff = 0;   // to store the maximum difference\\n        // for each node from 0 -> n-1, check the maximum achievable difference\\n        for (int i = 0; i < n; i++) {\\n            long currDiff = dfs(i, -1, price) - price[i];   // difference between path sum and node price\\n            // our dfs will give us the maximum achievable sum of all possible paths as i (node) as our endpoint\\n            maxDiff = Math.max(maxDiff, currDiff);\\n        }\\n\\n        return maxDiff;     // return maximum difference\\n    }\\n\\n    private long dfs(int currNode, int parent, int[] price) {\\n        long maxPathSum = 0;    // to store the maximum path sum achieved at current node\\n        // check for child nodes connected to our current node (child are stores a key in the map)\\n        for (int child : adj[currNode].keySet()) {\\n            if (child == parent) {  // we don\\'t want to go back to our parent\\n                continue;           // so continue if condition is hit\\n            }\\n            // now we will check what is the maximum sum that has already been achieved at our child\\n            // map stores the node as key, and the maximum sum that is achievable at that node as an endpoint from every direction/path\\n            long maxSumFromChild = adj[currNode].get(child);\\n            if (maxSumFromChild == 0) {     // if that maximum child path sum was not already computed\\n                maxSumFromChild = dfs(child, currNode, price);  // we will computed it by calling dfs at that child node\\n                adj[currNode].put(child, maxSumFromChild);      // and we will put that maximum child sum by mapping it to the child node value\\n            }\\n\\n            // Now we will update the maxPathSum (of our current node) with the max sum from our current child\\n            // this updation will be done after fetching max child path sum for each child \\n            maxPathSum = Math.max(maxPathSum, maxSumFromChild);     \\n        }\\n        \\n        // finally we have the maximum acheivable child path sum from every child of our current node\\n        // so what is the max path sum for our current node? \\n        // it is the sum of the max child sum and price of our current node (which will be given by price[] array)\\n        return maxPathSum + price[currNode];    // return the maximum sum achieved from all directions as currentNode as our end point\\n        // it will also be utilised upon occasional backtracking (if child path sum is not already computed, dfs will be called otherwise not)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903399,
                "title": "c-simple-dfs-calls",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    #define pii pair<ll,ll>\\n    #define ff first\\n    #define ss second\\n    long long dfs(int s,int par,vector<vector<int>>& g,vector<int> &p,vector<pii> &val,vector<int> &vv)\\n    {\\n        p[s]=par;\\n        vector<long long> a;\\n        for(auto i:g[s])\\n        {\\n            if(i!=par)\\n            {\\n                long long t;\\n                t=dfs(i,s,g,p,val,vv);\\n                a.push_back(t);\\n            }\\n        }\\n        sort(a.begin(),a.end(),greater<long long> ());\\n        long long x=0,y=0;\\n        if(a.size()>0)\\n        {\\n            x=a[0];\\n        }\\n        if(a.size()>1)\\n        {\\n            y=a[1];\\n        }\\n        val[s]={x,y};\\n        return x+=vv[s];\\n    }\\n    void dfs1(int s,int par,vector<vector<int>>& g,vector<int> &p,vector<pii> &val,vector<int> &vv,ll &ans)\\n    {\\n        \\n        ans=max(val[s].ff,ans);\\n        if(par!=-1)\\n        {\\n            ll vm=vv[par];\\n            if(val[par].ff==val[s].ff+vv[s])\\n            {\\n                vm+=val[par].ss;\\n            }\\n            else{\\n                vm+=val[par].ff;\\n            }\\n            if(val[s].ff<vm)\\n            {\\n                ll tt=val[s].ff;\\n                val[s].ff=vm;\\n                val[s].ss=tt;\\n            }\\n            else if(val[s].ss<vm)\\n            {\\n                val[s].ss=vm;\\n            }\\n            ans=max(ans,vm);\\n        }\\n        // cout<<ans<<\" \"<<s<<endl;\\n        for(auto i:g[s])\\n        {\\n            if(i!=par)\\n            {\\n                dfs1(i,s,g,p,val,vv,ans);\\n            }\\n        }\\n\\n\\n\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<int> p(n,-1);\\n        vector<pii> val(n);\\n        vector<vector<int>> g(n);\\n        for(auto& i:edges)\\n        {\\n            int u=i[0];\\n            int v=i[1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        int z=dfs(0,-1,g,p,val,price);\\n        ll ans=0;\\n        dfs1(0,-1,g,p,val,price,ans);\\n        for(auto i:val)\\n        {\\n            // cout<<i.ff<<\" \"<<i.ss<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    #define pii pair<ll,ll>\\n    #define ff first\\n    #define ss second\\n    long long dfs(int s,int par,vector<vector<int>>& g,vector<int> &p,vector<pii> &val,vector<int> &vv)\\n    {\\n        p[s]=par;\\n        vector<long long> a;\\n        for(auto i:g[s])\\n        {\\n            if(i!=par)\\n            {\\n                long long t;\\n                t=dfs(i,s,g,p,val,vv);\\n                a.push_back(t);\\n            }\\n        }\\n        sort(a.begin(),a.end(),greater<long long> ());\\n        long long x=0,y=0;\\n        if(a.size()>0)\\n        {\\n            x=a[0];\\n        }\\n        if(a.size()>1)\\n        {\\n            y=a[1];\\n        }\\n        val[s]={x,y};\\n        return x+=vv[s];\\n    }\\n    void dfs1(int s,int par,vector<vector<int>>& g,vector<int> &p,vector<pii> &val,vector<int> &vv,ll &ans)\\n    {\\n        \\n        ans=max(val[s].ff,ans);\\n        if(par!=-1)\\n        {\\n            ll vm=vv[par];\\n            if(val[par].ff==val[s].ff+vv[s])\\n            {\\n                vm+=val[par].ss;\\n            }\\n            else{\\n                vm+=val[par].ff;\\n            }\\n            if(val[s].ff<vm)\\n            {\\n                ll tt=val[s].ff;\\n                val[s].ff=vm;\\n                val[s].ss=tt;\\n            }\\n            else if(val[s].ss<vm)\\n            {\\n                val[s].ss=vm;\\n            }\\n            ans=max(ans,vm);\\n        }\\n        // cout<<ans<<\" \"<<s<<endl;\\n        for(auto i:g[s])\\n        {\\n            if(i!=par)\\n            {\\n                dfs1(i,s,g,p,val,vv,ans);\\n            }\\n        }\\n\\n\\n\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<int> p(n,-1);\\n        vector<pii> val(n);\\n        vector<vector<int>> g(n);\\n        for(auto& i:edges)\\n        {\\n            int u=i[0];\\n            int v=i[1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        int z=dfs(0,-1,g,p,val,price);\\n        ll ans=0;\\n        dfs1(0,-1,g,p,val,price,ans);\\n        for(auto i:val)\\n        {\\n            // cout<<i.ff<<\" \"<<i.ss<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3089833,
                "title": "c-root-shifting-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n    int dfs(vector<vector<int>>& nums,vector<int>& val,vector<long long>& sum,int in,int p){\\n        sum[in] = val[in];\\n        long long re = 0;\\n        for(int i = 0; i<(int)nums[in].size();++i){\\n            int j = nums[in][i];\\n            if(j!=p){\\n                long long k = dfs(nums,val,sum,j,in);\\n                re = max(re,k);\\n            }\\n        }\\n        return sum[in] = sum[in]+re;\\n    }\\n    void dfs2(vector<vector<int>> &nums,vector<int>& val,vector<long long>& sum,int in,int p,long long psum){\\n        psum+=val[in];\\n        ans = max(ans,max(psum,sum[in])-val[in]);\\n        priority_queue<pair<long long,long long>> q;\\n        for(int i = 0; i<nums[in].size();++i){\\n            int j = nums[in][i];\\n            if(j!=p){\\n                q.push({val[in]+sum[j],j});\\n            }\\n        }\\n        for(int i = 0; i<nums[in].size();++i){\\n            int j = nums[in][i];\\n            if(j!=p && q.size()){\\n                long long k = psum;\\n                if(q.top().second==j){\\n                    pair<int,int> p = q.top(); q.pop();\\n                    if(q.size()) k = max(k,q.top().first);\\n                    q.push(p);\\n                }\\n                else k = max(k,q.top().first);\\n                dfs2(nums,val,sum,j,in,k);\\n            }\\n        }\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& arr, vector<int>& cost) {\\n        vector<vector<int>> nums(n+1);\\n        for(int i = 0; i<arr.size(); ++i){\\n            nums[arr[i][0]].push_back(arr[i][1]);\\n            nums[arr[i][1]].push_back(arr[i][0]);\\n        }\\n        vector<long long> dp(n+1,0);\\n        dfs(nums,cost,dp,0,-1);\\n        dfs2(nums,cost,dp,0,-1,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n    int dfs(vector<vector<int>>& nums,vector<int>& val,vector<long long>& sum,int in,int p){\\n        sum[in] = val[in];\\n        long long re = 0;\\n        for(int i = 0; i<(int)nums[in].size();++i){\\n            int j = nums[in][i];\\n            if(j!=p){\\n                long long k = dfs(nums,val,sum,j,in);\\n                re = max(re,k);\\n            }\\n        }\\n        return sum[in] = sum[in]+re;\\n    }\\n    void dfs2(vector<vector<int>> &nums,vector<int>& val,vector<long long>& sum,int in,int p,long long psum){\\n        psum+=val[in];\\n        ans = max(ans,max(psum,sum[in])-val[in]);\\n        priority_queue<pair<long long,long long>> q;\\n        for(int i = 0; i<nums[in].size();++i){\\n            int j = nums[in][i];\\n            if(j!=p){\\n                q.push({val[in]+sum[j],j});\\n            }\\n        }\\n        for(int i = 0; i<nums[in].size();++i){\\n            int j = nums[in][i];\\n            if(j!=p && q.size()){\\n                long long k = psum;\\n                if(q.top().second==j){\\n                    pair<int,int> p = q.top(); q.pop();\\n                    if(q.size()) k = max(k,q.top().first);\\n                    q.push(p);\\n                }\\n                else k = max(k,q.top().first);\\n                dfs2(nums,val,sum,j,in,k);\\n            }\\n        }\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& arr, vector<int>& cost) {\\n        vector<vector<int>> nums(n+1);\\n        for(int i = 0; i<arr.size(); ++i){\\n            nums[arr[i][0]].push_back(arr[i][1]);\\n            nums[arr[i][1]].push_back(arr[i][0]);\\n        }\\n        vector<long long> dp(n+1,0);\\n        dfs(nums,cost,dp,0,-1);\\n        dfs2(nums,cost,dp,0,-1,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068590,
                "title": "thought-process-1-dfs-o-n",
                "content": "(1) intuitively, try every node as root, find max cost of each path from root\\n\\n(2) since all nodes\\'s price is positive, so minimum path sum will be the root itself, and problems become finding max sum of each path from root substract root\\'s price.\\nwe can do that with a single dfs, where each node returns the max path sum. time: `n`\\n```\\n     2:7*\\n     / \\n    1:8*\\n   / \\\\\\n  0:9 3:6*\\n       /  \\\\\\n     4:10* 5:5\\n```\\n(3) combining (1), (2), time:`O(n*n)`\\n\\n(4) can we re-use information from single dfs?\\n\\n(5) as we can observe, if we start from `0` as root, when we get to `1`, we can have information of each max sum path of childs, and each node can be root, so we can see if these paths can form paths of nodes within path as roots\\n```\\n   0\\n    \\\\\\n     1* <-\\n    / \\\\ \\n   2*  3*\\n      / \\\\\\n     4*  5\\n```\\n* cases\\n```\\ncase 1          case 2          case 3          case 4\\n   0               0               0               0\\n    \\\\               \\\\               \\\\               \\\\           \\n     1r <-           1* <-           1r <-           1* <-\\n    / \\\\             / \\\\             / \\\\             / \\\\\\n   2   3*          2   3*          2   3*          2   3r      \\n      / \\\\             / \\\\             / \\\\             / \\\\\\n     4*  5           4r  5           4   5           4   5\\n\\ncase 5          case 6          case 7          case 8\\n   0               0               0               0\\n    \\\\               \\\\               \\\\               \\\\           \\n     1r <-           1* <-           1* <-           1* <-\\n    / \\\\             / \\\\             / \\\\             / \\\\\\n   2*  3           2r  3           2r  3*          2*  3r      \\n      / \\\\             / \\\\             / \\\\             / \\\\\\n     4   5           4   5           4   5           4   5\\n\\ncase 9          case 10\\n   0               0\\n    \\\\               \\\\\\n     1* <-           1* <-\\n    / \\\\             / \\\\\\n   2r  3*          2*  3*\\n      / \\\\             / \\\\\\n     4*  5           4r  5\\n```\\n\\n(6) since we already got max sum path from all childs, the sum of merging these max paths to form new paths(case 9,10) will be larger than any other cases, so that they can be skipped\\n\\n(7) if there\\'s only 1 path from the only child, that sum path will be max. e.g.\\n```\\ncase 11          case 12\\n   0r <-           0* <-\\n    \\\\               \\\\\\n     1*              1*  \\n    / \\\\             / \\\\\\n   2   3*          2   3*\\n      / \\\\             / \\\\\\n     4*  5           4r  5\\n```\\n\\n(8) to sum up (6)(7), we can only consider merged max sum path from childs for each node as max cost candidate\\n\\n(9) to ensure we consider max sum path with ending node as root and non-root from childs, we need to record both cases in each node, \\nalso, in merging process, we need to ensure both path are from different child.\\nwe can do that as recording max 2 paths of 2 cases if max of both cases are overlapped, and do merging as \"max path with ending node as root\" with \"2nd max path with ending node as non-root\"\\ne.g. \\n```\\n   a) + d)         b) + c)\\n      0*              0*\\n     / \\\\             / \\\\\\n    1*  2*          1*  2*\\n   /     \\\\         /     \\\\\\n  3r      4*      3*      4r\\n\\nassuming:\\na) max sub path contain root, 1-3\\nb) max sub path not contain root, 1-3\\nc) 2nd max sub path contain root, 2-4\\nd) 2nd max sub path not contain root, 2-4\\n\\n```\\n\\n(10) so each node only process once and 2 cases (case 9,10 or case 11,12) is required, so time:`O(n)` = `2n`\\n\\n(11) to simplify code, although, processing more candidate paths, we can calculate \"max path with ending node as root\" by adding current node with child path and store for later merging while iterating childs, this can ensure we are merging sum paths of different child and including max ones, same applies to non-root paths.\\ne.g.\\n```\\n    0*\\n  / | \\\\\\n 1r 2  3\\n ^\\ncurrent child:1  \\nprevious max path=none, merge as 1-0\\n\\n    0*\\n  / | \\\\\\n 1r 2* 3\\n -  ^\\ncurrrent child:2\\nprevious max path=1, merge as 1-0-2\\n\\n    0*\\n  / | \\\\\\n 1  2r 3*\\n -  -  ^\\ncurrrent child:3\\nprevious max path=2, merge as 2-0-3\\n```\\n\\n\\n# Code\\n(9)\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        \\n        def maintain_2_max_paths(sum_path, sum_path_maxs, node):\\n            if len(sum_path_maxs) == 2 and sum_path > sum_path_maxs[0][0]:\\n                    heapq.heappop(sum_path_maxs)\\n            if len(sum_path_maxs) < 2:\\n                heapq.heappush(sum_path_maxs, (sum_path, node))\\n\\n        def dfs(node, root, edges_dict, visited):\\n            \"\"\" ret: sum_path_leaf_max, sum_path_root_max \"\"\"\\n            sum_path_sub_leaf_maxs = [] # list[i]=(sum_path_sub_leaf_max, node_nx)\\n            sum_path_sub_root_maxs = []\\n            for node_nx in [ node_nx for node_nx in edges_dict[node] if node_nx not in visited ]:\\n                visited.add(node_nx)\\n                sum_path_sub_leaf, sum_path_sub_root = dfs(node_nx, root, edges_dict, visited)\\n                maintain_2_max_paths(sum_path_sub_leaf, sum_path_sub_leaf_maxs, node_nx)\\n                maintain_2_max_paths(sum_path_sub_root, sum_path_sub_root_maxs, node_nx)\\n            # cur(root/leaf)\\n            if len(sum_path_sub_root_maxs) == 0:\\n                return price[node], 0\\n            sum_path_sub_root_max1, node_path_sub_root_max1 = sum_path_sub_root_maxs[-1]\\n            sum_path_sub_leaf_max1, node_path_sub_leaf_max1 = sum_path_sub_leaf_maxs[-1]\\n            sum_path_sub_root_max2, node_path_sub_root_max2 = sum_path_sub_root_maxs[0]\\n            sum_path_sub_leaf_max2, node_path_sub_leaf_max2 = sum_path_sub_leaf_maxs[0]\\n            # cur(root/leaf) + sub(root/leaf)\\n            if len(sum_path_sub_root_maxs) == 1 and node == root:\\n                self.cost_max = max(self.cost_max, 0 + sum_path_sub_leaf_max1)\\n                self.cost_max = max(self.cost_max, price[node] + sum_path_sub_root_max1)\\n            # sub(root/leaf) + cur + sub(root/leaf)\\n            elif len(sum_path_sub_root_maxs) == 2:\\n                # path of max sub root != max sub leaf\\n                if node_path_sub_root_max1 != node_path_sub_leaf_max1:\\n                    self.cost_max = max(self.cost_max, sum_path_sub_root_max1 + price[node] + sum_path_sub_leaf_max1)\\n                # path of max sub root == max sub leaf\\n                else:\\n                    self.cost_max = max(self.cost_max, sum_path_sub_root_max1 + price[node] + sum_path_sub_leaf_max2)\\n                    self.cost_max = max(self.cost_max, sum_path_sub_root_max2 + price[node] + sum_path_sub_leaf_max1)\\n            return sum_path_sub_leaf_max1+price[node], sum_path_sub_root_max1+price[node]\\n        \\n        self.cost_max = 0\\n        edges_dict = defaultdict(set)\\n        for v1, v2 in edges:\\n            edges_dict[v1].add(v2)\\n            edges_dict[v2].add(v1)\\n        \\n        visited = {0}\\n        dfs(0, 0, edges_dict, visited)\\n        return self.cost_max\\n```\\n\\n(11)\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        \\n        def dfs(node, edges_dict, visited):\\n            \"\"\" ret: sum_path_root, sum_path_leaf \"\"\"\\n            sum_path_root_max, sum_path_leaf_max = 0, price[node]\\n            for node_nx in edges_dict[node]:\\n                if node_nx in visited:\\n                    continue\\n                visited.add(node_nx)\\n                sum_sub_path_root, sum_sub_path_leaf = dfs(node_nx, edges_dict, visited)\\n                # sub path as root + (cur + max of other sub path as leaf)\\n                self.cost_max = max(self.cost_max, sum_sub_path_root + sum_path_leaf_max)\\n                # sub path as leaf + (cur + max of other sub path as root)\\n                self.cost_max = max(self.cost_max, sum_sub_path_leaf + sum_path_root_max)\\n                sum_path_root_max = max(sum_path_root_max, sum_sub_path_root + price[node])\\n                sum_path_leaf_max = max(sum_path_leaf_max, sum_sub_path_leaf + price[node])\\n            return sum_path_root_max, sum_path_leaf_max\\n        \\n        # main\\n        self.cost_max = 0\\n        edges_dict = defaultdict(set)\\n        for v1, v2 in edges:\\n            edges_dict[v1].add(v2)\\n            edges_dict[v2].add(v1)\\n        \\n        visited = {0}\\n        dfs(0, edges_dict, visited)\\n        return self.cost_max\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n     2:7*\\n     / \\n    1:8*\\n   / \\\\\\n  0:9 3:6*\\n       /  \\\\\\n     4:10* 5:5\\n```\n```\\n   0\\n    \\\\\\n     1* <-\\n    / \\\\ \\n   2*  3*\\n      / \\\\\\n     4*  5\\n```\n```\\ncase 1          case 2          case 3          case 4\\n   0               0               0               0\\n    \\\\               \\\\               \\\\               \\\\           \\n     1r <-           1* <-           1r <-           1* <-\\n    / \\\\             / \\\\             / \\\\             / \\\\\\n   2   3*          2   3*          2   3*          2   3r      \\n      / \\\\             / \\\\             / \\\\             / \\\\\\n     4*  5           4r  5           4   5           4   5\\n\\ncase 5          case 6          case 7          case 8\\n   0               0               0               0\\n    \\\\               \\\\               \\\\               \\\\           \\n     1r <-           1* <-           1* <-           1* <-\\n    / \\\\             / \\\\             / \\\\             / \\\\\\n   2*  3           2r  3           2r  3*          2*  3r      \\n      / \\\\             / \\\\             / \\\\             / \\\\\\n     4   5           4   5           4   5           4   5\\n\\ncase 9          case 10\\n   0               0\\n    \\\\               \\\\\\n     1* <-           1* <-\\n    / \\\\             / \\\\\\n   2r  3*          2*  3*\\n      / \\\\             / \\\\\\n     4*  5           4r  5\\n```\n```\\ncase 11          case 12\\n   0r <-           0* <-\\n    \\\\               \\\\\\n     1*              1*  \\n    / \\\\             / \\\\\\n   2   3*          2   3*\\n      / \\\\             / \\\\\\n     4*  5           4r  5\\n```\n```\\n   a) + d)         b) + c)\\n      0*              0*\\n     / \\\\             / \\\\\\n    1*  2*          1*  2*\\n   /     \\\\         /     \\\\\\n  3r      4*      3*      4r\\n\\nassuming:\\na) max sub path contain root, 1-3\\nb) max sub path not contain root, 1-3\\nc) 2nd max sub path contain root, 2-4\\nd) 2nd max sub path not contain root, 2-4\\n\\n```\n```\\n    0*\\n  / | \\\\\\n 1r 2  3\\n ^\\ncurrent child:1  \\nprevious max path=none, merge as 1-0\\n\\n    0*\\n  / | \\\\\\n 1r 2* 3\\n -  ^\\ncurrrent child:2\\nprevious max path=1, merge as 1-0-2\\n\\n    0*\\n  / | \\\\\\n 1  2r 3*\\n -  -  ^\\ncurrrent child:3\\nprevious max path=2, merge as 2-0-3\\n```\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        \\n        def maintain_2_max_paths(sum_path, sum_path_maxs, node):\\n            if len(sum_path_maxs) == 2 and sum_path > sum_path_maxs[0][0]:\\n                    heapq.heappop(sum_path_maxs)\\n            if len(sum_path_maxs) < 2:\\n                heapq.heappush(sum_path_maxs, (sum_path, node))\\n\\n        def dfs(node, root, edges_dict, visited):\\n            \"\"\" ret: sum_path_leaf_max, sum_path_root_max \"\"\"\\n            sum_path_sub_leaf_maxs = [] # list[i]=(sum_path_sub_leaf_max, node_nx)\\n            sum_path_sub_root_maxs = []\\n            for node_nx in [ node_nx for node_nx in edges_dict[node] if node_nx not in visited ]:\\n                visited.add(node_nx)\\n                sum_path_sub_leaf, sum_path_sub_root = dfs(node_nx, root, edges_dict, visited)\\n                maintain_2_max_paths(sum_path_sub_leaf, sum_path_sub_leaf_maxs, node_nx)\\n                maintain_2_max_paths(sum_path_sub_root, sum_path_sub_root_maxs, node_nx)\\n            # cur(root/leaf)\\n            if len(sum_path_sub_root_maxs) == 0:\\n                return price[node], 0\\n            sum_path_sub_root_max1, node_path_sub_root_max1 = sum_path_sub_root_maxs[-1]\\n            sum_path_sub_leaf_max1, node_path_sub_leaf_max1 = sum_path_sub_leaf_maxs[-1]\\n            sum_path_sub_root_max2, node_path_sub_root_max2 = sum_path_sub_root_maxs[0]\\n            sum_path_sub_leaf_max2, node_path_sub_leaf_max2 = sum_path_sub_leaf_maxs[0]\\n            # cur(root/leaf) + sub(root/leaf)\\n            if len(sum_path_sub_root_maxs) == 1 and node == root:\\n                self.cost_max = max(self.cost_max, 0 + sum_path_sub_leaf_max1)\\n                self.cost_max = max(self.cost_max, price[node] + sum_path_sub_root_max1)\\n            # sub(root/leaf) + cur + sub(root/leaf)\\n            elif len(sum_path_sub_root_maxs) == 2:\\n                # path of max sub root != max sub leaf\\n                if node_path_sub_root_max1 != node_path_sub_leaf_max1:\\n                    self.cost_max = max(self.cost_max, sum_path_sub_root_max1 + price[node] + sum_path_sub_leaf_max1)\\n                # path of max sub root == max sub leaf\\n                else:\\n                    self.cost_max = max(self.cost_max, sum_path_sub_root_max1 + price[node] + sum_path_sub_leaf_max2)\\n                    self.cost_max = max(self.cost_max, sum_path_sub_root_max2 + price[node] + sum_path_sub_leaf_max1)\\n            return sum_path_sub_leaf_max1+price[node], sum_path_sub_root_max1+price[node]\\n        \\n        self.cost_max = 0\\n        edges_dict = defaultdict(set)\\n        for v1, v2 in edges:\\n            edges_dict[v1].add(v2)\\n            edges_dict[v2].add(v1)\\n        \\n        visited = {0}\\n        dfs(0, 0, edges_dict, visited)\\n        return self.cost_max\\n```\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        \\n        def dfs(node, edges_dict, visited):\\n            \"\"\" ret: sum_path_root, sum_path_leaf \"\"\"\\n            sum_path_root_max, sum_path_leaf_max = 0, price[node]\\n            for node_nx in edges_dict[node]:\\n                if node_nx in visited:\\n                    continue\\n                visited.add(node_nx)\\n                sum_sub_path_root, sum_sub_path_leaf = dfs(node_nx, edges_dict, visited)\\n                # sub path as root + (cur + max of other sub path as leaf)\\n                self.cost_max = max(self.cost_max, sum_sub_path_root + sum_path_leaf_max)\\n                # sub path as leaf + (cur + max of other sub path as root)\\n                self.cost_max = max(self.cost_max, sum_sub_path_leaf + sum_path_root_max)\\n                sum_path_root_max = max(sum_path_root_max, sum_sub_path_root + price[node])\\n                sum_path_leaf_max = max(sum_path_leaf_max, sum_sub_path_leaf + price[node])\\n            return sum_path_root_max, sum_path_leaf_max\\n        \\n        # main\\n        self.cost_max = 0\\n        edges_dict = defaultdict(set)\\n        for v1, v2 in edges:\\n            edges_dict[v1].add(v2)\\n            edges_dict[v2].add(v1)\\n        \\n        visited = {0}\\n        dfs(0, edges_dict, visited)\\n        return self.cost_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061743,
                "title": "python-dfs-traverse-similar-to-the-maximum-path-sum-problem-explained",
                "content": "This problem is similar to the \"maximum path sum\" problem.\\n\\nWe pick any node, and DFS traverse the graph.\\n\\nFor each of the visiting node, we need to get **(1) the maximum path sum with the end node value; and (2) the maximum path sum without the end value**.\\n\\nSee the details in code:\\n\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        # it is the same problem as the finding the maximum path sum of a tree\\n        \\n        # step 1, build the graph\\n        self.G = collections.defaultdict(list)\\n        for s, e in edges:\\n            self.G[s].append(e)\\n            self.G[e].append(s)\\n\\n        self.visited = set()\\n        self.price = price\\n        self.ans = 0\\n\\n        # step 2, start from a random node and DFS traverse the graph\\n        #   the maximum path sum will be updated during the traversal, and we can\\n        #   return the result after the traversal is done.\\n        self.dfs(0)\\n        \\n        # Since we are using the min heap to track the maximum, we need to return - self.ans\\n        return -self.ans\\n\\n    \\n    def dfs(self, idx):\\n        self.visited.add(idx)\\n\\n        ps_f_list, ps_p_list = [], []\\n\\n        for nidx in self.G[idx]:\\n            # for each visiting child we need to get:\\n            # (1) the maximum path sum with the end node\\n            # (2) the maximum path sum without the end node\\n            # We are calculating the difference between maximum path sum and minimum path sum,\\n            # the price is always postive, therefore, the minimum path sum is always the root value. When we find a path sum, the maximum difference is the path sum - root value.\\n            # The root value can be at any end of this path.\\n            # Thus, we need to track two path sum: one is with the end node value, one is not.\\n            if nidx not in self.visited:\\n                ps_full, ps_partial = self.dfs(nidx)\\n                heapq.heappush(ps_f_list, (ps_full, nidx))\\n                heapq.heappush(ps_p_list, (ps_partial, nidx))\\n\\n        max_val = 0\\n        if len(ps_f_list) == 1:\\n            ps_f_max, _ = heapq.heappop(ps_f_list)\\n            ps_p_max, _ = heapq.heappop(ps_p_list)\\n            max_val = min(ps_f_max, ps_p_max - self.price[idx])\\n            fp_max, pp_max = ps_f_max - self.price[idx], ps_p_max - self.price[idx]\\n        elif len(ps_f_list) > 1:\\n            ps_f_max, fm_idx = heapq.heappop(ps_f_list)\\n            ps_p_max, pm_idx = heapq.heappop(ps_p_list)\\n            if fm_idx != pm_idx:\\n                max_val = ps_f_max + ps_p_max - self.price[idx]\\n                fp_max, pp_max = ps_f_max - self.price[idx], ps_p_max - self.price[idx]\\n            else:\\n                # get the second bigest price\\n                ps_f_max_2, _ = heapq.heappop(ps_f_list)\\n                ps_p_max_2, _ = heapq.heappop(ps_p_list)\\n                max_val = min(ps_f_max + ps_p_max_2, ps_f_max_2 + ps_p_max) - self.price[idx]\\n                fp_max, pp_max = ps_f_max - self.price[idx], ps_p_max - self.price[idx]\\n        else:\\n            fp_max, pp_max = -self.price[idx], 0\\n\\n        if max_val < self.ans:\\n            self.ans = max_val\\n\\n        return fp_max, pp_max\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        # it is the same problem as the finding the maximum path sum of a tree\\n        \\n        # step 1, build the graph\\n        self.G = collections.defaultdict(list)\\n        for s, e in edges:\\n            self.G[s].append(e)\\n            self.G[e].append(s)\\n\\n        self.visited = set()\\n        self.price = price\\n        self.ans = 0\\n\\n        # step 2, start from a random node and DFS traverse the graph\\n        #   the maximum path sum will be updated during the traversal, and we can\\n        #   return the result after the traversal is done.\\n        self.dfs(0)\\n        \\n        # Since we are using the min heap to track the maximum, we need to return - self.ans\\n        return -self.ans\\n\\n    \\n    def dfs(self, idx):\\n        self.visited.add(idx)\\n\\n        ps_f_list, ps_p_list = [], []\\n\\n        for nidx in self.G[idx]:\\n            # for each visiting child we need to get:\\n            # (1) the maximum path sum with the end node\\n            # (2) the maximum path sum without the end node\\n            # We are calculating the difference between maximum path sum and minimum path sum,\\n            # the price is always postive, therefore, the minimum path sum is always the root value. When we find a path sum, the maximum difference is the path sum - root value.\\n            # The root value can be at any end of this path.\\n            # Thus, we need to track two path sum: one is with the end node value, one is not.\\n            if nidx not in self.visited:\\n                ps_full, ps_partial = self.dfs(nidx)\\n                heapq.heappush(ps_f_list, (ps_full, nidx))\\n                heapq.heappush(ps_p_list, (ps_partial, nidx))\\n\\n        max_val = 0\\n        if len(ps_f_list) == 1:\\n            ps_f_max, _ = heapq.heappop(ps_f_list)\\n            ps_p_max, _ = heapq.heappop(ps_p_list)\\n            max_val = min(ps_f_max, ps_p_max - self.price[idx])\\n            fp_max, pp_max = ps_f_max - self.price[idx], ps_p_max - self.price[idx]\\n        elif len(ps_f_list) > 1:\\n            ps_f_max, fm_idx = heapq.heappop(ps_f_list)\\n            ps_p_max, pm_idx = heapq.heappop(ps_p_list)\\n            if fm_idx != pm_idx:\\n                max_val = ps_f_max + ps_p_max - self.price[idx]\\n                fp_max, pp_max = ps_f_max - self.price[idx], ps_p_max - self.price[idx]\\n            else:\\n                # get the second bigest price\\n                ps_f_max_2, _ = heapq.heappop(ps_f_list)\\n                ps_p_max_2, _ = heapq.heappop(ps_p_list)\\n                max_val = min(ps_f_max + ps_p_max_2, ps_f_max_2 + ps_p_max) - self.price[idx]\\n                fp_max, pp_max = ps_f_max - self.price[idx], ps_p_max - self.price[idx]\\n        else:\\n            fp_max, pp_max = -self.price[idx], 0\\n\\n        if max_val < self.ans:\\n            self.ans = max_val\\n\\n        return fp_max, pp_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053156,
                "title": "very-simple-dfs-dp-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAssuming any of the nodes can be root, we will check for each node.\\nFor any node:\\n    Mininum sum= node.val (as -ve numbers are not present)\\n    Maximum sum= node.val + max of all the paths through children ie. Maximum Sum (child) \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe tree can be though of as an undirected graph, with no cycle (only 2-way parent child relationship). We can create an adjacency list using the edges.\\n\\nWe can calculate the maximum sum recursively through DFS.\\nBut as this DFS will be called for each nodes, so the time comlexity will increase to O(n)*TC(DFS)=O(n)*O(n)\\n\\nTo reduce this, we can use caching or DP Memoization as there will be repeated subproblems. This will bring down the time complexity to O(n)\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        #DP+DFS\\n        adj_list=collections.defaultdict(list)\\n        for x,y in edges:\\n            adj_list[x].append(y)\\n            adj_list[y].append(x)\\n        \\n        dp={}\\n        def dfs(node,par)->int:\\n            if (node,par) in dp:\\n                return dp[(node,par)]\\n            \\n            sumC=0\\n            for child in adj_list[node]:\\n                if child!=par:\\n                    sumC=max(sumC,dfs(child,node))\\n            dp[(node,par)]=sumC+price[node]\\n            return dp[(node,par)]\\n            \\n        cost=0        \\n        for key in adj_list:\\n            maxV=dfs(key,-1)\\n            minV=price[key]\\n            cost=max(cost,maxV-minV)\\n        return cost\\n            \\n```\\n\\nPlease UPVOTE if this post helps.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        #DP+DFS\\n        adj_list=collections.defaultdict(list)\\n        for x,y in edges:\\n            adj_list[x].append(y)\\n            adj_list[y].append(x)\\n        \\n        dp={}\\n        def dfs(node,par)->int:\\n            if (node,par) in dp:\\n                return dp[(node,par)]\\n            \\n            sumC=0\\n            for child in adj_list[node]:\\n                if child!=par:\\n                    sumC=max(sumC,dfs(child,node))\\n            dp[(node,par)]=sumC+price[node]\\n            return dp[(node,par)]\\n            \\n        cost=0        \\n        for key in adj_list:\\n            maxV=dfs(key,-1)\\n            minV=price[key]\\n            cost=max(cost,maxV-minV)\\n        return cost\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052769,
                "title": "o-n-re-rooting-c",
                "content": "# Intuition\\nprecalculate the best paths if we had 0 as root and then re-root and update those values \\u200B\\u200Bin $O(1)$\\n\\n# Approach\\nFirst we need to find the answer for root 0, so we keep a kind of $DP$ that says the best answer for each node if we start from there and just go down, with this $DP$ the answer will be the best of its children for each node $u$ since we will update the values \\u200B\\u200Bas if the node $u$ were the root\\nThen it walks the tree with a dfs and tries to update said DP in an optimal way.\\n\\nTo do the re-root when we are going to travel to a node, we first have to update our DP value, for this there are 2 possible candidates to create the new best path from node $u$, the best child that is not the node we are going to, and our father if we have\\n\\n# Complexity\\n- Time complexity:\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n    vector<int> graph[100007];\\n    vector<long long> best;\\n    long long dfs_sz(int u,int p,vector<int> &pr){\\n        long long mx = 0;\\n        for(auto v:graph[u]){\\n            if(v ==p)continue;\\n            mx = max(mx,dfs_sz(v,u,pr));\\n        }\\n        best[u] = mx;\\n        return best[u]+pr[u];\\n    }\\n    \\n    void dfs(int u,int p  ,vector<int> &pr){\\n        vector<pair<long long,int>> A;\\n        for(auto v:graph[u]){\\n            A.push_back({best[v]+pr[v],v});\\n        }\\n        \\n        sort(A.rbegin(),A.rend());\\n        if(A.size())\\n            ans = max(ans,A[0].first);\\n        \\n        for(auto v:graph[u]){\\n            if(v == p)continue;\\n            long long last = best[u];\\n            long long nwBest = 0;\\n            if(v ==A[0].second && A.size()>1){\\n                nwBest += A[1].first;\\n            }\\n            else if(v != A[0].second){\\n                nwBest += A[0].first;\\n            }\\n            if(p !=-1){\\n                nwBest = max(nwBest,best[p]);\\n            }\\n            \\n            best[u] = nwBest;\\n            dfs(v,u,pr);\\n            \\n            best[u] = last;\\n        }\\n        \\n    }\\n    \\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        best.resize(n);\\n        for(int i = 0;i<n-1;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        dfs_sz(0,-1,price);\\n        dfs(0,-1,price);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n    vector<int> graph[100007];\\n    vector<long long> best;\\n    long long dfs_sz(int u,int p,vector<int> &pr){\\n        long long mx = 0;\\n        for(auto v:graph[u]){\\n            if(v ==p)continue;\\n            mx = max(mx,dfs_sz(v,u,pr));\\n        }\\n        best[u] = mx;\\n        return best[u]+pr[u];\\n    }\\n    \\n    void dfs(int u,int p  ,vector<int> &pr){\\n        vector<pair<long long,int>> A;\\n        for(auto v:graph[u]){\\n            A.push_back({best[v]+pr[v],v});\\n        }\\n        \\n        sort(A.rbegin(),A.rend());\\n        if(A.size())\\n            ans = max(ans,A[0].first);\\n        \\n        for(auto v:graph[u]){\\n            if(v == p)continue;\\n            long long last = best[u];\\n            long long nwBest = 0;\\n            if(v ==A[0].second && A.size()>1){\\n                nwBest += A[1].first;\\n            }\\n            else if(v != A[0].second){\\n                nwBest += A[0].first;\\n            }\\n            if(p !=-1){\\n                nwBest = max(nwBest,best[p]);\\n            }\\n            \\n            best[u] = nwBest;\\n            dfs(v,u,pr);\\n            \\n            best[u] = last;\\n        }\\n        \\n    }\\n    \\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        best.resize(n);\\n        for(int i = 0;i<n-1;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        dfs_sz(0,-1,price);\\n        dfs(0,-1,price);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991408,
                "title": "c-in-out-tree-dp-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(Adjacency List Size + 3*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define pi pair<long long,long long>\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    vector<long long> indp,outdp;\\n    vector<vector<int>> adj;\\n    vector<pi> maxVal;\\n\\n    void dfs1(int node,int par,vector<int> &price){\\n        indp[node]=0;\\n        long long mx =0;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(auto ch : adj[node]){\\n            if(ch==par) continue;\\n            dfs1(ch,node,price);\\n            mx = max(mx,indp[ch]);\\n            pq.push(indp[ch]);\\n            if(pq.size()>2) pq.pop();\\n        }\\n  // To calculate 1st max ans 2nd max\\n        if(pq.size()==0){\\n         maxVal[node]= {-1e9,-1e9};\\n        }\\n        else if(pq.size()==1){\\n            long long  max1 = pq.top();\\n            maxVal[node]={max1,-1e9};\\n        }\\n        else{\\n            long long max2 = pq.top();\\n            pq.pop();\\n            long long max1 = pq.top();\\n            maxVal[node] = {max1,max2};\\n        }\\n\\n  ////\\n        indp[node]+=(mx+price[node]);\\n    }\\n\\n    void dfs2(int node,int par,vector<int> &price){\\n        \\n        if(par==-1) outdp[node] = price[node];\\n        else{\\n             int nodeMx = indp[node];\\n             pi mxv= maxVal[par];\\n             if(outdp[par]> indp[par])    outdp[node] = (outdp[par] + price[node]);\\n             else{\\n                 if(mxv.F>indp[node])   outdp[node] = (indp[par]+price[node]);\\n                 else{\\n                  if(mxv.F == mxv.S)  outdp[node]=(mxv.S+price[node]+price[par]);\\n                  else{\\n                      if(mxv.S == -1)   outdp[node] = outdp[par] + price[node];\\n                      else               outdp[node]= max(outdp[par],(mxv.S+price[par]))+price[node];\\n                      }\\n                 }\\n             }\\n        }\\n        for(auto ch : adj[node]){\\n            if(ch==par) continue;\\n            dfs2(ch,node,price);\\n        }\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        indp.resize(n);\\n        outdp.resize(n);\\n        maxVal.resize(n);\\n        adj.resize(n);\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        dfs1(0,-1,price);\\n        dfs2(0,-1,price);\\n        long long ans = 0;\\n        for(int i =0;i<n;i++){\\n            ans = max(ans,max(indp[i],outdp[i])-price[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\n#define pi pair<long long,long long>\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    vector<long long> indp,outdp;\\n    vector<vector<int>> adj;\\n    vector<pi> maxVal;\\n\\n    void dfs1(int node,int par,vector<int> &price){\\n        indp[node]=0;\\n        long long mx =0;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(auto ch : adj[node]){\\n            if(ch==par) continue;\\n            dfs1(ch,node,price);\\n            mx = max(mx,indp[ch]);\\n            pq.push(indp[ch]);\\n            if(pq.size()>2) pq.pop();\\n        }\\n  // To calculate 1st max ans 2nd max\\n        if(pq.size()==0){\\n         maxVal[node]= {-1e9,-1e9};\\n        }\\n        else if(pq.size()==1){\\n            long long  max1 = pq.top();\\n            maxVal[node]={max1,-1e9};\\n        }\\n        else{\\n            long long max2 = pq.top();\\n            pq.pop();\\n            long long max1 = pq.top();\\n            maxVal[node] = {max1,max2};\\n        }\\n\\n  ////\\n        indp[node]+=(mx+price[node]);\\n    }\\n\\n    void dfs2(int node,int par,vector<int> &price){\\n        \\n        if(par==-1) outdp[node] = price[node];\\n        else{\\n             int nodeMx = indp[node];\\n             pi mxv= maxVal[par];\\n             if(outdp[par]> indp[par])    outdp[node] = (outdp[par] + price[node]);\\n             else{\\n                 if(mxv.F>indp[node])   outdp[node] = (indp[par]+price[node]);\\n                 else{\\n                  if(mxv.F == mxv.S)  outdp[node]=(mxv.S+price[node]+price[par]);\\n                  else{\\n                      if(mxv.S == -1)   outdp[node] = outdp[par] + price[node];\\n                      else               outdp[node]= max(outdp[par],(mxv.S+price[par]))+price[node];\\n                      }\\n                 }\\n             }\\n        }\\n        for(auto ch : adj[node]){\\n            if(ch==par) continue;\\n            dfs2(ch,node,price);\\n        }\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        indp.resize(n);\\n        outdp.resize(n);\\n        maxVal.resize(n);\\n        adj.resize(n);\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        dfs1(0,-1,price);\\n        dfs2(0,-1,price);\\n        long long ans = 0;\\n        for(int i =0;i<n;i++){\\n            ans = max(ans,max(indp[i],outdp[i])-price[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662145,
                "title": "easy-dp-on-tree-c-kartik-arora-style",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> g;\\n    vector<int> dep,val,outdp;\\n    vector<int> ans;\\n\\n    void dfs(int u,int par){\\n        for(auto v:g[u]){\\n            if(v==par) continue;\\n            dfs(v,u);\\n            dep[u]=max(dep[u],val[u]+dep[v]);\\n        }\\n    }\\n\\n    void dfs2(int u,int par,int par_ans){\\n        vector<int> pre,suf;\\n        for(auto v:g[u]){\\n            if(v==par) continue;\\n            pre.push_back(dep[v]);\\n            suf.push_back(dep[v]);\\n        }\\n        int sz = pre.size();\\n        for(int i=1;i<sz;i++){\\n            pre[i] = max(pre[i],pre[i-1]);\\n        }\\n        for(int i=sz-2;i>=0;i--){\\n            suf[i] = max(suf[i],suf[i+1]);\\n        }\\n        int idx = 0;\\n        for(auto v:g[u]){\\n            if(v==par) continue;\\n            int op1 = idx==0 ? INT_MIN : pre[idx-1];\\n            int op2 = idx==sz-1 ? INT_MIN : suf[idx+1];\\n            int p = val[u]+max(par_ans,max(op1,op2));\\n            dfs2(v,u,p); \\n            idx++;\\n        }\\n        if(sz==0){\\n            ans[u] = max(par_ans,-1);\\n            return;\\n        }\\n        ans[u] = max(par_ans,pre[sz-1]);\\n    }\\n\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        g.assign(n+1,vector<int>());\\n        ans.assign(n+1,0);\\n        for(auto it:edges){\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n        val = price;\\n        dep = price;\\n        outdp = price;\\n        dfs(0,-1);\\n        dfs2(0,-1,0);\\n        return *max_element(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> g;\\n    vector<int> dep,val,outdp;\\n    vector<int> ans;\\n\\n    void dfs(int u,int par){\\n        for(auto v:g[u]){\\n            if(v==par) continue;\\n            dfs(v,u);\\n            dep[u]=max(dep[u],val[u]+dep[v]);\\n        }\\n    }\\n\\n    void dfs2(int u,int par,int par_ans){\\n        vector<int> pre,suf;\\n        for(auto v:g[u]){\\n            if(v==par) continue;\\n            pre.push_back(dep[v]);\\n            suf.push_back(dep[v]);\\n        }\\n        int sz = pre.size();\\n        for(int i=1;i<sz;i++){\\n            pre[i] = max(pre[i],pre[i-1]);\\n        }\\n        for(int i=sz-2;i>=0;i--){\\n            suf[i] = max(suf[i],suf[i+1]);\\n        }\\n        int idx = 0;\\n        for(auto v:g[u]){\\n            if(v==par) continue;\\n            int op1 = idx==0 ? INT_MIN : pre[idx-1];\\n            int op2 = idx==sz-1 ? INT_MIN : suf[idx+1];\\n            int p = val[u]+max(par_ans,max(op1,op2));\\n            dfs2(v,u,p); \\n            idx++;\\n        }\\n        if(sz==0){\\n            ans[u] = max(par_ans,-1);\\n            return;\\n        }\\n        ans[u] = max(par_ans,pre[sz-1]);\\n    }\\n\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        g.assign(n+1,vector<int>());\\n        ans.assign(n+1,0);\\n        for(auto it:edges){\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n        val = price;\\n        dep = price;\\n        outdp = price;\\n        dfs(0,-1);\\n        dfs2(0,-1,0);\\n        return *max_element(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292971,
                "title": "o-n-python3-solution",
                "content": "```\\nfrom typing import List\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        def dfs(node, parent=-1):\\n            current_price = price[node]\\n            max_output = (0, current_price, 0)\\n\\n            for neighbor in graph[node]:\\n                if neighbor == parent:\\n                    continue\\n\\n                neighbor_output = dfs(neighbor, node)\\n                combined_output = (\\n                    max(\\n                        max_output[0],\\n                        neighbor_output[0],\\n                        max_output[1] + neighbor_output[2],\\n                        max_output[2] + neighbor_output[1],\\n                    ),\\n                    max(max_output[1], neighbor_output[1] + current_price),\\n                    max(max_output[2], neighbor_output[2] + current_price),\\n                )\\n\\n                max_output = combined_output\\n\\n            return max_output\\n\\n        if n <= 2:\\n            return sum(price) - min(price)\\n\\n        for node in range(n):\\n            if len(graph[node]) > 1:\\n                return dfs(node)[0]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        def dfs(node, parent=-1):\\n            current_price = price[node]\\n            max_output = (0, current_price, 0)\\n\\n            for neighbor in graph[node]:\\n                if neighbor == parent:\\n                    continue\\n\\n                neighbor_output = dfs(neighbor, node)\\n                combined_output = (\\n                    max(\\n                        max_output[0],\\n                        neighbor_output[0],\\n                        max_output[1] + neighbor_output[2],\\n                        max_output[2] + neighbor_output[1],\\n                    ),\\n                    max(max_output[1], neighbor_output[1] + current_price),\\n                    max(max_output[2], neighbor_output[2] + current_price),\\n                )\\n\\n                max_output = combined_output\\n\\n            return max_output\\n\\n        if n <= 2:\\n            return sum(price) - min(price)\\n\\n        for node in range(n):\\n            if len(graph[node]) > 1:\\n                return dfs(node)[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185029,
                "title": "c-easy-code-rerooting-simple-approach",
                "content": "# Intuition\\nBasically we will do two DFS calls.\\n\\n1) To find the max path from zero.\\n\\n2) we will have three things to find to get the max path for any node.\\n    a) sum[x].\\n    b) parent\\'s subtree that is having max path sum (other than subtree we are iterating).\\n    c) Grand parent\\'s that subtree that is having max path sum (other than subtree we are iterating).\\n\\nAns will be maximum of all this three + price[node], if not included.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs2(vector<vector<int>>& adj,vector<long long>&sum,vector<int>&vis,int u,vector<int>&price,vector<long long>& dist,long long par)\\n    {\\n        vis[u]=1;\\n        long long max1=0;\\n        long long max2=0;\\n        for(auto x:adj[u])\\n        {\\n            if(vis[x]==0)\\n            {\\n                if(sum[x]>=max1)\\n                {\\n                    max2=max1;\\n                    max1=sum[x];\\n                }\\n                else if(sum[x]>max2)\\n                max2=sum[x];\\n            }\\n        }\\n        \\n        long long calc=0;\\n        for(auto x:adj[u])\\n        {   \\n           if(vis[x]==0)\\n           {\\n               if(max1 == sum[x]) {\\n                    long long temp = max(max2+price[u]+price[x], sum[x]);\\n                    dist[x] = max(temp, price[u]+par+price[x]);\\n                    dfs2(adj,sum,vis,x,price,dist,max(max2,par)+price[u]);\\n               }else {\\n                    long long temp = max(max1+price[u]+price[x], sum[x]);\\n                    dist[x] = max(temp, price[u]+par+price[x]);\\n                    dfs2(adj,sum,vis,x,price,dist,max(max1,par)+price[u]);                   \\n               }\\n           } \\n        }\\n    }\\n    long long dfs1(vector<vector<int>>& adj,vector<long long>&sum,vector<int>&vis,int u,vector<int>&price)\\n    {\\n        vis[u]=1;\\n        long long val=0;\\n        long long ans=0;\\n        for(auto x:adj[u])\\n        {  \\n           if(vis[x]==0)\\n           {\\n              val=dfs1(adj,sum,vis,x,price);             \\n              ans=max(ans,val);\\n           }\\n        }\\n      \\n        sum[u]=ans+price[u];\\n        return sum[u];\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        \\n        vector<long long>sum(n,0);\\n        vector<vector<int>>adj(n,vector<int>());\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>vis(n,0);\\n        dfs1(adj,sum,vis,0,price);\\n        vector<int>vis2(n,0);\\n        vector<long long>dist(n,0);\\n        dfs2(adj,sum,vis2,0,price,dist,0);\\n        long long calc=0;\\n        dist[0] = sum[0];\\n        for(int i=0;i<n;i++)\\n        {\\n        //    cout << dist[i] << \" \";\\n            calc=max(calc,dist[i]-price[i]);\\n        }\\n        return calc;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs2(vector<vector<int>>& adj,vector<long long>&sum,vector<int>&vis,int u,vector<int>&price,vector<long long>& dist,long long par)\\n    {\\n        vis[u]=1;\\n        long long max1=0;\\n        long long max2=0;\\n        for(auto x:adj[u])\\n        {\\n            if(vis[x]==0)\\n            {\\n                if(sum[x]>=max1)\\n                {\\n                    max2=max1;\\n                    max1=sum[x];\\n                }\\n                else if(sum[x]>max2)\\n                max2=sum[x];\\n            }\\n        }\\n        \\n        long long calc=0;\\n        for(auto x:adj[u])\\n        {   \\n           if(vis[x]==0)\\n           {\\n               if(max1 == sum[x]) {\\n                    long long temp = max(max2+price[u]+price[x], sum[x]);\\n                    dist[x] = max(temp, price[u]+par+price[x]);\\n                    dfs2(adj,sum,vis,x,price,dist,max(max2,par)+price[u]);\\n               }else {\\n                    long long temp = max(max1+price[u]+price[x], sum[x]);\\n                    dist[x] = max(temp, price[u]+par+price[x]);\\n                    dfs2(adj,sum,vis,x,price,dist,max(max1,par)+price[u]);                   \\n               }\\n           } \\n        }\\n    }\\n    long long dfs1(vector<vector<int>>& adj,vector<long long>&sum,vector<int>&vis,int u,vector<int>&price)\\n    {\\n        vis[u]=1;\\n        long long val=0;\\n        long long ans=0;\\n        for(auto x:adj[u])\\n        {  \\n           if(vis[x]==0)\\n           {\\n              val=dfs1(adj,sum,vis,x,price);             \\n              ans=max(ans,val);\\n           }\\n        }\\n      \\n        sum[u]=ans+price[u];\\n        return sum[u];\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        \\n        vector<long long>sum(n,0);\\n        vector<vector<int>>adj(n,vector<int>());\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>vis(n,0);\\n        dfs1(adj,sum,vis,0,price);\\n        vector<int>vis2(n,0);\\n        vector<long long>dist(n,0);\\n        dfs2(adj,sum,vis2,0,price,dist,0);\\n        long long calc=0;\\n        dist[0] = sum[0];\\n        for(int i=0;i<n;i++)\\n        {\\n        //    cout << dist[i] << \" \";\\n            calc=max(calc,dist[i]-price[i]);\\n        }\\n        return calc;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3063604,
                "title": "re-rooting-o-n-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Set<Integer>[] graph;\\n    long[][] dp;   \\n    int[] price;\\n    long max = 0;\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        this.price = price;\\n        graph = new HashSet[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new HashSet<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        dp = new long[n][2];           \\n        dfs(0, -1);\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(max, dp[i][0] - price[i]);\\n        }\\n        dfs1(0, -1);        \\n        return max;\\n    }\\n\\n    private void dfs(int cur, int pre) {\\n        dp[cur][0] = price[cur];\\n        for (int child : graph[cur]) {\\n            if (child == pre) {\\n                continue;\\n            }\\n            dfs(child, cur);\\n            long max = dp[child][0] + price[cur];\\n            if (max > dp[cur][0]) {\\n                dp[cur][1] = dp[cur][0];\\n                dp[cur][0] = max;\\n            } else if (max > dp[cur][1]) {\\n                dp[cur][1] = max;\\n            }            \\n        }\\n    }\\n\\n    private void dfs1(int cur, int pre) {\\n        for (int child : graph[cur]) {           \\n            if (child == pre) {\\n                continue;\\n            }\\n            if (dp[cur][0] == dp[child][0] + price[cur]) {\\n                if (dp[child][0] > dp[cur][1] + price[child]) {\\n                    dp[child][0] = dp[child][0];\\n                    dp[child][1] = Math.max(dp[child][1], dp[cur][1] + price[child]);\\n                } else {\\n                    dp[child][0] = dp[cur][1] + price[child];\\n                    dp[child][1] = Math.min(dp[child][0], dp[cur][1] + price[child]);\\n                }\\n            } else {\\n                if (dp[child][0] > dp[cur][0] + price[child]) {\\n                    dp[child][0] = dp[child][0];\\n                    dp[child][1] = Math.max(dp[child][1], dp[cur][0] + price[child]);\\n                } else {\\n                    dp[child][0] = dp[cur][0] + price[child];\\n                    dp[child][1] = Math.min(dp[child][0], dp[cur][1] + price[child]);\\n                }\\n            }\\n            max = Math.max(max, dp[child][0] - price[child]);\\n            dfs1(child, cur);\\n        }       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Set<Integer>[] graph;\\n    long[][] dp;   \\n    int[] price;\\n    long max = 0;\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        this.price = price;\\n        graph = new HashSet[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new HashSet<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        dp = new long[n][2];           \\n        dfs(0, -1);\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(max, dp[i][0] - price[i]);\\n        }\\n        dfs1(0, -1);        \\n        return max;\\n    }\\n\\n    private void dfs(int cur, int pre) {\\n        dp[cur][0] = price[cur];\\n        for (int child : graph[cur]) {\\n            if (child == pre) {\\n                continue;\\n            }\\n            dfs(child, cur);\\n            long max = dp[child][0] + price[cur];\\n            if (max > dp[cur][0]) {\\n                dp[cur][1] = dp[cur][0];\\n                dp[cur][0] = max;\\n            } else if (max > dp[cur][1]) {\\n                dp[cur][1] = max;\\n            }            \\n        }\\n    }\\n\\n    private void dfs1(int cur, int pre) {\\n        for (int child : graph[cur]) {           \\n            if (child == pre) {\\n                continue;\\n            }\\n            if (dp[cur][0] == dp[child][0] + price[cur]) {\\n                if (dp[child][0] > dp[cur][1] + price[child]) {\\n                    dp[child][0] = dp[child][0];\\n                    dp[child][1] = Math.max(dp[child][1], dp[cur][1] + price[child]);\\n                } else {\\n                    dp[child][0] = dp[cur][1] + price[child];\\n                    dp[child][1] = Math.min(dp[child][0], dp[cur][1] + price[child]);\\n                }\\n            } else {\\n                if (dp[child][0] > dp[cur][0] + price[child]) {\\n                    dp[child][0] = dp[child][0];\\n                    dp[child][1] = Math.max(dp[child][1], dp[cur][0] + price[child]);\\n                } else {\\n                    dp[child][0] = dp[cur][0] + price[child];\\n                    dp[child][1] = Math.min(dp[child][0], dp[cur][1] + price[child]);\\n                }\\n            }\\n            max = Math.max(max, dp[child][0] - price[child]);\\n            dfs1(child, cur);\\n        }       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060957,
                "title": "python-explanation-of-dfs-cache-approach",
                "content": "```python\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        g = defaultdict(list)\\n        \\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n \\n        @cache\\n        def dfs(i, p):\\n            r = 0\\n\\n            for j in g[i]:\\n                if j == p:\\n                    continue\\n                \\n                r = max(r, dfs(j, i) + price[j])\\n\\n            return r\\n\\n        \"\"\"\\n        Here we just use DFS to get max sum from target node with\\n        cache which boost our search.\\n        \\n        min = price[i]\\n        result = dfs(i, 1) + price[i] - min\\n        \\n        DFS return sum without target node value, so we need to add it,\\n        also we need to substract minimum from path which supposed to be also\\n        node value, not last node because it\\'s optimization, because we will process\\n        from last node to target in future.\\n        \\n        Example:\\n        [1 + 2 + 3] : (2 + 3) + 1 - 1\\n                        DFS    val min\\n\\n        [3 + 2 + 1] : (2 + 1) + 3 - 3\\n                        DFS    val min\\n                        \\n        So we just use result of DFS :-)\\n        \"\"\"\\n        res = float(\\'-inf\\')\\n        for i in range(n):\\n            res = max(res, dfs(i, -1))\\n\\n        return res\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        g = defaultdict(list)\\n        \\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n \\n        @cache\\n        def dfs(i, p):\\n            r = 0\\n\\n            for j in g[i]:\\n                if j == p:\\n                    continue\\n                \\n                r = max(r, dfs(j, i) + price[j])\\n\\n            return r\\n\\n        \"\"\"\\n        Here we just use DFS to get max sum from target node with\\n        cache which boost our search.\\n        \\n        min = price[i]\\n        result = dfs(i, 1) + price[i] - min\\n        \\n        DFS return sum without target node value, so we need to add it,\\n        also we need to substract minimum from path which supposed to be also\\n        node value, not last node because it\\'s optimization, because we will process\\n        from last node to target in future.\\n        \\n        Example:\\n        [1 + 2 + 3] : (2 + 3) + 1 - 1\\n                        DFS    val min\\n\\n        [3 + 2 + 1] : (2 + 1) + 3 - 3\\n                        DFS    val min\\n                        \\n        So we just use result of DFS :-)\\n        \"\"\"\\n        res = float(\\'-inf\\')\\n        for i in range(n):\\n            res = max(res, dfs(i, -1))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060224,
                "title": "c-dfs-100-faster",
                "content": "```\\n#define ll long long int \\nclass Solution {\\npublic:\\n    ll ans=0;\\n  \\n  vector<ll> vec[100005];\\n  ll mx[100005];\\n  \\n  void dfs1(ll u, ll p , vector<int>&a)\\n  {\\n    mx[u]=0;\\n    \\n    for(ll v:vec[u])\\n    {\\n       if(v==p) continue;\\n       dfs1(v,u,a);\\n       mx[u]=max(mx[u], mx[v]);\\n    }\\n    mx[u]+=a[u];\\n  }\\n   void dfs(ll u, ll p ,vector<int>&a ,ll above)\\n   {\\n      multiset<ll>st;\\n      st.insert(above);\\n      \\n     for(ll v:vec[u])\\n     {\\n        if(v==p) continue;\\n        st.insert(mx[v]);\\n     }\\n     for(ll v:vec[u])\\n     {\\n        if(v==p) continue;\\n        st.erase(st.find(mx[v]));\\n        ll o=0;\\n        if(st.size()) o= *(--st.end());\\n        dfs(v,u,a,o+a[u]);\\n        st.insert(mx[v]);\\n     }\\n      ans=max(ans,*(--st.end()));\\n   }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& a) {\\n     \\n      for(vector<int>vv:edges)\\n      {\\n        vec[vv[0]].push_back(vv[1]);\\n        vec[vv[1]].push_back(vv[0]);\\n      }\\n      ans=0;\\n      dfs1(0,0,a);\\n      dfs(0,0,a,0);\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int \\nclass Solution {\\npublic:\\n    ll ans=0;\\n  \\n  vector<ll> vec[100005];\\n  ll mx[100005];\\n  \\n  void dfs1(ll u, ll p , vector<int>&a)\\n  {\\n    mx[u]=0;\\n    \\n    for(ll v:vec[u])\\n    {\\n       if(v==p) continue;\\n       dfs1(v,u,a);\\n       mx[u]=max(mx[u], mx[v]);\\n    }\\n    mx[u]+=a[u];\\n  }\\n   void dfs(ll u, ll p ,vector<int>&a ,ll above)\\n   {\\n      multiset<ll>st;\\n      st.insert(above);\\n      \\n     for(ll v:vec[u])\\n     {\\n        if(v==p) continue;\\n        st.insert(mx[v]);\\n     }\\n     for(ll v:vec[u])\\n     {\\n        if(v==p) continue;\\n        st.erase(st.find(mx[v]));\\n        ll o=0;\\n        if(st.size()) o= *(--st.end());\\n        dfs(v,u,a,o+a[u]);\\n        st.insert(mx[v]);\\n     }\\n      ans=max(ans,*(--st.end()));\\n   }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& a) {\\n     \\n      for(vector<int>vv:edges)\\n      {\\n        vec[vv[0]].push_back(vv[1]);\\n        vec[vv[1]].push_back(vv[0]);\\n      }\\n      ans=0;\\n      dfs1(0,0,a);\\n      dfs(0,0,a,0);\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055790,
                "title": "java-two-dfs",
                "content": "```\\n    //2.two DFS\\n    //Runtime: 105ms 100%; Memory 99.1MB 100%\\n    //Time: O(N); Space: O(N);\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<>();\\n\\n        for(int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n\\n        long[] counter = new long[n];\\n        //first dfs\\n        res2 = helper2_dfs(price, graph, 0, -1, counter);\\n        //second dfs: re-root\\n        helper2_dfs2(price, graph, 0, counter, new int[n]);\\n        return res2;\\n    }\\n\\n    private long res2 = 0;\\n    private void helper2_dfs2(int[] price, List<Integer>[] graph, int node,\\n                              long[] counter, int[] seen) {\\n\\n        long tmpX = counter[node];\\n        seen[node] = 1;\\n        for (int neighbour : graph[node]) {\\n            if (seen[neighbour] == 1) continue;\\n\\n            //root -> child\\n            long childCount = 0l;\\n            for (int child : graph[node]) {\\n                if (child == neighbour) continue;\\n                childCount = Math.max(childCount, price[child] + counter[child]);\\n            }\\n            counter[node] = childCount;\\n\\n            //child -> root\\n            long tmpY = counter[neighbour];\\n            counter[neighbour] = Math.max(price[node] + childCount, counter[neighbour]);\\n            res2 = Math.max(res2, counter[neighbour]);\\n\\n            seen[neighbour] = 1;\\n            helper2_dfs2(price, graph, neighbour, counter, seen);\\n            counter[neighbour] = tmpY;\\n        }\\n        counter[node] = tmpX;\\n    }\\n\\n    private long helper2_dfs(int[] price, List<Integer>[] graph, int node, int parent, long[] counter) {\\n        long res = 0l;\\n        for (int neighbour: graph[node]) {\\n            if (neighbour == parent) continue;\\n            res = Math.max(res, price[neighbour] + helper2_dfs(price, graph, neighbour, node, counter));\\n        }\\n        return counter[node] = res;\\n    }\\n\\n\\n\\n    //1.brute force | DFS\\n    //TLE\\n    //Time: O(N * N); Space: O(N)\\n    public long maxOutput_1(int n, int[][] edges, int[] price) {\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<>();\\n\\n        for(int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n\\n        long res = 0;\\n        for (int i = 0; i < n; i++)\\n            res = Math.max(res, helper_dfs(price, graph, i, -1));\\n\\n        return res;\\n    }\\n\\n    private long helper_dfs(int[] price, List<Integer>[] graph, int node, int parent) {\\n        long res = 0;\\n        for (int neighbour:  graph[node]) {\\n            if (neighbour == parent) continue;\\n            res = Math.max(res, price[neighbour] + helper_dfs(price, graph, neighbour, node));\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    //2.two DFS\\n    //Runtime: 105ms 100%; Memory 99.1MB 100%\\n    //Time: O(N); Space: O(N);\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<>();\\n\\n        for(int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n\\n        long[] counter = new long[n];\\n        //first dfs\\n        res2 = helper2_dfs(price, graph, 0, -1, counter);\\n        //second dfs: re-root\\n        helper2_dfs2(price, graph, 0, counter, new int[n]);\\n        return res2;\\n    }\\n\\n    private long res2 = 0;\\n    private void helper2_dfs2(int[] price, List<Integer>[] graph, int node,\\n                              long[] counter, int[] seen) {\\n\\n        long tmpX = counter[node];\\n        seen[node] = 1;\\n        for (int neighbour : graph[node]) {\\n            if (seen[neighbour] == 1) continue;\\n\\n            //root -> child\\n            long childCount = 0l;\\n            for (int child : graph[node]) {\\n                if (child == neighbour) continue;\\n                childCount = Math.max(childCount, price[child] + counter[child]);\\n            }\\n            counter[node] = childCount;\\n\\n            //child -> root\\n            long tmpY = counter[neighbour];\\n            counter[neighbour] = Math.max(price[node] + childCount, counter[neighbour]);\\n            res2 = Math.max(res2, counter[neighbour]);\\n\\n            seen[neighbour] = 1;\\n            helper2_dfs2(price, graph, neighbour, counter, seen);\\n            counter[neighbour] = tmpY;\\n        }\\n        counter[node] = tmpX;\\n    }\\n\\n    private long helper2_dfs(int[] price, List<Integer>[] graph, int node, int parent, long[] counter) {\\n        long res = 0l;\\n        for (int neighbour: graph[node]) {\\n            if (neighbour == parent) continue;\\n            res = Math.max(res, price[neighbour] + helper2_dfs(price, graph, neighbour, node, counter));\\n        }\\n        return counter[node] = res;\\n    }\\n\\n\\n\\n    //1.brute force | DFS\\n    //TLE\\n    //Time: O(N * N); Space: O(N)\\n    public long maxOutput_1(int n, int[][] edges, int[] price) {\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++)\\n            graph[i] = new ArrayList<>();\\n\\n        for(int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n\\n        long res = 0;\\n        for (int i = 0; i < n; i++)\\n            res = Math.max(res, helper_dfs(price, graph, i, -1));\\n\\n        return res;\\n    }\\n\\n    private long helper_dfs(int[] price, List<Integer>[] graph, int node, int parent) {\\n        long res = 0;\\n        for (int neighbour:  graph[node]) {\\n            if (neighbour == parent) continue;\\n            res = Math.max(res, price[neighbour] + helper_dfs(price, graph, neighbour, node));\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055415,
                "title": "rust-dfs-and-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse DFS twice, with the first one to calculate maximum cost of each subtree, and the second to calculate the answer with rerooting on a child.   \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Use dfs to calculate the maximum cost (array dist[]) choosen 0 as the root\\n2) Set ret = dist[0] - price[0].\\n3) Recursively call backtracking on u to refine ret with each child of u as the new root.\\n4) In calculating the cost with the new root v, we only need to consider two of the three types of paths:\\n    a) paths from parent u to other nodes that are not v\\'s siblings;\\n    b) paths from parent u to other siblings.\\n    c) Paths under the subtee rooted at v, these could be ignored since we are only interested in paths with biggest cost.    \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::collections::BTreeMap;\\n\\nimpl Solution {\\n    pub fn max_output(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>) -> i64 {\\n        let n = n as usize;\\n        let mut graph = vec![vec![]; n];\\n\\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n\\n        let mut dist = vec![0; n];\\n        Self::dfs(&graph, &price, &mut dist, 0, -1);\\n\\n        let mut ret = dist[0] - price[0] as i64;\\n        Self::backtracking(&graph, &price, &dist, &mut ret, 0, -1, 0);\\n        \\n        ret\\n    }\\n\\n    fn dfs(graph: &Vec<Vec<usize>>, price: &Vec<i32>, dist: &mut Vec<i64>, u: usize, p: i32) {\\n        dist[u] = price[u] as i64;\\n\\n        for v in &graph[u] {\\n            if p == *v as i32 { continue }\\n\\n            Self::dfs(graph, price, dist, *v, u as i32);\\n            dist[u] = dist[u].max(dist[*v] + price[u] as i64);\\n        }\\n    }\\n\\n    fn backtracking(graph: &Vec<Vec<usize>>, price: &Vec<i32>, dist: &Vec<i64>, ret: &mut i64, u: usize, p: i32, p_max: i64) {\\n        let mut mp = BTreeMap::<i64, i32>::new();\\n\\n        for v in &graph[u] {\\n            if p == *v as i32 { continue }\\n            \\n            *mp.entry(dist[*v]).or_insert(0) += 1;\\n        }\\n\\n        for v in &graph[u] {\\n            if p == *v as i32 { continue }\\n            \\n            if *mp.get(&dist[*v]).unwrap() == 1 { mp.remove(&dist[*v]); }\\n            else { *mp.entry(dist[*v]).or_insert(0) -= 1; }\\n\\n            let mut temp = price[u] as i64 + p_max;\\n            if mp.is_empty() == false { temp = temp.max(price[u] as i64 + *mp.keys().next_back().unwrap()); }\\n            *ret = (*ret).max(temp);\\n            Self::backtracking(graph, price, dist, ret, *v, u as i32, temp);\\n    \\n            *mp.entry(dist[*v]).or_insert(0) += 1;\\n        } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BTreeMap;\\n\\nimpl Solution {\\n    pub fn max_output(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>) -> i64 {\\n        let n = n as usize;\\n        let mut graph = vec![vec![]; n];\\n\\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n\\n        let mut dist = vec![0; n];\\n        Self::dfs(&graph, &price, &mut dist, 0, -1);\\n\\n        let mut ret = dist[0] - price[0] as i64;\\n        Self::backtracking(&graph, &price, &dist, &mut ret, 0, -1, 0);\\n        \\n        ret\\n    }\\n\\n    fn dfs(graph: &Vec<Vec<usize>>, price: &Vec<i32>, dist: &mut Vec<i64>, u: usize, p: i32) {\\n        dist[u] = price[u] as i64;\\n\\n        for v in &graph[u] {\\n            if p == *v as i32 { continue }\\n\\n            Self::dfs(graph, price, dist, *v, u as i32);\\n            dist[u] = dist[u].max(dist[*v] + price[u] as i64);\\n        }\\n    }\\n\\n    fn backtracking(graph: &Vec<Vec<usize>>, price: &Vec<i32>, dist: &Vec<i64>, ret: &mut i64, u: usize, p: i32, p_max: i64) {\\n        let mut mp = BTreeMap::<i64, i32>::new();\\n\\n        for v in &graph[u] {\\n            if p == *v as i32 { continue }\\n            \\n            *mp.entry(dist[*v]).or_insert(0) += 1;\\n        }\\n\\n        for v in &graph[u] {\\n            if p == *v as i32 { continue }\\n            \\n            if *mp.get(&dist[*v]).unwrap() == 1 { mp.remove(&dist[*v]); }\\n            else { *mp.entry(dist[*v]).or_insert(0) -= 1; }\\n\\n            let mut temp = price[u] as i64 + p_max;\\n            if mp.is_empty() == false { temp = temp.max(price[u] as i64 + *mp.keys().next_back().unwrap()); }\\n            *ret = (*ret).max(temp);\\n            Self::backtracking(graph, price, dist, ret, *v, u as i32, temp);\\n    \\n            *mp.entry(dist[*v]).or_insert(0) += 1;\\n        } \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3055027,
                "title": "java-dfs-memoriazation-with-explanation",
                "content": "# Intuition\\nThe idea that I have when seeing the problem is to use DFS. \\n- Build an adjacent table(HashMap) to record the neighbor point for each node;\\n- in the method of dfs, pass the current ndoe and its parent node(from where we traverse to current node)\\n- \\nBut the time complexity for it can be terrible since we need to  start at every node to get the result. So I have two optimazation here\\n1. only start dfs from a leaf node\\n    It is obviours that the path starts and end with leaf node.(If we start dfs from a none leaf node, we can get a longer path from one of its neighbor leaf node.)\\n    When we build a the adjacent table, we can record the degree of each node. Then we only start at nodes with degree 1\\n\\n2. Memorization\\n    We can have terrible time complexity in some cases. See the example below. \\n![1673794431342.jpg](https://assets.leetcode.com/users/images/c04898d6-a1fa-402c-a61e-68a2925e0286_1673794442.180001.png)\\n    In this example, we have two groups of nodes. Each time we start at a leaf node in the left group and traverse to right group, we need to go through every node on the right group. The time complexity come close to the case that we start dfs at every node.\\n    Then it brings me to the idea of memorization in dynamic programming. We can build a hashmap to record the previours path with its result. The good this here is that instead of using the entire path, we can just use the current node and parent node to represent the path.\\n    In the example above, say we have do dfs from node 0 to node1 to node6, and get the maximun result of going from node6 to all its leaf node in the first dfs. Then we have a map  Pair(cur, parent) : res. Next time we start dfs at node2 and traverse to node1 then to node6, we don\\'t need to try every cases in the right group.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    HashMap<Integer, List<Integer>> adj;\\n    int[] price;\\n    HashMap<Pair<Integer, Integer>, Long> memo = new HashMap<>();\\n    \\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        // edge case\\n        if(n == 1) return 0;\\n        \\n        adj = new HashMap<>();\\n        this.price = price;\\n        int[] degree = new int[n];  // record the degree of each node, those with degree 1 are leaf nodes\\n        \\n        for(int[] edge:edges){\\n            int a = edge[0];\\n            int b = edge[1];\\n            \\n            adj.putIfAbsent(a, new ArrayList<Integer>());\\n            adj.putIfAbsent(b, new ArrayList<Integer>());\\n            \\n            adj.get(a).add(b);\\n            adj.get(b).add(a);\\n            \\n            degree[a] ++;\\n            degree[b] ++;\\n        }\\n        \\n        long ans = 0;\\n        // dfs with leaf node(degree 1) \\n        for(int i=0; i<n; i++){\\n            ans = Math.max(ans, dfs(i, -1) - price[i]);\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n    \\n    public long dfs(int node, int pre){\\n        // reaches a leaf node\\n        if(adj.get(node).size() == 1 && adj.get(node).get(0) == pre){  \\n            return price[node];\\n        }\\n        \\n        //memorization\\n        Pair<Integer, Integer> pair = new Pair<>(node, pre);\\n        if(memo.containsKey(pair)) return memo.get(pair);\\n        \\n        long s = 0;\\n        for(Integer child:adj.get(node)){\\n            if(child == pre) continue;\\n            \\n            s = Math.max(s, dfs(child, node));\\n            \\n        }\\n        \\n        //update memo\\n        memo.put(pair, price[node] + s);\\n        \\n        return price[node] + s;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, List<Integer>> adj;\\n    int[] price;\\n    HashMap<Pair<Integer, Integer>, Long> memo = new HashMap<>();\\n    \\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        // edge case\\n        if(n == 1) return 0;\\n        \\n        adj = new HashMap<>();\\n        this.price = price;\\n        int[] degree = new int[n];  // record the degree of each node, those with degree 1 are leaf nodes\\n        \\n        for(int[] edge:edges){\\n            int a = edge[0];\\n            int b = edge[1];\\n            \\n            adj.putIfAbsent(a, new ArrayList<Integer>());\\n            adj.putIfAbsent(b, new ArrayList<Integer>());\\n            \\n            adj.get(a).add(b);\\n            adj.get(b).add(a);\\n            \\n            degree[a] ++;\\n            degree[b] ++;\\n        }\\n        \\n        long ans = 0;\\n        // dfs with leaf node(degree 1) \\n        for(int i=0; i<n; i++){\\n            ans = Math.max(ans, dfs(i, -1) - price[i]);\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n    \\n    public long dfs(int node, int pre){\\n        // reaches a leaf node\\n        if(adj.get(node).size() == 1 && adj.get(node).get(0) == pre){  \\n            return price[node];\\n        }\\n        \\n        //memorization\\n        Pair<Integer, Integer> pair = new Pair<>(node, pre);\\n        if(memo.containsKey(pair)) return memo.get(pair);\\n        \\n        long s = 0;\\n        for(Integer child:adj.get(node)){\\n            if(child == pre) continue;\\n            \\n            s = Math.max(s, dfs(child, node));\\n            \\n        }\\n        \\n        //update memo\\n        memo.put(pair, price[node] + s);\\n        \\n        return price[node] + s;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054976,
                "title": "javascript-easy-dfs-memoization-commented",
                "content": "\\n\\n\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} price\\n * @return {number}\\n */\\nvar maxOutput = function(n, edges, price) {\\n    const m = new Array(n).fill(null).map(_=> new Map());\\n    for(const edge of edges){\\n        // initialize graph and path values with 0\\n       m[edge[0]].set(edge[1], 0);\\n       m[edge[1]].set(edge[0], 0);\\n    }\\n    let ans = 0;\\n    for(let i = 0 ; i < n ; i++){\\n        // run dfs for every node\\n        ans = Math.max(ans, dfs(i, -1) - price[i]);\\n    }\\n    return ans;\\n    \\n    //i -> current node, p -> parent node of i\\n    function dfs(i, p){\\n        let maxPath = 0;\\n        for(const child of m[i].keys()){\\n            if(child != p){\\n                // consider every adjacent node except parent\\n                let path = m[i].get(child);\\n                if(path === 0){\\n                    // if price not calculated from i to child then calculate\\n                    path = dfs(child, i);\\n                    // memoize the calculation\\n                    m[i].set(child, path);    \\n                }\\n                maxPath = Math.max(maxPath, path);\\n            }\\n        }\\n        return maxPath + price[i];\\n    } \\n};",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "\\n\\n\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} price\\n * @return {number}\\n */\\nvar maxOutput = function(n, edges, price) {\\n    const m = new Array(n).fill(null).map(_=> new Map());\\n    for(const edge of edges){\\n        // initialize graph and path values with 0\\n       m[edge[0]].set(edge[1], 0);\\n       m[edge[1]].set(edge[0], 0);\\n    }\\n    let ans = 0;\\n    for(let i = 0 ; i < n ; i++){\\n        // run dfs for every node\\n        ans = Math.max(ans, dfs(i, -1) - price[i]);\\n    }\\n    return ans;\\n    \\n    //i -> current node, p -> parent node of i\\n    function dfs(i, p){\\n        let maxPath = 0;\\n        for(const child of m[i].keys()){\\n            if(child != p){\\n                // consider every adjacent node except parent\\n                let path = m[i].get(child);\\n                if(path === 0){\\n                    // if price not calculated from i to child then calculate\\n                    path = dfs(child, i);\\n                    // memoize the calculation\\n                    m[i].set(child, path);    \\n                }\\n                maxPath = Math.max(maxPath, path);\\n            }\\n        }\\n        return maxPath + price[i];\\n    } \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3053927,
                "title": "three-diffrent-solutions",
                "content": "## Solution 1\\n- Enumerate the root nodes and find the maximum path sum from each root node to the leaf. \\n- Pass the maximum path sum from parent branch during DFS. \\n\\n```\\n\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        g=[[] for _ in range(n)]\\n        for a,b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n        \\n        down_sum=[0]*n\\n        def dfs(i,p):\\n            r=price[i]\\n            for ch in g[i]:\\n                if ch==p:continue\\n                r=max(r,price[i]+dfs(ch,i))\\n            down_sum[i]=r\\n            return r\\n        dfs(0,-1)\\n\\n        res=0\\n        def dfs2(i, p, parent_sum):\\n            nonlocal res\\n            all_branch=[(parent_sum, p)]\\n            for child in g[i]:\\n                if child==p:continue\\n                res = max(res, down_sum[child])\\n                all_branch.append((down_sum[child],child))\\n                \\n            all_branch.sort()\\n            for child in g[i]:\\n                if child==p:continue\\n                if all_branch[-1][1]==child:\\n                    dfs2(child,i,all_branch[-2][0]+price[i])\\n                else:\\n                    dfs2(child,i,all_branch[-1][0]+price[i])\\n                    \\n        dfs2(0,-1,0)\\n        return res\\n```\\n\\n## Solution 2\\n- Enumerate the root nodes and find the maximum path sum from each root node to the leaf.\\n- Use Memoized DFS to Eliminate Duplicate Computations\\n\\n```\\n\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        g = [[] for _ in range(n)]\\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n\\n        @cache\\n        def dfs(i, p):\\n            r = 0\\n            for child in g[i]:\\n                if child==p: continue\\n                r = max(r, dfs(child, i)+price[child])\\n            return r\\n\\n        return max(dfs(i,-1) for i in range(n))\\n\\n```\\n\\n## Solution 3\\n- Enumerate simple paths in the tree.\\n\\n\\nSimilar to [124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/), the simple path in the tree is enumerated by DFS once, and the currently traversed node does not have to be the endpoint of the path.\\n\\nWhen we visit a node, we consider the simple path througth current node.\\n1. If current node has only one child branch, this node can be the path end.\\n2. Else the path sum is the sum of two diffrent child branches, but one of the branche\\'s sum need to be substracted by the weight of the leaf node. Then we find the maximum combination of two child branches.\\n\\nThe dfs function need to return two values, one is the maximum path sum in all child branches, another is the maximum sum of leaf-weight-removed path sum.\\n\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        if n==1:return 0\\n\\n        g=[[] for _ in range(n)]\\n        for a,b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n\\n        res=0\\n        def dfs(i,p):\\n            nonlocal res\\n            sum_full=[]\\n            sum_sub=[]\\n\\n            for ch in g[i]:\\n                if ch==p:continue\\n                full,sub=dfs(ch,i)\\n                sum_full.append((full+price[i],ch))\\n                sum_sub.append((sub+price[i],ch))\\n\\n            if sum_full==[]:\\n                return (price[i],0)\\n\\n            sum_full.sort(reverse=True)\\n            sum_sub.sort(reverse=True)\\n\\n            if len(sum_full) == 1:\\n                res=max(res,max(sum_sub[0][0], sum_full[0][0] - price[i]))\\n            elif sum_full[0][1] != sum_sub[0][1]:\\n                res = max(res, sum_full[0][0] + sum_sub[0][0] - price[i])\\n            else:\\n                res = max(res, max(sum_sub[1][0]+sum_full[0][0], sum_sub[0][0]+sum_full[1][0])-price[i])\\n\\n            return (sum_full[0][0],sum_sub[0][0])\\n\\n        dfs(0,-1)\\n        return res\\n\\n\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        g=[[] for _ in range(n)]\\n        for a,b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n        \\n        down_sum=[0]*n\\n        def dfs(i,p):\\n            r=price[i]\\n            for ch in g[i]:\\n                if ch==p:continue\\n                r=max(r,price[i]+dfs(ch,i))\\n            down_sum[i]=r\\n            return r\\n        dfs(0,-1)\\n\\n        res=0\\n        def dfs2(i, p, parent_sum):\\n            nonlocal res\\n            all_branch=[(parent_sum, p)]\\n            for child in g[i]:\\n                if child==p:continue\\n                res = max(res, down_sum[child])\\n                all_branch.append((down_sum[child],child))\\n                \\n            all_branch.sort()\\n            for child in g[i]:\\n                if child==p:continue\\n                if all_branch[-1][1]==child:\\n                    dfs2(child,i,all_branch[-2][0]+price[i])\\n                else:\\n                    dfs2(child,i,all_branch[-1][0]+price[i])\\n                    \\n        dfs2(0,-1,0)\\n        return res\\n```\n```\\n\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        g = [[] for _ in range(n)]\\n        for a, b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n\\n        @cache\\n        def dfs(i, p):\\n            r = 0\\n            for child in g[i]:\\n                if child==p: continue\\n                r = max(r, dfs(child, i)+price[child])\\n            return r\\n\\n        return max(dfs(i,-1) for i in range(n))\\n\\n```\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        if n==1:return 0\\n\\n        g=[[] for _ in range(n)]\\n        for a,b in edges:\\n            g[a].append(b)\\n            g[b].append(a)\\n\\n        res=0\\n        def dfs(i,p):\\n            nonlocal res\\n            sum_full=[]\\n            sum_sub=[]\\n\\n            for ch in g[i]:\\n                if ch==p:continue\\n                full,sub=dfs(ch,i)\\n                sum_full.append((full+price[i],ch))\\n                sum_sub.append((sub+price[i],ch))\\n\\n            if sum_full==[]:\\n                return (price[i],0)\\n\\n            sum_full.sort(reverse=True)\\n            sum_sub.sort(reverse=True)\\n\\n            if len(sum_full) == 1:\\n                res=max(res,max(sum_sub[0][0], sum_full[0][0] - price[i]))\\n            elif sum_full[0][1] != sum_sub[0][1]:\\n                res = max(res, sum_full[0][0] + sum_sub[0][0] - price[i])\\n            else:\\n                res = max(res, max(sum_sub[1][0]+sum_full[0][0], sum_sub[0][0]+sum_full[1][0])-price[i])\\n\\n            return (sum_full[0][0],sum_sub[0][0])\\n\\n        dfs(0,-1)\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053039,
                "title": "better-than-most-voted-easiest-c-brute-force-memoisation",
                "content": "Just use the brute force approach and memoise it using map.\\nYes, it\\'s that simple.\\n\\nNote: We are not using a ```dp[n][n]``` here because creating this only will take ```O(n^2)``` time, whereas not every node is going to have n childrens, this is where map comes handy.\\n\\nC++ code:\\n```\\nclass Solution {\\npublic:\\n    \\n    map<pair<int, int>, long long> mp;\\n    \\n    long long getLongestPath(int src, int par, vector<vector<int>>& adj, vector<int>& price) {\\n        pair<int, int> key = {src, par+1};\\n        \\n        if(mp.find(key) != mp.end()) return mp[key];\\n        \\n        long long childMax = 0;\\n        for(auto it: adj[src]) {\\n            if(it == par) continue;\\n            \\n            long long val = getLongestPath(it, src, adj, price);\\n            childMax = max(childMax, val);\\n        }\\n        \\n        return mp[key] = childMax + price[src];\\n    }\\n    \\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>> adj(n);\\n        for(auto it: edges) {\\n            int u = it[0], v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n    \\n        long long res = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            long long path = getLongestPath(i, -1, adj, price);\\n            res = max(res, path - price[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree",
                    "Memoization"
                ],
                "code": "```dp[n][n]```\n```O(n^2)```\n```\\nclass Solution {\\npublic:\\n    \\n    map<pair<int, int>, long long> mp;\\n    \\n    long long getLongestPath(int src, int par, vector<vector<int>>& adj, vector<int>& price) {\\n        pair<int, int> key = {src, par+1};\\n        \\n        if(mp.find(key) != mp.end()) return mp[key];\\n        \\n        long long childMax = 0;\\n        for(auto it: adj[src]) {\\n            if(it == par) continue;\\n            \\n            long long val = getLongestPath(it, src, adj, price);\\n            childMax = max(childMax, val);\\n        }\\n        \\n        return mp[key] = childMax + price[src];\\n    }\\n    \\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>> adj(n);\\n        for(auto it: edges) {\\n            int u = it[0], v = it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n    \\n        long long res = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            long long path = getLongestPath(i, -1, adj, price);\\n            res = max(res, path - price[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052937,
                "title": "damn-just-need-one-more-line-to-get-ak-this-week",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse dfs to build max price of each node\\ndon\\'t look at my code, its too complex and not elegant\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        n2n = defaultdict(set)\\n        for a, b in edges:\\n            n2n[a].add(b)\\n            n2n[b].add(a)\\n        \\n        nodeandway2path = dict()\\n        visited = set()\\n        \\n        \\n        def dfs1(node):\\n            rtn = 0\\n            for nxt in n2n[node]:\\n                if nxt not in visited:\\n                    visited.add(nxt)\\n                    maxprice = dfs1(nxt)\\n                    nodeandway2path[(node, nxt)] = maxprice + price[node]\\n                    rtn = max(rtn, maxprice)\\n            return rtn + price[node]\\n                    \\n        visited.add(0)            \\n        dfs1(0)\\n        \\n        visited = set()\\n        \\n        def dfs2(node, father):\\n            if father != None:\\n                maxfatherprice = price[father]\\n                for nxt in n2n[father]:\\n                    if nxt != node:\\n                        maxfatherprice = max(nodeandway2path[(father, nxt)], maxfatherprice)\\n                nodeandway2path[(node, father)] = maxfatherprice + price[node]\\n            for nxt in n2n[node]:\\n                if nxt not in visited:\\n                    visited.add(nxt)\\n                    dfs2(nxt, node)\\n        visited.add(0)\\n        dfs2(0, None)\\n        \\n        \\n        res = 0\\n        for node in range(n):\\n            maxprice = 0\\n            for nxt in n2n[node]:\\n                maxprice = max(nodeandway2path[(node, nxt)], maxprice)\\n            res = max(res, maxprice - price[node])\\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        n2n = defaultdict(set)\\n        for a, b in edges:\\n            n2n[a].add(b)\\n            n2n[b].add(a)\\n        \\n        nodeandway2path = dict()\\n        visited = set()\\n        \\n        \\n        def dfs1(node):\\n            rtn = 0\\n            for nxt in n2n[node]:\\n                if nxt not in visited:\\n                    visited.add(nxt)\\n                    maxprice = dfs1(nxt)\\n                    nodeandway2path[(node, nxt)] = maxprice + price[node]\\n                    rtn = max(rtn, maxprice)\\n            return rtn + price[node]\\n                    \\n        visited.add(0)            \\n        dfs1(0)\\n        \\n        visited = set()\\n        \\n        def dfs2(node, father):\\n            if father != None:\\n                maxfatherprice = price[father]\\n                for nxt in n2n[father]:\\n                    if nxt != node:\\n                        maxfatherprice = max(nodeandway2path[(father, nxt)], maxfatherprice)\\n                nodeandway2path[(node, father)] = maxfatherprice + price[node]\\n            for nxt in n2n[node]:\\n                if nxt not in visited:\\n                    visited.add(nxt)\\n                    dfs2(nxt, node)\\n        visited.add(0)\\n        dfs2(0, None)\\n        \\n        \\n        res = 0\\n        for node in range(n):\\n            maxprice = 0\\n            for nxt in n2n[node]:\\n                maxprice = max(nodeandway2path[(node, nxt)], maxprice)\\n            res = max(res, maxprice - price[node])\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052899,
                "title": "python-2-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        # 1 <= price[i] <= 10^^5\\n        # min value is value of the root itself\\n        # find max value from the root to any leaf\\n        \\n        \\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        \\n        rtl = [[] for _ in range(n)]\\n        # first traversal to find the node to leaf path from each of the node (assume 0 is the root)\\n        def traverse1(node, parent):\\n            for nei in graph[node]:\\n                if nei == parent: continue\\n                traverse1(nei, node)\\n                \\n                child = rtl[nei][-1] # the max entry\\n                rtl[node].append(child + price[node])\\n                \\n            if not rtl[node]:\\n                rtl[node].append(price[node])\\n            \\n            rtl[node].sort()\\n            rtl[node] = rtl[node][-2:]  # keep at most 2 entry, we dont need more\\n            \\n        traverse1(0, -1)\\n        \\n        ans = 0\\n        # second traversal to compute the result from the parent, max parent path that not going through the current node\\n        def traverse2(node, parent):\\n            if parent != -1:\\n                if len(rtl[parent]) == 1: # only 1 path\\n                    rtl[node].append(price[parent] + price[node])\\n                else:\\n                    if rtl[node][-1] + price[parent] == rtl[parent][-1]: # this is the longest path, we take the next longest\\n                        rtl[node].append(rtl[parent][-2] + price[node])\\n                    else:\\n                        rtl[node].append(rtl[parent][-1] + price[node])\\n            \\n            rtl[node].sort()\\n            for nei in graph[node]:\\n                if nei == parent:\\n                    continue\\n                \\n                traverse2(nei, node)\\n            \\n        traverse2(0, -1)\\n        return max(rtl[i][-1] - price[i] for i in range(n))\\n                \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        # 1 <= price[i] <= 10^^5\\n        # min value is value of the root itself\\n        # find max value from the root to any leaf\\n        \\n        \\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            \\n        \\n        rtl = [[] for _ in range(n)]\\n        # first traversal to find the node to leaf path from each of the node (assume 0 is the root)\\n        def traverse1(node, parent):\\n            for nei in graph[node]:\\n                if nei == parent: continue\\n                traverse1(nei, node)\\n                \\n                child = rtl[nei][-1] # the max entry\\n                rtl[node].append(child + price[node])\\n                \\n            if not rtl[node]:\\n                rtl[node].append(price[node])\\n            \\n            rtl[node].sort()\\n            rtl[node] = rtl[node][-2:]  # keep at most 2 entry, we dont need more\\n            \\n        traverse1(0, -1)\\n        \\n        ans = 0\\n        # second traversal to compute the result from the parent, max parent path that not going through the current node\\n        def traverse2(node, parent):\\n            if parent != -1:\\n                if len(rtl[parent]) == 1: # only 1 path\\n                    rtl[node].append(price[parent] + price[node])\\n                else:\\n                    if rtl[node][-1] + price[parent] == rtl[parent][-1]: # this is the longest path, we take the next longest\\n                        rtl[node].append(rtl[parent][-2] + price[node])\\n                    else:\\n                        rtl[node].append(rtl[parent][-1] + price[node])\\n            \\n            rtl[node].sort()\\n            for nei in graph[node]:\\n                if nei == parent:\\n                    continue\\n                \\n                traverse2(nei, node)\\n            \\n        traverse2(0, -1)\\n        return max(rtl[i][-1] - price[i] for i in range(n))\\n                \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052787,
                "title": "dp-topdown-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDP: dp(u,v) (Node.max in the program) would store the maximum path length from v considering u as the parent node.\\n\\ndp(u,v) = price[v]+max(dp(v, w)) where w belongs to {adj[v]} - {u}.\\n\\nUsing memoization to store all the values of (u,v). Number of such values = 2*Number of edges (for edge a-b, once \\'a\\' as parent and once \\'b\\' as parent) = O(n).\\n\\nConsider a node \\'i\\' as the root.\\nThe minimum path sum would only include node \\'i\\'.\\nThe maximum path sum would include node \\'i\\' + max(dp(i,adj[i])).\\nThus the difference is simply max(dp(i, adj[i])).\\n\\nThus, calculating all the path values dp(u,v) and finding the maximum of it would be our solution.\\n\\nAnswer = max(dp(u,v))\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThere are O(E) pairs of parent-child nodes.\\nSince Graph is a tree, number of edges = n-1.\\nThus, O(n) to calculate the dp max values.\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        Graph G = new Graph(n, price);\\n        for(int[] edge: edges) {\\n            G.addEdge(edge[0], edge[1]);\\n        }\\n        G.calcMax();\\n        return G.ans;\\n    }\\n    \\n    class Graph {\\n        int V;\\n        Map<Integer, Node> adj[];\\n        int[] price;\\n        long ans = 0;\\n        \\n        Graph(int V, int[] price) {\\n            this.V = V;\\n            this.adj = new HashMap[V];\\n            for(int i=0;i<V;i++) {\\n                adj[i] = new HashMap<>();\\n            }\\n            this.price = price;\\n        }\\n        \\n        void addEdge(int u, int v) {\\n            adj[u].put(v, new Node(u,v));\\n            adj[v].put(u, new Node(v,u));\\n        }\\n        \\n        long calcMax() {\\n            int max = 0;\\n            for(int u=0;u<V;u++) {\\n                for(Node n: adj[u].values()) {\\n                    calcMax(n.v, u);\\n                    //System.out.println(u+\" \"+n.v+\" \"+n.max);\\n                }\\n            }\\n            return 0;\\n        }\\n        \\n        long calcMax(int curr, int parent) {\\n            if(adj[parent].get(curr).max!=0) {\\n                return adj[parent].get(curr).max;\\n            }\\n            long max = 0;\\n            for(Node n: adj[curr].values()) {\\n                if(n.v!=parent) {\\n                    max = Math.max(max, calcMax(n.v, curr));\\n                }\\n            }\\n            adj[parent].get(curr).max = price[curr]+max;\\n            ans = Math.max(ans, price[curr]+max);\\n            return price[curr]+max;\\n        }\\n    }\\n    \\n    class Node {\\n        int u;\\n        int v;\\n        long max;\\n        \\n        Node(int u, int v) {\\n            this.u = u;\\n            this.v = v;\\n            this.max = 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        Graph G = new Graph(n, price);\\n        for(int[] edge: edges) {\\n            G.addEdge(edge[0], edge[1]);\\n        }\\n        G.calcMax();\\n        return G.ans;\\n    }\\n    \\n    class Graph {\\n        int V;\\n        Map<Integer, Node> adj[];\\n        int[] price;\\n        long ans = 0;\\n        \\n        Graph(int V, int[] price) {\\n            this.V = V;\\n            this.adj = new HashMap[V];\\n            for(int i=0;i<V;i++) {\\n                adj[i] = new HashMap<>();\\n            }\\n            this.price = price;\\n        }\\n        \\n        void addEdge(int u, int v) {\\n            adj[u].put(v, new Node(u,v));\\n            adj[v].put(u, new Node(v,u));\\n        }\\n        \\n        long calcMax() {\\n            int max = 0;\\n            for(int u=0;u<V;u++) {\\n                for(Node n: adj[u].values()) {\\n                    calcMax(n.v, u);\\n                    //System.out.println(u+\" \"+n.v+\" \"+n.max);\\n                }\\n            }\\n            return 0;\\n        }\\n        \\n        long calcMax(int curr, int parent) {\\n            if(adj[parent].get(curr).max!=0) {\\n                return adj[parent].get(curr).max;\\n            }\\n            long max = 0;\\n            for(Node n: adj[curr].values()) {\\n                if(n.v!=parent) {\\n                    max = Math.max(max, calcMax(n.v, curr));\\n                }\\n            }\\n            adj[parent].get(curr).max = price[curr]+max;\\n            ans = Math.max(ans, price[curr]+max);\\n            return price[curr]+max;\\n        }\\n    }\\n    \\n    class Node {\\n        int u;\\n        int v;\\n        long max;\\n        \\n        Node(int u, int v) {\\n            this.u = u;\\n            this.v = v;\\n            this.max = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052747,
                "title": "c-dfs-bfs-memo",
                "content": "use bfs to avoid stack over flow for 1e5 nodes\\n```\\nclass Solution {\\n    long long res = -1;\\n    vector<pair<long long, long long>> val;\\n    vector<vector<long long>> adj;\\n    vector<long long> P;\\n    void dfs(long long u, long long par) {\\n        val[u] = {0,P[u]};\\n        for(auto& v : adj[u]) {\\n            if(v == par) continue;\\n            dfs(v,u);\\n            val[u].first = max(val[u].first, val[v].first + P[u]);\\n            val[u].second = max(val[u].second, val[v].second + P[u]);\\n        }\\n        res = max(res, val[u].first);\\n    }\\n    void bfs(long long u, long long par, long long ma1, long long ma2) {\\n        queue<array<long long,4>> q;\\n        q.push({u,par,ma1,ma2});\\n        while(q.size()) {\\n            auto [u,par,ma1,ma2] = q.front(); q.pop();\\n            priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> q1,q2;\\n            res = max(res, ma1);\\n            q1.push({ma1,par});\\n            q2.push({ma2,par});\\n            q1.push({0,u});\\n            q2.push({P[u],u});\\n            for(auto& v : adj[u]) {\\n                if(v == par) continue;\\n                q1.push({val[v].first,v});\\n                q2.push({val[v].second,v});\\n                if(q1.size() > 2) q1.pop();\\n                if(q2.size() > 2) q2.pop();\\n            }\\n            vector<pair<long long, long long>> ma1v, ma2v;\\n            while(q1.size()) {\\n                ma1v.push_back(q1.top());\\n                q1.pop();\\n            }\\n            while(q2.size()) {\\n                ma2v.push_back(q2.top());\\n                q2.pop();\\n            }\\n            for(auto& [v1, idx1] : ma1v) {\\n                for(auto& [v2,idx2] : ma2v) {\\n                    if(idx1 == idx2) continue;\\n                    res = max(res,v1 + v2);\\n                }\\n            }\\n            for(auto& v : adj[u]) {\\n                if(v == par) continue;\\n                long long ma1u = 0, ma2u = 0;\\n                for(auto [value, idx] : ma1v) {\\n                    if(idx == v) continue;\\n                    ma1u = max(ma1u, value);\\n                    if(idx != par and idx != u) ma1u = max(ma1u, value + P[u]);\\n                }\\n                for(auto [value, idx] : ma2v) {\\n                    if(idx == v) continue;\\n                    ma2u = max(ma2u, value);\\n                    if(idx != par and idx != u) ma2u = max(ma2u, value + P[u]);\\n                }\\n                res = max(res, ma1u + val[v].second);\\n                res = max(res, ma2u + val[v].first);\\n                q.push({v,u,ma1u,ma2u});\\n            }\\n        }\\n\\n    }\\n\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        adj = vector<vector<long long>>(n + 10);\\n        val = vector<pair<long long,long long>>(n + 10);\\n        res = -1;\\n        for(auto e : edges) {\\n            int u = e[0], v = e[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        P = vector<long long>(n + 10);\\n        for(int i = 0; i < n; i++) P[i] = price[i];\\n        dfs(0,-1);\\n        bfs(0,-1,INT_MIN,INT_MIN);\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    long long res = -1;\\n    vector<pair<long long, long long>> val;\\n    vector<vector<long long>> adj;\\n    vector<long long> P;\\n    void dfs(long long u, long long par) {\\n        val[u] = {0,P[u]};\\n        for(auto& v : adj[u]) {\\n            if(v == par) continue;\\n            dfs(v,u);\\n            val[u].first = max(val[u].first, val[v].first + P[u]);\\n            val[u].second = max(val[u].second, val[v].second + P[u]);\\n        }\\n        res = max(res, val[u].first);\\n    }\\n    void bfs(long long u, long long par, long long ma1, long long ma2) {\\n        queue<array<long long,4>> q;\\n        q.push({u,par,ma1,ma2});\\n        while(q.size()) {\\n            auto [u,par,ma1,ma2] = q.front(); q.pop();\\n            priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> q1,q2;\\n            res = max(res, ma1);\\n            q1.push({ma1,par});\\n            q2.push({ma2,par});\\n            q1.push({0,u});\\n            q2.push({P[u],u});\\n            for(auto& v : adj[u]) {\\n                if(v == par) continue;\\n                q1.push({val[v].first,v});\\n                q2.push({val[v].second,v});\\n                if(q1.size() > 2) q1.pop();\\n                if(q2.size() > 2) q2.pop();\\n            }\\n            vector<pair<long long, long long>> ma1v, ma2v;\\n            while(q1.size()) {\\n                ma1v.push_back(q1.top());\\n                q1.pop();\\n            }\\n            while(q2.size()) {\\n                ma2v.push_back(q2.top());\\n                q2.pop();\\n            }\\n            for(auto& [v1, idx1] : ma1v) {\\n                for(auto& [v2,idx2] : ma2v) {\\n                    if(idx1 == idx2) continue;\\n                    res = max(res,v1 + v2);\\n                }\\n            }\\n            for(auto& v : adj[u]) {\\n                if(v == par) continue;\\n                long long ma1u = 0, ma2u = 0;\\n                for(auto [value, idx] : ma1v) {\\n                    if(idx == v) continue;\\n                    ma1u = max(ma1u, value);\\n                    if(idx != par and idx != u) ma1u = max(ma1u, value + P[u]);\\n                }\\n                for(auto [value, idx] : ma2v) {\\n                    if(idx == v) continue;\\n                    ma2u = max(ma2u, value);\\n                    if(idx != par and idx != u) ma2u = max(ma2u, value + P[u]);\\n                }\\n                res = max(res, ma1u + val[v].second);\\n                res = max(res, ma2u + val[v].first);\\n                q.push({v,u,ma1u,ma2u});\\n            }\\n        }\\n\\n    }\\n\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        adj = vector<vector<long long>>(n + 10);\\n        val = vector<pair<long long,long long>>(n + 10);\\n        res = -1;\\n        for(auto e : edges) {\\n            int u = e[0], v = e[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        P = vector<long long>(n + 10);\\n        for(int i = 0; i < n; i++) P[i] = price[i];\\n        dfs(0,-1);\\n        bfs(0,-1,INT_MIN,INT_MIN);\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052687,
                "title": "python3-dfs",
                "content": "\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        tree = [[] for _ in range(n)]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def dfs(u, p): \\n            \"\"\"Return \"\"\"\\n            nonlocal ans\\n            include = [] # include leaf value \\n            exclude = [] # exclude leaf value\\n            for v in tree[u]:\\n                if v != p: \\n                    x, y = dfs(v, u)\\n                    include.append((x+price[u], v))\\n                    exclude.append((y+price[u], v))\\n            if not include: \\n                include = [(price[u], u)]\\n                exclude = [(0, u)]\\n            if len(include) == 1: ans = max(ans, include[0][0] - price[u], exclude[0][0])\\n            else: \\n                include.sort(reverse=True)\\n                for e, v in exclude: \\n                    if v != include[0][1]: cand = e + include[0][0] - price[u]\\n                    else: cand = e + include[1][0] - price[u]\\n                    ans = max(ans, cand)\\n            return include[0][0], max(exclude)[0]\\n        \\n        ans = 0 \\n        dfs(0, -1)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        tree = [[] for _ in range(n)]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def dfs(u, p): \\n            \"\"\"Return \"\"\"\\n            nonlocal ans\\n            include = [] # include leaf value \\n            exclude = [] # exclude leaf value\\n            for v in tree[u]:\\n                if v != p: \\n                    x, y = dfs(v, u)\\n                    include.append((x+price[u], v))\\n                    exclude.append((y+price[u], v))\\n            if not include: \\n                include = [(price[u], u)]\\n                exclude = [(0, u)]\\n            if len(include) == 1: ans = max(ans, include[0][0] - price[u], exclude[0][0])\\n            else: \\n                include.sort(reverse=True)\\n                for e, v in exclude: \\n                    if v != include[0][1]: cand = e + include[0][0] - price[u]\\n                    else: cand = e + include[1][0] - price[u]\\n                    ans = max(ans, cand)\\n            return include[0][0], max(exclude)[0]\\n        \\n        ans = 0 \\n        dfs(0, -1)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096838,
                "title": "re-rooting-o-n-explained",
                "content": "# AUTHOR: JAYESH BADGUJAR\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Using DP O(N) Solution\\u2705\\n    long long dfs(int src,map<int,vector<int>>& mp,vector<int>& price,vector<long long>& dp,int par){\\n        long long maxi=price[src];\\n        for(auto it:mp[src]){\\n            if(it==par){\\n                continue;\\n            }\\n            maxi=max(maxi,price[src]+dfs(it,mp,price,dp,src));\\n        }\\n        \\n        return dp[src]=maxi;\\n    }\\n    void find(int src,map<int,vector<int>>& mp,vector<int>& price,vector<long long>& dp,vector<long long>& ans,int par,long long pre_sum){\\n        long long maxi=0;\\n        vector<long long> v;\\n        bool child=false;\\n        for(auto it:mp[src]){\\n            if(it==par) continue;\\n            child=true;\\n            maxi=max(maxi,dp[it]);\\n            v.push_back(dp[it]);\\n        }\\n        ans[src]=max(ans[src],maxi);\\n        int n=v.size();\\n        vector<long long> pre(n,0),suff(n,0);\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                pre[i]=v[i];\\n            }else{\\n                pre[i]=max(v[i],pre[i-1]);\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(i==n-1){\\n                suff[i]=v[i];\\n            }else{\\n                suff[i]=max(v[i],suff[i+1]);\\n            }\\n        }\\n        int i=0;\\n        for(auto it:mp[src]){\\n            if(it!=par){\\n                long long child_mx=0;\\n                if(i!=0){\\n                    child_mx=max(child_mx,pre[i-1]);\\n                }\\n                if(i!=n-1){\\n                    child_mx=max(child_mx,suff[i+1]);\\n                }\\n                child_mx=max(child_mx,pre_sum);\\n                ans[it]=max(ans[it],price[src]+child_mx);\\n                find(it,mp,price,dp,ans,src,price[src]+child_mx);\\n                i++;\\n            }\\n        }\\n        \\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<long long> dp(n,0),ans(n,0);\\n        map<int,vector<int>> mp;\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        dfs(0,mp,price,dp,-1);        \\n        find(0,mp,price,dp,ans,-1,0);\\n         long long maxi=0;\\n         for(int i=0;i<n;i++){\\n             maxi=max(maxi,ans[i]);\\n         }\\n         return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Using DP O(N) Solution\\u2705\\n    long long dfs(int src,map<int,vector<int>>& mp,vector<int>& price,vector<long long>& dp,int par){\\n        long long maxi=price[src];\\n        for(auto it:mp[src]){\\n            if(it==par){\\n                continue;\\n            }\\n            maxi=max(maxi,price[src]+dfs(it,mp,price,dp,src));\\n        }\\n        \\n        return dp[src]=maxi;\\n    }\\n    void find(int src,map<int,vector<int>>& mp,vector<int>& price,vector<long long>& dp,vector<long long>& ans,int par,long long pre_sum){\\n        long long maxi=0;\\n        vector<long long> v;\\n        bool child=false;\\n        for(auto it:mp[src]){\\n            if(it==par) continue;\\n            child=true;\\n            maxi=max(maxi,dp[it]);\\n            v.push_back(dp[it]);\\n        }\\n        ans[src]=max(ans[src],maxi);\\n        int n=v.size();\\n        vector<long long> pre(n,0),suff(n,0);\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                pre[i]=v[i];\\n            }else{\\n                pre[i]=max(v[i],pre[i-1]);\\n            }\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            if(i==n-1){\\n                suff[i]=v[i];\\n            }else{\\n                suff[i]=max(v[i],suff[i+1]);\\n            }\\n        }\\n        int i=0;\\n        for(auto it:mp[src]){\\n            if(it!=par){\\n                long long child_mx=0;\\n                if(i!=0){\\n                    child_mx=max(child_mx,pre[i-1]);\\n                }\\n                if(i!=n-1){\\n                    child_mx=max(child_mx,suff[i+1]);\\n                }\\n                child_mx=max(child_mx,pre_sum);\\n                ans[it]=max(ans[it],price[src]+child_mx);\\n                find(it,mp,price,dp,ans,src,price[src]+child_mx);\\n                i++;\\n            }\\n        }\\n        \\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<long long> dp(n,0),ans(n,0);\\n        map<int,vector<int>> mp;\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        dfs(0,mp,price,dp,-1);        \\n        find(0,mp,price,dp,ans,-1,0);\\n         long long maxi=0;\\n         for(int i=0;i<n;i++){\\n             maxi=max(maxi,ans[i]);\\n         }\\n         return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3983754,
                "title": "tree-kh-ng-c-root",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndfs: t\\u1EA1i m\\u1ED7i node, l\\u01B0u {\\u0111\\u01B0\\u1EDDng max nh\\u1EA5t t\\u1EEB node xu\\u1ED1ng l\\xE1, \\u0111\\u01B0\\u1EDDng max nh\\u1EA5t t\\u1EEB root xu\\u1ED1ng l\\xE1 - node cu\\u1ED1i}\\nL\\xE2y k\\u1EBFt qu\\u1EA3: T\\u1EA1i 1 node, for c\\xE1c nh\\xE1nh con v\\xE0 c\\u1EADp nh\\u1EADt res trong qu\\xE1 tr\\xECnh for, ch\\u1ECDn trong c\\xE1c tr\\u01B0\\u1EDDng h\\u1EE3p F \\u0111\\xE3 duy\\u1EC7t + S ti\\u1EBFp theo ho\\u1EB7c S \\u0111\\xE3 duy\\u1EC7t + F ti\\u1EBFp theo\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define pii pair<int, int>\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>> adj(n);\\n        for(auto&x:edges) {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        long long res = 0;\\n        function<pii(int,int)> dfs=[&](int node, int pre_node) {\\n            pii res_i = {price[node], 0};\\n            for(auto n_node:adj[node]) {\\n                if(n_node == pre_node) continue;\\n                pii n_res = dfs(n_node,node);\\n                res = max(res, 1ll*res_i.F + n_res.S);\\n                res = max(res, 1ll*res_i.S + n_res.F);\\n                res_i.F = max(res_i.F, price[node] + n_res.F);\\n                res_i.S = max(res_i.S, price[node] + n_res.S);\\n            }\\n            return res_i;\\n        };\\n        dfs(0,-1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define pii pair<int, int>\\n#define F first\\n#define S second\\n\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>> adj(n);\\n        for(auto&x:edges) {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        long long res = 0;\\n        function<pii(int,int)> dfs=[&](int node, int pre_node) {\\n            pii res_i = {price[node], 0};\\n            for(auto n_node:adj[node]) {\\n                if(n_node == pre_node) continue;\\n                pii n_res = dfs(n_node,node);\\n                res = max(res, 1ll*res_i.F + n_res.S);\\n                res = max(res, 1ll*res_i.S + n_res.F);\\n                res_i.F = max(res_i.F, price[node] + n_res.F);\\n                res_i.S = max(res_i.S, price[node] + n_res.S);\\n            }\\n            return res_i;\\n        };\\n        dfs(0,-1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974731,
                "title": "clean-in-out-dp-o-n-time-space",
                "content": "```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> adj;\\n    vector<int> p;\\n    vector<multiset<int>> in;\\n    vector<int> out;\\n    int res;\\n    void dfs1(int node, int par){\\n        in[node].insert(p[node]);\\n        in[node].insert(0);\\n        for(auto &a:adj[node]){\\n            if(a==par)\\n                continue;\\n            dfs1(a,node);\\n            in[node].insert(*in[a].rbegin()+p[node]);\\n            while(in[node].size()>2)\\n                in[node].erase(in[node].begin());\\n        }\\n    }\\n    void dfs2(int node, int par){\\n        out[node]=max(p[node],out[node]);\\n        for(auto &a:adj[node]){\\n            if(a==par)\\n                continue;\\n            out[a]=max(out[node]+p[a],out[a]);\\n            if(*in[node].rbegin()-p[node]==*in[a].rbegin())\\n                out[a]=max(*in[node].begin()+p[a],out[a]);\\n            else\\n                out[a]=max(*in[node].rbegin()+p[a],out[a]);\\n            dfs2(a,node);\\n        }\\n        res=max({*in[node].rbegin()-p[node],out[node]-p[node],res});\\n    }\\npublic:\\n    long long maxOutput(int nn, vector<vector<int>>& edges, vector<int>& price) {\\n        n=nn;\\n        p=price;\\n        adj.assign(n,{});\\n        in.assign(n,{0,0});\\n        out.assign(n,0);\\n        res=-1;\\n        for(auto &e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        dfs1(0,-1);\\n        dfs2(0,-1);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> adj;\\n    vector<int> p;\\n    vector<multiset<int>> in;\\n    vector<int> out;\\n    int res;\\n    void dfs1(int node, int par){\\n        in[node].insert(p[node]);\\n        in[node].insert(0);\\n        for(auto &a:adj[node]){\\n            if(a==par)\\n                continue;\\n            dfs1(a,node);\\n            in[node].insert(*in[a].rbegin()+p[node]);\\n            while(in[node].size()>2)\\n                in[node].erase(in[node].begin());\\n        }\\n    }\\n    void dfs2(int node, int par){\\n        out[node]=max(p[node],out[node]);\\n        for(auto &a:adj[node]){\\n            if(a==par)\\n                continue;\\n            out[a]=max(out[node]+p[a],out[a]);\\n            if(*in[node].rbegin()-p[node]==*in[a].rbegin())\\n                out[a]=max(*in[node].begin()+p[a],out[a]);\\n            else\\n                out[a]=max(*in[node].rbegin()+p[a],out[a]);\\n            dfs2(a,node);\\n        }\\n        res=max({*in[node].rbegin()-p[node],out[node]-p[node],res});\\n    }\\npublic:\\n    long long maxOutput(int nn, vector<vector<int>>& edges, vector<int>& price) {\\n        n=nn;\\n        p=price;\\n        adj.assign(n,{});\\n        in.assign(n,{0,0});\\n        out.assign(n,0);\\n        res=-1;\\n        for(auto &e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        dfs1(0,-1);\\n        dfs2(0,-1);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958665,
                "title": "code-is-lengthy-problem-is-based-on-tree-diameter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTree Diameter was my approach \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph;\\n    vector<int> cost;\\n    int n;\\n    pair<int,int> bfs(int node){\\n        vector<int> dist(n,INT_MIN);\\n        vector<int> visited(n,0);\\n        dist[node]=0;\\n        visited[node]=cost[node];\\n        int maxi = 0,resnode=node;\\n        queue<int> q;\\n        q.push(node);\\n        while(!q.empty()){\\n            int vertex = q.front();q.pop();\\n            visited[vertex]=1;\\n            for(int child:graph[vertex]){\\n                if(visited[child]==0 && dist[child]<dist[vertex]+cost[child]){\\n                    q.push(child);\\n                    visited[child]=1;\\n                    dist[child]=dist[vertex]+cost[child];\\n                    if(maxi<dist[child]){\\n                    maxi = dist[child];\\n                    resnode = child;\\n                    }\\n                }\\n            }\\n        }\\n        return {resnode,maxi};\\n    }\\n    vector<int> bfs1(int node){\\n        vector<int> dist(n,INT_MIN);\\n        vector<int> visited(n,0);\\n        dist[node]=cost[node];\\n        visited[node]=1;\\n        int maxi = 0,resnode=node;\\n        queue<int> q;\\n        q.push(node);\\n        while(!q.empty()){\\n            int vertex = q.front();q.pop();\\n            visited[vertex]=1;\\n            for(int child:graph[vertex]){\\n            if(visited[child]==0 && dist[child]<dist[vertex]+cost[child]){\\n                q.push(child);\\n                visited[child]=1;\\n                dist[child]=dist[vertex]+cost[child];\\n                if(maxi<dist[child]){\\n                maxi = dist[child];\\n                resnode = child;\\n                }\\n            }\\n            }\\n        }\\n        return dist;\\n    }\\n    long long maxOutput(int N, vector<vector<int>>& edges, vector<int>& price) {\\n        n = N;\\n        graph.resize(n);\\n        for(int i:price) cost.push_back(i);\\n        for(auto it:edges){\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        pair<int,int> p;\\n        p = bfs(0);\\n        int node1 = p.first;\\n        p = bfs(node1);\\n        int node2 = p.first, maxi = p.second;\\n        vector<int> dist1 = bfs1(node1);\\n        vector<int> dist2 = bfs1(node2);\\n        vector<int> ans(n,INT_MIN);\\n        for(int i=0;i<n;i++){\\n            ans[i]=max(ans[i],max(dist1[i],dist2[i]))-cost[i];\\n        }\\n        return *max_element(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph;\\n    vector<int> cost;\\n    int n;\\n    pair<int,int> bfs(int node){\\n        vector<int> dist(n,INT_MIN);\\n        vector<int> visited(n,0);\\n        dist[node]=0;\\n        visited[node]=cost[node];\\n        int maxi = 0,resnode=node;\\n        queue<int> q;\\n        q.push(node);\\n        while(!q.empty()){\\n            int vertex = q.front();q.pop();\\n            visited[vertex]=1;\\n            for(int child:graph[vertex]){\\n                if(visited[child]==0 && dist[child]<dist[vertex]+cost[child]){\\n                    q.push(child);\\n                    visited[child]=1;\\n                    dist[child]=dist[vertex]+cost[child];\\n                    if(maxi<dist[child]){\\n                    maxi = dist[child];\\n                    resnode = child;\\n                    }\\n                }\\n            }\\n        }\\n        return {resnode,maxi};\\n    }\\n    vector<int> bfs1(int node){\\n        vector<int> dist(n,INT_MIN);\\n        vector<int> visited(n,0);\\n        dist[node]=cost[node];\\n        visited[node]=1;\\n        int maxi = 0,resnode=node;\\n        queue<int> q;\\n        q.push(node);\\n        while(!q.empty()){\\n            int vertex = q.front();q.pop();\\n            visited[vertex]=1;\\n            for(int child:graph[vertex]){\\n            if(visited[child]==0 && dist[child]<dist[vertex]+cost[child]){\\n                q.push(child);\\n                visited[child]=1;\\n                dist[child]=dist[vertex]+cost[child];\\n                if(maxi<dist[child]){\\n                maxi = dist[child];\\n                resnode = child;\\n                }\\n            }\\n            }\\n        }\\n        return dist;\\n    }\\n    long long maxOutput(int N, vector<vector<int>>& edges, vector<int>& price) {\\n        n = N;\\n        graph.resize(n);\\n        for(int i:price) cost.push_back(i);\\n        for(auto it:edges){\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        pair<int,int> p;\\n        p = bfs(0);\\n        int node1 = p.first;\\n        p = bfs(node1);\\n        int node2 = p.first, maxi = p.second;\\n        vector<int> dist1 = bfs1(node1);\\n        vector<int> dist2 = bfs1(node2);\\n        vector<int> ans(n,INT_MIN);\\n        for(int i=0;i<n;i++){\\n            ans[i]=max(ans[i],max(dist1[i],dist2[i]))-cost[i];\\n        }\\n        return *max_element(ans.begin(),ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942016,
                "title": "intuitive-dfs-o-n-working-solution",
                "content": "The code is a bit long but I have tried to explain wherever felt necessary\\n\\n# Code\\n```\\nclass Solution {\\n    ArrayList<ArrayList<Integer>> list;\\n    long ans = 0;\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        list = new ArrayList();\\n        for(int i=0;i<n;++i){\\n            list.add(new ArrayList<Integer>());\\n        }\\n        for(int[] e : edges){ // adj list\\n            list.get(e[0]).add(e[1]);\\n            list.get(e[1]).add(e[0]);\\n        }\\n        // precomputing the maximum cost of a path when we use dfs for each node\\n        long[] pre = new long[n];\\n        ans = solve1(pre, price, 0, -1); // max cost path using dfs\\n\\n        // But dfs gives us the max cost from one side\\n        // what if we can add the  max cost from the other side\\n        // as well --> then we would get the maximum cost path \\n        // passing through that node\\n\\n        boolean[] vis = new boolean[n];\\n        solve2(pre, price, 0, vis);\\n\\n        // finally if youre confused that why are we not subtracting minimum cost, \\n        // then note that minimum cost will be the node price itself and \\n        // we have not added it when calculating the max for that node\\n        return ans;\\n    }\\n\\n    // after using this function the pre array will have the\\n    // maximum cost path pre[i] rooted at i\\n    // assuming 0 as the root node (you could take any other)\\n    long solve1(long[] pre, int[] price, int ind, int par) {\\n        long res = 0l;\\n        for (int i: list.get(ind)) {\\n            if (i == par) continue;\\n            res = Math.max(res, price[i] + solve1(pre, price, i, ind));\\n        }\\n        return pre[ind] = res;\\n    }\\n    void solve2(long[] pre, int[] price, int ind, boolean[] vis){\\n        long temp = pre[ind];\\n        vis[ind] = true;\\n\\n        // this is the tricky part\\n        // we already have the presum (max cost path of a subtree)\\n        // so now we will do the same thing which we did in solve1\\n        // just in the opposite manner (first calculate max for that node, then dfs)\\n        // but if you think about it what if the node where we will be \\n        // going next is the subtree which has given us the maximum cost path\\n        // the calculation would become wrong\\n        // we will take the maximum costpath from all other subtrees\\n        // except from the one where we will be going next\\n\\n        long max1 = 0, max2 = 0;\\n        for(int i : list.get(ind)){\\n            if(max1 <= price[i] + pre[i]){\\n                max2 = max1;\\n                max1 = price[i] + pre[i];\\n            }\\n            else if(max2 < price[i] + pre[i]){\\n                max2 = price[i] + pre[i];\\n            }\\n        }\\n        for(int i : list.get(ind)){\\n            if(vis[i]) continue;\\n            long child = 0;\\n            if(pre[i] + price[i] == max1){\\n                child = max2;\\n            }\\n            else{\\n                child = max1;\\n            }\\n            pre[ind] = child; // it would be used in calculation, when we \\n            // go in the subtree and check its neighbours\\n\\n            long temp1 = pre[i]; \\n            pre[i] = Math.max(price[ind] + child, pre[i]);\\n            ans = Math.max(ans, pre[i]);\\n            vis[i] = true;\\n            solve2(pre, price, i, vis);\\n            pre[i] = temp1;\\n        } \\n        pre[ind] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    ArrayList<ArrayList<Integer>> list;\\n    long ans = 0;\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        list = new ArrayList();\\n        for(int i=0;i<n;++i){\\n            list.add(new ArrayList<Integer>());\\n        }\\n        for(int[] e : edges){ // adj list\\n            list.get(e[0]).add(e[1]);\\n            list.get(e[1]).add(e[0]);\\n        }\\n        // precomputing the maximum cost of a path when we use dfs for each node\\n        long[] pre = new long[n];\\n        ans = solve1(pre, price, 0, -1); // max cost path using dfs\\n\\n        // But dfs gives us the max cost from one side\\n        // what if we can add the  max cost from the other side\\n        // as well --> then we would get the maximum cost path \\n        // passing through that node\\n\\n        boolean[] vis = new boolean[n];\\n        solve2(pre, price, 0, vis);\\n\\n        // finally if youre confused that why are we not subtracting minimum cost, \\n        // then note that minimum cost will be the node price itself and \\n        // we have not added it when calculating the max for that node\\n        return ans;\\n    }\\n\\n    // after using this function the pre array will have the\\n    // maximum cost path pre[i] rooted at i\\n    // assuming 0 as the root node (you could take any other)\\n    long solve1(long[] pre, int[] price, int ind, int par) {\\n        long res = 0l;\\n        for (int i: list.get(ind)) {\\n            if (i == par) continue;\\n            res = Math.max(res, price[i] + solve1(pre, price, i, ind));\\n        }\\n        return pre[ind] = res;\\n    }\\n    void solve2(long[] pre, int[] price, int ind, boolean[] vis){\\n        long temp = pre[ind];\\n        vis[ind] = true;\\n\\n        // this is the tricky part\\n        // we already have the presum (max cost path of a subtree)\\n        // so now we will do the same thing which we did in solve1\\n        // just in the opposite manner (first calculate max for that node, then dfs)\\n        // but if you think about it what if the node where we will be \\n        // going next is the subtree which has given us the maximum cost path\\n        // the calculation would become wrong\\n        // we will take the maximum costpath from all other subtrees\\n        // except from the one where we will be going next\\n\\n        long max1 = 0, max2 = 0;\\n        for(int i : list.get(ind)){\\n            if(max1 <= price[i] + pre[i]){\\n                max2 = max1;\\n                max1 = price[i] + pre[i];\\n            }\\n            else if(max2 < price[i] + pre[i]){\\n                max2 = price[i] + pre[i];\\n            }\\n        }\\n        for(int i : list.get(ind)){\\n            if(vis[i]) continue;\\n            long child = 0;\\n            if(pre[i] + price[i] == max1){\\n                child = max2;\\n            }\\n            else{\\n                child = max1;\\n            }\\n            pre[ind] = child; // it would be used in calculation, when we \\n            // go in the subtree and check its neighbours\\n\\n            long temp1 = pre[i]; \\n            pre[i] = Math.max(price[ind] + child, pre[i]);\\n            ans = Math.max(ans, pre[i]);\\n            vis[i] = true;\\n            solve2(pre, price, i, vis);\\n            pre[i] = temp1;\\n        } \\n        pre[ind] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931404,
                "title": "re-rooting-tree-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThough code is readable I recommend watching Kartik Arora DP on trees playlist for proper understanding and how to approach to these kind of problems!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> tree[100000];\\n    long long subTreeAns[100000];\\n    long long ans[100000];\\n\\n    void pre(int node, int par, vector<long long>& price){\\n        long long curr = 0;\\n        for(auto child : tree[node]){\\n            if(child != par){\\n                pre(child,node,price);\\n                curr = max(curr, subTreeAns[child]);\\n            }\\n        }\\n        subTreeAns[node] = curr + price[node];\\n    }\\n    void solve(int node, int par, long long par_ans, vector<long long> &price){\\n        vector<long long> prefix, suffix;\\n        for(auto child : tree[node]){\\n            if(child != par){\\n                prefix.push_back(subTreeAns[child]);\\n                suffix.push_back(subTreeAns[child]);\\n            }\\n        }\\n        int n = prefix.size();\\n        for(int i=1;i<n;i++){\\n            prefix[i] = max(prefix[i], prefix[i-1]);\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            suffix[i] = max(suffix[i], suffix[i+1]);\\n        }\\n        int i = 0;\\n        for(auto child : tree[node]){\\n            if(child != par){\\n                long long left = i > 0 ? prefix[i-1] : 0;\\n                long long right = i < n - 1 ? suffix[i+1] : 0;\\n                solve(child, node, price[node] + max({left,right,par_ans}), price);\\n                i++;\\n            }\\n        }\\n        ans[node] = max(par_ans, n == 0 ? 0 : prefix[n-1]);\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        for(auto it : edges){\\n            tree[it[0]].push_back(it[1]);\\n            tree[it[1]].push_back(it[0]);\\n        }\\n        vector<long long> temp(n);\\n        for(int i=0;i<n;i++){\\n            temp[i] = (long long)price[i];\\n        }\\n        pre(0,-1,temp);\\n        solve(0,-1,0,temp);\\n        long long output = 0;\\n        for(int i=0;i<n;i++){\\n            output = max(output, ans[i]);\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> tree[100000];\\n    long long subTreeAns[100000];\\n    long long ans[100000];\\n\\n    void pre(int node, int par, vector<long long>& price){\\n        long long curr = 0;\\n        for(auto child : tree[node]){\\n            if(child != par){\\n                pre(child,node,price);\\n                curr = max(curr, subTreeAns[child]);\\n            }\\n        }\\n        subTreeAns[node] = curr + price[node];\\n    }\\n    void solve(int node, int par, long long par_ans, vector<long long> &price){\\n        vector<long long> prefix, suffix;\\n        for(auto child : tree[node]){\\n            if(child != par){\\n                prefix.push_back(subTreeAns[child]);\\n                suffix.push_back(subTreeAns[child]);\\n            }\\n        }\\n        int n = prefix.size();\\n        for(int i=1;i<n;i++){\\n            prefix[i] = max(prefix[i], prefix[i-1]);\\n        }\\n        for(int i=n-2;i>=0;i--){\\n            suffix[i] = max(suffix[i], suffix[i+1]);\\n        }\\n        int i = 0;\\n        for(auto child : tree[node]){\\n            if(child != par){\\n                long long left = i > 0 ? prefix[i-1] : 0;\\n                long long right = i < n - 1 ? suffix[i+1] : 0;\\n                solve(child, node, price[node] + max({left,right,par_ans}), price);\\n                i++;\\n            }\\n        }\\n        ans[node] = max(par_ans, n == 0 ? 0 : prefix[n-1]);\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        for(auto it : edges){\\n            tree[it[0]].push_back(it[1]);\\n            tree[it[1]].push_back(it[0]);\\n        }\\n        vector<long long> temp(n);\\n        for(int i=0;i<n;i++){\\n            temp[i] = (long long)price[i];\\n        }\\n        pre(0,-1,temp);\\n        solve(0,-1,0,temp);\\n        long long output = 0;\\n        for(int i=0;i<n;i++){\\n            output = max(output, ans[i]);\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869401,
                "title": "re-rooting-tree-dp-happy-coding",
                "content": "# Intuition\\nThis is a re-rooting tree dp problem \\n\\n# Approach\\nfirst find the solution for any one node as a root ( eg. 0);\\nthat is what dfs(0, -1) is finding \\n\\nthen we need to update the root that is done using dfs2(-1, 0, 0);\\nfunction\\nthe below implementation is a standard template for rerooting the tree\\nstep to follow are \\n1.) we are at root u , store the ans for this root\\n2.) do some kind of preprocessing in sub-linear time so that we do not exceed O(N^2) bound ( Note : this step is difference bases on question)\\n3.) change the roots to current nodees children\\n    here also note that we need to calculate the parent contribution for this child and pass it in the recursive call\\n\\nthats it for re-rooting \\n\\n# Code\\n```\\n#define ll long long\\n\\nclass Solution {\\n    vector<vector<ll>> g;\\n    vector<ll> prices;\\n    vector<ll> dp, ans;\\n    //dp[u] : store max path sum in the subtree of u;\\npublic:\\n    ll dfs(int u, int p){\\n        ll maxi = 0LL;\\n        for(auto &v : g[u]){\\n            if(v == p)continue;\\n            ll childsum = dfs(v, u);\\n            maxi = max(maxi, childsum);\\n        }\\n        return dp[u] = maxi + prices[u];\\n    }\\n\\n    void dfs2(int u, int p, ll parentSum){\\n        int c1 = -1; //stores the child having max sum;\\n        ll msum1 = 0, msum2 = 0; //store two max sum in childrens\\n\\n        //just storing values of childrens (preprocessing step)\\n        for(auto &v : g[u]){\\n            if(v == p)continue;\\n            if(dp[v] > msum1){\\n                msum2 = msum1;\\n                msum1 = dp[v];\\n                c1 = v;\\n            }else if(dp[v] > msum2){\\n                msum2 = dp[v];\\n            }\\n        }\\n\\n        //calculate the ans for this node as a root;\\n        ans[u] = max(msum1, parentSum) + (ll)prices[u] - (ll)prices[u]; //minSum path is only one node long\\n\\n        //change root\\n        for(auto &v : g[u]){\\n            if(p == v)continue;\\n            //this if-else is for deciding parentSum\\n            if(v == c1){ \\n                ll ps = max(msum2, parentSum) + (ll)prices[u];\\n                dfs2(v, u, ps);\\n            }else{\\n                ll ps = max(msum1, parentSum) + (ll)prices[u];\\n                dfs2(v, u, ps);\\n            }\\n        }\\n            \\n    }\\n\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        g.clear(), prices.clear(), dp.clear(), ans.clear();\\n        g.resize(n), prices.resize(n), dp.resize(n), ans.resize(n);\\n        for(auto ed : edges){\\n            g[ed[0]].push_back(ed[1]);\\n            g[ed[1]].push_back(ed[0]);\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            prices[i] = price[i];\\n        }\\n\\n        dfs(0, -1);\\n        dfs2(0, -1, 0);\\n\\n        //find the max differene among all roots;\\n        ll res = 0;\\n        for(int i=0; i<n; i++){\\n            res = max(res, ans[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\n    vector<vector<ll>> g;\\n    vector<ll> prices;\\n    vector<ll> dp, ans;\\n    //dp[u] : store max path sum in the subtree of u;\\npublic:\\n    ll dfs(int u, int p){\\n        ll maxi = 0LL;\\n        for(auto &v : g[u]){\\n            if(v == p)continue;\\n            ll childsum = dfs(v, u);\\n            maxi = max(maxi, childsum);\\n        }\\n        return dp[u] = maxi + prices[u];\\n    }\\n\\n    void dfs2(int u, int p, ll parentSum){\\n        int c1 = -1; //stores the child having max sum;\\n        ll msum1 = 0, msum2 = 0; //store two max sum in childrens\\n\\n        //just storing values of childrens (preprocessing step)\\n        for(auto &v : g[u]){\\n            if(v == p)continue;\\n            if(dp[v] > msum1){\\n                msum2 = msum1;\\n                msum1 = dp[v];\\n                c1 = v;\\n            }else if(dp[v] > msum2){\\n                msum2 = dp[v];\\n            }\\n        }\\n\\n        //calculate the ans for this node as a root;\\n        ans[u] = max(msum1, parentSum) + (ll)prices[u] - (ll)prices[u]; //minSum path is only one node long\\n\\n        //change root\\n        for(auto &v : g[u]){\\n            if(p == v)continue;\\n            //this if-else is for deciding parentSum\\n            if(v == c1){ \\n                ll ps = max(msum2, parentSum) + (ll)prices[u];\\n                dfs2(v, u, ps);\\n            }else{\\n                ll ps = max(msum1, parentSum) + (ll)prices[u];\\n                dfs2(v, u, ps);\\n            }\\n        }\\n            \\n    }\\n\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        g.clear(), prices.clear(), dp.clear(), ans.clear();\\n        g.resize(n), prices.resize(n), dp.resize(n), ans.resize(n);\\n        for(auto ed : edges){\\n            g[ed[0]].push_back(ed[1]);\\n            g[ed[1]].push_back(ed[0]);\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            prices[i] = price[i];\\n        }\\n\\n        dfs(0, -1);\\n        dfs2(0, -1, 0);\\n\\n        //find the max differene among all roots;\\n        ll res = 0;\\n        for(int i=0; i<n; i++){\\n            res = max(res, ans[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798568,
                "title": "c-dfs-solution-o-n",
                "content": "Run-time is $$O(N)$$, space is $$O(N)$$.\\n\\nSome caveats: \\n\\n1. We only need to worry about each node\\'s children, and we can pick the starting node arbitrarily. This is because the path must consists of either path from any current child to some leaf node, or from root. We can leave the root calculation once we backtrack, so we only need to check child node paths\\n2. Since we cannot pick the \"same\" path, we need to keep top 2 `max_min` and `max_no_min` values. This is in case `max_min` and `max_no_min` comes from the same child. In this case we need to compute by paring with second biggest `max_min` and `max_no_min`. \\n\\n\\n# Code\\n```\\n\\n// max_min means maximum (path sum minus leaf value)\\n// max_no_min means maximum (path sum including leaf value)\\ntypedef struct data_s {\\n    data_s(int _max_min, int _max_no_min): max_min(_max_min), max_no_min(_max_no_min) {}\\n    int max_min;\\n    int max_no_min;\\n} data_t;\\n\\nclass Solution {\\n    int global_max = 0;\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        std::vector<std::vector<int>> adj(n);\\n\\n        for (auto e: edges) {\\n            adj[e[0]].emplace_back(e[1]);\\n            adj[e[1]].emplace_back(e[0]);\\n        }\\n\\n        dfs(adj, price, 0, -1);\\n        return global_max;\\n    }\\n\\n    data_t dfs(std::vector<std::vector<int>>& adj, std::vector<int>& price, int node, int prev) {\\n\\n        std::pair<int,int> min1(-1,-1), min2(-1,-1), no_min1(-1,-1), no_min2(-1,-1);\\n        for (auto n: adj[node]) {\\n            if (n == prev) continue;\\n            auto [cur_min, cur_no_min] = dfs(adj, price, n, node);\\n            if (cur_min > min1.first) {\\n                min2 = min1;\\n                min1 = {cur_min, n};\\n            } else if (cur_min > min2.first) {\\n                min2 = {cur_min, n};\\n            }\\n\\n            if (cur_no_min > no_min1.first) {\\n                no_min2 = no_min1;\\n                no_min1 = {cur_no_min, n};\\n            } else if (cur_no_min > no_min2.first) {\\n                no_min2 = {cur_no_min, n};\\n            }\\n        }\\n       \\n        if (min1.first == -1) {\\n            return {0, price[node]};\\n        }\\n\\n        int local_max = 0;\\n\\n        /* only 1 child, use self as other option */\\n        if (min2.first == -1) {\\n            min2 = {0, node};\\n            no_min2 = {price[node], node};\\n        } else {\\n            local_max = price[node];\\n        }\\n        \\n        if (min1.second != no_min1.second) {\\n            local_max += min1.first + no_min1.first;\\n        } else {\\n            if (min1.first + no_min2.first > min2.first + no_min1.first) {\\n                local_max += min1.first + no_min2.first;\\n            } else {\\n                local_max += min2.first + no_min1.first;\\n            }     \\n        }\\n\\n        global_max = std::max(local_max, global_max);\\n        return {min1.first+price[node], no_min1.first+price[node]};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n// max_min means maximum (path sum minus leaf value)\\n// max_no_min means maximum (path sum including leaf value)\\ntypedef struct data_s {\\n    data_s(int _max_min, int _max_no_min): max_min(_max_min), max_no_min(_max_no_min) {}\\n    int max_min;\\n    int max_no_min;\\n} data_t;\\n\\nclass Solution {\\n    int global_max = 0;\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        std::vector<std::vector<int>> adj(n);\\n\\n        for (auto e: edges) {\\n            adj[e[0]].emplace_back(e[1]);\\n            adj[e[1]].emplace_back(e[0]);\\n        }\\n\\n        dfs(adj, price, 0, -1);\\n        return global_max;\\n    }\\n\\n    data_t dfs(std::vector<std::vector<int>>& adj, std::vector<int>& price, int node, int prev) {\\n\\n        std::pair<int,int> min1(-1,-1), min2(-1,-1), no_min1(-1,-1), no_min2(-1,-1);\\n        for (auto n: adj[node]) {\\n            if (n == prev) continue;\\n            auto [cur_min, cur_no_min] = dfs(adj, price, n, node);\\n            if (cur_min > min1.first) {\\n                min2 = min1;\\n                min1 = {cur_min, n};\\n            } else if (cur_min > min2.first) {\\n                min2 = {cur_min, n};\\n            }\\n\\n            if (cur_no_min > no_min1.first) {\\n                no_min2 = no_min1;\\n                no_min1 = {cur_no_min, n};\\n            } else if (cur_no_min > no_min2.first) {\\n                no_min2 = {cur_no_min, n};\\n            }\\n        }\\n       \\n        if (min1.first == -1) {\\n            return {0, price[node]};\\n        }\\n\\n        int local_max = 0;\\n\\n        /* only 1 child, use self as other option */\\n        if (min2.first == -1) {\\n            min2 = {0, node};\\n            no_min2 = {price[node], node};\\n        } else {\\n            local_max = price[node];\\n        }\\n        \\n        if (min1.second != no_min1.second) {\\n            local_max += min1.first + no_min1.first;\\n        } else {\\n            if (min1.first + no_min2.first > min2.first + no_min1.first) {\\n                local_max += min1.first + no_min2.first;\\n            } else {\\n                local_max += min2.first + no_min1.first;\\n            }     \\n        }\\n\\n        global_max = std::max(local_max, global_max);\\n        return {min1.first+price[node], no_min1.first+price[node]};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711664,
                "title": "o-n-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question was difficult so if you cant do it is fine. I solved it after fixing various cases in O(n)\\nIf i rewrite the question it is give me the sum of maxium path\\nfrom the root node to leaf node without considering root node (as root node will be the minimum sum ), so let 0 be the root node \\n\\nSo the ans will be the maximum value of - (sum of path from any node to leaf + sum of from that node to another leaf without considering leaf  ) \\nBoth path should be different \\n![Capture.PNG](https://assets.leetcode.com/users/images/676c80cf-4623-49f6-83f5-943f2f4a5e59_1688368762.934252.png)\\n\\nhere for node 1 we are considering the max of -\\nmax( (sum of child 9 (without leaf ) + sum of child 3(with leaf )+ price[1]) , (sum of child 3 (without leaf ) + sum of child 9(with leaf )+ price[1]) )\\n\\nSo the difficult part in this question is we cant consider the max\\nfrom same path, that is sum of child 9(with leaf) + sum of child(without leaf) \\n\\nBoth path should be different\\n\\nNow cases - \\nCASE 1 - \\n \\n![Capture2.PNG](https://assets.leetcode.com/users/images/a55cee68-9723-47cb-b7df-01174f94a6d9_1688369391.5179734.png)\\nnow in the above image i can se as to get ans i cant only pass the max , and without max, sometime the need some could come big from the with less total sum ,so i need to pass leaf as well as maximum sum \\nfor both the one with maximum total sum without lead node and \\nthe one with total sum without leaf node\\n\\nSo will pass 4 values \\nMaximum sum, Maximum sum leaf , Maximum sum without leaf node, Maximum sum without leaf\\'s leaf node \\n\\nand will keep 4 values just to mark the node from which value is taken\\nso that final answer dont have same path\\n\\n\\n    \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(n)\\n\\n\\n# Code\\n```\\nclass Pair{\\n    public:\\n    long long  a ;\\n    long long  b ;\\n    long long  la ; \\n    long long  lb;\\n    Pair ( long long  a, long long  b , long long  la, long long  lb){\\n        this->a = a;\\n        this->b = b;\\n        this->la = la;\\n        this->lb = lb;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long sol = 0;\\n    Pair maxoutput(vector<vector<int>>&g, vector<int>&price ,int st, int p){\\n         long long  maxia = 0;\\n         long long  maxib = 0;\\n         long long maxilfa = -1;\\n         long long maxilfb = -1;\\n\\n         long long ansai = -1;\\n         long long ansbi = -1;\\n\\n         long long anssai = -1;\\n         long long anssbi = -1;\\n         Pair ans (0,0 , -1, -1  );\\n         for(auto x : g[st]){\\n            if( x == p){\\n                continue;\\n            }\\n            Pair val = maxoutput(g, price, x, st );\\n            \\n            if(ans.a < val.a ){\\n                maxia = ans.a;\\n                maxilfa = ans.la;\\n                ans.a = val.a;\\n                ans.la = val.la;\\n                ansai = x;\\n            }\\n            else if (maxia < val.a){\\n                maxia = val.a;\\n                maxilfa = val.la;\\n                anssai = x; \\n            }\\n\\n            if(ans.lb == -1 || ans.b - price[ans.lb] < val.b - price[val.lb]){\\n                maxib = ans.b;\\n                maxilfb = ans.lb;\\n                ans.b = val.b;\\n                ans.lb = val.lb;\\n                ansbi = x;\\n            }\\n            else if (maxilfb == -1 || maxib - price[maxilfb] < val.b  - price[val.lb]){\\n                maxib = val.b;\\n                maxilfb = val.lb;\\n                anssbi = x;\\n            }\\n\\n         }\\n         if(ansai == -1 && ansbi == -1){\\n             return Pair(price[st] , price[st] , st, st);\\n         }\\n         else if(ansai != ansbi){\\n             sol = max(sol , ans.a + ans.b - price[ans.lb] + price[st]);\\n         }\\n         else {\\n             sol = max(sol , ans.a);\\n             sol = max(sol, ans.b + price[st] - price[ans.lb]);\\n             if(maxilfb != -1)\\n             sol = max(sol , ans.a + maxib - price[maxilfb] + price[st]);\\n             if(maxilfa != -1){\\n             sol = max(sol, ans.b + maxia - price[ans.lb] + price[st]);\\n             }\\n            //  cout <<maxia <<\" \"<<ans.b<<\" h \"<< maxilfa<<\"  \";\\n         }\\n         ans.a += price[st];\\n         ans.b += price[st];\\n        //  cout << st<<\" \"<<sol <<\" \"<<ansai<<\" \"<<ansbi<<\" \"<<ans.a<<\" \"<<ans.b <<\"     \";\\n         return ans;\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>>g(n);\\n        for(int i = 0 ; i<edges.size(); i++){\\n            int  a = edges[i][0];\\n             int b = edges[i][1];\\n              g[a].push_back(b);\\n              g[b].push_back(a);\\n            }\\n            maxoutput(g, price, 0 ,0);\\n        return sol;\\n\\n\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Pair{\\n    public:\\n    long long  a ;\\n    long long  b ;\\n    long long  la ; \\n    long long  lb;\\n    Pair ( long long  a, long long  b , long long  la, long long  lb){\\n        this->a = a;\\n        this->b = b;\\n        this->la = la;\\n        this->lb = lb;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long sol = 0;\\n    Pair maxoutput(vector<vector<int>>&g, vector<int>&price ,int st, int p){\\n         long long  maxia = 0;\\n         long long  maxib = 0;\\n         long long maxilfa = -1;\\n         long long maxilfb = -1;\\n\\n         long long ansai = -1;\\n         long long ansbi = -1;\\n\\n         long long anssai = -1;\\n         long long anssbi = -1;\\n         Pair ans (0,0 , -1, -1  );\\n         for(auto x : g[st]){\\n            if( x == p){\\n                continue;\\n            }\\n            Pair val = maxoutput(g, price, x, st );\\n            \\n            if(ans.a < val.a ){\\n                maxia = ans.a;\\n                maxilfa = ans.la;\\n                ans.a = val.a;\\n                ans.la = val.la;\\n                ansai = x;\\n            }\\n            else if (maxia < val.a){\\n                maxia = val.a;\\n                maxilfa = val.la;\\n                anssai = x; \\n            }\\n\\n            if(ans.lb == -1 || ans.b - price[ans.lb] < val.b - price[val.lb]){\\n                maxib = ans.b;\\n                maxilfb = ans.lb;\\n                ans.b = val.b;\\n                ans.lb = val.lb;\\n                ansbi = x;\\n            }\\n            else if (maxilfb == -1 || maxib - price[maxilfb] < val.b  - price[val.lb]){\\n                maxib = val.b;\\n                maxilfb = val.lb;\\n                anssbi = x;\\n            }\\n\\n         }\\n         if(ansai == -1 && ansbi == -1){\\n             return Pair(price[st] , price[st] , st, st);\\n         }\\n         else if(ansai != ansbi){\\n             sol = max(sol , ans.a + ans.b - price[ans.lb] + price[st]);\\n         }\\n         else {\\n             sol = max(sol , ans.a);\\n             sol = max(sol, ans.b + price[st] - price[ans.lb]);\\n             if(maxilfb != -1)\\n             sol = max(sol , ans.a + maxib - price[maxilfb] + price[st]);\\n             if(maxilfa != -1){\\n             sol = max(sol, ans.b + maxia - price[ans.lb] + price[st]);\\n             }\\n            //  cout <<maxia <<\" \"<<ans.b<<\" h \"<< maxilfa<<\"  \";\\n         }\\n         ans.a += price[st];\\n         ans.b += price[st];\\n        //  cout << st<<\" \"<<sol <<\" \"<<ansai<<\" \"<<ansbi<<\" \"<<ans.a<<\" \"<<ans.b <<\"     \";\\n         return ans;\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>>g(n);\\n        for(int i = 0 ; i<edges.size(); i++){\\n            int  a = edges[i][0];\\n             int b = edges[i][1];\\n              g[a].push_back(b);\\n              g[b].push_back(a);\\n            }\\n            maxoutput(g, price, 0 ,0);\\n        return sol;\\n\\n\\n    }\\n\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3665023,
                "title": "c-dp-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    void inDfs(vector<int> adj[],int n,int node,int prev,vector<int> &price,vector<ll> &in){\\n        in[node] = price[node];\\n        ll mx = 0;\\n        for(auto &ele:adj[node]){\\n            if(ele!=prev){\\n                inDfs(adj,n,ele,node,price,in);\\n                mx = max(mx,in[ele]);\\n            }\\n        }\\n        in[node] += mx;\\n    }\\n    void outDfs(vector<int> adj[],int n,int node,int prev,vector<int> &price,vector<ll> &in,vector<ll> &out){\\n        ll mx1 = 0,mx2 = 0;\\n        // find longest path;\\n        for(auto &ele:adj[node]){\\n            if(ele!=prev){\\n                if(in[ele]>mx1){\\n                    mx2 = mx1;\\n                    mx1 = in[ele];\\n                }\\n                else if(in[ele]>mx2){\\n                    mx2 = in[ele];\\n                }\\n            }\\n        }\\n        for(auto &ele:adj[node]){\\n            if(ele!=prev){\\n                ll longest = mx1;\\n                if(longest==in[ele])\\n                    longest = mx2;\\n                out[ele] = price[ele] + max(out[node],price[node]+longest);\\n                outDfs(adj,n,ele,node,price,in,out);\\n            }\\n        }\\n    }\\n    ll maxOutput(int n, vector<vector<int>>& edges, vector<int>& price){\\n        vector<int> adj[n];\\n        for(auto &ele:edges){\\n            int u = ele[0],v = ele[1];\\n            adj[u].push_back(v),adj[v].push_back(u);\\n        }\\n        // ans = max(in[node],out[node]) for all nodes;\\n        // minimum will be node\\'s value it self , for maximum we can calculate like height;\\n        // for storing maximum sum;\\n        vector<ll> in(n,0),out(n,0);\\n        // in[node] = max(in[node],val[node]+in[child]);\\n        // out[node] = val[node] + max(out[parent],val[parent]+maximum from all the branches of parent excluding the current node);\\n        inDfs(adj,n,0,-1,price,in);\\n        outDfs(adj,n,0,-1,price,in,out);\\n        // minimum sum will be value on that node;\\n        ll ans = 0;\\n        for(int i=0;i<n;i++){\\n            // cout<<i<<\"-->\";\\n            // cout<<in[i]<<\" \"<<out[i]<<endl;\\n            ll mx = max(in[i],out[i]),mn = price[i];\\n            ans = max(ans,mx-mn);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    void inDfs(vector<int> adj[],int n,int node,int prev,vector<int> &price,vector<ll> &in){\\n        in[node] = price[node];\\n        ll mx = 0;\\n        for(auto &ele:adj[node]){\\n            if(ele!=prev){\\n                inDfs(adj,n,ele,node,price,in);\\n                mx = max(mx,in[ele]);\\n            }\\n        }\\n        in[node] += mx;\\n    }\\n    void outDfs(vector<int> adj[],int n,int node,int prev,vector<int> &price,vector<ll> &in,vector<ll> &out){\\n        ll mx1 = 0,mx2 = 0;\\n        // find longest path;\\n        for(auto &ele:adj[node]){\\n            if(ele!=prev){\\n                if(in[ele]>mx1){\\n                    mx2 = mx1;\\n                    mx1 = in[ele];\\n                }\\n                else if(in[ele]>mx2){\\n                    mx2 = in[ele];\\n                }\\n            }\\n        }\\n        for(auto &ele:adj[node]){\\n            if(ele!=prev){\\n                ll longest = mx1;\\n                if(longest==in[ele])\\n                    longest = mx2;\\n                out[ele] = price[ele] + max(out[node],price[node]+longest);\\n                outDfs(adj,n,ele,node,price,in,out);\\n            }\\n        }\\n    }\\n    ll maxOutput(int n, vector<vector<int>>& edges, vector<int>& price){\\n        vector<int> adj[n];\\n        for(auto &ele:edges){\\n            int u = ele[0],v = ele[1];\\n            adj[u].push_back(v),adj[v].push_back(u);\\n        }\\n        // ans = max(in[node],out[node]) for all nodes;\\n        // minimum will be node\\'s value it self , for maximum we can calculate like height;\\n        // for storing maximum sum;\\n        vector<ll> in(n,0),out(n,0);\\n        // in[node] = max(in[node],val[node]+in[child]);\\n        // out[node] = val[node] + max(out[parent],val[parent]+maximum from all the branches of parent excluding the current node);\\n        inDfs(adj,n,0,-1,price,in);\\n        outDfs(adj,n,0,-1,price,in,out);\\n        // minimum sum will be value on that node;\\n        ll ans = 0;\\n        for(int i=0;i<n;i++){\\n            // cout<<i<<\"-->\";\\n            // cout<<in[i]<<\" \"<<out[i]<<endl;\\n            ll mx = max(in[i],out[i]),mn = price[i];\\n            ans = max(ans,mx-mn);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3664905,
                "title": "c-easy-to-understand-o-n-solution-beats-96-9",
                "content": "```\\n#define ll long long\\nclass Solution {\\nprivate:\\n    vector<vector<int>> graph;\\n    vector<pair<ll,ll>> mxSubtree; // {mx1, mx2} branch-wise\\n    ll getMaxSubtree(int node, int par, vector<int> &price) { //dfs to get mx1,mx2 sum from all branches\\n        ll mx1 = 0, mx2 = 0;\\n        for(int &child: graph[node]) {\\n            if(child == par) continue;\\n            ll res = getMaxSubtree(child,node,price);\\n            res += price[child];\\n            if(mx1 <= res) {\\n                mx2 = max(mx2,mx1);\\n                mx1 = res;\\n            } else if(mx2 < res) mx2 = res;\\n        }\\n        mxSubtree[node] = {mx1,mx2};\\n        return mx1;\\n    }\\n    ll getMaxOutput(int node, int par, ll mxPar, vector<int> &price) { // O(N)\\n        ll ret = max(mxSubtree[node].first, mxPar);\\n        mxPar += price[node];\\n        for(int &child: graph[node]) {\\n            if(child == par) continue;\\n            ll mx = ((mxSubtree[child].first + price[child]) == mxSubtree[node].first) ?\\n            (mxSubtree[node].second + price[node]) : (mxSubtree[node].first + price[node]);\\n            if(mxPar > mx) mx = mxPar;\\n            ll res = getMaxOutput(child,node,mx,price);\\n            ret = max(ret, res);\\n        }\\n        return ret;\\n    }\\npublic: \\n    Solution() {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n    ll maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        graph = vector<vector<int>> (n);\\n        for(auto &i: edges) {\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        mxSubtree = vector<pair<ll,ll>>(n);\\n        getMaxSubtree(0,-1,price); // O(N)\\n        return getMaxOutput(0,-1,0,price);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\nprivate:\\n    vector<vector<int>> graph;\\n    vector<pair<ll,ll>> mxSubtree; // {mx1, mx2} branch-wise\\n    ll getMaxSubtree(int node, int par, vector<int> &price) { //dfs to get mx1,mx2 sum from all branches\\n        ll mx1 = 0, mx2 = 0;\\n        for(int &child: graph[node]) {\\n            if(child == par) continue;\\n            ll res = getMaxSubtree(child,node,price);\\n            res += price[child];\\n            if(mx1 <= res) {\\n                mx2 = max(mx2,mx1);\\n                mx1 = res;\\n            } else if(mx2 < res) mx2 = res;\\n        }\\n        mxSubtree[node] = {mx1,mx2};\\n        return mx1;\\n    }\\n    ll getMaxOutput(int node, int par, ll mxPar, vector<int> &price) { // O(N)\\n        ll ret = max(mxSubtree[node].first, mxPar);\\n        mxPar += price[node];\\n        for(int &child: graph[node]) {\\n            if(child == par) continue;\\n            ll mx = ((mxSubtree[child].first + price[child]) == mxSubtree[node].first) ?\\n            (mxSubtree[node].second + price[node]) : (mxSubtree[node].first + price[node]);\\n            if(mxPar > mx) mx = mxPar;\\n            ll res = getMaxOutput(child,node,mx,price);\\n            ret = max(ret, res);\\n        }\\n        return ret;\\n    }\\npublic: \\n    Solution() {\\n        ios::sync_with_stdio(false);\\n        cin.tie(NULL);\\n    }\\n    ll maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        graph = vector<vector<int>> (n);\\n        for(auto &i: edges) {\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        mxSubtree = vector<pair<ll,ll>>(n);\\n        getMaxSubtree(0,-1,price); // O(N)\\n        return getMaxOutput(0,-1,0,price);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3640994,
                "title": "beats-80-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<long long>> e;\\nvector<long long> fin;\\nvector<int> price;\\nvoid help(int node,int parent){\\n    fin[node]=price[node];\\n    for(int i=0;i<e[node].size();i++){\\n        if(e[node][i]!=parent){\\n            help(e[node][i],node);\\n            fin[node]=max(fin[node],fin[e[node][i]]+price[node]);\\n        }\\n    }\\n    return;\\n}\\nvoid help2(int node,int parent,long long t){\\n    fin[node]=max(fin[node],t+price[node]);\\n    long long ma1=price[node],ma2=price[node];\\n    for(int i=0;i<e[node].size();i++){\\n        if(e[node][i]!=parent){\\n            if(fin[e[node][i]]+price[node]>ma1){ma2=ma1;ma1=fin[e[node][i]]+price[node];}\\n            else\\n            ma2=max(ma2,fin[e[node][i]]+price[node]);\\n        }\\n    }\\n    t+=price[node];\\n    for(int i=0;i<e[node].size();i++){\\n        if(e[node][i]!=parent){\\n            if(fin[e[node][i]]+price[node]!=ma1)\\n            help2(e[node][i],node,max(t,ma1));\\n            else\\n            help2(e[node][i],node,max(t,ma2));\\n        }\\n    }\\n}\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& p) {\\n        e=vector<vector<long long>> (n,vector<long long>(0,0));\\n        price=p;\\n        fin=vector<long long>(n,0);\\n        for(int i=0;i<edges.size();i++){\\n            e[edges[i][0]].push_back(edges[i][1]);\\n            e[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        help(0,-1);\\n        help2(0,-1,0);\\n        long long ans=0;\\n        for(int i=0;i<fin.size();i++){\\n            ans=max(ans,abs(price[i]-fin[i]));\\n        }\\nreturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<long long>> e;\\nvector<long long> fin;\\nvector<int> price;\\nvoid help(int node,int parent){\\n    fin[node]=price[node];\\n    for(int i=0;i<e[node].size();i++){\\n        if(e[node][i]!=parent){\\n            help(e[node][i],node);\\n            fin[node]=max(fin[node],fin[e[node][i]]+price[node]);\\n        }\\n    }\\n    return;\\n}\\nvoid help2(int node,int parent,long long t){\\n    fin[node]=max(fin[node],t+price[node]);\\n    long long ma1=price[node],ma2=price[node];\\n    for(int i=0;i<e[node].size();i++){\\n        if(e[node][i]!=parent){\\n            if(fin[e[node][i]]+price[node]>ma1){ma2=ma1;ma1=fin[e[node][i]]+price[node];}\\n            else\\n            ma2=max(ma2,fin[e[node][i]]+price[node]);\\n        }\\n    }\\n    t+=price[node];\\n    for(int i=0;i<e[node].size();i++){\\n        if(e[node][i]!=parent){\\n            if(fin[e[node][i]]+price[node]!=ma1)\\n            help2(e[node][i],node,max(t,ma1));\\n            else\\n            help2(e[node][i],node,max(t,ma2));\\n        }\\n    }\\n}\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& p) {\\n        e=vector<vector<long long>> (n,vector<long long>(0,0));\\n        price=p;\\n        fin=vector<long long>(n,0);\\n        for(int i=0;i<edges.size();i++){\\n            e[edges[i][0]].push_back(edges[i][1]);\\n            e[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        help(0,-1);\\n        help2(0,-1,0);\\n        long long ans=0;\\n        for(int i=0;i<fin.size();i++){\\n            ans=max(ans,abs(price[i]-fin[i]));\\n        }\\nreturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566152,
                "title": "easy-o-n-most-efficient-solution-simple-code-with-explanations",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n## Cost simplified\\nAccording to the problem description:\\n```\\ncost = maximum price sum - minimum price sum\\n```\\nHowever, once you calm down you will notice that the `minimum price sum` is simply the price of the root.\\nTherefore the `cost` we are looking for is simply the maximum price sum of a path starting from the root but excluding the root itself.\\n\\n## It is a Tree\\nThe problem specifies that the graph is a *tree*, which means we do not need to do the standard DFS, but only need to do a much simplier version of it: **post-order tree travesal**.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe traverse the tree and collecting 3 pieces of information:\\n  * The max price sum path starting from the (subtree) root (`type I path`)\\n  * The max price sum path starting from the (subtree) root but *not* ending at a leaf (`type II path`)\\n  * The best answer for this subtree.\\n\\nThese can be calculated pretty easily recursively.\\n  * Best `type I path` is the max of children\\'s `type I path` plus root `price`.\\n  * Best `type II path` is also simply the max of children\\'s `type I path` plus root `price`, except when this root itself is a leaf, in which case this is 0.\\n  * `answer` for all children is already resolved. For new answer that goes through this root node: We pick one child with `type I path` and *another* child with `type II path` and add them together as well as the root price. Care must be taken when handling edge cases:\\n      - This is a leaf node: no new answer avaialbe.\\n      - Only a single child node exists, the new answer is simply the child\\'s `type II path`.\\n      - best children `type I path` and `type II path` belong to the same child: Take the second best into account.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$\\n\\n# Code\\n```\\nstruct TwoMax {\\n  int id_best = -1;\\n  int best = 0;\\n  int id_second = -1;\\n  int second = 0;\\n\\n  void Update(int id, int value) {\\n    if (value <= second) {\\n      return;\\n    }\\n    if (value <= best) {\\n      id_second = id;\\n      second = value;\\n      return;\\n    }\\n    // Now value > best\\n    id_second = id_best;\\n    second = best;\\n    id_best = id;\\n    best = value;\\n  }\\n};\\n\\nstruct TreeWalker {\\n  const vector<vector<int>>& graph;\\n  const vector<int>& prices;\\n\\n  // Returns <type I path, type II path>\\n  // type I path: a path from this node to a leaf.\\n  // type II path: a path from this node to a non-leaf node.\\n  pair<int, int> FindPathDown(int node, int parent, int& answer) {\\n    const vector<int>& adjs = graph[node];\\n    const int price = prices[node];\\n    const int children_count = adjs.size() - (parent == -1 ? 0 : 1);\\n    if (children_count == 0) {\\n      // leaf\\n      return {price, 0};\\n    }\\n    TwoMax path1;\\n    TwoMax path2;\\n    for (int child : adjs) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      auto [p1, p2] = FindPathDown(child, node, answer);\\n      path1.Update(child, p1);\\n      path2.Update(child, p2);\\n    }\\n    int new_answer = price;\\n    if (children_count == 1) {\\n      new_answer += path2.best;\\n    } else if (path1.id_best != path2.id_best) {\\n      new_answer += path1.best + path2.best;\\n    } else {\\n      new_answer += max(path1.best + path2.second, path1.second + path2.best);\\n    }\\n    answer = max(answer, new_answer);\\n    // cout << \"#\" << node << \": \" << path1.best + price << \", \" << path2.best + price << endl;\\n    return {path1.best + price, path2.best + price};\\n  }\\n};\\n\\nvector<vector<int>> BuildGraph(int n, const vector<vector<int>>& edges) {\\n  vector<vector<int>> graph(n);\\n  for (const vector<int>& edge : edges) {\\n    int a = edge[0];\\n    int b = edge[1];\\n    graph[a].push_back(b);\\n    graph[b].push_back(a);\\n  }\\n  return graph;\\n}\\n\\nclass Solution {\\npublic:\\n  long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n    if (n == 1) { return 0; }\\n    vector<vector<int>> graph = BuildGraph(n, edges);\\n    TreeWalker walker{.graph = graph, .prices = price};\\n    int answer = 0;\\n    auto [p1, p2] = walker.FindPathDown(0, -1, answer);\\n    return max(p1 - price[0], answer);\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\ncost = maximum price sum - minimum price sum\\n```\n```\\nstruct TwoMax {\\n  int id_best = -1;\\n  int best = 0;\\n  int id_second = -1;\\n  int second = 0;\\n\\n  void Update(int id, int value) {\\n    if (value <= second) {\\n      return;\\n    }\\n    if (value <= best) {\\n      id_second = id;\\n      second = value;\\n      return;\\n    }\\n    // Now value > best\\n    id_second = id_best;\\n    second = best;\\n    id_best = id;\\n    best = value;\\n  }\\n};\\n\\nstruct TreeWalker {\\n  const vector<vector<int>>& graph;\\n  const vector<int>& prices;\\n\\n  // Returns <type I path, type II path>\\n  // type I path: a path from this node to a leaf.\\n  // type II path: a path from this node to a non-leaf node.\\n  pair<int, int> FindPathDown(int node, int parent, int& answer) {\\n    const vector<int>& adjs = graph[node];\\n    const int price = prices[node];\\n    const int children_count = adjs.size() - (parent == -1 ? 0 : 1);\\n    if (children_count == 0) {\\n      // leaf\\n      return {price, 0};\\n    }\\n    TwoMax path1;\\n    TwoMax path2;\\n    for (int child : adjs) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      auto [p1, p2] = FindPathDown(child, node, answer);\\n      path1.Update(child, p1);\\n      path2.Update(child, p2);\\n    }\\n    int new_answer = price;\\n    if (children_count == 1) {\\n      new_answer += path2.best;\\n    } else if (path1.id_best != path2.id_best) {\\n      new_answer += path1.best + path2.best;\\n    } else {\\n      new_answer += max(path1.best + path2.second, path1.second + path2.best);\\n    }\\n    answer = max(answer, new_answer);\\n    // cout << \"#\" << node << \": \" << path1.best + price << \", \" << path2.best + price << endl;\\n    return {path1.best + price, path2.best + price};\\n  }\\n};\\n\\nvector<vector<int>> BuildGraph(int n, const vector<vector<int>>& edges) {\\n  vector<vector<int>> graph(n);\\n  for (const vector<int>& edge : edges) {\\n    int a = edge[0];\\n    int b = edge[1];\\n    graph[a].push_back(b);\\n    graph[b].push_back(a);\\n  }\\n  return graph;\\n}\\n\\nclass Solution {\\npublic:\\n  long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n    if (n == 1) { return 0; }\\n    vector<vector<int>> graph = BuildGraph(n, edges);\\n    TreeWalker walker{.graph = graph, .prices = price};\\n    int answer = 0;\\n    auto [p1, p2] = walker.FindPathDown(0, -1, answer);\\n    return max(p1 - price[0], answer);\\n  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3452867,
                "title": "reverse-wavefronts-bottom-up-tree-traversal",
                "content": "start from all the leaves and travel inwards according to number of unvisited neighbors == 1, keeping the queue and track of visited nodes just like you would do in BFS(naming it BFS in any way apart from use of queue would be wrong). **This is bottom up tree traversal i.e. no node is visited until all its children are visited.** \\nI have done it in breadth first manner using queue. You can all see it as a wavefront starting from all the leaves. You can also do it depth first manner using stacks + queue(for efficiency of keeping track of unvisited neighbors == 1).\\n```\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        if(n == 1) return 0;\\n        if(n == 2) return max(price[0], price[1]);\\n        vector<vector<int> > adj(n, vector<int>());\\n        for(vector<int> x: edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<pair<long long, long long> > endCost(n, {-1, -1});\\n        queue<int> q;\\n        for(int i = 0; i < n; i++){\\n            if(adj[i].size() == 1) {\\n                q.push(i);\\n                endCost[i] = {price[i], 0};\\n            }\\n            else endCost[i].second = adj[i].size();\\n        }\\n        int x;\\n        int gi, si, gl, sl;\\n        long long ans = 0;\\n        while(!q.empty()){\\n            x = q.front();\\n            q.pop();\\n            if(adj[x].size() == 1){\\n                for(int y: adj[x]){\\n                    endCost[y].second--;\\n                    if(endCost[y].second == 1){\\n                        endCost[y].first = 0;\\n                        q.push(y);\\n                    }\\n                }\\n            }\\n            else{\\n                gi = -1;\\n                si = -1;\\n                gl = -1;\\n                sl = -1;\\n                for(int i = 0; i < adj[x].size(); i++){\\n                    if(endCost[adj[x][i]].first == - 1){\\n                        endCost[adj[x][i]].second--;\\n                        if(endCost[adj[x][i]].second == 1){\\n                            endCost[adj[x][i]].first = 0;\\n                            q.push(adj[x][i]);\\n                        }\\n                    }\\n                    else if(endCost[adj[x][i]].first > 0){\\n                        if(gi == -1 || endCost[adj[x][i]].first > endCost[adj[x][gi]].first){\\n                            si = gi;\\n                            gi = i;\\n                        }\\n                        else if(si == -1 || endCost[adj[x][i]].first > endCost[adj[x][si]].first){\\n                            si = i;\\n                        }\\n                        if(gl == -1 || endCost[adj[x][i]].second > endCost[adj[x][gl]].second){\\n                            sl = gl;\\n                            gl = i;\\n                        }\\n                        else if(sl == -1 || endCost[adj[x][i]].second > endCost[adj[x][sl]].second){\\n                            sl = i;\\n                        }\\n                        if(si != -1){\\n                            if(gi == gl){\\n                                ans = max(ans, endCost[adj[x][gi]].first + endCost[adj[x][sl]].second + price[x]);\\n                                ans = ans = max(ans, endCost[adj[x][si]].first + endCost[adj[x][gl]].second + price[x]);\\n                            }\\n                            else{\\n                                ans = max(ans, endCost[adj[x][gi]].first + endCost[adj[x][gl]].second + price[x]);\\n                            }\\n                        }\\n                    }    \\n                }\\n                endCost[x].first = endCost[adj[x][gi]].first + price[x];\\n                endCost[x].second = endCost[adj[x][gl]].second + price[x];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        if(n == 1) return 0;\\n        if(n == 2) return max(price[0], price[1]);\\n        vector<vector<int> > adj(n, vector<int>());\\n        for(vector<int> x: edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<pair<long long, long long> > endCost(n, {-1, -1});\\n        queue<int> q;\\n        for(int i = 0; i < n; i++){\\n            if(adj[i].size() == 1) {\\n                q.push(i);\\n                endCost[i] = {price[i], 0};\\n            }\\n            else endCost[i].second = adj[i].size();\\n        }\\n        int x;\\n        int gi, si, gl, sl;\\n        long long ans = 0;\\n        while(!q.empty()){\\n            x = q.front();\\n            q.pop();\\n            if(adj[x].size() == 1){\\n                for(int y: adj[x]){\\n                    endCost[y].second--;\\n                    if(endCost[y].second == 1){\\n                        endCost[y].first = 0;\\n                        q.push(y);\\n                    }\\n                }\\n            }\\n            else{\\n                gi = -1;\\n                si = -1;\\n                gl = -1;\\n                sl = -1;\\n                for(int i = 0; i < adj[x].size(); i++){\\n                    if(endCost[adj[x][i]].first == - 1){\\n                        endCost[adj[x][i]].second--;\\n                        if(endCost[adj[x][i]].second == 1){\\n                            endCost[adj[x][i]].first = 0;\\n                            q.push(adj[x][i]);\\n                        }\\n                    }\\n                    else if(endCost[adj[x][i]].first > 0){\\n                        if(gi == -1 || endCost[adj[x][i]].first > endCost[adj[x][gi]].first){\\n                            si = gi;\\n                            gi = i;\\n                        }\\n                        else if(si == -1 || endCost[adj[x][i]].first > endCost[adj[x][si]].first){\\n                            si = i;\\n                        }\\n                        if(gl == -1 || endCost[adj[x][i]].second > endCost[adj[x][gl]].second){\\n                            sl = gl;\\n                            gl = i;\\n                        }\\n                        else if(sl == -1 || endCost[adj[x][i]].second > endCost[adj[x][sl]].second){\\n                            sl = i;\\n                        }\\n                        if(si != -1){\\n                            if(gi == gl){\\n                                ans = max(ans, endCost[adj[x][gi]].first + endCost[adj[x][sl]].second + price[x]);\\n                                ans = ans = max(ans, endCost[adj[x][si]].first + endCost[adj[x][gl]].second + price[x]);\\n                            }\\n                            else{\\n                                ans = max(ans, endCost[adj[x][gi]].first + endCost[adj[x][gl]].second + price[x]);\\n                            }\\n                        }\\n                    }    \\n                }\\n                endCost[x].first = endCost[adj[x][gi]].first + price[x];\\n                endCost[x].second = endCost[adj[x][gl]].second + price[x];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361163,
                "title": "both-o-n-and-o-nlog-n-solutions-c",
                "content": "# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\n- O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adjList ;\\n    long long result ;\\n    void ans(int source , int parent , vector<int>&price , vector<long long>&sum ){\\n        result = max(result , sum[source] - price[source]);\\n        cout<<source<<\" \"<<sum[source]<<endl;\\n        map<long long , long long>another ;\\n        for(auto it : adjList[source]){\\n            another[sum[it]]++ ;\\n        }\\n        for(auto it : adjList[source]){\\n            if(it != parent){\\n                another[sum[it]]-- ;\\n                if(another[sum[it]] == 0)\\n                    another.erase(sum[it]);\\n                long long ne = sum[it];\\n                long long first = sum[source];\\n                if(another.size() == 0){\\n                    sum[source] = price[source];\\n                    if(sum[it] < price[source] + price[it]){\\n                        sum[it] = price[source] + price[it];\\n                    }\\n                    ans(it , source , price , sum);\\n                    sum[source] = first ;\\n                    sum[it] = ne ;\\n                }\\n                else{\\n                    long long k = another.rbegin()->first;\\n                    k += price[source];\\n                    sum[source] = k ;\\n                    if(sum[it] < k + (long long)price[it]){\\n                        sum[it] = k + price[it] ;\\n                    }\\n                    ans(it , source , price , sum);\\n                    sum[source] = first ;\\n                    sum[it] = ne;\\n                }\\n                another[sum[it]]++;\\n            }\\n        }\\n        // sum[source] = curr ;\\n    }\\n    void dfs(int source , int parent , vector<int>&price , vector<long long>&sum){\\n        sum[source] = price[source];\\n        long long curr = 0 ;\\n        for(auto it : adjList[source]){\\n            if(it != parent){\\n                dfs(it , source , price , sum);\\n                curr = max(curr , sum[it]);\\n            }\\n        }\\n        sum[source] += curr ;\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<long long>sum(n);\\n        adjList.resize(n);\\n        for(auto it : edges){\\n            adjList[it[0]].push_back(it[1]);\\n            adjList[it[1]].push_back(it[0]);\\n        }\\n        dfs(0 , -1 , price , sum);\\n        result = 0 ;\\n        ans(0 , -1 , price , sum);\\n        return result ;\\n    }\\n};\\n};\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n- O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adjList ;\\n    vector<vector<long long>>mx ;\\n    vector<long long>price_sum ;\\n    long long result  ;\\n    void dfs1(int source , int parent , vector<int>&price){\\n        price_sum[source] = price[source];\\n        long long curr = 0 ;\\n        for(auto it : adjList[source]){\\n            if(it != parent){\\n                dfs1(it , source , price);\\n                curr = max(curr , price_sum[it]);\\n            }\\n        }\\n        price_sum[source] += curr ;\\n    }\\n\\n    void dfs2(int source , int parent , vector<int>&price){\\n        result = max(result , price_sum[source] - price[source]);\\n        // cout<<source<<\" \"<<price_sum[source]<<endl;\\n        for(auto it : adjList[source]){\\n            if(it != parent){\\n                long long ne = price_sum[it];\\n                long long first = price_sum[source];\\n                if(mx[source][1] == -1){\\n                    price_sum[source] = price[source];\\n                    long long g = price_sum[source];\\n                    long long a = mx[it][0] , b = mx[it][1];\\n                    if(g >= mx[it][0]){\\n                        mx[it][1] = mx[it][0];\\n                        mx[it][0] = g;\\n                    }\\n                    else if(g >= mx[it][1]){\\n                        mx[it][1] = g ;\\n                    }\\n                    price_sum[it] = max(price_sum[it] , price_sum[source] + price[it]);\\n                    dfs2(it , source , price);\\n                    mx[it][0] = a , mx[it][1] = b ;\\n                    price_sum[source] = first ;\\n                    price_sum[it] = ne ;\\n                }\\n                else{\\n                    if(price_sum[it] == mx[source][0]){\\n                        price_sum[source] = price[source] + mx[source][1];\\n                    }\\n                    else{\\n                        price_sum[source] = price[source] + mx[source][0];\\n                    }\\n                    long long g = price_sum[source];\\n                    long long a = mx[it][0] , b = mx[it][1];\\n                    if(g >= mx[it][0]){\\n                        mx[it][1] = mx[it][0];\\n                        mx[it][0] = g;\\n                    }\\n                    else if(g >= mx[it][1]){\\n                        mx[it][1] = g ;\\n                    }\\n                    price_sum[it] = max(price_sum[it] , price_sum[source] + price[it]);\\n                    dfs2(it , source , price);\\n                    mx[it][0] = a , mx[it][1] = b ;\\n                    price_sum[source] = first ;\\n                    price_sum[it] = ne ;\\n\\n                }\\n            }\\n        }\\n    }\\n    vector<int>par ;\\n    void dfs(int source , int parent ){\\n        par[source] = parent ;\\n        for(auto it : adjList[source]){\\n            if(it != parent){\\n                dfs(it  , source);\\n            }\\n        }\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        if(n == 1)return 0 ;\\n        result = 0 ;\\n        adjList.resize(n);\\n        price_sum.resize(n);\\n        for(auto it : edges){\\n            adjList[it[0]].push_back(it[1]);\\n            adjList[it[1]].push_back(it[0]);\\n        }\\n        par.resize(n);\\n        dfs(0 , -1);\\n\\n        dfs1(0  , -1 , price);\\n        for(int i = 0 ; i < n ; i++){\\n            long long first = -1 , second = -1 ;\\n            for(auto it : adjList[i]){\\n                if(it == par[i])\\n                    continue;\\n                if(price_sum[it] > first){\\n                    second = first ;\\n                    first = price_sum[it] ;\\n                }\\n                else if(price_sum[it] > second){\\n                    second = price_sum[it];\\n                }\\n            }\\n           vector<long long>a;\\n           a.push_back(first) , a.push_back(second);\\n           mx.push_back(a);\\n        }\\n        dfs2(0 , -1 , price);\\n\\n        return result ;\\n        // return 0 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adjList ;\\n    long long result ;\\n    void ans(int source , int parent , vector<int>&price , vector<long long>&sum ){\\n        result = max(result , sum[source] - price[source]);\\n        cout<<source<<\" \"<<sum[source]<<endl;\\n        map<long long , long long>another ;\\n        for(auto it : adjList[source]){\\n            another[sum[it]]++ ;\\n        }\\n        for(auto it : adjList[source]){\\n            if(it != parent){\\n                another[sum[it]]-- ;\\n                if(another[sum[it]] == 0)\\n                    another.erase(sum[it]);\\n                long long ne = sum[it];\\n                long long first = sum[source];\\n                if(another.size() == 0){\\n                    sum[source] = price[source];\\n                    if(sum[it] < price[source] + price[it]){\\n                        sum[it] = price[source] + price[it];\\n                    }\\n                    ans(it , source , price , sum);\\n                    sum[source] = first ;\\n                    sum[it] = ne ;\\n                }\\n                else{\\n                    long long k = another.rbegin()->first;\\n                    k += price[source];\\n                    sum[source] = k ;\\n                    if(sum[it] < k + (long long)price[it]){\\n                        sum[it] = k + price[it] ;\\n                    }\\n                    ans(it , source , price , sum);\\n                    sum[source] = first ;\\n                    sum[it] = ne;\\n                }\\n                another[sum[it]]++;\\n            }\\n        }\\n        // sum[source] = curr ;\\n    }\\n    void dfs(int source , int parent , vector<int>&price , vector<long long>&sum){\\n        sum[source] = price[source];\\n        long long curr = 0 ;\\n        for(auto it : adjList[source]){\\n            if(it != parent){\\n                dfs(it , source , price , sum);\\n                curr = max(curr , sum[it]);\\n            }\\n        }\\n        sum[source] += curr ;\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<long long>sum(n);\\n        adjList.resize(n);\\n        for(auto it : edges){\\n            adjList[it[0]].push_back(it[1]);\\n            adjList[it[1]].push_back(it[0]);\\n        }\\n        dfs(0 , -1 , price , sum);\\n        result = 0 ;\\n        ans(0 , -1 , price , sum);\\n        return result ;\\n    }\\n};\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adjList ;\\n    vector<vector<long long>>mx ;\\n    vector<long long>price_sum ;\\n    long long result  ;\\n    void dfs1(int source , int parent , vector<int>&price){\\n        price_sum[source] = price[source];\\n        long long curr = 0 ;\\n        for(auto it : adjList[source]){\\n            if(it != parent){\\n                dfs1(it , source , price);\\n                curr = max(curr , price_sum[it]);\\n            }\\n        }\\n        price_sum[source] += curr ;\\n    }\\n\\n    void dfs2(int source , int parent , vector<int>&price){\\n        result = max(result , price_sum[source] - price[source]);\\n        // cout<<source<<\" \"<<price_sum[source]<<endl;\\n        for(auto it : adjList[source]){\\n            if(it != parent){\\n                long long ne = price_sum[it];\\n                long long first = price_sum[source];\\n                if(mx[source][1] == -1){\\n                    price_sum[source] = price[source];\\n                    long long g = price_sum[source];\\n                    long long a = mx[it][0] , b = mx[it][1];\\n                    if(g >= mx[it][0]){\\n                        mx[it][1] = mx[it][0];\\n                        mx[it][0] = g;\\n                    }\\n                    else if(g >= mx[it][1]){\\n                        mx[it][1] = g ;\\n                    }\\n                    price_sum[it] = max(price_sum[it] , price_sum[source] + price[it]);\\n                    dfs2(it , source , price);\\n                    mx[it][0] = a , mx[it][1] = b ;\\n                    price_sum[source] = first ;\\n                    price_sum[it] = ne ;\\n                }\\n                else{\\n                    if(price_sum[it] == mx[source][0]){\\n                        price_sum[source] = price[source] + mx[source][1];\\n                    }\\n                    else{\\n                        price_sum[source] = price[source] + mx[source][0];\\n                    }\\n                    long long g = price_sum[source];\\n                    long long a = mx[it][0] , b = mx[it][1];\\n                    if(g >= mx[it][0]){\\n                        mx[it][1] = mx[it][0];\\n                        mx[it][0] = g;\\n                    }\\n                    else if(g >= mx[it][1]){\\n                        mx[it][1] = g ;\\n                    }\\n                    price_sum[it] = max(price_sum[it] , price_sum[source] + price[it]);\\n                    dfs2(it , source , price);\\n                    mx[it][0] = a , mx[it][1] = b ;\\n                    price_sum[source] = first ;\\n                    price_sum[it] = ne ;\\n\\n                }\\n            }\\n        }\\n    }\\n    vector<int>par ;\\n    void dfs(int source , int parent ){\\n        par[source] = parent ;\\n        for(auto it : adjList[source]){\\n            if(it != parent){\\n                dfs(it  , source);\\n            }\\n        }\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        if(n == 1)return 0 ;\\n        result = 0 ;\\n        adjList.resize(n);\\n        price_sum.resize(n);\\n        for(auto it : edges){\\n            adjList[it[0]].push_back(it[1]);\\n            adjList[it[1]].push_back(it[0]);\\n        }\\n        par.resize(n);\\n        dfs(0 , -1);\\n\\n        dfs1(0  , -1 , price);\\n        for(int i = 0 ; i < n ; i++){\\n            long long first = -1 , second = -1 ;\\n            for(auto it : adjList[i]){\\n                if(it == par[i])\\n                    continue;\\n                if(price_sum[it] > first){\\n                    second = first ;\\n                    first = price_sum[it] ;\\n                }\\n                else if(price_sum[it] > second){\\n                    second = price_sum[it];\\n                }\\n            }\\n           vector<long long>a;\\n           a.push_back(first) , a.push_back(second);\\n           mx.push_back(a);\\n        }\\n        dfs2(0 , -1 , price);\\n\\n        return result ;\\n        // return 0 ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3357145,
                "title": "graph-traversal-c",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\nEvery node gets visited exactly once during recursive solution.\\n\\n- Space complexity:\\n$$O(n)$$ for graph connectivity and also $$O(n)$$ worst-case stack requirement\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MaxOutput(int n, int[][] edges, int[] price) {\\n        var conn = new List<int>[n];\\n        for(int i = 0; i < n; i++)\\n            conn[i] = new List<int>();\\n        foreach(var v in edges)\\n        {\\n            conn[v[0]].Add(v[1]);\\n            conn[v[1]].Add(v[0]);\\n        }\\n\\n        int best = 0;\\n        bool[] visited = new bool[n];\\n\\n        //We are looking for the max sum of a path without counting one element at one end of the path\\n        //Approach: \\n        //for every subtree of node, find its max sum and its max sum without last element\\n        //From these values, calculate maximum sum of path crossing this node\\n        //iteratively visit every node\\n        (int node, int sum, int sumWithoutLast) traverse(int node)\\n        {            \\n            visited[node] = true;\\n            var subtrees = new List<(int node, int sum, int sumWithoutLast)>();\\n            foreach(int c in conn[node])\\n            {                \\n                if(!visited[c])\\n                    subtrees.Add(traverse(c));\\n            }\\n            //leaf node\\n            if(subtrees.Count == 0)\\n                return (node, price[node], 0);\\n\\n            //only one node, path starts or ends here\\n            if(subtrees.Count == 1)\\n            {\\n                best = Math.Max(best, subtrees[0].sumWithoutLast + price[node]);\\n                best = Math.Max(best, subtrees[0].sum);\\n                return (node, subtrees[0].sum + price[node], subtrees[0].sumWithoutLast + price[node]);\\n            }\\n\\n            //>=2  child nodes, max sum path must be crossing this node\\n            subtrees.Sort((x, y) => y.sum.CompareTo(x.sum));\\n            var bySum1 = subtrees[0];\\n            var bySum2 = subtrees[1];\\n            subtrees.Sort((x, y) => y.sumWithoutLast.CompareTo(x.sumWithoutLast));\\n            var bySumWO1 = subtrees[0];\\n            var bySumWO2 = subtrees[1];\\n            if(bySum1.node != bySumWO1.node)\\n            {\\n                //best sum node and best sum without last node are different, therefore we may use the best node of both\\n                best = Math.Max(best, bySum1.sum + bySumWO1.sumWithoutLast + price[node]);\\n            }\\n            else\\n            {\\n                //best sum node and best sum without last node are equal\\n                //therefore we may use only one of them and must use the second best for the other one\\n                best = Math.Max(best, bySum1.sum + bySumWO2.sumWithoutLast + price[node]);\\n                best = Math.Max(best, bySum2.sum + bySumWO1.sumWithoutLast + price[node]);\\n            }\\n            return (node, bySum1.sum + price[node], bySumWO1.sumWithoutLast + price[node]);\\n        }\\n\\n        traverse(0);\\n        return best;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Tree"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaxOutput(int n, int[][] edges, int[] price) {\\n        var conn = new List<int>[n];\\n        for(int i = 0; i < n; i++)\\n            conn[i] = new List<int>();\\n        foreach(var v in edges)\\n        {\\n            conn[v[0]].Add(v[1]);\\n            conn[v[1]].Add(v[0]);\\n        }\\n\\n        int best = 0;\\n        bool[] visited = new bool[n];\\n\\n        //We are looking for the max sum of a path without counting one element at one end of the path\\n        //Approach: \\n        //for every subtree of node, find its max sum and its max sum without last element\\n        //From these values, calculate maximum sum of path crossing this node\\n        //iteratively visit every node\\n        (int node, int sum, int sumWithoutLast) traverse(int node)\\n        {            \\n            visited[node] = true;\\n            var subtrees = new List<(int node, int sum, int sumWithoutLast)>();\\n            foreach(int c in conn[node])\\n            {                \\n                if(!visited[c])\\n                    subtrees.Add(traverse(c));\\n            }\\n            //leaf node\\n            if(subtrees.Count == 0)\\n                return (node, price[node], 0);\\n\\n            //only one node, path starts or ends here\\n            if(subtrees.Count == 1)\\n            {\\n                best = Math.Max(best, subtrees[0].sumWithoutLast + price[node]);\\n                best = Math.Max(best, subtrees[0].sum);\\n                return (node, subtrees[0].sum + price[node], subtrees[0].sumWithoutLast + price[node]);\\n            }\\n\\n            //>=2  child nodes, max sum path must be crossing this node\\n            subtrees.Sort((x, y) => y.sum.CompareTo(x.sum));\\n            var bySum1 = subtrees[0];\\n            var bySum2 = subtrees[1];\\n            subtrees.Sort((x, y) => y.sumWithoutLast.CompareTo(x.sumWithoutLast));\\n            var bySumWO1 = subtrees[0];\\n            var bySumWO2 = subtrees[1];\\n            if(bySum1.node != bySumWO1.node)\\n            {\\n                //best sum node and best sum without last node are different, therefore we may use the best node of both\\n                best = Math.Max(best, bySum1.sum + bySumWO1.sumWithoutLast + price[node]);\\n            }\\n            else\\n            {\\n                //best sum node and best sum without last node are equal\\n                //therefore we may use only one of them and must use the second best for the other one\\n                best = Math.Max(best, bySum1.sum + bySumWO2.sumWithoutLast + price[node]);\\n                best = Math.Max(best, bySum2.sum + bySumWO1.sumWithoutLast + price[node]);\\n            }\\n            return (node, bySum1.sum + price[node], bySumWO1.sumWithoutLast + price[node]);\\n        }\\n\\n        traverse(0);\\n        return best;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3325379,
                "title": "tree-dp-and-re-rooting-technique-o-n-code-c",
                "content": "# Intuition\\nFixing the root then using re-rooting technique to find the solution for all the other roots.\\n# Time Complexity\\n$$O(n)$$\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n   const static int M=1e5+100;\\n   ll dp[M];\\n    void dfs(int s,int p,vector<vector<int>>&graph,vector<int>&cost){\\n        \\n        ll mx=0;\\n     dp[s]=cost[s];\\n        for(auto i:graph[s]){\\n            if(i!=p){\\n                dfs(i,s,graph,cost);\\n               mx=max(mx,dp[i]);\\n            }\\n        }\\n      dp[s]+=mx;\\n    }\\n    \\n    \\n     ll ans=0;\\n    void reroot(int s,int p,vector<vector<int>>&graph,vector<int>&cost){\\n        ans=max(dp[s],ans);\\n        \\n        vector<ll>suf,pref;\\n        for(auto i:graph[s]){\\n            if(i!=p){\\n                pref.push_back(dp[i]);\\n                suf.push_back(dp[i]);\\n            }\\n        }\\n//Prefix and Suffix Max array for eliminating the current Child and getting max fromt all the other child path except the i\\'th child.\\n\\n        for(int i=1;i<(int)pref.size();i++){\\n            pref[i]=max(pref[i],pref[i-1]);\\n        }\\n        for(int i=(int)suf.size()-2;i>=0;i--){\\n            suf[i]=max(suf[i+1],suf[i]);\\n        }\\n     \\n        ll t1=dp[s];\\n        int it=0;\\n        for(auto i:graph[s]){\\n            if(i!=p){\\n                   ll l=0,r=0;\\n                if(it-1>=0)\\n                l=pref[it-1];\\n                if(it+1<(int)suf.size())\\n                r=suf[it+1];\\n                \\n                ll t2=dp[i];\\n                 dp[s]=max(l,r);\\n                \\n                if(p!=-1)\\n                    dp[s]=max(dp[s],dp[p]);\\n\\n                dp[s]+=cost[s];\\n                 dp[i]-=cost[i];\\n                dp[i]=max(dp[i],dp[s]);\\n             \\n                reroot(i,s,graph,cost);\\n\\n                dp[s]=t1;\\n                dp[i]=t2;\\n                it++;\\n                \\n            }\\n        }\\n        \\n    }\\n    \\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>>graph(n);\\n        for(auto it:edges){\\n            graph[it[0]].push_back(it[1]);\\n           graph[it[1]].push_back(it[0]);\\n        }\\n        dfs(0,-1,graph,price);\\n        dp[0]-=price[0];\\n// Considering root 0 as intital and calulating for all the other roots by re-rooting.\\n       reroot(0,-1,graph,price);\\n        \\n        \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n   const static int M=1e5+100;\\n   ll dp[M];\\n    void dfs(int s,int p,vector<vector<int>>&graph,vector<int>&cost){\\n        \\n        ll mx=0;\\n     dp[s]=cost[s];\\n        for(auto i:graph[s]){\\n            if(i!=p){\\n                dfs(i,s,graph,cost);\\n               mx=max(mx,dp[i]);\\n            }\\n        }\\n      dp[s]+=mx;\\n    }\\n    \\n    \\n     ll ans=0;\\n    void reroot(int s,int p,vector<vector<int>>&graph,vector<int>&cost){\\n        ans=max(dp[s],ans);\\n        \\n        vector<ll>suf,pref;\\n        for(auto i:graph[s]){\\n            if(i!=p){\\n                pref.push_back(dp[i]);\\n                suf.push_back(dp[i]);\\n            }\\n        }\\n//Prefix and Suffix Max array for eliminating the current Child and getting max fromt all the other child path except the i\\'th child.\\n\\n        for(int i=1;i<(int)pref.size();i++){\\n            pref[i]=max(pref[i],pref[i-1]);\\n        }\\n        for(int i=(int)suf.size()-2;i>=0;i--){\\n            suf[i]=max(suf[i+1],suf[i]);\\n        }\\n     \\n        ll t1=dp[s];\\n        int it=0;\\n        for(auto i:graph[s]){\\n            if(i!=p){\\n                   ll l=0,r=0;\\n                if(it-1>=0)\\n                l=pref[it-1];\\n                if(it+1<(int)suf.size())\\n                r=suf[it+1];\\n                \\n                ll t2=dp[i];\\n                 dp[s]=max(l,r);\\n                \\n                if(p!=-1)\\n                    dp[s]=max(dp[s],dp[p]);\\n\\n                dp[s]+=cost[s];\\n                 dp[i]-=cost[i];\\n                dp[i]=max(dp[i],dp[s]);\\n             \\n                reroot(i,s,graph,cost);\\n\\n                dp[s]=t1;\\n                dp[i]=t2;\\n                it++;\\n                \\n            }\\n        }\\n        \\n    }\\n    \\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>>graph(n);\\n        for(auto it:edges){\\n            graph[it[0]].push_back(it[1]);\\n           graph[it[1]].push_back(it[0]);\\n        }\\n        dfs(0,-1,graph,price);\\n        dp[0]-=price[0];\\n// Considering root 0 as intital and calulating for all the other roots by re-rooting.\\n       reroot(0,-1,graph,price);\\n        \\n        \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290461,
                "title": "reroot-so-only-2-dfs-is-needed-instead-of-n-dfs",
                "content": "# Intuition\\nWe can treat every node as root, and run DFS n times. But we can use re-root trick to do two DFS.\\n\\n# Code\\n```\\nstruct GraphNode {\\n    GraphNode(int id, int cost):\\n        id(id),\\n        cost(cost),\\n        neighbors(),\\n        maxDepth(cost),\\n        maxNodeId(-1),\\n        max2Depth(cost)\\n    {}\\n\\n    void updateFromChild(int childNodeId, long long childMaxDepth) {\\n        if (maxDepth < childMaxDepth + cost) {\\n            max2Depth = maxDepth;\\n            maxNodeId = childNodeId;\\n            maxDepth = childMaxDepth + cost;\\n        } else if (max2Depth < childMaxDepth + cost) {\\n            max2Depth = childMaxDepth + cost;\\n        }\\n    }\\n\\n    void updateFromParent(int parentNodeId, long long parentMaxDepth, int parentMaxNodeId, long long parentMax2Depth) {\\n        if (parentMaxNodeId == -1 || parentMaxNodeId != id) {\\n            updateFromChild(parentNodeId, parentMaxDepth);\\n        } else {\\n            updateFromChild(parentNodeId, parentMax2Depth);\\n        }\\n    }\\n\\n    int id;\\n    int cost;\\n    vector<int> neighbors;\\n    long long maxDepth;\\n    int maxNodeId;\\n    long long max2Depth;\\n};\\n\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<GraphNode> graph = SetupGraph(n, edges, price);\\n        dfs(graph, 0, -1);\\n        dfs2(graph, 0, -1);\\n        long long ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            ans = max(ans, graph[i].maxDepth - graph[i].cost);\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    vector<GraphNode> SetupGraph(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<GraphNode> graph;\\n        for (int i = 0; i < n; ++i) {\\n            graph.emplace_back(i, price[i]);\\n        }\\n        for (vector<int>& edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            graph[u].neighbors.emplace_back(v);\\n            graph[v].neighbors.emplace_back(u);\\n        }\\n        return graph;\\n    }\\n\\n    void dfs(vector<GraphNode>& graph, int i, int p) {\\n        for (int neighborId : graph[i].neighbors) {\\n            if (neighborId != p) {\\n                dfs(graph, neighborId, i);\\n                graph[i].updateFromChild(neighborId, graph[neighborId].maxDepth);\\n            }\\n        }\\n    }\\n\\n    void dfs2(vector<GraphNode>& graph, int i, int p) {\\n        for (int neighborId : graph[i].neighbors) {\\n            if (neighborId != p) {\\n                graph[neighborId].updateFromParent(i, graph[i].maxDepth, graph[i].maxNodeId, graph[i].max2Depth);\\n                dfs2(graph, neighborId, i);\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct GraphNode {\\n    GraphNode(int id, int cost):\\n        id(id),\\n        cost(cost),\\n        neighbors(),\\n        maxDepth(cost),\\n        maxNodeId(-1),\\n        max2Depth(cost)\\n    {}\\n\\n    void updateFromChild(int childNodeId, long long childMaxDepth) {\\n        if (maxDepth < childMaxDepth + cost) {\\n            max2Depth = maxDepth;\\n            maxNodeId = childNodeId;\\n            maxDepth = childMaxDepth + cost;\\n        } else if (max2Depth < childMaxDepth + cost) {\\n            max2Depth = childMaxDepth + cost;\\n        }\\n    }\\n\\n    void updateFromParent(int parentNodeId, long long parentMaxDepth, int parentMaxNodeId, long long parentMax2Depth) {\\n        if (parentMaxNodeId == -1 || parentMaxNodeId != id) {\\n            updateFromChild(parentNodeId, parentMaxDepth);\\n        } else {\\n            updateFromChild(parentNodeId, parentMax2Depth);\\n        }\\n    }\\n\\n    int id;\\n    int cost;\\n    vector<int> neighbors;\\n    long long maxDepth;\\n    int maxNodeId;\\n    long long max2Depth;\\n};\\n\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<GraphNode> graph = SetupGraph(n, edges, price);\\n        dfs(graph, 0, -1);\\n        dfs2(graph, 0, -1);\\n        long long ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            ans = max(ans, graph[i].maxDepth - graph[i].cost);\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    vector<GraphNode> SetupGraph(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<GraphNode> graph;\\n        for (int i = 0; i < n; ++i) {\\n            graph.emplace_back(i, price[i]);\\n        }\\n        for (vector<int>& edge : edges) {\\n            int u = edge[0], v = edge[1];\\n            graph[u].neighbors.emplace_back(v);\\n            graph[v].neighbors.emplace_back(u);\\n        }\\n        return graph;\\n    }\\n\\n    void dfs(vector<GraphNode>& graph, int i, int p) {\\n        for (int neighborId : graph[i].neighbors) {\\n            if (neighborId != p) {\\n                dfs(graph, neighborId, i);\\n                graph[i].updateFromChild(neighborId, graph[neighborId].maxDepth);\\n            }\\n        }\\n    }\\n\\n    void dfs2(vector<GraphNode>& graph, int i, int p) {\\n        for (int neighborId : graph[i].neighbors) {\\n            if (neighborId != p) {\\n                graph[neighborId].updateFromParent(i, graph[i].maxDepth, graph[i].maxNodeId, graph[i].max2Depth);\\n                dfs2(graph, neighborId, i);\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267697,
                "title": "100-working-dfs-re-rooting-technique",
                "content": "# Intuition\\nUsing the re-rooting technique\\n\\nTo understand this technique visit the on this you-tube link : \\n\\nhttps://www.youtube.com/watch?v=N7e4CTfimkU\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n** **\\n**Please upvote me if it helpful for you... happy coding**\\n# Code\\n```\\n#include<unordered_map>\\n#include<map>\\n#include<math.h>\\n#include<vector>\\n#include<string>\\n#define endl \\'\\\\n\\'\\n#define ll long long\\n#define pb push_back\\n#define pf push_front\\n#define ff first \\n#define ss second\\n#define sz(x) (int)(x).size()\\n#define pi 3.141592653589793238\\n#define MOD 1000000007\\n#define pinf INT_MAX\\n#define minf INT_MIN\\n#define py cout << \"YES\\\\n\"\\n#define pn cout << \"NO\\\\n\"\\n#define vi vector<ll>\\n#define vb vector<bool>\\nusing namespace std;\\n#define all(x) (x).begin(),(x).end()\\n\\nll depth[2000001];\\nll ans[2000001];\\nll p[2000001];\\n \\nvoid eval_depth(vector<vector<ll>>& adj, ll src, ll par) {\\n    bool leaf = 1;\\n    ll maxi = 0;\\n    for(auto u : adj[src]) {\\n        if(u != par) {\\n            leaf = 0;\\n            eval_depth(adj, u, src);\\n            maxi = max(maxi, depth[u]);\\n        }\\n    }\\n    if(leaf) depth[src] = p[src];\\n    else depth[src] = maxi + p[src];\\n}\\n \\nvoid dfs(vector<vector<ll>>& adj, ll src, ll par, ll partial) {\\n    vi prefix, suffix;\\n    for(auto child : adj[src]) {\\n        if(child != par) {\\n            prefix.pb(depth[child]);\\n            suffix.pb(depth[child]);\\n        }\\n    }\\n    ll n = prefix.size();\\n    for(int i = 1; i < n; i++) {\\n        prefix[i] = max(prefix[i], prefix[i - 1]);\\n    }\\n    for(int i = n - 2; i >= 0; i--) {\\n        suffix[i] = max(suffix[i], suffix[i + 1]);\\n    }\\n \\n    ll c_no = 0;\\n    for(ll child : adj[src]) {\\n        if(child != par) {\\n            ll op1 = c_no == 0? 0 : prefix[c_no - 1];\\n            ll op2 = c_no == suffix.size() - 1? 0 : suffix[c_no + 1];\\n            ll par_ans = p[src] +  max(partial, max(op1, op2));\\n            dfs(adj, child, src, par_ans);\\n            c_no++;\\n        }\\n    }\\n    ans[src] = max((prefix.empty()? 0 : prefix.back()), partial);\\n}\\n\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        for(int i = 0; i < n; i++) {\\n            p[i] = price[i];\\n        }\\n        vector<vector<ll>> adj(n);\\n        for(int i = 0; i < n - 1; i++) {\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            adj[a].pb(b);\\n            adj[b].pb(a);\\n        }\\n        eval_depth(adj, 0, -1);\\n        dfs(adj, 0, -1, 0);\\n        ll res = 0;\\n        for(int i = 0; i < n; i++) {\\n            res = max(res, ans[i]);\\n            cout << ans[i] << \" \";\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<unordered_map>\\n#include<map>\\n#include<math.h>\\n#include<vector>\\n#include<string>\\n#define endl \\'\\\\n\\'\\n#define ll long long\\n#define pb push_back\\n#define pf push_front\\n#define ff first \\n#define ss second\\n#define sz(x) (int)(x).size()\\n#define pi 3.141592653589793238\\n#define MOD 1000000007\\n#define pinf INT_MAX\\n#define minf INT_MIN\\n#define py cout << \"YES\\\\n\"\\n#define pn cout << \"NO\\\\n\"\\n#define vi vector<ll>\\n#define vb vector<bool>\\nusing namespace std;\\n#define all(x) (x).begin(),(x).end()\\n\\nll depth[2000001];\\nll ans[2000001];\\nll p[2000001];\\n \\nvoid eval_depth(vector<vector<ll>>& adj, ll src, ll par) {\\n    bool leaf = 1;\\n    ll maxi = 0;\\n    for(auto u : adj[src]) {\\n        if(u != par) {\\n            leaf = 0;\\n            eval_depth(adj, u, src);\\n            maxi = max(maxi, depth[u]);\\n        }\\n    }\\n    if(leaf) depth[src] = p[src];\\n    else depth[src] = maxi + p[src];\\n}\\n \\nvoid dfs(vector<vector<ll>>& adj, ll src, ll par, ll partial) {\\n    vi prefix, suffix;\\n    for(auto child : adj[src]) {\\n        if(child != par) {\\n            prefix.pb(depth[child]);\\n            suffix.pb(depth[child]);\\n        }\\n    }\\n    ll n = prefix.size();\\n    for(int i = 1; i < n; i++) {\\n        prefix[i] = max(prefix[i], prefix[i - 1]);\\n    }\\n    for(int i = n - 2; i >= 0; i--) {\\n        suffix[i] = max(suffix[i], suffix[i + 1]);\\n    }\\n \\n    ll c_no = 0;\\n    for(ll child : adj[src]) {\\n        if(child != par) {\\n            ll op1 = c_no == 0? 0 : prefix[c_no - 1];\\n            ll op2 = c_no == suffix.size() - 1? 0 : suffix[c_no + 1];\\n            ll par_ans = p[src] +  max(partial, max(op1, op2));\\n            dfs(adj, child, src, par_ans);\\n            c_no++;\\n        }\\n    }\\n    ans[src] = max((prefix.empty()? 0 : prefix.back()), partial);\\n}\\n\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        for(int i = 0; i < n; i++) {\\n            p[i] = price[i];\\n        }\\n        vector<vector<ll>> adj(n);\\n        for(int i = 0; i < n - 1; i++) {\\n            int a = edges[i][0];\\n            int b = edges[i][1];\\n            adj[a].pb(b);\\n            adj[b].pb(a);\\n        }\\n        eval_depth(adj, 0, -1);\\n        dfs(adj, 0, -1, 0);\\n        ll res = 0;\\n        for(int i = 0; i < n; i++) {\\n            res = max(res, ans[i]);\\n            cout << ans[i] << \" \";\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3187254,
                "title": "deatiled-description-c-easy-to-understand-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long result = 0;\\n    // Function to compute the max sum for a given subtree across all the nodes\\n    long long maxSum(int from, int cur, vector<vector<int>> &adj, vector<int> &price, vector<long long> &dp) {\\n        long long res = 0;\\n        for (auto &to : adj[cur]) {\\n            if (from == to) continue;\\n            res = max(res,maxSum(cur,to,adj,price,dp));\\n        }\\n        dp[cur] = price[cur] + res;\\n        return dp[cur];\\n    }\\n    // DFS each node from same start from where maxSum was calucualted\\n    // for a given node, there are n sums, 1 sum from parent chain, rest all  from its chidlrens.\\n    // if current node is removed then max Cost will be max of its parent Sum path and all rest of siblings.\\n    void dfs(int from, int cur, vector<vector<int>> &adj, vector<int> &price, vector<long long> &dp, long long parentSum) {\\n        int maxChild = -1;\\n        long long firstMax = 0; long long secondMax = 0;\\n        for (auto &to : adj[cur]) {\\n            if (to == from) continue;\\n            if (dp[to] > firstMax) {\\n                secondMax = firstMax;\\n                firstMax = dp[to];\\n                maxChild = to;\\n            } else if (dp[to] > secondMax) {\\n                secondMax = dp[to];\\n            }\\n        }\\n        // result captured if current node is cut off it is max of parent Sum or one of neighbors children sum\\n        long long curMax = max(parentSum,firstMax);\\n        result = max(result,curMax);\\n        int curPrice = price[cur];\\n        for (auto &to : adj[cur]) {\\n            if (to == from) continue;\\n            if (to == maxChild) {\\n                // if child is part of the maxResult chain of current node\\n                // take max of 2nd max neighbor which doesn\\'t include the current node\\n                // or parent Sum, Add the current node and pass on the chain to parentSum for \\n                // next chile\\n                dfs(cur,to,adj,price,dp,curPrice+max(parentSum,secondMax));\\n            } else {\\n                // if max path from current parent doesn\\'t include this node\\n                dfs(cur,to,adj,price,dp,curPrice+curMax);\\n            }\\n        }\\n    }\\n    \\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>> adj(n);\\n        for (auto &e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<long long> dp(n,0);\\n        maxSum(-1,0,adj,price,dp);\\n        dfs(-1,0,adj,price,dp,0);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long result = 0;\\n    // Function to compute the max sum for a given subtree across all the nodes\\n    long long maxSum(int from, int cur, vector<vector<int>> &adj, vector<int> &price, vector<long long> &dp) {\\n        long long res = 0;\\n        for (auto &to : adj[cur]) {\\n            if (from == to) continue;\\n            res = max(res,maxSum(cur,to,adj,price,dp));\\n        }\\n        dp[cur] = price[cur] + res;\\n        return dp[cur];\\n    }\\n    // DFS each node from same start from where maxSum was calucualted\\n    // for a given node, there are n sums, 1 sum from parent chain, rest all  from its chidlrens.\\n    // if current node is removed then max Cost will be max of its parent Sum path and all rest of siblings.\\n    void dfs(int from, int cur, vector<vector<int>> &adj, vector<int> &price, vector<long long> &dp, long long parentSum) {\\n        int maxChild = -1;\\n        long long firstMax = 0; long long secondMax = 0;\\n        for (auto &to : adj[cur]) {\\n            if (to == from) continue;\\n            if (dp[to] > firstMax) {\\n                secondMax = firstMax;\\n                firstMax = dp[to];\\n                maxChild = to;\\n            } else if (dp[to] > secondMax) {\\n                secondMax = dp[to];\\n            }\\n        }\\n        // result captured if current node is cut off it is max of parent Sum or one of neighbors children sum\\n        long long curMax = max(parentSum,firstMax);\\n        result = max(result,curMax);\\n        int curPrice = price[cur];\\n        for (auto &to : adj[cur]) {\\n            if (to == from) continue;\\n            if (to == maxChild) {\\n                // if child is part of the maxResult chain of current node\\n                // take max of 2nd max neighbor which doesn\\'t include the current node\\n                // or parent Sum, Add the current node and pass on the chain to parentSum for \\n                // next chile\\n                dfs(cur,to,adj,price,dp,curPrice+max(parentSum,secondMax));\\n            } else {\\n                // if max path from current parent doesn\\'t include this node\\n                dfs(cur,to,adj,price,dp,curPrice+curMax);\\n            }\\n        }\\n    }\\n    \\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>> adj(n);\\n        for (auto &e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<long long> dp(n,0);\\n        maxSum(-1,0,adj,price,dp);\\n        dfs(-1,0,adj,price,dp,0);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157292,
                "title": "c-dfs-two-dfs-traversal",
                "content": "0.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs2(vector<vector<int>>& adj,vector<long long>&sum,vector<int>&vis,int u,vector<int>&price,vector<long long>& dist)\\n    {\\n        vis[u]=1;\\n        long long max1=0;\\n        long long max2=0;\\n        for(auto x:adj[u])\\n        {\\n            if(vis[x]==0)\\n            {\\n                if(sum[x]>=max1)\\n                {\\n                    max2=max1;\\n                    max1=sum[x];\\n                }\\n                else if(sum[x]>max2)\\n                max2=sum[x];\\n            }\\n        }\\n        \\n        long long calc=0;\\n        for(auto x:adj[u])\\n        {   \\n           if(vis[x]==0)\\n           {\\n         \\n            if(max1==sum[x])\\n            {\\n               dist[x]=price[x]+max(max2+price[u],dist[u]);\\n            }\\n            else \\n            {\\n                dist[x]=price[x]+max(max1+price[u],dist[u]);\\n            }\\n            \\n            dfs2(adj,sum,vis,x,price,dist);\\n           } \\n        }\\n    }\\n    long long dfs1(vector<vector<int>>& adj,vector<long long>&sum,vector<int>&vis,int u,vector<int>&price)\\n    {\\n        vis[u]=1;\\n        long long val=0;\\n        long long ans=0;\\n        for(auto x:adj[u])\\n        {  \\n           if(vis[x]==0)\\n           {\\n              val=dfs1(adj,sum,vis,x,price);             \\n              ans=max(ans,val);\\n           }\\n        }\\n      \\n        sum[u]=ans+price[u];\\n        return sum[u];\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        \\n        vector<long long>sum(n,0);\\n        vector<vector<int>>adj(n,vector<int>());\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>vis(n,0);\\n        dfs1(adj,sum,vis,0,price);\\n        vector<int>vis2(n,0);\\n        vector<long long>dist(n,0);\\n        dfs2(adj,sum,vis2,0,price,dist);\\n        long long calc=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           \\n            calc=max(calc,(max(sum[i],dist[i])-price[i]));\\n        }\\n        return calc;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs2(vector<vector<int>>& adj,vector<long long>&sum,vector<int>&vis,int u,vector<int>&price,vector<long long>& dist)\\n    {\\n        vis[u]=1;\\n        long long max1=0;\\n        long long max2=0;\\n        for(auto x:adj[u])\\n        {\\n            if(vis[x]==0)\\n            {\\n                if(sum[x]>=max1)\\n                {\\n                    max2=max1;\\n                    max1=sum[x];\\n                }\\n                else if(sum[x]>max2)\\n                max2=sum[x];\\n            }\\n        }\\n        \\n        long long calc=0;\\n        for(auto x:adj[u])\\n        {   \\n           if(vis[x]==0)\\n           {\\n         \\n            if(max1==sum[x])\\n            {\\n               dist[x]=price[x]+max(max2+price[u],dist[u]);\\n            }\\n            else \\n            {\\n                dist[x]=price[x]+max(max1+price[u],dist[u]);\\n            }\\n            \\n            dfs2(adj,sum,vis,x,price,dist);\\n           } \\n        }\\n    }\\n    long long dfs1(vector<vector<int>>& adj,vector<long long>&sum,vector<int>&vis,int u,vector<int>&price)\\n    {\\n        vis[u]=1;\\n        long long val=0;\\n        long long ans=0;\\n        for(auto x:adj[u])\\n        {  \\n           if(vis[x]==0)\\n           {\\n              val=dfs1(adj,sum,vis,x,price);             \\n              ans=max(ans,val);\\n           }\\n        }\\n      \\n        sum[u]=ans+price[u];\\n        return sum[u];\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        \\n        vector<long long>sum(n,0);\\n        vector<vector<int>>adj(n,vector<int>());\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>vis(n,0);\\n        dfs1(adj,sum,vis,0,price);\\n        vector<int>vis2(n,0);\\n        vector<long long>dist(n,0);\\n        dfs2(adj,sum,vis2,0,price,dist);\\n        long long calc=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           \\n            calc=max(calc,(max(sum[i],dist[i])-price[i]));\\n        }\\n        return calc;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128520,
                "title": "o-n-re-rooting-w-two-pass-bidirectional-dfs-diagram-comments-semantic-variables",
                "content": "# Approach\\nThe brute-force approach would be to calculate the max path using a DFS from each node but this results in a TLE due to the O(n * n) time complexity. Instead we do two DFS passes and store two solutions for each node. This allows us to figure out the max path for each node on the second pass.\\n\\nIn the first pass we do a normal DFS traversal to find the max path from each node to its children but after this traversal our results are incomplete since we never considered the opposite path from child to parent (if we used a different root) which could result in a larger max path. This is why we do a second traversal in the opposite direction. The trick is that when we go in reverse from parent to child we have to be careful that we don\\'t create a cycle.\\n\\nIn the diagram below you can see that in the second pass node #1 points to the 2nd top neighbor of node #0 since the 1st top neighbor points back to node #1 which would create a cycle. This is why we need to store not only the max path for each node but also the 2nd top path as well.\\n\\nYou can also see that we could return our max result (20) directly from the 2nd traversal but I broke it out into another loop to make the code clearer.\\n\\n![2023-01-15-notes.jpg](https://assets.leetcode.com/users/images/945c054a-2d19-4777-9992-d56cbf822d35_1675276627.1758919.jpeg)\\n\\n# Complexity\\n- Time complexity: O(n) - Two linear traversals of the tree.\\n- Space complexity: O(n) - Dynamic programming cache stores constant data for each node.\\n\\n# Code\\n```\\n// A simple data structure to hold the root of a subtree and the sum of its\\n// maximum path.\\npublic record PathSum(int Root, long Sum);\\n\\n// A sort of specialized collection class that only holds the top two PathSums\\n// with the largest sums.\\npublic class TopNeighborPaths\\n{\\t\\n    private PathSum? _first;\\n    private PathSum? _second;\\n    \\n    private long _firstSum => _first?.Sum ?? 0;\\n    private long _secondSum => _second?.Sum ?? 0;\\n\\n    // Adds the provided PathSum only if it is greater than either of the\\n    // existing PathSums.\\n    public void Add(PathSum pathSum)\\n    {\\n        if (pathSum.Sum > _firstSum)\\n        {\\n            _second = _first;\\n            _first = pathSum;\\n        }\\n        else if (pathSum.Sum > _secondSum)\\n        {\\n            _second = pathSum;\\n        }\\n    }\\n    \\n    // Returns the max sum, optionally excluding a specific neighbor.\\n    public long GetMaxSum(int? neighborToExclude = null)\\n    {\\n        if (\\n            _first is not null &&\\n            (neighborToExclude is null || _first.Root != neighborToExclude)\\n        )\\n        {\\n            return _first.Sum;\\n        }\\n        return _secondSum;\\n    }\\n}\\n\\n// Run a depth-first search on the tree, measuring the top paths for each node\\'s\\n// children.\\npublic void MeasureChildrenMaxPaths(\\n    Dictionary<int, HashSet<int>> adjList,\\n    int[] prices,\\n    int node,\\n    int parent,\\n    TopNeighborPaths[] topNeighborPathsCache\\n)\\n{\\n    var topNeighborPaths = new TopNeighborPaths();\\n    foreach (var child in adjList[node])\\n    {\\n        if (child == parent)\\n        {\\n            continue;\\n        }\\n        \\n        // First measure the max paths for the child node.\\n        MeasureChildrenMaxPaths(\\n            adjList,\\n            prices,\\n            child,\\n            node,\\n            topNeighborPathsCache\\n        );\\n        \\n        // Then add the path sum for this node to the child by adding the price\\n        // of the child plus its max path.\\n        topNeighborPaths.Add(\\n            new PathSum(\\n                Root: child,\\n                Sum: prices[child] + topNeighborPathsCache[child].GetMaxSum()\\n            )\\n        );\\n    }\\n    topNeighborPathsCache[node] = topNeighborPaths;\\n}\\n\\n// Run a depth-first search on the tree, measuring the top path for each node\\'s\\n// parent.\\npublic void MeasureParentMaxPaths(\\n    Dictionary<int, HashSet<int>> adjList,\\n    int[] prices,\\n    int node,\\n    int parent,\\n    TopNeighborPaths[] topNeighborPathsCache\\n)\\n{\\n    if (parent != -1)\\n    {\\n        // When we add the path sum for this node to the parent we perform the\\n        // same steps as we do for the children, only we need to exclude the\\n        // first path if it leads back to this node.\\n        topNeighborPathsCache[node].Add(\\n            new PathSum(\\n                Root: parent,\\n                Sum: prices[parent] +\\n                    topNeighborPathsCache[parent].GetMaxSum(\\n                        neighborToExclude: node\\n                    )\\n            )\\n        );\\n    }\\n    foreach (var child in adjList[node])\\n    {\\n        if (child == parent)\\n        {\\n            continue;\\n        }\\n        MeasureParentMaxPaths(\\n            adjList,\\n            prices,\\n            child,\\n            node,\\n            topNeighborPathsCache\\n        );\\n    }\\n}\\n\\npublic long MaxOutput(int n, int[][] edges, int[] prices)\\n{\\n    // Handle the edge case of a single node here so that we don\\'t have to keep\\n    // checking for a node without edges later on.\\n    if (n == 1)\\n    {\\n        return 0;\\n    }\\n    \\n    // Build the adjacency list to efficiently traverse the tree.\\n    var adjList = new Dictionary<int, HashSet<int>>();\\n    foreach (var edge in edges)\\n    {\\n        int\\n            a = edge[0],\\n            b = edge[1];\\n        if (!adjList.ContainsKey(a))\\n        {\\n            adjList.Add(a, new());\\n        }\\n        if (!adjList.ContainsKey(b))\\n        {\\n            adjList.Add(b, new());\\n        }\\n        adjList[a].Add(b);\\n        adjList[b].Add(a);\\n    }\\n    \\n    // Set up our dynamic programming cache to store our work.\\n    var topNeighborPathsCache = new TopNeighborPaths[n];\\n    \\n    // First measure the max paths of the children for each node.\\n    MeasureChildrenMaxPaths(adjList, prices, 0, -1, topNeighborPathsCache);\\n    \\n    // Then measure the max path of the parent for reach node.\\n    MeasureParentMaxPaths(adjList, prices, 0, -1, topNeighborPathsCache);\\n    \\n    // Check the max cost for each node to find our result.\\n    long maxCost = 0;\\n    foreach (var kvp in adjList)\\n    {\\n        // The root with the highest cost will be a leaf node so we can skip any\\n        // non-leaf nodes.\\n        if (kvp.Value.Count > 1)\\n        {\\n            continue;\\n        }\\n        \\n        // Since the cost for any root is the max price sum minus the min price\\n        // sum and the min price sum is always the price of the root the max sum\\n        // of the neighbor paths will be the cost.\\n        maxCost = Math.Max(maxCost, topNeighborPathsCache[kvp.Key].GetMaxSum());\\n    }\\n    return maxCost;\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n// A simple data structure to hold the root of a subtree and the sum of its\\n// maximum path.\\npublic record PathSum(int Root, long Sum);\\n\\n// A sort of specialized collection class that only holds the top two PathSums\\n// with the largest sums.\\npublic class TopNeighborPaths\\n{\\t\\n    private PathSum? _first;\\n    private PathSum? _second;\\n    \\n    private long _firstSum => _first?.Sum ?? 0;\\n    private long _secondSum => _second?.Sum ?? 0;\\n\\n    // Adds the provided PathSum only if it is greater than either of the\\n    // existing PathSums.\\n    public void Add(PathSum pathSum)\\n    {\\n        if (pathSum.Sum > _firstSum)\\n        {\\n            _second = _first;\\n            _first = pathSum;\\n        }\\n        else if (pathSum.Sum > _secondSum)\\n        {\\n            _second = pathSum;\\n        }\\n    }\\n    \\n    // Returns the max sum, optionally excluding a specific neighbor.\\n    public long GetMaxSum(int? neighborToExclude = null)\\n    {\\n        if (\\n            _first is not null &&\\n            (neighborToExclude is null || _first.Root != neighborToExclude)\\n        )\\n        {\\n            return _first.Sum;\\n        }\\n        return _secondSum;\\n    }\\n}\\n\\n// Run a depth-first search on the tree, measuring the top paths for each node\\'s\\n// children.\\npublic void MeasureChildrenMaxPaths(\\n    Dictionary<int, HashSet<int>> adjList,\\n    int[] prices,\\n    int node,\\n    int parent,\\n    TopNeighborPaths[] topNeighborPathsCache\\n)\\n{\\n    var topNeighborPaths = new TopNeighborPaths();\\n    foreach (var child in adjList[node])\\n    {\\n        if (child == parent)\\n        {\\n            continue;\\n        }\\n        \\n        // First measure the max paths for the child node.\\n        MeasureChildrenMaxPaths(\\n            adjList,\\n            prices,\\n            child,\\n            node,\\n            topNeighborPathsCache\\n        );\\n        \\n        // Then add the path sum for this node to the child by adding the price\\n        // of the child plus its max path.\\n        topNeighborPaths.Add(\\n            new PathSum(\\n                Root: child,\\n                Sum: prices[child] + topNeighborPathsCache[child].GetMaxSum()\\n            )\\n        );\\n    }\\n    topNeighborPathsCache[node] = topNeighborPaths;\\n}\\n\\n// Run a depth-first search on the tree, measuring the top path for each node\\'s\\n// parent.\\npublic void MeasureParentMaxPaths(\\n    Dictionary<int, HashSet<int>> adjList,\\n    int[] prices,\\n    int node,\\n    int parent,\\n    TopNeighborPaths[] topNeighborPathsCache\\n)\\n{\\n    if (parent != -1)\\n    {\\n        // When we add the path sum for this node to the parent we perform the\\n        // same steps as we do for the children, only we need to exclude the\\n        // first path if it leads back to this node.\\n        topNeighborPathsCache[node].Add(\\n            new PathSum(\\n                Root: parent,\\n                Sum: prices[parent] +\\n                    topNeighborPathsCache[parent].GetMaxSum(\\n                        neighborToExclude: node\\n                    )\\n            )\\n        );\\n    }\\n    foreach (var child in adjList[node])\\n    {\\n        if (child == parent)\\n        {\\n            continue;\\n        }\\n        MeasureParentMaxPaths(\\n            adjList,\\n            prices,\\n            child,\\n            node,\\n            topNeighborPathsCache\\n        );\\n    }\\n}\\n\\npublic long MaxOutput(int n, int[][] edges, int[] prices)\\n{\\n    // Handle the edge case of a single node here so that we don\\'t have to keep\\n    // checking for a node without edges later on.\\n    if (n == 1)\\n    {\\n        return 0;\\n    }\\n    \\n    // Build the adjacency list to efficiently traverse the tree.\\n    var adjList = new Dictionary<int, HashSet<int>>();\\n    foreach (var edge in edges)\\n    {\\n        int\\n            a = edge[0],\\n            b = edge[1];\\n        if (!adjList.ContainsKey(a))\\n        {\\n            adjList.Add(a, new());\\n        }\\n        if (!adjList.ContainsKey(b))\\n        {\\n            adjList.Add(b, new());\\n        }\\n        adjList[a].Add(b);\\n        adjList[b].Add(a);\\n    }\\n    \\n    // Set up our dynamic programming cache to store our work.\\n    var topNeighborPathsCache = new TopNeighborPaths[n];\\n    \\n    // First measure the max paths of the children for each node.\\n    MeasureChildrenMaxPaths(adjList, prices, 0, -1, topNeighborPathsCache);\\n    \\n    // Then measure the max path of the parent for reach node.\\n    MeasureParentMaxPaths(adjList, prices, 0, -1, topNeighborPathsCache);\\n    \\n    // Check the max cost for each node to find our result.\\n    long maxCost = 0;\\n    foreach (var kvp in adjList)\\n    {\\n        // The root with the highest cost will be a leaf node so we can skip any\\n        // non-leaf nodes.\\n        if (kvp.Value.Count > 1)\\n        {\\n            continue;\\n        }\\n        \\n        // Since the cost for any root is the max price sum minus the min price\\n        // sum and the min price sum is always the price of the root the max sum\\n        // of the neighbor paths will be the cost.\\n        maxCost = Math.Max(maxCost, topNeighborPathsCache[kvp.Key].GetMaxSum());\\n    }\\n    return maxCost;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111069,
                "title": "c-up-to-down-and-down-to-up-dfs",
                "content": "Sorry my English here might not be the best.\\nFirst of all, the min price path is just the node by itself.\\nWe pick any root at random, let\\'s say 0.\\nFirst we get information from children and pass it up to the root (what is the maximum price path going downwards from the root) then we do another pass in which we pass information from the root down to the children (what is the maximum cost path if I pass through the parent). That way every node will know its own cost if it were the root.\\n```\\nclass Solution {\\npublic:\\n  struct Node {\\n    long long price;\\n    Node(long long price) : price(price) {}\\n    vector<int> neighbors;\\n    map<long long, int> costToNeighbor;\\n    \\n    // Get the maximum cost for the path starting from nbIdx\\n    // and passing through this node.\\n    long long getMaxCost(int nbIdx = -1) {\\n      if (costToNeighbor.empty()) {\\n        return price;\\n      } else {\\n        auto it = --costToNeighbor.end();\\n        if (it->second == nbIdx) {\\n          if (it == costToNeighbor.begin()) {\\n            return price;\\n          } else {\\n            --it;\\n            return price + it->first;\\n          }\\n        } else {\\n          return price + it->first;\\n        }\\n      }\\n    }\\n    \\n    long long getCost() {\\n      // The node\\'s own price will always be the minimum cost.\\n      return getMaxCost() - price;\\n    }\\n  };\\n  \\n  vector<Node> graph;\\n  \\n  long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n    for (int i = 0; i < n; ++i) {\\n      graph.push_back(Node(price[i]));\\n    }\\n    for (auto& edge : edges) {\\n      graph[edge[0]].neighbors.push_back(edge[1]);\\n      graph[edge[1]].neighbors.push_back(edge[0]);\\n    }\\n    downToUp(0, -1);\\n    upToDown(0, -1, -1);\\n    long long maxCost = 0;\\n    for (int i = 0; i < n; ++i) {\\n      maxCost = max(maxCost, graph[i].getCost());\\n    }\\n    return maxCost;\\n  }\\n  \\n  void upToDown(int nodeIdx, int parentIdx, int parentMaxCost) {\\n    auto& node = graph[nodeIdx];\\n    if (parentIdx != -1) {\\n      if (parentMaxCost != -1) {\\n        node.costToNeighbor[parentMaxCost] = parentIdx; \\n        // The map just needs to hold the highest and the\\n        // second highest cost.\\n        if (node.costToNeighbor.size() > 2) {\\n          node.costToNeighbor.erase(node.costToNeighbor.begin()->first);\\n        }\\n      }\\n    }\\n    for (int nbIdx : node.neighbors) {\\n      if (nbIdx == parentIdx) continue;\\n      int maxCost = -1;\\n      upToDown(nbIdx, nodeIdx, node.getMaxCost(nbIdx));\\n    }\\n  }\\n  \\n  void downToUp(int nodeIdx, int parentIdx) {\\n    auto& node = graph[nodeIdx];\\n    for (int nbIdx : node.neighbors) {\\n      if (nbIdx == parentIdx) continue;\\n      auto& nb = graph[nbIdx];\\n      downToUp(nbIdx, nodeIdx);\\n      node.costToNeighbor[nb.getMaxCost()] = nbIdx;\\n      // The map just needs to hold the highest and the\\n      // second highest cost.\\n      if (node.costToNeighbor.size() > 2) {\\n        node.costToNeighbor.erase(node.costToNeighbor.begin()->first);\\n      }\\n    }\\n  }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  struct Node {\\n    long long price;\\n    Node(long long price) : price(price) {}\\n    vector<int> neighbors;\\n    map<long long, int> costToNeighbor;\\n    \\n    // Get the maximum cost for the path starting from nbIdx\\n    // and passing through this node.\\n    long long getMaxCost(int nbIdx = -1) {\\n      if (costToNeighbor.empty()) {\\n        return price;\\n      } else {\\n        auto it = --costToNeighbor.end();\\n        if (it->second == nbIdx) {\\n          if (it == costToNeighbor.begin()) {\\n            return price;\\n          } else {\\n            --it;\\n            return price + it->first;\\n          }\\n        } else {\\n          return price + it->first;\\n        }\\n      }\\n    }\\n    \\n    long long getCost() {\\n      // The node\\'s own price will always be the minimum cost.\\n      return getMaxCost() - price;\\n    }\\n  };\\n  \\n  vector<Node> graph;\\n  \\n  long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n    for (int i = 0; i < n; ++i) {\\n      graph.push_back(Node(price[i]));\\n    }\\n    for (auto& edge : edges) {\\n      graph[edge[0]].neighbors.push_back(edge[1]);\\n      graph[edge[1]].neighbors.push_back(edge[0]);\\n    }\\n    downToUp(0, -1);\\n    upToDown(0, -1, -1);\\n    long long maxCost = 0;\\n    for (int i = 0; i < n; ++i) {\\n      maxCost = max(maxCost, graph[i].getCost());\\n    }\\n    return maxCost;\\n  }\\n  \\n  void upToDown(int nodeIdx, int parentIdx, int parentMaxCost) {\\n    auto& node = graph[nodeIdx];\\n    if (parentIdx != -1) {\\n      if (parentMaxCost != -1) {\\n        node.costToNeighbor[parentMaxCost] = parentIdx; \\n        // The map just needs to hold the highest and the\\n        // second highest cost.\\n        if (node.costToNeighbor.size() > 2) {\\n          node.costToNeighbor.erase(node.costToNeighbor.begin()->first);\\n        }\\n      }\\n    }\\n    for (int nbIdx : node.neighbors) {\\n      if (nbIdx == parentIdx) continue;\\n      int maxCost = -1;\\n      upToDown(nbIdx, nodeIdx, node.getMaxCost(nbIdx));\\n    }\\n  }\\n  \\n  void downToUp(int nodeIdx, int parentIdx) {\\n    auto& node = graph[nodeIdx];\\n    for (int nbIdx : node.neighbors) {\\n      if (nbIdx == parentIdx) continue;\\n      auto& nb = graph[nbIdx];\\n      downToUp(nbIdx, nodeIdx);\\n      node.costToNeighbor[nb.getMaxCost()] = nbIdx;\\n      // The map just needs to hold the highest and the\\n      // second highest cost.\\n      if (node.costToNeighbor.size() > 2) {\\n        node.costToNeighbor.erase(node.costToNeighbor.begin()->first);\\n      }\\n    }\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3107083,
                "title": "explained-and-commented-kotlin-solution",
                "content": "# Explanation\\nThis code is a solution to a problem where given a tree with n nodes and each node having a price, the goal is to find the maximum sum of prices that can be obtained by selecting a path in the tree such that no two nodes on the path are siblings.\\n\\nThe code defines a class Solution with three methods: maxOutput, dfs, and dfs2.\\n\\nThe maxOutput method takes in three parameters: an integer n representing the number of nodes in the tree, a 2D array of edges representing the connections between the nodes, and an array of prices representing the price of each node. It initializes an adjacency list tree to store the connections between the nodes, and a subtree_sum array to store the maximum sum obtainable from the subtree rooted at a particular node. It then calls the dfs method to fill the subtree_sum array, and the dfs2 method to find the maximum sum obtainable from the tree.\\n\\nThe dfs method is a recursive method that takes in four parameters: an integer node representing the current node being considered, an integer parent representing the parent of the current node, the tree adjacency list, and the price array. It calculates the maximum sum obtainable from the subtrees of the current node\\'s children and assigns this value to the subtree_sum array at the index of the current node.\\n\\nThe dfs2 method also takes in four parameters: an integer node representing the current node being considered, an integer parent representing the parent of the current node, the tree adjacency list, and the price array. It also takes in a parameter parent_contribution which represents the maximum sum that can be obtained by starting at the parent node and traversing the tree. The method calculates the maximum sum obtainable by starting at the current node and traversing the tree by considering the maximum sum obtainable from the current node\\'s children and the parent_contribution. It also updates the global variable max_dif with the maximum sum obtainable from the tree.\\n\\n# Code\\n```\\nclass Solution {\\n    private lateinit var subtree_sum: LongArray //Stores -> If the tree was rooted at node 0 what is the maximum sum we can get from subtree of i\\n    private var max_dif = 0L\\n    fun maxOutput(n: Int, edges: Array<IntArray>, price: IntArray): Long {\\n        val tree = Array(n) { mutableListOf<Int>() }\\n        for (e in edges) {\\n            tree[e[0]].add(e[1])\\n            tree[e[1]].add(e[0])\\n        }\\n        subtree_sum = LongArray(n)\\n        dfs(0, -1, tree, price)  //Fills the subtree_sum array\\n        dfs2(0, -1, tree, price, 0)\\n        return max_dif\\n    }\\n\\n    private fun dfs(node: Int, parent: Int, tree: Array<MutableList<Int>>, price: IntArray): Long {\\n        var m = 0L //We need the maximum contribution of children.\\n        for (child in tree[node]) {\\n            if (child == parent) continue\\n            m = Math.max(m, dfs(child, node, tree, price))\\n        }\\n        subtree_sum[node] = price[node] + m\\n        return subtree_sum[node]\\n    }\\n    private fun dfs2(node: Int, parent: Int, tree: Array<MutableList<Int>>, price: IntArray, parent_contribution: Long) {\\n        var c1 = -1\\n        var mc1 = 0L\\n        var mc2 = 0L  //2 maximum contribution of children\\n        for (child in tree[node]) {\\n            if (child == parent) continue\\n            if (subtree_sum[child] > mc1) {\\n                mc2 = mc1\\n                c1 = child\\n                mc1 = subtree_sum[child]\\n            } else if (subtree_sum[child] > mc2) {\\n                mc2 = subtree_sum[child]\\n            }\\n        }\\n        val path1 = mc1\\n        val path2 = parent_contribution\\n        max_dif = Math.max(max_dif, Math.max(path1, path2))\\n        for (child in tree[node]) {\\n            if (child == parent) continue\\n            /*\\n            How can a parent add a path to child?\\n            1. Take a path from a siblling of child     (we want the maximum siblling)\\n            2. Take a path from its parent\\n            Thus the contribution of current node to its child c is maximum(maximum siblling ,node\\'s parent_contribution)\\n            */\\n            if (c1 == child) dfs2(child, node, tree, price, price[node] + Math.max(mc2, parent_contribution))\\n            else dfs2(child, node, tree, price, price[node] + Math.max(mc1, parent_contribution))\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    private lateinit var subtree_sum: LongArray //Stores -> If the tree was rooted at node 0 what is the maximum sum we can get from subtree of i\\n    private var max_dif = 0L\\n    fun maxOutput(n: Int, edges: Array<IntArray>, price: IntArray): Long {\\n        val tree = Array(n) { mutableListOf<Int>() }\\n        for (e in edges) {\\n            tree[e[0]].add(e[1])\\n            tree[e[1]].add(e[0])\\n        }\\n        subtree_sum = LongArray(n)\\n        dfs(0, -1, tree, price)  //Fills the subtree_sum array\\n        dfs2(0, -1, tree, price, 0)\\n        return max_dif\\n    }\\n\\n    private fun dfs(node: Int, parent: Int, tree: Array<MutableList<Int>>, price: IntArray): Long {\\n        var m = 0L //We need the maximum contribution of children.\\n        for (child in tree[node]) {\\n            if (child == parent) continue\\n            m = Math.max(m, dfs(child, node, tree, price))\\n        }\\n        subtree_sum[node] = price[node] + m\\n        return subtree_sum[node]\\n    }\\n    private fun dfs2(node: Int, parent: Int, tree: Array<MutableList<Int>>, price: IntArray, parent_contribution: Long) {\\n        var c1 = -1\\n        var mc1 = 0L\\n        var mc2 = 0L  //2 maximum contribution of children\\n        for (child in tree[node]) {\\n            if (child == parent) continue\\n            if (subtree_sum[child] > mc1) {\\n                mc2 = mc1\\n                c1 = child\\n                mc1 = subtree_sum[child]\\n            } else if (subtree_sum[child] > mc2) {\\n                mc2 = subtree_sum[child]\\n            }\\n        }\\n        val path1 = mc1\\n        val path2 = parent_contribution\\n        max_dif = Math.max(max_dif, Math.max(path1, path2))\\n        for (child in tree[node]) {\\n            if (child == parent) continue\\n            /*\\n            How can a parent add a path to child?\\n            1. Take a path from a siblling of child     (we want the maximum siblling)\\n            2. Take a path from its parent\\n            Thus the contribution of current node to its child c is maximum(maximum siblling ,node\\'s parent_contribution)\\n            */\\n            if (c1 == child) dfs2(child, node, tree, price, price[node] + Math.max(mc2, parent_contribution))\\n            else dfs2(child, node, tree, price, price[node] + Math.max(mc1, parent_contribution))\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090628,
                "title": "c-dfs",
                "content": "# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<vector<int>>G;\\n    vector<pair<ll,ll>>mx;\\n    vector<pair<int,int>>mxIdx;\\n    vector<int>price;\\n    ll ans;\\n    ll dfs(int cur,int pre)\\n    {\\n        for(auto &x:G[cur])\\n        {\\n            if(x==pre)continue;\\n            ll child=dfs(x,cur);\\n            if(mx[cur].first<child)\\n            {\\n                mx[cur].second=mx[cur].first;\\n                mx[cur].first=child;\\n                mxIdx[cur].second=mxIdx[cur].first;\\n                mxIdx[cur].first=x;\\n            }else if(mx[cur].second<child)\\n            {\\n                mx[cur].second=child;\\n                mxIdx[cur].second=x;\\n            }\\n        }\\n        return mx[cur].first+price[cur];\\n    }\\n    void dfs2(int cur,int pre,ll up)\\n    {\\n        ans=max({ans,up,mx[cur].first});\\n        for(auto &x:G[cur])\\n        {\\n            if(x==pre)continue;\\n            ll nxUp=up;\\n            if(x==mxIdx[cur].first)nxUp=max(up+price[cur],mx[cur].second+price[cur]);\\n            else nxUp=max(up+price[cur],mx[cur].first+price[cur]);\\n            dfs2(x,cur,nxUp);\\n        }\\n        return;\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) \\n    {\\n        ans=0;\\n        G.resize(n);\\n        mx.resize(n,{0,0});\\n        mxIdx.resize(n,{-1,-1});\\n        this->price=price;\\n        for(auto &x:edges)\\n        {\\n            G[x[0]].push_back(x[1]);\\n            G[x[1]].push_back(x[0]);\\n        }\\n        dfs(0,-1);\\n        ans=mx[0].first;\\n        dfs2(0,-1,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<vector<int>>G;\\n    vector<pair<ll,ll>>mx;\\n    vector<pair<int,int>>mxIdx;\\n    vector<int>price;\\n    ll ans;\\n    ll dfs(int cur,int pre)\\n    {\\n        for(auto &x:G[cur])\\n        {\\n            if(x==pre)continue;\\n            ll child=dfs(x,cur);\\n            if(mx[cur].first<child)\\n            {\\n                mx[cur].second=mx[cur].first;\\n                mx[cur].first=child;\\n                mxIdx[cur].second=mxIdx[cur].first;\\n                mxIdx[cur].first=x;\\n            }else if(mx[cur].second<child)\\n            {\\n                mx[cur].second=child;\\n                mxIdx[cur].second=x;\\n            }\\n        }\\n        return mx[cur].first+price[cur];\\n    }\\n    void dfs2(int cur,int pre,ll up)\\n    {\\n        ans=max({ans,up,mx[cur].first});\\n        for(auto &x:G[cur])\\n        {\\n            if(x==pre)continue;\\n            ll nxUp=up;\\n            if(x==mxIdx[cur].first)nxUp=max(up+price[cur],mx[cur].second+price[cur]);\\n            else nxUp=max(up+price[cur],mx[cur].first+price[cur]);\\n            dfs2(x,cur,nxUp);\\n        }\\n        return;\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) \\n    {\\n        ans=0;\\n        G.resize(n);\\n        mx.resize(n,{0,0});\\n        mxIdx.resize(n,{-1,-1});\\n        this->price=price;\\n        for(auto &x:edges)\\n        {\\n            G[x[0]].push_back(x[1]);\\n            G[x[1]].push_back(x[0]);\\n        }\\n        dfs(0,-1);\\n        ans=mx[0].first;\\n        dfs2(0,-1,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078582,
                "title": "python-o-n-e-dp-dfs-cache",
                "content": "TIME: O(N + E)\\nSPACE:O(N + E)\\n\\nSCROLL DOWN to directly go to CODE, and skip verbage.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        \\n        #assume prices are  > 0. So, max path should be from leaf-node to leaf-node.\\n        #assume graph is valid tree (no cycle, no duplicate edges, unique nodes).\\n        #edges and price are arrays/lists, not data-streams.\\n\\n        #Intuition:\\n        #   Since the graph is a tree, visualize it as a tree with directed edges\\n        #   starting from root node. Here, use node 0 as default starting node.\\n        #   A single rooted tree structure means that every node must have a single\\n        #   parent node, except root node\\n        #   But, parent node can have multiple children nodes.\\n        #   Hence, max cost path sum for every node[i] = \\n        #   max(    max(    children\\'s max path sum),\\n        #           parent\\'s max path sum   if path doesn\\'t go through node[i],\\n        #                                  else get parent\\'s 2nd max path sum)\\n        #       )\\n        #   get the max path cost for every node[i] and return it.\\n\\n\\n        \\n        #steps:\\n        #   1. Build directed tree with node 0 as root.\\n        #   2. Use DP memoization to find max path price sum for every node.\\n        #       Use dfs and cache for memoization, starting from root node 0.\\n        #       The max path sum follows the directed tree edges.\\n        #       \\n        #   3. Use DP memoization to find max path price sum looking\\n        #       towards parent\\'s direction. \\n        #   4. Finally, solve each node\\'s max cost sum and return the max.\\n        #       cost node[i] = max( children\\'s max path - STEP 2,\\n        #                           parent\\'s max path   - STEP 3,\\n        #                           )\\n        #       \\n\\n\\n        ### STEP 1: Build directed tree structure, starting from default root 0.\\n        #######################################################################\\n        START_NODE          =   random.randint(0, n-1)      #0, pick any [0, n-1] as starting root node.\\n        graph               =   [list() for _ in range(n)]  #undirected graph.\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        # directed tree structure.\\n        listChildrenNodes   =   [list() for _ in range(n)]         \\n        parentOf            =   [None]*n\\n\\n        def populate_tree(  currNode    =   START_NODE,  parentNode  =   None):\\n            nonlocal graph, parentOf, listChildrenNodes\\n            if parentNode != None:\\n                parentOf[currNode] = parentNode\\n            for childNode in graph[currNode]:\\n                if childNode != parentNode:\\n                    populate_tree(  childNode, currNode)\\n                    listChildrenNodes[currNode].append( childNode)\\n            return\\n        \\n        ### STEP 2: DFS max path sum starting from default root 0.\\n        #######################################################################\\n        @functools.lru_cache(   maxsize = None)\\n        def get_node_maxpath(  currNode    =   START_NODE):\\n            # Returns the two largest max path sum of currNode, including its price.\\n            if currNode == None:    return 0        #dfs base case.\\n            \\n            currPrice   =   price[currNode]\\n            maxPaths    =   [currPrice]*2\\n            for childNode in listChildrenNodes[currNode]:\\n                _, childMaxPath =   get_node_maxpath(  childNode)       #get children\\'s max path. \\n                maxPaths        =   sorted(maxPaths + [currPrice + childMaxPath])[-2:] \\n\\n            return maxPaths\\n\\n        ### STEP 3: DFS max path sum for every [currNode, parentNode] edge.\\n        #######################################################################\\n        @functools.lru_cache(   maxsize =   None)\\n        def get_parent_maxpath(    childNode, parentNode):\\n            #   Returns max(    parent\\'s children max path,\\n            #                   parent\\'s parent max path\\n            #                   )\\n            ###############################################\\n\\n            if parentNode == None or childNode == None:     return 0    # dfs base case.\\n\\n            parentMaxPaths      =   get_node_maxpath(   parentNode)\\n            _, childMaxPath     =   get_node_maxpath(   childNode)\\n\\n            maxPath = parentMaxPaths[1]\\n            if childMaxPath + price[parentNode] == parentMaxPaths[1]:\\n                maxPath = parentMaxPaths[0]\\n\\n            maxPath =   max(    maxPath,  \\n                                price[parentNode] + get_parent_maxpath(    parentNode, parentOf[parentNode])\\n                            )\\n            return maxPath\\n\\n        #STEP 4: get max path sum for each node.\\n        ########################################\\n        def get_node_cost(   currNode):\\n            #   Returns the max(\\n            #       max(    children\\'s max path sum),\\n            #       (parent\\'s max path sum   if path doesn\\'t go through node[i]\\n            #                               else get parent\\'s 2nd max path sum),\\n            #       )\\n            ###################################################################\\n            _, maxPath  =   get_node_maxpath(  currNode)\\n            return max( maxPath - price[currNode],          #max child path\\n                        get_parent_maxpath(    currNode,   parentOf[currNode]),    #parent maxpath\\n                        )\\n\\n\\n        populate_tree()     #build the directed tree structure, starting at node 0.\\n\\n        # solve for max of each node\\'s cost.\\n        maxCost =   max( get_node_cost(currNode) for currNode in range(n))\\n\\n        #cleaning up the mess.\\n        get_node_maxpath.cache_clear()\\n        get_parent_maxpath.cache_clear()\\n        del graph, parentOf,listChildrenNodes\\n\\n        return maxCost\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        \\n        #assume prices are  > 0. So, max path should be from leaf-node to leaf-node.\\n        #assume graph is valid tree (no cycle, no duplicate edges, unique nodes).\\n        #edges and price are arrays/lists, not data-streams.\\n\\n        #Intuition:\\n        #   Since the graph is a tree, visualize it as a tree with directed edges\\n        #   starting from root node. Here, use node 0 as default starting node.\\n        #   A single rooted tree structure means that every node must have a single\\n        #   parent node, except root node\\n        #   But, parent node can have multiple children nodes.\\n        #   Hence, max cost path sum for every node[i] = \\n        #   max(    max(    children\\'s max path sum),\\n        #           parent\\'s max path sum   if path doesn\\'t go through node[i],\\n        #                                  else get parent\\'s 2nd max path sum)\\n        #       )\\n        #   get the max path cost for every node[i] and return it.\\n\\n\\n        \\n        #steps:\\n        #   1. Build directed tree with node 0 as root.\\n        #   2. Use DP memoization to find max path price sum for every node.\\n        #       Use dfs and cache for memoization, starting from root node 0.\\n        #       The max path sum follows the directed tree edges.\\n        #       \\n        #   3. Use DP memoization to find max path price sum looking\\n        #       towards parent\\'s direction. \\n        #   4. Finally, solve each node\\'s max cost sum and return the max.\\n        #       cost node[i] = max( children\\'s max path - STEP 2,\\n        #                           parent\\'s max path   - STEP 3,\\n        #                           )\\n        #       \\n\\n\\n        ### STEP 1: Build directed tree structure, starting from default root 0.\\n        #######################################################################\\n        START_NODE          =   random.randint(0, n-1)      #0, pick any [0, n-1] as starting root node.\\n        graph               =   [list() for _ in range(n)]  #undirected graph.\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        # directed tree structure.\\n        listChildrenNodes   =   [list() for _ in range(n)]         \\n        parentOf            =   [None]*n\\n\\n        def populate_tree(  currNode    =   START_NODE,  parentNode  =   None):\\n            nonlocal graph, parentOf, listChildrenNodes\\n            if parentNode != None:\\n                parentOf[currNode] = parentNode\\n            for childNode in graph[currNode]:\\n                if childNode != parentNode:\\n                    populate_tree(  childNode, currNode)\\n                    listChildrenNodes[currNode].append( childNode)\\n            return\\n        \\n        ### STEP 2: DFS max path sum starting from default root 0.\\n        #######################################################################\\n        @functools.lru_cache(   maxsize = None)\\n        def get_node_maxpath(  currNode    =   START_NODE):\\n            # Returns the two largest max path sum of currNode, including its price.\\n            if currNode == None:    return 0        #dfs base case.\\n            \\n            currPrice   =   price[currNode]\\n            maxPaths    =   [currPrice]*2\\n            for childNode in listChildrenNodes[currNode]:\\n                _, childMaxPath =   get_node_maxpath(  childNode)       #get children\\'s max path. \\n                maxPaths        =   sorted(maxPaths + [currPrice + childMaxPath])[-2:] \\n\\n            return maxPaths\\n\\n        ### STEP 3: DFS max path sum for every [currNode, parentNode] edge.\\n        #######################################################################\\n        @functools.lru_cache(   maxsize =   None)\\n        def get_parent_maxpath(    childNode, parentNode):\\n            #   Returns max(    parent\\'s children max path,\\n            #                   parent\\'s parent max path\\n            #                   )\\n            ###############################################\\n\\n            if parentNode == None or childNode == None:     return 0    # dfs base case.\\n\\n            parentMaxPaths      =   get_node_maxpath(   parentNode)\\n            _, childMaxPath     =   get_node_maxpath(   childNode)\\n\\n            maxPath = parentMaxPaths[1]\\n            if childMaxPath + price[parentNode] == parentMaxPaths[1]:\\n                maxPath = parentMaxPaths[0]\\n\\n            maxPath =   max(    maxPath,  \\n                                price[parentNode] + get_parent_maxpath(    parentNode, parentOf[parentNode])\\n                            )\\n            return maxPath\\n\\n        #STEP 4: get max path sum for each node.\\n        ########################################\\n        def get_node_cost(   currNode):\\n            #   Returns the max(\\n            #       max(    children\\'s max path sum),\\n            #       (parent\\'s max path sum   if path doesn\\'t go through node[i]\\n            #                               else get parent\\'s 2nd max path sum),\\n            #       )\\n            ###################################################################\\n            _, maxPath  =   get_node_maxpath(  currNode)\\n            return max( maxPath - price[currNode],          #max child path\\n                        get_parent_maxpath(    currNode,   parentOf[currNode]),    #parent maxpath\\n                        )\\n\\n\\n        populate_tree()     #build the directed tree structure, starting at node 0.\\n\\n        # solve for max of each node\\'s cost.\\n        maxCost =   max( get_node_cost(currNode) for currNode in range(n))\\n\\n        #cleaning up the mess.\\n        get_node_maxpath.cache_clear()\\n        get_parent_maxpath.cache_clear()\\n        del graph, parentOf,listChildrenNodes\\n\\n        return maxCost\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078001,
                "title": "dp-on-tree",
                "content": "# Code\\n```\\npublic class Solution {\\n    const int N = (int)1e5 + 1, M = N * 2;\\n    int[] h = new int[N], e = new int[M], ne = new int[M];\\n    int[,] f = new int[N, 5];\\n    int idx = 0, max = 0;\\n    public long MaxOutput(int n, int[][] edges, int[] p) {\\n        Array.Fill(h, -1);\\n        foreach(var edge in edges){\\n            int u = edge[0], v = edge[1];\\n            e[idx] = v; ne[idx] = h[u]; h[u] = idx++;\\n            e[idx] = u; ne[idx] = h[v]; h[v] = idx++;\\n        }\\n\\n        void Dfs1(int u, int fa){\\n            for(int i = h[u]; i != -1; i = ne[i]){\\n                int j = e[i];\\n                if(j == fa) continue;\\n                Dfs1(j, u);\\n                if(f[j, 0] + p[j] > f[u, 0]){\\n                    f[u, 3] = f[u, 2];\\n                    f[u, 2] = j;\\n                    f[u, 1] = f[u, 0];\\n                    f[u, 0] = f[j, 0] + p[j];\\n                }\\n                else if(f[j, 0] + p[j] > f[u, 1]){\\n                    f[u, 1] = f[j, 0] + p[j];\\n                    f[u, 3] = j;\\n                }\\n            }\\n        }\\n\\n        void Dfs2(int u, int fa){\\n            for(int i = h[u]; i != -1; i = ne[i]){\\n                int j = e[i];\\n                if(j == fa) continue;\\n                if(f[u, 2] == j)\\n                    f[j, 4] = Math.Max(f[u, 4], f[u, 1]) + p[u];\\n                else f[j, 4] = Math.Max(f[u, 4], f[u, 0]) + p[u];\\n                Dfs2(j, u);\\n            }\\n        } \\n\\n        Dfs1(0, -1);\\n        Dfs2(0, -1);\\n        for(int i = 0; i < n; i++)\\n            max = Math.Max(Math.Max(f[i, 0], f[i, 4]), max);\\n        return max;\\n    } \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    const int N = (int)1e5 + 1, M = N * 2;\\n    int[] h = new int[N], e = new int[M], ne = new int[M];\\n    int[,] f = new int[N, 5];\\n    int idx = 0, max = 0;\\n    public long MaxOutput(int n, int[][] edges, int[] p) {\\n        Array.Fill(h, -1);\\n        foreach(var edge in edges){\\n            int u = edge[0], v = edge[1];\\n            e[idx] = v; ne[idx] = h[u]; h[u] = idx++;\\n            e[idx] = u; ne[idx] = h[v]; h[v] = idx++;\\n        }\\n\\n        void Dfs1(int u, int fa){\\n            for(int i = h[u]; i != -1; i = ne[i]){\\n                int j = e[i];\\n                if(j == fa) continue;\\n                Dfs1(j, u);\\n                if(f[j, 0] + p[j] > f[u, 0]){\\n                    f[u, 3] = f[u, 2];\\n                    f[u, 2] = j;\\n                    f[u, 1] = f[u, 0];\\n                    f[u, 0] = f[j, 0] + p[j];\\n                }\\n                else if(f[j, 0] + p[j] > f[u, 1]){\\n                    f[u, 1] = f[j, 0] + p[j];\\n                    f[u, 3] = j;\\n                }\\n            }\\n        }\\n\\n        void Dfs2(int u, int fa){\\n            for(int i = h[u]; i != -1; i = ne[i]){\\n                int j = e[i];\\n                if(j == fa) continue;\\n                if(f[u, 2] == j)\\n                    f[j, 4] = Math.Max(f[u, 4], f[u, 1]) + p[u];\\n                else f[j, 4] = Math.Max(f[u, 4], f[u, 0]) + p[u];\\n                Dfs2(j, u);\\n            }\\n        } \\n\\n        Dfs1(0, -1);\\n        Dfs2(0, -1);\\n        for(int i = 0; i < n; i++)\\n            max = Math.Max(Math.Max(f[i, 0], f[i, 4]), max);\\n        return max;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076269,
                "title": "rerooting-easy-to-understand-commented-dfs",
                "content": "```\\n#define ll long long\\nclass Solution {\\nprivate: \\n    vector<ll> subtreeSum; \\n    unordered_map<int, vector<int>> adjList; \\n    ll ans = 0; \\npublic:\\n    \\n    // to calculate the maximum path sum of all the subtrees starting from node \\'i\\' \\n    ll dfs(int node, int par, vector<int> &price) {\\n        ll maxSubtreeSum = 0; \\n        for(auto it: adjList[node]) {\\n            if(it != par) {\\n                maxSubtreeSum = max(maxSubtreeSum, dfs(it, node, price)); \\n            }\\n        }\\n        return subtreeSum[node] = maxSubtreeSum + price[node]; \\n    }\\n    \\n    void dfs2(int node, int par, vector<int> &price, ll fromParent) {\\n        int c1 = -1; //child \\n        ll mxChild1 = 0, mxChild2 = 0; // contribution from to maximum childrens \\n        \\n        for(auto it: adjList[node]) {\\n            if(it != par) {\\n                // We will find two childs which has maximum sum \\n                if(subtreeSum[it] > mxChild1) {\\n                    c1 = it; \\n                    mxChild2 = mxChild1; \\n                    mxChild1 = subtreeSum[it]; \\n                   \\n                } else mxChild2 = max(mxChild2, subtreeSum[it]); \\n            }\\n        }\\n        \\n        // maxPath sum child is mxChild1\\n        ll path1 = mxChild1, path2 = fromParent; \\n        ans = max(ans, max(path1, path2)); \\n        \\n        for(auto it: adjList[node]) {\\n            if(it != par) {\\n                // How can a Parent add a path to child ?? \\n                // 1. take a path from maximum sibling \\n                // 2. take a path from its parent \\n                // thus contribution of current node to it\\'s children c is maximum when max_sibling, node\\'s parent contribution \\n                if(it == c1) dfs2(it, node, price, price[node] + max(mxChild2, fromParent)); \\n                else dfs2(it, node, price, price[node] + max(mxChild1, fromParent)); \\n            }\\n        }\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        \\n        subtreeSum = vector<ll>(n, 0); \\n        for(auto it: edges) {\\n            int a = it[0], b = it[1]; \\n            adjList[a].push_back(b); \\n            adjList[b].push_back(a); \\n        }\\n        \\n        // we call the dfs to fill the subtreeSum where subtreeSum[i] consist of maxSum of its childrens path + price[i] \\n        dfs(0, -1, price); \\n        \\n        \\n        dfs2(0, -1, price, 0 ); //[node, parent, price, parent_contribution] \\n        \\n        return ans; \\n    }\\n};\\n```\\n\\nUpvote if you like the solution :>",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\nprivate: \\n    vector<ll> subtreeSum; \\n    unordered_map<int, vector<int>> adjList; \\n    ll ans = 0; \\npublic:\\n    \\n    // to calculate the maximum path sum of all the subtrees starting from node \\'i\\' \\n    ll dfs(int node, int par, vector<int> &price) {\\n        ll maxSubtreeSum = 0; \\n        for(auto it: adjList[node]) {\\n            if(it != par) {\\n                maxSubtreeSum = max(maxSubtreeSum, dfs(it, node, price)); \\n            }\\n        }\\n        return subtreeSum[node] = maxSubtreeSum + price[node]; \\n    }\\n    \\n    void dfs2(int node, int par, vector<int> &price, ll fromParent) {\\n        int c1 = -1; //child \\n        ll mxChild1 = 0, mxChild2 = 0; // contribution from to maximum childrens \\n        \\n        for(auto it: adjList[node]) {\\n            if(it != par) {\\n                // We will find two childs which has maximum sum \\n                if(subtreeSum[it] > mxChild1) {\\n                    c1 = it; \\n                    mxChild2 = mxChild1; \\n                    mxChild1 = subtreeSum[it]; \\n                   \\n                } else mxChild2 = max(mxChild2, subtreeSum[it]); \\n            }\\n        }\\n        \\n        // maxPath sum child is mxChild1\\n        ll path1 = mxChild1, path2 = fromParent; \\n        ans = max(ans, max(path1, path2)); \\n        \\n        for(auto it: adjList[node]) {\\n            if(it != par) {\\n                // How can a Parent add a path to child ?? \\n                // 1. take a path from maximum sibling \\n                // 2. take a path from its parent \\n                // thus contribution of current node to it\\'s children c is maximum when max_sibling, node\\'s parent contribution \\n                if(it == c1) dfs2(it, node, price, price[node] + max(mxChild2, fromParent)); \\n                else dfs2(it, node, price, price[node] + max(mxChild1, fromParent)); \\n            }\\n        }\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        \\n        subtreeSum = vector<ll>(n, 0); \\n        for(auto it: edges) {\\n            int a = it[0], b = it[1]; \\n            adjList[a].push_back(b); \\n            adjList[b].push_back(a); \\n        }\\n        \\n        // we call the dfs to fill the subtreeSum where subtreeSum[i] consist of maxSum of its childrens path + price[i] \\n        dfs(0, -1, price); \\n        \\n        \\n        dfs2(0, -1, price, 0 ); //[node, parent, price, parent_contribution] \\n        \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073709,
                "title": "c-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long inDFS(vector<int> adj[], int i, int par, vector<int> &price, vector<long long> &maxIn) {\\n        long long temp = 0;\\n        for(int &x : adj[i]) {\\n            if(x == par)    continue;\\n            temp = max(temp, inDFS(adj, x, i, price, maxIn));\\n        }\\n        maxIn[i] = temp + price[i];\\n        return maxIn[i];\\n    }\\n\\n    void outDFS(vector<int> adj[], int i, int par, vector<int> &price, vector<long long> &maxOut, vector<long long> &maxIn) {\\n        multiset<long long> st;\\n        for(int &x : adj[i]) {\\n            if(x == par)    continue;\\n            st.insert({maxIn[x]});\\n        }\\n\\n        for(int &x : adj[i]) {\\n            if(x == par)    continue;\\n            auto value = st.find(maxIn[x]);\\n            int val = *value;\\n            st.erase(value);\\n\\n            long long temp = (st.empty())?0:(*(--st.end()));\\n            maxOut[x] = max(temp, maxOut[i]) + price[i];\\n            st.insert(val);\\n            outDFS(adj, x, i, price, maxOut, maxIn);\\n        }\\n    }\\n\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<int> adj[n];\\n        for(auto &x : edges) {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<long long> maxIn(n, 0), maxOut(n, 0);\\n        inDFS(adj, 0, -1, price, maxIn);\\n        outDFS(adj, 0, -1, price, maxOut, maxIn);\\n        \\n        long long ans = 0;\\n        for(int i=0;i<n;i++) {\\n            long long temp = max(maxIn[i], maxOut[i]+price[i]) - price[i];\\n            ans = max(temp, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long inDFS(vector<int> adj[], int i, int par, vector<int> &price, vector<long long> &maxIn) {\\n        long long temp = 0;\\n        for(int &x : adj[i]) {\\n            if(x == par)    continue;\\n            temp = max(temp, inDFS(adj, x, i, price, maxIn));\\n        }\\n        maxIn[i] = temp + price[i];\\n        return maxIn[i];\\n    }\\n\\n    void outDFS(vector<int> adj[], int i, int par, vector<int> &price, vector<long long> &maxOut, vector<long long> &maxIn) {\\n        multiset<long long> st;\\n        for(int &x : adj[i]) {\\n            if(x == par)    continue;\\n            st.insert({maxIn[x]});\\n        }\\n\\n        for(int &x : adj[i]) {\\n            if(x == par)    continue;\\n            auto value = st.find(maxIn[x]);\\n            int val = *value;\\n            st.erase(value);\\n\\n            long long temp = (st.empty())?0:(*(--st.end()));\\n            maxOut[x] = max(temp, maxOut[i]) + price[i];\\n            st.insert(val);\\n            outDFS(adj, x, i, price, maxOut, maxIn);\\n        }\\n    }\\n\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<int> adj[n];\\n        for(auto &x : edges) {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        vector<long long> maxIn(n, 0), maxOut(n, 0);\\n        inDFS(adj, 0, -1, price, maxIn);\\n        outDFS(adj, 0, -1, price, maxOut, maxIn);\\n        \\n        long long ans = 0;\\n        for(int i=0;i<n;i++) {\\n            long long temp = max(maxIn[i], maxOut[i]+price[i]) - price[i];\\n            ans = max(temp, ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072472,
                "title": "c-rerooting-dfs-clean-code-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> dp;\\n    vector<vector<int>> graph;\\n\\n    long long ans = 0;\\n\\n    long long maxPathHelp(int node, int parent, vector<int>& price){\\n        dp[node][0] = price[node];\\n\\n        long long subtreeSum;\\n        for(auto& child : graph[node]){\\n            if(child == parent) continue;\\n\\n            subtreeSum = price[node] + maxPathHelp(child, node, price);\\n\\n            if(subtreeSum > dp[node][0]){\\n                dp[node][1] = dp[node][0];\\n                dp[node][0] = subtreeSum;\\n            }else if(subtreeSum > dp[node][1]){\\n                dp[node][1] = subtreeSum;\\n            }\\n        }\\n\\n        return dp[node][0];\\n    }\\n\\n    void rerooting(int node, int parent, vector<int>& price){\\n        for(auto& child : graph[node]){\\n            if(child == parent) continue;\\n\\n            if(dp[node][0] == (dp[child][0] + price[node])){\\n                if(dp[child][0] > (dp[node][1] + price[child])){\\n                    dp[child][0] = dp[child][0];\\n                    dp[child][1] = max(dp[child][1], dp[node][1] + price[child]);\\n                }else{\\n                    long long oldMaxChildPath = dp[child][0];\\n                    dp[child][0] = dp[node][1] + price[child];\\n                    dp[child][1] = oldMaxChildPath;\\n                }\\n            }else{\\n                if(dp[child][0] > (dp[node][0] + price[child])){\\n                    dp[child][0] = dp[child][0];\\n                    dp[child][1] = max(dp[child][1], dp[node][0] + price[child]);\\n                }else{\\n                    long long oldMaxChildPath = dp[child][0];\\n                    dp[child][0] = dp[node][0] + price[child];\\n                    dp[child][1] = max(oldMaxChildPath, dp[node][1] + price[child]);\\n                }\\n            }\\n\\n            ans = max(ans, (long long)(dp[child][0] - price[child]));\\n            rerooting(child, node, price);\\n        }\\n    }\\n\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price){\\n        dp.resize(n, vector<long long>(2, 0));\\n        graph.resize(n);\\n\\n        for(auto& edge : edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        maxPathHelp(0, -1, price);\\n\\n        // for(int node = 0; node < n; node++){\\n        //     cout << node << \" : \" << dp[node][0] << \" - \" << dp[node][1] << endl;\\n        // }\\n\\n        ans = dp[0][0] - price[0];\\n        rerooting(0, -1, price);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<long long>> dp;\\n    vector<vector<int>> graph;\\n\\n    long long ans = 0;\\n\\n    long long maxPathHelp(int node, int parent, vector<int>& price){\\n        dp[node][0] = price[node];\\n\\n        long long subtreeSum;\\n        for(auto& child : graph[node]){\\n            if(child == parent) continue;\\n\\n            subtreeSum = price[node] + maxPathHelp(child, node, price);\\n\\n            if(subtreeSum > dp[node][0]){\\n                dp[node][1] = dp[node][0];\\n                dp[node][0] = subtreeSum;\\n            }else if(subtreeSum > dp[node][1]){\\n                dp[node][1] = subtreeSum;\\n            }\\n        }\\n\\n        return dp[node][0];\\n    }\\n\\n    void rerooting(int node, int parent, vector<int>& price){\\n        for(auto& child : graph[node]){\\n            if(child == parent) continue;\\n\\n            if(dp[node][0] == (dp[child][0] + price[node])){\\n                if(dp[child][0] > (dp[node][1] + price[child])){\\n                    dp[child][0] = dp[child][0];\\n                    dp[child][1] = max(dp[child][1], dp[node][1] + price[child]);\\n                }else{\\n                    long long oldMaxChildPath = dp[child][0];\\n                    dp[child][0] = dp[node][1] + price[child];\\n                    dp[child][1] = oldMaxChildPath;\\n                }\\n            }else{\\n                if(dp[child][0] > (dp[node][0] + price[child])){\\n                    dp[child][0] = dp[child][0];\\n                    dp[child][1] = max(dp[child][1], dp[node][0] + price[child]);\\n                }else{\\n                    long long oldMaxChildPath = dp[child][0];\\n                    dp[child][0] = dp[node][0] + price[child];\\n                    dp[child][1] = max(oldMaxChildPath, dp[node][1] + price[child]);\\n                }\\n            }\\n\\n            ans = max(ans, (long long)(dp[child][0] - price[child]));\\n            rerooting(child, node, price);\\n        }\\n    }\\n\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price){\\n        dp.resize(n, vector<long long>(2, 0));\\n        graph.resize(n);\\n\\n        for(auto& edge : edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        maxPathHelp(0, -1, price);\\n\\n        // for(int node = 0; node < n; node++){\\n        //     cout << node << \" : \" << dp[node][0] << \" - \" << dp[node][1] << endl;\\n        // }\\n\\n        ans = dp[0][0] - price[0];\\n        rerooting(0, -1, price);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3072405,
                "title": "o-n-easy-to-understand-solution-c-standard-approach-running-dfs-twice",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate leaf node as root node, because the maximum cost path would be from a leaf node to another leaf node in a graph with non-negative costs. And the minimum path would contain leaf node(root) only.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRunning DFS twice. First time to find the best cost path possible from the children of each node.\\nSecond time to find the best answer if the path from parent node is also included, because in the first time we won\\'t have the best cost path containing the parent node.\\n\\n# Complexity\\n- Time complexity: O(n), n being number of nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) + Recursion Stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<long long> best, new_best;\\n    vector<vector<int>> adj;\\n    \\n    // finding the max answer possible from the children of each node.\\n    long long dfs1(int curr, int par, vector<int> &price) {\\n        for(int child: adj[curr]) {\\n            if(child != par) {\\n                best[curr] = max(best[curr], dfs1(child, curr, price));\\n            }\\n        }\\n        best[curr] += price[curr];\\n        return best[curr];\\n    }\\n    \\n    // reiterating on all nodes keeping the best_answer from the parent\\n    void dfs2(int curr, int par, long long par_best, vector<int> &price) {\\n        new_best[curr] = max(best[curr], par_best + price[curr]);\\n        \\n        /*\\n            A little twist here, let\\'s say curr node has more than 1 child then we need to find the best answer from all the children and while going to each child we will send the best answer from the children and from the parent. But whatif, I\\'m going to child c and the child which gave the best answer is also child c, this would be a disaster. Right?\\n            So, I\\'ve splitted the solution of this problem in two parts.\\n            Part 1: find a child c, that is giving the best answer and go to all the children of curr node except child c.\\n            Part 2: find the best answer from the children of current node except c, and go to c.\\n        \\n        */\\n        \\n        // Part 1: \\n        int best_child = -1;\\n        long long best_child_ans = 0;\\n        for(int child: adj[curr]) {\\n            if(child != par && best_child_ans < best[child]) {\\n                best_child_ans = best[child];\\n                best_child = child;\\n            }\\n        }\\n        \\n        // going to all the children except the child giving best_answer\\n        for(int child: adj[curr]) {\\n            if(child != par && child != best_child) {\\n                dfs2(child, curr, max(par_best, best_child_ans) + price[curr], price);\\n            }\\n        }\\n        \\n        // Part 2: Goto the child that give the best answer in part 1.\\n        if(best_child != -1) { // current node has more than one child\\n            long long best_ans = 0;\\n            for(int child: adj[curr]) {\\n                if(child != par && child != best_child) {\\n                    best_ans = max(best_ans, best[child]);\\n                }\\n            }\\n            dfs2(best_child, curr, max(par_best, best_ans) + price[curr], price);\\n        }\\n    }\\n    \\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        // Initializing the arrays and creating a graph\\n        best = vector<long long> (n, 0);\\n        new_best = vector<long long> (n, 0);\\n        adj = vector<vector<int>> (n);\\n        for(vector<int> edge: edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        dfs1(0, -1, price);\\n        dfs2(0, -1, 0, price);\\n        \\n        // The Final Part: Iterating to all the leaf nodes of the graph.\\n        // Why Only Leaf Nodes? Because, the longest path in a graph(containing all positive ) would be from a leaf node to another leaf node. Think!!. Simple, Right?\\n        // and minimum path from this leaf node would contain this node only.\\n        long long mx = 0;\\n        for(int i=0; i<n; i++) {\\n            if(adj[i].size() == 1) {\\n                mx = max(mx, new_best[i] - price[i]);\\n            }\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    vector<long long> best, new_best;\\n    vector<vector<int>> adj;\\n    \\n    // finding the max answer possible from the children of each node.\\n    long long dfs1(int curr, int par, vector<int> &price) {\\n        for(int child: adj[curr]) {\\n            if(child != par) {\\n                best[curr] = max(best[curr], dfs1(child, curr, price));\\n            }\\n        }\\n        best[curr] += price[curr];\\n        return best[curr];\\n    }\\n    \\n    // reiterating on all nodes keeping the best_answer from the parent\\n    void dfs2(int curr, int par, long long par_best, vector<int> &price) {\\n        new_best[curr] = max(best[curr], par_best + price[curr]);\\n        \\n        /*\\n            A little twist here, let\\'s say curr node has more than 1 child then we need to find the best answer from all the children and while going to each child we will send the best answer from the children and from the parent. But whatif, I\\'m going to child c and the child which gave the best answer is also child c, this would be a disaster. Right?\\n            So, I\\'ve splitted the solution of this problem in two parts.\\n            Part 1: find a child c, that is giving the best answer and go to all the children of curr node except child c.\\n            Part 2: find the best answer from the children of current node except c, and go to c.\\n        \\n        */\\n        \\n        // Part 1: \\n        int best_child = -1;\\n        long long best_child_ans = 0;\\n        for(int child: adj[curr]) {\\n            if(child != par && best_child_ans < best[child]) {\\n                best_child_ans = best[child];\\n                best_child = child;\\n            }\\n        }\\n        \\n        // going to all the children except the child giving best_answer\\n        for(int child: adj[curr]) {\\n            if(child != par && child != best_child) {\\n                dfs2(child, curr, max(par_best, best_child_ans) + price[curr], price);\\n            }\\n        }\\n        \\n        // Part 2: Goto the child that give the best answer in part 1.\\n        if(best_child != -1) { // current node has more than one child\\n            long long best_ans = 0;\\n            for(int child: adj[curr]) {\\n                if(child != par && child != best_child) {\\n                    best_ans = max(best_ans, best[child]);\\n                }\\n            }\\n            dfs2(best_child, curr, max(par_best, best_ans) + price[curr], price);\\n        }\\n    }\\n    \\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        // Initializing the arrays and creating a graph\\n        best = vector<long long> (n, 0);\\n        new_best = vector<long long> (n, 0);\\n        adj = vector<vector<int>> (n);\\n        for(vector<int> edge: edges) {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        dfs1(0, -1, price);\\n        dfs2(0, -1, 0, price);\\n        \\n        // The Final Part: Iterating to all the leaf nodes of the graph.\\n        // Why Only Leaf Nodes? Because, the longest path in a graph(containing all positive ) would be from a leaf node to another leaf node. Think!!. Simple, Right?\\n        // and minimum path from this leaf node would contain this node only.\\n        long long mx = 0;\\n        for(int i=0; i<n; i++) {\\n            if(adj[i].size() == 1) {\\n                mx = max(mx, new_best[i] - price[i]);\\n            }\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071586,
                "title": "c-dfs-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long ans;\\n    long long cost[100000][2];\\n    vector<int> list[100000];    \\n    // update 1st child cost, 2nd child cost at cur node\\n    void f_update (long long v, long long cost[2]) {\\n        if(cost[0] < v) {\\n            cost[1] = cost[0];\\n            cost[0] = v;\\n        }\\n        else if(cost[1] < v) cost[1] = v;\\n    }\\n    // get child costs at cur node\\n    long long f_child_cost (int cur, int par, vector<int>& price) {\\n        for (int next : list[cur]) {\\n            if(next == par) continue;\\n            f_update(f_child_cost(next, cur, price), cost[cur]);\\n        }\\n        return cost[cur][0] + price[cur];\\n    }\\n    // update child costs, If cur node is root node\\n    void f_max_cost (int cur, int par, long long v, vector<int>& price) {\\n        f_update(v, cost[cur]);\\n        if(ans < cost[cur][0]) ans = cost[cur][0];\\n\\n        for (int next : list[cur]) {\\n            if(next == par) continue;\\n            // if next node is the 1st cost of cur then choose 2nd cost\\n            if(cost[next][0] + price[next] == cost[cur][0]) f_max_cost (next, cur, cost[cur][1] + price[cur], price);\\n            // if not, choose 1st cost\\n            else f_max_cost (next, cur, cost[cur][0] + price[cur], price);\\n        }\\n    }\\n\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        int m = edges.size();\\n        for (int i=0; i<m; ++i) {\\n            list[edges[i][0]].push_back(edges[i][1]);\\n            list[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        //find child 1st, 2nd costs\\n        f_child_cost(0, 0, price);\\n\\n        // update max cost\\n        ans = 0;\\n        f_max_cost (0, 0, 0, price);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans;\\n    long long cost[100000][2];\\n    vector<int> list[100000];    \\n    // update 1st child cost, 2nd child cost at cur node\\n    void f_update (long long v, long long cost[2]) {\\n        if(cost[0] < v) {\\n            cost[1] = cost[0];\\n            cost[0] = v;\\n        }\\n        else if(cost[1] < v) cost[1] = v;\\n    }\\n    // get child costs at cur node\\n    long long f_child_cost (int cur, int par, vector<int>& price) {\\n        for (int next : list[cur]) {\\n            if(next == par) continue;\\n            f_update(f_child_cost(next, cur, price), cost[cur]);\\n        }\\n        return cost[cur][0] + price[cur];\\n    }\\n    // update child costs, If cur node is root node\\n    void f_max_cost (int cur, int par, long long v, vector<int>& price) {\\n        f_update(v, cost[cur]);\\n        if(ans < cost[cur][0]) ans = cost[cur][0];\\n\\n        for (int next : list[cur]) {\\n            if(next == par) continue;\\n            // if next node is the 1st cost of cur then choose 2nd cost\\n            if(cost[next][0] + price[next] == cost[cur][0]) f_max_cost (next, cur, cost[cur][1] + price[cur], price);\\n            // if not, choose 1st cost\\n            else f_max_cost (next, cur, cost[cur][0] + price[cur], price);\\n        }\\n    }\\n\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        int m = edges.size();\\n        for (int i=0; i<m; ++i) {\\n            list[edges[i][0]].push_back(edges[i][1]);\\n            list[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        //find child 1st, 2nd costs\\n        f_child_cost(0, 0, price);\\n\\n        // update max cost\\n        ans = 0;\\n        f_max_cost (0, 0, 0, price);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068750,
                "title": "c-solution-using-dfs",
                "content": "# Complexity\\n- Time complexity: O(NlogN)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long anss = 0;\\n    long long max(long long a, long long b){\\n        return a>b?a:b;\\n    }\\n    void dfs2(int src, vector<int> v[], vector<int> &p, vector<int> &val, vector<int> &vis, long long par = 0){\\n        anss = max(anss, val[src]-p[src]);\\n        vis[src]=1;\\n        vector<pair<long long, int> > vv;\\n        for(auto x: v[src]){\\n            if(!vis[x]){\\n                vv.push_back(make_pair(val[x], x));\\n            }\\n        }\\n        vv.push_back(make_pair(par, -1));\\n        sort(vv.begin(), vv.end());\\n        reverse(vv.begin(), vv.end());\\n        anss = max(anss, vv[0].first);\\n        for(auto x: v[src]){\\n            if(vis[x])continue;\\n            if(vv[0].second == x){\\n                dfs2(x, v, p, val, vis, vv[1].first+p[src]);\\n            } else dfs2(x, v, p, val, vis, vv[0].first+p[src]);\\n        }\\n        \\n    }\\n    void dfs(int src, vector<int> v[], vector<int> &p, vector<int> &val, vector<int> &vis){\\n        vis[src]=1;\\n        long long ans = 0;\\n        for(auto x: v[src]){\\n            if(!vis[x]){\\n                dfs(x, v, p, val, vis);\\n                ans = max(ans, val[x]);\\n            }\\n        }\\n        val[src]=ans + p[src];\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& e, vector<int>& p) {\\n        vector<int> v[n+1];\\n        for(int i=0;i<e.size();++i){\\n            v[e[i][0]].push_back(e[i][1]);\\n            v[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<int> val(n+1);\\n        vector<int> vis(n+1);\\n        dfs(0, v, p, val, vis);\\n        for(int i=0;i<=n;++i)vis[i]=0;\\n        dfs2(0, v, p, val, vis);\\n        return anss;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long anss = 0;\\n    long long max(long long a, long long b){\\n        return a>b?a:b;\\n    }\\n    void dfs2(int src, vector<int> v[], vector<int> &p, vector<int> &val, vector<int> &vis, long long par = 0){\\n        anss = max(anss, val[src]-p[src]);\\n        vis[src]=1;\\n        vector<pair<long long, int> > vv;\\n        for(auto x: v[src]){\\n            if(!vis[x]){\\n                vv.push_back(make_pair(val[x], x));\\n            }\\n        }\\n        vv.push_back(make_pair(par, -1));\\n        sort(vv.begin(), vv.end());\\n        reverse(vv.begin(), vv.end());\\n        anss = max(anss, vv[0].first);\\n        for(auto x: v[src]){\\n            if(vis[x])continue;\\n            if(vv[0].second == x){\\n                dfs2(x, v, p, val, vis, vv[1].first+p[src]);\\n            } else dfs2(x, v, p, val, vis, vv[0].first+p[src]);\\n        }\\n        \\n    }\\n    void dfs(int src, vector<int> v[], vector<int> &p, vector<int> &val, vector<int> &vis){\\n        vis[src]=1;\\n        long long ans = 0;\\n        for(auto x: v[src]){\\n            if(!vis[x]){\\n                dfs(x, v, p, val, vis);\\n                ans = max(ans, val[x]);\\n            }\\n        }\\n        val[src]=ans + p[src];\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& e, vector<int>& p) {\\n        vector<int> v[n+1];\\n        for(int i=0;i<e.size();++i){\\n            v[e[i][0]].push_back(e[i][1]);\\n            v[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<int> val(n+1);\\n        vector<int> vis(n+1);\\n        dfs(0, v, p, val, vis);\\n        for(int i=0;i<=n;++i)vis[i]=0;\\n        dfs2(0, v, p, val, vis);\\n        return anss;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067704,
                "title": "calculate-largest-and-second-largest-path-from-root",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Brute Force**\\nFor all pair of leaf nodes (a,b) calculate max( path(a,b) - a, path(a,b) -b ) where path is the path sum from leaf node a to b.\\n\\n**Optimal Approach**\\nCalculate two paths :\\n- Largest path from curr node to leaf node (complete path)\\n- Largest path from curr node to leaf excluding leaf (partial path)\\n\\nans would be maximum of partial + complete paths.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>p;\\n    long long ans = 0;\\n    pair<long long,long long> f(int u,vector<vector<int>>&adj,vector<int>&vis){\\n        vis[u] = 1;\\n        if(adj[u].size() == 1){\\n            return {0,p[u]};\\n        }\\n        \\n        long long mx_complete = 0,mx_partial = 0;\\n        for(int nbr:adj[u]){\\n            if(!vis[nbr]){\\n                vis[nbr] = 1;\\n                pair<long long,long long>sm = f(nbr,adj,vis);\\n                long long partial = sm.first;\\n                long long complete = sm.second;\\n                long long tempans = p[u] + max(mx_complete + partial , mx_partial + complete);\\n                ans = max(ans,tempans);\\n                mx_complete = max(mx_complete,complete);\\n                mx_partial = max(mx_partial,partial);\\n            }\\n        }\\n        return {p[u] + mx_partial,p[u] + mx_complete};\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>>adj(n);\\n        if(n==1)return 0;\\n        if(n==2){\\n            return max(price[0],price[1]);\\n        }\\n        vector<int>vis(n,0);\\n        p = price;\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        int root=-1;\\n        for(int i=0;i<n;i++){\\n            if(adj[i].size()>1)root=i;\\n        }\\n        pair<long long,long long>t = f(root,adj,vis);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>p;\\n    long long ans = 0;\\n    pair<long long,long long> f(int u,vector<vector<int>>&adj,vector<int>&vis){\\n        vis[u] = 1;\\n        if(adj[u].size() == 1){\\n            return {0,p[u]};\\n        }\\n        \\n        long long mx_complete = 0,mx_partial = 0;\\n        for(int nbr:adj[u]){\\n            if(!vis[nbr]){\\n                vis[nbr] = 1;\\n                pair<long long,long long>sm = f(nbr,adj,vis);\\n                long long partial = sm.first;\\n                long long complete = sm.second;\\n                long long tempans = p[u] + max(mx_complete + partial , mx_partial + complete);\\n                ans = max(ans,tempans);\\n                mx_complete = max(mx_complete,complete);\\n                mx_partial = max(mx_partial,partial);\\n            }\\n        }\\n        return {p[u] + mx_partial,p[u] + mx_complete};\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>>adj(n);\\n        if(n==1)return 0;\\n        if(n==2){\\n            return max(price[0],price[1]);\\n        }\\n        vector<int>vis(n,0);\\n        p = price;\\n        for(auto i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        int root=-1;\\n        for(int i=0;i<n;i++){\\n            if(adj[i].size()>1)root=i;\\n        }\\n        pair<long long,long long>t = f(root,adj,vis);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065856,
                "title": "python3-commented-o-n-solution-traverse-only-twice-no-tle",
                "content": "As some of the O(N) DFS solutions are no longer able to pass the time limit as of 01-17-23 15:49, here is a solution based on message passing (like DP). It only traverse the tree twice. \\n\\n```python\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        \\n        if not len(edges):\\n            return 0\\n        \\n        graph = defaultdict(list)\\n        for i,j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        \\n        \\n        msg = {} # at most 2*edges\\n        \\n        # at first pass, we assume the tree is rooted at 0, and calculate the longest path from a node to leaves.\\n\\t\\t# this is upward message passing process\\n        def bot_up(i=0, j=-1):\\n            res = 0\\n            for k in graph[i]:\\n                if k != j:\\n                    msg[k,i] = bot_up(k, i)\\n                    res = max(res, msg[k,i])\\n            return res + price[i] \\n        \\n\\t\\t# at second pass, we start from root, and passing the message downwards\\n\\t\\t# when passing message from i to k (where i is parent), we gathering all message from any node to i (except k), and then take the maximum. \\n\\t\\t# this would be the message from i to k (plus the price itself)\\n\\t\\t# this mesage means the longest path k can have if it goes through i.\\n\\t\\t\\n\\t\\t# For implementation, you basically first take all message and find the maximum.\\n\\t\\t# Assume this maximum is from node `ind`, then only message i to `ind` is different from others. \\n\\t\\t\\n        def top_down(i=0, j = -1):\\n            info = [msg[k,i] for k in graph[i]]\\n            info.append(0)\\n            max_val = max(info)\\n            ind = info.index(max_val)\\n            info.pop(ind)\\n            sec_max = max(info)\\n            \\n            for _i, k in enumerate(graph[i]):\\n                if k != j:\\n                    if _i == ind:\\n                        msg[i,k] = sec_max + price[i]\\n                    else:\\n                        msg[i,k] = max_val + price[i]\\n                    \\n                    top_down(k,i)\\n            \\n        bot_up()\\n        top_down()\\n        return max(msg.values())\\n```\\n\\nThe time and space complexity is O(N).\\nSide Note: message passing is something related to inference of the Probabilistic Grpaphical Models (PGMs), a class of Machine Learning Models. \\n\\nAnother similar problem to practice:\\nhttps://leetcode.com/problems/sum-of-distances-in-tree/\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        \\n        if not len(edges):\\n            return 0\\n        \\n        graph = defaultdict(list)\\n        for i,j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        \\n        \\n        msg = {} # at most 2*edges\\n        \\n        # at first pass, we assume the tree is rooted at 0, and calculate the longest path from a node to leaves.\\n\\t\\t# this is upward message passing process\\n        def bot_up(i=0, j=-1):\\n            res = 0\\n            for k in graph[i]:\\n                if k != j:\\n                    msg[k,i] = bot_up(k, i)\\n                    res = max(res, msg[k,i])\\n            return res + price[i] \\n        \\n\\t\\t# at second pass, we start from root, and passing the message downwards\\n\\t\\t# when passing message from i to k (where i is parent), we gathering all message from any node to i (except k), and then take the maximum. \\n\\t\\t# this would be the message from i to k (plus the price itself)\\n\\t\\t# this mesage means the longest path k can have if it goes through i.\\n\\t\\t\\n\\t\\t# For implementation, you basically first take all message and find the maximum.\\n\\t\\t# Assume this maximum is from node `ind`, then only message i to `ind` is different from others. \\n\\t\\t\\n        def top_down(i=0, j = -1):\\n            info = [msg[k,i] for k in graph[i]]\\n            info.append(0)\\n            max_val = max(info)\\n            ind = info.index(max_val)\\n            info.pop(ind)\\n            sec_max = max(info)\\n            \\n            for _i, k in enumerate(graph[i]):\\n                if k != j:\\n                    if _i == ind:\\n                        msg[i,k] = sec_max + price[i]\\n                    else:\\n                        msg[i,k] = max_val + price[i]\\n                    \\n                    top_down(k,i)\\n            \\n        bot_up()\\n        top_down()\\n        return max(msg.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061566,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>> g(n);\\n        for(auto& e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        long long ans = 0;\\n        function<vector<long long>(int, int)> dfs = [&] (int now, int pre) ->vector<long long> {\\n            vector<long long> cur_max = {price[now], 0};\\n            for(auto& nei : g[now]) {\\n                if(nei != pre) {\\n                    auto&& sub = dfs(nei, now);\\n                    ans = max(ans, cur_max[0] + sub[1]);\\n                    ans = max(ans, cur_max[1] + sub[0]);\\n                    cur_max[0] = max(cur_max[0], sub[0] + price[now]);\\n                    cur_max[1] = max(cur_max[1], sub[1] + price[now]);\\n                }\\n            }\\n            return cur_max;\\n        };\\n        dfs(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>> g(n);\\n        for(auto& e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        long long ans = 0;\\n        function<vector<long long>(int, int)> dfs = [&] (int now, int pre) ->vector<long long> {\\n            vector<long long> cur_max = {price[now], 0};\\n            for(auto& nei : g[now]) {\\n                if(nei != pre) {\\n                    auto&& sub = dfs(nei, now);\\n                    ans = max(ans, cur_max[0] + sub[1]);\\n                    ans = max(ans, cur_max[1] + sub[0]);\\n                    cur_max[0] = max(cur_max[0], sub[0] + price[now]);\\n                    cur_max[1] = max(cur_max[1], sub[1] + price[now]);\\n                }\\n            }\\n            return cur_max;\\n        };\\n        dfs(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061022,
                "title": "swift-dfs",
                "content": "**DFS (accepted answer)**\\n```\\nclass Solution {\\n    func maxOutput(_ n: Int, _ edges: [[Int]], _ price: [Int]) -> Int {\\n        var result = 0\\n        let graph = edges.reduce(into: [0: [-1]]) { graph, edge in\\n            graph[edge[0], default: .init()].append(edge[1])\\n            graph[edge[1], default: .init()].append(edge[0])\\n        }\\n        \\n        func dfs(_ node: Int, _ prev: Int = -1) -> [Int] {\\n            graph[node]!.filter { $0 != prev }.reduce(into: [0, price[node]]) { nodeMax, next in\\n                let adjacentMax = dfs(next, node)\\n                result = max(result, zip(nodeMax, adjacentMax.reversed()).map{ $0.0 + $0.1 }.max()!)\\n                nodeMax = zip(nodeMax, adjacentMax).map { max($0.0, $0.1 + price[node]) }\\n            }\\n        }\\n        \\n        dfs(0)\\n        return result\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxOutput(_ n: Int, _ edges: [[Int]], _ price: [Int]) -> Int {\\n        var result = 0\\n        let graph = edges.reduce(into: [0: [-1]]) { graph, edge in\\n            graph[edge[0], default: .init()].append(edge[1])\\n            graph[edge[1], default: .init()].append(edge[0])\\n        }\\n        \\n        func dfs(_ node: Int, _ prev: Int = -1) -> [Int] {\\n            graph[node]!.filter { $0 != prev }.reduce(into: [0, price[node]]) { nodeMax, next in\\n                let adjacentMax = dfs(next, node)\\n                result = max(result, zip(nodeMax, adjacentMax.reversed()).map{ $0.0 + $0.1 }.max()!)\\n                nodeMax = zip(nodeMax, adjacentMax).map { max($0.0, $0.1 + price[node]) }\\n            }\\n        }\\n        \\n        dfs(0)\\n        return result\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060919,
                "title": "re-rooting-learning-solution",
                "content": "Learning from  [Re rooting](https://leetcode.com/problems/difference-between-maximum-and-minimum-price-sum/solutions/3052596/re-rooting/?orderBy=most_votes).\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/f15f4760-f5b2-43b7-874c-94e31951d41d_1673904905.5984175.png)\\n\\n-----\\n![image.png](https://assets.leetcode.com/users/images/caeecb4b-aea3-4e64-9ded-16909bdf370c_1673904936.892669.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    long[] subMaxSum;\\n    long maxDiff = 0L;\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        subMaxSum = new long[n];\\n        List<List<Integer>> tree = new ArrayList<>();\\n        for (int i = 0; i < n; i++) tree.add(new ArrayList<>());\\n        for (int[] edge : edges) {\\n            tree.get(edge[0]).add(edge[1]);\\n            tree.get(edge[1]).add(edge[0]);\\n        }\\n        // calculate subMaxSum;\\n        dfs(-1, 0, tree, price);\\n        dfs2(-1, 0, tree, price, 0);\\n        \\n        return maxDiff;\\n        \\n    }\\n\\n    private long dfs(int p, int u, List<List<Integer>> tree, int[] price) {\\n        long currMax = 0L;\\n        for (int v : tree.get(u)) {\\n            if (p == v) continue;\\n            currMax = Math.max(currMax, dfs(u, v, tree, price));\\n        }\\n        currMax += price[u];\\n        subMaxSum[u] = currMax;\\n        return currMax;\\n    }\\n\\n    private void dfs2(int p, int u, List<List<Integer>> tree, int[] price, long pSum) {\\n        // get 2 maxchildren sum\\n        long big1 = 0L, big2 = 0L;\\n        int c1 = -1;\\n\\n        for (int v : tree.get(u)) {\\n            if (v == p) continue;\\n            if (subMaxSum[v] > big1) {\\n                big2 = big1;\\n                big1 = subMaxSum[v];\\n                c1 = v;\\n            } else if (subMaxSum[v] > big2) {\\n                big2 = subMaxSum[v];\\n            }\\n        }\\n\\n        long path1 = big1, path2 = pSum;\\n        maxDiff = Math.max(maxDiff, Math.max(path1, path2));\\n\\n        // determine go to which child\\n        for (int v : tree.get(u)) {\\n            if (v == p) continue;\\n            if (v == c1) {\\n                dfs2(u, c1, tree, price, price[u] + Math.max(big2, pSum));\\n            } else {\\n                dfs2(u, v, tree, price, price[u] + Math.max(big1, pSum));\\n            }\\n        }\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long[] subMaxSum;\\n    long maxDiff = 0L;\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        subMaxSum = new long[n];\\n        List<List<Integer>> tree = new ArrayList<>();\\n        for (int i = 0; i < n; i++) tree.add(new ArrayList<>());\\n        for (int[] edge : edges) {\\n            tree.get(edge[0]).add(edge[1]);\\n            tree.get(edge[1]).add(edge[0]);\\n        }\\n        // calculate subMaxSum;\\n        dfs(-1, 0, tree, price);\\n        dfs2(-1, 0, tree, price, 0);\\n        \\n        return maxDiff;\\n        \\n    }\\n\\n    private long dfs(int p, int u, List<List<Integer>> tree, int[] price) {\\n        long currMax = 0L;\\n        for (int v : tree.get(u)) {\\n            if (p == v) continue;\\n            currMax = Math.max(currMax, dfs(u, v, tree, price));\\n        }\\n        currMax += price[u];\\n        subMaxSum[u] = currMax;\\n        return currMax;\\n    }\\n\\n    private void dfs2(int p, int u, List<List<Integer>> tree, int[] price, long pSum) {\\n        // get 2 maxchildren sum\\n        long big1 = 0L, big2 = 0L;\\n        int c1 = -1;\\n\\n        for (int v : tree.get(u)) {\\n            if (v == p) continue;\\n            if (subMaxSum[v] > big1) {\\n                big2 = big1;\\n                big1 = subMaxSum[v];\\n                c1 = v;\\n            } else if (subMaxSum[v] > big2) {\\n                big2 = subMaxSum[v];\\n            }\\n        }\\n\\n        long path1 = big1, path2 = pSum;\\n        maxDiff = Math.max(maxDiff, Math.max(path1, path2));\\n\\n        // determine go to which child\\n        for (int v : tree.get(u)) {\\n            if (v == p) continue;\\n            if (v == c1) {\\n                dfs2(u, c1, tree, price, price[u] + Math.max(big2, pSum));\\n            } else {\\n                dfs2(u, v, tree, price, price[u] + Math.max(big1, pSum));\\n            }\\n        }\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059130,
                "title": "updated-python-dfs-o-v-e-no-tle",
                "content": "For each vertex maintain at most two largest path sums that starts from that vertex\\nMain idea is to memoize computation result for each vertex.\\n# Code\\n```\\nfrom collections import defaultdict\\nfrom functools import cache\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        G = defaultdict(set)\\n        for v,w in edges:\\n            G[v].add(w)\\n            G[w].add(v)\\n        d = [[] for v in range(n)]\\n        @cache\\n        def dfs(u, v):\\n            res = 0\\n            if d[v] and u != -1: \\n                if max(d[v]) != dfs(v,u):\\n                    res = max(d[v])\\n                elif len(d[v]) > 1:\\n                    res = min(d[v])\\n            for w in G[v].copy():\\n                if w == u: continue\\n                heappush(d[v], dfs(v,w))\\n                res = max(res, dfs(v,w))\\n                if len(d[v]) > 2: heappop(d[v])\\n                G[v].remove(w)\\n            return price[v] + res\\n        res = 0\\n        for v in range(n):\\n            maxsum = dfs(-1, v)\\n            res = max(res, maxsum - price[v])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom functools import cache\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        G = defaultdict(set)\\n        for v,w in edges:\\n            G[v].add(w)\\n            G[w].add(v)\\n        d = [[] for v in range(n)]\\n        @cache\\n        def dfs(u, v):\\n            res = 0\\n            if d[v] and u != -1: \\n                if max(d[v]) != dfs(v,u):\\n                    res = max(d[v])\\n                elif len(d[v]) > 1:\\n                    res = min(d[v])\\n            for w in G[v].copy():\\n                if w == u: continue\\n                heappush(d[v], dfs(v,w))\\n                res = max(res, dfs(v,w))\\n                if len(d[v]) > 2: heappop(d[v])\\n                G[v].remove(w)\\n            return price[v] + res\\n        res = 0\\n        for v in range(n):\\n            maxsum = dfs(-1, v)\\n            res = max(res, maxsum - price[v])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3058145,
                "title": "java-one-of-the-easiest-solution-dfs-dp-explanation",
                "content": "```\\npublic static long maxOutput(int n, int[][] edges, int[] price) {\\n        Map<String, Long> map = new HashMap<>();\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n            String str1 = u+\"|\"+v;\\n            String str2 = v+\"|\"+u;\\n            map.put(str1, 0L);\\n            map.put(str2, 0L);\\n        }\\n        long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            long cur = dfs(adj, map, price, i, -1);\\n            ans = Math.max(ans, cur - price[i]);\\n        }\\n        return ans;\\n    }\\n\\n    private static long dfs(List<List<Integer>> adj, Map<String, Long> map, int[] price, int node, int parent) {\\n        long max = 0;\\n        for (int it : adj.get(node)) {\\n            if (it != parent) {\\n                String str = node + \"|\" + it;\\n                long temp = map.get(str);\\n                if (temp == 0) {\\n                    temp = dfs(adj, map, price,it, node);\\n                    map.put(str, temp);\\n                }\\n                max = Math.max(max, temp);\\n            }\\n        }\\n        return max + price[node];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\npublic static long maxOutput(int n, int[][] edges, int[] price) {\\n        Map<String, Long> map = new HashMap<>();\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n            String str1 = u+\"|\"+v;\\n            String str2 = v+\"|\"+u;\\n            map.put(str1, 0L);\\n            map.put(str2, 0L);\\n        }\\n        long ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            long cur = dfs(adj, map, price, i, -1);\\n            ans = Math.max(ans, cur - price[i]);\\n        }\\n        return ans;\\n    }\\n\\n    private static long dfs(List<List<Integer>> adj, Map<String, Long> map, int[] price, int node, int parent) {\\n        long max = 0;\\n        for (int it : adj.get(node)) {\\n            if (it != parent) {\\n                String str = node + \"|\" + it;\\n                long temp = map.get(str);\\n                if (temp == 0) {\\n                    temp = dfs(adj, map, price,it, node);\\n                    map.put(str, temp);\\n                }\\n                max = Math.max(max, temp);\\n            }\\n        }\\n        return max + price[node];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3057714,
                "title": "easy-c-solution-using-dp-on-trees",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> trees[100001];\\n    long long dp1[100001];\\n    long long dp2[100001];\\n    int path[100001];\\n    bool isLeaf(int src, int par){\\n        for(auto child : trees[src]){\\n            if(child != par) return false;\\n        }return true;\\n    }\\n    void dfs(int src, int par, vector<int>& price){\\n        dp1[src] = price[src];\\n        if(isLeaf(src,par)) return;\\n        long long ans = 0;\\n        for(auto child : trees[src]){\\n            if(child != par){\\n                dfs(child,src,price);\\n                ans = max(ans,dp1[child]);\\n            }\\n        }\\n        for(auto child : trees[src]){\\n            if(child != par){\\n                if(dp1[child] == ans) {path[child] = 1; break;}\\n            }\\n        }dp1[src] += ans;\\n    }\\n    void solve(int src, int par, vector<int>& price){\\n        vector<int> childAns;\\n        for(auto child : trees[src]){\\n            if(child != par){\\n                childAns.push_back(dp1[child]);\\n            }\\n        }sort(childAns.begin(),childAns.end());\\n        int n = childAns.size();\\n        for(auto child : trees[src]){\\n            if(child != par){\\n                long long l = 0;\\n                if(n > 1) l = childAns[n-2]; \\n                if(path[child] == 1) dp2[child] = price[child] + max(dp1[src]-dp1[child]+l, dp2[src]);\\n                if(path[child] == 0) dp2[child] = price[child] + max(dp1[src], dp2[src]);\\n                solve(child,src,price);\\n            }\\n        }\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        int m = edges.size();\\n        for(int i=0;i<m;i++){\\n            trees[edges[i][0]].push_back(edges[i][1]);\\n            trees[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        path[0] = 1;\\n        dfs(0,-1,price);\\n        dp2[0] = price[0];\\n        solve(0,-1,price);\\n        long long ans = 0;\\n        for(int i=0;i<n;i++) ans = max({ans,dp1[i]-price[i],dp2[i]-price[i]});\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> trees[100001];\\n    long long dp1[100001];\\n    long long dp2[100001];\\n    int path[100001];\\n    bool isLeaf(int src, int par){\\n        for(auto child : trees[src]){\\n            if(child != par) return false;\\n        }return true;\\n    }\\n    void dfs(int src, int par, vector<int>& price){\\n        dp1[src] = price[src];\\n        if(isLeaf(src,par)) return;\\n        long long ans = 0;\\n        for(auto child : trees[src]){\\n            if(child != par){\\n                dfs(child,src,price);\\n                ans = max(ans,dp1[child]);\\n            }\\n        }\\n        for(auto child : trees[src]){\\n            if(child != par){\\n                if(dp1[child] == ans) {path[child] = 1; break;}\\n            }\\n        }dp1[src] += ans;\\n    }\\n    void solve(int src, int par, vector<int>& price){\\n        vector<int> childAns;\\n        for(auto child : trees[src]){\\n            if(child != par){\\n                childAns.push_back(dp1[child]);\\n            }\\n        }sort(childAns.begin(),childAns.end());\\n        int n = childAns.size();\\n        for(auto child : trees[src]){\\n            if(child != par){\\n                long long l = 0;\\n                if(n > 1) l = childAns[n-2]; \\n                if(path[child] == 1) dp2[child] = price[child] + max(dp1[src]-dp1[child]+l, dp2[src]);\\n                if(path[child] == 0) dp2[child] = price[child] + max(dp1[src], dp2[src]);\\n                solve(child,src,price);\\n            }\\n        }\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        int m = edges.size();\\n        for(int i=0;i<m;i++){\\n            trees[edges[i][0]].push_back(edges[i][1]);\\n            trees[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        path[0] = 1;\\n        dfs(0,-1,price);\\n        dp2[0] = price[0];\\n        solve(0,-1,price);\\n        long long ans = 0;\\n        for(int i=0;i<n;i++) ans = max({ans,dp1[i]-price[i],dp2[i]-price[i]});\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057620,
                "title": "python-dfs-100-time-easy-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe do a DFS where we keep track of a tuple where the first element is the maximum price sum of a path from the `node` to a leaf and the second element is the maximum price sum of a path from the `node` to a leaf excluding the leaf\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        graph, res = defaultdict(list), 0\\n        for startNode, endNode in edges:\\n            graph[startNode].append(endNode)\\n            graph[endNode].append(startNode)\\n        \\n        def dfs(curNode: int, parent: int) -> Tuple[int]:\\n            nonlocal res\\n            ret = (price[curNode], 0)\\n            for neighbor in graph[curNode]:\\n                if neighbor == parent: \\n                    continue\\n                item = dfs(neighbor, curNode)\\n                res = max(res, ret[0] + item[1], ret[1] + item[0])\\n                ret = (max(ret[0], price[curNode] + item[0]), max(ret[1], price[curNode] + item[1]))\\n            return ret\\n\\n        dfs(0, -1)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```python []\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        graph, res = defaultdict(list), 0\\n        for startNode, endNode in edges:\\n            graph[startNode].append(endNode)\\n            graph[endNode].append(startNode)\\n        \\n        def dfs(curNode: int, parent: int) -> Tuple[int]:\\n            nonlocal res\\n            ret = (price[curNode], 0)\\n            for neighbor in graph[curNode]:\\n                if neighbor == parent: \\n                    continue\\n                item = dfs(neighbor, curNode)\\n                res = max(res, ret[0] + item[1], ret[1] + item[0])\\n                ret = (max(ret[0], price[curNode] + item[0]), max(ret[1], price[curNode] + item[1]))\\n            return ret\\n\\n        dfs(0, -1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057328,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  long long maxOutput(const int n, const vector<vector<int>> &edges, const vector<int> &price) {\\n    constexpr int i_node1 = 0;\\n    constexpr int i_node2 = 1;\\n    constexpr int invalid_parent = -1;\\n    vector<int> graph[n];\\n    for (const vector<int> &edge : edges) {\\n      const int node1 = edge[i_node1];\\n      const int node2 = edge[i_node2];\\n      graph[node1].emplace_back(node2);\\n      graph[node2].emplace_back(node1);\\n    }\\n    \\n    long long ret = 0LL;\\n    dfs(graph, price, 0, invalid_parent, ret);\\n    return ret;\\n  }\\n  \\n private:\\n  /**\\n   * @return: a pair\\n   *          the first element is the maximum price sum of a path from the `node` to a leaf\\n   *          the second element is the maximum price sum of a path from the `node` to a leaf,\\n   *                                excluding the leaf\\n   */\\n  pair<long long, long long> dfs(const vector<int> *graph,\\n                                 const vector<int> &price,\\n                                 const int node,\\n                                 const int parent,\\n                                 long long &result) {\\n    pair<long long, long long> ret{price[node], 0LL};\\n    for (const int child : graph[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      pair<long long, long long> item = dfs(graph, price, child, node, result);\\n      result = max({result, ret.first + item.second, ret.second + item.first});\\n      ret.first = max(ret.first, price[node] + item.first);\\n      ret.second = max(ret.second, price[node] + item.second);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  long long maxOutput(const int n, const vector<vector<int>> &edges, const vector<int> &price) {\\n    constexpr int i_node1 = 0;\\n    constexpr int i_node2 = 1;\\n    constexpr int invalid_parent = -1;\\n    vector<int> graph[n];\\n    for (const vector<int> &edge : edges) {\\n      const int node1 = edge[i_node1];\\n      const int node2 = edge[i_node2];\\n      graph[node1].emplace_back(node2);\\n      graph[node2].emplace_back(node1);\\n    }\\n    \\n    long long ret = 0LL;\\n    dfs(graph, price, 0, invalid_parent, ret);\\n    return ret;\\n  }\\n  \\n private:\\n  /**\\n   * @return: a pair\\n   *          the first element is the maximum price sum of a path from the `node` to a leaf\\n   *          the second element is the maximum price sum of a path from the `node` to a leaf,\\n   *                                excluding the leaf\\n   */\\n  pair<long long, long long> dfs(const vector<int> *graph,\\n                                 const vector<int> &price,\\n                                 const int node,\\n                                 const int parent,\\n                                 long long &result) {\\n    pair<long long, long long> ret{price[node], 0LL};\\n    for (const int child : graph[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      pair<long long, long long> item = dfs(graph, price, child, node, result);\\n      result = max({result, ret.first + item.second, ret.second + item.first});\\n      ret.first = max(ret.first, price[node] + item.first);\\n      ret.second = max(ret.second, price[node] + item.second);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056655,
                "title": "modified-diameter-of-a-tree-o-n-and-o-n",
                "content": "# Intuition\\nWe need to compute the max modified diameter of a tree where modified diameter is regular diameter minus the minimum of two leaf prices of the chosen diameter.\\n\\nFor max regular diameter of a (binary) tree see https://leetcode.com/problems/diameter-of-binary-tree/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) from dfs traversal\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) from dfs recursion tree\\n\\n# Code\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        \\n        G = defaultdict(list)\\n        for a,b in edges:\\n            G[a].append(b)\\n            G[b].append(a)\\n\\n        self.ans = 0\\n        \\n        def dfs(x,prev): # returns \"max price path\" and \"max price path ex leaf\" at node x\\n            A, B =[], [] # must keep track of TOP TWO max price path for both versions\\n            for y in G[x]:\\n                if y == prev:\\n                    continue # do not go up the tree\\n                a, b = dfs(y,x)\\n                bisect.insort(A,(a,y)) # need to know which child this max path belong to\\n                if len(A) > 2: #only need top two\\n                    A.pop(0)\\n                bisect.insort(B,(b,y))\\n                if len(B) > 2:\\n                    B.pop(0)\\n            if not A: \\n                return price[x], 0 # not child => not need to update self.ans\\n            if A[-1][1] != B[-1][1]: #two max paths belong to different child\\n                self.ans = max(self.ans, price[x]+A[-1][0] + B[-1][0])\\n            elif len(A) > 1: #max paths below to same child but must select different childs\\n                self.ans = max(self.ans, price[x]+A[-2][0] + B[-1][0], price[x]+A[-1][0]+B[-2][0])\\n            else: # only one child\\n                self.ans = max(self.ans, A[-1][0],price[x]+B[-1][0])\\n            return A[-1][0] + price[x], B[-1][0] + price[x]\\n        dfs(0,-1) #start at zero but can start anywhere\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        \\n        G = defaultdict(list)\\n        for a,b in edges:\\n            G[a].append(b)\\n            G[b].append(a)\\n\\n        self.ans = 0\\n        \\n        def dfs(x,prev): # returns \"max price path\" and \"max price path ex leaf\" at node x\\n            A, B =[], [] # must keep track of TOP TWO max price path for both versions\\n            for y in G[x]:\\n                if y == prev:\\n                    continue # do not go up the tree\\n                a, b = dfs(y,x)\\n                bisect.insort(A,(a,y)) # need to know which child this max path belong to\\n                if len(A) > 2: #only need top two\\n                    A.pop(0)\\n                bisect.insort(B,(b,y))\\n                if len(B) > 2:\\n                    B.pop(0)\\n            if not A: \\n                return price[x], 0 # not child => not need to update self.ans\\n            if A[-1][1] != B[-1][1]: #two max paths belong to different child\\n                self.ans = max(self.ans, price[x]+A[-1][0] + B[-1][0])\\n            elif len(A) > 1: #max paths below to same child but must select different childs\\n                self.ans = max(self.ans, price[x]+A[-2][0] + B[-1][0], price[x]+A[-1][0]+B[-2][0])\\n            else: # only one child\\n                self.ans = max(self.ans, A[-1][0],price[x]+B[-1][0])\\n            return A[-1][0] + price[x], B[-1][0] + price[x]\\n        dfs(0,-1) #start at zero but can start anywhere\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056469,
                "title": "dfs-memoization-to-memoize-the-subproblem-with-direction-from-parent-to-node",
                "content": "# Intuition\\nIt is relatively straightforward to think about constructing the graph and using dfs or bfs for every single node to get the result. The time complexity of this brute force approach is O(n*(m+n)), which will get us TLE.\\n\\nWe can see there are repeating subproblems we are trying to solve. In the given example 1, for node 3, we are trying to repeat solving the maxSum if we come from 1, from 4 or from 5. Basically, if we come from 1 to 3, the maxSum we can get from the remaining paths, if we come from 4 to 3, the maxSum we can get from the remaining paths, if we come from 5 to 3, the maxSum we can get from the remaining paths. \\n\\nWith this memo, we will lower the time big O to O(m+n).\\n\\n**What we are trying to memoize is the direction information here. The \"-1\" as parent really means there is not a parent node for a leaf node if we use the leaf node as the root.**\\n\\n![Screen Shot 2023-01-15 at 7.08.53 PM.png](https://assets.leetcode.com/users/images/50b37196-d110-4552-b15c-f922d3a9c6f4_1673827753.0521219.png)\\n\\n\\nTwo tricks here:\\n- the minSum starting from node i is really the price of this node i\\n- we can start only from leaf nodes, since the optimal solution we are trying to get will be a path without branches. \\n\\n**I was trying to use some trimming technique similar to Khan\\'s algo but did not get the correct approach :(** \\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    List<List<Integer>> graph;\\n    int[] price;\\n    Map<Integer, Long> memo;\\n    \\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        // construct the graph using n and edges\\n        this.graph = new ArrayList<>();\\n        for(int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        for(int[] edge : edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n\\n        this.price = price;\\n        this.memo = new HashMap<>(); // memo to record: in the direction from parent to node and the maxSum from the remaining tree\\n\\n        long result = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(graph.get(i).size() != 1) continue; // only start from leaf node, optimization\\n            result = Math.max(result, getMaxSum(-1, i) - price[i]);\\n        }\\n\\n        return result;\\n    }\\n\\n    private long getMaxSum(int parent, int node) {\\n        int key = parent * 100000 + node;\\n        if(memo.containsKey(key)) return memo.get(key);\\n\\n        long result = price[node];\\n\\n        long toAdd = 0;\\n\\n        for(int next : graph.get(node)) {\\n            if(next == parent) continue;\\n            toAdd = Math.max(toAdd, getMaxSum(node, next));\\n        }\\n\\n        memo.put(key, result + toAdd);\\n        return result + toAdd;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    List<List<Integer>> graph;\\n    int[] price;\\n    Map<Integer, Long> memo;\\n    \\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        // construct the graph using n and edges\\n        this.graph = new ArrayList<>();\\n        for(int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        for(int[] edge : edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n\\n        this.price = price;\\n        this.memo = new HashMap<>(); // memo to record: in the direction from parent to node and the maxSum from the remaining tree\\n\\n        long result = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(graph.get(i).size() != 1) continue; // only start from leaf node, optimization\\n            result = Math.max(result, getMaxSum(-1, i) - price[i]);\\n        }\\n\\n        return result;\\n    }\\n\\n    private long getMaxSum(int parent, int node) {\\n        int key = parent * 100000 + node;\\n        if(memo.containsKey(key)) return memo.get(key);\\n\\n        long result = price[node];\\n\\n        long toAdd = 0;\\n\\n        for(int next : graph.get(node)) {\\n            if(next == parent) continue;\\n            toAdd = Math.max(toAdd, getMaxSum(node, next));\\n        }\\n\\n        memo.put(key, result + toAdd);\\n        return result + toAdd;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056402,
                "title": "python-dfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        tree = defaultdict(list)\\n        for edge in edges:\\n            tree[edge[0]].append(edge[1])\\n            tree[edge[1]].append(edge[0])\\n        self.res = 0\\n\\n        @cache\\n        def dfs(node, parent, price_sum):\\n            local_sum = 0\\n            for nei in tree[node]:\\n                if nei != parent:\\n                    local_sum = max(local_sum, dfs(nei, node, price[nei]))\\n            return price_sum + local_sum\\n\\n        self.res = 0\\n        for node, _ in tree.items():\\n            max_sum = dfs(node, None, price[node])\\n            node_price = price[node]\\n            self.res = max(self.res, max_sum-node_price)\\n\\n        return self.res\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        tree = defaultdict(list)\\n        for edge in edges:\\n            tree[edge[0]].append(edge[1])\\n            tree[edge[1]].append(edge[0])\\n        self.res = 0\\n\\n        @cache\\n        def dfs(node, parent, price_sum):\\n            local_sum = 0\\n            for nei in tree[node]:\\n                if nei != parent:\\n                    local_sum = max(local_sum, dfs(nei, node, price[nei]))\\n            return price_sum + local_sum\\n\\n        self.res = 0\\n        for node, _ in tree.items():\\n            max_sum = dfs(node, None, price[node])\\n            node_price = price[node]\\n            self.res = max(self.res, max_sum-node_price)\\n\\n        return self.res\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056068,
                "title": "dfs-with-memoization-very-short-and-clean-python-code",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        tree = defaultdict(list)\\n        for x, y in edges:\\n            tree[x].append(y)\\n            tree[y].append(x)\\n        \\n        @cache\\n        def dfs(root, parent=None):\\n            cost = price[root]\\n            maxi = 0\\n            for child in tree[root]:\\n                if child != parent:\\n                    maxi = max(maxi, dfs(child, root))\\n            return cost + maxi\\n\\n        return max(dfs(i) - price[i] for i in range(0, n))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        tree = defaultdict(list)\\n        for x, y in edges:\\n            tree[x].append(y)\\n            tree[y].append(x)\\n        \\n        @cache\\n        def dfs(root, parent=None):\\n            cost = price[root]\\n            maxi = 0\\n            for child in tree[root]:\\n                if child != parent:\\n                    maxi = max(maxi, dfs(child, root))\\n            return cost + maxi\\n\\n        return max(dfs(i) - price[i] for i in range(0, n))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055904,
                "title": "recursion-based-solution-less-memory-than-100-o-n-time-updated",
                "content": "# Updated\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe quantity the problem wants us to compute is the maximum cost of any path, minus the smallest cost of one of its endpoints. Let\\'s call this the \"true cost\" of a path.\\n\\nIf a path ends at a node of degree $\\\\geq 2$, then we can extend it, leading to a strictly higher \"true cost\" for the extended path, so such paths will never produce the maximum. Hence we only need to consider paths that end at nodes of degree 1.\\n\\nConsider a breadth-first traversal of the graph, starting at the root, which we take to be 0. This gives an ordering of the graph.\\n\\nEach path must have a highest point in this ordering. Then its \"true cost\" is at most:\\n* the cost of the top node itself\\n* plus the cost of a bottom-up path ending at a child of the top node\\n* plus the same, for a **different** child, excluding the bottom vertex.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each node we compute the top 2 costs of a path ending at a child node and the top 2 costs for the same, excluding the bottom vertex.\\nWe need to compute the top 2 values for each, because the top child could be the same in both cases, while our computation requires two **different** child nodes.\\nWe keep track of the top child for each list, to see if it is the same or not. If it is the same, we also need to consider the second value on each list and do an extra comparison.\\n\\nThis can be done recursively from bottom to top, using the reverse of a breadth-first traversal.\\n\\nFinally, a node can only be the top node for a path if its degree is at least 3 (if it has degree 2 and it is the top node for a path, then it is an endpoint for that path, see above) or if it is the root node, leading to some special cases.\\n\\n# Complexity\\n- Time complexity: Update: This solution works in $O(n)$ time.\\nThe old solution can take $O(n^2)$ time in the worst case, due to having to consider all pairs of children of each vertex.\\nParadoxically, the old solution is faster than the new one.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nThis is the updated solution:\\n```class Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        if n==1:\\n            return 0\\n        g=[[] for _ in range(n)]\\n        for e in edges:\\n            g[e[0]].append(e[1])\\n            g[e[1]].append(e[0])\\n\\n        q=[0]*n\\n        par=[0]*n\\n        curs=0\\n        end=1\\n        while curs<n:\\n            v=q[curs]\\n            curs+=1\\n            for v2 in g[v]:\\n                if v2!=par[v]:\\n                    par[v2]=v\\n                    q[end]=v2\\n                    end+=1\\n\\n        topcst=[[0, None, 0] for _ in range(n)]\\n        topnoend=[[0, None, 0] for _ in range(n)]\\n\\n        for v in reversed(q[1:]):\\n            p=par[v]\\n            topcst[v][0]+=price[v]\\n            topcst[v][2]+=price[v]\\n            if topcst[v][0]>topcst[p][2]:\\n                if topcst[v][0]>topcst[p][0]:\\n                    topcst[p]=[topcst[v][0], v, topcst[p][0]]\\n                else:\\n                    topcst[p][2]=topcst[v][0]\\n            if len(g[v])!=1:\\n                tmp_noend=topnoend[v][0]+price[v]\\n                if tmp_noend>topnoend[p][2]:\\n                    if tmp_noend>topnoend[p][0]:\\n                        topnoend[p]=[tmp_noend, v, topnoend[p][0]]\\n                    else:\\n                        topnoend[p][2]=tmp_noend\\n        topnoend[0][0]+=price[0]\\n        topnoend[0][2]+=price[0]\\n\\n        trucst=lambda v: topcst[v][0]+topnoend[v][0] if topcst[v][1]!=topnoend[v][1] else max(topcst[v][0]+topnoend[v][2], topcst[v][2]+topnoend[v][0])\\n\\n        tmp=max((trucst(v) for v in range(n) if len(g[v])>=3), default=0)\\n        if len(g[0])==1:\\n            return max(tmp, topcst[0][0], topnoend[0][0])            \\n        elif len(g[0])==2:\\n            return max(tmp, trucst(0))\\n        else:\\n            return tmp\\n```\\n\\nThis is the first solution, which is probably better under contest conditions:\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        g=[[] for _ in range(n)]\\n        for e in edges:\\n            g[e[0]].append(e[1])\\n            g[e[1]].append(e[0])\\n        def parse(v, par):\\n            ct=0\\n            lng=[]\\n            noend=[]\\n            a3=0\\n            for v2 in g[v]:\\n                if v2!=par:\\n                    l1, n1, t1=parse(v2, v)\\n                    lng.append(l1)\\n                    noend.append(n1)\\n                    if t1>a3:\\n                        a3=t1\\n                    ct+=1\\n            a1=max(lng, default=0)+price[v]\\n            if ct>=1:\\n                a2=max(noend, default=0)+price[v]\\n                if ct>=2:\\n                    a3=max(a3, max(lng[i]+noend[j] for i in range(ct) for j in range(ct) if i!=j)+price[v])\\n                elif par!=None:\\n                    a3=max(a3, a1)\\n            else:\\n                a2=0\\n            return a1, a2, a3\\n        a1, a2, a3=parse(0, None)\\n        return max(a1-price[0], a2, a3)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```class Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        if n==1:\\n            return 0\\n        g=[[] for _ in range(n)]\\n        for e in edges:\\n            g[e[0]].append(e[1])\\n            g[e[1]].append(e[0])\\n\\n        q=[0]*n\\n        par=[0]*n\\n        curs=0\\n        end=1\\n        while curs<n:\\n            v=q[curs]\\n            curs+=1\\n            for v2 in g[v]:\\n                if v2!=par[v]:\\n                    par[v2]=v\\n                    q[end]=v2\\n                    end+=1\\n\\n        topcst=[[0, None, 0] for _ in range(n)]\\n        topnoend=[[0, None, 0] for _ in range(n)]\\n\\n        for v in reversed(q[1:]):\\n            p=par[v]\\n            topcst[v][0]+=price[v]\\n            topcst[v][2]+=price[v]\\n            if topcst[v][0]>topcst[p][2]:\\n                if topcst[v][0]>topcst[p][0]:\\n                    topcst[p]=[topcst[v][0], v, topcst[p][0]]\\n                else:\\n                    topcst[p][2]=topcst[v][0]\\n            if len(g[v])!=1:\\n                tmp_noend=topnoend[v][0]+price[v]\\n                if tmp_noend>topnoend[p][2]:\\n                    if tmp_noend>topnoend[p][0]:\\n                        topnoend[p]=[tmp_noend, v, topnoend[p][0]]\\n                    else:\\n                        topnoend[p][2]=tmp_noend\\n        topnoend[0][0]+=price[0]\\n        topnoend[0][2]+=price[0]\\n\\n        trucst=lambda v: topcst[v][0]+topnoend[v][0] if topcst[v][1]!=topnoend[v][1] else max(topcst[v][0]+topnoend[v][2], topcst[v][2]+topnoend[v][0])\\n\\n        tmp=max((trucst(v) for v in range(n) if len(g[v])>=3), default=0)\\n        if len(g[0])==1:\\n            return max(tmp, topcst[0][0], topnoend[0][0])            \\n        elif len(g[0])==2:\\n            return max(tmp, trucst(0))\\n        else:\\n            return tmp\\n```\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        g=[[] for _ in range(n)]\\n        for e in edges:\\n            g[e[0]].append(e[1])\\n            g[e[1]].append(e[0])\\n        def parse(v, par):\\n            ct=0\\n            lng=[]\\n            noend=[]\\n            a3=0\\n            for v2 in g[v]:\\n                if v2!=par:\\n                    l1, n1, t1=parse(v2, v)\\n                    lng.append(l1)\\n                    noend.append(n1)\\n                    if t1>a3:\\n                        a3=t1\\n                    ct+=1\\n            a1=max(lng, default=0)+price[v]\\n            if ct>=1:\\n                a2=max(noend, default=0)+price[v]\\n                if ct>=2:\\n                    a3=max(a3, max(lng[i]+noend[j] for i in range(ct) for j in range(ct) if i!=j)+price[v])\\n                elif par!=None:\\n                    a3=max(a3, a1)\\n            else:\\n                a2=0\\n            return a1, a2, a3\\n        a1, a2, a3=parse(0, None)\\n        return max(a1-price[0], a2, a3)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055679,
                "title": "dfs-with-image-easy-explanation-with-dfs-calling",
                "content": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,long long int>dp;\\n    long long dfs(int node,int parent,vector<int> adj[],vector<int>&prices){\\n      long long   int curr=prices[node];\\n        long long int x=0;\\n        long long c=0;\\n        if(dp.find({parent,node})!=dp.end()){\\n            return dp[{parent,node}];\\n        }\\n        for(auto it: adj[node]){\\n            if(it!=parent){\\n               c= dfs(it,node,adj,prices);\\n            }\\n        x=max(x,c);\\n        }\\n        return dp[{parent,node}]=x+curr;   \\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<int> adj[n];\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            long long res=dfs(i,-1,adj,price);\\n            ans=max(ans,res-price[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/71dbbef1-80bd-4081-9aa6-720c872bbf7a_1673805755.3886116.jpeg)",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,long long int>dp;\\n    long long dfs(int node,int parent,vector<int> adj[],vector<int>&prices){\\n      long long   int curr=prices[node];\\n        long long int x=0;\\n        long long c=0;\\n        if(dp.find({parent,node})!=dp.end()){\\n            return dp[{parent,node}];\\n        }\\n        for(auto it: adj[node]){\\n            if(it!=parent){\\n               c= dfs(it,node,adj,prices);\\n            }\\n        x=max(x,c);\\n        }\\n        return dp[{parent,node}]=x+curr;   \\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<int> adj[n];\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        long long ans=0;\\n        for(int i=0;i<n;i++){\\n            long long res=dfs(i,-1,adj,price);\\n            ans=max(ans,res-price[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055325,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n  \\nlong long dfs(int v,vector<vector<int>>&g,map< pair<int,int> ,long long>&m,vector<bool>&vis,vector<int>& p)\\n    {\\n       vis[v]=true;\\n        long long mx=0;\\n        for(auto child : g[v])\\n        {\\n            \\n            \\n            if(vis[child])continue;\\n            \\n            long long l;\\n            if(m.find({v,child})==m.end())\\n            {\\n                l=dfs(child,g,m,vis,p);\\n                 m[{v,child}]=l;\\n            }\\n             else\\n              l=m[{v,child}];\\n            \\n            mx=max(mx,l);         \\n        }\\n   \\n        return mx+p[v];      \\n    }\\n    long long maxOutput(int n, vector<vector<int>>& e, vector<int>& p) {\\n       \\n      map< pair<int,int> ,long long>m;\\n      vector<vector<int>>g(p.size(),vector<int>());\\n        \\n     for(int i=0;i<e.size();i++)\\n     {\\n         g[e[i][0]].push_back(e[i][1]);\\n         \\n         g[e[i][1]].push_back(e[i][0]);\\n     }\\n        \\n        \\n     for(int i=0;i<p.size();i++)\\n     {\\n         vector<bool>vis(p.size(),false);\\n         dfs(i,g,m,vis,p); \\n     }\\n        \\n      long long ans=0;\\n     \\n    for(auto it=m.begin();it!=m.end();it++)\\n    {\\n      \\n        if((long long)it->second>ans)\\n            ans=it->second;\\n              \\n    }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\nlong long dfs(int v,vector<vector<int>>&g,map< pair<int,int> ,long long>&m,vector<bool>&vis,vector<int>& p)\\n    {\\n       vis[v]=true;\\n        long long mx=0;\\n        for(auto child : g[v])\\n        {\\n            \\n            \\n            if(vis[child])continue;\\n            \\n            long long l;\\n            if(m.find({v,child})==m.end())\\n            {\\n                l=dfs(child,g,m,vis,p);\\n                 m[{v,child}]=l;\\n            }\\n             else\\n              l=m[{v,child}];\\n            \\n            mx=max(mx,l);         \\n        }\\n   \\n        return mx+p[v];      \\n    }\\n    long long maxOutput(int n, vector<vector<int>>& e, vector<int>& p) {\\n       \\n      map< pair<int,int> ,long long>m;\\n      vector<vector<int>>g(p.size(),vector<int>());\\n        \\n     for(int i=0;i<e.size();i++)\\n     {\\n         g[e[i][0]].push_back(e[i][1]);\\n         \\n         g[e[i][1]].push_back(e[i][0]);\\n     }\\n        \\n        \\n     for(int i=0;i<p.size();i++)\\n     {\\n         vector<bool>vis(p.size(),false);\\n         dfs(i,g,m,vis,p); \\n     }\\n        \\n      long long ans=0;\\n     \\n    for(auto it=m.begin();it!=m.end();it++)\\n    {\\n      \\n        if((long long)it->second>ans)\\n            ans=it->second;\\n              \\n    }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3055166,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dfs(int v, int p, vector<vector<int>>& edge, vector<int>& price, vector<long long>& mx) {\\n        long long vMx = 0;\\n        for (int u : edge[v]) {\\n            if (u != p) {\\n                long long cMx = dfs(u, v, edge, price, mx);\\n                mx[v] = max(mx[v], cMx);\\n            }\\n        }\\n        mx[v] += price[v];\\n        return mx[v];\\n    }\\n    void dfs1(int v, int p, vector<vector<int>>& edge, vector<int>& price, vector<long long>& mx, long long& sol, vector<long long>& ppMx) {\\n        long long pmx = mx[v];\\n        if (p != -1) {\\n            pmx = max(pmx, ppMx[p] + price[v]);\\n        }\\n        sol = max(sol, pmx - price[v]);\\n        for (int u : edge[v]) {\\n            if (u != p) {\\n                long long px = 0;\\n                if (p != -1) {\\n                    px = max(px, ppMx[p] + price[v]);\\n                }\\n                for (int k : edge[v]) {\\n                    if (k != u && k != p) {\\n                        px = max(px, mx[k] + price[v]);\\n                    }\\n                }\\n                ppMx[v] = px;\\n                if (ppMx[v] == 0) ppMx[v] = price[v];\\n                dfs1(u, v, edge, price, mx, sol, ppMx);\\n            }\\n        }\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>> edge(n);\\n        for (const vector<int>& v : edges) {\\n            edge[v[0]].push_back(v[1]);\\n            edge[v[1]].push_back(v[0]);\\n        }\\n        vector<long long> mx(n);\\n        dfs(0, -1, edge, price, mx);\\n        long long sol = mx[0] - price[0];\\n        vector<long long> ppMx(n);\\n        ppMx[0] = price[0];\\n        dfs1(0, -1, edge, price, mx, sol, ppMx);\\n        return sol;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dfs(int v, int p, vector<vector<int>>& edge, vector<int>& price, vector<long long>& mx) {\\n        long long vMx = 0;\\n        for (int u : edge[v]) {\\n            if (u != p) {\\n                long long cMx = dfs(u, v, edge, price, mx);\\n                mx[v] = max(mx[v], cMx);\\n            }\\n        }\\n        mx[v] += price[v];\\n        return mx[v];\\n    }\\n    void dfs1(int v, int p, vector<vector<int>>& edge, vector<int>& price, vector<long long>& mx, long long& sol, vector<long long>& ppMx) {\\n        long long pmx = mx[v];\\n        if (p != -1) {\\n            pmx = max(pmx, ppMx[p] + price[v]);\\n        }\\n        sol = max(sol, pmx - price[v]);\\n        for (int u : edge[v]) {\\n            if (u != p) {\\n                long long px = 0;\\n                if (p != -1) {\\n                    px = max(px, ppMx[p] + price[v]);\\n                }\\n                for (int k : edge[v]) {\\n                    if (k != u && k != p) {\\n                        px = max(px, mx[k] + price[v]);\\n                    }\\n                }\\n                ppMx[v] = px;\\n                if (ppMx[v] == 0) ppMx[v] = price[v];\\n                dfs1(u, v, edge, price, mx, sol, ppMx);\\n            }\\n        }\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        vector<vector<int>> edge(n);\\n        for (const vector<int>& v : edges) {\\n            edge[v[0]].push_back(v[1]);\\n            edge[v[1]].push_back(v[0]);\\n        }\\n        vector<long long> mx(n);\\n        dfs(0, -1, edge, price, mx);\\n        long long sol = mx[0] - price[0];\\n        vector<long long> ppMx(n);\\n        ppMx[0] = price[0];\\n        dfs1(0, -1, edge, price, mx, sol, ppMx);\\n        return sol;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054980,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_output(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>) -> i64 {\\n        let mut g = vec![vec![]; n as usize];\\n        for e in edges {\\n            g[e[0] as usize].push(e[1] as usize);\\n            g[e[1] as usize].push(e[0] as usize);\\n        }\\n        let mut ans = 0;\\n        fn dfs(ans: &mut i64, now: usize, pre: usize, g: &[Vec<usize>], price: &[i32]) -> Vec<i64> {\\n            let mut cur_max = vec![price[now] as i64, 0];\\n            for nei in &g[now] {\\n                if *nei != pre {\\n                    let sub = dfs(ans, *nei, now, g, price);\\n                    *ans = (*ans).max(cur_max[0] + sub[1]);\\n                    *ans = (*ans).max(cur_max[1] + sub[0]);\\n                    cur_max[0] = cur_max[0].max(sub[0] + price[now] as i64);\\n                    cur_max[1] = cur_max[1].max(sub[1] + price[now] as i64);\\n                }\\n            }\\n            cur_max\\n        }\\n\\n        dfs(&mut ans, 0, n as usize, &g, &price);\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_output(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>) -> i64 {\\n        let mut g = vec![vec![]; n as usize];\\n        for e in edges {\\n            g[e[0] as usize].push(e[1] as usize);\\n            g[e[1] as usize].push(e[0] as usize);\\n        }\\n        let mut ans = 0;\\n        fn dfs(ans: &mut i64, now: usize, pre: usize, g: &[Vec<usize>], price: &[i32]) -> Vec<i64> {\\n            let mut cur_max = vec![price[now] as i64, 0];\\n            for nei in &g[now] {\\n                if *nei != pre {\\n                    let sub = dfs(ans, *nei, now, g, price);\\n                    *ans = (*ans).max(cur_max[0] + sub[1]);\\n                    *ans = (*ans).max(cur_max[1] + sub[0]);\\n                    cur_max[0] = cur_max[0].max(sub[0] + price[now] as i64);\\n                    cur_max[1] = cur_max[1].max(sub[1] + price[now] as i64);\\n                }\\n            }\\n            cur_max\\n        }\\n\\n        dfs(&mut ans, 0, n as usize, &g, &price);\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3054937,
                "title": "python-3-start-from-leaf-nodes",
                "content": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:        \\n        \\n        g = defaultdict(set)\\n        deg = defaultdict(int)\\n        \\n        for a, b in edges:\\n            g[a].add(b)\\n            g[b].add(a)\\n            deg[a] += 1\\n            deg[b] += 1        \\n        \\n        cands = [i for i in range(n) if deg[i] == 1]\\n        \\n        @cache\\n        def dfs(cur, par):            \\n            ans = 0\\n            for nei in g[cur]:\\n                if nei == par : continue\\n                ans = max(ans, price[nei] + dfs(nei, cur))\\n            return ans        \\n        \\n        return max([dfs(cand, -1) for cand in cands], default=0)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:        \\n        \\n        g = defaultdict(set)\\n        deg = defaultdict(int)\\n        \\n        for a, b in edges:\\n            g[a].add(b)\\n            g[b].add(a)\\n            deg[a] += 1\\n            deg[b] += 1        \\n        \\n        cands = [i for i in range(n) if deg[i] == 1]\\n        \\n        @cache\\n        def dfs(cur, par):            \\n            ans = 0\\n            for nei in g[cur]:\\n                if nei == par : continue\\n                ans = max(ans, price[nei] + dfs(nei, cur))\\n            return ans        \\n        \\n        return max([dfs(cand, -1) for cand in cands], default=0)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3054909,
                "title": "dp-node-parent-returns-max-path-from-node-to-the-leaves",
                "content": "# Intuition\\ndp(node,parent) returns the max path from node to the leaves. Max result among all dp will be the final result. We cache the return value of dp, then solve the problem same way as the brute force O(n^2) way. The cache will make time complexity O(n) instead of O(n^2)\\n\\nTime complexity:\\nThe parent of a node can be any node connected to it, which equals the number of edges to this node. So for any given node, the number of **(node,parent)** pair equals the number of connected edges.\\nSo totally, there should be no more than 2*len(edges) of **(node,parent)** pairs to do dp cache, which takes O(n) time. Once we spend that O(n) time and cached all **(node,parent)** pairs, all dp(node,parent) later will take only O(1) time to finish.\\n\\n# Code\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        d = defaultdict(list)\\n        for a,b in edges:\\n            d[a].append(b)\\n            d[b].append(a)\\n        @cache\\n        def dp(node,parent):\\n            return max([dp(nxt,node) for nxt in d[node] if nxt!=parent],default=0)+price[node]\\n        return max(dp(node,None)-price[node] for node in range(n))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        d = defaultdict(list)\\n        for a,b in edges:\\n            d[a].append(b)\\n            d[b].append(a)\\n        @cache\\n        def dp(node,parent):\\n            return max([dp(nxt,node) for nxt in d[node] if nxt!=parent],default=0)+price[node]\\n        return max(dp(node,None)-price[node] for node in range(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054857,
                "title": "c-two-dfs-intuitive-solution-1000ms",
                "content": "# Data\\n- Using edge to store adjacent list.\\n- Using mp[u] to store all neighborhood path sum when u as root\\n\\n# Approach\\n- init() calculate all child path sum\\n- dfs() calculate max_path_sum when parent as the root to get above max_path_sum, and combinating path_sum from child to get below max_path_sum\\n\\n# Complexity\\n- Time complexity:\\n$$O(2*n)=O(n)$$\\n\\n- Space complexity:\\n$$O(2*edge)=O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long res;\\n    vector<vector<int>> edge;\\n    vector<unordered_map<int,long long>> mp;\\n\\n    // calculate all path_sum below the node\\n    long long init(int u, int p, vector<int>& price){\\n        long long f=0;\\n        for(auto &v:edge[u]){\\n            if(v==p)    continue;\\n            long long w=init(v,u,price);\\n            mp[u][v]=w;\\n            if(w>f){\\n                f=w;\\n            }\\n        }\\n        return f+price[u];\\n    }\\n\\n    // get result\\n    void dfs(int u, int p, vector<int>& price){\\n        // calculate max_path_sum above node\\n        if(u!=0){\\n            mp[u][p]=price[p];\\n            for(auto &v:edge[p]){\\n                if(v==u)    continue;\\n                mp[u][p]=max(mp[u][p],mp[p][v]+price[p]);\\n            }\\n        }\\n        // calculate the max_path_sum combinating path_sum above or below the node\\n        for(auto &v:edge[u]){\\n            res=max(res,mp[u][v]);\\n            if(v!=p)    dfs(v,u,price);\\n        }\\n    }\\n\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        res=0;\\n        edge.clear(),edge.resize(n);\\n        mp.clear(),mp.resize(n);\\n        for(auto &e:edges){\\n            edge[e[0]].push_back(e[1]);\\n            edge[e[1]].push_back(e[0]);\\n        }\\n        init(0,-1,price);\\n        dfs(0,-1,price);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long res;\\n    vector<vector<int>> edge;\\n    vector<unordered_map<int,long long>> mp;\\n\\n    // calculate all path_sum below the node\\n    long long init(int u, int p, vector<int>& price){\\n        long long f=0;\\n        for(auto &v:edge[u]){\\n            if(v==p)    continue;\\n            long long w=init(v,u,price);\\n            mp[u][v]=w;\\n            if(w>f){\\n                f=w;\\n            }\\n        }\\n        return f+price[u];\\n    }\\n\\n    // get result\\n    void dfs(int u, int p, vector<int>& price){\\n        // calculate max_path_sum above node\\n        if(u!=0){\\n            mp[u][p]=price[p];\\n            for(auto &v:edge[p]){\\n                if(v==u)    continue;\\n                mp[u][p]=max(mp[u][p],mp[p][v]+price[p]);\\n            }\\n        }\\n        // calculate the max_path_sum combinating path_sum above or below the node\\n        for(auto &v:edge[u]){\\n            res=max(res,mp[u][v]);\\n            if(v!=p)    dfs(v,u,price);\\n        }\\n    }\\n\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        res=0;\\n        edge.clear(),edge.resize(n);\\n        mp.clear(),mp.resize(n);\\n        for(auto &e:edges){\\n            edge[e[0]].push_back(e[1]);\\n            edge[e[1]].push_back(e[0]);\\n        }\\n        init(0,-1,price);\\n        dfs(0,-1,price);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054315,
                "title": "c-dfs-dp",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    const static int N = 1e5 + 1;\\n\\n    struct mxm{\\n        pair<int, long long> P;\\n        pair<int, long long> Q;\\n    };\\n\\n    mxm NP[N];\\n    long long answer[N];\\n    vector<int> g[N];\\n    long long longest_path[N];\\n    void pre_cal(int node, int parent, vector<int>& price) {\\n        longest_path[node] = price[node];\\n        for(int child : g[node]) {\\n            if(child != parent) {\\n                pre_cal(child, node, price);\\n                longest_path[node] = max(longest_path[node], longest_path[child] + price[node]);\\n            }\\n        }\\n    }\\n    void dfs(int node, int parent, vector<int>& price) {\\n        long long mx = longest_path[node];\\n\\n        if(parent != -1) {\\n            auto pairs = NP[parent];\\n            if(pairs.P.first != -1 && pairs.P.first != node) {\\n                mx = max(mx, pairs.P.second + price[node]);\\n            }\\n            if(pairs.Q.first != -1 && pairs.Q.first != node) {\\n                mx = max(mx, pairs.Q.second + price[node]);\\n            }\\n        }\\n\\n        answer[node] = mx - price[node];\\n\\n        long long mx1 = -1, mx2 = -1;\\n        int node1 = -1, node2 = -1;\\n        if(parent != -1) {\\n            auto pairs = NP[parent];\\n            if(pairs.P.first != -1 && pairs.P.first != node) {\\n                if(mx1 < pairs.P.second) {\\n                    mx1 = pairs.P.second + price[node];\\n                    node1 = node;\\n                }\\n            }\\n            if(pairs.Q.first != -1 && pairs.Q.first != node) {\\n                if(mx1 < pairs.Q.second) {\\n                    mx1 = pairs.Q.second + price[node];\\n                    node1 = node;\\n                }\\n            }\\n        }\\n\\n        for(int child : g[node]) {\\n            if(child != parent) {\\n                if(mx1 < longest_path[child] + price[node]) {\\n                    mx1 = longest_path[child] + price[node];\\n                    node1 = child;\\n                }\\n            }\\n        }\\n\\n        if(parent != -1) {\\n            auto pairs = NP[parent];\\n            if(pairs.P.first != -1 && pairs.P.first != node && pairs.P.first != node1) {\\n                if(mx2 < pairs.P.second) {\\n                    mx2 = pairs.P.second + price[node];\\n                    node2 = node;\\n                }\\n            }\\n            if(pairs.Q.first != -1 && pairs.Q.first != node && pairs.Q.first != node1) {\\n                if(mx2 < pairs.Q.second) {\\n                    mx2 = pairs.Q.second + price[node];\\n                    node2 = node;\\n                }\\n            }\\n        }\\n\\n        for(int child : g[node]) {\\n            if(child != parent && child != node1) {\\n                if(mx2 < longest_path[child] + price[node]) {\\n                    mx2 = longest_path[child] + price[node];\\n                    node2 = child;\\n                }\\n            }\\n        }\\n\\n        if(node1 == -1) {\\n            node1 = node;\\n            mx1 = price[node];\\n        }\\n        else if (node2 == -1) {\\n            node2 = node;\\n            mx2 = price[node];\\n        }\\n        NP[node] = {{node1, mx1}, {node2, mx2}};\\n\\n        for(int child : g[node]) {\\n            if(child != parent) {\\n                dfs(child, node, price);\\n            }\\n        }\\n    }\\n\\n    long long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price) {\\n        for(auto e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        pre_cal(0, -1, price);\\n        dfs(0, -1, price);\\n        long long ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            ans = max(ans, answer[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const static int N = 1e5 + 1;\\n\\n    struct mxm{\\n        pair<int, long long> P;\\n        pair<int, long long> Q;\\n    };\\n\\n    mxm NP[N];\\n    long long answer[N];\\n    vector<int> g[N];\\n    long long longest_path[N];\\n    void pre_cal(int node, int parent, vector<int>& price) {\\n        longest_path[node] = price[node];\\n        for(int child : g[node]) {\\n            if(child != parent) {\\n                pre_cal(child, node, price);\\n                longest_path[node] = max(longest_path[node], longest_path[child] + price[node]);\\n            }\\n        }\\n    }\\n    void dfs(int node, int parent, vector<int>& price) {\\n        long long mx = longest_path[node];\\n\\n        if(parent != -1) {\\n            auto pairs = NP[parent];\\n            if(pairs.P.first != -1 && pairs.P.first != node) {\\n                mx = max(mx, pairs.P.second + price[node]);\\n            }\\n            if(pairs.Q.first != -1 && pairs.Q.first != node) {\\n                mx = max(mx, pairs.Q.second + price[node]);\\n            }\\n        }\\n\\n        answer[node] = mx - price[node];\\n\\n        long long mx1 = -1, mx2 = -1;\\n        int node1 = -1, node2 = -1;\\n        if(parent != -1) {\\n            auto pairs = NP[parent];\\n            if(pairs.P.first != -1 && pairs.P.first != node) {\\n                if(mx1 < pairs.P.second) {\\n                    mx1 = pairs.P.second + price[node];\\n                    node1 = node;\\n                }\\n            }\\n            if(pairs.Q.first != -1 && pairs.Q.first != node) {\\n                if(mx1 < pairs.Q.second) {\\n                    mx1 = pairs.Q.second + price[node];\\n                    node1 = node;\\n                }\\n            }\\n        }\\n\\n        for(int child : g[node]) {\\n            if(child != parent) {\\n                if(mx1 < longest_path[child] + price[node]) {\\n                    mx1 = longest_path[child] + price[node];\\n                    node1 = child;\\n                }\\n            }\\n        }\\n\\n        if(parent != -1) {\\n            auto pairs = NP[parent];\\n            if(pairs.P.first != -1 && pairs.P.first != node && pairs.P.first != node1) {\\n                if(mx2 < pairs.P.second) {\\n                    mx2 = pairs.P.second + price[node];\\n                    node2 = node;\\n                }\\n            }\\n            if(pairs.Q.first != -1 && pairs.Q.first != node && pairs.Q.first != node1) {\\n                if(mx2 < pairs.Q.second) {\\n                    mx2 = pairs.Q.second + price[node];\\n                    node2 = node;\\n                }\\n            }\\n        }\\n\\n        for(int child : g[node]) {\\n            if(child != parent && child != node1) {\\n                if(mx2 < longest_path[child] + price[node]) {\\n                    mx2 = longest_path[child] + price[node];\\n                    node2 = child;\\n                }\\n            }\\n        }\\n\\n        if(node1 == -1) {\\n            node1 = node;\\n            mx1 = price[node];\\n        }\\n        else if (node2 == -1) {\\n            node2 = node;\\n            mx2 = price[node];\\n        }\\n        NP[node] = {{node1, mx1}, {node2, mx2}};\\n\\n        for(int child : g[node]) {\\n            if(child != parent) {\\n                dfs(child, node, price);\\n            }\\n        }\\n    }\\n\\n    long long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price) {\\n        for(auto e : edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        pre_cal(0, -1, price);\\n        dfs(0, -1, price);\\n        long long ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            ans = max(ans, answer[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054139,
                "title": "easy-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is to apply DP.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt is really hard to identify that we can apply DP to this problem. Since it is a tree DP table will only take O(2n) space.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dfs(int curr,int par,vector<int>adj[],vector<int>& price,unordered_map<int,long long>dp[]){\\n        if(dp[curr].count(par)) return dp[curr][par];\\n        long long temp = 0;\\n        for(auto &nbr:adj[curr]){\\n            if(nbr != par){\\n                temp = max(temp,dfs(nbr,curr,adj,price,dp));\\n            }\\n        }\\n        return dp[curr][par] = temp + price[curr];\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n       vector<int>adj[n];\\n        for(auto &e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        long long ans = 0;\\n        unordered_map<int,long long>dp[n];\\n        for(int i = 0;i < n;i++){\\n            ans = max(ans,dfs(i,-1,adj,price,dp)-price[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dfs(int curr,int par,vector<int>adj[],vector<int>& price,unordered_map<int,long long>dp[]){\\n        if(dp[curr].count(par)) return dp[curr][par];\\n        long long temp = 0;\\n        for(auto &nbr:adj[curr]){\\n            if(nbr != par){\\n                temp = max(temp,dfs(nbr,curr,adj,price,dp));\\n            }\\n        }\\n        return dp[curr][par] = temp + price[curr];\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n       vector<int>adj[n];\\n        for(auto &e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        long long ans = 0;\\n        unordered_map<int,long long>dp[n];\\n        for(int i = 0;i < n;i++){\\n            ans = max(ans,dfs(i,-1,adj,price,dp)-price[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054123,
                "title": "simple-dfs-approach-and-using-map-to-store-the-results",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to understand that in the question we always want the min to be a leaf node think about this point as this thing will always be deleted so basically what is left is finding the largest path without the start leaf node in it and using memoization to store the results.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int root;\\n    vector<unordered_map<int,long long>>m;\\n    long long dfs(int source,vector<bool>&visited,vector<vector<int>>&adj,int prev,vector<int>&price){\\n        if(adj[source].size()==1 and source!=root){\\n            return m[source][prev] = price[source];\\n        }\\n        if(m[source].count(prev)){\\n            return m[source][prev];\\n        }\\n        long long sum=0;\\n        visited[source]=true; \\n        for(int i=0;i<adj[source].size();i++){\\n            if(adj[source][i]!=prev and visited[adj[source][i]]==false){\\n                long long value=dfs(adj[source][i],visited,adj,source,price);\\n                sum=max(sum,value+price[source]);\\n            }\\n        }\\n    return m[source][prev]=sum;\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        m.resize(n);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>work;\\n        for(int i=0;i<adj.size();i++){\\n            if(adj[i].size()==1){\\n                work.push_back(i);\\n            }\\n        }\\n        long long result1=0;\\n        for(int i=0;i<work.size();i++){\\n            vector<bool>visited(n+1,false);\\n            root=work[i];\\n            result1=max(result1,dfs(work[i],visited,adj,-1,price)-price[work[i]]);\\n        }\\n    return result1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int root;\\n    vector<unordered_map<int,long long>>m;\\n    long long dfs(int source,vector<bool>&visited,vector<vector<int>>&adj,int prev,vector<int>&price){\\n        if(adj[source].size()==1 and source!=root){\\n            return m[source][prev] = price[source];\\n        }\\n        if(m[source].count(prev)){\\n            return m[source][prev];\\n        }\\n        long long sum=0;\\n        visited[source]=true; \\n        for(int i=0;i<adj[source].size();i++){\\n            if(adj[source][i]!=prev and visited[adj[source][i]]==false){\\n                long long value=dfs(adj[source][i],visited,adj,source,price);\\n                sum=max(sum,value+price[source]);\\n            }\\n        }\\n    return m[source][prev]=sum;\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        m.resize(n);\\n        vector<vector<int>>adj(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>work;\\n        for(int i=0;i<adj.size();i++){\\n            if(adj[i].size()==1){\\n                work.push_back(i);\\n            }\\n        }\\n        long long result1=0;\\n        for(int i=0;i<work.size();i++){\\n            vector<bool>visited(n+1,false);\\n            root=work[i];\\n            result1=max(result1,dfs(work[i],visited,adj,-1,price)-price[work[i]]);\\n        }\\n    return result1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053795,
                "title": "python-dfs-memorization-from-every-leaf-nodes",
                "content": "# Intuition\\nI think the longer the path is, the greather the path sum is.\\nfind all the leaf nodes and use DFS to calculate path sum.\\n\\nsince lots of path sum will be calculated multiple times, we can cache it to reduce time complexity\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\neach node only calculate one time and it\\'ll be cached\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        graph = defaultdict(list)\\n        indegree = [0] * n\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            indegree[u] += 1\\n            indegree[v] += 1\\n\\n        leaves = [node for node, deg in enumerate(indegree) if deg == 1]\\n\\n        \\n        cache = {}\\n        def dfs(node, prev):\\n            if (node, prev) in cache:\\n                return cache[(node, prev)]\\n\\n            pathsum = 0\\n            for nei in graph[node]:\\n                if nei == prev: continue\\n                pathsum = max(pathsum, dfs(nei, node))\\n\\n            cache[(node, prev)] = pathsum + price[node]\\n            return cache[(node, prev)]\\n        \\n        res = 0\\n        for node in leaves:\\n            res = max(res, dfs(node, node) - price[node])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        graph = defaultdict(list)\\n        indegree = [0] * n\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            indegree[u] += 1\\n            indegree[v] += 1\\n\\n        leaves = [node for node, deg in enumerate(indegree) if deg == 1]\\n\\n        \\n        cache = {}\\n        def dfs(node, prev):\\n            if (node, prev) in cache:\\n                return cache[(node, prev)]\\n\\n            pathsum = 0\\n            for nei in graph[node]:\\n                if nei == prev: continue\\n                pathsum = max(pathsum, dfs(nei, node))\\n\\n            cache[(node, prev)] = pathsum + price[node]\\n            return cache[(node, prev)]\\n        \\n        res = 0\\n        for node in leaves:\\n            res = max(res, dfs(node, node) - price[node])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053739,
                "title": "python-dfs-dp-solution-a-tree-is-a-simple-graph-don-t-overthink",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitially I thought this problem might have similarities with the tree diameter question. But I was wrong, and this question is actually simpler\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key point is that we have a tree, not a complicated graph. There are no cycles and price sum difference passing through parent node to child node can be reused. A clear example is shown in Example 1, in which we calculated max price sum difference for any path that passes through node 1 to node 3, the dfs from node 0 and node 2 both uses the result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(E)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Notes\\n- Added new testcase trashed the DP method. As explained in the forum, we can use rerooting to solve the problem in linear time, no matter the topological structure of the graph. This reminds me of a really similar question:\\n- [834. Sum of Distances in Tree](https://leetcode.com/problems/sum-of-distances-in-tree/description/)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    # We can dfs from all nodes. Since the object is a tree (acyclic undirected graph), we note that if we look at an edge from parent i to child j\\n    # The maximum cost is from the path that traverses from j, which never goes back to i\\n    # Like in example 1, max path starting from 0 and 2 gives the same cost (1 -> 3 -> 4). \\n    # So if we record the maximum price sum for a path going through node 1 to node 3, it can be reused for searches from both node 0 and node 2\\n    \\n    @lru_cache(None)\\n    def dfs(self, parent, child):\\n        result = 0\\n        for nxt in self.graph[child]:\\n            if nxt != parent:\\n                result = max(result, self.dfs(child, nxt))\\n        result += self.price[child]\\n        return result\\n  \\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        cost = 0\\n        self.graph = [set() for i in range(n)]\\n        self.price = price\\n\\n        for a, b in edges:\\n            self.graph[a].add(b)\\n            self.graph[b].add(a)\\n        \\n        for i in range(n):\\n            for nxt in self.graph[i]:\\n                cost = max(cost, self.dfs(i, nxt))\\n        \\n        return cost\\n\\nclass Solution:\\n    # We use rerooting to solve the problem.\\n    # Firstly, we DFS from a random node, (choose 0 for the problem)\\n    # In the process, we record the subtree sum excluding the current point\\n    # Next, we dfs a second time, this time we compare the maximum cost path from its children vs its parent\\n    # If the considered child is the one giving maximum path cost, we provide the max between the second largest sibling and parent for dfs downstream\\n    # Otherwise we provide the largest sibling and parent\\n    \\n    def dfs(self, node, parent):\\n        m = 0\\n        for nxt in self.graph[node]:\\n            if nxt == parent:\\n                continue\\n            else:\\n                m = max(m, self.dfs(nxt, node))\\n        self.subtreeSum[node] = m + self.price[node]\\n        return m + self.price[node]\\n    \\n    def dfs2(self, node, parent, parentContribution):\\n        maxChild = -1\\n        largestChildContribution = 0\\n        secondChildContribution = 0\\n        for nxt in self.graph[node]:\\n            if nxt == parent:\\n                continue\\n            elif self.subtreeSum[nxt] > largestChildContribution:\\n                secondChildContribution = largestChildContribution\\n                largestChildContribution = self.subtreeSum[nxt]\\n                maxChild = nxt\\n            elif self.subtreeSum[nxt] > secondChildContribution:\\n                secondChildContribution = self.subtreeSum[nxt]\\n        \\n        self.result = max(self.result, largestChildContribution, parentContribution)\\n        for nxt in self.graph[node]:\\n            if nxt == parent:\\n                continue\\n            elif nxt == maxChild:\\n                self.dfs2(nxt, node, self.price[node] + max(parentContribution, secondChildContribution))\\n            else:\\n                self.dfs2(nxt, node, self.price[node] + max(parentContribution, largestChildContribution))\\n\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        self.graph = [set() for i in range(n)]\\n        for a, b in edges:\\n            self.graph[a].add(b)\\n            self.graph[b].add(a)\\n\\n        self.subtreeSum = [0]*n\\n        self.price = price\\n        self.result = 0\\n        rootSubTreeSum = self.dfs(0, -1)\\n        self.dfs2(0,-1,0)\\n        return self.result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # We can dfs from all nodes. Since the object is a tree (acyclic undirected graph), we note that if we look at an edge from parent i to child j\\n    # The maximum cost is from the path that traverses from j, which never goes back to i\\n    # Like in example 1, max path starting from 0 and 2 gives the same cost (1 -> 3 -> 4). \\n    # So if we record the maximum price sum for a path going through node 1 to node 3, it can be reused for searches from both node 0 and node 2\\n    \\n    @lru_cache(None)\\n    def dfs(self, parent, child):\\n        result = 0\\n        for nxt in self.graph[child]:\\n            if nxt != parent:\\n                result = max(result, self.dfs(child, nxt))\\n        result += self.price[child]\\n        return result\\n  \\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        cost = 0\\n        self.graph = [set() for i in range(n)]\\n        self.price = price\\n\\n        for a, b in edges:\\n            self.graph[a].add(b)\\n            self.graph[b].add(a)\\n        \\n        for i in range(n):\\n            for nxt in self.graph[i]:\\n                cost = max(cost, self.dfs(i, nxt))\\n        \\n        return cost\\n\\nclass Solution:\\n    # We use rerooting to solve the problem.\\n    # Firstly, we DFS from a random node, (choose 0 for the problem)\\n    # In the process, we record the subtree sum excluding the current point\\n    # Next, we dfs a second time, this time we compare the maximum cost path from its children vs its parent\\n    # If the considered child is the one giving maximum path cost, we provide the max between the second largest sibling and parent for dfs downstream\\n    # Otherwise we provide the largest sibling and parent\\n    \\n    def dfs(self, node, parent):\\n        m = 0\\n        for nxt in self.graph[node]:\\n            if nxt == parent:\\n                continue\\n            else:\\n                m = max(m, self.dfs(nxt, node))\\n        self.subtreeSum[node] = m + self.price[node]\\n        return m + self.price[node]\\n    \\n    def dfs2(self, node, parent, parentContribution):\\n        maxChild = -1\\n        largestChildContribution = 0\\n        secondChildContribution = 0\\n        for nxt in self.graph[node]:\\n            if nxt == parent:\\n                continue\\n            elif self.subtreeSum[nxt] > largestChildContribution:\\n                secondChildContribution = largestChildContribution\\n                largestChildContribution = self.subtreeSum[nxt]\\n                maxChild = nxt\\n            elif self.subtreeSum[nxt] > secondChildContribution:\\n                secondChildContribution = self.subtreeSum[nxt]\\n        \\n        self.result = max(self.result, largestChildContribution, parentContribution)\\n        for nxt in self.graph[node]:\\n            if nxt == parent:\\n                continue\\n            elif nxt == maxChild:\\n                self.dfs2(nxt, node, self.price[node] + max(parentContribution, secondChildContribution))\\n            else:\\n                self.dfs2(nxt, node, self.price[node] + max(parentContribution, largestChildContribution))\\n\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        self.graph = [set() for i in range(n)]\\n        for a, b in edges:\\n            self.graph[a].add(b)\\n            self.graph[b].add(a)\\n\\n        self.subtreeSum = [0]*n\\n        self.price = price\\n        self.result = 0\\n        rootSubTreeSum = self.dfs(0, -1)\\n        self.dfs2(0,-1,0)\\n        return self.result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053541,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n    #define vi(x) vector<x>\\n    typedef pair<ll, ll> pi;\\npublic:\\n    ll n, ans;\\n    vi(vi(ll))g;\\n    pi dfs(const vi(int)&p, ll nd, ll pre){\\n        ll ansMps=p[nd], ansActual=0;\\n\\t\\t// mps -> Maximum Path Sum || actual -> sum of a proper path (end node subtracted)\\n        for(const ll&child:g[nd]){\\n            if(child==pre){\\n                continue;\\n            }\\n            const auto&[mps, actual]=dfs(p, child, nd);\\n            ans=max({ans, ansMps+actual, ansActual+mps});\\n            ansMps=max(ansMps, p[nd]+mps);\\n            ansActual=max(ansActual, p[nd]+actual);\\n        }\\n        return {ansMps, ansActual};\\n    }\\n    long long maxOutput(int N, vector<vector<int>>& edges, vector<int>& price) {\\n        n=N, ans=0;\\n        g.resize(n);\\n        for(const auto&edge:edges){\\n            g[edge[0]].pb(edge[1]), g[edge[1]].pb(edge[0]);\\n        }\\n        dfs(price, 0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n    #define vi(x) vector<x>\\n    typedef pair<ll, ll> pi;\\npublic:\\n    ll n, ans;\\n    vi(vi(ll))g;\\n    pi dfs(const vi(int)&p, ll nd, ll pre){\\n        ll ansMps=p[nd], ansActual=0;\\n\\t\\t// mps -> Maximum Path Sum || actual -> sum of a proper path (end node subtracted)\\n        for(const ll&child:g[nd]){\\n            if(child==pre){\\n                continue;\\n            }\\n            const auto&[mps, actual]=dfs(p, child, nd);\\n            ans=max({ans, ansMps+actual, ansActual+mps});\\n            ansMps=max(ansMps, p[nd]+mps);\\n            ansActual=max(ansActual, p[nd]+actual);\\n        }\\n        return {ansMps, ansActual};\\n    }\\n    long long maxOutput(int N, vector<vector<int>>& edges, vector<int>& price) {\\n        n=N, ans=0;\\n        g.resize(n);\\n        for(const auto&edge:edges){\\n            g[edge[0]].pb(edge[1]), g[edge[1]].pb(edge[0]);\\n        }\\n        dfs(price, 0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053350,
                "title": "fastest-2-dfs-approach-with-dp",
                "content": "# Intuition dp on treedp\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach apply 2 dfs \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> pr;\\n     vector<vector<int>> g;\\n    vector<vector<vector<ll>>> d;\\n    vector<ll> ans;\\n    ll dfs(int i,int p){\\n        vector<vector<ll>> vp={{pr[i],-1},{pr[i],0}};\\n        for(int j:g[i])if(j!=p){\\n            ll s=dfs(j,i);\\n            vector<ll> pa={s+pr[i],j};\\n            if(pa>=vp[0]){ vp[1]=vp[0]; vp[0]=pa;  }\\n            else if(pa>vp[1]){ vp[1]=pa;}\\n        }\\n    d[i]=vp;\\n    return vp[0][0];\\n    }\\n    void dfs2(int i,int p,ll ps){\\n         ans[i]=max(ps+pr[i],d[i][0][0]);\\n          for(int j:g[i])if(j!=p){\\n              ll sm=ps+pr[i];\\n              if(j!=d[i][0][1])sm=max(sm,d[i][0][0]);\\n              else sm=max(sm,d[i][1][0]);\\n            dfs2(j,i,sm);\\n            \\n        }\\n        \\n    }\\n    long long maxOutput(int n, vector<vector<int>>& e, vector<int>& p) {\\n        pr=p;\\n        g.clear();\\n      \\n         g.resize(n+1);\\n     d.clear();\\n      \\n         d.resize(n+1);\\n         ans.clear();\\n      \\n         ans.resize(n+1);\\n         \\n        for(auto &i:e){ g[i[0]].push_back(i[1]); g[i[1]].push_back(i[0]);  }\\n        dfs(0,-1);\\n        dfs2(0,-1,0);\\n        ll ans1=0;\\n        for(int i=0;i<n;i++){ans1=max(ans[i]-(ll)p[i],ans1); cout<<ans[i]<<\" \"; }\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<int> pr;\\n     vector<vector<int>> g;\\n    vector<vector<vector<ll>>> d;\\n    vector<ll> ans;\\n    ll dfs(int i,int p){\\n        vector<vector<ll>> vp={{pr[i],-1},{pr[i],0}};\\n        for(int j:g[i])if(j!=p){\\n            ll s=dfs(j,i);\\n            vector<ll> pa={s+pr[i],j};\\n            if(pa>=vp[0]){ vp[1]=vp[0]; vp[0]=pa;  }\\n            else if(pa>vp[1]){ vp[1]=pa;}\\n        }\\n    d[i]=vp;\\n    return vp[0][0];\\n    }\\n    void dfs2(int i,int p,ll ps){\\n         ans[i]=max(ps+pr[i],d[i][0][0]);\\n          for(int j:g[i])if(j!=p){\\n              ll sm=ps+pr[i];\\n              if(j!=d[i][0][1])sm=max(sm,d[i][0][0]);\\n              else sm=max(sm,d[i][1][0]);\\n            dfs2(j,i,sm);\\n            \\n        }\\n        \\n    }\\n    long long maxOutput(int n, vector<vector<int>>& e, vector<int>& p) {\\n        pr=p;\\n        g.clear();\\n      \\n         g.resize(n+1);\\n     d.clear();\\n      \\n         d.resize(n+1);\\n         ans.clear();\\n      \\n         ans.resize(n+1);\\n         \\n        for(auto &i:e){ g[i[0]].push_back(i[1]); g[i[1]].push_back(i[0]);  }\\n        dfs(0,-1);\\n        dfs2(0,-1,0);\\n        ll ans1=0;\\n        for(int i=0;i<n;i++){ans1=max(ans[i]-(ll)p[i],ans1); cout<<ans[i]<<\" \"; }\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3053295,
                "title": "python3-concise-verbose-approaches-130-mb-600-ms-difference",
                "content": "concise approach, but less efficient (takes ~350 MB, 3300 ms):\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        graph = {i: [] for i in range(n)}\\n        for source, destination in edges:\\n            graph[source].append(destination)\\n            graph[destination].append(source)\\n        @functools.cache\\n        def dfs(current, source, price=price) -> int:\\n            if not graph[current]: return price[current] # handle test case 51\\n            return price[current] + max(\\n                dfs(neighbor, current) if neighbor != source else 0\\n                for neighbor in graph[current]\\n        )\\n        return max(\\n\\t\\t    dfs(node, -1) - price[node]\\n\\t\\t    for node in range(n)\\n\\t\\t)\\n\\n```\\n\\nverbose approach, but more efficient (takes ~ 220 MB, ~2600 ms):\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        graph = {i: [] for i in range(n)}\\n        for source, destination in edges:\\n            graph[source].append(destination)\\n            graph[destination].append(source)\\n        @functools.cache\\n        def dfs(current, source, price=price) -> int:\\n            neighbors, current_price = graph[current], price[current]\\n            largest = path_cost = current_price\\n            for neighbor in neighbors:\\n                if neighbor != source:\\n                    path_cost = dfs(neighbor, current)\\n                    largest   = max(largest, path_cost + current_price)\\n            return largest\\n        largest_difference = 0\\n        for node in range(n):\\n            largest_path_cost  = dfs(node, -1)\\n            root_value         = price[node]\\n            difference         = largest_path_cost - root_value\\n            largest_difference = max(largest_difference, difference)\\n        return largest_difference\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        graph = {i: [] for i in range(n)}\\n        for source, destination in edges:\\n            graph[source].append(destination)\\n            graph[destination].append(source)\\n        @functools.cache\\n        def dfs(current, source, price=price) -> int:\\n            if not graph[current]: return price[current] # handle test case 51\\n            return price[current] + max(\\n                dfs(neighbor, current) if neighbor != source else 0\\n                for neighbor in graph[current]\\n        )\\n        return max(\\n\\t\\t    dfs(node, -1) - price[node]\\n\\t\\t    for node in range(n)\\n\\t\\t)\\n\\n```\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        graph = {i: [] for i in range(n)}\\n        for source, destination in edges:\\n            graph[source].append(destination)\\n            graph[destination].append(source)\\n        @functools.cache\\n        def dfs(current, source, price=price) -> int:\\n            neighbors, current_price = graph[current], price[current]\\n            largest = path_cost = current_price\\n            for neighbor in neighbors:\\n                if neighbor != source:\\n                    path_cost = dfs(neighbor, current)\\n                    largest   = max(largest, path_cost + current_price)\\n            return largest\\n        largest_difference = 0\\n        for node in range(n):\\n            largest_path_cost  = dfs(node, -1)\\n            root_value         = price[node]\\n            difference         = largest_path_cost - root_value\\n            largest_difference = max(largest_difference, difference)\\n        return largest_difference\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053232,
                "title": "c-computation-along-dfs-easy-to-understand",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIf we try naive approach to dfs the tree from node r, for every node in the tree as a root.\\nThe time complexity will be O(n^2).\\n\\nFor time complexity of O(n), we will try to store some information while doing dfs.\\n\\nWe will store the max sum path below node v (including v) which includes edge u-v (u is the parent).\\nWe will use this information to calculate maximum path sum for other nodes, without having to do dfs again and again.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dfs(int node,int par,vector<int> &price,map<int,ll> adj[]){\\n        int curr=price[node];\\n        ll m=0;\\n        for(auto it:adj[node]){\\n            if(it.first!=par){\\n                // ll temp=0;\\n                if(it.second==0){\\n                    it.second=dfs(it.first,node,price,adj);\\n                    adj[node][it.first]=it.second;\\n                    // it.second=temp;\\n                }\\n                m=max(m,it.second);\\n            }\\n        }\\n        return m+curr;\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        map<int,ll> adj[n];\\n        for(auto it:edges){\\n            adj[it[0]][it[1]]=0;\\n            adj[it[1]][it[0]]=0;\\n        }\\n        ll ans=0;\\n        for(int i=0;i<n;i++){\\n            ll temp=dfs(i,n,price,adj);\\n            ans=max(ans,temp-price[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph",
                    "Ordered Map"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll dfs(int node,int par,vector<int> &price,map<int,ll> adj[]){\\n        int curr=price[node];\\n        ll m=0;\\n        for(auto it:adj[node]){\\n            if(it.first!=par){\\n                // ll temp=0;\\n                if(it.second==0){\\n                    it.second=dfs(it.first,node,price,adj);\\n                    adj[node][it.first]=it.second;\\n                    // it.second=temp;\\n                }\\n                m=max(m,it.second);\\n            }\\n        }\\n        return m+curr;\\n    }\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        map<int,ll> adj[n];\\n        for(auto it:edges){\\n            adj[it[0]][it[1]]=0;\\n            adj[it[1]][it[0]]=0;\\n        }\\n        ll ans=0;\\n        for(int i=0;i<n;i++){\\n            ll temp=dfs(i,n,price,adj);\\n            ans=max(ans,temp-price[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053217,
                "title": "simple-dfs-code-dp-re-rooting-memo",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList());\\n        }\\n        for (int[] e : edges) {\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n        }\\n        long res = 0;\\n       Map<String,Long> dp = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            res = Math.max(res, dfs(i,-1,adj,dp,price) - price[i]);\\n        }\\n        return res;\\n    }\\n    \\n    private long dfs(int curr,int prev,List<List<Integer>> adj,Map<String,Long> dp,int[] prices) {\\n        long max = 0;\\n        for(int child:adj.get(curr)){\\n            String x = curr+\"-\"+child;\\n            if(child!=prev){\\n                if(dp.get(x)==null){\\n                    dp.put(x,dfs(child,curr,adj,dp,prices));\\n                }\\n                max=Math.max(max,dp.get(x));\\n            }\\n        }\\n        return max+prices[curr];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maxOutput(int n, int[][] edges, int[] price) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList());\\n        }\\n        for (int[] e : edges) {\\n            adj.get(e[0]).add(e[1]);\\n            adj.get(e[1]).add(e[0]);\\n        }\\n        long res = 0;\\n       Map<String,Long> dp = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            res = Math.max(res, dfs(i,-1,adj,dp,price) - price[i]);\\n        }\\n        return res;\\n    }\\n    \\n    private long dfs(int curr,int prev,List<List<Integer>> adj,Map<String,Long> dp,int[] prices) {\\n        long max = 0;\\n        for(int child:adj.get(curr)){\\n            String x = curr+\"-\"+child;\\n            if(child!=prev){\\n                if(dp.get(x)==null){\\n                    dp.put(x,dfs(child,curr,adj,dp,prices));\\n                }\\n                max=Math.max(max,dp.get(x));\\n            }\\n        }\\n        return max+prices[curr];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053086,
                "title": "python-dfs-solution",
                "content": "```\\ndef maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n\\tself.ans, d = 0, defaultdict(list)\\n\\tfor u, v in edges:\\n\\t\\td[u].append(v)\\n\\t\\td[v].append(u)\\n\\n\\tdef dfs(i, fi):\\n\\t\\tmx1, mx2 = price[i], 0\\n\\t\\tfor x in d[i]:\\n\\t\\t\\tif x != fi:\\n\\t\\t\\t\\ts1, s2 = dfs(x, i)\\n\\t\\t\\t\\tself.ans = max(self.ans, mx1 + s2, mx2 + s1)\\n\\t\\t\\t\\tmx1 = max(mx1, s1 + price[i])\\n\\t\\t\\t\\tmx2 = max(mx2, s2 + price[i])\\n\\t\\treturn mx1, mx2\\n\\n\\tdfs(0, -1)\\n\\treturn self.ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n\\tself.ans, d = 0, defaultdict(list)\\n\\tfor u, v in edges:\\n\\t\\td[u].append(v)\\n\\t\\td[v].append(u)\\n\\n\\tdef dfs(i, fi):\\n\\t\\tmx1, mx2 = price[i], 0\\n\\t\\tfor x in d[i]:\\n\\t\\t\\tif x != fi:\\n\\t\\t\\t\\ts1, s2 = dfs(x, i)\\n\\t\\t\\t\\tself.ans = max(self.ans, mx1 + s2, mx2 + s1)\\n\\t\\t\\t\\tmx1 = max(mx1, s1 + price[i])\\n\\t\\t\\t\\tmx2 = max(mx2, s2 + price[i])\\n\\t\\treturn mx1, mx2\\n\\n\\tdfs(0, -1)\\n\\treturn self.ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3053072,
                "title": "re-rooting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is a solution by re-rooting.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, when the root is 0, find the maximum value (=mx[v]) of price_sum from each vertex v to its descendants.\\nUse mx[v] to find the price_sum of v toward the parent(=X) in dfs. Let par be the parent node of v. X is price[par]+mx[k], where k is a child of par and not v.\\nThis can be calculated by finding the maximum value of mx[i] from the left and right of v when the children of par are arranged from the left.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<int>G[100005];\\n    ll mx[100005],p[100005];\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        for(auto x:edges){\\n            G[x[0]].push_back(x[1]);\\n            G[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<n;i++)p[i]=price[i];\\n        a(0,-1);\\n        b(0,-1,0);\\n        \\n        ll ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,mx[i]-p[i]);\\n        }\\n        return ans;\\n    }\\n    \\n    void a(int v,int pre){\\n        ll x=0;\\n        for(int u:G[v]){\\n            if(u==pre){continue;}\\n            a(u,v);\\n            x=max(x,mx[u]);\\n        }\\n        mx[v]=x+p[v];\\n    }\\n    void b(int v,int pre,int x){\\n        int m=G[v].size();\\n        mx[v]=max(mx[v],x+p[v]);\\n        vector<int>lx(m),rx(m);\\n        ll xx=0;\\n        for(int i=0;i<m;i++){\\n            int u=G[v][i];\\n            if(u==pre){continue;}\\n            lx[i]=xx;\\n            xx=max(xx,mx[u]);\\n        }\\n        \\n        xx=0;\\n        for(int i=m-1;i>=0;i--){\\n            int u=G[v][i];\\n            if(u==pre){continue;}\\n            rx[i]=xx;\\n            xx=max(xx,mx[u]);\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            int u=G[v][i];\\n            if(u==pre){continue;}\\n            int X=max({x,lx[i],rx[i]})+p[v];\\n            b(u,v,X);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<int>G[100005];\\n    ll mx[100005],p[100005];\\n    long long maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\\n        for(auto x:edges){\\n            G[x[0]].push_back(x[1]);\\n            G[x[1]].push_back(x[0]);\\n        }\\n        for(int i=0;i<n;i++)p[i]=price[i];\\n        a(0,-1);\\n        b(0,-1,0);\\n        \\n        ll ans=0;\\n        for(int i=0;i<n;i++){\\n            ans=max(ans,mx[i]-p[i]);\\n        }\\n        return ans;\\n    }\\n    \\n    void a(int v,int pre){\\n        ll x=0;\\n        for(int u:G[v]){\\n            if(u==pre){continue;}\\n            a(u,v);\\n            x=max(x,mx[u]);\\n        }\\n        mx[v]=x+p[v];\\n    }\\n    void b(int v,int pre,int x){\\n        int m=G[v].size();\\n        mx[v]=max(mx[v],x+p[v]);\\n        vector<int>lx(m),rx(m);\\n        ll xx=0;\\n        for(int i=0;i<m;i++){\\n            int u=G[v][i];\\n            if(u==pre){continue;}\\n            lx[i]=xx;\\n            xx=max(xx,mx[u]);\\n        }\\n        \\n        xx=0;\\n        for(int i=m-1;i>=0;i--){\\n            int u=G[v][i];\\n            if(u==pre){continue;}\\n            rx[i]=xx;\\n            xx=max(xx,mx[u]);\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            int u=G[v][i];\\n            if(u==pre){continue;}\\n            int X=max({x,lx[i],rx[i]})+p[v];\\n            b(u,v,X);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1758557,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1772359,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1758891,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1758851,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1758776,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1758644,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 2049468,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1804954,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1787066,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1765146,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1758557,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1772359,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1758891,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1758851,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1758776,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1758644,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 2049468,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1804954,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1787066,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1765146,
                "content": [
                    {
                        "username": "Magsut",
                        "content": "At the beginning, I thought I just need to find diameter of the tree, but after I fully understood this problem, then I realized that this problem is hard :). \nWe have to find all diameters and choose one of them that gives us maximum possible cost."
                    },
                    {
                        "username": "tejasX",
                        "content": "Then? Is it also based on rerooting or some other algo?"
                    },
                    {
                        "username": "sherwinpoh3",
                        "content": "Very strange. Even with a O(n) solution, I still see a TLE. My solution is basically memoized DFS. each iteration identified by (current node, parent) = max price sum of subtree rooted at current node with parent. To prevent N^2 blowup for star-like trees along with calculating (current node, parent) I update all (current node, parent) where parent = each of node\\'s neighbours as well.\\n\\nTest cases need to improve"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "No, there is a test case with 50000, in which with 0 node, all others nodes connected in star manner. In this case memo is not giving benefit leading to O(N^2) soln."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "first i cried looking at the question, later read it."
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "Can anyone explain,\\nThe question states- tree can be rooted at any node root of your choice\\nSo, in the 1st testcase- n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5] given in the problem statement, can\\'t we select the root as node 3.\\nThen the path 3->1->0 and 3->4 combined ( i,e the path 0->1->3->4 ) gives the path sum of 33. The minimum path sum will be value of node 3. So, answer should be 33-6 =27.\\nWhat am I missing here?"
                    },
                    {
                        "username": "pru_cuder",
                        "content": "path should start from root node you have selected, in your case path is starting from 0 or 4"
                    },
                    {
                        "username": "pulukurijagadeesh472",
                        "content": "if you taking 3 as root we have to take max of the both bro\\n"
                    },
                    {
                        "username": "murotyangiboyev",
                        "content": "This problem rerooting algorithm)"
                    },
                    {
                        "username": "error_202",
                        "content": "can you share code and bit elaborate."
                    },
                    {
                        "username": "amritanshusharma25",
                        "content": " n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\\nShouldn\\'t ans will be 25 if we take 1 as root\\npath 0->1->3->4\\nWhat I am missing in this"
                    },
                    {
                        "username": "naveen_reddy",
                        "content": "[@amritanshusharma25](/amritanshusharma25) your min path also should start at root only.. since we have all positive values which mean we have to substract the root value only.\n"
                    },
                    {
                        "username": "PrateekTewary",
                        "content": "If you take 1 as the root then you can only choose one of the following paths as per your query:\\n```1->0``` or ```1->3->4``` . \\nIf you are considering a path from a node then you can\\'t go two different directions from that node."
                    },
                    {
                        "username": "czjnbb",
                        "content": "The result path will be between 2 leaves. Root at any non-leave node and DFS."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "this is a similar problem to practice:\n834. Sum of Distances in Tree \nit has much better resources to learn the concept of rerooting or dp on trees"
                    },
                    {
                        "username": "vishalgoel",
                        "content": "Anyone solved the Star problem test case ? used DFS with memo."
                    },
                    {
                        "username": "Partharora_07",
                        "content": "TLE\\n```\\nclass Solution {\\npublic:\\n#define ll long long\\n\\nmap<pair<int, int>, ll int> mp;\\n\\nint dfs(vector<vector<int>> &graph, int node, int parent, vector<int> &prices)\\n{\\n    if(mp.count({parent,node})) return mp[{parent,node}];\\n    ll ans = INT_MIN;\\n    for (auto &child : graph[node])\\n    {\\n        if (child != parent)\\n        {\\n            ll res = dfs(graph, child, node, prices);\\n            ans = max(ans, res);\\n        }\\n    }\\n    if (ans == INT_MIN)\\n        ans = 0;\\n    ans += prices[node];\\n    mp[{parent, node}] = ans;\\n    return ans;\\n}\\n\\nlong long maxOutput(int n, vector<vector<int>> &edges, vector<int> &price)\\n{\\n    vector<vector<int>> graph(n);\\n    for (int i = 0; i < edges.size(); i++)\\n    {\\n        graph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n    }\\n\\n    ll ans = 0;\\n\\n    for (int i = 0; i < n; i++)\\n    {\\n        ll res = dfs(graph, i, -1, price);\\n        ans = max(ans, res - price[i]);\\n    }\\n\\n    return ans;\\n}\\n};"
                    }
                ]
            }
        ]
    }
]