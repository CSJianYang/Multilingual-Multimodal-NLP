[
    {
        "title": "Maximize Sum Of Array After K Negations",
        "question_content": "Given an integer array nums and an integer k, modify the array in the following way:\n\n\tchoose an index i and replace nums[i] with -nums[i].\n\nYou should apply this process exactly k times. You may choose the same index i multiple times.\nReturn the largest possible sum of the array after modifying it in this way.\n&nbsp;\nExample 1:\n\nInput: nums = [4,2,3], k = 1\nOutput: 5\nExplanation: Choose index 1 and nums becomes [4,-2,3].\n\nExample 2:\n\nInput: nums = [3,-1,0,2], k = 3\nOutput: 6\nExplanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2].\n\nExample 3:\n\nInput: nums = [2,-3,-1,5,-4], k = 2\nOutput: 13\nExplanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4].\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t-100 <= nums[i] <= 100\n\t1 <= k <= 104",
        "solutions": [
            {
                "id": 3540706,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\nlong long getSum(vector<int> negate, vector<int>positive)\\n{\\n    long long sum =0;\\n                for(int i=0;i<negate.size();i++)\\n            {\\n                sum+=negate[i];\\n            }\\n        for(int i=0;i<positive.size();i++)\\n            {\\n                sum+=positive[i];\\n            }\\n            return sum;\\n}\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n   vector<int>negate;\\n   vector<int>positive;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]>=0)\\n        {\\n            positive.push_back(nums[i]);\\n        }\\n        else{\\n            negate.push_back(nums[i]);\\n        }\\n    }\\n    if(negate.size()>k)\\n    {\\n        sort(negate.begin(), negate.end());\\n        for(int i=0;i<k;i++)\\n        {\\n            negate[i] = abs(negate[i]);\\n        }\\n        return getSum(negate, positive);\\n    } else {\\n        for(int i=0;i<negate.size();i++)\\n        {\\n            negate[i] = abs(negate[i]);\\n        }\\n        int remainingcount = k-negate.size();\\n        if(remainingcount%2==0)\\n        {\\n            return getSum(negate, positive);\\n        } else {\\n        int mini = INT_MAX;\\n            for(int i=0;i<negate.size();i++)\\n            {\\n                mini = min(mini, negate[i]);\\n            }\\n        for(int i=0;i<positive.size();i++)\\n            {\\n                mini = min(mini, positive[i]);\\n            }\\ncout<<mini<<endl;\\ncout<<getSum(negate, positive)<<endl;\\n            return (getSum(negate, positive) - 2*mini);\\n        }\\n    }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums = sorted(nums)\\n        for i in range(len(nums)):\\n            if nums[i] < 0 and k > 0:\\n                nums[i] = -nums[i]\\n                k -= 1\\n        nums = sorted(nums)\\n        if k > 0 and k % 2 != 0: \\n            nums[0] = -nums[0]\\n        return sum(nums)\\n```\\n\\n```Java []\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int[] numbers = new int[201];\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n: nums) {\\n            maxAbs = Math.max(maxAbs, Math.abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\nlong long getSum(vector<int> negate, vector<int>positive)\\n{\\n    long long sum =0;\\n                for(int i=0;i<negate.size();i++)\\n            {\\n                sum+=negate[i];\\n            }\\n        for(int i=0;i<positive.size();i++)\\n            {\\n                sum+=positive[i];\\n            }\\n            return sum;\\n}\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n   vector<int>negate;\\n   vector<int>positive;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]>=0)\\n        {\\n            positive.push_back(nums[i]);\\n        }\\n        else{\\n            negate.push_back(nums[i]);\\n        }\\n    }\\n    if(negate.size()>k)\\n    {\\n        sort(negate.begin(), negate.end());\\n        for(int i=0;i<k;i++)\\n        {\\n            negate[i] = abs(negate[i]);\\n        }\\n        return getSum(negate, positive);\\n    } else {\\n        for(int i=0;i<negate.size();i++)\\n        {\\n            negate[i] = abs(negate[i]);\\n        }\\n        int remainingcount = k-negate.size();\\n        if(remainingcount%2==0)\\n        {\\n            return getSum(negate, positive);\\n        } else {\\n        int mini = INT_MAX;\\n            for(int i=0;i<negate.size();i++)\\n            {\\n                mini = min(mini, negate[i]);\\n            }\\n        for(int i=0;i<positive.size();i++)\\n            {\\n                mini = min(mini, positive[i]);\\n            }\\ncout<<mini<<endl;\\ncout<<getSum(negate, positive)<<endl;\\n            return (getSum(negate, positive) - 2*mini);\\n        }\\n    }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums = sorted(nums)\\n        for i in range(len(nums)):\\n            if nums[i] < 0 and k > 0:\\n                nums[i] = -nums[i]\\n                k -= 1\\n        nums = sorted(nums)\\n        if k > 0 and k % 2 != 0: \\n            nums[0] = -nums[0]\\n        return sum(nums)\\n```\n```Java []\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int[] numbers = new int[201];\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n: nums) {\\n            maxAbs = Math.max(maxAbs, Math.abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 252254,
                "title": "java-c-python-sort",
                "content": "## **Explanation**\\n@codePower:\\nIn case someone needs an explanation:\\n1- sort the numbers in ascending order\\n2- flip all the negative numbers, as long as k > 0\\n3- find the sum of the new array (with flipped numbers if any) and keep track of the minimum number\\n4- Now for the return statement\\n\\n`res` is the total sum of the new array\\n`K % 2` check if the remaining `K` is odd.\\n\\nBecause if it\\'s even, it will have no effect\\n(we will flip a number and then get it back to the original)\\n\\nIf it\\'s odd,\\nflip the minimum number and remove twice its value from the result\\n(twice because we already added it as positive in our sum operation)\\n<br>\\n\\n## **Complexity**\\nTime `O(NlogN)` for sorting.\\nSpace `O(1)` extra space, in-place sort\\n\\nTime can be easily improved to `O(N)`,\\nby quick selecting the `k`th negative.\\n<br>\\n\\n**Java**\\n```java\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        for (int i = 0; K > 0 && i < A.length && A[i] < 0; ++i, --K)\\n            A[i] = -A[i];\\n        int res = 0, min = Integer.MAX_VALUE;\\n        for (int a : A) {\\n            res += a;\\n            min = Math.min(min, a);\\n        }\\n        return res - (K % 2) * min * 2;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        for (int i = 0; K > 0 && i < A.size() && A[i] < 0; ++i, --K)\\n            A[i] = -A[i];\\n        return accumulate(A.begin(), A.end(), 0) - (K%2) * *min_element(A.begin(), A.end()) * 2;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def largestSumAfterKNegations(self, A, K):\\n        A.sort()\\n        i = 0\\n        while i < len(A) and i < K and A[i] < 0:\\n            A[i] = -A[i]\\n            i += 1\\n        return sum(A) - (K - i) % 2 * min(A) * 2\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        for (int i = 0; K > 0 && i < A.length && A[i] < 0; ++i, --K)\\n            A[i] = -A[i];\\n        int res = 0, min = Integer.MAX_VALUE;\\n        for (int a : A) {\\n            res += a;\\n            min = Math.min(min, a);\\n        }\\n        return res - (K % 2) * min * 2;\\n    }\\n```\n```cpp\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        for (int i = 0; K > 0 && i < A.size() && A[i] < 0; ++i, --K)\\n            A[i] = -A[i];\\n        return accumulate(A.begin(), A.end(), 0) - (K%2) * *min_element(A.begin(), A.end()) * 2;\\n    }\\n```\n```py\\n    def largestSumAfterKNegations(self, A, K):\\n        A.sort()\\n        i = 0\\n        while i < len(A) and i < K and A[i] < 0:\\n            A[i] = -A[i]\\n            i += 1\\n        return sum(A) - (K - i) % 2 * min(A) * 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 252228,
                "title": "a-very-simple-java-solution",
                "content": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        \\n        for(int x: A) pq.add(x);\\n        while( K--  > 0) pq.add(-pq.poll());\\n  \\n        int sum  = 0;\\n        for(int i = 0; i < A.length; i++){\\n            sum += pq.poll();\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        \\n        for(int x: A) pq.add(x);\\n        while( K--  > 0) pq.add(-pq.poll());\\n  \\n        int sum  = 0;\\n        for(int i = 0; i < A.length; i++){\\n            sum += pq.poll();\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252849,
                "title": "c-java-o-n-o-1",
                "content": "Since the ```A[i]``` is limited to [-100, 100], we can use an fixed-size array ```cnt``` to count occurrences. Bucket sort (or, more precise, countint sort), in other words :)\\n\\nThen, as we process numbers ```[-100, 100]```, we flip the negative numbers by moving count from ```cnt[i + 100]``` to ```cnt[-i + 100]```. This guaranties that, if ```K > 0``` after processing all negative numbers, the first positive number will have the smallest absolute value.\\n\\nTherefore, when we encounter the first positive number, and our ```K % 2 == 1```, we negate one occurrence of that number.\\n```\\nint largestSumAfterKNegations(vector<int>& A, int K) {\\n  int cnt[201] = {}, j = -100;\\n  for (auto i : A) ++cnt[i + 100];\\n  for (auto i = -100; i <= 100 && K; ++i) {\\n    if (cnt[i + 100]) {\\n      auto k = i < 0 ? min(K, cnt[i + 100]) : K % 2;\\n      cnt[-i + 100] += k;\\n      cnt[i + 100] -= k;\\n      K = i < 0 ? K - k : 0;\\n    }\\n  }\\n  return accumulate(begin(cnt), end(cnt), 0, [&](int s, int cnt) { return s + cnt * j++; });\\n}\\n```\\nJava version:\\n```\\npublic int largestSumAfterKNegations(int[] A, int K) {\\n  int[] cnt = new int[201];\\n  int res = 0;\\n  for (int i : A) ++cnt[i + 100];\\n  for (int i = -100; i <= 100 && K > 0; ++i) {\\n    if (cnt[i + 100] > 0) {\\n      int k = i < 0 ? Math.min(K, cnt[i + 100]) : K % 2;\\n      cnt[-i + 100] += k;\\n      cnt[i + 100] -= k;\\n      K = i < 0 ? K - k : 0;\\n    }\\n  }\\n  for (int i = -100; i <= 100; ++i) res += i * cnt[i + 100];\\n  return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```A[i]```\n```cnt```\n```[-100, 100]```\n```cnt[i + 100]```\n```cnt[-i + 100]```\n```K > 0```\n```K % 2 == 1```\n```\\nint largestSumAfterKNegations(vector<int>& A, int K) {\\n  int cnt[201] = {}, j = -100;\\n  for (auto i : A) ++cnt[i + 100];\\n  for (auto i = -100; i <= 100 && K; ++i) {\\n    if (cnt[i + 100]) {\\n      auto k = i < 0 ? min(K, cnt[i + 100]) : K % 2;\\n      cnt[-i + 100] += k;\\n      cnt[i + 100] -= k;\\n      K = i < 0 ? K - k : 0;\\n    }\\n  }\\n  return accumulate(begin(cnt), end(cnt), 0, [&](int s, int cnt) { return s + cnt * j++; });\\n}\\n```\n```\\npublic int largestSumAfterKNegations(int[] A, int K) {\\n  int[] cnt = new int[201];\\n  int res = 0;\\n  for (int i : A) ++cnt[i + 100];\\n  for (int i = -100; i <= 100 && K > 0; ++i) {\\n    if (cnt[i + 100] > 0) {\\n      int k = i < 0 ? Math.min(K, cnt[i + 100]) : K % 2;\\n      cnt[-i + 100] += k;\\n      cnt[i + 100] -= k;\\n      K = i < 0 ? K - k : 0;\\n    }\\n  }\\n  for (int i = -100; i <= 100; ++i) res += i * cnt[i + 100];\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252596,
                "title": "python-straightforward-self-explanatory-concise",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K):\\n            heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K):\\n            heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696962,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int, vector<int>, greater<int>> pq(A.begin(), A.end());\\n        while (K--) {\\n            int x = pq.top();\\n            pq.pop();\\n\\n            pq.push(-1 * x);\\n        }\\n        int res = 0;\\n        while (!pq.empty()) {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int, vector<int>, greater<int>> pq(A.begin(), A.end());\\n        while (K--) {\\n            int x = pq.top();\\n            pq.pop();\\n\\n            pq.push(-1 * x);\\n        }\\n        int res = 0;\\n        while (!pq.empty()) {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628859,
                "title": "min-heap-o-n-k-log-n-time-o-1-space",
                "content": "Hi LeetCoders \\uD83D\\uDC4B\\nHere is my simple and clean solution to this problem with use of min-heap.\\n\\n**Code:**\\n```\\nfrom heapq import heapify, heapreplace\\n\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        while k and nums[0] < 0:\\n            heapreplace(nums, -nums[0])\\n            k -= 1\\n        if k % 2:\\n            heapreplace(nums, -nums[0])\\n        return sum(nums)\\n```\\n\\n**Idea explanation:**\\n* negate negative numbers as many as you can\\n* if ```k % 2 == 1``` negate the smallest element in the heap\\n\\n**Notes:**\\nAvoid using ```heappush + heappop``` because it takes ```O(2 * log (n))``` time, use ```heapreplace``` instead and pay just ```O(log (n))```. Isn\\'t that a great deal?\\n\\n**Algorithm complexity:**\\n*n = len(nums)*\\n*Time complexity: O(n + k * log (n))*\\n*Space complexity: O(1)*\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I hope you learned something and wish you an enjoyable time on LeetCode. \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heapify, heapreplace\\n\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        while k and nums[0] < 0:\\n            heapreplace(nums, -nums[0])\\n            k -= 1\\n        if k % 2:\\n            heapreplace(nums, -nums[0])\\n        return sum(nums)\\n```\n```k % 2 == 1```\n```heappush + heappop```\n```O(2 * log (n))```\n```heapreplace```\n```O(log (n))```",
                "codeTag": "Java"
            },
            {
                "id": 301380,
                "title": "java-simple-greedy-solution-explained-beats-100",
                "content": "The intution is - \\n1. Sort the array.\\n2. Check if first element of the array is positive.\\n\\ti. If K is even, don\\'t modify anything.\\n\\tii. Else, modify the lowest element.\\n3. Else, mark all -ve elements positive for a given K.\\n4. If K after operations is not even then, mark the lowest element -ve.\\n5. Sum up and return.\\n\\n\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n        if (A[0] >= 0 && K % 2 != 0) {\\n            A[0] = - A[0];\\n        } else if (A[0] < 0 ) { //&& K % 2 == 0) {\\n            int change = 0;\\n            while (K > 0 && A[change] < 0 && change < A.length) {\\n                A[change] = - A[change++];\\n                K--;\\n            }\\n            if (K % 2 != 0) {\\n                int index = A[change] < A[change - 1] ? change : change - 1;\\n                A[index] = - A[index];\\n            }\\n        }\\n        for (int val : A) sum += val;\\n        return sum;\\n    }\\n}\\n```\\n\\nIf you liked the post please do upvote and any suggestions are most welcome.\\nPS: I see a few people posting solution with PriorityQueue, which is awesome, however, the question says \\'modify the array\\'.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n        if (A[0] >= 0 && K % 2 != 0) {\\n            A[0] = - A[0];\\n        } else if (A[0] < 0 ) { //&& K % 2 == 0) {\\n            int change = 0;\\n            while (K > 0 && A[change] < 0 && change < A.length) {\\n                A[change] = - A[change++];\\n                K--;\\n            }\\n            if (K % 2 != 0) {\\n                int index = A[change] < A[change - 1] ? change : change - 1;\\n                A[index] = - A[index];\\n            }\\n        }\\n        for (int val : A) sum += val;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895079,
                "title": "c-solution-100-faster-memory-efficient",
                "content": "A pure greedy question.\\nAlgorithm\\n1. Sort the vector\\n2. Run a loop until looping variable reaches to size of vector or K.\\n\\t* If the vector element is found greater than or equal to 0, terminate the loop\\n\\t* If the vector element is found less than 0 then negate its value.\\n3. Sort the value again \\n4. Check if looping variable is less than K then calculate its difference. \\n5. If the difference is not divisible by 2 then negate A[0].\\n\\n\\nNote:\\n1. Sorting of vector in step 3 is required to arrange back the numbers to ascending order as in previous loop the negative number was made positive too.\\n2. Step 5 is checked because we can negate a number as many times possible. So we will negate the smallest number only to get maximum result.(Also twice negation of a number results to same number. So the difference is calculated and checked for its divisibility by 2.)\\n3. Sorting and step 5 are showing the greedy nature of the problem.\\n\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        int i, t=0, n=A.size();\\n        \\n        for(i=0; i < min(n, K); i++) {\\n            if(A[t]>=0) break;\\n            \\n            else {\\n                A[t]=-A[t];\\n                t++;\\n            }\\n        }\\n        \\n        sort(A.begin(), A.end());\\n        if(i<K) {\\n            if((K-i)%2) {\\n                A[0]=-A[0];\\n            }\\n        }\\n        \\n        int sum=0;\\n        for(i=0; i<A.size(); i++) {\\n            sum += A[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(), A.end());\\n        int i, t=0, n=A.size();\\n        \\n        for(i=0; i < min(n, K); i++) {\\n            if(A[t]>=0) break;\\n            \\n            else {\\n                A[t]=-A[t];\\n                t++;\\n            }\\n        }\\n        \\n        sort(A.begin(), A.end());\\n        if(i<K) {\\n            if((K-i)%2) {\\n                A[0]=-A[0];\\n            }\\n        }\\n        \\n        int sum=0;\\n        for(i=0; i<A.size(); i++) {\\n            sum += A[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278596,
                "title": "heapq-python",
                "content": "```\\nimport heapq\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        heapq.heapify(A)\\n        while K:\\n            heapq.heapreplace(A, -A[0])\\n            K -= 1\\n        return sum(A)\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        heapq.heapify(A)\\n        while K:\\n            heapq.heapreplace(A, -A[0])\\n            K -= 1\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688733,
                "title": "python-3-min-heap-few-lines-easy-to-read-solution",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, min_heap: List[int], K: int) -> int:\\n        heapify(min_heap)\\n        while K > 0:\\n            heappush(min_heap , - (heappop(min_heap)))            \\n            K -= 1\\n        return sum(min_heap)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, min_heap: List[int], K: int) -> int:\\n        heapify(min_heap)\\n        while K > 0:\\n            heappush(min_heap , - (heappop(min_heap)))            \\n            K -= 1\\n        return sum(min_heap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157105,
                "title": "super-simple-c-o-nlog-n-solution-w-explanation",
                "content": "# Intuition\\nSorting is your best friend here. That way we can make as many negative values as possible become positive (maximizing the final sum).\\n\\nThe other key detail to notice is that if every element is already positive, changing the sign of any element twice reduces `k` by $$2$$ without reducing the final sum.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Sort the input\\n2. Loop through as many negatives elements as possible, `k` permitting\\n3. Lastly check if `k` is odd. If it is, then sort the array again and negate the first (a.k.a. smallest) element\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0;\\n        while(i<nums.size() && nums[i]<0 && k>0)\\n        {\\n            nums[i] *= -1;\\n            i++;\\n            k--;\\n        }\\n        if(k%2 == 1)\\n        {\\n            sort(nums.begin(),nums.end());\\n            nums[0] *= -1;\\n        }\\n        int sum = 0;\\n        for(int n : nums)\\n        {\\n            sum += n;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0;\\n        while(i<nums.size() && nums[i]<0 && k>0)\\n        {\\n            nums[i] *= -1;\\n            i++;\\n            k--;\\n        }\\n        if(k%2 == 1)\\n        {\\n            sort(nums.begin(),nums.end());\\n            nums[0] *= -1;\\n        }\\n        int sum = 0;\\n        for(int n : nums)\\n        {\\n            sum += n;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808062,
                "title": "easy-to-understand-apprach-without-cases",
                "content": "Basic idea is to sort the array based on their absolute value and then start taking ones having greater absolute value. If we encouter a negative element, we can use one negation to negate it and add it\\'s absolute value, otherwise we have no other option, we have to take it\\'s original value. In the last, we will check if we have some K left i.e. we have to negate more elements. Most optimal choice here is to negate the minimum absolute value element. If K is even, it will not have any effect otherwise we have to subtract it\\'s *absolute value* twice from our sum as we have taken it once before also.\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        int n = A.size();\\n        auto cmp = [](int a, int b) {\\n            return abs(a) > abs(b);\\n        };\\n        \\n        sort(A.begin(), A.end(), cmp);\\n        int sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(A[i] < 0 && K > 0) {\\n                sum += -A[i];\\n                K--;\\n            }\\n            else {\\n                sum += A[i];\\n            }\\n        }\\n        \\n        if(K&1) {\\n            sum -= 2*(abs(A[n-1]));\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        int n = A.size();\\n        auto cmp = [](int a, int b) {\\n            return abs(a) > abs(b);\\n        };\\n        \\n        sort(A.begin(), A.end(), cmp);\\n        int sum = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(A[i] < 0 && K > 0) {\\n                sum += -A[i];\\n                K--;\\n            }\\n            else {\\n                sum += A[i];\\n            }\\n        }\\n        \\n        if(K&1) {\\n            sum -= 2*(abs(A[n-1]));\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254652,
                "title": "beat-94-56-with-explain-o-nlgn",
                "content": "Sort the array first.\\n\\nThe negation rules are quite simple\\uFF1A\\n\\n1. execute negation for K times\\uFF0Cso use a for loop\\n2. after negation, if the next number (if has) is smaller, the next number is next to negation (if still in for loop). Here we use a greedy strategy. If the next number is non-negative and smaller than the current one, negation it will result in less sum loss(for example current is 4, and next is 1), if the next number is negative and smaller than the current one, negation it will result in more sum (for example current is 4 and next is -3). \\n\\nAfter that , compute the sum.\\n\\n    class Solution {\\n        public int largestSumAfterKNegations(int[] A, int K) {\\n            Arrays.sort(A);\\n            int idx = 0;\\n            for (int i = 0; i < K; ++i) {\\n                A[idx] = -A[idx];\\n                if (idx + 1 < A.length) {\\n                    if (A[idx + 1] < A[idx]) idx += 1;\\n                }\\n            }\\n            int sum = 0;\\n            for (int i = 0; i < A.length; ++i) sum += A[i];\\n            return sum;\\n        }\\n    }\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n        public int largestSumAfterKNegations(int[] A, int K) {\\n            Arrays.sort(A);\\n            int idx = 0;\\n            for (int i = 0; i < K; ++i) {\\n                A[idx] = -A[idx];\\n                if (idx + 1 < A.length) {\\n                    if (A[idx + 1] < A[idx]) idx += 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 384970,
                "title": "python-5-lines-very-easy-solution",
                "content": "```python\\nclass Solution:\\n    def largestSumAfterKNegations(self, A, K):\\n\\t\\tfor _ in range(K):\\n            target = min(A)\\n            A.remove(target)\\n            A.append(-target)\\n        return sum(A)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def largestSumAfterKNegations(self, A, K):\\n\\t\\tfor _ in range(K):\\n            target = min(A)\\n            A.remove(target)\\n            A.append(-target)\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776207,
                "title": "simple-java-solution-stream-api",
                "content": "```\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n\\n        var minHeap = new PriorityQueue<Integer>(Arrays.stream(nums).boxed().toList());\\n        \\n        IntStream.range(0, k).forEach(i -> minHeap.add(-minHeap.remove()));\\n        \\n        return minHeap.stream().reduce(0, (intermediateResult, num) -> intermediateResult + num);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n\\n        var minHeap = new PriorityQueue<Integer>(Arrays.stream(nums).boxed().toList());\\n        \\n        IntStream.range(0, k).forEach(i -> minHeap.add(-minHeap.remove()));\\n        \\n        return minHeap.stream().reduce(0, (intermediateResult, num) -> intermediateResult + num);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120243,
                "title": "weeb-explains-python-solution",
                "content": "![image](https://assets.leetcode.com/users/images/deac20d6-f25b-4f9f-9a91-4f79bcb66724_1620122556.4046779.png)\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n\\t\\t\\tA.sort()\\n\\t\\t\\ti = 0\\n\\t\\t\\twhile i < len(A) and K>0:\\n\\t\\t\\t\\tif A[i] < 0: # negative value\\n\\t\\t\\t\\t\\tA[i] = A[i] * -1 # update the list, change negative to positive\\n\\t\\t\\t\\t\\tK-=1\\n\\n\\t\\t\\t\\telif A[i] > 0: # positive value\\n\\t\\t\\t\\t\\tif K % 2 == 0: # let K==2(must be even value), this means -1*-1==1 so it has no effect on sum\\n\\t\\t\\t\\t\\t\\treturn sum(A)\\n\\t\\t\\t\\t\\telse: return sum(A) - 2 * min(A) # let A==[1,2,3],K=1, so equation is 6-2(1)==4, same as -1+2+3=4 after taking the minimum in the list to give the largest possible sum required in the question\\n\\n\\t\\t\\t\\telse: return sum(A) # if A[i]==0,just sum cuz 0 is neutral: 1-0==1 or 1+0==1 thus no change just sum\\n\\n\\t\\t\\t\\ti+=1\\n\\n\\t\\t\\tif K > len(A): # that means we have changed all values to positive\\n\\t\\t\\t\\tA.sort() # cuz now its the opposite let A = [-4,-2,-3], K = 8, now flipping all negatives to positives, we have a new minimum which is 2\\n\\t\\t\\t\\tif K % 2 == 0: # Here onwards is basically the same thing from before\\n\\t\\t\\t\\t\\treturn sum(A)\\n\\t\\t\\t\\telse: return sum(A) - 2 * min(A)\\n\\n\\t\\t\\treturn sum(A)\\n\\nAight, time for some anime recommendations\\n# try watching ***Uzaki-chan Wants to Hang Out!***\\n# Genres: Romantic comedy, Slice of life\\n# Episodes: 12\\n\\nOverall, this anime is quite fun to watch. Although i have to warn you, this anime does contain some ecchi(perverted) elements in it, but its not extreme.\\n\\nNow go take a break and watch some anime.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/deac20d6-f25b-4f9f-9a91-4f79bcb66724_1620122556.4046779.png)\\n\\n\\t\\n\\tclass Solution:\\n\\t\\tdef largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n\\t\\t\\tA.sort()\\n\\t\\t\\ti = 0\\n\\t\\t\\twhile i < len(A) and K>0:\\n\\t\\t\\t\\tif A[i] < 0: # negative value\\n\\t\\t\\t\\t\\tA[i] = A[i] * -1 # update the list, change negative to positive\\n\\t\\t\\t\\t\\tK-=1\\n\\n\\t\\t\\t\\telif A[i] > 0: # positive value\\n\\t\\t\\t\\t\\tif K % 2 == 0: # let K==2(must be even value), this means -1*-1==1 so it has no effect on sum\\n\\t\\t\\t\\t\\t\\treturn sum(A)\\n\\t\\t\\t\\t\\telse: return sum(A) - 2 * min(A) # let A==[1,2,3],K=1, so equation is 6-2(1)==4, same as -1+2+3=4 after taking the minimum in the list to give the largest possible sum required in the question\\n\\n\\t\\t\\t\\telse: return sum(A) # if A[i]==0,just sum cuz 0 is neutral: 1-0==1 or 1+0==1 thus no change just sum\\n\\n\\t\\t\\t\\ti+=1\\n\\n\\t\\t\\tif K > len(A): # that means we have changed all values to positive\\n\\t\\t\\t\\tA.sort() # cuz now its the opposite let A = [-4,-2,-3], K = 8, now flipping all negatives to positives, we have a new minimum which is 2\\n\\t\\t\\t\\tif K % 2 == 0: # Here onwards is basically the same thing from before\\n\\t\\t\\t\\t\\treturn sum(A)\\n\\t\\t\\t\\telse: return sum(A) - 2 * min(A)\\n\\n\\t\\t\\treturn sum(A)\\n\\nAight, time for some anime recommendations\\n# try watching ***Uzaki-chan Wants to Hang Out!***\\n# Genres: Romantic comedy, Slice of life\\n# Episodes: 12\\n\\nOverall, this anime is quite fun to watch. Although i have to warn you, this anime does contain some ecchi(perverted) elements in it, but its not extreme.\\n\\nNow go take a break and watch some anime.\\n",
                "codeTag": "Java"
            },
            {
                "id": 891225,
                "title": "java-easy-to-understand",
                "content": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n\\n        for(int i = 0; i < A.length && K > 0 && A[i] < 0; i++){\\n            A[i] = -A[i];\\n            K--;\\n        }\\n\\n        Arrays.sort(A);\\n        for(int a : A) sum+= a;\\n        if(K > 0 && K % 2 == 1){\\n            sum -= A[0] * 2;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n\\n        for(int i = 0; i < A.length && K > 0 && A[i] < 0; i++){\\n            A[i] = -A[i];\\n            K--;\\n        }\\n\\n        Arrays.sort(A);\\n        for(int a : A) sum+= a;\\n        if(K > 0 && K % 2 == 1){\\n            sum -= A[0] * 2;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252410,
                "title": "o-n-k-logn-using-min-heap",
                "content": "1.build a min-heap (cost O(n));\\n2.negate the root node\\'s val then heapify the heap\\nrepeat step 2  K times\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void heapify(int arr[], int n, int i) { \\n        int smallest = i;  \\n        int l = 2*i + 1; // left = 2*i + 1 \\n        int r = 2*i + 2; // right = 2*i + 2 \\n        if (l < n && arr[l] < arr[smallest]) smallest = l; \\n        if (r < n && arr[r] < arr[smallest]) smallest = r; \\n        if (smallest != i) { \\n            swap(arr[i], arr[smallest]); \\n            heapify(arr, n, smallest); \\n        } \\n    } \\n  \\n    void helper(int arr[], int n, int K) { \\n        for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);   \\n        for(int i = 0; i < K; ++i) {\\n            arr[0] = -arr[0];\\n            heapify(arr, n, 0);\\n        }\\n    } \\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        if(A.empty()) return -1;\\n        int sum = 0;\\n        helper(A.data(), A.size(), K);\\n        for(auto &e:A) sum += e;\\n        return sum;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void heapify(int arr[], int n, int i) { \\n        int smallest = i;  \\n        int l = 2*i + 1; // left = 2*i + 1 \\n        int r = 2*i + 2; // right = 2*i + 2 \\n        if (l < n && arr[l] < arr[smallest]) smallest = l; \\n        if (r < n && arr[r] < arr[smallest]) smallest = r; \\n        if (smallest != i) { \\n            swap(arr[i], arr[smallest]); \\n            heapify(arr, n, smallest); \\n        } \\n    } \\n  \\n    void helper(int arr[], int n, int K) { \\n        for (int i = n / 2 - 1; i >= 0; i--) heapify(arr, n, i);   \\n        for(int i = 0; i < K; ++i) {\\n            arr[0] = -arr[0];\\n            heapify(arr, n, 0);\\n        }\\n    } \\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        if(A.empty()) return -1;\\n        int sum = 0;\\n        helper(A.data(), A.size(), K);\\n        for(auto &e:A) sum += e;\\n        return sum;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637579,
                "title": "python-3-min-heap-for-negative-values-with-comments-beats-80",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        # if k <= n(count of negative numbers )=> need make highest negative values positive (here using heap for this)\\n        # if k > n(count of negative numbers) and k-n is odd => need make all negative numbers positive and minVal make negative\\n        heap, res, minVal = [], 0, 101\\n\\n        for n in nums:\\n            if n > 0: res += n\\n            elif n < 0: heappush(heap, n)\\n            minVal = min(minVal, abs(n))\\n\\n        # make highest negative values positive while k opertions available\\n        while heap and k > 0:\\n            res += -heappop(heap) #add negative value\\n            k -= 1\\n        # if still exists negative value, just add them to final sum\\n        if heap:\\n            res += sum(heap)\\n        # if k > 0 and it\\'s odd need make minVal negative (if 0 exists it will be smalles value)\\n        if k % 2:\\n            res = res - 2 * minVal\\n        \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        # if k <= n(count of negative numbers )=> need make highest negative values positive (here using heap for this)\\n        # if k > n(count of negative numbers) and k-n is odd => need make all negative numbers positive and minVal make negative\\n        heap, res, minVal = [], 0, 101\\n\\n        for n in nums:\\n            if n > 0: res += n\\n            elif n < 0: heappush(heap, n)\\n            minVal = min(minVal, abs(n))\\n\\n        # make highest negative values positive while k opertions available\\n        while heap and k > 0:\\n            res += -heappop(heap) #add negative value\\n            k -= 1\\n        # if still exists negative value, just add them to final sum\\n        if heap:\\n            res += sum(heap)\\n        # if k > 0 and it\\'s odd need make minVal negative (if 0 exists it will be smalles value)\\n        if k % 2:\\n            res = res - 2 * minVal\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738913,
                "title": "java-ms-solution",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        int count=0;\\n        int prev=0;\\n        for(int i:nums)\\n        {\\n            if(i<0)\\n            {\\n                if(k>0)\\n                {\\n                    count+=Math.abs(i);\\n                    k--;\\n                    prev = i;\\n                }\\n                else\\n                {\\n                    count+=i;\\n                }\\n            }\\n            else if(i==0)\\n            {\\n                k=0;\\n            }\\n            else\\n            {\\n                if(k%2==0)\\n                {\\n                    count+=i;\\n                    k=0;\\n                }\\n                else\\n                {\\n                    if(prev==0)\\n                    {\\n                        count+=(-1*i);\\n                        k=0;\\n                    }\\n                    else\\n                    {\\n                        if(prev>i || Math.abs(prev)>i)\\n                        {\\n                            count+=(-1*i);\\n                        }\\n                        else\\n                        {\\n                            count+=prev;\\n                            count+=(prev + i);\\n                        }\\n                        k=0;\\n                    }\\n                }\\n            }\\n        }\\n        if(k%2!=0)\\n        {\\n            count+=(prev + prev);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        int count=0;\\n        int prev=0;\\n        for(int i:nums)\\n        {\\n            if(i<0)\\n            {\\n                if(k>0)\\n                {\\n                    count+=Math.abs(i);\\n                    k--;\\n                    prev = i;\\n                }\\n                else\\n                {\\n                    count+=i;\\n                }\\n            }\\n            else if(i==0)\\n            {\\n                k=0;\\n            }\\n            else\\n            {\\n                if(k%2==0)\\n                {\\n                    count+=i;\\n                    k=0;\\n                }\\n                else\\n                {\\n                    if(prev==0)\\n                    {\\n                        count+=(-1*i);\\n                        k=0;\\n                    }\\n                    else\\n                    {\\n                        if(prev>i || Math.abs(prev)>i)\\n                        {\\n                            count+=(-1*i);\\n                        }\\n                        else\\n                        {\\n                            count+=prev;\\n                            count+=(prev + i);\\n                        }\\n                        k=0;\\n                    }\\n                }\\n            }\\n        }\\n        if(k%2!=0)\\n        {\\n            count+=(prev + prev);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241273,
                "title": "100-faster-sol-c",
                "content": "The time complexity of this approach is O(n+n log n).\\nhope you will find it helpful.\\n```\\nint largestSumAfterKNegations(vector<int>& nums, int k) {\\n       sort(nums.begin(),nums.end());\\n        int i=0,sum=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]<0&& k>0)\\n            {\\n                nums[i]*=(-1);\\n                k--;\\n            }\\n            else if(nums[i]>=0)\\n                break;\\n            i++;\\n        }\\n        if(k%2!=0)\\n        {\\n            sort(nums.begin(),nums.end());\\n                nums[0]*=(-1);           \\n        }               \\n        for(auto a:nums)\\n            sum+=a;\\n        return sum; \\n    }\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint largestSumAfterKNegations(vector<int>& nums, int k) {\\n       sort(nums.begin(),nums.end());\\n        int i=0,sum=0;\\n        while(i<nums.size())\\n        {\\n            if(nums[i]<0&& k>0)\\n            {\\n                nums[i]*=(-1);\\n                k--;\\n            }\\n            else if(nums[i]>=0)\\n                break;\\n            i++;\\n        }\\n        if(k%2!=0)\\n        {\\n            sort(nums.begin(),nums.end());\\n                nums[0]*=(-1);           \\n        }               \\n        for(auto a:nums)\\n            sum+=a;\\n        return sum; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1753580,
                "title": "c-easy-heap-solution",
                "content": "```\\nBefore discussing the problem, let me tell you something, it\\'s our coding nature \\nwhen we see to find max/min sum , element we think of sorting . But what if i tell \\nyou do sorting but in a better and optimized way, sort only those elements which \\nneed to be sorted.\\n\\nOk let\\'s talk about logic to the problem, we have to negate any index element \\nk times so array elements yields max sum. So it is clear we have to always \\nnegate smallest element, so we can use \" min Heap \" which will ensure you have \\nsmallest element always on top no matter how many insertion or deletion you make.\\n```\\n```\\nclass Solution {\\npublic:\\n    int find_sum(vector<int>&v, int k){\\n        priority_queue<int,vector<int>,greater<int>>q;       // Mean Heap\\n        for(int i=0; i<v.size(); i++)\\n            q.push(v[i]);\\n        while(k){                        // Negate k times ( min element will always be on top )\\n            int res = -q.top();\\n            q.pop();\\n            q.push(res);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n        return sum;\\n    }\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = find_sum(nums,k);\\n        return sum;\\n    }\\n};\\n```\\n```\\nLet me tell you a secret, if question is based on array and you feel there is a need of sorting always think of heap solution as a possibility.\\n```\\nIf you liked my solution please upvote to motivate me. Happy Coding :)\\n",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nBefore discussing the problem, let me tell you something, it\\'s our coding nature \\nwhen we see to find max/min sum , element we think of sorting . But what if i tell \\nyou do sorting but in a better and optimized way, sort only those elements which \\nneed to be sorted.\\n\\nOk let\\'s talk about logic to the problem, we have to negate any index element \\nk times so array elements yields max sum. So it is clear we have to always \\nnegate smallest element, so we can use \" min Heap \" which will ensure you have \\nsmallest element always on top no matter how many insertion or deletion you make.\\n```\n```\\nclass Solution {\\npublic:\\n    int find_sum(vector<int>&v, int k){\\n        priority_queue<int,vector<int>,greater<int>>q;       // Mean Heap\\n        for(int i=0; i<v.size(); i++)\\n            q.push(v[i]);\\n        while(k){                        // Negate k times ( min element will always be on top )\\n            int res = -q.top();\\n            q.pop();\\n            q.push(res);\\n            k--;\\n        }\\n        int sum = 0;\\n        while(!q.empty()){\\n            sum += q.top();\\n            q.pop();\\n        }\\n        return sum;\\n    }\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = find_sum(nums,k);\\n        return sum;\\n    }\\n};\\n```\n```\\nLet me tell you a secret, if question is based on array and you feel there is a need of sorting always think of heap solution as a possibility.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582378,
                "title": "c-only-for-beginners-simple-and-clean-solution",
                "content": "**Please Upvote If it helped You !!!\\nHappy Coding :)**\\n```\\nint largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        \\n        int sum=0;\\n        sort(nums.begin(),nums.end());\\n        while(k>0)\\n        {\\n            nums[0]= -1*nums[0];\\n            k--;\\n            sort(nums.begin(),nums.end());\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum= sum+nums[i];\\n        }\\n        return sum;\\n    }\\n```\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        \\n        int sum=0;\\n        sort(nums.begin(),nums.end());\\n        while(k>0)\\n        {\\n            nums[0]= -1*nums[0];\\n            k--;\\n            sort(nums.begin(),nums.end());\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum= sum+nums[i];\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1385477,
                "title": "python-logic",
                "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \\n        while k > 0:\\n            nums.sort()\\n            nums[0] = nums[0] * -1\\n            k = k -1\\n        return sum(nums)\\n            \\n## \\t\\t\\t``",
                "solutionTags": [],
                "code": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \\n        while k > 0:\\n            nums.sort()\\n            nums[0] = nums[0] * -1\\n            k = k -1\\n        return sum(nums)\\n            \\n## \\t\\t\\t``",
                "codeTag": "Java"
            },
            {
                "id": 1191474,
                "title": "javascript-concise",
                "content": "```\\nvar largestSumAfterKNegations = function(A, K) {\\n    while(K > 0 ){ \\n        let v = Math.min(...A)\\n        let i = A.indexOf(v)\\n        A[i] = - A[i]\\n        K--\\n    }\\n    \\n    return A.reduce((a,c) => a+c,0)\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestSumAfterKNegations = function(A, K) {\\n    while(K > 0 ){ \\n        let v = Math.min(...A)\\n        let i = A.indexOf(v)\\n        A[i] = - A[i]\\n        K--\\n    }\\n    \\n    return A.reduce((a,c) => a+c,0)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 518152,
                "title": "simple-java-solution",
                "content": "```\\npublic int largestSumAfterKNegations(int[] arr, int k) {\\n\\tArrays.sort(arr);\\n\\tint sum = 0, len = arr.length, minIndex = 0;\\n\\twhile (k > 0) {\\n\\t\\tarr[minIndex] *= -1;\\n\\t\\tk--;\\n\\t\\tif (minIndex + 1 < len && arr[minIndex] > arr[minIndex + 1]) minIndex++;\\n\\t}\\n\\tfor (int i : arr) sum += i;\\n\\treturn sum;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int largestSumAfterKNegations(int[] arr, int k) {\\n\\tArrays.sort(arr);\\n\\tint sum = 0, len = arr.length, minIndex = 0;\\n\\twhile (k > 0) {\\n\\t\\tarr[minIndex] *= -1;\\n\\t\\tk--;\\n\\t\\tif (minIndex + 1 < len && arr[minIndex] > arr[minIndex + 1]) minIndex++;\\n\\t}\\n\\tfor (int i : arr) sum += i;\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252520,
                "title": "java-solution-o-1-space-one-pass",
                "content": "Traverse the array, track the number of negative elements\\nIf number of negative elements is smaller than K, we can flip it to positive, otherwise, keep it as negative.\\nAfter the traversal, if we still have K - count flips to finish, it means we have flipped all negative elements, and have to touch a positive element. if K - count is even, flip any element is ok since it does not change anything. If K - count is odd, choose the smallest element which we have kept tracking in the traversal by minPositive.\\n\\n```java\\n        Arrays.sort(A);\\n        int count = 0, sum = 0, minPositive = Integer.MAX_VALUE;\\n        for (int num : A) {\\n            if (num < 0 && ++count <= K) {\\n                num = -num;\\n            }\\n            sum += num;\\n            minPositive = Math.min(minPositive, num);\\n        }\\n        if (count > K || (K - count) % 2 == 0) {\\n            return sum;\\n        } else {\\n            return sum - minPositive * 2;\\n        }\\n```",
                "solutionTags": [],
                "code": "```java\\n        Arrays.sort(A);\\n        int count = 0, sum = 0, minPositive = Integer.MAX_VALUE;\\n        for (int num : A) {\\n            if (num < 0 && ++count <= K) {\\n                num = -num;\\n            }\\n            sum += num;\\n            minPositive = Math.min(minPositive, num);\\n        }\\n        if (count > K || (K - count) % 2 == 0) {\\n            return sum;\\n        } else {\\n            return sum - minPositive * 2;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2478851,
                "title": "java-easy-priority-queue",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> q=new PriorityQueue<>();\\n        for(int n:nums){\\n            q.add(n);\\n        }\\n        while(k>0)\\n        {\\n            int val=q.poll();\\n            q.add(-val);\\n            k--;\\n        }\\n        int sum=0;\\n        while(!q.isEmpty())\\n        {\\n            sum+=q.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> q=new PriorityQueue<>();\\n        for(int n:nums){\\n            q.add(n);\\n        }\\n        while(k>0)\\n        {\\n            int val=q.poll();\\n            q.add(-val);\\n            k--;\\n        }\\n        int sum=0;\\n        while(!q.isEmpty())\\n        {\\n            sum+=q.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431212,
                "title": "3ms-t-c-java-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n        Arrays.sort(nums);\\n\\n        int sum = 0;\\n        int min = 100;\\n        int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right){\\n            min = Math.min(min, Math.abs(nums[left]));\\n            if (k == 0) {\\n                sum += nums[left];\\n                left++;\\n            }\\n            else if (nums[right] < Math.abs(nums[left])){\\n                sum += Math.abs(nums[left]);\\n                left++;\\n                k--;\\n            }\\n            else {\\n                sum += nums[right];\\n                right--;\\n            }\\n        }\\n\\n        return k % 2 == 0 ? sum : sum - 2 * min;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816680,
                "title": "fastest-3-liner-solution-with-inbuilt-functions",
                "content": "```\\nvar largestSumAfterKNegations = function(nums, k) {\\n    while(k>0){\\n        let i = nums.indexOf(Math.min(...nums)); //find the index of minimum item in array using inbuilt function\\n        nums[i]*=-1; //Toggle the minimum value to get the maximum sum\\n        k--;\\n    }\\n    return nums.reduce((acc, curr)=>acc+curr); //return the sum using reduce function\\n};\\n```\\n\\n**Please upvote if I could help**\\nOpen to Suggestions :)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestSumAfterKNegations = function(nums, k) {\\n    while(k>0){\\n        let i = nums.indexOf(Math.min(...nums)); //find the index of minimum item in array using inbuilt function\\n        nums[i]*=-1; //Toggle the minimum value to get the maximum sum\\n        k--;\\n    }\\n    return nums.reduce((acc, curr)=>acc+curr); //return the sum using reduce function\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1756738,
                "title": "java-simple-explained",
                "content": "**Idea:**\\n* To maximize the sum, negate the negatives and then the smallest number\\n* Negation of negation of n gives back n. \\n* This means if k is even, then we can exhaust it on the smallest int without changing it. So ignore even value k after loop  \\n* If k is odd, only then you need to actually negate the smallest int for maximum sum\\n>**T/S:** O(n lg n)/O(1), where n = size(nums) (ignored extra space of Arrays.sort)\\n```\\npublic int largestSumAfterKNegations(int[] nums, int k) {\\n\\tArrays.sort(nums);\\n\\tvar minIndex = 0;\\n\\t\\n\\tfor (var i = 0; i < nums.length && k > 0; i++) {\\n\\t\\tif (nums[i] < 0) {\\n\\t\\t\\tnums[i] *= -1;\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\tif (nums[minIndex] > nums[i])\\n\\t\\t\\tminIndex = i;\\n\\t}\\n\\n\\tif ((k & 1) == 1)\\n\\t\\tnums[minIndex] *= -1;\\n\\t\\t\\n\\treturn Arrays.stream(nums)\\n\\t\\t\\t\\t .sum();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int largestSumAfterKNegations(int[] nums, int k) {\\n\\tArrays.sort(nums);\\n\\tvar minIndex = 0;\\n\\t\\n\\tfor (var i = 0; i < nums.length && k > 0; i++) {\\n\\t\\tif (nums[i] < 0) {\\n\\t\\t\\tnums[i] *= -1;\\n\\t\\t\\tk--;\\n\\t\\t}\\n\\t\\tif (nums[minIndex] > nums[i])\\n\\t\\t\\tminIndex = i;\\n\\t}\\n\\n\\tif ((k & 1) == 1)\\n\\t\\tnums[minIndex] *= -1;\\n\\t\\t\\n\\treturn Arrays.stream(nums)\\n\\t\\t\\t\\t .sum();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1388659,
                "title": "c-greedy-using-priority-queue-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i:nums)\\n            pq.push(i);\\n        while(k--)\\n        {\\n            int x=pq.top(); pq.pop();\\n            pq.push(x * -1);\\n        }\\n        while(!pq.empty())\\n        {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i:nums)\\n            pq.push(i);\\n        while(k--)\\n        {\\n            int x=pq.top(); pq.pop();\\n            pq.push(x * -1);\\n        }\\n        while(!pq.empty())\\n        {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375639,
                "title": "1005-maximize-sum-of-array-after-k-negations",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        # sort nums according to each num\\'s absolute value in descending order\\n        nums = sorted(nums, key = abs, reverse = True)\\n        \\n        # we first negate the smallest negative num (it\\'s absolute value is the largest), so it adds most to the sum of nums\\n        for i in range(len(nums)):\\n            if k > 0 and nums[i] < 0:\\n                nums[i] *= -1\\n                k -= 1\\n        \\n        # after negating all negative numbers, if k is still not zero (we need to do more negation), we negate the smallest positive number (which is the last element in nums) k times. Only if k is odd it will be negated \\n        if k % 2 == 1:\\n            nums[-1] *= -1\\n        \\n        return sum(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        # sort nums according to each num\\'s absolute value in descending order\\n        nums = sorted(nums, key = abs, reverse = True)\\n        \\n        # we first negate the smallest negative num (it\\'s absolute value is the largest), so it adds most to the sum of nums\\n        for i in range(len(nums)):\\n            if k > 0 and nums[i] < 0:\\n                nums[i] *= -1\\n                k -= 1\\n        \\n        # after negating all negative numbers, if k is still not zero (we need to do more negation), we negate the smallest positive number (which is the last element in nums) k times. Only if k is odd it will be negated \\n        if k % 2 == 1:\\n            nums[-1] *= -1\\n        \\n        return sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1285244,
                "title": "java-solution-priority-queue-code-with-comments",
                "content": "```\\n// TC: O(nlogn)\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        \\n        // Create a priority queue and insert all array elements in the priority queue      TC: O(n)\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int num : nums)\\n            pq.add(num);\\n        // Do k negations by removing a minimum element k times         TC: O(log n)\\n        while(k--> 0) {\\n            int temp = pq.poll();   // Retrieve and remove min element\\n            \\n            temp *= -1;     // Modify the min element and add it back to priority queue\\n            pq.add(temp);\\n        }\\n        \\n        // Compute sum of all elements in priority queue\\n        int sum = 0;\\n        for(int num : pq)\\n            sum += num;\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// TC: O(nlogn)\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        \\n        // Create a priority queue and insert all array elements in the priority queue      TC: O(n)\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(int num : nums)\\n            pq.add(num);\\n        // Do k negations by removing a minimum element k times         TC: O(log n)\\n        while(k--> 0) {\\n            int temp = pq.poll();   // Retrieve and remove min element\\n            \\n            temp *= -1;     // Modify the min element and add it back to priority queue\\n            pq.add(temp);\\n        }\\n        \\n        // Compute sum of all elements in priority queue\\n        int sum = 0;\\n        for(int num : pq)\\n            sum += num;\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001349,
                "title": "java-straightforward-priority-queue",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int x : A) {\\n            pq.offer(x);\\n        }\\n        while (K > 0) {\\n            pq.offer(-pq.poll());\\n            K--;\\n        }\\n        return pq.stream().mapToInt(i -> i).sum();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for (int x : A) {\\n            pq.offer(x);\\n        }\\n        while (K > 0) {\\n            pq.offer(-pq.poll());\\n            K--;\\n        }\\n        return pq.stream().mapToInt(i -> i).sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875597,
                "title": "python-4-lines-heapq-o-n-klogn",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K): \\n            heapq.heapreplace(A, -A[0])\\n        return sum(A)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K): \\n            heapq.heapreplace(A, -A[0])\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515509,
                "title": "javascript-solution",
                "content": "```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(A, K) {\\n  A.sort((a, b) => a - b);\\n  for (let i = 0; i < A.length && K > 0 && A[i] < 0; i++, K--) A[i] = -A[i];\\n  if (K > 0 && K % 2 == 1) {\\n    const minI = A.reduce((min, cur, i) => (cur < A[min] ? i : min), 0);\\n    A[minI] = -A[minI];\\n  }\\n  return A.reduce((acc, cur) => acc + cur);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(A, K) {\\n  A.sort((a, b) => a - b);\\n  for (let i = 0; i < A.length && K > 0 && A[i] < 0; i++, K--) A[i] = -A[i];\\n  if (K > 0 && K % 2 == 1) {\\n    const minI = A.reduce((min, cur, i) => (cur < A[min] ? i : min), 0);\\n    A[minI] = -A[minI];\\n  }\\n  return A.reduce((acc, cur) => acc + cur);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350855,
                "title": "solution-in-python-3-beats-100",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n    \\tS, a = sum(A), sorted([i for i in A if i < 0])\\n    \\tL, b = len(a), min([i for i in A if i >= 0])\\n    \\tif L == 0: return S if K % 2 == 0 else S - 2*b\\n    \\tif K <= L or (K - L) % 2 == 0: return S - 2*sum(a[:min(K,L)])\\n    \\treturn S - 2*sum(a[:-1]) if -a[-1] < b else S - 2*sum(a) - 2*b\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n    \\tS, a = sum(A), sorted([i for i in A if i < 0])\\n    \\tL, b = len(a), min([i for i in A if i >= 0])\\n    \\tif L == 0: return S if K % 2 == 0 else S - 2*b\\n    \\tif K <= L or (K - L) % 2 == 0: return S - 2*sum(a[:min(K,L)])\\n    \\treturn S - 2*sum(a[:-1]) if -a[-1] < b else S - 2*sum(a) - 2*b\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 253429,
                "title": "java-solutions",
                "content": "**Solution 1: Linear Search Approach**\\n\\n- The idea is to replace the minimum element `A[minIndex]` in array by `-A[minIndex]` for current operation. In this way we can make `sum` of array maximum after `K` operations. \\n- One interesting case is, once minimum element becomes `0`, we don\\u2019t need to make any more changes.\\n- Here we use linear search to find minimum element. So the time complexity of the this solution is `O(K * n)`.\\n\\nTime complexity: `O(K * n)` - where `n` is the length of an input array.\\nSpace complexity: `O(1)`\\n\\n```\\nclass Solution\\n{\\n    public int largestSumAfterKNegations(int[] A, int K)\\n    {\\n        int sum = 0;\\n        \\n        while(K-- > 0)\\n        {\\n            int minIndex = findMinIndex(A);\\n\\t\\t\\t\\n\\t\\t\\tif(A[minIndex] == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n                A[minIndex] = -A[minIndex];\\n        }\\n        \\n        for(int n : A)\\n            sum += n;\\n        return sum;\\n    }\\n    \\n    private int findMinIndex(int[] A)\\n    {\\n        int minIndex = 0;\\n\\n        for(int i = 0; i < A.length; i++)\\n        {\\n            if(A[i] <= A[minIndex])\\n                minIndex = i;\\n        }\\n        return minIndex;\\n    }\\n}\\n```\\n\\n**Solution 2: Using minHeap**\\n\\n- Here an optimized solution is implemented that uses a `PriorityQueue` to find the minimum element quickly.\\n- The time complexity to insert `n` elements in to the `PriorityQueue` takes `O(n log n)` time in the general case. An `O(n)` algorithm exists for the special case where the input is already ordered, but this is not provided in `java.util.PriorityQueue` class. Also adding and removing `K` elements from the `minHeap` of size `n` takes `O(K log n)`, so the total complexity is `O(n log n + K log n) = (n + K) * log n`.\\n\\nTime complexity: `O(n log n + K log n) = (n + K) * log n` - where `n` is the length of an input array.\\nSpace complexity: `O(n)` - space required for the `minHeap`\\n\\n```\\nclass Solution\\n{\\n    public int largestSumAfterKNegations(int[] A, int K)\\n    {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        int sum = 0;\\n        \\n        for(int n : A)\\n            minHeap.add(n);\\n        \\n        while(K-- > 0 && minHeap.peek() != 0)\\n            minHeap.add(-minHeap.poll());\\n        \\n        while(!minHeap.isEmpty())\\n            sum += minHeap.poll();\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public int largestSumAfterKNegations(int[] A, int K)\\n    {\\n        int sum = 0;\\n        \\n        while(K-- > 0)\\n        {\\n            int minIndex = findMinIndex(A);\\n\\t\\t\\t\\n\\t\\t\\tif(A[minIndex] == 0)\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\telse\\n                A[minIndex] = -A[minIndex];\\n        }\\n        \\n        for(int n : A)\\n            sum += n;\\n        return sum;\\n    }\\n    \\n    private int findMinIndex(int[] A)\\n    {\\n        int minIndex = 0;\\n\\n        for(int i = 0; i < A.length; i++)\\n        {\\n            if(A[i] <= A[minIndex])\\n                minIndex = i;\\n        }\\n        return minIndex;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public int largestSumAfterKNegations(int[] A, int K)\\n    {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        int sum = 0;\\n        \\n        for(int n : A)\\n            minHeap.add(n);\\n        \\n        while(K-- > 0 && minHeap.peek() != 0)\\n            minHeap.add(-minHeap.poll());\\n        \\n        while(!minHeap.isEmpty())\\n            sum += minHeap.poll();\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545228,
                "title": "explanation-of-the-whole-idea",
                "content": "## Explanation\\n```\\nAssume nums = [8,-1,8,-3,2,-2], k = 2\\n\\nTo get the LARGEST SUM we will make positive -3 and -2 as they are the SMALLEST NEGATIVE\\nNUMBERS. This finding process would be easier if we sort first:\\n\\n               -3,-2,-1,2,8,8 \\n\\nIf k were 5, first we would turn all the negative numbers to positive numbers, right?\\nCause the Q asked us LARGEST SUM!\\n\\n               3,2,1,2,8,8 and now k = 5 - 3 = 2\\n\\nAs we can choose the same index multiple times SO AFTER TURNING NEGATIVE NUMBERS\\nTO POSITIVE NUMBERS, OBVIOUSLY WE WILL NOW PICK THE SMALLEST NUMBER TO CHANGE IT\\'S SIGN\\nTO REMAINING K TIMES TO GET THE LARGEST SUM.\\n\\nHere the smallest number now is 1 and k = 2, so -1,1 which is same as 1 cause \\n       if k is even, sign won\\'t change, but if k is odd, sign will change 100%.\\n```\\n\\n```CPP []\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        for(int i=0; i<nums.size() && nums[i]<0 && k>0; i++, k--)\\n            nums[i] = -nums[i];    \\n\\n        nums[min_element(begin(nums),end(nums))-begin(nums)] *= ((k&1) == 1? -1 : 1);\\n        return accumulate(begin(nums),end(nums),0);      \\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int :\\n        nums.sort()\\n        i = 0\\n        while i<len(nums) and k>0 and nums[i]<0 :\\n            nums[i] = -nums[i]\\n            i, k = i+1, k-1\\n        nums[nums.index(min(nums))] *= -1 if k&1 else 1\\n        return sum(nums) \\n```\\n```\\nTime complexity  : O(nlogn)\\nSpace complexity : O(sort)\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nAssume nums = [8,-1,8,-3,2,-2], k = 2\\n\\nTo get the LARGEST SUM we will make positive -3 and -2 as they are the SMALLEST NEGATIVE\\nNUMBERS. This finding process would be easier if we sort first:\\n\\n               -3,-2,-1,2,8,8 \\n\\nIf k were 5, first we would turn all the negative numbers to positive numbers, right?\\nCause the Q asked us LARGEST SUM!\\n\\n               3,2,1,2,8,8 and now k = 5 - 3 = 2\\n\\nAs we can choose the same index multiple times SO AFTER TURNING NEGATIVE NUMBERS\\nTO POSITIVE NUMBERS, OBVIOUSLY WE WILL NOW PICK THE SMALLEST NUMBER TO CHANGE IT\\'S SIGN\\nTO REMAINING K TIMES TO GET THE LARGEST SUM.\\n\\nHere the smallest number now is 1 and k = 2, so -1,1 which is same as 1 cause \\n       if k is even, sign won\\'t change, but if k is odd, sign will change 100%.\\n```\n```CPP []\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        for(int i=0; i<nums.size() && nums[i]<0 && k>0; i++, k--)\\n            nums[i] = -nums[i];    \\n\\n        nums[min_element(begin(nums),end(nums))-begin(nums)] *= ((k&1) == 1? -1 : 1);\\n        return accumulate(begin(nums),end(nums),0);      \\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int :\\n        nums.sort()\\n        i = 0\\n        while i<len(nums) and k>0 and nums[i]<0 :\\n            nums[i] = -nums[i]\\n            i, k = i+1, k-1\\n        nums[nums.index(min(nums))] *= -1 if k&1 else 1\\n        return sum(nums) \\n```\n```\\nTime complexity  : O(nlogn)\\nSpace complexity : O(sort)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496667,
                "title": "maximize-sum-of-array-after-k-negations-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int i, j=0, sum=0;\\n        sort(nums.begin(), nums.end());\\n        for(i=0 ; i<k ; i++)\\n        {\\n            if(nums[j]<0)\\n            {\\n                nums[j] *= (-1);\\n                if(j<nums.size()-1 && nums[j+1]<abs(nums[j]))\\n                    j++;\\n            }\\n            else if(nums[j]>=0)\\n            {\\n                nums[j] *= -1;\\n            }\\n        }\\n        sum = accumulate(nums.begin(), nums.end(), 0);\\n        return sum;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/4615bd62-f688-4d57-965e-a6968997c323_1683460834.4019096.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int i, j=0, sum=0;\\n        sort(nums.begin(), nums.end());\\n        for(i=0 ; i<k ; i++)\\n        {\\n            if(nums[j]<0)\\n            {\\n                nums[j] *= (-1);\\n                if(j<nums.size()-1 && nums[j+1]<abs(nums[j]))\\n                    j++;\\n            }\\n            else if(nums[j]>=0)\\n            {\\n                nums[j] *= -1;\\n            }\\n        }\\n        sum = accumulate(nums.begin(), nums.end(), 0);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486353,
                "title": "beats-100-java-c-python-non-queue-solution",
                "content": "> \\u26A0\\uFE0F **Disclaimer**: The original solution was crafted in Java. Thus, when we mention \"Beats 100%\" it applies specifically to Java submissions. The performance may vary for other languages.\\n\\nDont forget to upvote if you like the content below. \\uD83D\\uDE43\\n\\n# Intuition\\nGiven the problem, we should always aim to negate the smallest number in the array in each iteration to maximize the final sum. However, we can use a micro-optimization by calculating the sum once at the beginning and then adjusting it after each negation.\\n\\n# Approach\\nWe start by creating a frequency array, $$numbers$$, with the index representing the number in the original array + $$100$$. This allows us to handle negative numbers seamlessly.\\n\\nNext, we iterate through the $$nums$$ array, count the frequencies, and calculate the sum. Simultaneously, we keep track of the maximum absolute value in the array ($$maxAbs$$), which we will use later to determine the start index for the negation process.\\n\\nIf $$maxAbs$$ is zero after the first pass, it means all elements in the array are zero, and we return $$0$$, as negating zero doesn\\'t change the sum.\\n\\nThen, we perform $$k$$ negations. For each negation, we start at the index $$i$$ equal to $$100 - maxAbs$$, which represents the smallest possible number in the array. We find the first index with a non-zero frequency, decrement its frequency, increment the frequency of its negation $$(200 - i)$$, and adjust the sum by subtracting twice the current number (since we have negated it).\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is $$O(n + k)$$, where $$n$$ is the length of the array and $$k$$ is the number of negations. $$n$$ is for the initial iteration through the nums array, and $$k$$ is for the negations.\\n\\n- Space complexity:\\nThe space complexity is $$O(1)$$, as we only use a constant amount of extra space. The numbers array\\'s size is a constant $$201$$, accommodating all possible values from $$-100$$ to $$100$$.\\n\\nThis solution is optimal for the problem constraints. While a PriorityQueue-based solution could also work, it might not be as fast due to overheads associated with creating and managing the PriorityQueue. Our solution avoids these overheads by using a simple frequency count array and a single pass through the array. The index calculation $$(number + 100)$$ and the negation index calculation $$(200 - index)$$ are straightforward and efficient, making this solution particularly suitable for the given constraints.\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int[] numbers = new int[201];\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n: nums) {\\n            maxAbs = Math.max(maxAbs, Math.abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        vector<int> numbers(201, 0);\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n : nums) {\\n            maxAbs = max(maxAbs, abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n\\n        return sum;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        numbers = [0] * 201\\n        total_sum = 0\\n        max_abs = 0\\n        \\n        for n in nums:\\n            max_abs = max(max_abs, abs(n))\\n            numbers[100 + n] += 1\\n            total_sum += n\\n\\n        if max_abs == 0:\\n            return 0\\n\\n        while k > 0:\\n            k -= 1\\n            i = 100 - max_abs\\n            while numbers[i] == 0:\\n                i += 1\\n            numbers[i] -= 1\\n            numbers[200 - i] += 1\\n            total_sum -= 2 * (i - 100)\\n\\n        return total_sum\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Counting"
                ],
                "code": "```java []\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int[] numbers = new int[201];\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n: nums) {\\n            maxAbs = Math.max(maxAbs, Math.abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        vector<int> numbers(201, 0);\\n        int sum = 0;\\n        int maxAbs = 0;\\n        for (int n : nums) {\\n            maxAbs = max(maxAbs, abs(n));\\n            numbers[100 + n]++;\\n            sum += n;\\n        }\\n\\n        if (maxAbs == 0) {\\n            return 0;\\n        }\\n\\n        while (k-- != 0) {\\n            int i = 100 - maxAbs;\\n            while (numbers[i] == 0) {\\n                i++;\\n            }\\n            numbers[i]--;\\n            numbers[200 - i]++;\\n            sum -= 2 * (i - 100);\\n        }\\n\\n        return sum;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        numbers = [0] * 201\\n        total_sum = 0\\n        max_abs = 0\\n        \\n        for n in nums:\\n            max_abs = max(max_abs, abs(n))\\n            numbers[100 + n] += 1\\n            total_sum += n\\n\\n        if max_abs == 0:\\n            return 0\\n\\n        while k > 0:\\n            k -= 1\\n            i = 100 - max_abs\\n            while numbers[i] == 0:\\n                i += 1\\n            numbers[i] -= 1\\n            numbers[200 - i] += 1\\n            total_sum -= 2 * (i - 100)\\n\\n        return total_sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459930,
                "title": "5-line-code-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsorting\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nklog(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        int sum=0;\\n        while(k>0)\\n        {\\n                nums[0]=-nums[0];\\n                sort(begin(nums),end(nums));\\n                 k--;\\n        }\\n         for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        int sum=0;\\n        while(k>0)\\n        {\\n                nums[0]=-nums[0];\\n                sort(begin(nums),end(nums));\\n                 k--;\\n        }\\n         for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315221,
                "title": "1005-simple-solution-beats-91",
                "content": "# Code\\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        last_negative, last_ind = nums[0], 0\\n        for x, item in enumerate(nums):\\n            if k <= 0 or item == 0: break\\n            if item < 0:\\n                last_negative = -item\\n                last_ind = x\\n                nums[x] = -1 * item\\n                k -= 1\\n            elif item > 0:\\n                if k % 2 == 0: break\\n                else:\\n                    if item > last_negative:\\n                        nums[last_ind] = -1* last_negative\\n                        break\\n                    else:\\n                        nums[x] = -item\\n                        break\\n        else:\\n            nums[last_ind] = (-1**k)* last_negative\\n        return sum(nums)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Math",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        last_negative, last_ind = nums[0], 0\\n        for x, item in enumerate(nums):\\n            if k <= 0 or item == 0: break\\n            if item < 0:\\n                last_negative = -item\\n                last_ind = x\\n                nums[x] = -1 * item\\n                k -= 1\\n            elif item > 0:\\n                if k % 2 == 0: break\\n                else:\\n                    if item > last_negative:\\n                        nums[last_ind] = -1* last_negative\\n                        break\\n                    else:\\n                        nums[x] = -item\\n                        break\\n        else:\\n            nums[last_ind] = (-1**k)* last_negative\\n        return sum(nums)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060253,
                "title": "easy-python3-intuition-approach",
                "content": "# Code1\\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        for i in range(k):\\n            n=nums.index(min(nums))\\n            nums[n]=-1*nums[n]\\n        return sum(nums)\\n```\\n\\n# Code2\\n\\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        for i in range(k,0,-1):\\n            if min(nums)>=0 and i%2==0:return sum(nums)\\n            n=nums.index(min(nums))\\n            nums[n]=-1*nums[n]            \\n        return sum(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        for i in range(k):\\n            n=nums.index(min(nums))\\n            nums[n]=-1*nums[n]\\n        return sum(nums)\\n```\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        for i in range(k,0,-1):\\n            if min(nums)>=0 and i%2==0:return sum(nums)\\n            n=nums.index(min(nums))\\n            nums[n]=-1*nums[n]            \\n        return sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674119,
                "title": "java-priorityqueue-approach",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int p : nums){\\n            pq.offer(p);\\n        }\\n        while(k --> 0){\\n            int temp = pq.poll();\\n            temp = -temp;\\n            pq.offer(temp);\\n        }\\n        int sum = 0;\\n        while(!pq.isEmpty()){\\n            sum += pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int p : nums){\\n            pq.offer(p);\\n        }\\n        while(k --> 0){\\n            int temp = pq.poll();\\n            temp = -temp;\\n            pq.offer(temp);\\n        }\\n        int sum = 0;\\n        while(!pq.isEmpty()){\\n            sum += pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506908,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\n var largestSumAfterKNegations = function(nums, k) {\\n    const sortedNums = nums.sort((a,b) => a-b);\\n    let lowestPos = 0;\\n    for (let i = 0; i < k; i++) {\\n        // keep track of the lowest positive number\\n        if (sortedNums[i] < sortedNums[lowestPos]) lowestPos = i;\\n        // if the number is negative, flip it, otherwise continue to flip the lowest positive number\\n        sortedNums[i] < 0 ? sortedNums[i] = -sortedNums[i] : sortedNums[lowestPos] = -sortedNums[lowestPos];\\n    }\\n    return sortedNums.reduce((a,b) => a + b);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n var largestSumAfterKNegations = function(nums, k) {\\n    const sortedNums = nums.sort((a,b) => a-b);\\n    let lowestPos = 0;\\n    for (let i = 0; i < k; i++) {\\n        // keep track of the lowest positive number\\n        if (sortedNums[i] < sortedNums[lowestPos]) lowestPos = i;\\n        // if the number is negative, flip it, otherwise continue to flip the lowest positive number\\n        sortedNums[i] < 0 ? sortedNums[i] = -sortedNums[i] : sortedNums[lowestPos] = -sortedNums[lowestPos];\\n    }\\n    return sortedNums.reduce((a,b) => a + b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2096202,
                "title": "python-use-min-heap-to-always-operate-the-minelement-k-times",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        heapq.heapify(nums)\\n        while k > 0:\\n            _min = heapq.heappop(nums)\\n            heapq.heappush(nums, -_min)\\n            k -= 1\\n        res = 0\\n        while n > 0:\\n            res += heapq.heappop(nums)\\n            n -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        heapq.heapify(nums)\\n        while k > 0:\\n            _min = heapq.heappop(nums)\\n            heapq.heappush(nums, -_min)\\n            k -= 1\\n        res = 0\\n        while n > 0:\\n            res += heapq.heappop(nums)\\n            n -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882763,
                "title": "c-solution-beginner-friendly-using-priority-queue",
                "content": "```\\nint n=a.size(),c=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<n;i++)\\n            pq.push(a[i]);\\n        while(k--)\\n        {\\n            int p=pq.top();\\n            pq.pop();\\n            pq.push(-p);\\n        }\\n        while(!pq.empty())\\n        {\\n            c+=pq.top();\\n            pq.pop();\\n        }\\n       return c; \\n    }\\n```\\n``` If you like my approach then please upvote me.```",
                "solutionTags": [],
                "code": "```\\nint n=a.size(),c=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<n;i++)\\n            pq.push(a[i]);\\n        while(k--)\\n        {\\n            int p=pq.top();\\n            pq.pop();\\n            pq.push(-p);\\n        }\\n        while(!pq.empty())\\n        {\\n            c+=pq.top();\\n            pq.pop();\\n        }\\n       return c; \\n    }\\n```\n``` If you like my approach then please upvote me.```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809612,
                "title": "greedy-approach-python",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort(key=abs, reverse=True)\\n        for i in range(len(nums)):\\n            if nums[i] < 0 and k > 0:\\n                nums[i] *= -1\\n                k -= 1\\n            if k == 0:\\n                break\\n        if k % 2 != 0:\\n            nums[-1] *= -1\\n        return sum(nums)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort(key=abs, reverse=True)\\n        for i in range(len(nums)):\\n            if nums[i] < 0 and k > 0:\\n                nums[i] *= -1\\n                k -= 1\\n            if k == 0:\\n                break\\n        if k % 2 != 0:\\n            nums[-1] *= -1\\n        return sum(nums)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1794751,
                "title": "python3-priority-queue-min-heap-easy-understanding",
                "content": "TC: O(n + klog(x)) with x < n\\nSC: O(1)\\n\\n```\\ndef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        \\n        for _ in range(k):\\n            heapreplace(nums, -nums[0])\\n        return sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        \\n        for _ in range(k):\\n            heapreplace(nums, -nums[0])\\n        return sum(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1595423,
                "title": "c-solution-with-explanation",
                "content": "```\\nint cmp(const void *a, const void *b){\\n    return *(int*)a > *(int*)b;\\n}\\n\\nint largestSumAfterKNegations(int* nums, int numsSize, int k){\\n    // Sort the array first. \\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int i, N = numsSize, j = 0, sum = 0;\\n    \\n    // Concept: Flip the smallest element at each round. If it becomes larger than the next smallest element, don\\'t flip it in later rounds and switch to the next element. \\n    for(; k > 0; k--){  \\n        nums[j] = -nums[j];\\n        if(j == N - 1){\\n            continue;\\n        }\\n        if(nums[j] > nums[j + 1]){\\n            j++;\\n        }\\n    }\\n    for(i = 0; i < N; i++){\\n        sum += nums[i];\\n    }\\n    \\n    return sum;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmp(const void *a, const void *b){\\n    return *(int*)a > *(int*)b;\\n}\\n\\nint largestSumAfterKNegations(int* nums, int numsSize, int k){\\n    // Sort the array first. \\n    qsort(nums, numsSize, sizeof(int), cmp);\\n    int i, N = numsSize, j = 0, sum = 0;\\n    \\n    // Concept: Flip the smallest element at each round. If it becomes larger than the next smallest element, don\\'t flip it in later rounds and switch to the next element. \\n    for(; k > 0; k--){  \\n        nums[j] = -nums[j];\\n        if(j == N - 1){\\n            continue;\\n        }\\n        if(nums[j] > nums[j + 1]){\\n            j++;\\n        }\\n    }\\n    for(i = 0; i < N; i++){\\n        sum += nums[i];\\n    }\\n    \\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1547583,
                "title": "c-100-lengthy-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum=0;\\n        int i=0;\\n        \\n       sort(nums.begin(),nums.end());\\n       while(i<nums.size()&&(k>0&&nums[i]<=0)){\\n           if(nums[i]<0){\\n               nums[i]=-nums[i];\\n               k--;\\n           }\\n           else {\\n               k=0;\\n               break;\\n           }\\n           i++;\\n           }\\n        while(i<nums.size()&&(k>0&&nums[i]>0)){\\n            if(i!=0){\\n                if(nums[i]<=nums[i-1]){\\n                    if(k%2!=0){\\n                        nums[i]=-nums[i];\\n                        k=0;\\n                    }\\n                }\\n                if(nums[i]>nums[i-1]){\\n                    if(k%2!=0){\\n                        nums[i-1]=-nums[i-1];\\n                        k=0;\\n                    }\\n                }\\n            }\\n            else{\\n                if(k%2!=0){\\n                    \\n                    nums[i]=-nums[i];\\n                    cout<<nums[i]<<endl;\\n                    k=0;\\n                }\\n            }\\n            i++;\\n}\\n            if(k%2!=0){\\n                nums[nums.size()-1]=-nums[nums.size()-1];\\n                k=0;\\n            }      \\n        \\n        for(int j=0;j<nums.size();j++){\\n            sum+=nums[j];\\n        }\\n        return sum;\\n       }\\n    };\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum=0;\\n        int i=0;\\n        \\n       sort(nums.begin(),nums.end());\\n       while(i<nums.size()&&(k>0&&nums[i]<=0)){\\n           if(nums[i]<0){\\n               nums[i]=-nums[i];\\n               k--;\\n           }\\n           else {\\n               k=0;\\n               break;\\n           }\\n           i++;\\n           }\\n        while(i<nums.size()&&(k>0&&nums[i]>0)){\\n            if(i!=0){\\n                if(nums[i]<=nums[i-1]){\\n                    if(k%2!=0){\\n                        nums[i]=-nums[i];\\n                        k=0;\\n                    }\\n                }\\n                if(nums[i]>nums[i-1]){\\n                    if(k%2!=0){\\n                        nums[i-1]=-nums[i-1];\\n                        k=0;\\n                    }\\n                }\\n            }\\n            else{\\n                if(k%2!=0){\\n                    \\n                    nums[i]=-nums[i];\\n                    cout<<nums[i]<<endl;\\n                    k=0;\\n                }\\n            }\\n            i++;\\n}\\n            if(k%2!=0){\\n                nums[nums.size()-1]=-nums[nums.size()-1];\\n                k=0;\\n            }      \\n        \\n        for(int j=0;j<nums.size();j++){\\n            sum+=nums[j];\\n        }\\n        return sum;\\n       }\\n    };\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1502226,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int largestSumAfterKNegations(int[] nums, int k) {     \\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tint min = 101;\\n\\t\\t\\tfor(int i=0; i<nums.length; ++i){\\n\\t\\t\\t\\tif(nums[i] < 0 && k > 0){ // flip a negative number, \\n\\t\\t\\t\\t\\tnums[i] = -nums[i];\\n\\t\\t\\t\\t\\tk--; \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(nums[i] < min){\\n\\t\\t\\t\\t\\tmin=nums[i]; // find the minimum in the array \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres += nums[i];\\n\\t\\t\\t}\\n\\t\\t\\tif(k%2==1) \\n\\t\\t\\t\\tres -= 2*min;\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}\\n\\t\\t\\t// step 1 sort \\n\\t\\t\\t// step 2 if there are negative numbers, flip the negatives according to k, and find the minimum in the array \\n\\t\\t\\t// step 3 if k%2==1, we will subtract min twice. \\n\\t\\t\\t// time O(nlogn)\\n\\t\\t\\t// space O(1)",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int largestSumAfterKNegations(int[] nums, int k) {     \\n\\t\\t\\tArrays.sort(nums);\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tint min = 101;\\n\\t\\t\\tfor(int i=0; i<nums.length; ++i){\\n\\t\\t\\t\\tif(nums[i] < 0 && k > 0){ // flip a negative number, \\n\\t\\t\\t\\t\\tnums[i] = -nums[i];\\n\\t\\t\\t\\t\\tk--; \\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1115003,
                "title": "easy-way-of-using-priorityqueue-java",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        \\n        //Using of min heap.\\n        //Min heap by default.\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i=0;i<A.length;i++)\\n            pq.add(A[i]);\\n        int start = 0;\\n        while(start<K)\\n        {\\n            int min_value = pq.poll();\\n            pq.add(min_value*(-1));\\n            start++;\\n        }\\n        int sum = 0;\\n        while(!pq.isEmpty())\\n            sum = sum + pq.poll();\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        \\n        //Using of min heap.\\n        //Min heap by default.\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int i=0;i<A.length;i++)\\n            pq.add(A[i]);\\n        int start = 0;\\n        while(start<K)\\n        {\\n            int min_value = pq.poll();\\n            pq.add(min_value*(-1));\\n            start++;\\n        }\\n        int sum = 0;\\n        while(!pq.isEmpty())\\n            sum = sum + pq.poll();\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087877,
                "title": "java-minheap-simple-greedy-approach",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        \\n        for(int elem: A){\\n            minHeap.add(elem);\\n        }\\n        \\n        for(int i=0 ; i<K ; ++i){\\n            int curr = minHeap.poll();\\n            minHeap.add(-1*curr);\\n        }\\n        \\n        int sum = 0;\\n        while(!minHeap.isEmpty()){\\n            sum += minHeap.poll();\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n        \\n        for(int elem: A){\\n            minHeap.add(elem);\\n        }\\n        \\n        for(int i=0 ; i<K ; ++i){\\n            int curr = minHeap.poll();\\n            minHeap.add(-1*curr);\\n        }\\n        \\n        int sum = 0;\\n        while(!minHeap.isEmpty()){\\n            sum += minHeap.poll();\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986825,
                "title": "two-months-of-python-solution",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A, K) -> int:\\n\\n        minvalue = min(A)\\n        start = 0\\n\\n        while start != K:\\n            for i in range(len(A)):\\n                if A[i] == minvalue:\\n                    A[i] = - A[i]\\n                    break\\n\\n            minvalue = min(A)\\n            start +=1\\n\\n        return sum(A)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A, K) -> int:\\n\\n        minvalue = min(A)\\n        start = 0\\n\\n        while start != K:\\n            for i in range(len(A)):\\n                if A[i] == minvalue:\\n                    A[i] = - A[i]\\n                    break\\n\\n            minvalue = min(A)\\n            start +=1\\n\\n        return sum(A)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917150,
                "title": "easy-adn-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int k) {\\n        sort(a.begin(),a.end());      // sorting in begining\\n        int sum=0;\\n        for(int i=0;i<a.size()&&k>0;i++)\\n        {\\n            if(a[i]<0)       // for all negative elements\\n            {\\n                a[i]=-a[i];\\n                k--;\\n            }\\n            else \\n                break;      // else breaking out of loop\\n        }\\n        sort(a.begin(),a.end());           // sorting again to find out the smallest element in the modified array\\n        for(int i=1;i<a.size();i++)            // calculating sum except the smallest element i.e a[0]\\n                sum+=a[i];\\n        if(k%2==0)\\n            return sum+a[0];                    // adding smallest element as it is if k is even\\n        else\\n            return sum-a[0];                   // adding smallest element after changinf sign if k is odd\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int k) {\\n        sort(a.begin(),a.end());      // sorting in begining\\n        int sum=0;\\n        for(int i=0;i<a.size()&&k>0;i++)\\n        {\\n            if(a[i]<0)       // for all negative elements\\n            {\\n                a[i]=-a[i];\\n                k--;\\n            }\\n            else \\n                break;      // else breaking out of loop\\n        }\\n        sort(a.begin(),a.end());           // sorting again to find out the smallest element in the modified array\\n        for(int i=1;i<a.size();i++)            // calculating sum except the smallest element i.e a[0]\\n                sum+=a[i];\\n        if(k%2==0)\\n            return sum+a[0];                    // adding smallest element as it is if k is even\\n        else\\n            return sum-a[0];                   // adding smallest element after changinf sign if k is odd\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761620,
                "title": "java-2-solutions-using-heap-sorting",
                "content": "Using Priority Queue :\\n```\\nPriorityQueue<Integer> pq = new PriorityQueue<>();\\nfor(int num : A) pq.add(num);\\n\\nwhile(K-- > 0)\\n\\tpq.add(-pq.poll());\\n\\nint sum = 0;\\nwhile(!pq.isEmpty())\\n\\tsum += pq.poll();\\nreturn sum;\\n```\\n\\nUsing Sorting :\\n\\n```\\nArrays.sort(A);\\nint sum = 0;\\n\\nfor(int i = 0; i < A.length; i++){\\n\\n\\twhile(A[i] < 0 && K > 0){\\n\\t\\tA[i] = -A[i];\\n\\t\\tK--;\\n\\t\\ti++;\\n\\t}\\n\\n\\tK = K%2 == 0 ? 0 : 1;\\n\\tif(K > 0){\\n\\t\\tif(i > 0 && A[i] > A[i-1])\\n\\t\\t\\tA[i-1] = -A[i-1];\\n\\t\\telse\\n\\t\\t\\tA[i] = -A[i];\\n\\t}\\n\\tbreak;\\n}\\nfor(int num : A)\\n\\tsum += num;\\nreturn sum;\\n```",
                "solutionTags": [],
                "code": "```\\nPriorityQueue<Integer> pq = new PriorityQueue<>();\\nfor(int num : A) pq.add(num);\\n\\nwhile(K-- > 0)\\n\\tpq.add(-pq.poll());\\n\\nint sum = 0;\\nwhile(!pq.isEmpty())\\n\\tsum += pq.poll();\\nreturn sum;\\n```\n```\\nArrays.sort(A);\\nint sum = 0;\\n\\nfor(int i = 0; i < A.length; i++){\\n\\n\\twhile(A[i] < 0 && K > 0){\\n\\t\\tA[i] = -A[i];\\n\\t\\tK--;\\n\\t\\ti++;\\n\\t}\\n\\n\\tK = K%2 == 0 ? 0 : 1;\\n\\tif(K > 0){\\n\\t\\tif(i > 0 && A[i] > A[i-1])\\n\\t\\t\\tA[i-1] = -A[i-1];\\n\\t\\telse\\n\\t\\t\\tA[i] = -A[i];\\n\\t}\\n\\tbreak;\\n}\\nfor(int num : A)\\n\\tsum += num;\\nreturn sum;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 601888,
                "title": "java-99-9-1-ms-only-sorting",
                "content": "```\\n private int largestSumAfterKNegations(int[] A,int K){\\n        Arrays.sort(A); \\n        int minIdx = 0;\\n        while(K-- > 0){\\n            if(minIdx < A.length && A[minIdx] < 0){\\n                A[minIdx] = -A[minIdx];\\n\\t\\t\\t\\t//Move minIdx only if the next number is less than min\\n                if(minIdx+1 < A.length && A[minIdx+1] < A[minIdx])minIdx++;\\n            }else{\\n                 A[minIdx] = -A[minIdx];\\n            }\\n            \\n        }\\n        int sum = 0;\\n        for(int num:A){\\n            sum += num;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n private int largestSumAfterKNegations(int[] A,int K){\\n        Arrays.sort(A); \\n        int minIdx = 0;\\n        while(K-- > 0){\\n            if(minIdx < A.length && A[minIdx] < 0){\\n                A[minIdx] = -A[minIdx];\\n\\t\\t\\t\\t//Move minIdx only if the next number is less than min\\n                if(minIdx+1 < A.length && A[minIdx+1] < A[minIdx])minIdx++;\\n            }else{\\n                 A[minIdx] = -A[minIdx];\\n            }\\n            \\n        }\\n        int sum = 0;\\n        for(int num:A){\\n            sum += num;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560334,
                "title": "6-lines-solution-with-c-stl",
                "content": "```c++\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        for (int i = 0; i < K; i++)\\n        {\\n            auto itr = min_element(A.begin(), A.end());\\n            *itr = -(*itr);\\n        }\\n        return accumulate(A.begin(), A.end(), 0);\\n    }\\n};\\n```\\n**PEACE**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        for (int i = 0; i < K; i++)\\n        {\\n            auto itr = min_element(A.begin(), A.end());\\n            *itr = -(*itr);\\n        }\\n        return accumulate(A.begin(), A.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456042,
                "title": "1005-maximize-sum-of-array-after-k-negations-py-all-in-one-by-talse",
                "content": "**Get it Done, Make it Better, Share the Best -- Talse**\\n**I). Min Heap**\\n| O(T): O(nlgn) | O(S): O(1) | Rt: 48ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K): heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\\nComment: always negate the minimum. \\nAlternative: slightly improved. | Rt: 40ms |\\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K % (2 * len(A))): heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\\nComment: if you do 2 * len(A) negating, you can always get the original input list. \\nTriple: further improved.  | Rt: 48ms |\\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        K %= 2*len(A)\\n        for i in range(K):\\n            if A[0] >= 0: return sum(A) - ((K - i) & 1) * 2 * A[0] \\n            heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\\nComment: Once all elements are positive, stop the game and check the remaining times need to modify. If the remaining is even, it is the sum of current list (you negate the minimun even times, it remains the same). Otherwise, you need to deduct the minimum twice because you already added it to the sum once (and it is negative after odd times negating). This should boost the runtime however it didn\\'t ....\\n\\nQuestion: could we reduce K by % 2(len(A))? I think not, but the solution get passed. **I clarify the \"Reduce K\" trick in the above solutions (and below) may not be applicable in case some troubles .** \\n\\n\\n**II). Remove and Append**\\n| O(T): O(kn) | O(S): O(1) | Rt: 136ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        for _ in range(K): \\n            curmin = min(A)\\n            A.remove(curmin)\\n            A.append(-curmin)\\n        return sum(A)\\n```\\nAlternative: slightly improved.  | Rt: 124ms | O(T): n^2 |\\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        for _ in range(K % (2*len(A))): \\n            curmin = min(A)\\n            A.remove(curmin)\\n            A.append(-curmin)\\n        return sum(A)\\n```\\n\\n\\n**III). Greedy**\\n| O(T): O(nlgn) | O(S): O(1) | Rt: 56ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort(); K %= 2 * len(A); i = 0\\n        while A[i] < 0 and i < K: A[i], i = -A[i], i + 1\\n        return sum(A) - ((K-i) % 2) * 2 * min(A)\\n```\\n\\n\\n**IV). Counting Sort**\\n| O(T): O(n) | O(S): O(n) | Rt: 56ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        ct = collections.Counter(A)\\n        for i in range(-100, 0):\\n            if K == 0: break\\n            if i in ct: \\n                amt = min(K, ct[i])\\n                ct[i] -= amt\\n                ct[-i] += amt\\n                K -= amt\\n        a = list(ct.elements())\\n        return sum(a) - (K&1) * 2 * min(a) \\n```\\nReferrence: https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/discuss/252254/C++Python-Sort/246430\\nComment: take advantage of the -100 <= A[i] <= 100.\\n\\n\\n**V). Bucket Collect then Counting Sort**\\n| O(T): O(n) | O(S): O(1) | Rt: 48ms | \\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        m = [0] * 201\\n        for i in A: m[i+100] += 1\\n        for i in range(0, 100):\\n            if K == 0: break\\n            if m[i]: \\n                amt = min(K, m[i])\\n                m[i] -= amt\\n                # -(i - 100) + 100 = 200 -i\\n                m[200 - i] += amt\\n                K -= amt\\n        suma = sum((i-100) * v for i, v in enumerate(m) if v)\\n        # mina = next(i - 100 for i, v in enumerate(m) if v)\\n        return suma - (K&1) * 2 * min(map(abs, A)) \\n```\\nReferrence: idea from https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/discuss/252849/C%2B%2BJava-O(n)-or-O(1)\\nQuestion: min([5,6,9,-3,3], key=abs) == -3 and min([5,6,9,-4,3], key=abs) == 3. Who tell me Why?\\n",
                "solutionTags": [],
                "code": "```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K): heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K % (2 * len(A))): heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        K %= 2*len(A)\\n        for i in range(K):\\n            if A[0] >= 0: return sum(A) - ((K - i) & 1) * 2 * A[0] \\n            heapq.heappush(A, -heapq.heappop(A))\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        for _ in range(K): \\n            curmin = min(A)\\n            A.remove(curmin)\\n            A.append(-curmin)\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        for _ in range(K % (2*len(A))): \\n            curmin = min(A)\\n            A.remove(curmin)\\n            A.append(-curmin)\\n        return sum(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort(); K %= 2 * len(A); i = 0\\n        while A[i] < 0 and i < K: A[i], i = -A[i], i + 1\\n        return sum(A) - ((K-i) % 2) * 2 * min(A)\\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        ct = collections.Counter(A)\\n        for i in range(-100, 0):\\n            if K == 0: break\\n            if i in ct: \\n                amt = min(K, ct[i])\\n                ct[i] -= amt\\n                ct[-i] += amt\\n                K -= amt\\n        a = list(ct.elements())\\n        return sum(a) - (K&1) * 2 * min(a) \\n```\n```python\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        m = [0] * 201\\n        for i in A: m[i+100] += 1\\n        for i in range(0, 100):\\n            if K == 0: break\\n            if m[i]: \\n                amt = min(K, m[i])\\n                m[i] -= amt\\n                # -(i - 100) + 100 = 200 -i\\n                m[200 - i] += amt\\n                K -= amt\\n        suma = sum((i-100) * v for i, v in enumerate(m) if v)\\n        # mina = next(i - 100 for i, v in enumerate(m) if v)\\n        return suma - (K&1) * 2 * min(map(abs, A)) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 422182,
                "title": "simple-solution-with-python-40ms",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort()\\n        i = 0\\n        while K > 0 and A[i] < 0:\\n            A[i] *= -1\\n            i += 1\\n            K -= 1\\n        if K % 2 == 0:\\n            return sum(A)\\n        else:\\n            return sum(A) - 2 * min(A[i],A[i-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort()\\n        i = 0\\n        while K > 0 and A[i] < 0:\\n            A[i] *= -1\\n            i += 1\\n            K -= 1\\n        if K % 2 == 0:\\n            return sum(A)\\n        else:\\n            return sum(A) - 2 * min(A[i],A[i-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332070,
                "title": "straightforward-java-o-nlogn-and-constant-space-with-thinking-process",
                "content": "The idea is pretty simple:\\n1. The sum maximizes when all numbers are positive.\\n2. If K >= neg(count of negative numbers), we use neg flips to make all negative numbers to positive. If (K - neg) % 2 == 0, good, nothing will be changed; If not, flip the number that has min Math.abs(number) once. \\n3. If K < neg, we just need to flip the first K negative numbers in a sorted array. \\n```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        int neg = 0, sum = 0, close = Integer.MAX_VALUE;\\n        for(int i : A){\\n            if(i < 0) neg++;\\n            if(Math.abs(i) < close) close = Math.abs(i);\\n        }\\n        if(K >= neg){\\n            int remain = K - neg;\\n            for(int i : A) sum += Math.abs(i);\\n            return remain % 2 == 0? sum : sum - 2*close;\\n        }\\n        else {\\n            Arrays.sort(A);\\n            for(int i : A){\\n                if(K > 0){\\n                    sum += Math.abs(i);\\n                    K--;\\n                }\\n                else sum += i;\\n            }\\n            return sum;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        int neg = 0, sum = 0, close = Integer.MAX_VALUE;\\n        for(int i : A){\\n            if(i < 0) neg++;\\n            if(Math.abs(i) < close) close = Math.abs(i);\\n        }\\n        if(K >= neg){\\n            int remain = K - neg;\\n            for(int i : A) sum += Math.abs(i);\\n            return remain % 2 == 0? sum : sum - 2*close;\\n        }\\n        else {\\n            Arrays.sort(A);\\n            for(int i : A){\\n                if(K > 0){\\n                    sum += Math.abs(i);\\n                    K--;\\n                }\\n                else sum += i;\\n            }\\n            return sum;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331164,
                "title": "javascript-beats-99-5",
                "content": "Runtime: 52 ms, faster than 99.50% of JavaScript online submissions\\nMemory Usage: 35.9 MB, less than 33.80% of JavaScript online submissions\\n\\nTrying to take every short circuit I can.\\n\\n```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nconst largestSumAfterKNegations = (A, K) => {\\n  A.sort((a, b) => a - b);\\n  let sum = 0;\\n  for (let i = 0; i < A.length; i++) {\\n    let val = A[i];\\n    if (0 < K) {\\n      if (val < 0) {\\n        let next = A[i + 1];\\n        if (Math.abs(val) < next && 0 === K % 2) K = 0;\\n        else [val, K] = [-val, K - 1];\\n      } else if (0 !== val && 1 === K % 2) [val, K] = [-val, 0];\\n      else K = 0;\\n    }\\n    sum += val;\\n  }\\n  return sum;\\n};\\n```\\n\\nAnd here is a recursive solution.\\n\\nRuntime: 68 ms, faster than 72.92% of JavaScript online submissions\\nMemory Usage: 36.3 MB, less than 50.00% of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nconst largestSumAfterKNegations = (a, k) => {\\n  if (0 === k) return a.reduce((acc, curr) => acc + curr);\\n  let [min, mindex] = [Infinity];\\n  for (let i = 0; i < a.length; i++) if (a[i] < min) [min, mindex] = [a[i], i];\\n  if (min < 0 || k % 2) a[mindex] = -a[mindex];\\n  return largestSumAfterKNegations(a, min < 0 ? k - 1 : 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nconst largestSumAfterKNegations = (A, K) => {\\n  A.sort((a, b) => a - b);\\n  let sum = 0;\\n  for (let i = 0; i < A.length; i++) {\\n    let val = A[i];\\n    if (0 < K) {\\n      if (val < 0) {\\n        let next = A[i + 1];\\n        if (Math.abs(val) < next && 0 === K % 2) K = 0;\\n        else [val, K] = [-val, K - 1];\\n      } else if (0 !== val && 1 === K % 2) [val, K] = [-val, 0];\\n      else K = 0;\\n    }\\n    sum += val;\\n  }\\n  return sum;\\n};\\n```\n```javascript\\n/**\\n * @param {number[]} A\\n * @param {number} K\\n * @return {number}\\n */\\nconst largestSumAfterKNegations = (a, k) => {\\n  if (0 === k) return a.reduce((acc, curr) => acc + curr);\\n  let [min, mindex] = [Infinity];\\n  for (let i = 0; i < a.length; i++) if (a[i] < min) [min, mindex] = [a[i], i];\\n  if (min < 0 || k % 2) a[mindex] = -a[mindex];\\n  return largestSumAfterKNegations(a, min < 0 ? k - 1 : 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 253629,
                "title": "c-10-lines-o-nlogn-time-o-1-space-use-only-sort-comparison-beat-99-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        \\n        sort(A.begin(), A.end());\\n        int minIdx = 0;\\n        // Do K steps\\n        for(int i = 0; i < K; i++){\\n            // change the sign of the smallest element\\n            A[minIdx] = -A[minIdx];\\n            if(minIdx == A.size()-1  || A[minIdx] > A[minIdx + 1])  minIdx++;\\n        }\\n        int sum = 0;\\n        for(auto a: A)  sum += a;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        \\n        sort(A.begin(), A.end());\\n        int minIdx = 0;\\n        // Do K steps\\n        for(int i = 0; i < K; i++){\\n            // change the sign of the smallest element\\n            A[minIdx] = -A[minIdx];\\n            if(minIdx == A.size()-1  || A[minIdx] > A[minIdx + 1])  minIdx++;\\n        }\\n        int sum = 0;\\n        for(auto a: A)  sum += a;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 253368,
                "title": "quickselect-o-n-solution",
                "content": "We don\\'t need sorted sequence. We just need the K smallest negative elements to negate their sign and if we have less than K negative elements  and the left number of operations is odd - choose the smallest positive (or zero) and negate its sign.\\n```\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n\\n        nth_element(A.begin(), A.begin() + K, A.end());\\n        int cnt = K;\\n        int minIdx = 0;\\n        \\n        for (int i = 0; i < K; ++i) {\\n            if (A[i] < 0) {\\n                A[i] = -A[i];\\n                cnt--;\\n            }\\n            if (A[i] < A[minIdx]) minIdx = i;\\n        }\\n        if (cnt % 2 != 0) {\\n            A[minIdx] = -A[minIdx];\\n        }\\n        \\n        return accumulate(A.begin(), A.end(), 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n\\n        nth_element(A.begin(), A.begin() + K, A.end());\\n        int cnt = K;\\n        int minIdx = 0;\\n        \\n        for (int i = 0; i < K; ++i) {\\n            if (A[i] < 0) {\\n                A[i] = -A[i];\\n                cnt--;\\n            }\\n            if (A[i] < A[minIdx]) minIdx = i;\\n        }\\n        if (cnt % 2 != 0) {\\n            A[minIdx] = -A[minIdx];\\n        }\\n        \\n        return accumulate(A.begin(), A.end(), 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252965,
                "title": "simple-python-heap-solution",
                "content": "Keep negating the minimum value:\\n\\n```\\nimport heapq\\n\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, S, K):\\n        heapq.heapify(S)\\n        for _ in range(K):\\n            v = heapq.heappop(S)\\n            heapq.heappush(S, -v)\\n        return sum(S)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, S, K):\\n        heapq.heapify(S)\\n        for _ in range(K):\\n            v = heapq.heappop(S)\\n            heapq.heappush(S, -v)\\n        return sum(S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622679,
                "title": "c-min-heap-different-approach",
                "content": "**Test on this example:**\\n`[-8,3,-5,-3,-5,-2]` to understand `if (-smallest > -pq.top())`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        // O(n), min heap\\n        priority_queue<int, vector<int>, greater<int>> pq(nums.begin(), nums.end());    \\n\\n        // while smallest numbers are negative\\n        while (k > 0 && pq.top() < 0) {\\n            int smallest = pq.top();\\n            sum -= 2 * smallest;\\n            pq.pop();\\n            if (-smallest > -pq.top())\\n                pq.push(-smallest);\\n            k--;\\n        }\\n        // when all negatives are done, negate the 0 or smallest positive number multiple times\\n        if (k % 2 == 1) sum -= 2*pq.top(); \\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = accumulate(nums.begin(), nums.end(), 0);\\n        // O(n), min heap\\n        priority_queue<int, vector<int>, greater<int>> pq(nums.begin(), nums.end());    \\n\\n        // while smallest numbers are negative\\n        while (k > 0 && pq.top() < 0) {\\n            int smallest = pq.top();\\n            sum -= 2 * smallest;\\n            pq.pop();\\n            if (-smallest > -pq.top())\\n                pq.push(-smallest);\\n            k--;\\n        }\\n        // when all negatives are done, negate the 0 or smallest positive number multiple times\\n        if (k % 2 == 1) sum -= 2*pq.top(); \\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496724,
                "title": "c-solution-simple-to-understand",
                "content": "## Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int i=0;\\n        sort(nums.begin(),nums.end());\\n        for(; i<n; i++){\\n            if (k==0)break;\\n            if (nums[i]>=0)break;\\n            nums[i]*= -1;\\n            k--;\\n        }\\n        if (k&1){\\n            if (i-1>=0){\\n                if (abs(nums[i-1])<abs(nums[i]))nums[i-1]*=-1;\\n                else nums[i]*=-1;\\n            }\\n            else nums[i]*=-1;\\n\\n        }\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            ans+= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int n= nums.size();\\n        int i=0;\\n        sort(nums.begin(),nums.end());\\n        for(; i<n; i++){\\n            if (k==0)break;\\n            if (nums[i]>=0)break;\\n            nums[i]*= -1;\\n            k--;\\n        }\\n        if (k&1){\\n            if (i-1>=0){\\n                if (abs(nums[i-1])<abs(nums[i]))nums[i-1]*=-1;\\n                else nums[i]*=-1;\\n            }\\n            else nums[i]*=-1;\\n\\n        }\\n        int ans=0;\\n        for (int i=0; i<n; i++){\\n            ans+= nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231286,
                "title": "c-easy-code",
                "content": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue <int, vector<int>, greater<int> > pq;\\n        for(auto it:nums)\\n        {\\n            pq.push(it);\\n        }\\n        vector<int> ans;\\n        int cnt=0,sum=0;\\n        while(cnt!=k)\\n        {\\n            if(pq.top()==0)\\n            {\\n                ans.push_back(0);\\n            }\\n            int x=pq.top();\\n            pq.pop();\\n            int y=(-1)*(x);\\n            pq.push(y);\\n            cnt++;\\n        }\\n        for(auto it:ans)\\n        {\\n            pq.push(it);\\n        }\\n        while(!pq.empty())\\n        {\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue <int, vector<int>, greater<int> > pq;\\n        for(auto it:nums)\\n        {\\n            pq.push(it);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3062731,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func largestSumAfterKNegations(_ nums: [Int], _ k: Int) -> Int {\\n        \\n        var ns = nums.sorted()\\n        var i = 0\\n        \\n        while i < k, i < nums.count, ns[i] < 0 {\\n            ns[i] = -ns[i]\\n            i += 1\\n        }\\n        \\n        guard i > k || (k - i) % 2 == 1 else { return ns.reduce(0, +) }\\n        \\n        var mi = ns[min(i, ns.count - 1)]\\n        if i > 0, ns[i - 1] < mi { mi = ns[i - 1] }\\n        \\n        return ns.reduce(0, +) - 2 * mi\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func largestSumAfterKNegations(_ nums: [Int], _ k: Int) -> Int {\\n        \\n        var ns = nums.sorted()\\n        var i = 0\\n        \\n        while i < k, i < nums.count, ns[i] < 0 {\\n            ns[i] = -ns[i]\\n            i += 1\\n        }\\n        \\n        guard i > k || (k - i) % 2 == 1 else { return ns.reduce(0, +) }\\n        \\n        var mi = ns[min(i, ns.count - 1)]\\n        if i > 0, ns[i - 1] < mi { mi = ns[i - 1] }\\n        \\n        return ns.reduce(0, +) - 2 * mi\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2971088,
                "title": "1005-java-2-approach",
                "content": "# Complexity\\n- Time complexity || Runtime : 2 ms \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity || Memory : 42 MB \\n\\n- Beats : 99.10%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = 0 , index = 0;\\n        for(int i : nums){\\n            if(i < 0 && k > 0){\\n                k--;\\n                ans += i * -1;\\n                nums[index] = i * -1;\\n            }\\n            else ans += i;\\n            index++;\\n        }\\n        Arrays.sort(nums);\\n        if(k % 2 == 1) ans -= (nums[0] + nums[0]);\\n        return ans;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity || Runtime : 2 ms \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity || Memory : 41.7 MB \\n\\n- Beats : 99.10%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 2\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = 0 , index = 0 , min = Integer.MAX_VALUE;\\n        for(int i : nums){\\n            if(i < 0 && k > 0){\\n                k--;\\n                ans += i * -1;\\n                nums[index] = i * -1;\\n            }\\n            else ans += i;\\n            if(i < min) min = nums[index];\\n            index++;\\n        }\\n        if(k % 2 == 1) ans -= min + min;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = 0 , index = 0;\\n        for(int i : nums){\\n            if(i < 0 && k > 0){\\n                k--;\\n                ans += i * -1;\\n                nums[index] = i * -1;\\n            }\\n            else ans += i;\\n            index++;\\n        }\\n        Arrays.sort(nums);\\n        if(k % 2 == 1) ans -= (nums[0] + nums[0]);\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int ans = 0 , index = 0 , min = Integer.MAX_VALUE;\\n        for(int i : nums){\\n            if(i < 0 && k > 0){\\n                k--;\\n                ans += i * -1;\\n                nums[index] = i * -1;\\n            }\\n            else ans += i;\\n            if(i < min) min = nums[index];\\n            index++;\\n        }\\n        if(k % 2 == 1) ans -= min + min;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932116,
                "title": "js-javascript-greedy-easy-to-understand-solution",
                "content": "\\n## Optimized Solution\\nTC :\\nSC: \\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(nums, k) {    \\n    nums.sort((a, b) => a - b);\\n    let modify = 0;\\n    let i = 0;\\n    while (k > 0) {\\n        if (nums[i] < nums[modify]) modify = i;\\n        if (i + 1 < nums.length) i ++;\\n        nums[modify] = -nums[modify];\\n        k --;\\n    }\\n    return nums.reduce((acc, cur) => acc + cur, 0);\\n};\\n```\\n\\n\\n## Easy To Understand \\n- slow\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(nums, k) {\\n    let i = 0;\\n    while (i < k) {\\n        nums.sort((a, b) => a - b);\\n        nums[0] = -nums[0];\\n        i ++;\\n    }\\n    return nums.reduce((acc, cur) => acc + cur, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(nums, k) {    \\n    nums.sort((a, b) => a - b);\\n    let modify = 0;\\n    let i = 0;\\n    while (k > 0) {\\n        if (nums[i] < nums[modify]) modify = i;\\n        if (i + 1 < nums.length) i ++;\\n        nums[modify] = -nums[modify];\\n        k --;\\n    }\\n    return nums.reduce((acc, cur) => acc + cur, 0);\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar largestSumAfterKNegations = function(nums, k) {\\n    let i = 0;\\n    while (i < k) {\\n        nums.sort((a, b) => a - b);\\n        nums[0] = -nums[0];\\n        i ++;\\n    }\\n    return nums.reduce((acc, cur) => acc + cur, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2657499,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = 0,i=0,length=nums.size();\\n        sort(nums.begin(), nums.end());\\n        while(nums[i]<0 && i<length){\\n            if(k<=0)\\n                break;\\n            nums[i] *= -1;\\n            i++;\\n            k--;\\n        }\\n        sort(nums.begin(), nums.end());\\n        if(k>0 && nums[0]!=0)\\n            if(k%2)\\n                nums[0] *= -1;\\n        for(auto x:nums){\\n            sum += x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum = 0,i=0,length=nums.size();\\n        sort(nums.begin(), nums.end());\\n        while(nums[i]<0 && i<length){\\n            if(k<=0)\\n                break;\\n            nums[i] *= -1;\\n            i++;\\n            k--;\\n        }\\n        sort(nums.begin(), nums.end());\\n        if(k>0 && nums[0]!=0)\\n            if(k%2)\\n                nums[0] *= -1;\\n        for(auto x:nums){\\n            sum += x;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549142,
                "title": "c-min-heap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n       priority_queue<int, vector<int>, greater<int>> pq(A.begin(), A.end());\\n        while(k--){\\n            int t=pq.top();pq.pop();\\n            pq.push(t*-1);\\n        }\\n    \\n        int n=0;\\n       while(!pq.empty()){\\n           int t=pq.top();pq.pop();\\n           n+=t;\\n       }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n       priority_queue<int, vector<int>, greater<int>> pq(A.begin(), A.end());\\n        while(k--){\\n            int t=pq.top();pq.pop();\\n            pq.push(t*-1);\\n        }\\n    \\n        int n=0;\\n       while(!pq.empty()){\\n           int t=pq.top();pq.pop();\\n           n+=t;\\n       }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544881,
                "title": "c-min-heap-explained",
                "content": "\\t*********please upvote if it helps.\\n\\tclass Solution {\\n\\tpublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n      int n=nums.size();\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto x:nums){\\n            pq.push(x);\\n        }\\n\\t\\t//min will at top so if if we push negative of that then only ans will be minimum\\n        while(k--){\\n            int x=pq.top();\\n            pq.pop();\\n            pq.push(-x);\\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n      int n=nums.size();\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto x:nums){\\n            pq.push(x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2480046,
                "title": "c-simple-if-else",
                "content": "**hope u find it helpful**\\n\\n\\t int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin() , nums.end());\\n        \\n        while(k > 0)\\n        {\\n           if(nums[0] == 0)\\n           {\\n               break;\\n           }\\n            \\n           else if(nums[0] > 0)\\n            {\\n                k = k%2 ;\\n                if(k)\\n                {\\n                    nums[0] = -nums[0];\\n                    k=0;\\n                }\\n            }\\n            else{\\n                nums[0] = -nums[0];\\n                k--;\\n                sort(nums.begin() , nums.end());\\n            }\\n        }\\n        int sum = 0;\\n        for(auto i:nums)\\n        {\\n            sum += i;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [],
                "code": "**hope u find it helpful**\\n\\n\\t int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin() , nums.end());\\n        \\n        while(k > 0)\\n        {\\n           if(nums[0] == 0)\\n           {\\n               break;\\n           }\\n            \\n           else if(nums[0] > 0)\\n            {\\n                k = k%2 ;\\n                if(k)\\n                {\\n                    nums[0] = -nums[0];\\n                    k=0;\\n                }\\n            }\\n            else{\\n                nums[0] = -nums[0];\\n                k--;\\n                sort(nums.begin() , nums.end());\\n            }\\n        }\\n        int sum = 0;\\n        for(auto i:nums)\\n        {\\n            sum += i;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2465321,
                "title": "c-100-beats-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0, n = nums.size();\\n        while((i<n) && k){\\n            if(nums[i]<0){\\n                nums[i] = -nums[i];\\n                k--;\\n            }else{\\n                break;\\n            }\\n            i++;\\n        }\\n        if(k%2){\\n            if(i==n){\\n                nums[i-1] = -nums[i-1];\\n            }\\n            else if(i>0 && nums[i]>nums[i-1]){\\n                nums[i-1] = -nums[i-1];\\n            }else{\\n                nums[i] = -nums[i];\\n            }\\n        }\\n        int sum = 0;\\n        for(auto &i: nums){\\n            // cout<<i<<\" \";\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0, n = nums.size();\\n        while((i<n) && k){\\n            if(nums[i]<0){\\n                nums[i] = -nums[i];\\n                k--;\\n            }else{\\n                break;\\n            }\\n            i++;\\n        }\\n        if(k%2){\\n            if(i==n){\\n                nums[i-1] = -nums[i-1];\\n            }\\n            else if(i>0 && nums[i]>nums[i-1]){\\n                nums[i-1] = -nums[i-1];\\n            }else{\\n                nums[i] = -nums[i];\\n            }\\n        }\\n        int sum = 0;\\n        for(auto &i: nums){\\n            // cout<<i<<\" \";\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2336382,
                "title": "you-have-to-be-greedy-to-understand-greedy",
                "content": "```\\n  int largestSumAfterKNegations(vector<int>& arr, int k) {\\n    \\n        sort(arr.begin(),arr.end());\\n        \\n        //make the negative numbers positve as many you can\\n        int mino=INT_MAX;\\n        for(int i=0;i<arr.size() and k>0;i++)\\n        {\\n            if(arr[i]<0)  //jitne negative numbers ko positive bna skte bnalo\\n            {\\n                arr[i]=-arr[i]; \\n                k--;\\n            }              \\n            mino=min(arr[i],mino);  //min nikalo bcha hua \\'k\\' jo hoga isi number p krege\\n        }\\n        \\n        int sum=0;\\n        for(auto i:arr)\\n            sum+=i;\\n        \\n    //if even k=2 then 2 3 7  --> -2 3 7 --> 2 3 7 even me no change in array same sum \\n//if odd k=3 then 2 3 7 --> -2 3 7 --> 2 3 7 --> -2 3 7 odd me sum-=2*mino sum-=4 \\n        return k%2?sum-2*mino:sum;  \\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n  int largestSumAfterKNegations(vector<int>& arr, int k) {\\n    \\n        sort(arr.begin(),arr.end());\\n        \\n        //make the negative numbers positve as many you can\\n        int mino=INT_MAX;\\n        for(int i=0;i<arr.size() and k>0;i++)\\n        {\\n            if(arr[i]<0)  //jitne negative numbers ko positive bna skte bnalo\\n            {\\n                arr[i]=-arr[i]; \\n                k--;\\n            }              \\n            mino=min(arr[i],mino);  //min nikalo bcha hua \\'k\\' jo hoga isi number p krege\\n        }\\n        \\n        int sum=0;\\n        for(auto i:arr)\\n            sum+=i;\\n        \\n    //if even k=2 then 2 3 7  --> -2 3 7 --> 2 3 7 even me no change in array same sum \\n//if odd k=3 then 2 3 7 --> -2 3 7 --> 2 3 7 --> -2 3 7 odd me sum-=2*mino sum-=4 \\n        return k%2?sum-2*mino:sum;  \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2298751,
                "title": "java-easy-solution-3ms-faster",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (count < k) {\\n                if (nums[i] < 0) {\\n                    nums[i] = -1 * nums[i];\\n                    count++;\\n                }\\n            }\\n        }\\n        if (count < k) {\\n            Arrays.sort(nums);\\n            while (count < k) {\\n                nums[0] = -1 * nums[0];\\n                count++;\\n            }\\n        }\\n\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n\\n        return sum; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (count < k) {\\n                if (nums[i] < 0) {\\n                    nums[i] = -1 * nums[i];\\n                    count++;\\n                }\\n            }\\n        }\\n        if (count < k) {\\n            Arrays.sort(nums);\\n            while (count < k) {\\n                nums[0] = -1 * nums[0];\\n                count++;\\n            }\\n        }\\n\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n        }\\n\\n        return sum; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118546,
                "title": "c-faster-6ms-run-time-solution",
                "content": "Firstly, we ```sort then convert``` the negative numbers in the array to positive while decreasing \\'k\\' with each operetion...```[first we sort so the grater negative numbers are changed first]```\\n ```-[if in this process the number of opertions is passed we return the sum of the elements]```\\nThen, if all elements are positive we change the sign of the minimum number in the array for the remaining no. of operations and return the total sum. \\n\\n         Runtime: 6 ms, faster than 69.56%\\n    Memory Usage: 9 MB,   less than 65.64% \\n\\n                     \\nCode:\\n\\n                        UPVOTE if you like the Explanition / Solution \\n\\t\\t \\n```\\nclass Solution \\n{\\npublic:\\n    int largestSumAfterKNegations(vector<int>& n, int k) \\n    {\\n        sort(n.begin(),n.end()); //sorting\\n        for(int i=0;i<n.size();i++)\\n        {\\n            if(n[i]<0){n[i]*=-1;k--;}//converting negative elements if any\\n            if(k==0){return accumulate(n.begin(),n.end(),0);}\\n\\t\\t\\t//at any point if no. of operations is reached we return the present sum\\n        }\\n        if(k%2==0){return accumulate(n.begin(),n.end(),0);}\\n\\t\\t//if remaining no. of operations are even the minimum element will not change thus we return current total sum\\n        \\n\\t\\t//else no. of operations are odd the least element will change sign....\\n\\t\\t//hence we subtract it twice from total sum\\n\\t\\tint l=*min_element(n.begin(),n.end());\\n        return accumulate(n.begin(),n.end(),0)-(2*l);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```sort then convert```\n```[first we sort so the grater negative numbers are changed first]```\n```-[if in this process the number of opertions is passed we return the sum of the elements]```\n```\\nclass Solution \\n{\\npublic:\\n    int largestSumAfterKNegations(vector<int>& n, int k) \\n    {\\n        sort(n.begin(),n.end()); //sorting\\n        for(int i=0;i<n.size();i++)\\n        {\\n            if(n[i]<0){n[i]*=-1;k--;}//converting negative elements if any\\n            if(k==0){return accumulate(n.begin(),n.end(),0);}\\n\\t\\t\\t//at any point if no. of operations is reached we return the present sum\\n        }\\n        if(k%2==0){return accumulate(n.begin(),n.end(),0);}\\n\\t\\t//if remaining no. of operations are even the minimum element will not change thus we return current total sum\\n        \\n\\t\\t//else no. of operations are odd the least element will change sign....\\n\\t\\t//hence we subtract it twice from total sum\\n\\t\\tint l=*min_element(n.begin(),n.end());\\n        return accumulate(n.begin(),n.end(),0)-(2*l);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104403,
                "title": "c-maximize-sum-of-array-after-k-negations",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int largestSumAfterKNegations(vector<int> &nums, int k)\\n        {\\n            sort(nums.begin(), nums.end());\\n            int i = 0;\\n            while (i < nums.size() and nums[i] < 0 and k > 0)\\n            {\\n                nums[i] = -nums[i];\\n                k--;\\n                i++;\\n            }\\n            bool isOdd = k % 2 != 0;\\n            sort(nums.begin(), nums.end());\\n            if (i < nums.size() and isOdd or k > 0 and isOdd)\\n                nums[0] = -nums[0];\\n            int sum = 0;\\n            for (int x: nums)\\n                sum += x;\\n            return sum;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int largestSumAfterKNegations(vector<int> &nums, int k)\\n        {\\n            sort(nums.begin(), nums.end());\\n            int i = 0;\\n            while (i < nums.size() and nums[i] < 0 and k > 0)\\n            {\\n                nums[i] = -nums[i];\\n                k--;\\n                i++;\\n            }\\n            bool isOdd = k % 2 != 0;\\n            sort(nums.begin(), nums.end());\\n            if (i < nums.size() and isOdd or k > 0 and isOdd)\\n                nums[0] = -nums[0];\\n            int sum = 0;\\n            for (int x: nums)\\n                sum += x;\\n            return sum;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2100016,
                "title": "java-solution-using-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num : nums)\\n            pq.add(num);\\n        \\n        while(k > 0 && !pq.isEmpty())\\n        {\\n            pq.add(pq.poll() * -1);\\n            k -= 1;\\n        }\\n        \\n        int sum = 0;\\n        while(!pq.isEmpty())\\n            sum += pq.poll();\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        for(int num : nums)\\n            pq.add(num);\\n        \\n        while(k > 0 && !pq.isEmpty())\\n        {\\n            pq.add(pq.poll() * -1);\\n            k -= 1;\\n        }\\n        \\n        int sum = 0;\\n        while(!pq.isEmpty())\\n            sum += pq.poll();\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087015,
                "title": "o-n-using-quick-select-and-no-extra-memory",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int l = nums.length;\\n        int minI = 0, minVal, sum=Math.abs(nums[0]),t,s,e;\\n        for(int i=1;i<l;i++) {\\n            if(Math.abs(nums[i])<= Math.abs(nums[minI])) minI = i;\\n            sum+=Math.abs(nums[i]);\\n        }\\n        minVal = Math.abs(nums[minI]);\\n        swap(nums,minI,l-1);\\n        minI = partition(nums,0,l-1);\\n        if(minI<l && nums[minI]< 0) minI++;\\n        if(k>=minI){\\n            if((k-minI)%2==1) sum -=(2* minVal);\\n        }else{\\n            s = 0;e=minI-1;\\n            t=partition(nums,s,e);\\n            while(t!=k-1){\\n                if(t<k-1) s = t+1; else e = t-1;\\n                t=partition(nums,s,e);\\n            }\\n            for(int i =t+1;i<minI;i++) sum+=2*(nums[i]);\\n        }\\n        return sum;\\n    }\\n    \\n    int partition(int[] nums, int start,int end){\\n        int pivotId = end, slow = start, fast = start;\\n        if(nums[pivotId]>=0)\\n        for(;fast<end; fast++) {if(nums[fast]<nums[pivotId]) swap(nums, fast, slow++);}\\n        else\\n        for(;fast<end; fast++) {if(nums[fast]<=nums[pivotId]) swap(nums, fast, slow++);}\\n        swap(nums, pivotId, slow);\\n        return slow;\\n    }\\n    \\n    void swap(int[] nums, int a,int b){\\n        if (nums[a]==nums[b]) return;\\n        nums[a] = nums[a]^nums[b];\\n        nums[b] = nums[a]^nums[b];\\n        nums[a] = nums[a]^nums[b];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int l = nums.length;\\n        int minI = 0, minVal, sum=Math.abs(nums[0]),t,s,e;\\n        for(int i=1;i<l;i++) {\\n            if(Math.abs(nums[i])<= Math.abs(nums[minI])) minI = i;\\n            sum+=Math.abs(nums[i]);\\n        }\\n        minVal = Math.abs(nums[minI]);\\n        swap(nums,minI,l-1);\\n        minI = partition(nums,0,l-1);\\n        if(minI<l && nums[minI]< 0) minI++;\\n        if(k>=minI){\\n            if((k-minI)%2==1) sum -=(2* minVal);\\n        }else{\\n            s = 0;e=minI-1;\\n            t=partition(nums,s,e);\\n            while(t!=k-1){\\n                if(t<k-1) s = t+1; else e = t-1;\\n                t=partition(nums,s,e);\\n            }\\n            for(int i =t+1;i<minI;i++) sum+=2*(nums[i]);\\n        }\\n        return sum;\\n    }\\n    \\n    int partition(int[] nums, int start,int end){\\n        int pivotId = end, slow = start, fast = start;\\n        if(nums[pivotId]>=0)\\n        for(;fast<end; fast++) {if(nums[fast]<nums[pivotId]) swap(nums, fast, slow++);}\\n        else\\n        for(;fast<end; fast++) {if(nums[fast]<=nums[pivotId]) swap(nums, fast, slow++);}\\n        swap(nums, pivotId, slow);\\n        return slow;\\n    }\\n    \\n    void swap(int[] nums, int a,int b){\\n        if (nums[a]==nums[b]) return;\\n        nums[a] = nums[a]^nums[b];\\n        nums[b] = nums[a]^nums[b];\\n        nums[a] = nums[a]^nums[b];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061193,
                "title": "simple-solution-using-sorting-with-explanation",
                "content": "```go\\nfunc largestSumAfterKNegations(nums []int, k int) int {\\n  // First sort the numbers in ascending order\\n  sort.Ints(nums)\\n  // Let\\'s try to make as much negative numbers positive as possible\\n  // and also compute the sum as a result of this.\\n  // We\\'ll also keep track of the minimum element in this loop that we\\'l use later.\\n  var sum int\\n  min := math.MaxInt32\\n  for i := 0; i < len(nums); i++ {\\n    if k > 0 && nums[i] < 0 {\\n      nums[i] = -nums[i]\\n      k--\\n    }\\n    sum += nums[i]\\n    if nums[i] < min {\\n      min = nums[i]\\n    }\\n  }\\n  // We\\'ve applied as much negations on negative numbers. Now we don\\'t have any more\\n  // negative numbers. If k is even, we don\\'t need to do anything because the negations\\n  // cancel out. If it is odd, we\\'ll apply all the remaining negations on the min of the\\n  // result of the previous step.\\n  if k%2 != 0 {\\n    sum -= 2 * min\\n  }\\n  return sum\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sorting"
                ],
                "code": "```go\\nfunc largestSumAfterKNegations(nums []int, k int) int {\\n  // First sort the numbers in ascending order\\n  sort.Ints(nums)\\n  // Let\\'s try to make as much negative numbers positive as possible\\n  // and also compute the sum as a result of this.\\n  // We\\'ll also keep track of the minimum element in this loop that we\\'l use later.\\n  var sum int\\n  min := math.MaxInt32\\n  for i := 0; i < len(nums); i++ {\\n    if k > 0 && nums[i] < 0 {\\n      nums[i] = -nums[i]\\n      k--\\n    }\\n    sum += nums[i]\\n    if nums[i] < min {\\n      min = nums[i]\\n    }\\n  }\\n  // We\\'ve applied as much negations on negative numbers. Now we don\\'t have any more\\n  // negative numbers. If k is even, we don\\'t need to do anything because the negations\\n  // cancel out. If it is odd, we\\'ll apply all the remaining negations on the min of the\\n  // result of the previous step.\\n  if k%2 != 0 {\\n    sum -= 2 * min\\n  }\\n  return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2008660,
                "title": "super-clear-illustrated-explanation",
                "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/7cad9926-b5d3-458c-9b5c-7130c339fce5_1651692881.4312992.png)\\n\\n\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S in place \"\"\"\\n        heapq.heapify(nums)\\n        [heapq.heappush(nums, -heapq.heappop(nums)) for _ in range(k)]\\n        return sum(nums)\\n\\n\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S \"\"\"\\n        heapq.heapify(nums)\\n        [heapq.heapreplace(nums, -nums[0]) for _ in range(k)] # some optimization\\n        return sum(nums)",
                "solutionTags": [],
                "code": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/7cad9926-b5d3-458c-9b5c-7130c339fce5_1651692881.4312992.png)\\n\\n\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S in place \"\"\"\\n        heapq.heapify(nums)\\n        [heapq.heappush(nums, -heapq.heappop(nums)) for _ in range(k)]\\n        return sum(nums)\\n\\n\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        \"\"\" O(NlogN)T O(1)S \"\"\"\\n        heapq.heapify(nums)\\n        [heapq.heapreplace(nums, -nums[0]) for _ in range(k)] # some optimization\\n        return sum(nums)",
                "codeTag": "Python3"
            },
            {
                "id": 1999055,
                "title": "textbook-greedy-problem",
                "content": "```\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(k==0)\\n                break;\\n            if(nums[i]<0){\\n                nums[i]=nums[i]*-1;\\n                k--;\\n            }\\n            else \\n                break;\\n        }\\n        if(k!=0){\\n            sort(nums.begin(),nums.end());\\n            k=k-(k/2)*2;\\n            if(k==1)\\n                nums[0]=nums[0]*-1;\\n        }\\n        int sum = 0;\\n        for(int x:nums){\\n            sum=sum+x;\\n        }\\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(k==0)\\n                break;\\n            if(nums[i]<0){\\n                nums[i]=nums[i]*-1;\\n                k--;\\n            }\\n            else \\n                break;\\n        }\\n        if(k!=0){\\n            sort(nums.begin(),nums.end());\\n            k=k-(k/2)*2;\\n            if(k==1)\\n                nums[0]=nums[0]*-1;\\n        }\\n        int sum = 0;\\n        for(int x:nums){\\n            sum=sum+x;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1906868,
                "title": "priority-queue-in-js-or-negation-logic-detailed-explanation-with-time-space-complexity-analysis",
                "content": "2 approaches \\n# Priority Queues\\n\\n- First, we put the array into the priority queue pq\\n- For each negation, we try to negate the **smallest** possible element via` num = pq.peak().element`\\n\\t- If the element is positive -> it becomes only negative (since other elements are larger than this)\\n\\t- If the element is negative -> it becomes positive \\n- After that, we enqueue the negated version of it \\n- After the all iterations, sum all elements to get the sum.\\n\\nTime complexity: O(K log N) - K iterations and heap enqueue and dequeue operate in O(logN) \\nSpace complexity: O(N)\\n```\\n\\nvar largestSumAfterKNegations = function(nums, k) {\\n    const pq = new MinPriorityQueue();\\n    let sum = 0;\\n    \\n    nums.map(e => {\\n        pq.enqueue(e);\\n    });\\n        \\n    for (let i = 1; i <= k; i++) {\\n        let num = pq.dequeue().element;\\n        pq.enqueue(-num);\\n    }\\n            \\n    return pq.toArray().reduce((prev, curr) => {\\n        return prev + curr.element;\\n    }, 0);\\n};\\n```\\n\\n# Negating logic\\n- First, we sort the array\\n- Second, we loop through the array and negate the negative values of the array \\n\\t- Case 1, if the negation K <= the numbers of negative value => all the negations are used correctly, since it will produce the largest sum\\n\\t- Case 2, if the negation K > the numbers of negative value \\n\\t\\t- all the negative ones are now positive\\n\\t\\t- we sum all the numbers\\n\\t\\t- we keep track of the smallest positive value since the all the next negations are actually time this number by -1\\n\\t\\t\\t- When it is positive, it is the smallest\\n\\t\\t\\t- When it is negative, it is also the smallest\\n\\t\\t- depending the leftover negation are odd or even\\n\\t\\t\\t- if odd => sum = sum - (smallest * 2) \\n\\t\\t\\t- if even => sum = sum\\n\\t\\nTime complexity: O(NlogN)\\nSpace complexity: O(1)\\n\\n```\\nvar largestSumAfterKNegations = (A, K) => {\\n    A.sort((a, b) => a - b);\\n    \\n    let negations = 0, sum = 0, smallest = A[0];\\n    \\n    for (let i = 0; i < A.length; i++) {\\n        if (A[i] < 0 && negations < K) {\\n            A[i] = -A[i];\\n            negations++;\\n        }\\n        \\n        sum += A[i];\\n        smallest = Math.min(smallest, A[i]);\\n    }\\n    \\n    return (K - negations) % 2 === 0 ? sum : sum - (smallest * 2);\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nvar largestSumAfterKNegations = function(nums, k) {\\n    const pq = new MinPriorityQueue();\\n    let sum = 0;\\n    \\n    nums.map(e => {\\n        pq.enqueue(e);\\n    });\\n        \\n    for (let i = 1; i <= k; i++) {\\n        let num = pq.dequeue().element;\\n        pq.enqueue(-num);\\n    }\\n            \\n    return pq.toArray().reduce((prev, curr) => {\\n        return prev + curr.element;\\n    }, 0);\\n};\\n```\n```\\nvar largestSumAfterKNegations = (A, K) => {\\n    A.sort((a, b) => a - b);\\n    \\n    let negations = 0, sum = 0, smallest = A[0];\\n    \\n    for (let i = 0; i < A.length; i++) {\\n        if (A[i] < 0 && negations < K) {\\n            A[i] = -A[i];\\n            negations++;\\n        }\\n        \\n        sum += A[i];\\n        smallest = Math.min(smallest, A[i]);\\n    }\\n    \\n    return (K - negations) % 2 === 0 ? sum : sum - (smallest * 2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1852427,
                "title": "priority-queue-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        h = []\\n        for num in nums:\\n            heappush(h, num)\\n        while k:\\n            num = heappop(h)\\n            heappush(h, -num)\\n            k -= 1\\n        return sum(h)\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        h = []\\n        for num in nums:\\n            heappush(h, num)\\n        while k:\\n            num = heappop(h)\\n            heappush(h, -num)\\n            k -= 1\\n        return sum(h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831321,
                "title": "c-simple-concise-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (auto &n: nums) pq.push(n);\\n        for (;k--;) {\\n            int x = pq.top();\\n            pq.pop();\\n            pq.push(x * -1);\\n        }\\n        int ans = 0;\\n        for (;!pq.empty(); ans += pq.top(), pq.pop());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for (auto &n: nums) pq.push(n);\\n        for (;k--;) {\\n            int x = pq.top();\\n            pq.pop();\\n            pq.push(x * -1);\\n        }\\n        int ans = 0;\\n        for (;!pq.empty(); ans += pq.top(), pq.pop());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763840,
                "title": "greedy-java-o-n-k-log-n",
                "content": "First toggle the signs of as many negative numbers as you can, starting from the smallest negative number as the smallest negative number will be the largest one (when you toggle the sign of any negative number) and will contribute more to the sum.\\nIn case there is no more negative numbers and `k>0`, toggle the sign of the smallest number k times. So if `k%2==0` there is ultimately no change to the sign of that number, else it becomes negative.\\n\\n```\\npublic int largestSumAfterKNegations1(int[] nums, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue();\\n        int sum=0;\\n        \\n        for(int i:nums){\\n            pq.add(i);\\n            sum+=i;\\n        }\\n        \\n        while(k>0 && pq.peek()<0){\\n            int curr=pq.poll();\\n            pq.add(curr*-1);\\n            sum-=2*curr;\\n            k--;\\n        }\\n        if(k>0 && k%2!=0){\\n            int curr=pq.poll();\\n            pq.add(curr*-1);\\n            sum-=2*curr;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int largestSumAfterKNegations1(int[] nums, int k) {\\n        PriorityQueue<Integer> pq=new PriorityQueue();\\n        int sum=0;\\n        \\n        for(int i:nums){\\n            pq.add(i);\\n            sum+=i;\\n        }\\n        \\n        while(k>0 && pq.peek()<0){\\n            int curr=pq.poll();\\n            pq.add(curr*-1);\\n            sum-=2*curr;\\n            k--;\\n        }\\n        if(k>0 && k%2!=0){\\n            int curr=pq.poll();\\n            pq.add(curr*-1);\\n            sum-=2*curr;\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1715780,
                "title": "fastest-but-complex-java-solution",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        int count=0;\\n        int prev=0;\\n        for(int i:nums)\\n        {\\n            //System.out.println(i+\" \"+count);\\n            if(i<0)\\n            {\\n                if(k>0)\\n                {\\n                    count+=Math.abs(i);\\n                    k--;\\n                    prev = i;\\n                }\\n                else\\n                {\\n                    count+=i;\\n                }\\n                //System.out.println(count+\" \"+k);\\n            }\\n            else if(i==0)\\n            {\\n                k=0;\\n            }\\n            else\\n            {\\n                //System.out.println(count+\" \"+k);\\n                if(k%2==0)\\n                {\\n                    count+=i;\\n                    k=0;\\n                }\\n                else\\n                {\\n                    if(prev==0)\\n                    {\\n                        count+=(-1*i);\\n                        k=0;\\n                    }\\n                    else\\n                    {\\n                        if(prev>i || Math.abs(prev)>i)\\n                        {\\n                            count+=(-1*i);\\n                        }\\n                        else\\n                        {\\n                            count+=prev;\\n                            count+=(prev + i);\\n                        }\\n                        k=0;\\n                    }\\n                }\\n            }\\n        }\\n        if(k%2!=0)\\n        {\\n            count+=(prev + prev);\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        int count=0;\\n        int prev=0;\\n        for(int i:nums)\\n        {\\n            //System.out.println(i+\" \"+count);\\n            if(i<0)\\n            {\\n                if(k>0)\\n                {\\n                    count+=Math.abs(i);\\n                    k--;\\n                    prev = i;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1701952,
                "title": "c-very-simple-easy-to-understand-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n\\t\\t//negate the minimum element\\n        //start negating negative element \\n\\t\\t//can also use min heap\\n        sort(nums.begin(),nums.end());\\n        \\n        int i=0;\\n        while(k--)\\n        {\\n            nums[i]=-nums[i];\\n            //decesion to increment i -> this is trick\\n            i++;\\n            if(i==nums.size() || nums[i]>nums[i-1]) i--;\\n        }\\n        \\n        int sum=0;\\n        sum=accumulate(nums.begin(),nums.end(),sum);  //sum of all elements\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n\\t\\t//negate the minimum element\\n        //start negating negative element \\n\\t\\t//can also use min heap\\n        sort(nums.begin(),nums.end());\\n        \\n        int i=0;\\n        while(k--)\\n        {\\n            nums[i]=-nums[i];\\n            //decesion to increment i -> this is trick\\n            i++;\\n            if(i==nums.size() || nums[i]>nums[i-1]) i--;\\n        }\\n        \\n        int sum=0;\\n        sum=accumulate(nums.begin(),nums.end(),sum);  //sum of all elements\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644297,
                "title": "c-greedy-with-intuition",
                "content": "intuition : First of all sort the vector and then check if the element at the 0th position is negative (say -a ) ,then replace it by -(-a) and decrement the value of k by 1 else if its 0 then keep it as it is and decrement the value of k by k i.e now k=0 ; else if the 0th element is positive then replace the element by -(a) and decrement k by 1.Do the same until k becomes 0. And finally return the sum of all elemnts .\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int i=0;\\n        while(k!=0)\\n        {\\n            sort(nums.begin(),nums.end());\\n            if(nums[i]<0)\\n            {\\n                nums[i]= -nums[i];\\n                k--;\\n            }\\n            else if(nums[i]==0)\\n            {\\n                nums[i]=nums[i];\\n                k=k-k;\\n            }\\n            else\\n            {\\n                nums[i]=-nums[i];\\n                k--;\\n            }\\n        }\\n        int sum=0;\\n        for(auto i:nums)\\n            sum+=i;\\n        return sum;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int i=0;\\n        while(k!=0)\\n        {\\n            sort(nums.begin(),nums.end());\\n            if(nums[i]<0)\\n            {\\n                nums[i]= -nums[i];\\n                k--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1640773,
                "title": "maximize-sum-of-array-after-k-negations-c-easy-solution",
                "content": "**Please Upvote \\n If you Liked solution**\\n\\n\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        \\n            sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] < 0 && k!=0){\\n                nums[i] = -nums[i];\\n                k--;\\n            }\\n        }\\n        long long int sum = 0;\\n        for(int i=0;i<nums.size();i++){\\n            sum += nums[i];\\n        }\\n        if(k%2!=0){\\n            sum = sum - (*min_element(nums.begin(),nums.end())*2);\\n        }\\n        return sum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        \\n            sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] < 0 && k!=0){\\n                nums[i] = -nums[i];\\n                k--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1624514,
                "title": "here-is-my-c-cpp-solutionon-0ms-beats-100-other-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        vector<int>neg;\\n        vector<int>ans;\\n        bool z = false;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(nums[i] < 0)\\n            {\\n                neg.push_back(nums[i]);\\n            }\\n            else\\n                ans.push_back(nums[i]);\\n            if(nums[i] == 0)\\n                z = true;\\n        }\\n        sort(neg.begin(),neg.end());\\n        for(int i = 0;i<neg.size() and k>0;i++)\\n        {\\n            neg[i] *= -1;\\n            k--;\\n        }\\n        for(int i = 0;i<neg.size();i++)\\n        {\\n            ans.push_back(neg[i]);\\n        }\\n        k %= 2;\\n        if(k == 0)return accumulate(ans.begin(),ans.end(),0);\\n        if(k)\\n        {\\n            if(z)\\n            {\\n                return accumulate(ans.begin(),ans.end(),0);\\n            }\\n        }\\n        int mn = *min_element(ans.begin(),ans.end());\\n        for(int i = 0;i<ans.size();i++)\\n        {\\n            if(ans[i] == mn)\\n            {\\n                ans[i] *= -1;\\n                break;\\n            }\\n        }\\n        int sum = accumulate(ans.begin(),ans.end(),0);\\n        return sum;\\n    }\\n};\\nIf you like the solution Please upvote :)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        vector<int>neg;\\n        vector<int>ans;\\n        bool z = false;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(nums[i] < 0)\\n            {\\n                neg.push_back(nums[i]);\\n            }\\n            else\\n                ans.push_back(nums[i]);\\n            if(nums[i] == 0)\\n                z = true;\\n        }\\n        sort(neg.begin(),neg.end());\\n        for(int i = 0;i<neg.size() and k>0;i++)\\n        {\\n            neg[i] *= -1;\\n            k--;\\n        }\\n        for(int i = 0;i<neg.size();i++)\\n        {\\n            ans.push_back(neg[i]);\\n        }\\n        k %= 2;\\n        if(k == 0)return accumulate(ans.begin(),ans.end(),0);\\n        if(k)\\n        {\\n            if(z)\\n            {\\n                return accumulate(ans.begin(),ans.end(),0);\\n            }\\n        }\\n        int mn = *min_element(ans.begin(),ans.end());\\n        for(int i = 0;i<ans.size();i++)\\n        {\\n            if(ans[i] == mn)\\n            {\\n                ans[i] *= -1;\\n                break;\\n            }\\n        }\\n        int sum = accumulate(ans.begin(),ans.end(),0);\\n        return sum;\\n    }\\n};\\nIf you like the solution Please upvote :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1607986,
                "title": "k-nlog-n-time-complexicity-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        \\n        while(k != 0){\\n            sort(nums.begin(), nums.end());\\n            nums[0] = -nums[0];\\n            k -= 1;    \\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++)sum += nums[i];\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        \\n        while(k != 0){\\n            sort(nums.begin(), nums.end());\\n            nums[0] = -nums[0];\\n            k -= 1;    \\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++)sum += nums[i];\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1587950,
                "title": "python-40ms-faster-than-95-simplest-logic-no-extra-edge-cases",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        i=0\\n        n = len(nums)\\n        while(i<n and k>0):\\n            if nums[i]<0:\\n                #make it positive\\n                nums[i] = -nums[i]\\n                k-=1\\n                i+=1\\n            elif nums[i]>=0:\\n                break\\n        if k%2==1:\\n            return sum(nums)-2*(min(nums))\\n        else:\\n            return sum(nums)\\n\\t\\t\\t#if k is odd, we will have to take the minimum element 2k+1 times\\n\\t\\t\\t#if its even, we can take whole nums, as it has k nonnegative values\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        i=0\\n        n = len(nums)\\n        while(i<n and k>0):\\n            if nums[i]<0:\\n                #make it positive\\n                nums[i] = -nums[i]\\n                k-=1\\n                i+=1\\n            elif nums[i]>=0:\\n                break\\n        if k%2==1:\\n            return sum(nums)-2*(min(nums))\\n        else:\\n            return sum(nums)\\n\\t\\t\\t#if k is odd, we will have to take the minimum element 2k+1 times\\n\\t\\t\\t#if its even, we can take whole nums, as it has k nonnegative values\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1570660,
                "title": "c-o-n-time-85-faster-with-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(auto i: a) pq.push(i);\\n        while(k--) {\\n            int t = pq.top();\\n            pq.pop();\\n            t *= -1;\\n            pq.push(t);\\n        }\\n        int sum = 0;\\n        while(pq.size()) {\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(auto i: a) pq.push(i);\\n        while(k--) {\\n            int t = pq.top();\\n            pq.pop();\\n            t *= -1;\\n            pq.push(t);\\n        }\\n        int sum = 0;\\n        while(pq.size()) {\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519826,
                "title": "c-0ms-stl-accumulate-min-element-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int ops) {//ops => operations remaining\\n\\t\\tsort(a.begin(),a.end());//sort will bring negative elements at the starting\\n        for(int i=0;i<a.size();i++){\\n            if(ops>0&&a[i]<0)a[i]=-a[i],ops--; //turning smallest negative numbers into positive numbers\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Turning -5 -> 5 is better rather than -2 -> 2\\n\\t\\t\\t\\tif(ops==0){         //If run out of operations, stop\\n                return accumulate(a.begin(),a.end(),0);  //sum all elements to 0\\n            }\\n        }\\n\\t\\t//at this point there will be no negative elements remaining in the vector\\n\\t\\t//if number of operations are even, we can change any same element\\'s sign and it will not affect the result\\n        if(ops%2==0)return accumulate(a.begin(),a.end(),0);\\n\\t\\t\\n\\t\\t//if we have odd operations, we can turn smallest number to negative\\n        return accumulate(a.begin(),a.end(),0) -2* (*min_element(a.begin(),a.end()));\\n\\t\\t//We have already counted the positive/zero number in sum, hence subtracting twice\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& a, int ops) {//ops => operations remaining\\n\\t\\tsort(a.begin(),a.end());//sort will bring negative elements at the starting\\n        for(int i=0;i<a.size();i++){\\n            if(ops>0&&a[i]<0)a[i]=-a[i],ops--; //turning smallest negative numbers into positive numbers\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Turning -5 -> 5 is better rather than -2 -> 2\\n\\t\\t\\t\\tif(ops==0){         //If run out of operations, stop\\n                return accumulate(a.begin(),a.end(),0);  //sum all elements to 0\\n            }\\n        }\\n\\t\\t//at this point there will be no negative elements remaining in the vector\\n\\t\\t//if number of operations are even, we can change any same element\\'s sign and it will not affect the result\\n        if(ops%2==0)return accumulate(a.begin(),a.end(),0);\\n\\t\\t\\n\\t\\t//if we have odd operations, we can turn smallest number to negative\\n        return accumulate(a.begin(),a.end(),0) -2* (*min_element(a.begin(),a.end()));\\n\\t\\t//We have already counted the positive/zero number in sum, hence subtracting twice\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424648,
                "title": "python3-nice-trick-faster-than-97-09-memory-less-than-81-00",
                "content": "Explanation:\\nCheck if the array is just a positive numbers, if yes then if k is even then this would not affect anything otherwise flip the minimun element.\\n\\nif there is negative elements in the array, sort the array with absolute value[no importance for the sign] then start from the last element which is the larger one in his absolute value, if this element is negative then flip his sign and decrease k by 1\\nif you reach the minimum element and k != 0 then we have more move to make, in this case if k is even then as usual it has no affect otherwise flip his sign then sum up all the elements.\\n\\n![image](https://assets.leetcode.com/users/images/1cdf6bd7-42a5-4a18-bcc5-31b3ab1dfddb_1629865210.0578444.png)\\n\\n```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n\\n        less = False\\n        for i in nums:\\n            if i < 0:\\n                less = True\\n                break\\n        \\n        nums.sort(key = lambda x : abs(x))\\n\\n        if not less:\\n            if k % 2 == 0:\\n                return sum(nums)\\n            else:\\n                return sum(nums[1:]) - nums[0]\\n\\n        i = len(nums) - 1\\n        while(k > 0):\\n            if nums[i] < 0:\\n                nums[i] *= -1\\n                k -= 1\\n            i -= 1\\n\\n            if i == 0 and k > 0:\\n                if nums[0] > 0:\\n                    if k % 2 == 0:\\n                        break\\n                    else:\\n                        nums[0] *= -1\\n                        break\\n                else:\\n                    if k % 2 == 0:\\n                        break\\n                    else:\\n                        nums[0] *= -1\\n                        break\\n\\n        return sum(nums)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n\\n        less = False\\n        for i in nums:\\n            if i < 0:\\n                less = True\\n                break\\n        \\n        nums.sort(key = lambda x : abs(x))\\n\\n        if not less:\\n            if k % 2 == 0:\\n                return sum(nums)\\n            else:\\n                return sum(nums[1:]) - nums[0]\\n\\n        i = len(nums) - 1\\n        while(k > 0):\\n            if nums[i] < 0:\\n                nums[i] *= -1\\n                k -= 1\\n            i -= 1\\n\\n            if i == 0 and k > 0:\\n                if nums[0] > 0:\\n                    if k % 2 == 0:\\n                        break\\n                    else:\\n                        nums[0] *= -1\\n                        break\\n                else:\\n                    if k % 2 == 0:\\n                        break\\n                    else:\\n                        nums[0] *= -1\\n                        break\\n\\n        return sum(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420953,
                "title": "easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size() && k>0; i++)\\n        {\\n           if(nums[i]>=0)\\n               break;\\n            nums[i]*=-1;\\n            k--;\\n        }\\n        sort(nums.begin(), nums.end());\\n        if(k%2)\\n            nums[0]*=-1;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int sum=0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size() && k>0; i++)\\n        {\\n           if(nums[i]>=0)\\n               break;\\n            nums[i]*=-1;\\n            k--;\\n        }\\n        sort(nums.begin(), nums.end());\\n        if(k%2)\\n            nums[0]*=-1;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            sum+=nums[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395789,
                "title": "python3-priority-queue-very-easy",
                "content": "\\tclass Solution:\\n\\t\\tdef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n\\t\\t\\theapq.heapify(nums)\\n\\t\\t\\twhile k > 0:\\n\\t\\t\\t\\tval=heapq.heappop(nums)\\n\\t\\t\\t\\tval *=  -1\\n\\t\\t\\t\\theapq.heappush(nums,val)\\n\\t\\t\\t\\tk = k -1\\n\\t\\t\\treturn sum(nums)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n\\t\\t\\theapq.heapify(nums)\\n\\t\\t\\twhile k > 0:\\n\\t\\t\\t\\tval=heapq.heappop(nums)\\n\\t\\t\\t\\tval *=  -1\\n\\t\\t\\t\\theapq.heappush(nums,val)\\n\\t\\t\\t\\tk = k -1\\n\\t\\t\\treturn sum(nums)",
                "codeTag": "Java"
            },
            {
                "id": 1388198,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i:nums)\\n            pq.push(i);\\n        while(k--)\\n        {\\n            int x=pq.top(); pq.pop();\\n            pq.push(x * -1);\\n        }\\n        while(!pq.empty())\\n        {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) \\n    {\\n        int res=0;\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n        for(int i:nums)\\n            pq.push(i);\\n        while(k--)\\n        {\\n            int x=pq.top(); pq.pop();\\n            pq.push(x * -1);\\n        }\\n        while(!pq.empty())\\n        {\\n            res += pq.top();\\n            pq.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344662,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(), nums.end());\\n        while(k>0){\\n            k--;\\n            nums[0]=-nums[0];\\n            sort(nums.begin(), nums.end());\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            ans += nums[i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        int ans=0;\\n        sort(nums.begin(), nums.end());\\n        while(k>0){\\n            k--;\\n            nums[0]=-nums[0];\\n            sort(nums.begin(), nums.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1340418,
                "title": "easy-to-understand-java-beats-99-87",
                "content": "```class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int i=0;\\n        while(i<nums.length && nums[i]<0 && k>0){\\n            nums[i]= -nums[i];\\n            i++;\\n            k--;\\n        }\\n        \\n        if(k>0 && k%2==1){\\n            Arrays.sort(nums);\\n            nums[0]= -nums[0];\\n        }\\n        \\n        int res=0;\\n        for(int n : nums){\\n            res+=n;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int i=0;\\n        while(i<nums.length && nums[i]<0 && k>0){\\n            nums[i]= -nums[i];\\n            i++;\\n            k--;\\n        }\\n        \\n        if(k>0 && k%2==1){\\n            Arrays.sort(nums);\\n            nums[0]= -nums[0];\\n        }\\n        \\n        int res=0;\\n        for(int n : nums){\\n            res+=n;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1331217,
                "title": "c-code",
                "content": "```\\nint largestSumAfterKNegations(vector<int>& v, int k) {\\n        sort(v.begin(), v.end());\\n        \\n        int count{};\\n        //counting negative numbers\\n        for(int i = 0 ; i < v.size(); i++){\\n           if(v[i] >= 0) break;\\n            count++;\\n        }\\n        \\n        //if negative numbers are more than k\\n        if(count > k){ \\n        for(int i = 0; i < k; i++){\\n            v[i] = -v[i];\\n        }}\\n        //negative numbers less than k\\n        else{\\n            int i = 0;\\n            for(; i < count; i++){\\n               v[i] = -v[i];\\n               k--;\\n            } \\n            //k%2 to decrease the value of k\\n             k = k%2;\\n            if(k > 0){\\n             if(i==0 && k > 0) v[0] = -v[0];\\n             else if(v[i] < v[i-1] && k > 0) v[i] = -v[i];\\n             else v[i-1] = -v[i-1];}\\n           }\\n        \\n        int sum{};\\n        for(auto val : v){\\n           sum += val; \\n        }\\n        \\n        return sum;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\nint largestSumAfterKNegations(vector<int>& v, int k) {\\n        sort(v.begin(), v.end());\\n        \\n        int count{};\\n        //counting negative numbers\\n        for(int i = 0 ; i < v.size(); i++){\\n           if(v[i] >= 0) break;\\n            count++;\\n        }\\n        \\n        //if negative numbers are more than k\\n        if(count > k){ \\n        for(int i = 0; i < k; i++){\\n            v[i] = -v[i];\\n        }}\\n        //negative numbers less than k\\n        else{\\n            int i = 0;\\n            for(; i < count; i++){\\n               v[i] = -v[i];\\n               k--;\\n            } \\n            //k%2 to decrease the value of k\\n             k = k%2;\\n            if(k > 0){\\n             if(i==0 && k > 0) v[0] = -v[0];\\n             else if(v[i] < v[i-1] && k > 0) v[i] = -v[i];\\n             else v[i-1] = -v[i-1];}\\n           }\\n        \\n        int sum{};\\n        for(auto val : v){\\n           sum += val; \\n        }\\n        \\n        return sum;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1305157,
                "title": "java-quick-sort-faster-than-99-66",
                "content": "I am a newbie just learnt quick sort. If you know any algorithm which can make it even faster, please tell me and I will appreciate it!\\n\\n```\\npublic class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int length = nums.length;\\n        int negNum = 0;\\n        boolean[] neg = new boolean[length];\\n        for (int i = 0; i < length; i++)\\n            if (nums[i] < 0) {\\n                neg[i] = true;\\n                negNum++;\\n                nums[i] = -nums[i];\\n            }\\n\\n        quickSort(neg, nums, 0, length - 1);\\n\\n        if (k < negNum) {\\n            int reverse = 0;\\n            for (int i = 0; i < length; i++) {\\n                if (k <= reverse) {\\n                    for (int j = i; j < length; j++)\\n                        if (neg[j])\\n                            nums[j] = -nums[j];\\n\\n                    break;\\n                }\\n                else {\\n                    if (neg[i])\\n                        reverse++;\\n                }\\n            }\\n        }\\n        else {\\n            k = (k - negNum) % 2;\\n            if (k == 1)\\n                nums[length - 1] = -nums[length - 1];\\n        }\\n\\n        int answer = 0;\\n        for (int i = 0; i < length; i++)\\n            answer += nums[i];\\n\\n        return answer;\\n    }\\n\\n    public static void quickSort(boolean[] neg, int[] arr, int start, int end) {\\n        if (start >= end) return;\\n\\n        int pivot = arr[start];\\n        int i = start, j = end;\\n\\n        while (i != j) {\\n            while (i < j && arr[j] <= pivot)\\n                j--;\\n            swap(neg, arr, i, j);\\n            while (i < j && arr[i] >= pivot)\\n                i++;\\n            swap(neg, arr, i, j);\\n        }\\n\\n        quickSort(neg, arr, start, i-1);\\n        quickSort(neg, arr, i+1, end);\\n    }\\n\\n    public static void swap(boolean[] neg, int[] arr, int a, int b) {\\n        int c = arr[a];\\n        boolean cb = neg[a];\\n\\n        arr[a] = arr[b];\\n        neg[a] = neg[b];\\n\\n        arr[b] = c;\\n        neg[b] = cb;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int largestSumAfterKNegations(int[] nums, int k) {\\n        int length = nums.length;\\n        int negNum = 0;\\n        boolean[] neg = new boolean[length];\\n        for (int i = 0; i < length; i++)\\n            if (nums[i] < 0) {\\n                neg[i] = true;\\n                negNum++;\\n                nums[i] = -nums[i];\\n            }\\n\\n        quickSort(neg, nums, 0, length - 1);\\n\\n        if (k < negNum) {\\n            int reverse = 0;\\n            for (int i = 0; i < length; i++) {\\n                if (k <= reverse) {\\n                    for (int j = i; j < length; j++)\\n                        if (neg[j])\\n                            nums[j] = -nums[j];\\n\\n                    break;\\n                }\\n                else {\\n                    if (neg[i])\\n                        reverse++;\\n                }\\n            }\\n        }\\n        else {\\n            k = (k - negNum) % 2;\\n            if (k == 1)\\n                nums[length - 1] = -nums[length - 1];\\n        }\\n\\n        int answer = 0;\\n        for (int i = 0; i < length; i++)\\n            answer += nums[i];\\n\\n        return answer;\\n    }\\n\\n    public static void quickSort(boolean[] neg, int[] arr, int start, int end) {\\n        if (start >= end) return;\\n\\n        int pivot = arr[start];\\n        int i = start, j = end;\\n\\n        while (i != j) {\\n            while (i < j && arr[j] <= pivot)\\n                j--;\\n            swap(neg, arr, i, j);\\n            while (i < j && arr[i] >= pivot)\\n                i++;\\n            swap(neg, arr, i, j);\\n        }\\n\\n        quickSort(neg, arr, start, i-1);\\n        quickSort(neg, arr, i+1, end);\\n    }\\n\\n    public static void swap(boolean[] neg, int[] arr, int a, int b) {\\n        int c = arr[a];\\n        boolean cb = neg[a];\\n\\n        arr[a] = arr[b];\\n        neg[a] = neg[b];\\n\\n        arr[b] = c;\\n        neg[b] = cb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272999,
                "title": "python-simple-heap-solution-o-nlogk",
                "content": "```python\\ndef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:        \\n        heapify(nums)\\n        while nums[0] < 0 and k:\\n            heappush(nums, -heappop(nums))\\n            k -= 1\\n        if k%2:\\n            nums[0] = -nums[0]\\n        return sum(nums)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef largestSumAfterKNegations(self, nums: List[int], k: int) -> int:        \\n        heapify(nums)\\n        while nums[0] < 0 and k:\\n            heappush(nums, -heappop(nums))\\n            k -= 1\\n        if k%2:\\n            nums[0] = -nums[0]\\n        return sum(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1265322,
                "title": "o-n-min-k-n-logn-no-sort-only-negatives-in-minheap-and-some-idea-for-special-case-o-n-d",
                "content": "```\\n\\t\\t# O(N+min(K,N)*logN) idea -> divide into positive and negative nums\\n        # make two heaps, try to always remove most negative and make \\n        # him positive, if over then take smallest positive\\n        # and make it neg, if odd count\\n        # if even count just discard\\n        res = 0\\n        negs = [x for x in nums if x < 0]\\n        heapify(negs)\\n        minPos = min([x for x in nums if x >= 0])\\n\\n        \\n        while negs and k:\\n            k -= 1\\n            v = -(heappop(negs))\\n            nums.append(v) # he is now a positive number so he\\n            minPos = min(minPos, v) #  is included in minPos (testcase 78)!\\n            \\n        if negs and k==0:\\n            return  sum(negs) + sum([x for x in nums if x > 0])\\n        \\n        elif k % 2:\\n            return res + sum([x for x in nums if x >= 0]) - 2*minPos\\n        \\n        return  sum([x for x in nums if x >= 0])\\n    \\n    \\n        # can do quickselect for K smallest.. negs O(Negs) but too lazy\\n        # another optimization, if K > no. of negatives THEN no \\n        # q needed!!! just add all absolute values - min abs() \\n        # and return  :D\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\t\\t# O(N+min(K,N)*logN) idea -> divide into positive and negative nums\\n        # make two heaps, try to always remove most negative and make \\n        # him positive, if over then take smallest positive\\n        # and make it neg, if odd count\\n        # if even count just discard\\n        res = 0\\n        negs = [x for x in nums if x < 0]\\n        heapify(negs)\\n        minPos = min([x for x in nums if x >= 0])\\n\\n        \\n        while negs and k:\\n            k -= 1\\n            v = -(heappop(negs))\\n            nums.append(v) # he is now a positive number so he\\n            minPos = min(minPos, v) #  is included in minPos (testcase 78)!\\n            \\n        if negs and k==0:\\n            return  sum(negs) + sum([x for x in nums if x > 0])\\n        \\n        elif k % 2:\\n            return res + sum([x for x in nums if x >= 0]) - 2*minPos\\n        \\n        return  sum([x for x in nums if x >= 0])\\n    \\n    \\n        # can do quickselect for K smallest.. negs O(Negs) but too lazy\\n        # another optimization, if K > no. of negatives THEN no \\n        # q needed!!! just add all absolute values - min abs() \\n        # and return  :D\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1254689,
                "title": "simple-java-solution-easy-to-understand",
                "content": "For every bit remain the cur % 10, and check (cur * 2 + bit) % 5 == 0.\\n\\n```java\\n// AC: Runtime: 3 ms, faster than 59.64% of Java online submissions for Binary Prefix Divisible By 5.\\n// Memory Usage: 39.6 MB, less than 54.20% of Java online submissions for Binary Prefix Divisible By 5.\\n// every bit remain the cur % 10, and check (cur * 2 + bit) % 5 == 0.\\n// T:O(n), S:O(1)\\n//\\nclass Solution {\\n    public List<Boolean> prefixesDivBy5(int[] nums) {\\n        List<Boolean> ret = new LinkedList<>();\\n        int cur = 0;\\n        for (int num : nums) {\\n            cur = cur * 2 + num;\\n            ret.add(cur % 5 == 0);\\n            cur %= 10;\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n// AC: Runtime: 3 ms, faster than 59.64% of Java online submissions for Binary Prefix Divisible By 5.\\n// Memory Usage: 39.6 MB, less than 54.20% of Java online submissions for Binary Prefix Divisible By 5.\\n// every bit remain the cur % 10, and check (cur * 2 + bit) % 5 == 0.\\n// T:O(n), S:O(1)\\n//\\nclass Solution {\\n    public List<Boolean> prefixesDivBy5(int[] nums) {\\n        List<Boolean> ret = new LinkedList<>();\\n        int cur = 0;\\n        for (int num : nums) {\\n            cur = cur * 2 + num;\\n            ret.add(cur % 5 == 0);\\n            cur %= 10;\\n        }\\n\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243544,
                "title": "c-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq(nums.begin(), nums.end());        \\n        \\n        while(k-- != 0) {\\n            int x = pq.top();\\n            \\n            pq.pop();\\n            x *= -1;\\n            pq.push(x);\\n        }\\n        \\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int, vector<int>, greater<int>> pq(nums.begin(), nums.end());        \\n        \\n        while(k-- != 0) {\\n            int x = pq.top();\\n            \\n            pq.pop();\\n            x *= -1;\\n            pq.push(x);\\n        }\\n        \\n        int sum = 0;\\n        while(!pq.empty()){\\n            sum += pq.top();\\n            pq.pop();\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243074,
                "title": "c-simple-easy-to-understand-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n        \\n        while(k--)\\n        {\\n            int x=pq.top();\\n            pq.pop();\\n            x=x*(-1);\\n            pq.push(x);\\n            \\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            pq.push(nums[i]);\\n        }\\n        \\n        while(k--)\\n        {\\n            int x=pq.top();\\n            pq.pop();\\n            x=x*(-1);\\n            pq.push(x);\\n            \\n        }\\n        int sum=0;\\n        while(!pq.empty()){\\n            sum+=pq.top();\\n            pq.pop();\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228053,
                "title": "simple-readable-java-code-beats-99-60-time-o-nlogn",
                "content": "```\\nclass Solution { \\n    public int largestSumAfterKNegations(int[] nums, int k) {    \\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int l = 0;\\n        while(l<nums.length && k>=1){\\n            if(nums[l]<0){\\n                nums[l]=(-1)*nums[l];\\n                k--;\\n                l++;\\n            }\\n            else{\\n               break;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        if(nums[0]==0 || k==0){\\n            for(int i=0; i<nums.length; i++){\\n                ans = ans + nums[i];\\n            }\\n        } \\n        else{  \\n            if(k%2==0){\\n                for(int i=0; i<nums.length; i++){\\n                    ans = ans + nums[i];\\n                }\\n            }\\n            else{  \\n                for(int i=0; i<nums.length; i++){\\n                    ans = ans + nums[i];\\n                }\\n                ans = ans-2*(nums[0]);\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution { \\n    public int largestSumAfterKNegations(int[] nums, int k) {    \\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int l = 0;\\n        while(l<nums.length && k>=1){\\n            if(nums[l]<0){\\n                nums[l]=(-1)*nums[l];\\n                k--;\\n                l++;\\n            }\\n            else{\\n               break;\\n            }\\n        }\\n        Arrays.sort(nums);\\n        if(nums[0]==0 || k==0){\\n            for(int i=0; i<nums.length; i++){\\n                ans = ans + nums[i];\\n            }\\n        } \\n        else{  \\n            if(k%2==0){\\n                for(int i=0; i<nums.length; i++){\\n                    ans = ans + nums[i];\\n                }\\n            }\\n            else{  \\n                for(int i=0; i<nums.length; i++){\\n                    ans = ans + nums[i];\\n                }\\n                ans = ans-2*(nums[0]);\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223059,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n            sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n                if(nums[i]<0 ){\\n                        if(k>0){\\n                                nums[i]=-nums[i];\\n                                k--;\\n                        }\\n                        else{\\n                                break;\\n                        }\\n                }\\n        }\\n            int res=0;\\n            for(int x:nums){\\n                    res+=x;\\n            }\\n            cout<<res;\\n            if(k==0 or k%2==0){\\n                    return res;\\n            }\\n            sort(nums.begin(),nums.end());\\n            res=res-2*nums[0];\\n            return res;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\\n            sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n                if(nums[i]<0 ){\\n                        if(k>0){\\n                                nums[i]=-nums[i];\\n                                k--;\\n                        }\\n                        else{\\n                                break;\\n                        }\\n                }\\n        }\\n            int res=0;\\n            for(int x:nums){\\n                    res+=x;\\n            }\\n            cout<<res;\\n            if(k==0 or k%2==0){\\n                    return res;\\n            }\\n            sort(nums.begin(),nums.end());\\n            res=res-2*nums[0];\\n            return res;\\n            \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1184981,
                "title": "java-o-nlogn-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int i = 0;\\n       while(K > 0) {\\n           if(A[i] > 0) {\\n               if(K % 2 == 0)\\n                   K = 0;\\n               else {\\n                   A[i] = -1*A[i];\\n                   K = 0;\\n               }\\n           }\\n           else if(A[i] < 0){\\n               if(i + 1 != A.length && A[i + 1] > 0 && A[i + 1] > -1*A[i]) {\\n                   K--;\\n                   if(K % 2 == 0) {\\n                       A[i] = -1* A[i];\\n                       K = 0;\\n                       \\n                   }\\n                   else{\\n                       K = 0;\\n                       }\\n               }\\n               else{\\n               A[i] = -1* A[i];\\n               K--;\\n               i++;\\n               }\\n           }\\n           else{\\n               K = 0;\\n           }\\n       }\\n        int sum = 0;\\n        for(int j = 0; j < A.length; j++) {\\n            sum += A[j];\\n        }\\n        return sum;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int i = 0;\\n       while(K > 0) {\\n           if(A[i] > 0) {\\n               if(K % 2 == 0)\\n                   K = 0;\\n               else {\\n                   A[i] = -1*A[i];\\n                   K = 0;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 1155292,
                "title": "c-0ms-100-basket-sort-with-comments",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Maximize Sum Of Array After K Negations.\\nMemory Usage: 9.1 MB, less than 41.00% of C++ online submissions for Maximize Sum Of Array After K Negations.\\n**General idea:** \\n1. Use basket sort and contain all numbers into array table\\n2. Travers through negative numbers and do two operation : transforme (K negative numbers) and find the greater negative number (flag - for mark : we transform all negative numbers or not) and culculate total sum\\n3.  Travers through positive numbers : culculate total sum and find the minimal positive number.\\n4.  After these if we have K is even or we have 0 in array - our sum is answer;\\n in other case we check mn and mp (minimal negative and minimal positive number) and delete minimal from sum. \\n\\n```\\nclass Solution {\\npublic:\\n  int largestSumAfterKNegations(vector<int>& A, int K) {\\n    int table[201] = {0}, sum = 0, i = 0, j = -100, mn = -1000, mp = 1000;\\n    bool flag = false;\\n    \\n    for(int i = 0 ; i != A.size(); i++) table[A[i] + 100]++;\\n    \\n    for(;i != 100 && K;i++,j++){\\n      if(table[i]){\\n        mn = j;\\n        if(K >= table[i]) {sum -= j*table[i]; K -= table[i];} \\n        else {sum -= j*K; sum += j*(table[i] - K); K = 0; flag = true;} \\n      }\\n    }\\n    for(;i != 100;i++,j++){\\n      if(table[i]){\\n        flag = true;\\n        mn = j;\\n        sum += j*table[i]; \\n      }\\n    }\\n    i = 200, j = 100;\\n    for(;j ;i--,j--){\\n      if(table[i]){\\n        mp = j;\\n        sum += j*table[i]; \\n      }\\n    }\\n   \\n    if(table[100] || K%2 == 0) return sum;\\n    if(!flag || mn == -1000) mn = -mn;\\n   \\n    return mp < mn ? sum - mp*2 : sum - mn*2;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int largestSumAfterKNegations(vector<int>& A, int K) {\\n    int table[201] = {0}, sum = 0, i = 0, j = -100, mn = -1000, mp = 1000;\\n    bool flag = false;\\n    \\n    for(int i = 0 ; i != A.size(); i++) table[A[i] + 100]++;\\n    \\n    for(;i != 100 && K;i++,j++){\\n      if(table[i]){\\n        mn = j;\\n        if(K >= table[i]) {sum -= j*table[i]; K -= table[i];} \\n        else {sum -= j*K; sum += j*(table[i] - K); K = 0; flag = true;} \\n      }\\n    }\\n    for(;i != 100;i++,j++){\\n      if(table[i]){\\n        flag = true;\\n        mn = j;\\n        sum += j*table[i]; \\n      }\\n    }\\n    i = 200, j = 100;\\n    for(;j ;i--,j--){\\n      if(table[i]){\\n        mp = j;\\n        sum += j*table[i]; \\n      }\\n    }\\n   \\n    if(table[100] || K%2 == 0) return sum;\\n    if(!flag || mn == -1000) mn = -mn;\\n   \\n    return mp < mn ? sum - mp*2 : sum - mn*2;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100048,
                "title": "really-simple-solution-using-a-min-heap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n        int total = accumulate(A.begin(), A.end(), 0);\\n        priority_queue<int, vector<int>, greater<int>> q;\\n        for(int i : A)  q.push(i);\\n        while(k--){\\n            int t = q.top();\\n            q.pop();\\n            q.push((-t));\\n            total = total + ((-t) - t);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n        int total = accumulate(A.begin(), A.end(), 0);\\n        priority_queue<int, vector<int>, greater<int>> q;\\n        for(int i : A)  q.push(i);\\n        while(k--){\\n            int t = q.top();\\n            q.pop();\\n            q.push((-t));\\n            total = total + ((-t) - t);\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1078815,
                "title": "faster-than-100-percent-c",
                "content": "sort(A.begin(),A.end());\\n        int n=A.size();\\n        int i;\\n        int sum=0;\\n        int negative_c=0;\\n        if(A[0]>=0&&k%2==0)\\n        {\\n            for(i=0;i<n;i++)\\n            {\\n                sum+=A[i];\\n            }\\n        }\\n        else if(A[0]>=0&&k%2==1)\\n        {\\n             for(i=0;i<n;i++)\\n            {\\n                sum+=A[i];\\n            }\\n            sum-=A[0];\\n            sum-=A[0];\\n        }\\n        else \\n        {\\n            for(i=0;i<n;i++)\\n            {\\n                if(A[i]<0)\\n                {\\n                    negative_c++;\\n                }\\n            }\\n            if(negative_c==k)\\n            {\\n                for(i=0;i<n;i++)\\n                {\\n                    sum+=abs(A[i]);\\n                }\\n            }\\n            else if(negative_c>k)\\n            {\\n                for(i=0;i<n;i++)\\n                {\\n                    if(k>0&&A[i]<0)\\n                    {\\n                        sum+=abs(A[i]);\\n                        k--;\\n                    }\\n                    else if(k<=0)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                }\\n            }\\n            else if(k>negative_c)\\n            {\\n                k=k-negative_c;\\n                for(i=0;i<n;i++)\\n                {\\n                    A[i]=abs(A[i]);\\n                }\\n                sort(A.begin(),A.end());\\n                if(k%2==0)\\n                {\\n                    for(i=0;i<n;i++)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                }\\n                else\\n                {\\n                    for(i=0;i<n;i++)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                    sum-=A[0];\\n                    sum-=A[0];\\n                }\\n            }\\n        }\\n        return sum;",
                "solutionTags": [],
                "code": "sort(A.begin(),A.end());\\n        int n=A.size();\\n        int i;\\n        int sum=0;\\n        int negative_c=0;\\n        if(A[0]>=0&&k%2==0)\\n        {\\n            for(i=0;i<n;i++)\\n            {\\n                sum+=A[i];\\n            }\\n        }\\n        else if(A[0]>=0&&k%2==1)\\n        {\\n             for(i=0;i<n;i++)\\n            {\\n                sum+=A[i];\\n            }\\n            sum-=A[0];\\n            sum-=A[0];\\n        }\\n        else \\n        {\\n            for(i=0;i<n;i++)\\n            {\\n                if(A[i]<0)\\n                {\\n                    negative_c++;\\n                }\\n            }\\n            if(negative_c==k)\\n            {\\n                for(i=0;i<n;i++)\\n                {\\n                    sum+=abs(A[i]);\\n                }\\n            }\\n            else if(negative_c>k)\\n            {\\n                for(i=0;i<n;i++)\\n                {\\n                    if(k>0&&A[i]<0)\\n                    {\\n                        sum+=abs(A[i]);\\n                        k--;\\n                    }\\n                    else if(k<=0)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                }\\n            }\\n            else if(k>negative_c)\\n            {\\n                k=k-negative_c;\\n                for(i=0;i<n;i++)\\n                {\\n                    A[i]=abs(A[i]);\\n                }\\n                sort(A.begin(),A.end());\\n                if(k%2==0)\\n                {\\n                    for(i=0;i<n;i++)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                }\\n                else\\n                {\\n                    for(i=0;i<n;i++)\\n                    {\\n                        sum+=A[i];\\n                    }\\n                    sum-=A[0];\\n                    sum-=A[0];\\n                }\\n            }\\n        }\\n        return sum;",
                "codeTag": "Unknown"
            },
            {
                "id": 986268,
                "title": "faster-than-99-of-c-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        \\n        sort(A.begin(),A.end());\\n        int n = A.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i] < 0 && K>0)   // if element is negative, reverse it until k iterations\\n            {\\n                A[i]=A[i]*(-1);\\n                K--;\\n            }\\n        }\\n        int index=min_element(A.begin(),A.end())-A.begin(); // find index of minimum element\\n        \\n        if(K%2==1)   // if k is even, no change in array required.. if odd, then reverse                           // smallest\\n        {\\n            A[index]=A[index]*(-1);\\n          \\n        }\\n        int sum=0;\\n\\n        for(auto it:A)\\n            sum+=it;\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        \\n        sort(A.begin(),A.end());\\n        int n = A.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(A[i] < 0 && K>0)   // if element is negative, reverse it until k iterations\\n            {\\n                A[i]=A[i]*(-1);\\n                K--;\\n            }\\n        }\\n        int index=min_element(A.begin(),A.end())-A.begin(); // find index of minimum element\\n        \\n        if(K%2==1)   // if k is even, no change in array required.. if odd, then reverse                           // smallest\\n        {\\n            A[index]=A[index]*(-1);\\n          \\n        }\\n        int sum=0;\\n\\n        for(auto it:A)\\n            sum+=it;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976835,
                "title": "sort-and-then-one-pass",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int i=0,s=0;\\n        while(K>0 && A[i]<0)\\n        {\\n            s-=A[i];\\n            K--;\\n            i++;\\n        }\\n        if(A[0]<0 && K%2!=0 && A[i]!=0)\\n        {\\n            if(-A[i-1]<A[i])\\n            {\\n                s+=2*A[i-1];\\n            }\\n            else\\n            {\\n                s-=A[i++];\\n            }\\n        }\\n        else if(A[i]!=0 && K%2!=0)\\n        {\\n            s-=A[i++];\\n        }\\n        for(;i<A.length;i++)\\n        {\\n            s+=A[i];\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int i=0,s=0;\\n        while(K>0 && A[i]<0)\\n        {\\n            s-=A[i];\\n            K--;\\n            i++;\\n        }\\n        if(A[0]<0 && K%2!=0 && A[i]!=0)\\n        {\\n            if(-A[i-1]<A[i])\\n            {\\n                s+=2*A[i-1];\\n            }\\n            else\\n            {\\n                s-=A[i++];\\n            }\\n        }\\n        else if(A[i]!=0 && K%2!=0)\\n        {\\n            s-=A[i++];\\n        }\\n        for(;i<A.length;i++)\\n        {\\n            s+=A[i];\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890598,
                "title": "python-heap-time-o-n-k-ln-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K):\\n            a = heapq.heappop(A)\\n            heapq.heappush(A, -a)        \\n        return sum(A)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        for _ in range(K):\\n            a = heapq.heappop(A)\\n            heapq.heappush(A, -a)        \\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857619,
                "title": "c-simple-o-nlogn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n        \\n        sort(A.begin(),A.end());\\n        int n = A.size(),sum=0,neg=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            if(A[i]<0)\\n                neg++;\\n        }\\n      \\n        if(neg>=k)\\n            for(int i=0;i<k;i++)\\n                A[i]*=-1;\\n        else{\\n            for(int i=0;i<neg;i++)\\n                A[i]*=-1;\\n            k-=neg;\\n            sort(A.begin(),A.end());    \\n            if(k%2!=0)\\n                A[0]*=-1;\\n            }\\n       \\n        for(int i=0;i<n;i++)\\n            sum+=A[i];\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int k) {\\n        \\n        sort(A.begin(),A.end());\\n        int n = A.size(),sum=0,neg=0;\\n        \\n        for(int i=0;i<A.size();i++){\\n            if(A[i]<0)\\n                neg++;\\n        }\\n      \\n        if(neg>=k)\\n            for(int i=0;i<k;i++)\\n                A[i]*=-1;\\n        else{\\n            for(int i=0;i<neg;i++)\\n                A[i]*=-1;\\n            k-=neg;\\n            sort(A.begin(),A.end());    \\n            if(k%2!=0)\\n                A[0]*=-1;\\n            }\\n       \\n        for(int i=0;i<n;i++)\\n            sum+=A[i];\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854867,
                "title": "go-solution-with-sort",
                "content": "https://github.com/phea/leetcode-go\\n```go\\nfunc largestSumAfterKNegations(A []int, K int) int {\\n\\tsort.Ints(A)\\n\\tvar pos int\\n\\tfor K > 0 {\\n\\t\\tif A[pos] == 0 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif pos < len(A)-1 {\\n\\t\\t\\tif (A[pos] < 0 && A[pos+1] < 0) || A[pos]*-1 > A[pos+1] {\\n\\t\\t\\t\\tA[pos] *= -1\\n\\t\\t\\t\\tpos++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tA[pos] *= -1\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tA[pos] *= -1\\n\\t\\t}\\n\\n\\t\\tK--\\n\\t}\\n\\n\\tvar total int\\n\\tfor _, n := range A {\\n\\t\\ttotal += n\\n\\t}\\n\\n\\treturn total\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc largestSumAfterKNegations(A []int, K int) int {\\n\\tsort.Ints(A)\\n\\tvar pos int\\n\\tfor K > 0 {\\n\\t\\tif A[pos] == 0 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif pos < len(A)-1 {\\n\\t\\t\\tif (A[pos] < 0 && A[pos+1] < 0) || A[pos]*-1 > A[pos+1] {\\n\\t\\t\\t\\tA[pos] *= -1\\n\\t\\t\\t\\tpos++\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tA[pos] *= -1\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tA[pos] *= -1\\n\\t\\t}\\n\\n\\t\\tK--\\n\\t}\\n\\n\\tvar total int\\n\\tfor _, n := range A {\\n\\t\\ttotal += n\\n\\t}\\n\\n\\treturn total\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 845908,
                "title": "java-brutal-force",
                "content": "I don\\'t think this should be an easy quesiton.\\n```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        int m = A.length, neg = 0, min = Integer.MAX_VALUE, sum = 0;\\n        for (int n : A) {\\n            if (n < 0) neg++;\\n            else min = Math.min(n, min);  //find the min to keep turning;\\n            sum += n;\\n        }\\n        if (neg != 0) {\\n            if (neg > K) { // find the smallest negs to turn to positive;\\n                PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);  // min queue\\n                for (int n : A) {\\n                    if (n < 0) pq.offer(n);\\n                    if (pq.size() > K) pq.poll();\\n                }\\n                while (!pq.isEmpty()) sum -= 2 * pq.poll();\\n                return sum;\\n            }\\n            K -= neg;  // turn all neg to positive;\\n            for (int n : A) {\\n                if (n < 0) {\\n                    n *= -1;\\n                    sum += n * 2;\\n                }\\n                min = Math.min(n, min);\\n            }\\n        }\\n        if (K % 2 == 0) return sum;\\n        return sum - 2 * min;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        int m = A.length, neg = 0, min = Integer.MAX_VALUE, sum = 0;\\n        for (int n : A) {\\n            if (n < 0) neg++;\\n            else min = Math.min(n, min);  //find the min to keep turning;\\n            sum += n;\\n        }\\n        if (neg != 0) {\\n            if (neg > K) { // find the smallest negs to turn to positive;\\n                PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);  // min queue\\n                for (int n : A) {\\n                    if (n < 0) pq.offer(n);\\n                    if (pq.size() > K) pq.poll();\\n                }\\n                while (!pq.isEmpty()) sum -= 2 * pq.poll();\\n                return sum;\\n            }\\n            K -= neg;  // turn all neg to positive;\\n            for (int n : A) {\\n                if (n < 0) {\\n                    n *= -1;\\n                    sum += n * 2;\\n                }\\n                min = Math.min(n, min);\\n            }\\n        }\\n        if (K % 2 == 0) return sum;\\n        return sum - 2 * min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 840510,
                "title": "very-simple-pyhon3-solution-using-sort-faster-than-50-46",
                "content": "```\\n\\t\\tfor i in range(K):\\n            A.sort()\\n            A[0] = 0 - A[0]\\n        return sum(A)\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tfor i in range(K):\\n            A.sort()\\n            A[0] = 0 - A[0]\\n        return sum(A)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 753996,
                "title": "python-with-explanation-on-greedy",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        #globally optimal strategy:\\n        #if there are negative nums, pick all of these, and pick the smaller ones first\\n        # if there are no negative nums, pick and stick to the smallest one\\n        A.sort()\\n        index = 0\\n        for i in range(len(A)): \\n            if K == 0: \\n                return sum(A)\\n            if A[i] < 0: \\n                A[i] = -A[i]\\n                K -= 1\\n            elif A[i] >= 0: # no more negative nums in A anymore\\n                #look for the smallest num in A\\n                index = A.index(min(A))\\n                break\\n        if K%2 != 0: \\n            A[index] = -A[index]\\n        return sum(A)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        #globally optimal strategy:\\n        #if there are negative nums, pick all of these, and pick the smaller ones first\\n        # if there are no negative nums, pick and stick to the smallest one\\n        A.sort()\\n        index = 0\\n        for i in range(len(A)): \\n            if K == 0: \\n                return sum(A)\\n            if A[i] < 0: \\n                A[i] = -A[i]\\n                K -= 1\\n            elif A[i] >= 0: # no more negative nums in A anymore\\n                #look for the smallest num in A\\n                index = A.index(min(A))\\n                break\\n        if K%2 != 0: \\n            A[index] = -A[index]\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753524,
                "title": "c-o-n-time-o-1-space-using-nth-element",
                "content": "```\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        bool flag_zero = 0;\\n        int max_sum = 0;\\n        int min_el = INT_MAX;\\n        \\n        std::nth_element(A.begin(), A.begin() + K, A.end());\\n        \\n        for (int x : A) {\\n            min_el = std::min(min_el, std::abs(x));\\n            \\n            if (x == 0)\\n                flag_zero = 1;\\n            \\n            if (K > 0 && x < 0) {\\n                max_sum -= x;\\n                K--;\\n            } else\\n                max_sum += x;\\n        }\\n        \\n        if (flag_zero || K % 2 == 0)\\n            return max_sum;\\n        \\n        return max_sum - 2 * min_el;    \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        bool flag_zero = 0;\\n        int max_sum = 0;\\n        int min_el = INT_MAX;\\n        \\n        std::nth_element(A.begin(), A.begin() + K, A.end());\\n        \\n        for (int x : A) {\\n            min_el = std::min(min_el, std::abs(x));\\n            \\n            if (x == 0)\\n                flag_zero = 1;\\n            \\n            if (K > 0 && x < 0) {\\n                max_sum -= x;\\n                K--;\\n            } else\\n                max_sum += x;\\n        }\\n        \\n        if (flag_zero || K % 2 == 0)\\n            return max_sum;\\n        \\n        return max_sum - 2 * min_el;    \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 752030,
                "title": "java-99-88",
                "content": "class Solution {\\n\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum =0;\\n        int i=0;\\n        int index=0;\\n        while(K-- >0){\\n            index=i;\\n            if(A[i]>A[i+1]){\\n                i++;\\n                index=i;\\n            }\\n            A[index]=-A[index];\\n        }\\n        for(int a:A){\\n            sum+=a;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum =0;\\n        int i=0;\\n        int index=0;\\n        while(K-- >0){\\n            index=i;\\n            if(A[i]>A[i+1]){\\n                i++;\\n                index=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 744515,
                "title": "java-with-comments-using-priority-queue-very-short-and-simple",
                "content": "```\\n public int largestSumAfterKNegations(int[] A, int K) {    \\n    PriorityQueue<Integer>  minHeap = new  PriorityQueue<Integer>();     \\n    for ( int a : A ) minHeap.add(a);\\n    // for K times , pick the smallest element , multiple by -1 andd into PQ .\\n    // replace A[i] with -A[i], and we repeat this process K times in total.\\n    while( K-- > 0 )  minHeap.add((-1)*minHeap.remove());    \\n    // Now add all elements , which will give max sum .        \\n    int sum =0 ;\\n    while(!minHeap.isEmpty()) sum+= minHeap.remove();\\n    return(sum);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int largestSumAfterKNegations(int[] A, int K) {    \\n    PriorityQueue<Integer>  minHeap = new  PriorityQueue<Integer>();     \\n    for ( int a : A ) minHeap.add(a);\\n    // for K times , pick the smallest element , multiple by -1 andd into PQ .\\n    // replace A[i] with -A[i], and we repeat this process K times in total.\\n    while( K-- > 0 )  minHeap.add((-1)*minHeap.remove());    \\n    // Now add all elements , which will give max sum .        \\n    int sum =0 ;\\n    while(!minHeap.isEmpty()) sum+= minHeap.remove();\\n    return(sum);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732238,
                "title": "simple-python-solution-sort-by-absolute-value",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort(key=abs, reverse=True)\\n        k = 0\\n        for i in range(len(A)):\\n            if A[i] < 0:\\n                A[i] = -A[i]\\n                k += 1\\n            if k >= K:\\n                return sum(A)\\n        if (K - k) % 2 == 1:\\n            A[-1] = -A[-1]\\n        return sum(A)\\n```\\nWorks well with very large K.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort(key=abs, reverse=True)\\n        k = 0\\n        for i in range(len(A)):\\n            if A[i] < 0:\\n                A[i] = -A[i]\\n                k += 1\\n            if k >= K:\\n                return sum(A)\\n        if (K - k) % 2 == 1:\\n            A[-1] = -A[-1]\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671331,
                "title": "java-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n        int i = 0;\\n        while(A[i] < 0 && K > 0) {\\n            A[i] = -1 * A[i];\\n            i++;\\n            K--;\\n        }\\n        Arrays.sort(A);\\n        if(K % 2 == 1) {\\n            A[0] = -1 * A[0];\\n        }\\n        for(int j = 0; j < A.length; j++) {\\n            sum += A[j];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        Arrays.sort(A);\\n        int sum = 0;\\n        int i = 0;\\n        while(A[i] < 0 && K > 0) {\\n            A[i] = -1 * A[i];\\n            i++;\\n            K--;\\n        }\\n        Arrays.sort(A);\\n        if(K % 2 == 1) {\\n            A[0] = -1 * A[0];\\n        }\\n        for(int j = 0; j < A.length; j++) {\\n            sum += A[j];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649806,
                "title": "easy-to-understand-solution-c",
                "content": "The solution is to invert the negative numbers first (as many as possible), so that sum becomes larger. After all the negatives are inverted and we still have K > 0, check for following:\\n* If K is even, return the sum of the array (as no negatives are present at this point)\\n* If K is odd, we need to change sign only for minimum element in current array (so subtract twice of that minimum element from new sum calculated)\\n\\nHope this helps for someone! : )\\n```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(),A.end());\\n        for(int i=0;i<A.size() && K>0 && A[i]<0;i++,K--)\\n            A[i] = -A[i];\\n        int sum = 0, minVal = INT_MAX;\\n        for(int x : A){\\n            sum += x;\\n            minVal = min(x,minVal);\\n        }\\n        if(K & 1)\\n            return (sum - 2 * minVal);\\n        else\\n            return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(),A.end());\\n        for(int i=0;i<A.size() && K>0 && A[i]<0;i++,K--)\\n            A[i] = -A[i];\\n        int sum = 0, minVal = INT_MAX;\\n        for(int x : A){\\n            sum += x;\\n            minVal = min(x,minVal);\\n        }\\n        if(K & 1)\\n            return (sum - 2 * minVal);\\n        else\\n            return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645310,
                "title": "java-2-different-solutions-accepted",
                "content": "ok lets do this!\\n\\nFirst of all this is a problem which can solved using **Greedy Algorithm**!\\nwhy?\\n\\n# intuiton-\\n**we are said to negate an element of the array for k times,and maximise the sum of the array elements!\\nso basically what should come to mind immediately that we should negate the smallest number in the array so that our maximum gets decreased as little as possible!\\nhence we are greedily choosing the lowest element at each iteration !**\\n\\nfirst thing that comes to mind is that we should sort the array in ascending order!\\nthat is correct ,but remember k can be greater than one ,hence we need to sort the array for each iteration of k;\\n\\ncode-\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n    Arrays.sort(A);\\n        int t=0;\\n        while(K-- > 0)\\n        {\\n     t=A[0];    //each time choosing the smallest element\\n    A[0]=-t;\\n            Arrays.sort(A);\\n        }\\n        \\n        int s=0;\\n        for(int i  :A)\\n        {\\n            s+=i;\\n        }\\n        return s;       \\n    }\\n}\\n```\\n\\nthis solution does the job but we are sorting the array k times,hence the runtime will be higher!\\n\\nwe can get through this problem of sorting everytime by using a **priority queue**!\\nthe priority queue will itself maintain its first element as the lowest one!\\n\\ncode-\\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n    \\n        PriorityQueue<Integer> q = new PriorityQueue<>();  //queue will maintain ascending order \\n        for(int k :  A)\\n        {\\n            q.add(k);\\n        }\\n    \\n    \\n    while(K-- > 0)\\n    {\\n       int x=q.poll();\\n        q.add(-x);  //adding the negative value of the lowest element\\n    }\\n    int s=0;\\n        \\n       while(!q.isEmpty())\\n        {\\n            s+=q.poll() ;\\n        }\\n   return s;\\n    }\\n}\\n```\\n\\n\\nhope it helps!\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n    Arrays.sort(A);\\n        int t=0;\\n        while(K-- > 0)\\n        {\\n     t=A[0];    //each time choosing the smallest element\\n    A[0]=-t;\\n            Arrays.sort(A);\\n        }\\n        \\n        int s=0;\\n        for(int i  :A)\\n        {\\n            s+=i;\\n        }\\n        return s;       \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n    \\n        PriorityQueue<Integer> q = new PriorityQueue<>();  //queue will maintain ascending order \\n        for(int k :  A)\\n        {\\n            q.add(k);\\n        }\\n    \\n    \\n    while(K-- > 0)\\n    {\\n       int x=q.poll();\\n        q.add(-x);  //adding the negative value of the lowest element\\n    }\\n    int s=0;\\n        \\n       while(!q.isEmpty())\\n        {\\n            s+=q.poll() ;\\n        }\\n   return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633557,
                "title": "simpla-java-priority-queue-implementation",
                "content": "Though Process\\n1. Each time we need to flip smallest number\\n2. To Track smallest number use priority queue\\n3. Alternatively you can use loop to track smallest number but it will be tedious to do so\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> q=new PriorityQueue<>();\\n        int sum=0;\\n        for(int i=0;i<A.length;i++)\\n        {\\n            q.offer(A[i]);\\n            sum=sum+A[i];\\n        }\\n        for(int i=1;i<=K;i++)\\n        {\\n            int item=q.poll();\\n            sum=sum-item;\\n            q.offer(-item);\\n            sum=sum-item;\\n        }\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        PriorityQueue<Integer> q=new PriorityQueue<>();\\n        int sum=0;\\n        for(int i=0;i<A.length;i++)\\n        {\\n            q.offer(A[i]);\\n            sum=sum+A[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 629515,
                "title": "python-3-heap-97-runtime",
                "content": "```\\nfrom heapq import *\\n\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        \\n        while(K>0):\\n            min_v = heapq.heappop(A)\\n            heapq.heappush(A, min_v * -1)\\n            K -= 1\\n            \\n        return sum(A)",
                "solutionTags": [],
                "code": "```\\nfrom heapq import *\\n\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        \\n        while(K>0):\\n            min_v = heapq.heappop(A)\\n            heapq.heappush(A, min_v * -1)\\n            K -= 1\\n            \\n        return sum(A)",
                "codeTag": "Java"
            },
            {
                "id": 610700,
                "title": "cpp-simple-priority-queue-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int, vector<int>, greater<int> > q(begin(A),end(A));\\n        int x;\\n        while(K--){\\n            x=q.top();\\n            q.pop();\\n            q.push(-x);\\n        }\\n        int s=0;\\n        while(!q.empty()){\\n            s+=q.top();\\n            q.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int, vector<int>, greater<int> > q(begin(A),end(A));\\n        int x;\\n        while(K--){\\n            x=q.top();\\n            q.pop();\\n            q.push(-x);\\n        }\\n        int s=0;\\n        while(!q.empty()){\\n            s+=q.top();\\n            q.pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 595661,
                "title": "python-easy-to-understand",
                "content": "```\\n\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        for i in range(K):\\n            index = A.index(min(A))\\n            A[index] = -A[index]\\n        return sum(A)\\n\\n```\\n\\n************* If helped dont forget to give it a star******************",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        for i in range(K):\\n            index = A.index(min(A))\\n            A[index] = -A[index]\\n        return sum(A)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590356,
                "title": "c-solution-partial-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        // if there is a single item inverse the item K times \\n        if (1 == A.size())\\n            return 0 == K % 2 ? A[0] : -A[0];\\n        \\n        // use partial sort to set at most K items in order\\n        std::partial_sort(A.begin(), A.begin() + std::min(static_cast<int>(A.size()), K), A.end());\\n        \\n        // inverse by negating at most K negative items\\n        auto it = A.begin();\\n        for (; it != A.end() && *it < 0 && 0 != K; ++it, --K)\\n            *it = -*it;\\n        \\n        // if there is an odd number of inversions left\\n        // and the iterator does not address \\'0\\' value\\n        // we continue maximization by selecting\\n        // an item that the negation of will result in\\n        // the topmost maximum of the sum\\n        if (0 != K % 2 && (it == A.end() || 0 != *it))\\n        {\\n            // if the pointer is at the end then the original array consisted of\\n            // only negative numbers, then we need to inverse the last modified item\\n            // to maximize the sum\\n            if (A.end() == it)\\n                --it;\\n            // if the pointer is at a middle we need to\\n            // decide between two adjacent items which one could result better in the ultimate sum\\n            // be aware, in the modified array order could be violated since negations might have taken place\\n            // in the above\\n            // if the pointer is at the beginning then the array consists of only positive numbers\\n            // then we need to only inverse the first since it is the smallest\\n            else if (A.begin() != it)\\n                it = std::min(it - 1, it, [](auto a, auto b){ return *a < *b; });\\n            *it = -*it;\\n        }\\n        \\n        // summarize the result array\\n        return std::accumulate(A.begin(), A.end(), 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        // if there is a single item inverse the item K times \\n        if (1 == A.size())\\n            return 0 == K % 2 ? A[0] : -A[0];\\n        \\n        // use partial sort to set at most K items in order\\n        std::partial_sort(A.begin(), A.begin() + std::min(static_cast<int>(A.size()), K), A.end());\\n        \\n        // inverse by negating at most K negative items\\n        auto it = A.begin();\\n        for (; it != A.end() && *it < 0 && 0 != K; ++it, --K)\\n            *it = -*it;\\n        \\n        // if there is an odd number of inversions left\\n        // and the iterator does not address \\'0\\' value\\n        // we continue maximization by selecting\\n        // an item that the negation of will result in\\n        // the topmost maximum of the sum\\n        if (0 != K % 2 && (it == A.end() || 0 != *it))\\n        {\\n            // if the pointer is at the end then the original array consisted of\\n            // only negative numbers, then we need to inverse the last modified item\\n            // to maximize the sum\\n            if (A.end() == it)\\n                --it;\\n            // if the pointer is at a middle we need to\\n            // decide between two adjacent items which one could result better in the ultimate sum\\n            // be aware, in the modified array order could be violated since negations might have taken place\\n            // in the above\\n            // if the pointer is at the beginning then the array consists of only positive numbers\\n            // then we need to only inverse the first since it is the smallest\\n            else if (A.begin() != it)\\n                it = std::min(it - 1, it, [](auto a, auto b){ return *a < *b; });\\n            *it = -*it;\\n        }\\n        \\n        // summarize the result array\\n        return std::accumulate(A.begin(), A.end(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574462,
                "title": "c-100-fast-o-k-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(),A.end());\\n        int index=0;\\n        int i=0;\\n        int min=INT_MAX;\\n        int sum=0;\\n            while(A[i]<0 && K)\\n            {\\n                A[i]=-A[i];\\n                if(A[i]<min)\\n                {\\n                    min=A[i];\\n                    index=i;\\n                }\\n                K--;\\n                i++;\\n            }\\n            \\n              if(A[i]<min)\\n                {\\n                    min=A[i];\\n                    index=i;\\n                }\\n              if(K%2==1)\\n                A[index]=-A[index];\\n                \\n        for(int i=0;i<A.size();i++)\\n            sum+=A[i];\\n        \\n        return sum;\\n    }\\n};``\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        sort(A.begin(),A.end());\\n        int index=0;\\n        int i=0;\\n        int min=INT_MAX;\\n        int sum=0;\\n            while(A[i]<0 && K)\\n            {\\n                A[i]=-A[i];\\n                if(A[i]<min)\\n                {\\n                    min=A[i];\\n                    index=i;\\n                }\\n                K--;\\n                i++;\\n            }\\n            \\n              if(A[i]<min)\\n                {\\n                    min=A[i];\\n                    index=i;\\n                }\\n              if(K%2==1)\\n                A[index]=-A[index];\\n                \\n        for(int i=0;i<A.size();i++)\\n            sum+=A[i];\\n        \\n        return sum;\\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530233,
                "title": "c-solution-use-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int,vector<int>,greater<int>> q;\\n        for(int i:A)q.push(i);\\n        int res=0;\\n        while(K--){\\n            if(q.top()==0)break;\\n            int k=q.top();q.pop();\\n            q.push(k*-1);\\n        }\\n        while(!q.empty()){\\n            res+=q.top();q.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestSumAfterKNegations(vector<int>& A, int K) {\\n        priority_queue<int,vector<int>,greater<int>> q;\\n        for(int i:A)q.push(i);\\n        int res=0;\\n        while(K--){\\n            if(q.top()==0)break;\\n            int k=q.top();q.pop();\\n            q.push(k*-1);\\n        }\\n        while(!q.empty()){\\n            res+=q.top();q.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507282,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        i = 0\\n        while K > 0:\\n            A[i] = -A[i]\\n            if A[i] > A[i+1]:\\n                i = i+1\\n            K = K-1\\n            \\n        return sum(A)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestSumAfterKNegations(self, A, K):\\n        \"\"\"\\n        :type A: List[int]\\n        :type K: int\\n        :rtype: int\\n        \"\"\"\\n        A.sort()\\n        i = 0\\n        while K > 0:\\n            A[i] = -A[i]\\n            if A[i] > A[i+1]:\\n                i = i+1\\n            K = K-1\\n            \\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495271,
                "title": "a-c-python-3-solution-recursion-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort()\\n        # print(\" A = \", A)\\n        # print(\"K = \", K)\\n\\n        if (K == 0):\\n            return sum(A)\\n        elif (K == 1):\\n\\n            A[0] = 0-A[0]\\n            return sum(A)\\n        elif (K > 1):\\n\\n            A[0] = 0-A[0]\\n            return self.largestSumAfterKNegations(A, K-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        A.sort()\\n        # print(\" A = \", A)\\n        # print(\"K = \", K)\\n\\n        if (K == 0):\\n            return sum(A)\\n        elif (K == 1):\\n\\n            A[0] = 0-A[0]\\n            return sum(A)\\n        elif (K > 1):\\n\\n            A[0] = 0-A[0]\\n            return self.largestSumAfterKNegations(A, K-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484496,
                "title": "java-solution-using-priority-queue",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        if(A == null || A.length == 0)\\n            return 0;\\n        int sum = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        for(int num : A)\\n            pq.add(num);\\n        while(K>0)\\n        {\\n            int num = pq.poll();\\n            pq.add(num*-1);\\n            K--;\\n        }\\n        while(!pq.isEmpty())\\n        {\\n            sum+=pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int K) {\\n        if(A == null || A.length == 0)\\n            return 0;\\n        int sum = 0;\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>();\\n        for(int num : A)\\n            pq.add(num);\\n        while(K>0)\\n        {\\n            int num = pq.poll();\\n            pq.add(num*-1);\\n            K--;\\n        }\\n        while(!pq.isEmpty())\\n        {\\n            sum+=pq.poll();\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 451306,
                "title": "o-klogn-solution",
                "content": "Data Structure Used : \\n\\tMin-Heap\\nLogic : \\n\\t  &nbsp; 1) If minimum element is negative, we just change sign of that element and push back into min heap.\\n\\t&nbsp; 2) If minimum element in the array is non negative: ( Base case )\\n\\t\\t&nbsp; &nbsp; a) if K is even:\\n\\t\\t\\t&nbsp; &nbsp; We can just use same index for changing sign even number of times, so our answer is just sum of the array.\\n\\t\\t&nbsp; &nbsp; b) If K is odd:\\n\\t\\t\\t&nbsp; &nbsp; We can do same as before, hence K odd is as good as K  = 1, so we just change sign of minimum element.\\n\\n\\nPython3 Code : \\n\\n```\\nimport heapq \\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        while K:\\n            if A[0] >= 0:\\n                if K & 1:\\n                    heapq.heappush(A,-1*heapq.heappop(A))                    \\n                break\\n            else:\\n                heapq.heappush(A,-1*heapq.heappop(A))                      \\n            K -= 1\\n        return sum(A)\\n```\\nTime Complexity   :   O(N+KLogN)\\nSpace Complexity  :  O(1)",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq \\nclass Solution:\\n    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n        heapq.heapify(A)\\n        while K:\\n            if A[0] >= 0:\\n                if K & 1:\\n                    heapq.heappush(A,-1*heapq.heappop(A))                    \\n                break\\n            else:\\n                heapq.heappush(A,-1*heapq.heappop(A))                      \\n            K -= 1\\n        return sum(A)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 429423,
                "title": "java-greedy-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int largestSumAfterKNegations(int[] A, int K) {\\n\\t\\t\\tQueue<Integer> q = new PriorityQueue<>();\\n\\t\\t\\tfor(int a:A) q.add(a);\\n\\t\\t\\twhile(K>0){\\n\\t\\t\\t\\tq.add(-q.poll());\\n\\t\\t\\t\\tK--;\\n\\t\\t\\t}\\n\\t\\t\\tint res = 0;\\n\\t\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\t\\tres += q.poll();\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int largestSumAfterKNegations(int[] A, int K) {\\n\\t\\t\\tQueue<Integer> q = new PriorityQueue<>();\\n\\t\\t\\tfor(int a:A) q.add(a);\\n\\t\\t\\twhile(K>0){\\n\\t\\t\\t\\tq.add(-q.poll());\\n\\t\\t\\t\\tK--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 424914,
                "title": "simple-heap-solution",
                "content": "```\\ndef largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n\\th = heapq.heapify(A)\\n\\tfor _ in range(K):\\n\\t\\tm = heapq.heappop(A)\\n\\t\\theapq.heappush(A, -m)\\n\\treturn sum(A)\\n```",
                "solutionTags": [],
                "code": "```\\ndef largestSumAfterKNegations(self, A: List[int], K: int) -> int:\\n\\th = heapq.heapify(A)\\n\\tfor _ in range(K):\\n\\t\\tm = heapq.heappop(A)\\n\\t\\theapq.heappush(A, -m)\\n\\treturn sum(A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 383851,
                "title": "java-solution-2ms-87-faster-with-comments",
                "content": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int k) {\\n        /*\\n            Greedy\\n        */\\n        \\n        // first sort the array\\n        Arrays.sort(A);\\n        \\n        /*\\n            keep fliping the negative values in the array, until \\n                there is no more negative values or\\n                k reaches zero or\\n                we are at the end of the array\\n        */\\n        int index = 0;\\n        for (; index < A.length; ++index) {\\n            if (k > 0 && A[index] < 0) {\\n                k--;\\n                A[index] = -A[index];\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        /*\\n            at this stage, if k is even, we just skip this step and calculate the sum\\n            if k is odd, \\n                if index is zero, which means whole array are all positive numbers at the begining, we simply flip the first value\\n                if index >= A.length, we are at the end of the array, flip the last value in the array\\n                if A[index] >= A[index - 1], we are at middle of the array, and we want to flip the smallest value in the array\\n                which is either A[index], or A[index - 1], so we compare them and flip the smaller one\\n        */\\n        if (k % 2 != 0) {\\n            if (index == 0) A[index] = -A[index]; \\n            else if (index >= A.length || A[index] >= A[index - 1]) A[index - 1] = -A[index - 1];\\n            else A[index] = -A[index];\\n        }\\n        \\n        int sum = 0;\\n        for (int i : A) {\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestSumAfterKNegations(int[] A, int k) {\\n        /*\\n            Greedy\\n        */\\n        \\n        // first sort the array\\n        Arrays.sort(A);\\n        \\n        /*\\n            keep fliping the negative values in the array, until \\n                there is no more negative values or\\n                k reaches zero or\\n                we are at the end of the array\\n        */\\n        int index = 0;\\n        for (; index < A.length; ++index) {\\n            if (k > 0 && A[index] < 0) {\\n                k--;\\n                A[index] = -A[index];\\n            } else {\\n                break;\\n            }\\n        }\\n        \\n        /*\\n            at this stage, if k is even, we just skip this step and calculate the sum\\n            if k is odd, \\n                if index is zero, which means whole array are all positive numbers at the begining, we simply flip the first value\\n                if index >= A.length, we are at the end of the array, flip the last value in the array\\n                if A[index] >= A[index - 1], we are at middle of the array, and we want to flip the smallest value in the array\\n                which is either A[index], or A[index - 1], so we compare them and flip the smaller one\\n        */\\n        if (k % 2 != 0) {\\n            if (index == 0) A[index] = -A[index]; \\n            else if (index >= A.length || A[index] >= A[index - 1]) A[index - 1] = -A[index - 1];\\n            else A[index] = -A[index];\\n        }\\n        \\n        int sum = 0;\\n        for (int i : A) {\\n            sum += i;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1714633,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1929395,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1835017,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1752530,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 2028770,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1941381,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1876946,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1828596,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1724874,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1699153,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1714633,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1929395,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1835017,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1752530,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 2028770,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1941381,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1876946,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1828596,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1724874,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            },
            {
                "id": 1699153,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "Such a beautiful problem..\\n"
                    },
                    {
                        "username": "meanup",
                        "content": "`Hint`\n\nOne way to approach this problem is to sort the `nums` in non-decreasing order and then iterate through the array, flipping the sign of the negative numbers until all negative numbers have been flipped (`You may choose the same index i multiple times.` as same characters can be repeated multiple times), and `k` flip has been performed.\n\nIf there is still flip remaining or `k` is `odd`, then flip the smallest absolute value in the array. Finally, return the sum of the modified array.\n\nCode [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/submissions/971227833/)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@soso_gyewo](/soso_gyewo) His hint helped me solve but I wouldn\\'t say flip the smallest absolute value. \\n\\nThink about the array after flipping all negatives. If you still have flips, then this means all negatives are already flipped. So it makes sense to only flip the smallest number k more times and not the biggest so you can maximize your sum \\n"
                    },
                    {
                        "username": "soso_gyewo",
                        "content": "what i dont understand is the question says i need to perform this exactly k times , and if lets say after negating all negative numbers, i still have to perform it 3 times(i.e k remains 3)...then how come just flipping the smallest absolute value is enough, since we need to do it 3 times more."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "One thing a beginner may not know and everyone assume you already know everything ,  a  \\' - \" in front of a variable converts the number ,if it\\'s positive  then its converted to negative , if its negative its converted to positive "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Never would have thought of heaps if I didnt look at Solutions. Tricky problem!"
                    },
                    {
                        "username": "mochiball",
                        "content": "This problem gave me headaches"
                    },
                    {
                        "username": "geekyshark",
                        "content": "remember folks, don\\'t forget to consider the case of all negative elements in the array(without 0), Happy Leetcoding"
                    },
                    {
                        "username": "laichbr",
                        "content": "Can we have -0? "
                    },
                    {
                        "username": "laichbr",
                        "content": "[@Nikhil_G002109](/Nikhil_G002109) I wish there was a way to laugh react, but sadly there is not. Don\\'t take such comments so seriously. Mainly pointing out that with a -0 there are a number of their test cases that do pass versus ones that do not. Zero obviously can\\'t have a sign in most computational formats, but if considering direction of approach for physics based simulations, it may come up. Anyways, cheers from the future! "
                    },
                    {
                        "username": "Nikhil_G002109",
                        "content": "Zero is neither positive nor negative so useless!"
                    },
                    {
                        "username": "speedyy",
                        "content": "..-1,-0,0,1.. ??\\n0 * positive_negative_any_value = 0"
                    },
                    {
                        "username": "almostmonday",
                        "content": "If you are looking for a O(N) + O(1) solution without sorting, you could have a look [here](https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/solutions/3195376/solution-without-sorting-beats-100-runtime-on-o1-python/)."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Can anyone explain this test case why output is 26? I was so confused....\\ninput: [5,6,9,-3,3], k = 2   -> output: 26\\nwhy it\\'s 26? It didn\\'t make sense to me :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Are you sure output is 26..? It should be 20\\n\\nNegate -3 once : 5,6,9,3,3. k = 1 now\\nAll positive so you must negate the smallest value.. so 3 -> -3 \\n5 + 6 + 9 = 20"
                    },
                    {
                        "username": "kairrat",
                        "content": "cuz you are choosin last 3 in array and it becomes  -3, k =1 , 3, k = 2 , iteration is done.  "
                    },
                    {
                        "username": "rafiq1600",
                        "content": "class Solution:\\n    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:\\n        heapq.heapify(nums)\\n\\n        for i in range(k) :\\n            x = heapq.heappop(nums)\\n            heapq.heappush(nums, -x)\\n        sums = 0\\n        while len(nums) > 0 :\\n            sums += heapq.heappop(nums)\\n        return sums\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Two Non-overlapping Sub-arrays Each With Target Sum",
        "question_content": "<p>You are given an array of integers <code>arr</code> and an integer <code>target</code>.</p>\n\n<p>You have to find <strong>two non-overlapping sub-arrays</strong> of <code>arr</code> each with a sum equal <code>target</code>. There can be multiple answers so you have to find an answer where the sum of the lengths of the two sub-arrays is <strong>minimum</strong>.</p>\n\n<p>Return <em>the minimum sum of the lengths</em> of the two required sub-arrays, or return <code>-1</code> if you cannot find such two sub-arrays.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [3,2,2,4,3], target = 3\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Only two sub-arrays have sum = 3 ([3] and [3]). The sum of their lengths is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [7,3,4,7], target = 7\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Although we have three non-overlapping sub-arrays of sum = 7 ([7], [3,4] and [7]), but we will choose the first and third sub-arrays as the sum of their lengths is 2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [4,3,2,6,2,3,4], target = 6\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> We have only one sub-array of sum = 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= arr[i] &lt;= 1000</code></li>\n\t<li><code>1 &lt;= target &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 685486,
                "title": "java-o-n-time-two-pass-solution-using-hashmap",
                "content": "Concept: First traverse through the array once and store the (key,value) pair as (sum(arr[0:i+1]),i) for 0<=i<size of arr. Put, (0,-1) in hashmap as default. Now traverse through the array again, and for every i, find the minimum value of length of sub-array on the left or starting with i whose value is equal to target. Find another sub-array starting with i+1, whose sum is target. Update the result with the minimum value of the sum of both the sub-array. This is possible because all values are positive and the value of sum is strictly increasing.\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        HashMap<Integer,Integer> hmap=new HashMap<>();\\n        int sum=0,lsize=Integer.MAX_VALUE,result=Integer.MAX_VALUE;\\n        hmap.put(0,-1);\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            hmap.put(sum,i); // stores key as sum upto index i, and value as i.\\n        }\\n        sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            if(hmap.get(sum-target)!=null){\\n                lsize=Math.min(lsize,i-hmap.get(sum-target));      // stores minimum length of sub-array ending with index<= i with sum target. This ensures non- overlapping property.\\n            }\\n\\t\\t\\t//hmap.get(sum+target) searches for any sub-array starting with index i+1 with sum target.\\n            if(hmap.get(sum+target)!=null&&lsize<Integer.MAX_VALUE){\\n                result=Math.min(result,hmap.get(sum+target)-i+lsize); // updates the result only if both left and right sub-array exists.\\n            }\\n        }\\n        return result==Integer.MAX_VALUE?-1:result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        HashMap<Integer,Integer> hmap=new HashMap<>();\\n        int sum=0,lsize=Integer.MAX_VALUE,result=Integer.MAX_VALUE;\\n        hmap.put(0,-1);\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            hmap.put(sum,i); // stores key as sum upto index i, and value as i.\\n        }\\n        sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            if(hmap.get(sum-target)!=null){\\n                lsize=Math.min(lsize,i-hmap.get(sum-target));      // stores minimum length of sub-array ending with index<= i with sum target. This ensures non- overlapping property.\\n            }\\n\\t\\t\\t//hmap.get(sum+target) searches for any sub-array starting with index i+1 with sum target.\\n            if(hmap.get(sum+target)!=null&&lsize<Integer.MAX_VALUE){\\n                result=Math.min(result,hmap.get(sum+target)-i+lsize); // updates the result only if both left and right sub-array exists.\\n            }\\n        }\\n        return result==Integer.MAX_VALUE?-1:result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686105,
                "title": "java-sliding-window-with-only-one-array-no-hasmap",
                "content": "I see, mot of the people confused this with 560. `Subarray Sum Equals K` off course that would give correct answer, no doubt about that. But I think we can leverage the constraint here, which says `a[i] >= 1` due to this constraint we don\\'t need a `HashMap` here. Problem can be solved by vanilla sliding window.\\n\\n ```\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int best[] = new int[n];\\n        Arrays.fill(best, Integer.MAX_VALUE);\\n        int sum = 0, start = 0, ans = Integer.MAX_VALUE, bestSoFar = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++){\\n            sum += arr[i];\\n            while(sum > target){\\n                sum -= arr[start];\\n                start++;\\n            }\\n            if(sum == target){\\n                if(start > 0 && best[start - 1] != Integer.MAX_VALUE){\\n                    ans = min(ans, best[start - 1] + i - start + 1);\\n                }\\n                bestSoFar = min(bestSoFar, i - start + 1);\\n            }\\n            best[i] = bestSoFar;\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int best[] = new int[n];\\n        Arrays.fill(best, Integer.MAX_VALUE);\\n        int sum = 0, start = 0, ans = Integer.MAX_VALUE, bestSoFar = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++){\\n            sum += arr[i];\\n            while(sum > target){\\n                sum -= arr[start];\\n                start++;\\n            }\\n            if(sum == target){\\n                if(start > 0 && best[start - 1] != Integer.MAX_VALUE){\\n                    ans = min(ans, best[start - 1] + i - start + 1);\\n                }\\n                bestSoFar = min(bestSoFar, i - start + 1);\\n            }\\n            best[i] = bestSoFar;\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 685470,
                "title": "python-one-pass-prefix-sum-o-n",
                "content": "Keep track of the running prefix-sum and the length of the shortest sub-array that sums to the target up to that point (`best_till` in my solution).\\nEach time we find another such sub-array, look up that length value at the index right before it starts.\\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefix = {0: -1}\\n        best_till = [math.inf] * len(arr)\\n        ans = best = math.inf\\n        for i, curr in enumerate(itertools.accumulate(arr)):\\n            if curr - target in prefix:\\n                end = prefix[curr - target]\\n                if end > -1:\\n                    ans = min(ans, i - end + best_till[end])\\n                best = min(best, i - end)\\n            best_till[i] = best\\n            prefix[curr] = i\\n        return -1 if ans == math.inf else ans\\n```\\nIn the contest I misread sub-array as subsequence so ran out of time \\uD83D\\uDE22",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefix = {0: -1}\\n        best_till = [math.inf] * len(arr)\\n        ans = best = math.inf\\n        for i, curr in enumerate(itertools.accumulate(arr)):\\n            if curr - target in prefix:\\n                end = prefix[curr - target]\\n                if end > -1:\\n                    ans = min(ans, i - end + best_till[end])\\n                best = min(best, i - end)\\n            best_till[i] = best\\n            prefix[curr] = i\\n        return -1 if ans == math.inf else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688689,
                "title": "c-general-dp-solution-n-non-overlapping-sub-arrays",
                "content": "What if the problem changes to find **N** Non-overlapping Sub-arrays Each With Target Sum, **instead of two**?\\n\\nI would like to provide a more **General** solution here:\\n\\nDenote `dp[i][j]` as: \\nWe are only using `arr[1,2,...,i]`, and we have found `j` non-overlapping sub-arrays with target sum. The value of `dp[i][j`] is the minimum sum of the lengths of the sub-arrays.\\n\\nThen we have the equation:\\n```\\ndp[i][j] = min(dp[i-1][j], dp[d][j-1] + i - d)\\n```\\n\\nExplanation:\\n1. `dp[i][j] <= dp[i-1][j]`: \\nThis is because, we are considering more elements than before, hence the result can only be better (the length is smaller).\\n2. `dp[d][j-1] + i - d`: \\nThe `d` here is the index satisfying `sum(arr[i-d+1,...,i]) = target`. This sub-array has length = `i-d`.\\nTo ensure the sub-arrays don\\'t overlap, the rest of the sub-arrays must use index `<= d`, hence this is why we use `dp[d][j-1]` here.\\nTo quickly find such `d`, use a unordered_map to keep track of the prefix sum.\\n\\nIn the code:\\nNotice that we are using index from 1 to n, hence we can easily use index 0 to prevent extra checking.\\nAlso notice that we are initializing `dp[i][0] = 0`, because if we can\\'t find any subarray, the sum of length must be 0.\\n\\nThen, the answer is given by` dp[n][j]`. In this problem,` j = 2`.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[100005][3];  //if asking for n subarrays, change 3 to n+1\\n    unordered_map<int,int> sm;  // keep track of (prefixsum : index)  \\n    \\n    int minSumOfLengths(vector<int>& arr, int tar) {\\n        int n = arr.size(), cursum = 0;\\n        sm[0] = 0;\\n        memset(dp, 127, sizeof(dp));  //initialize to INF\\n        for (int i = 0; i < 100005; i++) dp[i][0] = 0;  //if we doesn\\'t find a subarray, len = 0\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int d = -1;  //initialize to -1\\n            cursum += arr[i-1];\\n            sm[cursum] = i;\\n            if (sm.count(cursum - tar)) d = sm[cursum-tar];\\n            \\n            for (int j = 1; j <= 2; j++) {  // if asking for n subarrays, change 2 to n\\n                dp[i][j] = min(dp[i][j], dp[i-1][j]);  //dp[i][j] must <= dp[i-1][j]\\n                if (d != -1) dp[i][j] = min(dp[i][j],dp[d][j-1] + i - d);\\n            }\\n        }\\n        if (dp[n][2] > 1e9) return -1;   // if asking for n subarrays, change 2 to n\\n        return dp[n][2];   // if asking for n subarrays, change 2 to n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i][j] = min(dp[i-1][j], dp[d][j-1] + i - d)\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[100005][3];  //if asking for n subarrays, change 3 to n+1\\n    unordered_map<int,int> sm;  // keep track of (prefixsum : index)  \\n    \\n    int minSumOfLengths(vector<int>& arr, int tar) {\\n        int n = arr.size(), cursum = 0;\\n        sm[0] = 0;\\n        memset(dp, 127, sizeof(dp));  //initialize to INF\\n        for (int i = 0; i < 100005; i++) dp[i][0] = 0;  //if we doesn\\'t find a subarray, len = 0\\n        \\n        for (int i = 1; i <= n; i++) {\\n            int d = -1;  //initialize to -1\\n            cursum += arr[i-1];\\n            sm[cursum] = i;\\n            if (sm.count(cursum - tar)) d = sm[cursum-tar];\\n            \\n            for (int j = 1; j <= 2; j++) {  // if asking for n subarrays, change 2 to n\\n                dp[i][j] = min(dp[i][j], dp[i-1][j]);  //dp[i][j] must <= dp[i-1][j]\\n                if (d != -1) dp[i][j] = min(dp[i][j],dp[d][j-1] + i - d);\\n            }\\n        }\\n        if (dp[n][2] > 1e9) return -1;   // if asking for n subarrays, change 2 to n\\n        return dp[n][2];   // if asking for n subarrays, change 2 to n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685600,
                "title": "python-similar-to-buy-and-sell-stock-3-simple-dp-solution-logic-and-intuition-explained",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##        \\n\\t\\t## Similar to Leetcode: 123 Best Time To Buy And Sell Stock III ##\\n        ## LOGIC ##\\n        ## 1. Like typical subarray sum problem, calculate the valid subarray lengths at that particular index using running/prefix sum\\n        ## 2. dp will have the minimum subarray length with sum = target found till that index.\\n        ## 3. now reverse the array and compute the same. (we now have both dp_left and dp_right)\\n        ## 4. As there should not be any overlaps, we consider minimum found till index - 1 in left side and minimum found from this current index till end on right side. Compute the sum and store in ans.\\n\\t\\t\\n\\t\\t## INTUITION ## (How did I get to know that I have to use dp_left and dp_ right ?)\\n\\t\\t## As we are finding only 2 best cases, if we consider any particular index, one best case can be to its left side , othe best case can be to its right side ##\\n        \\n\\t\\t## TIME COMPLEXICITY : O(3xN) ##\\n\\t\\t## SPACE COMPLEXICITY : O(N) ##\\n        \\n        def get_sub_arrays( arr ):\\n            lookup = collections.defaultdict(int)\\n            running_sum = 0\\n            dp = [float(\\'inf\\')] * len(arr)\\n            \\n            for i, num in enumerate(arr):\\n                running_sum += num\\n                if running_sum == target:\\n                    dp[i] = i - 0 + 1\\n                elif running_sum - target in lookup:\\n                    dp[i] = i - lookup[running_sum - target] + 1\\n                lookup[running_sum] = i+1\\n                dp[i] = min( dp[i-1], dp[i] )\\n            return dp\\n        \\n        dp_left = get_sub_arrays( arr )                     # from front\\n        dp_right = get_sub_arrays( arr[::-1] )[::-1]        # from backwards\\n        \\n        ans = float(\\'inf\\')\\n        for i in range( 1, len(arr) ):\\n            ans = min( ans, dp_left[i-1] + dp_right[i] )\\n        return ans if( ans != float(\\'inf\\') ) else -1\\n```\\nUPVOTE IF YOU LIKE MY SOLUTION.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        ## RC ##\\n        ## APPROACH : DP ##        \\n\\t\\t## Similar to Leetcode: 123 Best Time To Buy And Sell Stock III ##\\n        ## LOGIC ##\\n        ## 1. Like typical subarray sum problem, calculate the valid subarray lengths at that particular index using running/prefix sum\\n        ## 2. dp will have the minimum subarray length with sum = target found till that index.\\n        ## 3. now reverse the array and compute the same. (we now have both dp_left and dp_right)\\n        ## 4. As there should not be any overlaps, we consider minimum found till index - 1 in left side and minimum found from this current index till end on right side. Compute the sum and store in ans.\\n\\t\\t\\n\\t\\t## INTUITION ## (How did I get to know that I have to use dp_left and dp_ right ?)\\n\\t\\t## As we are finding only 2 best cases, if we consider any particular index, one best case can be to its left side , othe best case can be to its right side ##\\n        \\n\\t\\t## TIME COMPLEXICITY : O(3xN) ##\\n\\t\\t## SPACE COMPLEXICITY : O(N) ##\\n        \\n        def get_sub_arrays( arr ):\\n            lookup = collections.defaultdict(int)\\n            running_sum = 0\\n            dp = [float(\\'inf\\')] * len(arr)\\n            \\n            for i, num in enumerate(arr):\\n                running_sum += num\\n                if running_sum == target:\\n                    dp[i] = i - 0 + 1\\n                elif running_sum - target in lookup:\\n                    dp[i] = i - lookup[running_sum - target] + 1\\n                lookup[running_sum] = i+1\\n                dp[i] = min( dp[i-1], dp[i] )\\n            return dp\\n        \\n        dp_left = get_sub_arrays( arr )                     # from front\\n        dp_right = get_sub_arrays( arr[::-1] )[::-1]        # from backwards\\n        \\n        ans = float(\\'inf\\')\\n        for i in range( 1, len(arr) ):\\n            ans = min( ans, dp_left[i-1] + dp_right[i] )\\n        return ans if( ans != float(\\'inf\\') ) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685463,
                "title": "c-o-n-solution-by-prefix-sum-and-dp",
                "content": "1. precalculate at each position, i, the min length of array with target sum from left and from right respectively. \\n\\ta. fromLeft[i]: from the leftmost to position, i, ```(i.e. [0 .. i])```, the min length of the array with target sum\\n\\tb. fromRight[i]: from the rightmost to position, i, ```(i.e. [i .. n-1])```, the min length of the array with target sum\\n2. use DP to find the min sum of length at each pisition, i. ```(i.e. , dp[i] = fromLeft[i] + fromRight[i+1])```\\n\\ta. consider the minimal sum of two arrays\\' length at each index, i. ```(i.e. min sum of length at index i = min length in the range of [0 .. i] + min length in the range of [i+1 .. n-1])```\\n\\tb. reverse the given array and apply the same subfunction to simply the code.  \\n3. complexity \\n\\ta. Time complexity : O(N)\\n\\tb. Space complexity: O(N)\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        // from the left, min length of array with sum = target\\n        vector<int> left = minLen(arr, target);\\n\\n        // from the right, min length of array with sum = target\\n        vector<int> arrReverse(arr.begin(), arr.end());\\n        reverse(arrReverse.begin(), arrReverse.end());\\n        vector<int> right = minLen(arrReverse, target);\\n        \\n        // consider each position to find the min sum of length of the two array with target sum\\n        int min_val = arr.size() + 1;\\n        int n = arr.size();\\n        for(int i = 0; i < arr.size() - 1; ++i) {\\n            min_val = min(min_val, left[i] + right[n-1-i-1]);\\n        }\\n        return min_val == arr.size() + 1 ? -1 : min_val;\\n    }\\n    \\n    // at each position, i, find the min length of array with target sum \\n    vector<int> minLen(vector<int> &arr, int target) {\\n        int n = arr.size();\\n        vector<int> presum(n, 0);\\n        unordered_map<int, int> idx;\\n        vector<int> ans(n, n + 1);\\n        idx[0] = -1;\\n        for(int i = 0; i < arr.size(); ++i) {\\n            presum[i] = i == 0 ? arr[i] : arr[i] + presum[i-1];\\n            int len = arr.size() + 1;\\n            if(idx.find(presum[i] - target) != idx.end()) {\\n                len = i - idx[presum[i]-target];\\n            }\\n            idx[presum[i]] = i;\\n            ans[i] = i == 0 ? len : min(ans[i-1], len);    \\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```(i.e. [0 .. i])```\n```(i.e. [i .. n-1])```\n```(i.e. , dp[i] = fromLeft[i] + fromRight[i+1])```\n```(i.e. min sum of length at index i = min length in the range of [0 .. i] + min length in the range of [i+1 .. n-1])```\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        // from the left, min length of array with sum = target\\n        vector<int> left = minLen(arr, target);\\n\\n        // from the right, min length of array with sum = target\\n        vector<int> arrReverse(arr.begin(), arr.end());\\n        reverse(arrReverse.begin(), arrReverse.end());\\n        vector<int> right = minLen(arrReverse, target);\\n        \\n        // consider each position to find the min sum of length of the two array with target sum\\n        int min_val = arr.size() + 1;\\n        int n = arr.size();\\n        for(int i = 0; i < arr.size() - 1; ++i) {\\n            min_val = min(min_val, left[i] + right[n-1-i-1]);\\n        }\\n        return min_val == arr.size() + 1 ? -1 : min_val;\\n    }\\n    \\n    // at each position, i, find the min length of array with target sum \\n    vector<int> minLen(vector<int> &arr, int target) {\\n        int n = arr.size();\\n        vector<int> presum(n, 0);\\n        unordered_map<int, int> idx;\\n        vector<int> ans(n, n + 1);\\n        idx[0] = -1;\\n        for(int i = 0; i < arr.size(); ++i) {\\n            presum[i] = i == 0 ? arr[i] : arr[i] + presum[i-1];\\n            int len = arr.size() + 1;\\n            if(idx.find(presum[i] - target) != idx.end()) {\\n                len = i - idx[presum[i]-target];\\n            }\\n            idx[presum[i]] = i;\\n            ans[i] = i == 0 ? len : min(ans[i-1], len);    \\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775374,
                "title": "python-o-n-sliding-window-with-comments",
                "content": "```py\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        INF = len(arr) + 1\\n        best_at_i = [INF]*len(arr) # the ith index represents the smallest length subarray we\\'ve found ending <= i that sums to target\\n        best = INF # output \\n        curr_sum = 0 # current sum between left and right\\n        \\n        left = 0\\n        for right in range(len(arr)):\\n            # update the running sum\\n            curr_sum += arr[right]\\n            \\n            # arr is strictly positive, so shrink window until we\\'re not above target\\n            while curr_sum > target and left <= right:\\n                curr_sum -= arr[left]\\n                left += 1\\n                \\n            if curr_sum == target:\\n                # we have a new shortest candidate to consider\\n                best = min(best, best_at_i[left-1] + right - left + 1)\\n                best_at_i[right] = min(best_at_i[right-1], right - left + 1)\\n            else:\\n                # best we\\'ve seen is the previous best (overlaps to end if right == 0)\\n                best_at_i[right] = best_at_i[right-1]\\n        \\n        if best == INF:\\n            return -1\\n        return best\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```py\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        INF = len(arr) + 1\\n        best_at_i = [INF]*len(arr) # the ith index represents the smallest length subarray we\\'ve found ending <= i that sums to target\\n        best = INF # output \\n        curr_sum = 0 # current sum between left and right\\n        \\n        left = 0\\n        for right in range(len(arr)):\\n            # update the running sum\\n            curr_sum += arr[right]\\n            \\n            # arr is strictly positive, so shrink window until we\\'re not above target\\n            while curr_sum > target and left <= right:\\n                curr_sum -= arr[left]\\n                left += 1\\n                \\n            if curr_sum == target:\\n                # we have a new shortest candidate to consider\\n                best = min(best, best_at_i[left-1] + right - left + 1)\\n                best_at_i[right] = min(best_at_i[right-1], right - left + 1)\\n            else:\\n                # best we\\'ve seen is the previous best (overlaps to end if right == 0)\\n                best_at_i[right] = best_at_i[right-1]\\n        \\n        if best == INF:\\n            return -1\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685548,
                "title": "java-sliding-window-with-dp-o-n-20-lines",
                "content": "This problem is similar to [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/discuss/?currentPage=1&orderBy=most_votes&query=)\\n\\nLike `Subarray Sum Equals K` we use `HashMap` to remember the prefix sum, here we choose `sum - target` as our key and `index` as value, so `length = i - map.get(sum - target)`. In case the first x element\\'s sum equals `target` we should put `(0 , -1)` first.\\n\\nSince we need to calculate the length of two sub-arrays, we can use dp to memorize the minimum length of previous subarray.\\n\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        map.put(0, -1);\\n        int[] min = new int[arr.length];\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < arr.length; i++) {\\n            sum += arr[i];\\n            min[i] = i > 0? min[i - 1] : Integer.MAX_VALUE;\\n            if (map.containsKey(sum - target)) {\\n                int pre = map.get(sum - target);\\n                min[i] = Math.min(min[i], i - pre);\\n\\t\\t\\t\\t// if pre equals -1 means we only get one sub-array whoes sum eqauls target\\n                if (pre != -1 && min[pre] != Integer.MAX_VALUE) {\\n                    res = Math.min(res, min[pre] + i - pre);\\n                }\\n            }\\n            map.put(sum, i);\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        map.put(0, -1);\\n        int[] min = new int[arr.length];\\n        int res = Integer.MAX_VALUE;\\n        for (int i = 0; i < arr.length; i++) {\\n            sum += arr[i];\\n            min[i] = i > 0? min[i - 1] : Integer.MAX_VALUE;\\n            if (map.containsKey(sum - target)) {\\n                int pre = map.get(sum - target);\\n                min[i] = Math.min(min[i], i - pre);\\n\\t\\t\\t\\t// if pre equals -1 means we only get one sub-array whoes sum eqauls target\\n                if (pre != -1 && min[pre] != Integer.MAX_VALUE) {\\n                    res = Math.min(res, min[pre] + i - pre);\\n                }\\n            }\\n            map.put(sum, i);\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 743967,
                "title": "c-sliding-window-dp-o-n",
                "content": "Let us assume that dp[i] stores the length of the previous shortest subarray whose sum=target before index i. Now suppose after index i, we encounter another subarray of some length l at index r whose sum is also equal to target, then our ans would be the current length, l+dp[r-l] since l length from index r would be used and if there is any subarray whose sum equals target before index (r-l) then we can add that to our ans and that would be some feasible ans and then we take take the minimum of all these feasible answers to find the optimum value.\\n\\nWe can also guarantee that there would be atleast two such arrays if ans!=INT_MAX by checking if dp[r-l] contains some valid value otherwise this is the first subarray with target sum.\\n\\nHere is the code:\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int l=0,r=0,csum=0,ans=INT_MAX;\\n        vector<int> dp(arr.size(),INT_MAX);\\n        for(;r<arr.size();r++){\\n            csum+=arr[r];\\n            while(csum>target)\\n                csum-=arr[l++];\\n            if(csum==target){\\n                dp[r]=r-l+1;\\n                if(l-1>=0 && dp[l-1]!=INT_MAX)\\n                    ans=min(ans,dp[r]+dp[l-1]);\\n            }\\n            if(r-1>=0)\\n                dp[r]=min(dp[r-1],dp[r]);\\n        }\\n        \\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int l=0,r=0,csum=0,ans=INT_MAX;\\n        vector<int> dp(arr.size(),INT_MAX);\\n        for(;r<arr.size();r++){\\n            csum+=arr[r];\\n            while(csum>target)\\n                csum-=arr[l++];\\n            if(csum==target){\\n                dp[r]=r-l+1;\\n                if(l-1>=0 && dp[l-1]!=INT_MAX)\\n                    ans=min(ans,dp[r]+dp[l-1]);\\n            }\\n            if(r-1>=0)\\n                dp[r]=min(dp[r-1],dp[r]);\\n        }\\n        \\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000782,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int sum = 0, n = arr.size(), ans = INT_MAX, len = INT_MAX;\\n        vector<int> min_len(n, INT_MAX);\\n        int start = 0;\\n        for (int end = 0; end < n; end++) {\\n            sum += arr[end];\\n            //shrink the window\\n            while (sum > target) {\\n                sum -= arr[start];\\n                start++;\\n            }\\n            if (sum == target) {\\n                //update the min_len\\n                int curLen = end - start + 1;\\n                if (start > 0 && min_len[start-1] != INT_MAX) {\\n                    ans = min(ans, curLen + min_len[start-1]);\\n                }\\n                len = min(curLen, len); \\n            }\\n            min_len[end] = len;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int sum = 0, n = arr.size(), ans = INT_MAX, len = INT_MAX;\\n        vector<int> min_len(n, INT_MAX);\\n        int start = 0;\\n        for (int end = 0; end < n; end++) {\\n            sum += arr[end];\\n            //shrink the window\\n            while (sum > target) {\\n                sum -= arr[start];\\n                start++;\\n            }\\n            if (sum == target) {\\n                //update the min_len\\n                int curLen = end - start + 1;\\n                if (start > 0 && min_len[start-1] != INT_MAX) {\\n                    ans = min(ans, curLen + min_len[start-1]);\\n                }\\n                len = min(curLen, len); \\n            }\\n            min_len[end] = len;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686648,
                "title": "c-prefix-sum-hash-two-pass",
                "content": "Based on C++ version of @pramitb\\'s JAVA solution\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        unordered_map<int, int>hm;\\n        hm[0] = -1;\\n        int sum = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            hm[sum] = i;\\n        }\\n        \\n        sum = 0;\\n        int msize = INT_MAX, res = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            \\n            if (hm.find(sum-target) != hm.end())\\n                msize = min(msize, i-hm[sum-target]);\\n            \\n            if (hm.find(sum+target) != hm.end() && msize != INT_MAX)\\n                res = min(res, msize + hm[sum+target]-i);\\n        }\\n        \\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        unordered_map<int, int>hm;\\n        hm[0] = -1;\\n        int sum = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            hm[sum] = i;\\n        }\\n        \\n        sum = 0;\\n        int msize = INT_MAX, res = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            \\n            if (hm.find(sum-target) != hm.end())\\n                msize = min(msize, i-hm[sum-target]);\\n            \\n            if (hm.find(sum+target) != hm.end() && msize != INT_MAX)\\n                res = min(res, msize + hm[sum+target]-i);\\n        }\\n        \\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687163,
                "title": "java-prefix-suffix-sum",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int[] left = findMinLengths(0, arr.length, target,arr);\\n        int[] right = findMinLengths(arr.length-1, 0,target,arr);\\n        \\n        for(int i=1;i<arr.length;i++)\\n            left[i] = Math.min(left[i],left[i-1]);\\n        \\n        for(int i=arr.length-2;i>=0;i--)\\n            right[i] = Math.min(right[i],right[i+1]);\\n        \\n        int min = arr.length+1;\\n        \\n        for(int i=0;i<arr.length-1;i++)\\n            min = Math.min(min,left[i] + right[i+1]);\\n        \\n        return min == arr.length+1 ? -1 : min;\\n    }\\n    \\n    private int[] findMinLengths(int start,int end,int target,int[] arr){\\n        int[] ans = new int[arr.length];\\n        \\n        Arrays.fill(ans,arr.length);\\n        \\n        int i = start,j = start;\\n        int sum = 0;\\n        \\n        int dir = (int)Math.signum(end-start);\\n        \\n        while(j != end){\\n            sum += arr[j];\\n            \\n            while(sum > target){\\n                sum -= arr[i];\\n                i += dir;\\n            }\\n                \\n            if(sum == target){\\n                ans[j] = Math.abs(i-j)+1;\\n            }\\n            \\n            j+=dir;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int[] left = findMinLengths(0, arr.length, target,arr);\\n        int[] right = findMinLengths(arr.length-1, 0,target,arr);\\n        \\n        for(int i=1;i<arr.length;i++)\\n            left[i] = Math.min(left[i],left[i-1]);\\n        \\n        for(int i=arr.length-2;i>=0;i--)\\n            right[i] = Math.min(right[i],right[i+1]);\\n        \\n        int min = arr.length+1;\\n        \\n        for(int i=0;i<arr.length-1;i++)\\n            min = Math.min(min,left[i] + right[i+1]);\\n        \\n        return min == arr.length+1 ? -1 : min;\\n    }\\n    \\n    private int[] findMinLengths(int start,int end,int target,int[] arr){\\n        int[] ans = new int[arr.length];\\n        \\n        Arrays.fill(ans,arr.length);\\n        \\n        int i = start,j = start;\\n        int sum = 0;\\n        \\n        int dir = (int)Math.signum(end-start);\\n        \\n        while(j != end){\\n            sum += arr[j];\\n            \\n            while(sum > target){\\n                sum -= arr[i];\\n                i += dir;\\n            }\\n                \\n            if(sum == target){\\n                ans[j] = Math.abs(i-j)+1;\\n            }\\n            \\n            j+=dir;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685354,
                "title": "clean-python-3-o-n-with-sliding-window-fixed",
                "content": "Make a targets list of all possible subarrays with their corresponding length.\\nAnd then find its possible minimun pair by a premin list.\\nTime: `O(N)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        i, window, targets = 0, 0, [float(\\'inf\\')] * len(arr)\\n        for j, num in enumerate(arr):\\n            window += num\\n            while window > target:\\n                window -= arr[i]\\n                i += 1\\n            if window == target: targets[j] = j - i + 1\\n        premin, result = [float(\\'inf\\')] * len(arr), float(\\'inf\\')\\n        for i, target in enumerate(targets):\\n            if i - target >= 0: result = min(result, target + premin[i - target])\\n            premin[i] = target if i == 0 else min(target, premin[i - 1])\\n        return result if result < float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        i, window, targets = 0, 0, [float(\\'inf\\')] * len(arr)\\n        for j, num in enumerate(arr):\\n            window += num\\n            while window > target:\\n                window -= arr[i]\\n                i += 1\\n            if window == target: targets[j] = j - i + 1\\n        premin, result = [float(\\'inf\\')] * len(arr), float(\\'inf\\')\\n        for i, target in enumerate(targets):\\n            if i - target >= 0: result = min(result, target + premin[i - target])\\n            premin[i] = target if i == 0 else min(target, premin[i - 1])\\n        return result if result < float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848400,
                "title": "c-easy-to-understand-dp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int currsum=0;\\n        int st=0;\\n        int len=INT_MAX;\\n        vector<int> dp(arr.size(),INT_MAX);\\n        int anslen=INT_MAX;\\n        int i=0;\\n        while(i<arr.size())\\n        {\\n            currsum+=arr[i];\\n            while(currsum>target)\\n            {\\n                currsum-=arr[st];\\n                st++;\\n            }\\n            if(currsum==target)\\n            {\\n                if(st>0 and dp[st-1]!=INT_MAX)\\n                    len=min(len,dp[st-1]+i-st+1);\\n                anslen=min(anslen,i-st+1);\\n            }\\n            dp[i]=anslen;\\n            i++;\\n        }\\n        return len==INT_MAX?-1:len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int currsum=0;\\n        int st=0;\\n        int len=INT_MAX;\\n        vector<int> dp(arr.size(),INT_MAX);\\n        int anslen=INT_MAX;\\n        int i=0;\\n        while(i<arr.size())\\n        {\\n            currsum+=arr[i];\\n            while(currsum>target)\\n            {\\n                currsum-=arr[st];\\n                st++;\\n            }\\n            if(currsum==target)\\n            {\\n                if(st>0 and dp[st-1]!=INT_MAX)\\n                    len=min(len,dp[st-1]+i-st+1);\\n                anslen=min(anslen,i-st+1);\\n            }\\n            dp[i]=anslen;\\n            i++;\\n        }\\n        return len==INT_MAX?-1:len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237424,
                "title": "c-sliding-widow-easy-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> dp(n, INT_MAX);\\n        \\n        int sum = 0;      \\n        int ans = INT_MAX;\\n        int len = INT_MAX;     \\n        int start = 0;\\n        int end = 0;\\n        \\n        for (end = 0; end < n; end++) {\\n            sum += arr[end];\\n            \\n            while (sum > target) {\\n                sum -= arr[start];\\n                start++;\\n            }\\n            \\n            if (sum == target) {\\n                int curLen = end - start + 1;\\n                if (start > 0 && dp[start-1] != INT_MAX) \\n                {\\n                    ans = min(ans, curLen + dp[start-1]); // ans will be the 2 sub-array length or current length + last min length( which is stored in dp)\\n                }\\n                len = min(curLen, len); \\n            }\\n            dp[end] = len;  // dp stores the previous min length\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> dp(n, INT_MAX);\\n        \\n        int sum = 0;      \\n        int ans = INT_MAX;\\n        int len = INT_MAX;     \\n        int start = 0;\\n        int end = 0;\\n        \\n        for (end = 0; end < n; end++) {\\n            sum += arr[end];\\n            \\n            while (sum > target) {\\n                sum -= arr[start];\\n                start++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 685916,
                "title": "java-one-pass-o-n-the-simplest-solution-with-explanation",
                "content": "This problem can be divided to two small problems: 1) find all subarray whose sum is equal to target; 2) find two subarrays from the former result which are not overlapping and whose total length is minimum.\\n\\nFor subproblem 1), we can use sliding window to find all subarray; basically use two pointers, i, j to scan the arr and check the sum between i and j; \\n\\nFor subproblem 2) we can use an array, e.g. dp to record that for every index i, the shortest length subarray whose sum is equal to target up until index i and including index i itself. \\n\\nNotice subproblem 2) can be solved along with subproblem 1);  Also the final result can solved along the two subproblem, bascially when we find subarray[i, j], notice the previous non-overlapping subarray length will be dp[i-1], so we can update the result with dp[i-1] + (j - i + 1);\\n\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {        \\n        int result = Integer.MAX_VALUE; // the final result\\n        int len = arr.length;\\n        int[] dp = new int[len]; //min subarray length so far until the index\\n        int i = 0, j = 0; // i is left pointer, j is right pointer\\n        int sum = 0;\\n        while(j<len) {\\n            dp[j] = Integer.MAX_VALUE; // initialize the value\\n            sum += arr[j];\\n            while(i<len && sum > target) { // move left pointer if sum is larger than target\\n                sum -= arr[i];\\n                i++;\\n            }\\n            \\n            if(sum == target) {\\n                dp[j] = j - i + 1;  // set the dp value to current subarray\\n                \\n                if(i-1>=0 && dp[i-1] != Integer.MAX_VALUE) // dp[i-1] will the min length of non-overlapping subarray \\n                    result = Math.min(dp[j] + dp[i-1], re); \\n            }\\n            \\n            if(j-1>=0)\\n               dp[j] = Math.min(dp[j], dp[j-1]); // dp[i] represents the shortest length subarray so far\\n            \\n            j++;\\n        }\\n        \\n        return result == Integer.MAX_VALUE ? -1 : result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {        \\n        int result = Integer.MAX_VALUE; // the final result\\n        int len = arr.length;\\n        int[] dp = new int[len]; //min subarray length so far until the index\\n        int i = 0, j = 0; // i is left pointer, j is right pointer\\n        int sum = 0;\\n        while(j<len) {\\n            dp[j] = Integer.MAX_VALUE; // initialize the value\\n            sum += arr[j];\\n            while(i<len && sum > target) { // move left pointer if sum is larger than target\\n                sum -= arr[i];\\n                i++;\\n            }\\n            \\n            if(sum == target) {\\n                dp[j] = j - i + 1;  // set the dp value to current subarray\\n                \\n                if(i-1>=0 && dp[i-1] != Integer.MAX_VALUE) // dp[i-1] will the min length of non-overlapping subarray \\n                    result = Math.min(dp[j] + dp[i-1], re); \\n            }\\n            \\n            if(j-1>=0)\\n               dp[j] = Math.min(dp[j], dp[j-1]); // dp[i] represents the shortest length subarray so far\\n            \\n            j++;\\n        }\\n        \\n        return result == Integer.MAX_VALUE ? -1 : result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685326,
                "title": "o-n-o-n-2-window-sliding-simple-approach-w-video-explanation-of-subarray-sum",
                "content": "**UPDATE** \\nO(N) approach is based on this beautiful solution here,\\nhttps://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/discuss/685486/JAVA-O(N)-Time-Two-Pass-Solution-using-HashMap by @pramitb\\n\\n**O(N^2) Approach**\\n\\n\\nI am using simple approach from the following video, where I have explained how can we find a subarray whose sum is equal to a given target, \\nIn this case I am just storing length of each such subarray, start and end index in a vector. \\nAnd then sort this vector by length, \\n\\n\\nhttps://www.youtube.com/watch?v=1XLTftBtqZs\\n\\n\\n```\\n// using subarray sum equals to target, \\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        map<int, int> _map; // can use unordered_map as well\\n        vector<pair<int, pair<int, int> > > subs;\\n        \\n        _map[0] = -1;\\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            \\n            if(sum - target >= 0 && _map.find(sum - target) != _map.end()) {\\n                subs.push_back({i - _map[sum-target], {_map[sum - target] + 1, i}});\\n            }\\n            _map[sum] = i;\\n        }\\n        \\n        sort(subs.begin(), subs.end());\\n        if(subs.size() < 2)\\n            return -1;\\n        \\n        \\n        for(int i = 0; i < subs.size() - 1; i++) {\\n            \\n            for(int j = i + 1; j < subs.size(); j++) {\\n                if(subs[i].second.second < subs[j].second.first || subs[i].second.first > subs[j].second.second)\\n                    return subs[i].first + subs[j].first; \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n\\n**O(N)** ( thanks to @pramitb for his solution)\\n\\nBetter approach is that we can compute and store all the prefix sum. And then traverse the array again and restart computing the prefix sum ( i.e  `sum = 0`). And this time for each `i` we also check if there is a subarray whose sum is equals to `sum + target` , if we find such value in map that means there exist a subarray on the right of current whose sum will be equals to `target`. And then we can compare both of them, and store the minimum answer. Check below the code for better understanding.\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        map<int, int> _map;\\n        \\n        _map[0] = -1;\\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            _map[sum] = i;\\n        }\\n       \\n        sum = 0;\\n        \\n        int ans = INT_MAX;\\n        int min_left = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++){\\n            sum += arr[i];\\n            \\n            if(_map.find(sum - target) != _map.end()){\\n                min_left = min(min_left, i - _map[sum - target]); \\n            }\\n\\t\\t\\t\\n            if( _map.find(sum + target) != _map.end() && min_left < INT_MAX){\\n                ans = min(ans, _map[sum + target] - i + min_left);\\n            }\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n// using subarray sum equals to target, \\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        map<int, int> _map; // can use unordered_map as well\\n        vector<pair<int, pair<int, int> > > subs;\\n        \\n        _map[0] = -1;\\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            \\n            if(sum - target >= 0 && _map.find(sum - target) != _map.end()) {\\n                subs.push_back({i - _map[sum-target], {_map[sum - target] + 1, i}});\\n            }\\n            _map[sum] = i;\\n        }\\n        \\n        sort(subs.begin(), subs.end());\\n        if(subs.size() < 2)\\n            return -1;\\n        \\n        \\n        for(int i = 0; i < subs.size() - 1; i++) {\\n            \\n            for(int j = i + 1; j < subs.size(); j++) {\\n                if(subs[i].second.second < subs[j].second.first || subs[i].second.first > subs[j].second.second)\\n                    return subs[i].first + subs[j].first; \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        map<int, int> _map;\\n        \\n        _map[0] = -1;\\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            _map[sum] = i;\\n        }\\n       \\n        sum = 0;\\n        \\n        int ans = INT_MAX;\\n        int min_left = INT_MAX;\\n        \\n        for(int i = 0; i < n; i++){\\n            sum += arr[i];\\n            \\n            if(_map.find(sum - target) != _map.end()){\\n                min_left = min(min_left, i - _map[sum - target]); \\n            }\\n\\t\\t\\t\\n            if( _map.find(sum + target) != _map.end() && min_left < INT_MAX){\\n                ans = min(ans, _map[sum + target] - i + min_left);\\n            }\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685320,
                "title": "java-o-n-12ms",
                "content": "* Storing all the index of sub arrays with sum equals to target using sliding window.\\n* `dp[en] = st`, where st, en represents the start and end of the sub array respectively.\\n* ans = Math.min(ans, length of curr subarray **+** min length of subarray with index < start of curr subarray) => `Math.min(ans, (i - dp[i] + 1) + dp[dp[i]-1])`\\n* Updating dp[i] with min length encountered till index i => `dp[i] = Math.min(dp[i-1], i-dp[i] + 1)`\\n\\n\\n```\\npublic int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int []dp = new int[n+1];\\n        int st = 0;\\n        int en = 0;\\n        int sum = 0;\\n        int ans = Integer.MAX_VALUE;\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        while(en < n){\\n            sum += arr[en];\\n            while(st <= en && sum > target){\\n                sum -= arr[st++];\\n            }\\n            if(sum == target){\\n                dp[en+1] = st+1;\\n            }\\n            en ++;\\n        }\\n        for(int i=1;i<=n;i++){\\n            if(dp[i] != Integer.MAX_VALUE){\\n                if(dp[dp[i]-1] != Integer.MAX_VALUE){\\n                    ans = Math.min(ans, dp[dp[i]-1] + i - dp[i] + 1);\\n                }\\n                dp[i] = Math.min(i-dp[i]+1, dp[i-1]);\\n            }else{\\n                dp[i] = dp[i-1];\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int []dp = new int[n+1];\\n        int st = 0;\\n        int en = 0;\\n        int sum = 0;\\n        int ans = Integer.MAX_VALUE;\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        while(en < n){\\n            sum += arr[en];\\n            while(st <= en && sum > target){\\n                sum -= arr[st++];\\n            }\\n            if(sum == target){\\n                dp[en+1] = st+1;\\n            }\\n            en ++;\\n        }\\n        for(int i=1;i<=n;i++){\\n            if(dp[i] != Integer.MAX_VALUE){\\n                if(dp[dp[i]-1] != Integer.MAX_VALUE){\\n                    ans = Math.min(ans, dp[dp[i]-1] + i - dp[i] + 1);\\n                }\\n                dp[i] = Math.min(i-dp[i]+1, dp[i-1]);\\n            }else{\\n                dp[i] = dp[i-1];\\n            }\\n        }\\n        if(ans == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1987219,
                "title": "python-sliding-window-o-n-with-detail-comments",
                "content": "\\n```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        l, windowSum, res = 0, 0, float(\\'inf\\')\\n        min_till = [float(\\'inf\\')] * len(arr) # records smallest lenth of subarry with target sum up till index i.\\n        for r, num in enumerate(arr): # r:right pointer and index of num in arr\\n            windowSum += num\\n            while windowSum > target: \\n\\t\\t\\t# when the sum of current window is larger then target, shrink the left end of the window one by one until windowSum <= target\\n                windowSum -= arr[l]\\n                l += 1\\n\\t\\t\\t# the case when we found a new target sub-array, i.e. current window\\n            if windowSum == target:\\n\\t\\t\\t   # length of current window\\n                curLen = r - l + 1\\n\\t\\t\\t\\t# min_till[l - 1]: the subarray with min len up till the previous position of left end of the current window: \\n\\t\\t\\t\\t# avoid overlap with cur window\\n\\t\\t\\t\\t# new_sum_of_two_subarray = length of current window + the previous min length of target subarray without overlapping\\n\\t\\t\\t\\t# , if < res, update res.\\n                res = min(res, curLen + min_till[l - 1])\\n\\t\\t\\t\\t# Everytime we found a target window, update the min_till of current right end of the window, \\n\\t\\t\\t\\t# for future use when sum up to new length of sum_of_two_subarray and update the res.\\n                min_till[r] = min(curLen, min_till[r - 1])\\n            else:\\n\\t\\t\\t# If windowSum < target: window with current arr[r] as right end does not have any target subarry, \\n\\t\\t\\t# the min_till[r] doesn\\'t get any new minimum update, i.e it equals to previous min_till at index r - 1. \\n                min_till[r] = min_till[r - 1]\\n        return res if res < float(\\'inf\\') else -1\\n\\t\\nTime = O(n): when sliding the window, left and right pointers traverse the array once.\\nSpace = O(n): we use one additional list min_till[] to record min length of target subarray till index i.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "\\n```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        l, windowSum, res = 0, 0, float(\\'inf\\')\\n        min_till = [float(\\'inf\\')] * len(arr) # records smallest lenth of subarry with target sum up till index i.\\n        for r, num in enumerate(arr): # r:right pointer and index of num in arr\\n            windowSum += num\\n            while windowSum > target: \\n\\t\\t\\t# when the sum of current window is larger then target, shrink the left end of the window one by one until windowSum <= target\\n                windowSum -= arr[l]\\n                l += 1\\n\\t\\t\\t# the case when we found a new target sub-array, i.e. current window\\n            if windowSum == target:\\n\\t\\t\\t   # length of current window\\n                curLen = r - l + 1\\n\\t\\t\\t\\t# min_till[l - 1]: the subarray with min len up till the previous position of left end of the current window: \\n\\t\\t\\t\\t# avoid overlap with cur window\\n\\t\\t\\t\\t# new_sum_of_two_subarray = length of current window + the previous min length of target subarray without overlapping\\n\\t\\t\\t\\t# , if < res, update res.\\n                res = min(res, curLen + min_till[l - 1])\\n\\t\\t\\t\\t# Everytime we found a target window, update the min_till of current right end of the window, \\n\\t\\t\\t\\t# for future use when sum up to new length of sum_of_two_subarray and update the res.\\n                min_till[r] = min(curLen, min_till[r - 1])\\n            else:\\n\\t\\t\\t# If windowSum < target: window with current arr[r] as right end does not have any target subarry, \\n\\t\\t\\t# the min_till[r] doesn\\'t get any new minimum update, i.e it equals to previous min_till at index r - 1. \\n                min_till[r] = min_till[r - 1]\\n        return res if res < float(\\'inf\\') else -1\\n\\t\\nTime = O(n): when sliding the window, left and right pointers traverse the array once.\\nSpace = O(n): we use one additional list min_till[] to record min length of target subarray till index i.",
                "codeTag": "Java"
            },
            {
                "id": 1787274,
                "title": "summary-for-3-ways-by-using-prefix-sum-or-sliding-window",
                "content": "prefix sum and iterate twice\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) { //this fits the case when there\\'s negative number, kind like 560\\n        if (arr == null || arr.length == 0) return 0;\\n        Map<Integer, Integer> map = new HashMap<>(); //sum - index\\n        map.put(0, -1);\\n        int sum = 0;\\n        for (int i = 0; i < arr.length; i++) { //record preSum and index\\n            sum += arr[i];\\n            map.put(sum, i);\\n        }\\n        sum = 0;\\n        int size = arr.length + 1, res = arr.length + 1;//note if we set size as MAX_VALUE the line 16 may overflow\\n        for (int i = 0; i < arr.length; i++) {\\n            sum += arr[i];\\n            if (map.containsKey(sum - target)) size = Math.min(size, i - map.get(sum - target)); //find the subarray from the previous index to current one\\n            if (map.containsKey(sum + target)) res = Math.min(res, size + map.get(sum + target) - i); //from the current index to next one, this avoid overlap\\n        }\\n        return res == arr.length + 1 ? -1 : res;\\n    }\\n}\\n```\\n\\nprefix sum just iterate once by using extra array to record previous valid subarray length\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        if (arr == null || arr.length == 0) return 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0, n = arr.length, res = n + 1;\\n        map.put(0, -1);\\n        int[] min = new int[n];\\n        for (int i = 0; i < arr.length; i++) {\\n            sum += arr[i];\\n            min[i] = i > 0 ? min[i - 1] : n + 1;\\n            if (map.containsKey(sum - target)) {\\n                int pre = map.get(sum - target);\\n                min[i] = Math.min(min[i], i - pre);\\n\\t\\t\\t\\t// if pre equals -1 means we only get one sub-array whoes sum eqauls target\\n                if (pre != -1 && min[pre] != n + 1) res = Math.min(res, min[pre] + i - pre);\\n            }\\n            map.put(sum, i);\\n        }\\n        return res == n + 1 ? -1 : res;\\n    }\\n}\\n```\\n\\nSliding window without hashmap to iterate once and also use extra array to record previous valid subarray length\\nNote this only works when all elements >= 0\\n```\\nclass Solution { \\n   public int minSumOfLengths(int[] arr, int target) {\\n       if (arr == null || arr.length == 0) return 0;\\n       int n = arr.length;\\n       int[] best = new int[n];\\n       Arrays.fill(best, n + 1);\\n       int sum = 0, start = 0, ans = n + 1, bestSoFar = n + 1;\\n       for(int i = 0; i < n; i++){\\n           sum += arr[i];\\n           while(sum > target) sum -= arr[start++];\\n           if(sum == target){\\n               int cur = i - start + 1;\\n               if(start > 0 && best[start - 1] != n + 1) ans = Math.min(ans, best[start - 1] + cur); //first subarray exists\\n               bestSoFar = Math.min(bestSoFar, cur); //update current one\\n           }\\n           best[i] = bestSoFar;\\n       }\\n       return ans == n + 1 ? -1 : ans;\\n   }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) { //this fits the case when there\\'s negative number, kind like 560\\n        if (arr == null || arr.length == 0) return 0;\\n        Map<Integer, Integer> map = new HashMap<>(); //sum - index\\n        map.put(0, -1);\\n        int sum = 0;\\n        for (int i = 0; i < arr.length; i++) { //record preSum and index\\n            sum += arr[i];\\n            map.put(sum, i);\\n        }\\n        sum = 0;\\n        int size = arr.length + 1, res = arr.length + 1;//note if we set size as MAX_VALUE the line 16 may overflow\\n        for (int i = 0; i < arr.length; i++) {\\n            sum += arr[i];\\n            if (map.containsKey(sum - target)) size = Math.min(size, i - map.get(sum - target)); //find the subarray from the previous index to current one\\n            if (map.containsKey(sum + target)) res = Math.min(res, size + map.get(sum + target) - i); //from the current index to next one, this avoid overlap\\n        }\\n        return res == arr.length + 1 ? -1 : res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        if (arr == null || arr.length == 0) return 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int sum = 0, n = arr.length, res = n + 1;\\n        map.put(0, -1);\\n        int[] min = new int[n];\\n        for (int i = 0; i < arr.length; i++) {\\n            sum += arr[i];\\n            min[i] = i > 0 ? min[i - 1] : n + 1;\\n            if (map.containsKey(sum - target)) {\\n                int pre = map.get(sum - target);\\n                min[i] = Math.min(min[i], i - pre);\\n\\t\\t\\t\\t// if pre equals -1 means we only get one sub-array whoes sum eqauls target\\n                if (pre != -1 && min[pre] != n + 1) res = Math.min(res, min[pre] + i - pre);\\n            }\\n            map.put(sum, i);\\n        }\\n        return res == n + 1 ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948086,
                "title": "python-one-pass",
                "content": "It\\'s standard to find valid intervals with sum equal to `target`. To find the min sum of lengths, we maintain the minimal length of such intervals that don\\'t overlap with current interval, and keep the min of sum when we traverse all possible intervals.\\n```\\n   def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        min_l = math.inf\\n        d = {0: -1}\\n        q = deque()\\n        s = 0\\n        res = math.inf\\n        for right_end, a in enumerate(arr):\\n            s += a\\n            if (s - target) in d:\\n                left_end = d[s - target]\\n\\t\\t        # The current interval is (left_end, right_end], left_end excluded. \\n                cur_l = right_end - left_end\\n\\t\\t\\t\\t# q maintain all previous valid intervals with [right_end, interval_length].\\n                while q and q[0][0] <= left_end:\\n                    min_l = min(min_l, q.popleft()[1])\\n\\t\\t\\t\\t# We can take any interval whose right_end <= current left end, we might as well take the shortest one.\\n                res = min(res, min_l + cur_l)\\n                q.append([i, cur_l])\\n            d[s] = right_end\\n        if res < math.inf:\\n            return res\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\n   def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        min_l = math.inf\\n        d = {0: -1}\\n        q = deque()\\n        s = 0\\n        res = math.inf\\n        for right_end, a in enumerate(arr):\\n            s += a\\n            if (s - target) in d:\\n                left_end = d[s - target]\\n\\t\\t        # The current interval is (left_end, right_end], left_end excluded. \\n                cur_l = right_end - left_end\\n\\t\\t\\t\\t# q maintain all previous valid intervals with [right_end, interval_length].\\n                while q and q[0][0] <= left_end:\\n                    min_l = min(min_l, q.popleft()[1])\\n\\t\\t\\t\\t# We can take any interval whose right_end <= current left end, we might as well take the shortest one.\\n                res = min(res, min_l + cur_l)\\n                q.append([i, cur_l])\\n            d[s] = right_end\\n        if res < math.inf:\\n            return res\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1079426,
                "title": "c-solution-with-detailed-explanation",
                "content": "According to the constraints, we know that values stored in \"arr\" are all positive value.\\nWhich give us 2 preconditions:\\n1. there\\'s no duplicates if we calculate accumulative sum \"Accum\" for all possible value of i. (0 <= i < arr.size())\\n- Accum[i] stores the sum of arr[0] + arr[1] + ... + arr[i] \\n2. \"Accum\" array is in increasing order.\\n\\nWith above preconditions, \\n1. We loop through \"arr\" for the first time and setup a hash table \"tbl\" that store {accum[i], i} as {key, value} pair.\\n2. Loop through \"arr\" again, this time we keep track of current accumulative sum \"sum\". (current index).\\n3. if \"sum - target\" exist in the hash table, which means there\\'s a subarray on the left and ends at index i with length of i - tbl[sum - target].  Update the \"l_len\" to keep track of minimum length of left subarray .\\n- Since \"sum\" and \"target\" are both positive integer and accum[i] is in increasing order, tbl[sum - target] would guarantee to be smaller than i\\n4. if \"sum + target\" exist in the hash table, which means there\\'s a subarray on the right that starts from index i + 1 with length of tbl[sum + target] - i. Update \"ret\" to keep track of minimum sum of two subarray length.\\n\\nNote that Step#3 & #4 would guarantee two subrarry are non-overlapping.\\n\\n\\n```\\nint minSumOfLengths(vector<int>& arr, int target) {\\n        unordered_map<int, int> tbl;\\n        int sum = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            sum += arr[i];\\n            tbl[sum] = i;\\n        }\\n        int l_len = INT_MAX;\\n        int ret = INT_MAX;\\n        sum = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            sum += arr[i];\\n            if (tbl.count(sum - target))\\n                l_len = min(l_len, i - tbl[sum - target]);\\n            else if (sum == target)\\n                l_len = min(l_len, tbl[sum] + 1);\\n            if (tbl.count(sum + target) && l_len != INT_MAX)\\n                ret = min(ret, tbl[sum + target] - i + l_len);\\n        }\\n        return (ret == INT_MAX) ? (-1):(ret);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minSumOfLengths(vector<int>& arr, int target) {\\n        unordered_map<int, int> tbl;\\n        int sum = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            sum += arr[i];\\n            tbl[sum] = i;\\n        }\\n        int l_len = INT_MAX;\\n        int ret = INT_MAX;\\n        sum = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            sum += arr[i];\\n            if (tbl.count(sum - target))\\n                l_len = min(l_len, i - tbl[sum - target]);\\n            else if (sum == target)\\n                l_len = min(l_len, tbl[sum] + 1);\\n            if (tbl.count(sum + target) && l_len != INT_MAX)\\n                ret = min(ret, tbl[sum + target] - i + l_len);\\n        }\\n        return (ret == INT_MAX) ? (-1):(ret);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 807629,
                "title": "how-i-gradually-optimized-c",
                "content": "\\nHOW I APPROACHED AND GRADUALLY OPTIMIZED\\n\\nFIRST (TLE) 53/60 passed\\n\\n1) prefix sum array\\n2) collect all the subarray {start, end} whose sum matches target\\n3) loop through unique pair subarrays N*(N-1)/2\\n4) compare non-overlapping and minimize the sum of their lengths\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        arr.insert(arr.begin(),0);\\n        \\n        for(int i=1;i<=n;i++)\\n            arr[i]+=arr[i-1];\\n        \\n        vector<pair<int,int>> vtr;\\n        for(int i=0;i<n;i++){\\n           for(int j=i;j<n;j++){\\n               int subsum = arr[j+1]-arr[i];\\n               if(subsum==target)\\n                   vtr.push_back({i,j});\\n           }\\n        }\\n\\n        int mini = INT_MAX;\\n        if(vtr.size()<=1)\\n            return -1;\\n        for(int i=0;i<vtr.size();i++){\\n            for(int j=i+1; j<vtr.size();j++){\\n                if(vtr[i].second<vtr[j].first){\\n                    mini=min(vtr[i].second-vtr[i].first+1 + vtr[j].second-vtr[j].first+1 , mini);\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX) return -1;\\n        else return mini;\\n        \\n    }\\n};\\n```\\n\\n\\nSECOND 54/60 (TLE) PASSED\\n\\n1) JUST BREAKING THE LOOP WHEN SUBARRAY SUM IS GREATER THAN THE TARGET\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        arr.insert(arr.begin(),0);\\n        \\n        for(int i=1;i<=n;i++)\\n            arr[i]+=arr[i-1];\\n        \\n\\n        vector<pair<int,int>> vtr;\\n        for(int i=0;i<n;i++){\\n           for(int j=i;j<n;j++){\\n               int subsum = arr[j+1]-arr[i];\\n               if(subsum>target)\\n                   break;\\n               if(subsum==target)\\n                   vtr.push_back({i,j});\\n           }\\n        }\\n     \\n        int mini = INT_MAX;\\n        if(vtr.size()<=1)\\n            return -1;\\n        for(int i=0;i<vtr.size();i++){\\n            for(int j=i+1; j<vtr.size();j++){\\n                if(vtr[i].second<vtr[j].first){\\n                    mini=min(vtr[i].second-vtr[i].first+1 + vtr[j].second-vtr[j].first+1 , mini);\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX) return -1;\\n        else return mini;\\n        \\n    }\\n};\\n```\\n\\nTHIRD 54/60 (TLE) PASSED\\n\\n1) INSTEAD OF PREFIX SUM ARRAY, I USED A HASHMAP TO STORE THE {SUM, ending_array_index}\\n2) WITH THE HELP OF THE MAP COLLECT SUBARRAY INDICES {start, end} WHOSE SUM EQUALS TARGET\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                vtr.push_back({mp[sum-target]+1, i});\\n            }\\n            mp[sum]=i;\\n        }\\n        for(auto x:vtr)\\n            cout<<x.first<<\" \"<<x.second<<endl;\\n        \\n        \\n         int mini = INT_MAX;\\n        if(vtr.size()<=1)\\n            return -1;\\n        for(int i=0;i<vtr.size();i++){\\n            for(int j=i+1; j<vtr.size();j++){\\n                if(vtr[i].second<vtr[j].first){\\n                    mini=min(vtr[i].second-vtr[i].first+1 + vtr[j].second-vtr[j].first+1 , mini);\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX) return -1;\\n        else return mini;\\n        \\n    }\\n};\\n```\\n\\nFOURTH (WRONG) 56/60 PASSED\\n\\n1) TO OPTIMIZE THE SECOND PART, I DO NOT CHECK THAT OVERLAPPING CONDITION\\n2) JUST ADDED THE TWO MEAN SUBARRAY LENGTH AND RETURNED\\n\\n```\\nbool comp(pair<int,int> a, pair<int,int> b){\\n    return a.second-a.first+1 < b.second-b.first+1;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                vtr.push_back({mp[sum-target]+1, i});\\n            }\\n            mp[sum]=i;\\n        }\\n        if(vtr.size()<=1)\\n            return -1;\\n        sort(vtr.begin(), vtr.end(), comp);\\n        return vtr[0].second - vtr[0].first+1+vtr[1].second - vtr[1].first+1;\\n        \\n    }\\n};\\n```\\n\\nFIFTH (WRONG) 57/60 PASSED\\n\\n1) JUST ADDED A OVERLAP CHECKER TWO THE PREVIOUSLY INSERTED SUBARRAY INDICES\\n\\n```\\nbool comp(pair<int,int> a, pair<int,int> b){\\n    return a.second-a.first+1 < b.second-b.first+1;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                if(vtr.size()==0)\\n                    vtr.push_back({mp[sum-target]+1, i});\\n                else{\\n                    if(vtr.back().second<mp[sum-target]+1){\\n                        vtr.push_back({mp[sum-target]+1, i});\\n                    }\\n                }\\n            }\\n            mp[sum]=i;\\n        }\\n        if(vtr.size()<=1)\\n            return -1;\\n        sort(vtr.begin(), vtr.end(), comp);\\n        return vtr[0].second - vtr[0].first+1+vtr[1].second - vtr[1].first+1;\\n       \\n        \\n    }\\n};\\n```\\n\\nSIXTH (CORRECT) ALL PASSED (60/60)\\n\\n1) USED MAP TO STORE {KEY: ARRAY_INDEX -> VAL: PREFIX_SUM}\\n2) FOR EACH INDEX\\n    I SEARCHED IF TARGET SUM SUBARRAYS EXSIST IN THE LEFT OR NOT\\n        IF EXSIST I CONSIDER THE MINIMUM OF THEIR LENGTH\\n    I SEARCHED IF A TARGET SUM SUBARRAY EXSISTS IN ITS JUST RIGHT OR NOT\\n        IF EXSISTS ALONG WITH A VALID LEFT SUBARRAY I CONSIDER THE MINIMUM OF LENGTH SUM OF THE TWO\\n\\n```\\nbool comp(pair<int,int> a, pair<int,int> b){\\n    return a.second-a.first+1 < b.second-b.first+1;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            \\n        }\\n        \\n        int left =INT_MAX/2;\\n        int right=0;\\n        int mini = INT_MAX;\\n        sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                left = min(left,i-mp[sum-target]);\\n            }\\n            if(mp.find(sum+target)!=mp.end()){\\n                right = mp[sum+target]-i;\\n                if(left!=INT_MAX/2)\\n                    mini=min(mini, right+left);\\n            }\\n            \\n        }\\n        if(mini==INT_MAX)\\n            return -1;\\n        return mini;\\n    \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        arr.insert(arr.begin(),0);\\n        \\n        for(int i=1;i<=n;i++)\\n            arr[i]+=arr[i-1];\\n        \\n        vector<pair<int,int>> vtr;\\n        for(int i=0;i<n;i++){\\n           for(int j=i;j<n;j++){\\n               int subsum = arr[j+1]-arr[i];\\n               if(subsum==target)\\n                   vtr.push_back({i,j});\\n           }\\n        }\\n\\n        int mini = INT_MAX;\\n        if(vtr.size()<=1)\\n            return -1;\\n        for(int i=0;i<vtr.size();i++){\\n            for(int j=i+1; j<vtr.size();j++){\\n                if(vtr[i].second<vtr[j].first){\\n                    mini=min(vtr[i].second-vtr[i].first+1 + vtr[j].second-vtr[j].first+1 , mini);\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX) return -1;\\n        else return mini;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        arr.insert(arr.begin(),0);\\n        \\n        for(int i=1;i<=n;i++)\\n            arr[i]+=arr[i-1];\\n        \\n\\n        vector<pair<int,int>> vtr;\\n        for(int i=0;i<n;i++){\\n           for(int j=i;j<n;j++){\\n               int subsum = arr[j+1]-arr[i];\\n               if(subsum>target)\\n                   break;\\n               if(subsum==target)\\n                   vtr.push_back({i,j});\\n           }\\n        }\\n     \\n        int mini = INT_MAX;\\n        if(vtr.size()<=1)\\n            return -1;\\n        for(int i=0;i<vtr.size();i++){\\n            for(int j=i+1; j<vtr.size();j++){\\n                if(vtr[i].second<vtr[j].first){\\n                    mini=min(vtr[i].second-vtr[i].first+1 + vtr[j].second-vtr[j].first+1 , mini);\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX) return -1;\\n        else return mini;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                vtr.push_back({mp[sum-target]+1, i});\\n            }\\n            mp[sum]=i;\\n        }\\n        for(auto x:vtr)\\n            cout<<x.first<<\" \"<<x.second<<endl;\\n        \\n        \\n         int mini = INT_MAX;\\n        if(vtr.size()<=1)\\n            return -1;\\n        for(int i=0;i<vtr.size();i++){\\n            for(int j=i+1; j<vtr.size();j++){\\n                if(vtr[i].second<vtr[j].first){\\n                    mini=min(vtr[i].second-vtr[i].first+1 + vtr[j].second-vtr[j].first+1 , mini);\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX) return -1;\\n        else return mini;\\n        \\n    }\\n};\\n```\n```\\nbool comp(pair<int,int> a, pair<int,int> b){\\n    return a.second-a.first+1 < b.second-b.first+1;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                vtr.push_back({mp[sum-target]+1, i});\\n            }\\n            mp[sum]=i;\\n        }\\n        if(vtr.size()<=1)\\n            return -1;\\n        sort(vtr.begin(), vtr.end(), comp);\\n        return vtr[0].second - vtr[0].first+1+vtr[1].second - vtr[1].first+1;\\n        \\n    }\\n};\\n```\n```\\nbool comp(pair<int,int> a, pair<int,int> b){\\n    return a.second-a.first+1 < b.second-b.first+1;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                if(vtr.size()==0)\\n                    vtr.push_back({mp[sum-target]+1, i});\\n                else{\\n                    if(vtr.back().second<mp[sum-target]+1){\\n                        vtr.push_back({mp[sum-target]+1, i});\\n                    }\\n                }\\n            }\\n            mp[sum]=i;\\n        }\\n        if(vtr.size()<=1)\\n            return -1;\\n        sort(vtr.begin(), vtr.end(), comp);\\n        return vtr[0].second - vtr[0].first+1+vtr[1].second - vtr[1].first+1;\\n       \\n        \\n    }\\n};\\n```\n```\\nbool comp(pair<int,int> a, pair<int,int> b){\\n    return a.second-a.first+1 < b.second-b.first+1;\\n}\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> v = arr;\\n        map<int,int> mp;\\n        mp[0]=-1;\\n        vector<pair<int,int>> vtr;\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            \\n        }\\n        \\n        int left =INT_MAX/2;\\n        int right=0;\\n        int mini = INT_MAX;\\n        sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(mp.find(sum-target)!=mp.end()){\\n                left = min(left,i-mp[sum-target]);\\n            }\\n            if(mp.find(sum+target)!=mp.end()){\\n                right = mp[sum+target]-i;\\n                if(left!=INT_MAX/2)\\n                    mini=min(mini, right+left);\\n            }\\n            \\n        }\\n        if(mini==INT_MAX)\\n            return -1;\\n        return mini;\\n    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 685490,
                "title": "c-o-n-sliding-window-find-all-intervals-pick-two-non-overlapping-smallest",
                "content": "**Update**:  We can maintain minimum length so far at each array index so when sum == target, we can look up if there is length encountered which is minimum as well as non-overlapping by checking the value at index `start - 1`\\n\\n```csharp\\npublic int MinSumOfLengths(int[] arr, int target)\\n{\\n\\tint[] minLengths = new int[arr.Length];\\n\\tfor (int i = 0; i < arr.Length; i++)\\n\\t{\\n\\t\\tminLengths[i] = int.MaxValue;\\n\\t}\\n\\n\\tint sum = 0;\\n\\tint start = 0;\\n\\tint result = int.MaxValue;\\n\\tint currentMinLength = int.MaxValue;\\n\\n\\tfor (int end = 0; end < arr.Length; end++)\\n\\t{\\n\\t\\tsum += arr[end];\\n\\n\\t\\twhile (sum > target)\\n\\t\\t{\\n\\t\\t\\tsum -= arr[start];\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\n\\t\\tif (sum == target)\\n\\t\\t{\\n\\t\\t\\tint currentLength = end - start + 1;\\n\\n\\t\\t\\tif (start > 0 && minLengths[start - 1] != int.MaxValue)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = Math.Min(result, minLengths[start - 1] + currentLength);\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentMinLength = Math.Min(currentMinLength, currentLength);\\n\\t\\t}\\n\\n\\t\\tminLengths[end] = currentMinLength;\\n\\t}\\n\\n\\treturn result == int.MaxValue ? -1 : result;\\n}\\n```\\n\\nBelow is original incorrect solution - min length may not be correct as first pick since for test cases like [1,1,3,2,1,1,1]  - it would pick(3, 2) and block (1,1,3) (2,1,1,1) as lengths to be considered giving no solution.\\n\\n```csharp\\npublic int MinSumOfLengths(int[] arr, int target) \\n{\\n\\tList<(int Start, int End, int Length)> lengths = new List<(int, int, int)>();\\n\\tint sum = 0;\\n\\tint start = 0;\\n\\n\\tfor(int end = 0; end < arr.Length; end++)\\n\\t{\\n\\t\\tsum += arr[end];\\n\\n\\t\\twhile(sum > target && start <= end)\\n\\t\\t{\\n\\t\\t\\tsum -= arr[start];\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\n\\t\\tif(sum == target)\\n\\t\\t{\\n\\t\\t\\tlengths.Add((start, end, end - start + 1));\\n\\t\\t}\\n\\t}\\n\\n\\tif(lengths.Count < 2)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tlengths = lengths.OrderBy(x => x.Length).ToList();\\n\\tvar first = lengths[0];\\n\\tforeach(var len in lengths)\\n\\t{\\n\\t\\tif(len.Start > first.End || len.End < first.Start)\\n\\t\\t{\\n\\t\\t\\treturn first.Length + len.Length;\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int MinSumOfLengths(int[] arr, int target)\\n{\\n\\tint[] minLengths = new int[arr.Length];\\n\\tfor (int i = 0; i < arr.Length; i++)\\n\\t{\\n\\t\\tminLengths[i] = int.MaxValue;\\n\\t}\\n\\n\\tint sum = 0;\\n\\tint start = 0;\\n\\tint result = int.MaxValue;\\n\\tint currentMinLength = int.MaxValue;\\n\\n\\tfor (int end = 0; end < arr.Length; end++)\\n\\t{\\n\\t\\tsum += arr[end];\\n\\n\\t\\twhile (sum > target)\\n\\t\\t{\\n\\t\\t\\tsum -= arr[start];\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\n\\t\\tif (sum == target)\\n\\t\\t{\\n\\t\\t\\tint currentLength = end - start + 1;\\n\\n\\t\\t\\tif (start > 0 && minLengths[start - 1] != int.MaxValue)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = Math.Min(result, minLengths[start - 1] + currentLength);\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentMinLength = Math.Min(currentMinLength, currentLength);\\n\\t\\t}\\n\\n\\t\\tminLengths[end] = currentMinLength;\\n\\t}\\n\\n\\treturn result == int.MaxValue ? -1 : result;\\n}\\n```\n```csharp\\npublic int MinSumOfLengths(int[] arr, int target) \\n{\\n\\tList<(int Start, int End, int Length)> lengths = new List<(int, int, int)>();\\n\\tint sum = 0;\\n\\tint start = 0;\\n\\n\\tfor(int end = 0; end < arr.Length; end++)\\n\\t{\\n\\t\\tsum += arr[end];\\n\\n\\t\\twhile(sum > target && start <= end)\\n\\t\\t{\\n\\t\\t\\tsum -= arr[start];\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\n\\t\\tif(sum == target)\\n\\t\\t{\\n\\t\\t\\tlengths.Add((start, end, end - start + 1));\\n\\t\\t}\\n\\t}\\n\\n\\tif(lengths.Count < 2)\\n\\t{\\n\\t\\treturn -1;\\n\\t}\\n\\n\\tlengths = lengths.OrderBy(x => x.Length).ToList();\\n\\tvar first = lengths[0];\\n\\tforeach(var len in lengths)\\n\\t{\\n\\t\\tif(len.Start > first.End || len.End < first.Start)\\n\\t\\t{\\n\\t\\t\\treturn first.Length + len.Length;\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 685356,
                "title": "google-onsite-question-very-easy-java-o-n-with-explanation",
                "content": "```\\nclass Solution {\\n    \\n    private int INF = 1000000;\\n    \\n    public int minSumOfLengths(int[] arr, int target) {\\n        if(arr == null || arr.length == 0 || target <= 0) {\\n            return 0;\\n        }\\n        \\n        int[] left = findLeft(arr, target); // Calculate length of all sub arrays whose sum is target & ends at i, starts at any j >= 0 where j <= i.\\n        int[] right = findLeft(reverse(arr), target); // Do the same thing for right side.\\n        right = reverse(right);\\n        \\n\\t\\t// Now start from the left, for all i, replace left[i] with the best (minimum most) length, we do this so that at any point i, we know the most optimal sub array length from the left. We will use this information after some time.\\n        int minLeft = left[0];\\n        for(int i = 1; i < left.length; i++) {\\n            minLeft = Math.min(minLeft, left[i]);\\n            left[i] = minLeft;\\n        }\\n        \\n        int result = INF;\\n\\t\\t// Now, left[i] already contains most optimal left side sub array length with sum = target from 0 to i.\\n\\t\\t// We will start with right side, make sum of right[i] & left[i-1] since we need to take non-overlapping sub arrays, and compare the sum with result & set the result if necessary.\\n        for(int i = right.length - 1; i > 0; i--) {\\n            if(right[i] + left[i-1] < result) {\\n                result = right[i] + left[i-1];\\n            }\\n        }\\n        \\n        return result < INF ? result : -1;\\n    }\\n    \\n    private int[] reverse(int[] a) {\\n        int[] r = new int[a.length];\\n        int i = 0;\\n        for(; i < a.length; i++) {\\n            r[i] = a[a.length - 1 - i];\\n        }\\n        \\n        return r;\\n    } \\n    \\n    private int[] findLeft(int[] arr, int target) {\\n        int start = 0, i = 0;\\n        int sum = 0;\\n        int[] left = new int[arr.length];\\n        Arrays.fill(left, INF);\\n        \\n        while(i < arr.length) {\\n            sum += arr[i];\\n            \\n            while(sum > target && start <= i) {\\n                sum -= arr[start];\\n                start++;\\n            }\\n            \\n            if(sum == target) {\\n                left[i] = i - start + 1;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int INF = 1000000;\\n    \\n    public int minSumOfLengths(int[] arr, int target) {\\n        if(arr == null || arr.length == 0 || target <= 0) {\\n            return 0;\\n        }\\n        \\n        int[] left = findLeft(arr, target); // Calculate length of all sub arrays whose sum is target & ends at i, starts at any j >= 0 where j <= i.\\n        int[] right = findLeft(reverse(arr), target); // Do the same thing for right side.\\n        right = reverse(right);\\n        \\n\\t\\t// Now start from the left, for all i, replace left[i] with the best (minimum most) length, we do this so that at any point i, we know the most optimal sub array length from the left. We will use this information after some time.\\n        int minLeft = left[0];\\n        for(int i = 1; i < left.length; i++) {\\n            minLeft = Math.min(minLeft, left[i]);\\n            left[i] = minLeft;\\n        }\\n        \\n        int result = INF;\\n\\t\\t// Now, left[i] already contains most optimal left side sub array length with sum = target from 0 to i.\\n\\t\\t// We will start with right side, make sum of right[i] & left[i-1] since we need to take non-overlapping sub arrays, and compare the sum with result & set the result if necessary.\\n        for(int i = right.length - 1; i > 0; i--) {\\n            if(right[i] + left[i-1] < result) {\\n                result = right[i] + left[i-1];\\n            }\\n        }\\n        \\n        return result < INF ? result : -1;\\n    }\\n    \\n    private int[] reverse(int[] a) {\\n        int[] r = new int[a.length];\\n        int i = 0;\\n        for(; i < a.length; i++) {\\n            r[i] = a[a.length - 1 - i];\\n        }\\n        \\n        return r;\\n    } \\n    \\n    private int[] findLeft(int[] arr, int target) {\\n        int start = 0, i = 0;\\n        int sum = 0;\\n        int[] left = new int[arr.length];\\n        Arrays.fill(left, INF);\\n        \\n        while(i < arr.length) {\\n            sum += arr[i];\\n            \\n            while(sum > target && start <= i) {\\n                sum -= arr[start];\\n                start++;\\n            }\\n            \\n            if(sum == target) {\\n                left[i] = i - start + 1;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329637,
                "title": "c-sliding-window-prefix-sum-dp-solution-o-n",
                "content": "Runtime: 108 ms, faster than 76.46% of C++ online submissions for Find Two Non-overlapping Sub-arrays Each With Target Sum.\\nMemory Usage: 77 MB, less than 65.79% of C++ online submissions for Find Two Non-overlapping Sub-arrays Each With Target Sum.\\n\\n```\\nFinding target sum sub-array can be done using Sliding Window and Prefix Sum approach easily. \\nChallenge is tracking the total min length of 2 target sum subarray who has min length and there is where DP is needed. \\nWhat to store in DP so that we can get the min length non-overlapping array while\\nwe find a target subarray 2nd time ? We can store the min length of possible target sum subarray\\nin DP and so we can use that later to calculate total min length 2 target sum subarray when we find\\ntarget sum subarray again where DP[first-1] will return a previous non-overlapping taregt sum subarray min length.\\n```\\n\\n**NOTE: Below sliding window code iteration is index 1 based.**\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        \\n        // track prefix sum of array \\n        vector<int>sum(n+1,0);\\n        \\n        // track the min length target sum subarray till last pointer\\n        vector<int>dp(n+1,INT_MAX);\\n        \\n        sum[0] = 0;\\n        \\n        // first pointer of the window \\n        int first = 1;        \\n        \\n        // result min length sum of 2 target sum sub array\\n        int min_length_sum = INT_MAX;\\n        \\n        // current window length\\n        int curr_len = 0;\\n        \\n        // min length target sum subarray till last pointer\\n        int min_len = INT_MAX;\\n        \\n        // loop through array and check target sum subarray and previous min length target sum subarray\\n        for(int last=1;last<=n;last++)\\n        {\\n            // update prefix sum for current last pointer\\n            sum[last] = sum[last-1] + arr[last-1];\\n            curr_len++;\\n            \\n            // shrink window until window sum <= target \\n            while((sum[last] - sum[first-1]) > target)\\n                first++,curr_len--;\\n            \\n            // check for previous valid target sum subarray of min length if current window sum == target\\n            if((sum[last] - sum[first-1])==target)\\n            {\\n                // if previous target sum subarray exists then update min_length_sum\\n                // if no previous target sum subarray exists then dp[first-2] will be INT_MAX\\n                // dp[first-2] returns min length of target sum subarray which has last < current first\\n                if(first>1 && dp[first-2]!=INT_MAX)\\n                    min_length_sum = min(min_length_sum,(dp[first-2] + curr_len));\\n                \\n                // update min length only any target sum subarray found \\n                min_len = min(min_len,curr_len);                                        \\n            }\\n            \\n            // update DP[last-1] with min_len which stores the min length of possible target sum subrray till last\\n            dp[last-1] = min_len;\\n        }\\n        \\n        // no result found if min_length_sum is INT_MAX\\n        return min_length_sum==INT_MAX?-1 : min_length_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Dynamic Programming",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nFinding target sum sub-array can be done using Sliding Window and Prefix Sum approach easily. \\nChallenge is tracking the total min length of 2 target sum subarray who has min length and there is where DP is needed. \\nWhat to store in DP so that we can get the min length non-overlapping array while\\nwe find a target subarray 2nd time ? We can store the min length of possible target sum subarray\\nin DP and so we can use that later to calculate total min length 2 target sum subarray when we find\\ntarget sum subarray again where DP[first-1] will return a previous non-overlapping taregt sum subarray min length.\\n```\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size();\\n        \\n        // track prefix sum of array \\n        vector<int>sum(n+1,0);\\n        \\n        // track the min length target sum subarray till last pointer\\n        vector<int>dp(n+1,INT_MAX);\\n        \\n        sum[0] = 0;\\n        \\n        // first pointer of the window \\n        int first = 1;        \\n        \\n        // result min length sum of 2 target sum sub array\\n        int min_length_sum = INT_MAX;\\n        \\n        // current window length\\n        int curr_len = 0;\\n        \\n        // min length target sum subarray till last pointer\\n        int min_len = INT_MAX;\\n        \\n        // loop through array and check target sum subarray and previous min length target sum subarray\\n        for(int last=1;last<=n;last++)\\n        {\\n            // update prefix sum for current last pointer\\n            sum[last] = sum[last-1] + arr[last-1];\\n            curr_len++;\\n            \\n            // shrink window until window sum <= target \\n            while((sum[last] - sum[first-1]) > target)\\n                first++,curr_len--;\\n            \\n            // check for previous valid target sum subarray of min length if current window sum == target\\n            if((sum[last] - sum[first-1])==target)\\n            {\\n                // if previous target sum subarray exists then update min_length_sum\\n                // if no previous target sum subarray exists then dp[first-2] will be INT_MAX\\n                // dp[first-2] returns min length of target sum subarray which has last < current first\\n                if(first>1 && dp[first-2]!=INT_MAX)\\n                    min_length_sum = min(min_length_sum,(dp[first-2] + curr_len));\\n                \\n                // update min length only any target sum subarray found \\n                min_len = min(min_len,curr_len);                                        \\n            }\\n            \\n            // update DP[last-1] with min_len which stores the min length of possible target sum subrray till last\\n            dp[last-1] = min_len;\\n        }\\n        \\n        // no result found if min_length_sum is INT_MAX\\n        return min_length_sum==INT_MAX?-1 : min_length_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305708,
                "title": "java-o-n-time-o-n-space-using-two-pointers",
                "content": "```class Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int[] minsFound = new int[arr.length + 1];\\n        minsFound[0] = 2 * arr.length;\\n        int minLen = 2 * arr.length;\\n        int twoMinLens = 2 * arr.length;\\n        int sum = 0;\\n        int b = 0;\\n        int e = 0;\\n        while (b < arr.length) {\\n            if (sum == target) {\\n                minLen = Math.min(e - b, minLen);\\n                twoMinLens = Math.min(twoMinLens, e - b + minsFound[b]);\\n            }\\n            if (sum >= target || e == arr.length) {\\n                sum -= arr[b];\\n                b++;\\n            } else {\\n                minsFound[e] = minLen;\\n                sum += arr[e];\\n                e++;\\n            }\\n        }\\n        return twoMinLens < 2 * arr.length ? twoMinLens : -1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int[] minsFound = new int[arr.length + 1];\\n        minsFound[0] = 2 * arr.length;\\n        int minLen = 2 * arr.length;\\n        int twoMinLens = 2 * arr.length;\\n        int sum = 0;\\n        int b = 0;\\n        int e = 0;\\n        while (b < arr.length) {\\n            if (sum == target) {\\n                minLen = Math.min(e - b, minLen);\\n                twoMinLens = Math.min(twoMinLens, e - b + minsFound[b]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 848325,
                "title": "beat-100-and-dp-space-o-n-time-o-n",
                "content": "In fact, we don\\'t need to create all DP cache memory of entire array to store each found length\\nbecause only when the known minimal length of window changes(when we find window sum equals target), \\nwe need to store it into cache.\\nWe can use result to control the minimal sum of the two sub-arrays.\\n\\nThe cache size of minimal length only depends on \\n*how shorter length than target we find first.*  \\nIf target is 10 and we find one 10 first, the cache size will be always 1.\\nIf we find 9,1 first, the cache size will be always smaller than or equal 2.\\n\\n**The key point** in short is \\nwe only need to store minimal found length and result.\\n\\n**For example,**\\n(cache only stores the new minimum)\\nSuppose windows have no overlaps in the following example.\\nIf overlap, we just need to find the found length in cache without overlap, \\nbut cache is small, so it\\'s very fast. I will show it in code.\\n```\\nRound 0\\ncache {}, result {}, found length {}\\n```\\n```\\nRound 1\\ncache {2}, result {2}, found length {2}\\n```\\n```\\nRound 2\\ncache {2}, result {2+3}, found length {3}\\n```\\n```\\nRound 3\\ncache {2}, result {2+2}, found length {2}\\n```\\n```\\nRound 4\\ncache {2, 1}, result {2+1}, found length {1}\\n```\\n```\\nRound 5\\ncache {2, 1}, result {2+1}, found length {3}\\n```\\nIn a result, perfermance don\\'t change, \\nbut we save memory from using all DP cache memory of entire array.\\nCode with clear comments as below\\n\\n```\\nclass Solution: # best, 804 ms\\n  def minSumOfLengths(self, arr, target):\\n    result = inf = 2**31-1\\n    i = window = count = 0\\n    # preMin: store (index, previous shortest length)\\n    preMin = [(-1, inf)]\\n\\n    # i: window start, j: window end\\n    for j, num in enumerate(arr):\\n      window += num\\n      while window > target:\\n        window -= arr[i]\\n        i += 1\\n      if window == target:\\n        # curr: current length\\n        curr = j - i + 1\\n\\t\\t\\n\\t    # early stopping if found two single targets\\n        if curr == 1: \\n\\t\\t    count += 1\\n            if count == 2: return 2\\n\\t\\t\\n        n = 0 \\n        # find first minimal length n before window start i\\n        for index, length in preMin[::-1]:\\n          if index <= i-1: \\n            n = length           \\n            break\\n\\t\\t\\t\\n        # update result  \\n        if result > curr + n: result = curr + n\\n            \\n        # update shortest length\\n        if curr < preMin[-1][-1]: preMin.append((j, curr))\\n\\n    return result if result < inf else -1\\n```\\nwelcome upvote and comments",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nRound 0\\ncache {}, result {}, found length {}\\n```\n```\\nRound 1\\ncache {2}, result {2}, found length {2}\\n```\n```\\nRound 2\\ncache {2}, result {2+3}, found length {3}\\n```\n```\\nRound 3\\ncache {2}, result {2+2}, found length {2}\\n```\n```\\nRound 4\\ncache {2, 1}, result {2+1}, found length {1}\\n```\n```\\nRound 5\\ncache {2, 1}, result {2+1}, found length {3}\\n```\n```\\nclass Solution: # best, 804 ms\\n  def minSumOfLengths(self, arr, target):\\n    result = inf = 2**31-1\\n    i = window = count = 0\\n    # preMin: store (index, previous shortest length)\\n    preMin = [(-1, inf)]\\n\\n    # i: window start, j: window end\\n    for j, num in enumerate(arr):\\n      window += num\\n      while window > target:\\n        window -= arr[i]\\n        i += 1\\n      if window == target:\\n        # curr: current length\\n        curr = j - i + 1\\n\\t\\t\\n\\t    # early stopping if found two single targets\\n        if curr == 1: \\n\\t\\t    count += 1\\n            if count == 2: return 2\\n\\t\\t\\n        n = 0 \\n        # find first minimal length n before window start i\\n        for index, length in preMin[::-1]:\\n          if index <= i-1: \\n            n = length           \\n            break\\n\\t\\t\\t\\n        # update result  \\n        if result > curr + n: result = curr + n\\n            \\n        # update shortest length\\n        if curr < preMin[-1][-1]: preMin.append((j, curr))\\n\\n    return result if result < inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766171,
                "title": "javascript-o-n-with-hashmap-and-sliding-window",
                "content": "These are Java solutions with great votes. I\\'ve just converted them in to Javascript\\n\\n**Hashmap**\\n```\\nfunction minSumOfLengths(arr, target) {\\n  let hmap = new Map();\\n  let sum = 0, lsize = Number.MAX_VALUE, result = Number.MAX_VALUE;\\n  hmap.set(0, -1);\\n  for (let i = 0; i < arr.length; i++) {\\n    sum += arr[i];\\n    hmap.set(sum, i); // stores key as sum upto index i, and value as i.\\n  }\\n  sum = 0;\\n  for (let i = 0; i < arr.length; i++) {\\n    sum += arr[i];\\n    if (hmap.get(sum - target) != null) {\\n      lsize = Math.min(lsize, i - hmap.get(sum - target));      // stores minimum length of sub-array ending with index<= i with sum target. This ensures non- overlapping property.\\n    }\\n    //hmap.get(sum+target) searches for any sub-array starting with index i+1 with sum target.\\n    if (hmap.get(sum + target) != null && lsize < Number.MAX_VALUE) {\\n      result = Math.min(result, hmap.get(sum + target) - i + lsize); // updates the result only if both left and right sub-array exists.\\n    }\\n  }\\n  return result == Number.MAX_VALUE ? -1 : result;\\n}\\n```\\n\\n**Sliding Window**\\n```\\nvar minSumOfLengths = function (arr, target) {\\n  let n = arr.length;\\n  let best = new Array(n).fill(Number.MAX_VALUE);\\n  let sum = 0, start = 0, ans = Number.MAX_VALUE, bestSoFar = Number.MAX_VALUE;\\n  for (let i = 0; i < n; i++) {\\n    sum += arr[i];\\n    while (sum > target) {\\n      sum -= arr[start];\\n      start++;\\n    }\\n    if (sum == target) {\\n      if (start > 0 && best[start - 1] != Number.MAX_VALUE) {\\n        ans = Math.min(ans, best[start - 1] + i - start + 1);\\n      }\\n      bestSoFar = Math.min(bestSoFar, i - start + 1);\\n    }\\n    best[i] = bestSoFar;\\n  }\\n  return ans == Number.MAX_VALUE ? -1 : ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nfunction minSumOfLengths(arr, target) {\\n  let hmap = new Map();\\n  let sum = 0, lsize = Number.MAX_VALUE, result = Number.MAX_VALUE;\\n  hmap.set(0, -1);\\n  for (let i = 0; i < arr.length; i++) {\\n    sum += arr[i];\\n    hmap.set(sum, i); // stores key as sum upto index i, and value as i.\\n  }\\n  sum = 0;\\n  for (let i = 0; i < arr.length; i++) {\\n    sum += arr[i];\\n    if (hmap.get(sum - target) != null) {\\n      lsize = Math.min(lsize, i - hmap.get(sum - target));      // stores minimum length of sub-array ending with index<= i with sum target. This ensures non- overlapping property.\\n    }\\n    //hmap.get(sum+target) searches for any sub-array starting with index i+1 with sum target.\\n    if (hmap.get(sum + target) != null && lsize < Number.MAX_VALUE) {\\n      result = Math.min(result, hmap.get(sum + target) - i + lsize); // updates the result only if both left and right sub-array exists.\\n    }\\n  }\\n  return result == Number.MAX_VALUE ? -1 : result;\\n}\\n```\n```\\nvar minSumOfLengths = function (arr, target) {\\n  let n = arr.length;\\n  let best = new Array(n).fill(Number.MAX_VALUE);\\n  let sum = 0, start = 0, ans = Number.MAX_VALUE, bestSoFar = Number.MAX_VALUE;\\n  for (let i = 0; i < n; i++) {\\n    sum += arr[i];\\n    while (sum > target) {\\n      sum -= arr[start];\\n      start++;\\n    }\\n    if (sum == target) {\\n      if (start > 0 && best[start - 1] != Number.MAX_VALUE) {\\n        ans = Math.min(ans, best[start - 1] + i - start + 1);\\n      }\\n      bestSoFar = Math.min(bestSoFar, i - start + 1);\\n    }\\n    best[i] = bestSoFar;\\n  }\\n  return ans == Number.MAX_VALUE ? -1 : ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 753675,
                "title": "python-rust-prefix-sum",
                "content": "-  **Python**\\n\\n```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        s, lsize, res = 0, float(\\'inf\\'), float(\\'inf\\')\\n        prefixSum = { 0: -1 }\\n        \\n        for i, val in enumerate(arr):\\n            s += val\\n            prefixSum[s] = i\\n            \\n        s = 0\\n        for i, val in enumerate(arr):\\n            s += val\\n            \\n            if s - target in prefixSum:\\n                lsize = min(i - prefixSum[s - target], lsize)\\n            \\n            if s + target in prefixSum and lsize != float(\\'inf\\'):\\n                rsize = prefixSum[s + target] - i\\n                res = min(res, rsize + lsize)\\n                \\n        return res if res != float(\\'inf\\') else -1\\n```\\n\\n- **Rust**\\n\\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn min_sum_of_lengths(arr: Vec<i32>, target: i32) -> i32 {\\n        let (mut sum, mut res, mut lsize) = (0, std::i32::MAX, std::i32::MAX);\\n        let mut prefixSum: HashMap<i32, i32> = HashMap::new();\\n        \\n        prefixSum.insert(0, -1);\\n        \\n        for (i, val) in arr.iter().enumerate() {\\n            sum += *val;\\n            prefixSum.insert(sum, i as i32);\\n        }\\n        \\n        sum = 0;\\n        for (i, val) in arr.iter().enumerate() {\\n            sum += *val;\\n            let index = i as i32;\\n            \\n            if prefixSum.contains_key(&(sum - target)) {\\n                lsize = lsize.min(index - *prefixSum.get(&(sum - target)).unwrap());\\n            }\\n            \\n            if prefixSum.contains_key(&(sum + target)) && lsize != std::i32::MAX {\\n                let rsize = *prefixSum.get(&(sum + target)).unwrap() - index;\\n                res = res.min(rsize + lsize);\\n            }\\n        }\\n        \\n        return if res == std::i32::MAX { -1 } else { res }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        s, lsize, res = 0, float(\\'inf\\'), float(\\'inf\\')\\n        prefixSum = { 0: -1 }\\n        \\n        for i, val in enumerate(arr):\\n            s += val\\n            prefixSum[s] = i\\n            \\n        s = 0\\n        for i, val in enumerate(arr):\\n            s += val\\n            \\n            if s - target in prefixSum:\\n                lsize = min(i - prefixSum[s - target], lsize)\\n            \\n            if s + target in prefixSum and lsize != float(\\'inf\\'):\\n                rsize = prefixSum[s + target] - i\\n                res = min(res, rsize + lsize)\\n                \\n        return res if res != float(\\'inf\\') else -1\\n```\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn min_sum_of_lengths(arr: Vec<i32>, target: i32) -> i32 {\\n        let (mut sum, mut res, mut lsize) = (0, std::i32::MAX, std::i32::MAX);\\n        let mut prefixSum: HashMap<i32, i32> = HashMap::new();\\n        \\n        prefixSum.insert(0, -1);\\n        \\n        for (i, val) in arr.iter().enumerate() {\\n            sum += *val;\\n            prefixSum.insert(sum, i as i32);\\n        }\\n        \\n        sum = 0;\\n        for (i, val) in arr.iter().enumerate() {\\n            sum += *val;\\n            let index = i as i32;\\n            \\n            if prefixSum.contains_key(&(sum - target)) {\\n                lsize = lsize.min(index - *prefixSum.get(&(sum - target)).unwrap());\\n            }\\n            \\n            if prefixSum.contains_key(&(sum + target)) && lsize != std::i32::MAX {\\n                let rsize = *prefixSum.get(&(sum + target)).unwrap() - index;\\n                res = res.min(rsize + lsize);\\n            }\\n        }\\n        \\n        return if res == std::i32::MAX { -1 } else { res }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1738733,
                "title": "c-one-pass-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int size=arr.size(),sum=0,ans=INT_MAX;\\n        unordered_map<int,int>mp;\\n        // to handle corner cases,you can say it is also one pass,but i am just ignoring it :P\\n        arr.insert(arr.begin(),0);\\n        size++;\\n        // trackmin[i] will give you the minimum length of subarray till i(included) ,whose sum is equals to target\\n        vector<int>trackmin(size,INT_MAX);\\n        mp[0]=0;\\n        for(int i=1;i<size;i++){\\n           sum+=arr[i];\\n            // if we find subarray whose sum== target\\n            if(mp.find(sum-target)!=mp.end()){\\n                // calculate surrent length\\n                int curlen=i-mp[sum-target];\\n                // get previous length from trackmin\\n                int premin=trackmin[mp[sum-target]];\\n                if(premin!=INT_MAX)\\n                    ans=min(ans,curlen+premin);\\n                // update trackmin[i]\\n                trackmin[i]=min(curlen,trackmin[i-1]);\\n            }\\n            else\\n               trackmin[i]=trackmin[i-1];\\n            mp[sum]=i;\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```\\nDo **UPVOTE** is it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int size=arr.size(),sum=0,ans=INT_MAX;\\n        unordered_map<int,int>mp;\\n        // to handle corner cases,you can say it is also one pass,but i am just ignoring it :P\\n        arr.insert(arr.begin(),0);\\n        size++;\\n        // trackmin[i] will give you the minimum length of subarray till i(included) ,whose sum is equals to target\\n        vector<int>trackmin(size,INT_MAX);\\n        mp[0]=0;\\n        for(int i=1;i<size;i++){\\n           sum+=arr[i];\\n            // if we find subarray whose sum== target\\n            if(mp.find(sum-target)!=mp.end()){\\n                // calculate surrent length\\n                int curlen=i-mp[sum-target];\\n                // get previous length from trackmin\\n                int premin=trackmin[mp[sum-target]];\\n                if(premin!=INT_MAX)\\n                    ans=min(ans,curlen+premin);\\n                // update trackmin[i]\\n                trackmin[i]=min(curlen,trackmin[i-1]);\\n            }\\n            else\\n               trackmin[i]=trackmin[i-1];\\n            mp[sum]=i;\\n        }\\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580326,
                "title": "o-n-sliding-window-prefix-suffix-sums-suffix-min",
                "content": "Given an array of length `n` of positive numbers, our goal is to find two non-overlapping subarrays which:\\n- both sum to a specified target value  `T`\\n- whose sum of individual lengths are minimized\\n\\n**FINDING SUBARRAYS: SLIDING WINDOW + PREFIX/SUFFIX SUMS**\\nFor each index `i` of our array, we consider the following:\\n* The shortest subarray length ending at index `i` that sums to target `T`, denoted `end(i)`\\n* The shortest subarray length starting at index `i` that sums to target `T`, denoted `start(i)`\\n\\nTo compute `end(i)` for each ending index `i`, we can leverage prefix sums and a queue of already encountered indices as follows:\\n\\n* `prefix_sum(i) < T`: no subarray ending at `i` sums to `T` (since all entries are positive)\\n* `prefix_sum(i) = T`: The subarray from index 0 to `i` of length `i+1` is the unique one that ends at index `i` and sums to `T`\\n* `prefix_sum(i) > T`: Start going from the front of our queue of previously handled end indexes, and pop away anything for which the difference of prefix_sums between index `i` and that top index exceeds `T`. We know that we no longer have to bother checking that prior index, when we go to later/greater values `i`, since our prefix sum is monotonic increasing function (all values in the original array are positive), so if `prefix_sum(i) - prefix_sum(q(0)) > T`, then necessarily `prefix_sum(i+1) - prefix_sum(q(0)) > prefix_sum(i) - prefix_sum(q(0)) > T`. If we arrive finally at a difference in prefix sums that equals our target `T`, we\\'ve found a valid subarray ending at index `i`.\\n\\nWe can do the same thing for `start(i)`, but in this case, we are looking at differences of suffix sums (i.e. iterating from the back of the array, but still leveraging this sliding window/queue approach).\\n\\n**PUTTING IT ALL TOGETHER: SUFFIX MIN**\\nSo we now have a way of getting the length of subarrays that start/end at each index and sum to our target `T`. It follows now that for each possible index `i`, we need to determine the sum of lengths of:\\n\\n* the subarray ending at index `i` which sums to `T`\\n* the mimimum length of a subarray starting after index `i` which sums to `T`\\n\\nOr to put in more succinct notation:\\n```\\nend(i) + min_{j > i} {start(j)}\\n```\\nOur final answer wlll then just be the global min over all possible such first-end indices `i`:\\n```\\nmin_{i = 0, ..., n-1} {end(i) + min_{j > i} {start(j)}}\\n```\\n\\nIn order to avoid performing the `min_{j > i} start(j)` calculation `n` different times, we can leverage a suffix min here, given by the recursive formula:\\n```\\nsuffix_min(n-1) = min{infty, start(n-1)}\\nsuffix_min(j) = min(suffix_min(j+1), start(j)}  j = n-2, ..., 1, 0\\n```\\nand thus this last quantity involving nested mins can be done in linear time.\\n\\n**CODE**\\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        \\n        # STEP 1: For each possible index, find the minimum length subarray ending at that index which\\n        # sums to our desired target (infinity if no such subarray exists)\\n        prefix_sum = [0] * n\\n        min_len_ending_at = [float(\"inf\")] * n\\n        q = []\\n        for i in range(n):\\n            prefix_sum[i] = prefix_sum[i-1] + arr[i]\\n            if prefix_sum[i] == target:\\n                min_len_ending_at[i] = i + 1\\n            else:\\n                while q and prefix_sum[i] - prefix_sum[q[0]] > target:\\n                    q.pop(0)\\n                if len(q) > 0 and prefix_sum[i] - prefix_sum[q[0]] == target:\\n                    min_len_ending_at[i] = i - q[0]\\n            q.append(i)\\n        \\n        # STEP 2: For each possible index, find the minimum length subarray starting at that index which\\n        # sums to our desired target (infinity if no such subarray exists)\\n        suffix_sum = [0] * n\\n        min_len_starting_at = [float(\"inf\")] * n\\n        q = []\\n        for i in range(n-1, -1, -1):\\n            suffix_sum[i] = suffix_sum[(i+1) % n] + arr[i]\\n            if suffix_sum[i] == target:\\n                min_len_starting_at[i] = n - i\\n            else:\\n                while len(q) > 0 and suffix_sum[i] - suffix_sum[q[0]] > target:\\n                    q.pop(0)\\n                if len(q) > 0 and suffix_sum[i] - suffix_sum[q[0]] == target:\\n                    min_len_starting_at[i] = q[0] - i\\n            q.append(i)\\n        \\n        # STEP 3: For each possible index, determine the minimum length of any subarray starting at or after\\n        # this index, which sums to our desired target\\n        suffix_min_len_after = [float(inf)] * n\\n        for i in range(n-1, -1, -1):\\n            suffix_min_len_after[i] = min(suffix_min_len_after[(i+1) % n], min_len_starting_at[i])\\n        \\n        # STEP 4: For each possible end index, determine the sum of the:\\n        # - length of the subarray ending at the index which sums to target (infinity if no such subarray exists)\\n        # - length of shortest subarray starting AFTER this end index, which also sums to our target\\n        # and compare to current smallest such sum of interval lengths.\\n        res = float(\"inf\")\\n        for i in range(n-1):\\n            res = min(res, min_len_ending_at[i] + suffix_min_len_after[i+1])\\n        \\n        if res == float(\"inf\"):\\n            return -1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nend(i) + min_{j > i} {start(j)}\\n```\n```\\nmin_{i = 0, ..., n-1} {end(i) + min_{j > i} {start(j)}}\\n```\n```\\nsuffix_min(n-1) = min{infty, start(n-1)}\\nsuffix_min(j) = min(suffix_min(j+1), start(j)}  j = n-2, ..., 1, 0\\n```\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        \\n        # STEP 1: For each possible index, find the minimum length subarray ending at that index which\\n        # sums to our desired target (infinity if no such subarray exists)\\n        prefix_sum = [0] * n\\n        min_len_ending_at = [float(\"inf\")] * n\\n        q = []\\n        for i in range(n):\\n            prefix_sum[i] = prefix_sum[i-1] + arr[i]\\n            if prefix_sum[i] == target:\\n                min_len_ending_at[i] = i + 1\\n            else:\\n                while q and prefix_sum[i] - prefix_sum[q[0]] > target:\\n                    q.pop(0)\\n                if len(q) > 0 and prefix_sum[i] - prefix_sum[q[0]] == target:\\n                    min_len_ending_at[i] = i - q[0]\\n            q.append(i)\\n        \\n        # STEP 2: For each possible index, find the minimum length subarray starting at that index which\\n        # sums to our desired target (infinity if no such subarray exists)\\n        suffix_sum = [0] * n\\n        min_len_starting_at = [float(\"inf\")] * n\\n        q = []\\n        for i in range(n-1, -1, -1):\\n            suffix_sum[i] = suffix_sum[(i+1) % n] + arr[i]\\n            if suffix_sum[i] == target:\\n                min_len_starting_at[i] = n - i\\n            else:\\n                while len(q) > 0 and suffix_sum[i] - suffix_sum[q[0]] > target:\\n                    q.pop(0)\\n                if len(q) > 0 and suffix_sum[i] - suffix_sum[q[0]] == target:\\n                    min_len_starting_at[i] = q[0] - i\\n            q.append(i)\\n        \\n        # STEP 3: For each possible index, determine the minimum length of any subarray starting at or after\\n        # this index, which sums to our desired target\\n        suffix_min_len_after = [float(inf)] * n\\n        for i in range(n-1, -1, -1):\\n            suffix_min_len_after[i] = min(suffix_min_len_after[(i+1) % n], min_len_starting_at[i])\\n        \\n        # STEP 4: For each possible end index, determine the sum of the:\\n        # - length of the subarray ending at the index which sums to target (infinity if no such subarray exists)\\n        # - length of shortest subarray starting AFTER this end index, which also sums to our target\\n        # and compare to current smallest such sum of interval lengths.\\n        res = float(\"inf\")\\n        for i in range(n-1):\\n            res = min(res, min_len_ending_at[i] + suffix_min_len_after[i+1])\\n        \\n        if res == float(\"inf\"):\\n            return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411902,
                "title": "easy-c-sol",
                "content": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int start=0;\\n        int len=INT_MAX;\\n        \\n        int n=arr.size();\\n        \\n        int sum=0;\\n        int res=INT_MAX;\\n        \\n        vector<int> dp(n,INT_MAX);\\n        \\n        for(int end=0;end<n;end++)\\n        {\\n            sum+=arr[end];\\n            \\n            while(sum>target)\\n            {\\n                sum-=arr[start];\\n                start++;\\n            }\\n            \\n            if(sum==target)\\n            {\\n                int curlen=end-start+1;\\n                \\n                if(start>0  &&   dp[start-1]!=INT_MAX)\\n                {\\n                    res=min(curlen+dp[start-1],res);\\n                }\\n                \\n                len=min(curlen,len);\\n            }\\n            \\n            dp[end]=len;\\n            \\n        }\\n        \\n        if(res==INT_MAX)\\n            return -1;\\n        \\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int start=0;\\n        int len=INT_MAX;\\n        \\n        int n=arr.size();\\n        \\n        int sum=0;\\n        int res=INT_MAX;\\n        \\n        vector<int> dp(n,INT_MAX);\\n        \\n        for(int end=0;end<n;end++)\\n        {\\n            sum+=arr[end];\\n            \\n            while(sum>target)\\n            {\\n                sum-=arr[start];\\n                start++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1117315,
                "title": "o-n-one-pass-solution-using-hashmap",
                "content": "```\\nclass Solution:\\n    from collections import defaultdict\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefixSum = defaultdict(int) # prefix sum dictionary \\n        currSum = 0\\n        prefixSum[0] = -1 \\n        n = len(arr)\\n        res = float(\\'inf\\') # results\\n        dp = [float(\\'inf\\')] * n # dp[i] the length of longest subarray whose sum is target and ends at or before i \\n        for i in range(n):\\n            currSum += arr[i]\\n            restSum = currSum - target\\n            if i - 1 >= 0: dp[i] = dp[i-1] \\n            if restSum in prefixSum:\\n                right,left = i,prefixSum[restSum]+1\\n                if left - 1 >= 0:\\n                    res = min(res,right - left + 1 + dp[left - 1])\\n                dp[i] = min(dp[i],right - left + 1)\\n            prefixSum[currSum] = i # update prefix sum dictionary\\n        return res if res != float(\\'inf\\') else -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    from collections import defaultdict\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefixSum = defaultdict(int) # prefix sum dictionary \\n        currSum = 0\\n        prefixSum[0] = -1 \\n        n = len(arr)\\n        res = float(\\'inf\\') # results\\n        dp = [float(\\'inf\\')] * n # dp[i] the length of longest subarray whose sum is target and ends at or before i \\n        for i in range(n):\\n            currSum += arr[i]\\n            restSum = currSum - target\\n            if i - 1 >= 0: dp[i] = dp[i-1] \\n            if restSum in prefixSum:\\n                right,left = i,prefixSum[restSum]+1\\n                if left - 1 >= 0:\\n                    res = min(res,right - left + 1 + dp[left - 1])\\n                dp[i] = min(dp[i],right - left + 1)\\n            prefixSum[currSum] = i # update prefix sum dictionary\\n        return res if res != float(\\'inf\\') else -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025778,
                "title": "python3-sliding-window-one-pass-o-n",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        res, cur, i, p = inf, 0, 0, [inf]\\n        for j, a in enumerate(arr):\\n            cur += a\\n            while cur > target:\\n                cur -= arr[i]\\n                i += 1\\n            if cur == target:\\n                res = min(res, j-i+1+p[i])\\n                p += min(p[-1], j-i+1),\\n            else:\\n                p += p[-1],\\n        return res if res < inf else -1",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        res, cur, i, p = inf, 0, 0, [inf]\\n        for j, a in enumerate(arr):\\n            cur += a\\n            while cur > target:\\n                cur -= arr[i]\\n                i += 1\\n            if cur == target:\\n                res = min(res, j-i+1+p[i])\\n                p += min(p[-1], j-i+1),\\n            else:\\n                p += p[-1],\\n        return res if res < inf else -1",
                "codeTag": "Java"
            },
            {
                "id": 796649,
                "title": "prefix-sum-sliding-window-python-code-with-comments-beat-99",
                "content": "```\\nclass Solution(object):\\n    def minSumOfLengths(self, arr, target):\\n        # prefix sum + sliding window method O(n)\\n        \\n        n = len(arr)\\n        Max = 2**31-1\\n        minlens = [Max] * n # every position, has a min-length subarray ends/or before it, with a sum-up = target\\n        minlen = Max # currently (global) min-length subarray and whose sum-up = target\\n        ans = Max # final answer\\n        \\n        left = 0\\n        presum = 0  # store prefix-sum\\n        \\n        for right in range(n):\\n            presum += arr[right]\\n            \\n            while presum > target: # sliding window method to enlarge left so that presum <= target\\n                presum -= arr[left]\\n                left += 1\\n            \\n            if presum == target: # update values when we find presum==target\\n                curlen = right - left + 1 # the length of current subarray from left to right, both inclusive [left, right]\\n                if left > 0 and minlens[left-1] < Max: \\n\\t\\t\\t\\t    # since left is included in current subarray, we have to find a subarray with sum=target before left\\n\\t\\t\\t\\t    # and the best is recorded in minles[left-1]:\\n                    ans = min(ans, curlen + minlens[left-1]) \\n\\t\\t\\t\\t\\t# update ans, a former subarray with length minlens[left-1] and current length\\n                minlen = min(minlen, curlen) # update the global min-length of subarray whose sum-up = target\\n            minlens[right] = minlen # update right-position\\'s best minlen(before or ends at \\'right\\')\\n        return -1 if ans == Max else ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minSumOfLengths(self, arr, target):\\n        # prefix sum + sliding window method O(n)\\n        \\n        n = len(arr)\\n        Max = 2**31-1\\n        minlens = [Max] * n # every position, has a min-length subarray ends/or before it, with a sum-up = target\\n        minlen = Max # currently (global) min-length subarray and whose sum-up = target\\n        ans = Max # final answer\\n        \\n        left = 0\\n        presum = 0  # store prefix-sum\\n        \\n        for right in range(n):\\n            presum += arr[right]\\n            \\n            while presum > target: # sliding window method to enlarge left so that presum <= target\\n                presum -= arr[left]\\n                left += 1\\n            \\n            if presum == target: # update values when we find presum==target\\n                curlen = right - left + 1 # the length of current subarray from left to right, both inclusive [left, right]\\n                if left > 0 and minlens[left-1] < Max: \\n\\t\\t\\t\\t    # since left is included in current subarray, we have to find a subarray with sum=target before left\\n\\t\\t\\t\\t    # and the best is recorded in minles[left-1]:\\n                    ans = min(ans, curlen + minlens[left-1]) \\n\\t\\t\\t\\t\\t# update ans, a former subarray with length minlens[left-1] and current length\\n                minlen = min(minlen, curlen) # update the global min-length of subarray whose sum-up = target\\n            minlens[right] = minlen # update right-position\\'s best minlen(before or ends at \\'right\\')\\n        return -1 if ans == Max else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793994,
                "title": "best-explain",
                "content": "1.brute approach\\n```\\npublic int minSumOfLengths(int[] arr, int target) {\\n        if(arr==null||arr.length==0||target<1){\\n            return -1;\\n        }\\n        int[] dp=new int[arr.length];\\n        List<Pair<Integer,Integer>> subarr=new ArrayList<>();\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<=i;j++){\\n                dp[j]=((i==j)?arr[i]:dp[j]+arr[i]);\\n                if(dp[j]==target){\\n                    subarr.add(new Pair(j,i));\\n                }\\n            }\\n        }\\n        int minSum=Integer.MAX_VALUE;\\n        for(int i=0;i<subarr.size();i++){\\n            Pair<Integer,Integer> pairI=subarr.get(i);\\n            int start=pairI.getKey();\\n            int end=pairI.getValue();\\n            for(int j=i+1;j<subarr.size();j++){\\n                Pair<Integer,Integer> pairJ=subarr.get(j);\\n                int start1=pairJ.getKey();\\n                int end1=pairJ.getValue();\\n                if(end<start1||start>end1){\\n                    minSum=Math.min(minSum,end-start+end1-start1+2);\\n                }\\n            }\\n        }\\n        return minSum==Integer.MAX_VALUE?-1:minSum;\\n    }\\n```\\n\\n2.opt\\n    1.brute approach:\\n       a:find the list for all of the  subarr which equals target.\\n       b:then compute the sum of two subarr in the list,which need be uncrossed.\\n       time complexity O(n^2)\\n    2.how can we opt the brute approach?we can not opt it by caculating the two process separately.because  it has been optimum.in the case,we need merge the two process \\n      into one process.\\n    3.how to merge the two process?\\n     c:for the subarr of start at i and sum equals target, we need find the min one subarr of start at (0,i-1) and sum equals target,the time complexity is O(n)\\n     d:two subarr need be uncrossed.so for the subarr of start at i, we just need compare the subarr of  end at (0,i-1)\\n     e:we can find it will be many duplicate computing  the sum of subarr in the process d.we can opt it by saving the sum of subarr,which use sum+=arr[i],dp[i]=sum.\\n\\n    ```\\n    public int minSumOfLengths(int[] arr, int target) {\\n        if(arr==null||arr.length==0||target<1){\\n            return -1;\\n        }\\n        Map<Integer,Integer> dp = new HashMap<>();\\n        dp.put(0,-1);\\n        int sum=0;\\n        int lsize=Integer.MAX_VALUE;\\n        int result=Integer.MAX_VALUE;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            dp.put(sum,i);\\n        }\\n        sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            Integer left=dp.get(sum-target);\\n            Integer right=dp.get(sum+target);\\n            if(left!=null){\\n                lsize=Math.min(lsize,i-left);\\n            }\\n            if(right!=null&&lsize!=Integer.MAX_VALUE){\\n                result=Math.min(result,right-i+lsize);\\n            }\\n        }\\n        return result==Integer.MAX_VALUE?-1:result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minSumOfLengths(int[] arr, int target) {\\n        if(arr==null||arr.length==0||target<1){\\n            return -1;\\n        }\\n        int[] dp=new int[arr.length];\\n        List<Pair<Integer,Integer>> subarr=new ArrayList<>();\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<=i;j++){\\n                dp[j]=((i==j)?arr[i]:dp[j]+arr[i]);\\n                if(dp[j]==target){\\n                    subarr.add(new Pair(j,i));\\n                }\\n            }\\n        }\\n        int minSum=Integer.MAX_VALUE;\\n        for(int i=0;i<subarr.size();i++){\\n            Pair<Integer,Integer> pairI=subarr.get(i);\\n            int start=pairI.getKey();\\n            int end=pairI.getValue();\\n            for(int j=i+1;j<subarr.size();j++){\\n                Pair<Integer,Integer> pairJ=subarr.get(j);\\n                int start1=pairJ.getKey();\\n                int end1=pairJ.getValue();\\n                if(end<start1||start>end1){\\n                    minSum=Math.min(minSum,end-start+end1-start1+2);\\n                }\\n            }\\n        }\\n        return minSum==Integer.MAX_VALUE?-1:minSum;\\n    }\\n```\n```\\n    public int minSumOfLengths(int[] arr, int target) {\\n        if(arr==null||arr.length==0||target<1){\\n            return -1;\\n        }\\n        Map<Integer,Integer> dp = new HashMap<>();\\n        dp.put(0,-1);\\n        int sum=0;\\n        int lsize=Integer.MAX_VALUE;\\n        int result=Integer.MAX_VALUE;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            dp.put(sum,i);\\n        }\\n        sum=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            Integer left=dp.get(sum-target);\\n            Integer right=dp.get(sum+target);\\n            if(left!=null){\\n                lsize=Math.min(lsize,i-left);\\n            }\\n            if(right!=null&&lsize!=Integer.MAX_VALUE){\\n                result=Math.min(result,right-i+lsize);\\n            }\\n        }\\n        return result==Integer.MAX_VALUE?-1:result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 746091,
                "title": "python3-o-n-using-prefix-sum-strategy",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        hashTable = defaultdict(int)\\n        hashTable[0] = -1\\n        summation = 0\\n        for i in range(len(arr)):\\n            summation = summation + arr[i]\\n            hashTable[summation] = i\\n        \\n        summation = 0\\n        minimumLeft = float(\\'inf\\')\\n        result = float(\\'inf\\')\\n        for i in range(len(arr)):\\n            summation = summation + arr[i]\\n            if summation - target in hashTable:\\n                leftLength = i-hashTable[summation-target]\\n                minimumLeft = min(minimumLeft,leftLength)\\n            if summation + target in hashTable and minimumLeft < float(\\'inf\\'):\\n                rightLength = hashTable[summation+target]-i\\n                result = min(result,hashTable[summation+target]-i+minimumLeft)\\n        \\n        if result == float(\\'inf\\'):\\n            return -1\\n        return result\\n\\t```\\n\\t\\n\\t\\n\\tInspired from @pramitb Java Solution",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        hashTable = defaultdict(int)\\n        hashTable[0] = -1\\n        summation = 0\\n        for i in range(len(arr)):\\n            summation = summation + arr[i]\\n            hashTable[summation] = i\\n        \\n        summation = 0\\n        minimumLeft = float(\\'inf\\')\\n        result = float(\\'inf\\')\\n        for i in range(len(arr)):\\n            summation = summation + arr[i]\\n            if summation - target in hashTable:\\n                leftLength = i-hashTable[summation-target]\\n                minimumLeft = min(minimumLeft,leftLength)\\n            if summation + target in hashTable and minimumLeft < float(\\'inf\\'):\\n                rightLength = hashTable[summation+target]-i\\n                result = min(result,hashTable[summation+target]-i+minimumLeft)\\n        \\n        if result == float(\\'inf\\'):\\n            return -1\\n        return result\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 694223,
                "title": "javascript-prefix-suffix-array",
                "content": "For better understanding, Please visit:\\nhttps://youtu.be/2PG3b067ogM?t=2\\nif you like it. Please like and subscribe\\n```\\n/**\\n * @param {number[]} arr\\n * @param {number} target [64,5,20,9,1,39]\\n * @return {number}\\n */\\nvar minSumOfLengths = function(nums, target) {\\n        let prefix = [],suffix=[],start=0,sum=0,min=0\\n        for(let i=0;i<nums.length;i++){\\n             sum += nums[i]\\n                while(sum > target){\\n                    sum -= nums[start++]\\n                }\\n            if(target == sum){\\n                prefix[i] = min?Math.min(i-start+1,min):i-start+1\\n                min = prefix[i]\\n            }else{\\n                prefix[i] = min\\n            }\\n        }\\n        min = 0,sum = 0,start=nums.length-1\\n        for(let i=nums.length-1;i>=0;i--){\\n            while(sum > target){\\n                    sum -= nums[start--]\\n                }\\n            if(target == sum){\\n                suffix[i] = min?Math.min(start-i,min):start-i\\n                min = suffix[i]\\n            }else{\\n                suffix[i] = min\\n            }\\n            sum += nums[i]\\n        }\\n    let ans = Number.MAX_VALUE\\n    for(let i=0;i<nums.length;i++){\\n        if(!prefix[i] || !suffix[i])continue\\n        ans = Math.min(prefix[i]+suffix[i],ans)\\n    }\\n    return ans == Number.MAX_VALUE?-1:ans\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Suffix Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @param {number} target [64,5,20,9,1,39]\\n * @return {number}\\n */\\nvar minSumOfLengths = function(nums, target) {\\n        let prefix = [],suffix=[],start=0,sum=0,min=0\\n        for(let i=0;i<nums.length;i++){\\n             sum += nums[i]\\n                while(sum > target){\\n                    sum -= nums[start++]\\n                }\\n            if(target == sum){\\n                prefix[i] = min?Math.min(i-start+1,min):i-start+1\\n                min = prefix[i]\\n            }else{\\n                prefix[i] = min\\n            }\\n        }\\n        min = 0,sum = 0,start=nums.length-1\\n        for(let i=nums.length-1;i>=0;i--){\\n            while(sum > target){\\n                    sum -= nums[start--]\\n                }\\n            if(target == sum){\\n                suffix[i] = min?Math.min(start-i,min):start-i\\n                min = suffix[i]\\n            }else{\\n                suffix[i] = min\\n            }\\n            sum += nums[i]\\n        }\\n    let ans = Number.MAX_VALUE\\n    for(let i=0;i<nums.length;i++){\\n        if(!prefix[i] || !suffix[i])continue\\n        ans = Math.min(prefix[i]+suffix[i],ans)\\n    }\\n    return ans == Number.MAX_VALUE?-1:ans\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 688920,
                "title": "c-sliding-window-comments-warning-test-cases-missing",
                "content": "**Idea**: \\nFind two sub-arrays to meet the following two conditions:\\n1) sum(sub_array1) == target && sum(sub_array2) == target\\n2) min_of_all_possible_comibantion(len1 + len2), where len1= length(sub_array1), len2= length(sub_array2), len1 and len2 are the smallest two subarrays meet the condition 1.\\nNote:\\nmin_of_all_possible(len1 + len2)  =/= min_of_all_possible(len1) + min_of_all_possible(len2)\\n\\n\\n\\n\\n\\n\\nVersion 1: Sliding Window Time/Space: O(N) / O(N)\\n```\\nclass Solution { // Sliding window; Original author: huahua[1]\\npublic: // Time/Space: O(N); O(N)\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        const int n = arr.size(), kInf = INT_MAX/2;\\n        int ans = kInf;\\n        vector<int> memo(n, kInf); //memo[i] := min length of a valid subarray ends or before i.\\n        for(int i = 0, sum = 0, s=0, min_len = kInf; i < n; i++){\\n            sum += arr[i];\\n            while(sum > target) sum -= arr[s++]; //shrink from left, \\'s\\'\\n            if(sum == target){                \\n                int cur_len = i - s + 1;\\n                if( s > 0 && memo[s-1] != kInf)\\n                    ans = min(ans, cur_len + memo[s-1]);\\n                min_len = min(min_len, cur_len);\\n            }\\n            memo[i]=min_len;\\n        }        \\n        return ans < kInf ? ans : -1;\\n    }\\n};\\n```\\nReference:\\n[1] https://zxi.mytechroad.com/blog/sliding-window/leetcode-1477-find-two-non-overlapping-sub-arrays-each-with-target-sum/\\n\\nOkay, I keep thinking for hours that do we really need keep memo, or the information for the minimal  length of the desired subarray (length and ending index) good enough? It turns out by far I still need memo to track all possible comibination. \\n\\nThen I provided the 2nd version, which is surpisingly but not that surpsingly wrong. @Chernik provided an good example where this solution might fail:\\n\\nWhy? This is not a greedy question.\\n```\\nmin_of_all_possible(len1 + len2)  != min_of_all_possible(len1) + min_of_all_possible(len2)\\n```\\n len1 is from the past, len2 is from the current sub-array when you scan from left to right.\\n\\nVersion 2: Sliding Window Time/Space: O(N) / O(1)  (This version is wrong.)\\n```\\nclass Solution { // Sliding window: Wrong Solution. \\npublic: // Time/Space: O(N); O(1)\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        const int n = arr.size(), kInf = INT_MAX/2;\\n        int ans = kInf;        \\n        for(int i = 0, sum = 0, s=0, min_len = kInf, last_end = 0; i < n; i++){\\n            sum += arr[i];\\n            while(sum > target) sum -= arr[s++]; //shrink from left, \\'s\\'\\n            if(sum == target){                \\n                int cur_len = i - s + 1;                \\n                if( min_len < kInf && last_end < s)//already seen one slidwing window with min_len in the past, which dose not overlap with current one\\n                    ans = min(ans, cur_len + min_len);                \\n                if(cur_len < min_len){\\n                    last_end = i; // ending index of the minimum length window by far\\n                    min_len = cur_len;\\n                }            \\n            }            \\n        }        \\n        return ans < kInf ? ans : -1;\\n    }\\n};\\n```\\n[1,1,1,2,1,1]\\n3\\n```\\n\\nP.S.:\\nIf you like the idea here, please help upvote since it takes hours to optmize.\\nIf you do not like the idea here, please let me know so that I can optimize myself to provide better solution in future.",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution { // Sliding window; Original author: huahua[1]\\npublic: // Time/Space: O(N); O(N)\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        const int n = arr.size(), kInf = INT_MAX/2;\\n        int ans = kInf;\\n        vector<int> memo(n, kInf); //memo[i] := min length of a valid subarray ends or before i.\\n        for(int i = 0, sum = 0, s=0, min_len = kInf; i < n; i++){\\n            sum += arr[i];\\n            while(sum > target) sum -= arr[s++]; //shrink from left, \\'s\\'\\n            if(sum == target){                \\n                int cur_len = i - s + 1;\\n                if( s > 0 && memo[s-1] != kInf)\\n                    ans = min(ans, cur_len + memo[s-1]);\\n                min_len = min(min_len, cur_len);\\n            }\\n            memo[i]=min_len;\\n        }        \\n        return ans < kInf ? ans : -1;\\n    }\\n};\\n```\n```\\nmin_of_all_possible(len1 + len2)  != min_of_all_possible(len1) + min_of_all_possible(len2)\\n```\n```\\nclass Solution { // Sliding window: Wrong Solution. \\npublic: // Time/Space: O(N); O(1)\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        const int n = arr.size(), kInf = INT_MAX/2;\\n        int ans = kInf;        \\n        for(int i = 0, sum = 0, s=0, min_len = kInf, last_end = 0; i < n; i++){\\n            sum += arr[i];\\n            while(sum > target) sum -= arr[s++]; //shrink from left, \\'s\\'\\n            if(sum == target){                \\n                int cur_len = i - s + 1;                \\n                if( min_len < kInf && last_end < s)//already seen one slidwing window with min_len in the past, which dose not overlap with current one\\n                    ans = min(ans, cur_len + min_len);                \\n                if(cur_len < min_len){\\n                    last_end = i; // ending index of the minimum length window by far\\n                    min_len = cur_len;\\n                }            \\n            }            \\n        }        \\n        return ans < kInf ? ans : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687456,
                "title": "java-2sum-on-prefix-sum",
                "content": "1, acc[i] is sum of prefix array ending at i - 1;\\n2, using dp[i] to remember min length of valid subarrays ending at i - 1;\\n3, using map to remember all prefix sum\\'s index; (see 2 Sum);\\nacc[i] - target == acc[j] then: acc[i] - acc[j] == target \\n4, compare everytime we find a new subarray, which will cover all cases.\\n```\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length, acc[] = new int[n + 1], dp[] = new int[n + 1], minLen = Integer.MAX_VALUE, res = minLen;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < acc.length; i++) {\\n            if (i > 0) acc[i] = acc[i - 1] + arr[i - 1];\\n            if (map.containsKey(acc[i] - target)){\\n                int preIdx = map.get(acc[i] - target);\\n                minLen = Math.min(minLen, i - preIdx);\\n                if (dp[preIdx] < Integer.MAX_VALUE) res = Math.min(res, i - preIdx + dp[preIdx]);\\n            }\\n            map.put(acc[i], i); // empty array\\n            dp[i] = minLen;\\n        }\\n        return res < Integer.MAX_VALUE ? res : -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length, acc[] = new int[n + 1], dp[] = new int[n + 1], minLen = Integer.MAX_VALUE, res = minLen;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < acc.length; i++) {\\n            if (i > 0) acc[i] = acc[i - 1] + arr[i - 1];\\n            if (map.containsKey(acc[i] - target)){\\n                int preIdx = map.get(acc[i] - target);\\n                minLen = Math.min(minLen, i - preIdx);\\n                if (dp[preIdx] < Integer.MAX_VALUE) res = Math.min(res, i - preIdx + dp[preIdx]);\\n            }\\n            map.put(acc[i], i); // empty array\\n            dp[i] = minLen;\\n        }\\n        return res < Integer.MAX_VALUE ? res : -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 685761,
                "title": "c-o-n-simple-solution",
                "content": "```\\nint minSumOfLengths(vector<int>& arr, int target) {\\n\\tint ans = INT_MAX, prev_min = INT_MAX, left = 0, right = 0, curr = 0;\\n\\tqueue<pair<int, int>> q;\\n\\twhile(right < arr.size()) {\\n\\t\\tcurr += arr[right++];\\n\\t\\twhile(curr > target && left < right) \\n\\t\\t\\tcurr -= arr[left++];\\n\\t\\t\\n\\t\\twhile(!q.empty() && q.front().second <= left) {\\n\\t\\t\\tprev_min = min(prev_min, q.front().second - q.front().first);\\n\\t\\t\\tq.pop();\\n\\t\\t}\\n\\t\\tif(curr == target) {\\n\\t\\t\\tif(prev_min != INT_MAX)\\n\\t\\t\\t\\tans = min(ans, prev_min + right - left);\\n\\t\\t\\tq.emplace(left, right);\\n\\t\\t}\\n\\t}\\n\\treturn ans == INT_MAX ? -1 : ans;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint minSumOfLengths(vector<int>& arr, int target) {\\n\\tint ans = INT_MAX, prev_min = INT_MAX, left = 0, right = 0, curr = 0;\\n\\tqueue<pair<int, int>> q;\\n\\twhile(right < arr.size()) {\\n\\t\\tcurr += arr[right++];\\n\\t\\twhile(curr > target && left < right) \\n\\t\\t\\tcurr -= arr[left++];\\n\\t\\t\\n\\t\\twhile(!q.empty() && q.front().second <= left) {\\n\\t\\t\\tprev_min = min(prev_min, q.front().second - q.front().first);\\n\\t\\t\\tq.pop();\\n\\t\\t}\\n\\t\\tif(curr == target) {\\n\\t\\t\\tif(prev_min != INT_MAX)\\n\\t\\t\\t\\tans = min(ans, prev_min + right - left);\\n\\t\\t\\tq.emplace(left, right);\\n\\t\\t}\\n\\t}\\n\\treturn ans == INT_MAX ? -1 : ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 685466,
                "title": "java-using-treemap-to-find-the-minimum-interval",
                "content": "I\\'ve noticed people are placing solutions to avoid TLE taking only the first interval. It usually fails on the next counter case:\\n```\\n[1,2,3,3,3]\\n6\\n```\\n\\nI\\'ve used a `TreeMap` to calculate the minimum interval prior to the current point.\\n\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int i = 0;\\n        int j = 0;\\n        int sum = 0;\\n        int N = arr.length;\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        int best = -1;\\n        while (i < N) {\\n            if (j < N && sum < target) sum += arr[j++];\\n            if (sum == target) {\\n                m.put(j, i);\\n\\t\\t\\t\\t// if we have another interval prior to this point, use it \\n                Integer k = m.floorKey(i);\\n                if (k != null) {\\n                    int l = j - i + k - m.get(k);\\n                    best = best == -1 ? l : Math.min(l, best);\\n                }\\n\\t\\t\\t\\t// put the best interval distance back, we check the best interval prior to this point, and if it has shorted distance - use it instead, so maintain the shortest distance for the left interval\\n                Integer b = m.floorKey(j - 1);\\n                int bl = b == null ? j - i : Math.min(j - i, b - m.get(b));\\n                m.put(j, j - bl);\\n            }\\n            if (sum >= target) {\\n                sum -= arr[i++];\\n            }\\n            \\n            if (sum < target && j >= N) break;\\n        }\\n        return best;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n[1,2,3,3,3]\\n6\\n```\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int i = 0;\\n        int j = 0;\\n        int sum = 0;\\n        int N = arr.length;\\n        TreeMap<Integer, Integer> m = new TreeMap<>();\\n        int best = -1;\\n        while (i < N) {\\n            if (j < N && sum < target) sum += arr[j++];\\n            if (sum == target) {\\n                m.put(j, i);\\n\\t\\t\\t\\t// if we have another interval prior to this point, use it \\n                Integer k = m.floorKey(i);\\n                if (k != null) {\\n                    int l = j - i + k - m.get(k);\\n                    best = best == -1 ? l : Math.min(l, best);\\n                }\\n\\t\\t\\t\\t// put the best interval distance back, we check the best interval prior to this point, and if it has shorted distance - use it instead, so maintain the shortest distance for the left interval\\n                Integer b = m.floorKey(j - 1);\\n                int bl = b == null ? j - i : Math.min(j - i, b - m.get(b));\\n                m.put(j, j - bl);\\n            }\\n            if (sum >= target) {\\n                sum -= arr[i++];\\n            }\\n            \\n            if (sum < target && j >= N) break;\\n        }\\n        return best;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685384,
                "title": "tle-c-solution-hope-it-helps-at-all-first-time-trying-to-give-back-to-the-community",
                "content": "Hi, I hope this helps anyone trying to start this problem. I\\'m a weak programmer and didn\\'t quite figure out a good solution yet. But I just want to post my naive TLE solution here. First time trying to give back to this community. XD\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        if(arr.size() < 2)\\n            return -1;\\n        unordered_map<int, int> m;\\n        vector<pair<int, int> > subs;\\n        m[0] = -1;\\n        int sum = 0;\\n        for(int i=0; i<arr.size(); i++){\\n            sum+=arr[i];\\n            if(m.count(sum-target)){\\n                subs.push_back(make_pair(m[sum-target], i));\\n            }\\n            m[sum] = i;\\n        }\\n        auto comp = [](pair<int, int>& a, pair<int, int>& b){return (a.second-a.first) < (b.second-b.first); };\\n        sort(subs.begin(), subs.end(), comp);\\n        \\n        // for(auto& a:subs){\\n        //     cout << a.first << \" \" << a.second << endl;\\n        // }\\n        for(int i=0; i<subs.size(); i++){\\n            for(int j=i+1; j<subs.size(); j++){\\n                if(noOver(subs[i], subs[j]))\\n                    return (subs[i].second-subs[i].first + subs[j].second - subs[j].first);\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    bool noOver(pair<int, int>& a, pair<int, int>& b){\\n        if( (a.first <= b.first && a.second > b.first)\\n            || (a.first >= b.first && a.first < b.second) )\\n            return false;\\n        return true;\\n            \\n    }\\n\\n};\\n```\\n\\nupdate:\\nIf anyone is interested, I actually figured out how to solve this. I don\\'t quite need to sort the vector, but rather I could keep the shortest subarray while I go over the array.\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        if(arr.size() < 2)\\n            return -1;\\n        unordered_map<int, int> m;\\n        vector<pair<int, int> > subs;\\n        m[0] = -1;\\n        int sum = 0;\\n        int shortest_len = INT_MAX;\\n        pair<int, int> shortest = {-1, -1};\\n        for(int i=0; i<arr.size(); i++){\\n            sum+=arr[i];\\n            if(m.count(sum-target)){\\n                subs.push_back(make_pair(m[sum-target], i));\\n                if(i-m[sum-target] < shortest_len){\\n                    shortest_len = i-m[sum-target];\\n                    shortest = make_pair(m[sum-target], i);\\n                }\\n            }\\n            m[sum] = i;\\n        }\\n        if(shortest_len == INT_MAX)\\n            return -1;\\n        int second_shortest_len = INT_MAX;\\n        pair<int, int> second_shortest = {-1, -1};\\n        for(int i=0; i<subs.size(); i++){\\n            if(noOver(subs[i], shortest)){\\n                if((subs[i].second - subs[i].first ) < second_shortest_len){\\n                    second_shortest_len = subs[i].second - subs[i].first;\\n                    second_shortest = subs[i];\\n                }\\n            }\\n        }\\n         if(second_shortest_len == INT_MAX)\\n            return -1;\\n        return (shortest.second-shortest.first + second_shortest.second - second_shortest.first);\\n    }\\n    \\n    bool noOver(pair<int, int>& a, pair<int, int>& b){\\n        if( (a.first <= b.first && a.second > b.first)\\n            || (a.first >= b.first && a.first < b.second) )\\n            return false;\\n        return true;\\n    }\\n};\\n```\\nOnly beats 20%. But still being proud of it.\\n\\n2nd update:\\nI don\\'t think there\\'s really a way to solve this with my intuition. (Not confident at all).\\nMy second solution couldn\\'t pass testcases for [1,2,3,3,2,1] because it assumes [3,3] is a part of the final answer. My first solution could solve the problem, which makes it O(n^2) though. Sad face.\\n\\n(and [1,2,3,3,2,1] is not part of the test cases given.)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        if(arr.size() < 2)\\n            return -1;\\n        unordered_map<int, int> m;\\n        vector<pair<int, int> > subs;\\n        m[0] = -1;\\n        int sum = 0;\\n        for(int i=0; i<arr.size(); i++){\\n            sum+=arr[i];\\n            if(m.count(sum-target)){\\n                subs.push_back(make_pair(m[sum-target], i));\\n            }\\n            m[sum] = i;\\n        }\\n        auto comp = [](pair<int, int>& a, pair<int, int>& b){return (a.second-a.first) < (b.second-b.first); };\\n        sort(subs.begin(), subs.end(), comp);\\n        \\n        // for(auto& a:subs){\\n        //     cout << a.first << \" \" << a.second << endl;\\n        // }\\n        for(int i=0; i<subs.size(); i++){\\n            for(int j=i+1; j<subs.size(); j++){\\n                if(noOver(subs[i], subs[j]))\\n                    return (subs[i].second-subs[i].first + subs[j].second - subs[j].first);\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    bool noOver(pair<int, int>& a, pair<int, int>& b){\\n        if( (a.first <= b.first && a.second > b.first)\\n            || (a.first >= b.first && a.first < b.second) )\\n            return false;\\n        return true;\\n            \\n    }\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        if(arr.size() < 2)\\n            return -1;\\n        unordered_map<int, int> m;\\n        vector<pair<int, int> > subs;\\n        m[0] = -1;\\n        int sum = 0;\\n        int shortest_len = INT_MAX;\\n        pair<int, int> shortest = {-1, -1};\\n        for(int i=0; i<arr.size(); i++){\\n            sum+=arr[i];\\n            if(m.count(sum-target)){\\n                subs.push_back(make_pair(m[sum-target], i));\\n                if(i-m[sum-target] < shortest_len){\\n                    shortest_len = i-m[sum-target];\\n                    shortest = make_pair(m[sum-target], i);\\n                }\\n            }\\n            m[sum] = i;\\n        }\\n        if(shortest_len == INT_MAX)\\n            return -1;\\n        int second_shortest_len = INT_MAX;\\n        pair<int, int> second_shortest = {-1, -1};\\n        for(int i=0; i<subs.size(); i++){\\n            if(noOver(subs[i], shortest)){\\n                if((subs[i].second - subs[i].first ) < second_shortest_len){\\n                    second_shortest_len = subs[i].second - subs[i].first;\\n                    second_shortest = subs[i];\\n                }\\n            }\\n        }\\n         if(second_shortest_len == INT_MAX)\\n            return -1;\\n        return (shortest.second-shortest.first + second_shortest.second - second_shortest.first);\\n    }\\n    \\n    bool noOver(pair<int, int>& a, pair<int, int>& b){\\n        if( (a.first <= b.first && a.second > b.first)\\n            || (a.first >= b.first && a.first < b.second) )\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3747124,
                "title": "clean-and-easy-to-understand-implementation-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size(), i = 0, sum = 0;\\n\\n        vector<int>left(n) , right(n);\\n        int len = INT_MAX;\\n        for(int j=0; j<n; j++){\\n            sum += arr[j];\\n            while(sum > target){\\n                sum -= arr[i];\\n                i++;\\n            }\\n            if(sum == target){\\n                len = min(len,j-i+1);\\n            }\\n            left[j] = len;\\n        }\\n\\n        i = n-1; sum = 0; len = INT_MAX;\\n\\n        for(int j=n-1; j>=0; j--){\\n            sum += arr[j];\\n            while(sum > target){\\n                sum -= arr[i];\\n                i--;\\n            }\\n            if(sum == target){\\n                len = min(len,i-j+1);\\n            }\\n            right[j] = len;\\n        }\\n\\n        int ans = INT_MAX;\\n        for(int j=1; j<n; j++){\\n            if(left[j-1] != INT_MAX && right[j] != INT_MAX) ans = min(ans,left[j-1] + right[j]);\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size(), i = 0, sum = 0;\\n\\n        vector<int>left(n) , right(n);\\n        int len = INT_MAX;\\n        for(int j=0; j<n; j++){\\n            sum += arr[j];\\n            while(sum > target){\\n                sum -= arr[i];\\n                i++;\\n            }\\n            if(sum == target){\\n                len = min(len,j-i+1);\\n            }\\n            left[j] = len;\\n        }\\n\\n        i = n-1; sum = 0; len = INT_MAX;\\n\\n        for(int j=n-1; j>=0; j--){\\n            sum += arr[j];\\n            while(sum > target){\\n                sum -= arr[i];\\n                i--;\\n            }\\n            if(sum == target){\\n                len = min(len,i-j+1);\\n            }\\n            right[j] = len;\\n        }\\n\\n        int ans = INT_MAX;\\n        for(int j=1; j<n; j++){\\n            if(left[j-1] != INT_MAX && right[j] != INT_MAX) ans = min(ans,left[j-1] + right[j]);\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171241,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) \\n    {      \\n        map<int,int>mp,mp2;\\n        int n=arr.size();\\n        int sum=0;\\n        mp[0]=-1;\\n        int mn=INT_MAX;\\n        vector<int>pre(n),suff(n);\\n        for (int i=0;i<n;i++)\\n        {\\n            sum+=arr[i];\\n            int temp=INT_MAX;\\n            if (mp.find(sum-target)!=mp.end())\\n            {\\n               int ind=mp[sum-target];\\n               temp=i-ind;\\n            }\\n            mn=min(mn,temp);\\n            pre[i]=mn;\\n            mp[sum]=i;\\n        }\\n        sum=0;\\n        mp2[0]=n;\\n        mn=INT_MAX;\\n        for (int i=n-1;i>=0;i--)\\n        {\\n            int temp=INT_MAX;\\n            if (mp2.find(sum-target)!=mp2.end())\\n            {\\n                int ind=mp2[sum-target];\\n                temp=ind-i-1;\\n            }\\n            mn=min(mn,temp);\\n            suff[i]=mn;\\n            sum+=arr[i];\\n           mp2[sum]=i;\\n        }\\n        int ans=INT_MAX;\\n        for (int i=0;i<n;i++)\\n        {\\n         //cout<<pre[i]<<\" \"<<suff[i]<<endl;\\n        if (suff[i]==INT_MAX || pre[i]==INT_MAX) continue;\\n\\n        ans=min(ans,suff[i]+pre[i]);\\n        }\\n        if (ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) \\n    {      \\n        map<int,int>mp,mp2;\\n        int n=arr.size();\\n        int sum=0;\\n        mp[0]=-1;\\n        int mn=INT_MAX;\\n        vector<int>pre(n),suff(n);\\n        for (int i=0;i<n;i++)\\n        {\\n            sum+=arr[i];\\n            int temp=INT_MAX;\\n            if (mp.find(sum-target)!=mp.end())\\n            {\\n               int ind=mp[sum-target];\\n               temp=i-ind;\\n            }\\n            mn=min(mn,temp);\\n            pre[i]=mn;\\n            mp[sum]=i;\\n        }\\n        sum=0;\\n        mp2[0]=n;\\n        mn=INT_MAX;\\n        for (int i=n-1;i>=0;i--)\\n        {\\n            int temp=INT_MAX;\\n            if (mp2.find(sum-target)!=mp2.end())\\n            {\\n                int ind=mp2[sum-target];\\n                temp=ind-i-1;\\n            }\\n            mn=min(mn,temp);\\n            suff[i]=mn;\\n            sum+=arr[i];\\n           mp2[sum]=i;\\n        }\\n        int ans=INT_MAX;\\n        for (int i=0;i<n;i++)\\n        {\\n         //cout<<pre[i]<<\" \"<<suff[i]<<endl;\\n        if (suff[i]==INT_MAX || pre[i]==INT_MAX) continue;\\n\\n        ans=min(ans,suff[i]+pre[i]);\\n        }\\n        if (ans==INT_MAX) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2640023,
                "title": "c-perfect-solution-o-n-tc-dp",
                "content": "TC: O(3 * N)\\nSC: O(N)\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n\\t// Approach : Contraction and expansion of subarray to find the subaaray equals to target\\n\\t// if at any index i , sum > target --> start contracting the subarray by remove the element from front from subarray unless sum<=target\\t\\n\\t// else continue the expansion of subarray\\n        int n=arr.size();\\n        vector<int>prefix(n);\\n        vector<int>suffix(n);\\n        int sum=0;\\n        int sz=1e9,j=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            while(sum>target){\\n                j++;\\n                sum-=arr[j];\\n            }\\n            if(sum==target){\\n                sz=min(sz,i-j);\\n            }\\n            prefix[i]= (sz>=1e9 ? -1 : sz);\\n        }\\n        sum=0;\\n        sz=1e9;\\n        j=n;\\n        for(int i=n-1;i>=0;i--){\\n            sum+=arr[i];\\n            while(sum>target){\\n                j--;\\n                sum-=arr[j];\\n            }\\n            if(sum==target){\\n                sz=min(sz,j-i);\\n            }\\n            suffix[i]= (sz>=1e9 ? -1 : sz);            \\n        }\\n        \\n        int size=1e9;\\n        for(int i=0;i<n;i++){\\n            int left=prefix[i];\\n            int right = (i+1>=n ? -1 : suffix[i+1]);\\n             \\n            if(left!=-1 && right !=-1)\\n                size = min(size, left+right);\\n        }\\n        return size>=1e9 ? -1 : size;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n\\t// Approach : Contraction and expansion of subarray to find the subaaray equals to target\\n\\t// if at any index i , sum > target --> start contracting the subarray by remove the element from front from subarray unless sum<=target\\t\\n\\t// else continue the expansion of subarray\\n        int n=arr.size();\\n        vector<int>prefix(n);\\n        vector<int>suffix(n);\\n        int sum=0;\\n        int sz=1e9,j=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            while(sum>target){\\n                j++;\\n                sum-=arr[j];\\n            }\\n            if(sum==target){\\n                sz=min(sz,i-j);\\n            }\\n            prefix[i]= (sz>=1e9 ? -1 : sz);\\n        }\\n        sum=0;\\n        sz=1e9;\\n        j=n;\\n        for(int i=n-1;i>=0;i--){\\n            sum+=arr[i];\\n            while(sum>target){\\n                j--;\\n                sum-=arr[j];\\n            }\\n            if(sum==target){\\n                sz=min(sz,j-i);\\n            }\\n            suffix[i]= (sz>=1e9 ? -1 : sz);            \\n        }\\n        \\n        int size=1e9;\\n        for(int i=0;i<n;i++){\\n            int left=prefix[i];\\n            int right = (i+1>=n ? -1 : suffix[i+1]);\\n             \\n            if(left!=-1 && right !=-1)\\n                size = min(size, left+right);\\n        }\\n        return size>=1e9 ? -1 : size;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936799,
                "title": "java-sliding-window-beat-90-solutions-o-n",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int[] min_len = new int[arr.length];\\n        Arrays.fill(min_len, Integer.MAX_VALUE);\\n        \\n        int sum = 0;\\n        int start = 0;\\n        int res = Integer.MAX_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int end = 0; end < arr.length; end++){\\n            sum += arr[end];\\n            \\n            while(sum > target){\\n                sum -= arr[start++];\\n            }\\n            \\n            if(sum == target){\\n                int cur_len = end-start+1;\\n                if(start > 0 && min_len[start-1] != Integer.MAX_VALUE){\\n                    res = Math.min(res, cur_len + min_len[start-1]);\\n                }\\n                min = Math.min(min, cur_len);\\n            }\\n            min_len[end] = min;\\n        }\\n        \\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int[] min_len = new int[arr.length];\\n        Arrays.fill(min_len, Integer.MAX_VALUE);\\n        \\n        int sum = 0;\\n        int start = 0;\\n        int res = Integer.MAX_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int end = 0; end < arr.length; end++){\\n            sum += arr[end];\\n            \\n            while(sum > target){\\n                sum -= arr[start++];\\n            }\\n            \\n            if(sum == target){\\n                int cur_len = end-start+1;\\n                if(start > 0 && min_len[start-1] != Integer.MAX_VALUE){\\n                    res = Math.min(res, cur_len + min_len[start-1]);\\n                }\\n                min = Math.min(min, cur_len);\\n            }\\n            min_len[end] = min;\\n        }\\n        \\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916200,
                "title": "sliding-window-dp",
                "content": "```\\n/*\\n\\n    dp[i] : the length of the shortest subarray which lies in the range [0...i], having a sum = target\\n    we can use sliding window to solve this problem\\n\\n    as soon as [i...j] has a sum = target, the second subarray will be i...j, and we will take the first subarray\\n    given by dp[i - 1]\\n\\n*/\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1e7);\\n        int ans = INT_MAX;\\n\\n\\n        int i = 0, j = -1;\\n        int sum = 0;\\n        int res = 1e7;\\n\\n        while (j < n - 1) {\\n            sum += arr[++j];\\n            while (i <= j && sum > target) {\\n                sum -= arr[i++];\\n            }\\n\\n            if (sum == target) {\\n                dp[j] = min(dp[j], j - i + 1);\\n\\n                if (i > 0) ans = min(ans, j - i + 1 + dp[i - 1]);\\n            }\\n            if (j > 0) dp[j] = min(dp[j], dp[j - 1]);\\n        }\\n\\n\\n        return ans > 1e5 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\n/*\\n\\n    dp[i] : the length of the shortest subarray which lies in the range [0...i], having a sum = target\\n    we can use sliding window to solve this problem\\n\\n    as soon as [i...j] has a sum = target, the second subarray will be i...j, and we will take the first subarray\\n    given by dp[i - 1]\\n\\n*/\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> dp(n, 1e7);\\n        int ans = INT_MAX;\\n\\n\\n        int i = 0, j = -1;\\n        int sum = 0;\\n        int res = 1e7;\\n\\n        while (j < n - 1) {\\n            sum += arr[++j];\\n            while (i <= j && sum > target) {\\n                sum -= arr[i++];\\n            }\\n\\n            if (sum == target) {\\n                dp[j] = min(dp[j], j - i + 1);\\n\\n                if (i > 0) ans = min(ans, j - i + 1 + dp[i - 1]);\\n            }\\n            if (j > 0) dp[j] = min(dp[j], dp[j - 1]);\\n        }\\n\\n\\n        return ans > 1e5 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668949,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        unordered_map<int,int>m;\\n        \\n        // \\'sum\\' will store the current sum of the elements\\n        int sum=0,n=arr.size();\\n        \\n        // \\'ans\\' will be the ans\\n        long long ans=INT_MAX;\\n        \\n        // We\\'ll build two arrays prefix and suffix\\n        // prefix[i] = minimum length of subarray ending on or before index i with sum = target\\n        // suffix[i] = minimum length of subarray starting from or after index i with sum = target\\n        vector<int>prefix(n,INT_MAX),suffix(n,INT_MAX);\\n        \\n        // Now populate the prefix array\\n\\t\\t// Logic to populate the array is similar to finding the smallest subarray with a target sum\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=arr[i];\\n            if(sum==target)\\n            {\\n                prefix[i]=min(prefix[i],i+1);\\n            }\\n            if(m.find(sum-target)!=m.end())\\n            {\\n                prefix[i]=min(prefix[i],i-m[sum-target]);\\n            }\\n            prefix[i]=i>0?min(prefix[i],prefix[i-1]):prefix[i];\\n            m[sum]=i;\\n        }\\n        m.clear();\\n        sum=0;\\n        \\n        // Populate the suffix array\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            sum+=arr[i];\\n            if(sum==target)\\n            {\\n                suffix[i]=min(suffix[i],n-i);\\n            }\\n            if(m.find(sum-target)!=m.end())\\n            {\\n                suffix[i]=min(suffix[i],m[sum-target]-i);\\n            }\\n            suffix[i]=i+1<n?min(suffix[i],suffix[i+1]):suffix[i];\\n            m[sum]=i;\\n        }\\n        \\n        // Now once we\\'ve got the prefix and suffix array we will traverse from 1 to n-1 and compute the answer\\n        for(int i=1;i<n-1;i++)\\n        {\\n            // first find left subarray ending on or before index \\'i\\' and right subarray starting from or after index \\'i+1\\'\\n            long long first=(long long)prefix[i]+(long long)suffix[i+1];\\n            \\n            // second find left subarray ending on or before index \\'i-1\\' and right subarray starting from or after index \\'i\\'\\n            long long second=(long long)prefix[i-1]+(long long)suffix[i];\\n            \\n            // take whichever gives the min aggregate length\\n            ans=min({ans,first,second});\\n        }\\n        \\n        // if at the end the ans is INT_MAX or greater that means there were no 2 subarrys with sum = target so return -1. otherwise return the actual ans\\n        return ans>=INT_MAX?-1:ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        unordered_map<int,int>m;\\n        \\n        // \\'sum\\' will store the current sum of the elements\\n        int sum=0,n=arr.size();\\n        \\n        // \\'ans\\' will be the ans\\n        long long ans=INT_MAX;\\n        \\n        // We\\'ll build two arrays prefix and suffix\\n        // prefix[i] = minimum length of subarray ending on or before index i with sum = target\\n        // suffix[i] = minimum length of subarray starting from or after index i with sum = target\\n        vector<int>prefix(n,INT_MAX),suffix(n,INT_MAX);\\n        \\n        // Now populate the prefix array\\n\\t\\t// Logic to populate the array is similar to finding the smallest subarray with a target sum\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=arr[i];\\n            if(sum==target)\\n            {\\n                prefix[i]=min(prefix[i],i+1);\\n            }\\n            if(m.find(sum-target)!=m.end())\\n            {\\n                prefix[i]=min(prefix[i],i-m[sum-target]);\\n            }\\n            prefix[i]=i>0?min(prefix[i],prefix[i-1]):prefix[i];\\n            m[sum]=i;\\n        }\\n        m.clear();\\n        sum=0;\\n        \\n        // Populate the suffix array\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            sum+=arr[i];\\n            if(sum==target)\\n            {\\n                suffix[i]=min(suffix[i],n-i);\\n            }\\n            if(m.find(sum-target)!=m.end())\\n            {\\n                suffix[i]=min(suffix[i],m[sum-target]-i);\\n            }\\n            suffix[i]=i+1<n?min(suffix[i],suffix[i+1]):suffix[i];\\n            m[sum]=i;\\n        }\\n        \\n        // Now once we\\'ve got the prefix and suffix array we will traverse from 1 to n-1 and compute the answer\\n        for(int i=1;i<n-1;i++)\\n        {\\n            // first find left subarray ending on or before index \\'i\\' and right subarray starting from or after index \\'i+1\\'\\n            long long first=(long long)prefix[i]+(long long)suffix[i+1];\\n            \\n            // second find left subarray ending on or before index \\'i-1\\' and right subarray starting from or after index \\'i\\'\\n            long long second=(long long)prefix[i-1]+(long long)suffix[i];\\n            \\n            // take whichever gives the min aggregate length\\n            ans=min({ans,first,second});\\n        }\\n        \\n        // if at the end the ans is INT_MAX or greater that means there were no 2 subarrys with sum = target so return -1. otherwise return the actual ans\\n        return ans>=INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371713,
                "title": "java-two-pointer-o-n",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length,res = Integer.MAX_VALUE;\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp,n);\\n        int i = -1,j = -1,sum = 0;\\n        while(j < n){\\n            if(j < n-1 && sum < target) sum += arr[++j];\\n            else if(i < n-1 && sum > target) sum -= arr[++i];\\n            else if(sum == target){\\n                if(dp[i+1] < n)\\n                    res = Math.min(res,dp[i+1]+j-i);\\n                dp[j+1] = j-i; \\n                sum -= arr[++i];\\n            }\\n            else break;\\n            dp[j+1] = Math.min(dp[j],dp[j+1]);\\n        }\\n        return res == Integer.MAX_VALUE?-1:res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length,res = Integer.MAX_VALUE;\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp,n);\\n        int i = -1,j = -1,sum = 0;\\n        while(j < n){\\n            if(j < n-1 && sum < target) sum += arr[++j];\\n            else if(i < n-1 && sum > target) sum -= arr[++i];\\n            else if(sum == target){\\n                if(dp[i+1] < n)\\n                    res = Math.min(res,dp[i+1]+j-i);\\n                dp[j+1] = j-i; \\n                sum -= arr[++i];\\n            }\\n            else break;\\n            dp[j+1] = Math.min(dp[j],dp[j+1]);\\n        }\\n        return res == Integer.MAX_VALUE?-1:res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201389,
                "title": "5ms-98-faster-o-n-dp-sliding-window-solution",
                "content": "java code is:\\n# \\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int sum=0,i=0,n=arr.length,res=Integer.MAX_VALUE,length=1000000;\\n        int dp[]=new int[n];\\n        Arrays.fill(dp,-1);\\n        for(int j=0;j<n;j++){\\n            sum+=arr[j];\\n            while(sum>target) {sum-=arr[i];\\n                               if(dp[i]!=-1)length=Math.min(length,i-dp[i]+1);\\n                               i++;    \\n            }\\n            if(sum==target){ \\n                dp[j]=i;\\n                if(length!=1000000)res=Math.min(res,length+j-i+1);\\n            }\\n        }\\n        return res==Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```\\n**Time:** O(n)\\n**Space:** O(n)\\n***Please,Upvote if this is helpful***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int sum=0,i=0,n=arr.length,res=Integer.MAX_VALUE,length=1000000;\\n        int dp[]=new int[n];\\n        Arrays.fill(dp,-1);\\n        for(int j=0;j<n;j++){\\n            sum+=arr[j];\\n            while(sum>target) {sum-=arr[i];\\n                               if(dp[i]!=-1)length=Math.min(length,i-dp[i]+1);\\n                               i++;    \\n            }\\n            if(sum==target){ \\n                dp[j]=i;\\n                if(length!=1000000)res=Math.min(res,length+j-i+1);\\n            }\\n        }\\n        return res==Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102531,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n   // left[i] is the size of the min size subarray in arr[0, i] that sums up to target. Is Integer.MAX_VALUE if there is no subarray that sums up to target.\\n// right[i] is the size of the min size subarray in arr[i, arr.length - 1] that sums up to target.\\n// for (int i = 1; i < arr.length; ++i) result = Math.min(result, left[i - 1] + right[i]);\\npublic int minSumOfLengths(int[] arr, int target) {          \\n    int[] left = new int[arr.length];\\n    int sum = 0, best = Integer.MAX_VALUE;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    map.put(0, -1);   \\n    for (int i = 0; i < arr.length; ++i) {\\n        sum += arr[i];\\n        if (map.containsKey(sum - target)) {\\n            best = Math.min(best, i - map.get(sum - target));  \\n        }\\n        left[i] = best;\\n        map.put(sum, i);    \\n    }\\n    \\n    int[] right = new int[arr.length];\\n    sum = 0; best = Integer.MAX_VALUE;\\n    map = new HashMap<>();\\n    map.put(0, arr.length);    \\n    for (int i = arr.length - 1; i >= 0; --i) {\\n        sum += arr[i];\\n        if (map.containsKey(sum - target)) {\\n            best = Math.min(best, map.get(sum - target) - i); \\n        }\\n        right[i] = best;\\n        map.put(sum, i);  \\n    }\\n    \\n    int result = Integer.MAX_VALUE;\\n    for (int i = 1; i < arr.length; ++i) {\\n        if (left[i - 1] != Integer.MAX_VALUE && right[i] != Integer.MAX_VALUE) {\\n            result = Math.min(result, left[i - 1] + right[i]);  \\n        }\\n    }\\n    return result == Integer.MAX_VALUE ? -1 : result;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   // left[i] is the size of the min size subarray in arr[0, i] that sums up to target. Is Integer.MAX_VALUE if there is no subarray that sums up to target.\\n// right[i] is the size of the min size subarray in arr[i, arr.length - 1] that sums up to target.\\n// for (int i = 1; i < arr.length; ++i) result = Math.min(result, left[i - 1] + right[i]);\\npublic int minSumOfLengths(int[] arr, int target) {          \\n    int[] left = new int[arr.length];\\n    int sum = 0, best = Integer.MAX_VALUE;\\n    Map<Integer, Integer> map = new HashMap<>();\\n    map.put(0, -1);   \\n    for (int i = 0; i < arr.length; ++i) {\\n        sum += arr[i];\\n        if (map.containsKey(sum - target)) {\\n            best = Math.min(best, i - map.get(sum - target));  \\n        }\\n        left[i] = best;\\n        map.put(sum, i);    \\n    }\\n    \\n    int[] right = new int[arr.length];\\n    sum = 0; best = Integer.MAX_VALUE;\\n    map = new HashMap<>();\\n    map.put(0, arr.length);    \\n    for (int i = arr.length - 1; i >= 0; --i) {\\n        sum += arr[i];\\n        if (map.containsKey(sum - target)) {\\n            best = Math.min(best, map.get(sum - target) - i); \\n        }\\n        right[i] = best;\\n        map.put(sum, i);  \\n    }\\n    \\n    int result = Integer.MAX_VALUE;\\n    for (int i = 1; i < arr.length; ++i) {\\n        if (left[i - 1] != Integer.MAX_VALUE && right[i] != Integer.MAX_VALUE) {\\n            result = Math.min(result, left[i - 1] + right[i]);  \\n        }\\n    }\\n    return result == Integer.MAX_VALUE ? -1 : result;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894090,
                "title": "documented-o-n-solution",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefix = [float(\\'inf\\')]*len(arr) # this array stores the minimum length of the subarray that ends at i or before that\\n        suffix = [float(\\'inf\\')]*len(arr) # this array stores the minimum length of the subarray that starts at i or after that\\n        \\n        start = 0\\n        currSum = 0\\n        for index in range(len(arr)):\\n            currSum += arr[index]\\n            \\n            while currSum > target:\\n                currSum -= arr[start]\\n                start += 1\\n            \\n            if currSum == target:\\n                # populate prefix and suffix array.\\n                # at this point we are simply storing the values for respective index not minimum\\n                length = index-start+1\\n                prefix[index] = length \\n                suffix[start] = length\\n        \\n        # correcting prefix array\\n        for index in range(1, len(arr)):\\n            prefix[index] = min(prefix[index], prefix[index-1])\\n        \\n        # correcting suffix array\\n        for index in range(len(arr)-2, -1, -1):\\n            suffix[index] = min(suffix[index], suffix[index+1])\\n        \\n        \\n\\t\\t# Working with the idea that a non overlapping subarray lies to right and left of an index, \\n\\t\\t# so we select minimum subarray from the two halves of the array.  \\n        minComb = float(\\'inf\\')\\n        for index in range(1, len(arr)):\\n            minComb = min(minComb, prefix[index-1]+suffix[index])\\n        return minComb if minComb < float(\\'inf\\') else -1",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefix = [float(\\'inf\\')]*len(arr) # this array stores the minimum length of the subarray that ends at i or before that\\n        suffix = [float(\\'inf\\')]*len(arr) # this array stores the minimum length of the subarray that starts at i or after that\\n        \\n        start = 0\\n        currSum = 0\\n        for index in range(len(arr)):\\n            currSum += arr[index]\\n            \\n            while currSum > target:\\n                currSum -= arr[start]\\n                start += 1\\n            \\n            if currSum == target:\\n                # populate prefix and suffix array.\\n                # at this point we are simply storing the values for respective index not minimum\\n                length = index-start+1\\n                prefix[index] = length \\n                suffix[start] = length\\n        \\n        # correcting prefix array\\n        for index in range(1, len(arr)):\\n            prefix[index] = min(prefix[index], prefix[index-1])\\n        \\n        # correcting suffix array\\n        for index in range(len(arr)-2, -1, -1):\\n            suffix[index] = min(suffix[index], suffix[index+1])\\n        \\n        \\n\\t\\t# Working with the idea that a non overlapping subarray lies to right and left of an index, \\n\\t\\t# so we select minimum subarray from the two halves of the array.  \\n        minComb = float(\\'inf\\')\\n        for index in range(1, len(arr)):\\n            minComb = min(minComb, prefix[index-1]+suffix[index])\\n        return minComb if minComb < float(\\'inf\\') else -1",
                "codeTag": "Java"
            },
            {
                "id": 833215,
                "title": "java-o-n-solution-using-prefixsum-and-hashmap",
                "content": "I create a prefixSum array and store the indices of prefixSum with the corresponding index. Then start a search for prefixSum[i] - target and prefixSum[i] + target for each index in prefixSum to find the minimum left and right ranges respectively.\\n\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n\\t\\tint[] prefixSum = new int[arr.length + 1];\\n\\t\\tMap<Integer, Integer> indexMap = new HashMap<>();\\n\\t\\tindexMap.put(0, -1);\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tprefixSum[i + 1] = prefixSum[i] + arr[i];\\n\\t\\t\\tindexMap.put(prefixSum[i + 1], i);\\n\\t\\t}\\n\\n\\t\\tint left = Integer.MAX_VALUE;\\n\\t\\tint right = 0;\\n\\t\\tint result = Integer.MAX_VALUE;\\n\\n\\t\\tfor (int i = 0; i < prefixSum.length; i++) {\\n\\t\\t\\tif (indexMap.containsKey(prefixSum[i] - target)) {\\n\\t\\t\\t\\tint prevIdx = indexMap.get(prefixSum[i] - target);\\n\\t\\t\\t\\tleft = Math.min(left, i - prevIdx);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (indexMap.containsKey(prefixSum[i] + target)) {\\n\\t\\t\\t\\tint nextIdx = indexMap.get(prefixSum[i] + target);\\n\\t\\t\\t\\tright = nextIdx - i;\\n\\t\\t\\t\\tif (left != Integer.MAX_VALUE) {\\n\\t\\t\\t\\t\\tresult = Math.min(result, right + left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (result == Integer.MAX_VALUE)\\n\\t\\t\\treturn -1;\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n\\t\\tint[] prefixSum = new int[arr.length + 1];\\n\\t\\tMap<Integer, Integer> indexMap = new HashMap<>();\\n\\t\\tindexMap.put(0, -1);\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tprefixSum[i + 1] = prefixSum[i] + arr[i];\\n\\t\\t\\tindexMap.put(prefixSum[i + 1], i);\\n\\t\\t}\\n\\n\\t\\tint left = Integer.MAX_VALUE;\\n\\t\\tint right = 0;\\n\\t\\tint result = Integer.MAX_VALUE;\\n\\n\\t\\tfor (int i = 0; i < prefixSum.length; i++) {\\n\\t\\t\\tif (indexMap.containsKey(prefixSum[i] - target)) {\\n\\t\\t\\t\\tint prevIdx = indexMap.get(prefixSum[i] - target);\\n\\t\\t\\t\\tleft = Math.min(left, i - prevIdx);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (indexMap.containsKey(prefixSum[i] + target)) {\\n\\t\\t\\t\\tint nextIdx = indexMap.get(prefixSum[i] + target);\\n\\t\\t\\t\\tright = nextIdx - i;\\n\\t\\t\\t\\tif (left != Integer.MAX_VALUE) {\\n\\t\\t\\t\\t\\tresult = Math.min(result, right + left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (result == Integer.MAX_VALUE)\\n\\t\\t\\treturn -1;\\n\\t\\treturn result;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790734,
                "title": "python-this-is-what-interviewer-is-expecting-prefix-suffix-array-clean-code",
                "content": "Hint made the solution quite clear, you can get 2 lists that contain prefix shortest lengths and suffix shortest lengths, the result is just simply minimal of sum(prefix[i], suffix[i+1]) for i in [0, n-2]. I don\\'t like those dirty tricks that trying to avoid hashmap, most of those implementations are hard to understand and maintain, I don\\'t expect to see those in my everyday work.\\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n\\t    # prefix shortest length read from left to right [3,1,5,2,1]3 -> [1, 1, 1, 1, 1]\\n        leftmin = self.getMinArr(arr, target, True)\\n\\t\\t# suffix shortest length read from right to left [3,1,5,2,1]3 -> [1, 2, 2, 2, max]\\n        rightmin = self.getMinArr(arr, target, False)\\n        res = sys.maxsize\\n        for i in range(0, len(arr) - 1):\\n            if max(leftmin[i], rightmin[i + 1]) != sys.maxsize: # no overlap for i and i + 1\\n                res = min(leftmin[i] + rightmin[i + 1], res)\\n        return res if res < sys.maxsize else -1\\n    \\n    def getMinArr(self, arr: list, target: int, right: bool) -> None:\\n        res = [sys.maxsize] * len(arr)\\n        cursum = 0\\n        nummap = {0: 0}\\n        # if it\\'s reading from right to left, then reverse input array\\n        nums = arr if right else arr[::-1]\\n        for i, num in enumerate(nums):\\n            if i > 0: # min length is the same with previous one before calculation\\n                res[i] = res[i - 1]\\n            cursum += num\\n            if cursum - target in nummap: # get target, calculate minimal length\\n                curlen = i - nummap[cursum - target] + 1\\n                res[i] = min(res[i], curlen)\\n            nummap[cursum] = i + 1\\n        if not right: # reverse result array if it was reading from right to left\\n            res.reverse()\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n\\t    # prefix shortest length read from left to right [3,1,5,2,1]3 -> [1, 1, 1, 1, 1]\\n        leftmin = self.getMinArr(arr, target, True)\\n\\t\\t# suffix shortest length read from right to left [3,1,5,2,1]3 -> [1, 2, 2, 2, max]\\n        rightmin = self.getMinArr(arr, target, False)\\n        res = sys.maxsize\\n        for i in range(0, len(arr) - 1):\\n            if max(leftmin[i], rightmin[i + 1]) != sys.maxsize: # no overlap for i and i + 1\\n                res = min(leftmin[i] + rightmin[i + 1], res)\\n        return res if res < sys.maxsize else -1\\n    \\n    def getMinArr(self, arr: list, target: int, right: bool) -> None:\\n        res = [sys.maxsize] * len(arr)\\n        cursum = 0\\n        nummap = {0: 0}\\n        # if it\\'s reading from right to left, then reverse input array\\n        nums = arr if right else arr[::-1]\\n        for i, num in enumerate(nums):\\n            if i > 0: # min length is the same with previous one before calculation\\n                res[i] = res[i - 1]\\n            cursum += num\\n            if cursum - target in nummap: # get target, calculate minimal length\\n                curlen = i - nummap[cursum - target] + 1\\n                res[i] = min(res[i], curlen)\\n            nummap[cursum] = i + 1\\n        if not right: # reverse result array if it was reading from right to left\\n            res.reverse()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740070,
                "title": "c-easy-understand-intuitive-o-n-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& a, int target) {\\n        int n = a.size();\\n        vector<int> s(n+1);\\n        for (int i = 1; i <= n; ++i) s[i] = s[i-1]+a[i-1];\\n        \\n        unordered_map<int, int> m; // map[x,y] that holds sum \\'x\\' is available at index \\'y\\'\\n        m[0] = 0; \\n        const int INF = 1e9;\\n        vector<int> x(n+1, INF), y(n+1, INF);\\n        for (int i = 1; i <= n; ++i)\\n        {\\n            if (m.count(s[i]-target))\\n            {\\n                int tmp = m[s[i]-target]+1;\\n                x[i] = i-tmp+1; // i is ending index\\n                y[tmp] = i-tmp+1; // tmp is starting index\\n            }\\n            m[s[i]] = i;\\n        }\\n        \\n        int ans = INF;\\n        for (int i = 1; i < n; ++i)\\n        {\\n            x[i] = min(x[i], x[i-1]); // min length subarray ending in index i\\n            ans = min(ans, x[i]+y[i+1]); // y[i+1] represents subarray starting from i+1 so that there is no overlap\\n        }\\n        if (ans == INF) ans = -1;\\n        return ans;\\n    }\\n};\\n```\\nUpvote only if it helped, thanks.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& a, int target) {\\n        int n = a.size();\\n        vector<int> s(n+1);\\n        for (int i = 1; i <= n; ++i) s[i] = s[i-1]+a[i-1];\\n        \\n        unordered_map<int, int> m; // map[x,y] that holds sum \\'x\\' is available at index \\'y\\'\\n        m[0] = 0; \\n        const int INF = 1e9;\\n        vector<int> x(n+1, INF), y(n+1, INF);\\n        for (int i = 1; i <= n; ++i)\\n        {\\n            if (m.count(s[i]-target))\\n            {\\n                int tmp = m[s[i]-target]+1;\\n                x[i] = i-tmp+1; // i is ending index\\n                y[tmp] = i-tmp+1; // tmp is starting index\\n            }\\n            m[s[i]] = i;\\n        }\\n        \\n        int ans = INF;\\n        for (int i = 1; i < n; ++i)\\n        {\\n            x[i] = min(x[i], x[i-1]); // min length subarray ending in index i\\n            ans = min(ans, x[i]+y[i+1]); // y[i+1] represents subarray starting from i+1 so that there is no overlap\\n        }\\n        if (ans == INF) ans = -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723145,
                "title": "python-one-pass-using-defaultdict-instead-of-sliding-window",
                "content": "Like most solutions, I basically do this:\\n(1) Maintain a prefix sum and store the last index for the current prefix sum (\"lastSeen\").\\n(2) Use defaultdict (\"minSize\") to store the minimum size of the qualifying subarray up to that point.\\n(3) Update these as well as the result in the loop. Others use the sliding window approach to avoid maintaining the \"lastSeen\" data structure but I find that harder to understand.\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def minSumOfLengths(self, arr, target):\\n        inf = float(\\'inf\\')\\n        prefix = 0\\n        minSize = defaultdict(lambda: inf)\\n        lastSeen = {0: -1}\\n        result = inf\\n        for i, n in enumerate(arr):\\n            prefix += n\\n            if prefix-target in lastSeen:\\n                j = lastSeen[prefix-target]\\n                result = min(result, i-j + minSize[j])\\n                minSize[i] = min(minSize[i-1], i-j)\\n            else:\\n                minSize[i] = minSize[i-1]\\n            \\n            lastSeen[prefix] = i\\n\\n        return -1 if result == inf else result\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def minSumOfLengths(self, arr, target):\\n        inf = float(\\'inf\\')\\n        prefix = 0\\n        minSize = defaultdict(lambda: inf)\\n        lastSeen = {0: -1}\\n        result = inf\\n        for i, n in enumerate(arr):\\n            prefix += n\\n            if prefix-target in lastSeen:\\n                j = lastSeen[prefix-target]\\n                result = min(result, i-j + minSize[j])\\n                minSize[i] = min(minSize[i-1], i-j)\\n            else:\\n                minSize[i] = minSize[i-1]\\n            \\n            lastSeen[prefix] = i\\n\\n        return -1 if result == inf else result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685689,
                "title": "python-3-very-short-o-n",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, a: List[int], targ: int) -> int:\\n        \\n        n = len(a)\\n        d1 = defaultdict(lambda: inf)\\n        ret2 = inf\\n        tot = 0\\n        j = 0\\n        \\n        for i,x in enumerate(a):\\n            \\n            tot += x\\n            \\n            while tot > targ:\\n                tot -= a[j]\\n                j += 1\\n            \\n            sz = i-j+1\\n            \\n            if tot == targ:\\n                d1[i] = sz\\n                ret2 = min(ret2, d1[j-1] + sz)\\n            \\n            d1[i] = min(d1[i], d1[i-1])\\n        \\n        return -1 if ret2 == inf else ret2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, a: List[int], targ: int) -> int:\\n        \\n        n = len(a)\\n        d1 = defaultdict(lambda: inf)\\n        ret2 = inf\\n        tot = 0\\n        j = 0\\n        \\n        for i,x in enumerate(a):\\n            \\n            tot += x\\n            \\n            while tot > targ:\\n                tot -= a[j]\\n                j += 1\\n            \\n            sz = i-j+1\\n            \\n            if tot == targ:\\n                d1[i] = sz\\n                ret2 = min(ret2, d1[j-1] + sz)\\n            \\n            d1[i] = min(d1[i], d1[i-1])\\n        \\n        return -1 if ret2 == inf else ret2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685687,
                "title": "c-o-n-solution-with-helper-arrays-and-explanation",
                "content": "The problem could be splitted in two subproblems:\\n- find all subarrays which sum is equal to target\\n- between the valid subarrays, find the two smalles not overlapping\\n\\nFor the first problem we can easily solve it using the standard approach of prefix sum + helper HashMap with the ending index of previous sums (approach 4 of https://leetcode.com/problems/subarray-sum-equals-k/solution/ )\\nEvery time we have a match we can track that we found a matching array of size X starting at the index L and ending at index R. In the index L and R we can directly store the size. We can then linearly calculate what is the smallest array which ends before or which start after a specific index.\\n\\nFinally we can go over all pair of indexes \\'i\\' and \\'i+1\\', checking the sum of the smallest array which ends before \\'i\\' and which start after \\'i+1\\'. We can do this because we know that they don\\'t overlap\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        unordered_map<int, int> prev;\\n        prev[0] = -1;\\n        int prevVal = 0;\\n        \\n        vector<int> matchLeft(n, n + 1), matchRight(n, n + 1);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // calculate cumulative sum\\n            arr[i] += prevVal;\\n            prevVal = arr[i];\\n            \\n            if (prev.count(arr[i] - target)) {\\n                // subarray sum matches the target\\n                int secondIndex = prev[arr[i] - target];\\n                \\n                // store the shortest matching array ending in \\'i\\'\\n                if (matchLeft[i] > i - secondIndex)\\n                    matchLeft[i] = i - secondIndex;\\n                \\n                // store the shortest matching array starting in \\'secondIndex + 1\\'\\n                if (matchRight[secondIndex + 1] > i - secondIndex)\\n                    matchRight[secondIndex + 1] = i - secondIndex;\\n            }\\n            prev[arr[i]] = i;\\n        }\\n        \\n        // store the shortest matching array after index \\'i\\'\\n        for (int i = n - 2; i >= 0; --i)\\n            matchRight[i] = min(matchRight[i], matchRight[i+1]);\\n        \\n        int ans = n + 1;\\n        int minLeft = matchLeft[0];\\n        \\n        // for each \\'i\\' and \\'i+1\\', calculate the shortest matching array\\n        // which ends before \\'i\\' and the shortest which start after \\'i+1\\'\\n        for (int i = 0; i < n - 1; ++i) {\\n            minLeft = min(minLeft, matchLeft[i]);\\n            ans = min(ans, minLeft + matchRight[i+1]);\\n        }\\n        \\n        if (ans == n + 1)\\n            return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        unordered_map<int, int> prev;\\n        prev[0] = -1;\\n        int prevVal = 0;\\n        \\n        vector<int> matchLeft(n, n + 1), matchRight(n, n + 1);\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // calculate cumulative sum\\n            arr[i] += prevVal;\\n            prevVal = arr[i];\\n            \\n            if (prev.count(arr[i] - target)) {\\n                // subarray sum matches the target\\n                int secondIndex = prev[arr[i] - target];\\n                \\n                // store the shortest matching array ending in \\'i\\'\\n                if (matchLeft[i] > i - secondIndex)\\n                    matchLeft[i] = i - secondIndex;\\n                \\n                // store the shortest matching array starting in \\'secondIndex + 1\\'\\n                if (matchRight[secondIndex + 1] > i - secondIndex)\\n                    matchRight[secondIndex + 1] = i - secondIndex;\\n            }\\n            prev[arr[i]] = i;\\n        }\\n        \\n        // store the shortest matching array after index \\'i\\'\\n        for (int i = n - 2; i >= 0; --i)\\n            matchRight[i] = min(matchRight[i], matchRight[i+1]);\\n        \\n        int ans = n + 1;\\n        int minLeft = matchLeft[0];\\n        \\n        // for each \\'i\\' and \\'i+1\\', calculate the shortest matching array\\n        // which ends before \\'i\\' and the shortest which start after \\'i+1\\'\\n        for (int i = 0; i < n - 1; ++i) {\\n            minLeft = min(minLeft, matchLeft[i]);\\n            ans = min(ans, minLeft + matchRight[i+1]);\\n        }\\n        \\n        if (ans == n + 1)\\n            return -1;\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685682,
                "title": "c-easy-2-pointer-o-n-constant-space-solution-explained",
                "content": "m1 = length of smallest subarray\\nm2= length of 2nd smallest\\nl= length of subarray\\nstart=starting index of current subarray\\nend = ending index of prev subarray +1\\nI am subtracting the current index value from sum which was equal to target. As soon as sum becomes negative I add the initial value of the subarray and decrease the counter l till sum is negative. When sum = 0 if the length of the new subarray is less than m1, I update m1 with l, m2 with m1 and ending of this new subarray with current index i, but if the length of current subarray is greater than m1 but less than m2 I check if the subarrays are overlapping, if not then I update m2.\\nI check for sum =0 condition again outside the loop in case if the last index of array makes the sum =0.\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& a, int target) {\\n        if(a.size()<=1)return -1;\\n        int m1=INT_MAX,m2=INT_MAX,l=0,sum=target,start=0,end=-1;\\n        for(int i=0;i<a.size();i++){\\n            if(sum==0){\\n                if(l<m1){if(start>=end)m2=m1;m1=l;end=i;}\\n                else if(l<m2 && start>=end){m2=l;end=i;}\\n                l--;\\n                sum+=a[start++];\\n            }\\n           sum-=a[i];\\n            l++;\\n            if(sum<0){\\n                while(sum<0){sum+=a[start++];l--;}\\n            }\\n\\n        }\\n         \\n        if(sum==0){\\n                if(l<m1 ){if(start>=end)m2=m1;m1=l;}\\n                else if(l<m2 && start>=end){m2=l;}\\n        }\\n        if(m1==INT_MAX || m2==INT_MAX )return -1;\\n        else return m1+m2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& a, int target) {\\n        if(a.size()<=1)return -1;\\n        int m1=INT_MAX,m2=INT_MAX,l=0,sum=target,start=0,end=-1;\\n        for(int i=0;i<a.size();i++){\\n            if(sum==0){\\n                if(l<m1){if(start>=end)m2=m1;m1=l;end=i;}\\n                else if(l<m2 && start>=end){m2=l;end=i;}\\n                l--;\\n                sum+=a[start++];\\n            }\\n           sum-=a[i];\\n            l++;\\n            if(sum<0){\\n                while(sum<0){sum+=a[start++];l--;}\\n            }\\n\\n        }\\n         \\n        if(sum==0){\\n                if(l<m1 ){if(start>=end)m2=m1;m1=l;}\\n                else if(l<m2 && start>=end){m2=l;}\\n        }\\n        if(m1==INT_MAX || m2==INT_MAX )return -1;\\n        else return m1+m2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685630,
                "title": "java-dp-and-window-sliding-one-pass-o-n-time-easy-to-understand",
                "content": "Borrow the idea from the TreeMap solution. dp[i] stores the length of shortest interval with sum equals to target from index 0 to i. Using slide window to calculate sum of subarray, whenever target is met, use dp to find the min interval not overlapping. At the end of each loop, update dp[i] = min(dp[i], dp[i-1]).\\n\\n```\\npublic int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        int sum = 0;\\n        int i = 0;\\n        int j = 0;\\n        int res = Integer.MAX_VALUE;\\n        while(j < arr.length)\\n        {\\n            sum += arr[j];\\n            while(sum > target)\\n            {\\n                sum -= arr[i];\\n                i++;\\n            }\\n            if(sum == target)\\n            {\\n                if(i-1 >= 0 && dp[i-1] != Integer.MAX_VALUE)\\n                {\\n                    res = Math.min(res, j-i+1 + dp[i-1]); //find non overlap interval before i\\n                }\\n                dp[j] = j-i+1;\\n            }\\n            if(j > 0)\\n                dp[j] = Math.min(dp[j], dp[j-1]); //the min interval until j\\n            j++;\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "Borrow the idea from the TreeMap solution. dp[i] stores the length of shortest interval with sum equals to target from index 0 to i. Using slide window to calculate sum of subarray, whenever target is met, use dp to find the min interval not overlapping. At the end of each loop, update dp[i] = min(dp[i], dp[i-1]).\\n\\n```\\npublic int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        int sum = 0;\\n        int i = 0;\\n        int j = 0;\\n        int res = Integer.MAX_VALUE;\\n        while(j < arr.length)\\n        {\\n            sum += arr[j];\\n            while(sum > target)\\n            {\\n                sum -= arr[i];\\n                i++;\\n            }\\n            if(sum == target)\\n            {\\n                if(i-1 >= 0 && dp[i-1] != Integer.MAX_VALUE)\\n                {\\n                    res = Math.min(res, j-i+1 + dp[i-1]); //find non overlap interval before i\\n                }\\n                dp[j] = j-i+1;\\n            }\\n            if(j > 0)\\n                dp[j] = Math.min(dp[j], dp[j-1]); //the min interval until j\\n            j++;\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 685611,
                "title": "c-concept-and-easy-solution-with-dp",
                "content": "Although I could solve this during contest due to one edge case but I think is the shortest understandable approach.\\n\\nApproach is this:\\n- Keep track of minimum length subarray at each index of the nums\\n- Whenever you find next subarray with sum=target just check if this subarry length plus any previous subarray length can be are our desired result(less than any two subarray sum untill this)\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();        \\n        int res=INT_MAX;       \\n        int i=0,j=0,sum=0;\\n        vector<int> dp(n+1,INT_MAX);  // Just to keep track of minimum subarray untill current index\\n        sum+=arr[0];\\n        j=1;\\n        while(j<=n){         \\n            \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0while(i<j && sum>target){  // Check current windows if sum is greater than target\\n                sum -= arr[i];   //shrink sliding windows\\n                i++;\\n            }\\n            \\n            if(target==sum){    // If current windows sum is target\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(dp[i]!=INT_MAX){ \\xA0  // If  this is atleast 2nd subarray(we already found one subarray with target before)\\n                    int curr = j-i+dp[i]; // length of this windows + length of previous minimum window \\n                    res = min(res, curr);   // Check if these two subarrays are minimum length\\n                }                       \\n                dp[j] = min(j-i, dp[j-1]);  // check minimum subarray length with target at this index               \\n            } else{            \\n                dp[j] = dp[j-1];   // If current windows sum is not target and minimum subarray untill now is just like previous index\\n            }        \\n            \\n            if(j==n) break;\\n            \\n            sum+=arr[j];\\n            j++;\\n        }       \\n        if(res<=100000)   \\n            return res;\\n        return -1;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();        \\n        int res=INT_MAX;       \\n        int i=0,j=0,sum=0;\\n        vector<int> dp(n+1,INT_MAX);  // Just to keep track of minimum subarray untill current index\\n        sum+=arr[0];\\n        j=1;\\n        while(j<=n){         \\n            \\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0while(i<j && sum>target){  // Check current windows if sum is greater than target\\n                sum -= arr[i];   //shrink sliding windows\\n                i++;\\n            }\\n            \\n            if(target==sum){    // If current windows sum is target\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(dp[i]!=INT_MAX){ \\xA0  // If  this is atleast 2nd subarray(we already found one subarray with target before)\\n                    int curr = j-i+dp[i]; // length of this windows + length of previous minimum window \\n                    res = min(res, curr);   // Check if these two subarrays are minimum length\\n                }                       \\n                dp[j] = min(j-i, dp[j-1]);  // check minimum subarray length with target at this index               \\n            } else{            \\n                dp[j] = dp[j-1];   // If current windows sum is not target and minimum subarray untill now is just like previous index\\n            }        \\n            \\n            if(j==n) break;\\n            \\n            sum+=arr[j];\\n            j++;\\n        }       \\n        if(res<=100000)   \\n            return res;\\n        return -1;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685538,
                "title": "c-o-n-dp-and-prefix-sum-solution-one-pass",
                "content": "For each element ``` arr[i] ```, use prefix-sum to find if a valid subarray exists ending at ```i```. If yes, it will start at ```j = index[sum-target]```, where ```sum``` is the running total. Simply find the length of the shortest valid subarray before the start of this subarray, ```minDP[j]``` and add it to the length of the current valid array, ``` dp[i] = i-j ```. Keep track of the minimum sum of these two lengths.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> dp(n); // dp[i]: length of valid subarray ending at i\\n        vector<int> minDP(n); // minDP[i]: length of shortest valid subarray till i\\n        unordered_map<int,int> index;  // maps running total to index\\n        int mindp = INT_MAX,ans = INT_MAX,sum = 0;\\n        index[sum] = -1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(index.find(sum-target)!=index.end()){ // valid subarray\\n\\t\\t\\t\\tint j = index[sum-target];\\n                dp[i] = i-j; // length of current subarray\\n                if(j>=0 && minDP[j]!=INT_MAX) \\n                    ans = min(ans, dp[i]+minDP[j]);\\n            }\\n            else dp[i] = INT_MAX; // invalid subarray\\n            mindp = min(mindp,dp[i]);\\n            minDP[i] = mindp;\\n            index[sum] = i;\\n        }\\n        return ans==INT_MAX? -1:ans;\\n    }\\n};\\n```\\n\\nTime - ```O(n)```\\nSpace - ```O(n)```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "``` arr[i] ```\n```i```\n```j = index[sum-target]```\n```sum```\n```minDP[j]```\n``` dp[i] = i-j ```\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> dp(n); // dp[i]: length of valid subarray ending at i\\n        vector<int> minDP(n); // minDP[i]: length of shortest valid subarray till i\\n        unordered_map<int,int> index;  // maps running total to index\\n        int mindp = INT_MAX,ans = INT_MAX,sum = 0;\\n        index[sum] = -1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            if(index.find(sum-target)!=index.end()){ // valid subarray\\n\\t\\t\\t\\tint j = index[sum-target];\\n                dp[i] = i-j; // length of current subarray\\n                if(j>=0 && minDP[j]!=INT_MAX) \\n                    ans = min(ans, dp[i]+minDP[j]);\\n            }\\n            else dp[i] = INT_MAX; // invalid subarray\\n            mindp = min(mindp,dp[i]);\\n            minDP[i] = mindp;\\n            index[sum] = i;\\n        }\\n        return ans==INT_MAX? -1:ans;\\n    }\\n};\\n```\n```O(n)```\n```O(n)```",
                "codeTag": "Java"
            },
            {
                "id": 685418,
                "title": "java-heap-correct-for-given-cases-feel-free-to-modify-to-run-all-test-case",
                "content": "\\nfind all subarrays with given sum. and add it to heap ( sorted according to the length of subarray).\\ntake 2 subarrays out. if they overlap. insert min one and continue till u get result.\\n\\n**doesnt work for test cases where u need to not put min back inside the heap.**\\n\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n       \\n        Queue<int[]> q = new PriorityQueue<>(new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] x, int[] y)\\n            {\\n                return x[0]-y[0];\\n            }\\n        });\\n        int sum =0;\\n        m.put(0,-1);\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            sum +=arr[i];\\n            if(m.containsKey(sum-target))\\n            {\\n                \\n                q.add(new int[]{i-m.get(sum-target) , i});\\n            }\\n            m.put(sum, i);\\n        }\\n        while(q.size()>1)\\n        {\\n            int x[] = q.poll();\\n            int y[] = q.poll();\\n            if(overlap(x,y))\\n                q.add(x);\\n            else\\n                return x[0]+y[0];\\n        }\\n        return -1;\\n    }\\n    boolean overlap(int x[], int[] y)\\n    {\\n        if(x[1]<=y[1]-y[0])\\n            return false;\\n        if(y[1]<=x[1]-x[0])\\n            return false;\\n        return true;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n       \\n        Queue<int[]> q = new PriorityQueue<>(new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] x, int[] y)\\n            {\\n                return x[0]-y[0];\\n            }\\n        });\\n        int sum =0;\\n        m.put(0,-1);\\n        for(int i=0; i<arr.length; i++)\\n        {\\n            sum +=arr[i];\\n            if(m.containsKey(sum-target))\\n            {\\n                \\n                q.add(new int[]{i-m.get(sum-target) , i});\\n            }\\n            m.put(sum, i);\\n        }\\n        while(q.size()>1)\\n        {\\n            int x[] = q.poll();\\n            int y[] = q.poll();\\n            if(overlap(x,y))\\n                q.add(x);\\n            else\\n                return x[0]+y[0];\\n        }\\n        return -1;\\n    }\\n    boolean overlap(int x[], int[] y)\\n    {\\n        if(x[1]<=y[1]-y[0])\\n            return false;\\n        if(y[1]<=x[1]-x[0])\\n            return false;\\n        return true;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685380,
                "title": "java-sliding-window-and-check-overlap-interval",
                "content": "**Modify the code to handle failed cases**\\n\\n\\nBasica idea is using sliding window and check for the intervals sum to target.\\nBut we may face some interval are overlapped. \\nSo we could matain the heap to check for overlapped intervals and select two non-overlapped interval that has least range.\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int left = 0;\\n        int sum = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        for (int right = 0; right < arr.length; right++) {\\n            sum += arr[right];         \\n            while (sum > target) {\\n                sum -= arr[left];\\n                left++;\\n            }\\n            if (sum == target) {\\n                int[] interval = {left, right, right - left + 1};\\n                pq.offer(interval);\\n            }\\n        }\\n        \\n        if (pq.size() < 2) {\\n            return -1;\\n        }\\n \\n\\n        int res = Integer.MAX_VALUE;\\n        int[] first = pq.poll();\\n        PriorityQueue<int[]> conflictedPq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        \\n        while (!pq.isEmpty()) {\\n            int s = first[2];\\n            int[] cur = pq.poll();\\n\\n            //check overlap, non overlap, possible solution;\\n            boolean find = false;\\n            if (cur[0] > first[1] || cur[1] < first[0]) {\\n                s += cur[2];\\n                res = Math.min(res, s);\\n                find = true;\\n            }\\n            else {\\n                // overlapped, those overlapped conflict with the selected smaller range, could also form possible solutions\\n                conflictedPq.offer(cur);\\n            }\\n            \\n            if (find || pq.isEmpty()) {\\n                pq = conflictedPq;\\n                conflictedPq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n                first = pq.poll();\\n            }\\n\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int left = 0;\\n        int sum = 0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        for (int right = 0; right < arr.length; right++) {\\n            sum += arr[right];         \\n            while (sum > target) {\\n                sum -= arr[left];\\n                left++;\\n            }\\n            if (sum == target) {\\n                int[] interval = {left, right, right - left + 1};\\n                pq.offer(interval);\\n            }\\n        }\\n        \\n        if (pq.size() < 2) {\\n            return -1;\\n        }\\n \\n\\n        int res = Integer.MAX_VALUE;\\n        int[] first = pq.poll();\\n        PriorityQueue<int[]> conflictedPq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        \\n        while (!pq.isEmpty()) {\\n            int s = first[2];\\n            int[] cur = pq.poll();\\n\\n            //check overlap, non overlap, possible solution;\\n            boolean find = false;\\n            if (cur[0] > first[1] || cur[1] < first[0]) {\\n                s += cur[2];\\n                res = Math.min(res, s);\\n                find = true;\\n            }\\n            else {\\n                // overlapped, those overlapped conflict with the selected smaller range, could also form possible solutions\\n                conflictedPq.offer(cur);\\n            }\\n            \\n            if (find || pq.isEmpty()) {\\n                pq = conflictedPq;\\n                conflictedPq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n                first = pq.poll();\\n            }\\n\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685324,
                "title": "python-prefix-sums-heap-passes-given-test-cases-feel-free-to-modify-to-run-all-test-cases",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        heap = []\\n        prefix_sum = {}\\n        prefix_sum[0] = -1\\n        curr_sum = 0\\n        for i in range(n): \\n            curr_sum += arr[i]\\n            if prefix_sum.get(curr_sum - target):\\n                heapq.heappush(heap,(i - prefix_sum.get(curr_sum - target), i))\\n            prefix_sum[curr_sum] = i\\n                \\n        while len(heap) > 1:\\n            len1, end1 = heapq.heappop(heap)\\n            len2, end2 = heapq.heappop(heap)\\n            if end1 <= end2 - len2 or end2 <= end1 - len1:    \\n                return len1 + len2\\n            else:    # overlap\\n                heapq.heappush(heap, (len1, end1))\\n                \\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        heap = []\\n        prefix_sum = {}",
                "codeTag": "Java"
            },
            {
                "id": 3915250,
                "title": "prefix-sum-application",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& a, int t) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        mp[0] = -1;\\n        int sum = 0;\\n        int lsz = INT_MAX;\\n        int res = INT_MAX;\\n        int n = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=a[i];\\n            mp[sum] = i; \\n        }\\n        \\n        sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=a[i];\\n            if(mp.find(sum-t)!=mp.end())\\n            {\\n                lsz = min(lsz,i-mp[sum-t]);\\n            }\\n            \\n            \\n            if(mp.find(sum+t)!=mp.end() && lsz !=INT_MAX)\\n            {\\n                res = min(res,mp[sum+t]-i + lsz );\\n            }\\n        }\\n        \\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& a, int t) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        mp[0] = -1;\\n        int sum = 0;\\n        int lsz = INT_MAX;\\n        int res = INT_MAX;\\n        int n = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=a[i];\\n            mp[sum] = i; \\n        }\\n        \\n        sum = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=a[i];\\n            if(mp.find(sum-t)!=mp.end())\\n            {\\n                lsz = min(lsz,i-mp[sum-t]);\\n            }\\n            \\n            \\n            if(mp.find(sum+t)!=mp.end() && lsz !=INT_MAX)\\n            {\\n                res = min(res,mp[sum+t]-i + lsz );\\n            }\\n        }\\n        \\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555848,
                "title": "c-python-prefix-sum-dynamic-programming-solution-with-explanation",
                "content": "First, we can use prefix sum to find left side of array whose right side is at current number and sum is equal to ```target```.\\nThe problem is how to find another array is not overlapped with this array and sum of two array length is the shortest.\\n```dp[i]``` is length of shortest array whose sum is equal to ```target``` before location ```i```.\\nSo, if we find a array whose sum is equal to ```target```, ```dp[i] = min(dp[i-1], length)``` else ```dp[i] = dp[i-1]```\\n\\nThe key is ```dp```, if current number is right side of array whose sum is equal to ```target```, one array length is ``` current index - prefix[cur sum - target]```, another array should be before location ```prefix[cur sum - target] + 1```, so its length is ```dp[prefix[cur sum - target]]```, so two array length is ```current index - prefix[cur sum - target] + dp[prefix[cur sum - target]]```, and track the shortest length is the answer.\\n\\ne.g. ```[1,1,1,2,1,1,1], target = 3```\\n```\\nprefix is a mapping from current sum to index.\\nidx     -1 0 1 2 3 4 5 6\\n         x 1 1 2 1 1 1 3\\nsum      0 1 2 4 5 6 7 10\\ndp[idx]  m m m 2 2 2 2 1\\nans      m m m m m m 5 3\\n\\nAt arr[5] = 1, current sum is 7, 7 - 3 = 4 in prefix, prefix[4] is 2 which means arr[3~5] is one of both array\\nlength of array whose right side at nums[5] is 5 - prefix[4](=index 2) = 3,\\nanother array should be before index 3, so length of another array is dp[2] = dp[prefix[4]] = dp[prefix[current sum - target]].\\n\\n```\\ntc is O(n), sc is O(n)\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int ans = 2 * arr.size(), cur = 0;\\n        vector<int> dp (arr.size() + 1, 2 * arr.size());  // because of dp[i-1], add a trivail value be index -1\\n        unordered_map<int, int> prefix;\\n        prefix[0] = -1;\\n        for (int i = 0, leng; i < arr.size(); i+=1) {\\n            cur += arr[i];\\n            if (prefix.count(cur - target) != 0) {\\n                leng = i - prefix[cur - target];\\n                dp[i+1] = min(dp[i], leng);\\n                ans = min(ans, leng + dp[prefix[cur - target] + 1]);\\n                \\n            } else dp[i+1] = dp[i];\\n            prefix[cur] = i;\\n        }\\n        return ans != 2 * arr.size()? ans :-1;\\n    }\\n};\\n\\n```\\n### python\\n```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefix = {0: -1}\\n        ans = 2 * len(arr)\\n        cur = 0 # current sum\\n        dp = [2 * len(arr)] * (len(arr) + 1) # because of dp[i-1], add a trivail value be index -1\\n        for idx, n in enumerate(arr):\\n            cur += n\\n            if cur - target in prefix:\\n                leng = idx - prefix[cur - target]\\n                dp[idx+1] = min(dp[idx], leng)\\n                ans = min(ans, leng + dp[prefix[cur - target] + 1])\\n            else: dp[idx+1] = dp[idx]\\n            prefix[cur] = idx\\n        return ans if ans != 2 * len(arr) else -1\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```target```\n```dp[i]```\n```target```\n```i```\n```target```\n```dp[i] = min(dp[i-1], length)```\n```dp[i] = dp[i-1]```\n```dp```\n```target```\n``` current index - prefix[cur sum - target]```\n```prefix[cur sum - target] + 1```\n```dp[prefix[cur sum - target]]```\n```current index - prefix[cur sum - target] + dp[prefix[cur sum - target]]```\n```[1,1,1,2,1,1,1], target = 3```\n```\\nprefix is a mapping from current sum to index.\\nidx     -1 0 1 2 3 4 5 6\\n         x 1 1 2 1 1 1 3\\nsum      0 1 2 4 5 6 7 10\\ndp[idx]  m m m 2 2 2 2 1\\nans      m m m m m m 5 3\\n\\nAt arr[5] = 1, current sum is 7, 7 - 3 = 4 in prefix, prefix[4] is 2 which means arr[3~5] is one of both array\\nlength of array whose right side at nums[5] is 5 - prefix[4](=index 2) = 3,\\nanother array should be before index 3, so length of another array is dp[2] = dp[prefix[4]] = dp[prefix[current sum - target]].\\n\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int ans = 2 * arr.size(), cur = 0;\\n        vector<int> dp (arr.size() + 1, 2 * arr.size());  // because of dp[i-1], add a trivail value be index -1\\n        unordered_map<int, int> prefix;\\n        prefix[0] = -1;\\n        for (int i = 0, leng; i < arr.size(); i+=1) {\\n            cur += arr[i];\\n            if (prefix.count(cur - target) != 0) {\\n                leng = i - prefix[cur - target];\\n                dp[i+1] = min(dp[i], leng);\\n                ans = min(ans, leng + dp[prefix[cur - target] + 1]);\\n                \\n            } else dp[i+1] = dp[i];\\n            prefix[cur] = i;\\n        }\\n        return ans != 2 * arr.size()? ans :-1;\\n    }\\n};\\n\\n```\n```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        prefix = {0: -1}\\n        ans = 2 * len(arr)\\n        cur = 0 # current sum\\n        dp = [2 * len(arr)] * (len(arr) + 1) # because of dp[i-1], add a trivail value be index -1\\n        for idx, n in enumerate(arr):\\n            cur += n\\n            if cur - target in prefix:\\n                leng = idx - prefix[cur - target]\\n                dp[idx+1] = min(dp[idx], leng)\\n                ans = min(ans, leng + dp[prefix[cur - target] + 1])\\n            else: dp[idx+1] = dp[idx]\\n            prefix[cur] = idx\\n        return ans if ans != 2 * len(arr) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392189,
                "title": "hashmap-with-o-n-time",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n\\n        int sum = 0;\\n\\n        // first mapping all the prefix sum indices\\n        for(int i=0;i<n;i++) {\\n            sum += arr[i];\\n            mp[sum] = i;\\n        }\\n\\n        int len1 = INT_MAX, res = INT_MAX;\\n        sum = 0;\\n        // the basic idea is to get the target sum with minimum length subarray from current index to left and right\\n        for(int i=0;i<n;i++) {\\n            sum += arr[i];\\n\\n            if(mp.find(sum-target) != mp.end()) {       // to the left\\n                len1 = min(len1,i-mp[sum-target]);\\n            }\\n\\n            if(mp.find(sum+target) != mp.end() && len1 != INT_MAX) {     // to the right\\n                int len2 = mp[sum+target]-i;\\n                res = min(res, len1+len2);       // also need to check whether len != INT_MAX bcz, we haven\\'t even got the target sum on the left and we are looking for right(we have to find two subarrays so left would be the first priority) \\n            }\\n\\n        }\\n        return (res == INT_MAX?-1:res);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n\\n        unordered_map<int,int> mp;\\n        mp[0] = -1;\\n\\n        int sum = 0;\\n\\n        // first mapping all the prefix sum indices\\n        for(int i=0;i<n;i++) {\\n            sum += arr[i];\\n            mp[sum] = i;\\n        }\\n\\n        int len1 = INT_MAX, res = INT_MAX;\\n        sum = 0;\\n        // the basic idea is to get the target sum with minimum length subarray from current index to left and right\\n        for(int i=0;i<n;i++) {\\n            sum += arr[i];\\n\\n            if(mp.find(sum-target) != mp.end()) {       // to the left\\n                len1 = min(len1,i-mp[sum-target]);\\n            }\\n\\n            if(mp.find(sum+target) != mp.end() && len1 != INT_MAX) {     // to the right\\n                int len2 = mp[sum+target]-i;\\n                res = min(res, len1+len2);       // also need to check whether len != INT_MAX bcz, we haven\\'t even got the target sum on the left and we are looking for right(we have to find two subarrays so left would be the first priority) \\n            }\\n\\n        }\\n        return (res == INT_MAX?-1:res);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250804,
                "title": "easy-c-solution-in-o-n-using-dp-and-prefix-sum",
                "content": "# Intuition\\nThe prefix-sum is used to calculate the valid subarays. The `dp[i]` stores the minimum length valid subarray till index `i`. \\n\\n# Approach\\nOn every iteration, find the running sum (`prefix sum`). If there exists `s-target` already, means that the subarray between `m[s-target] + 1` and till `i` has a sum of `target`. We\\'ll then mark this as a valid subarray. Now, for this valid subarray, let `j` be the starting index. If there exists any valid subarray till `j-1`, we may have a result. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n\\n- Space complexity: $$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size(), s = 0,result = INT_MAX;;\\n        vector<int> dp(n, INT_MAX);     //len of smallest valid subarray ending at i\\n        \\n        unordered_map<int,int> m;\\n        m[0] = -1;\\n        for(int i=0;i<n;i++){\\n            s += arr[i];\\n            if(m.find(s-target) != m.end()){\\n                int j = m[s-target] + 1;\\n                dp[i] = i - (j) + 1;\\n\\n                //we also have a previous array\\n                if(j> 0 && dp[j - 1] != INT_MAX){\\n                    result = min(result, dp[j-1] + dp[i]);\\n                }\\n            }\\n\\n            if(i > 0){dp[i] = min(dp[i], dp[i-1]);}\\n            m[s] = i;\\n        }        \\n        \\n        return result == INT_MAX ? -1 : result;\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n = arr.size(), s = 0,result = INT_MAX;;\\n        vector<int> dp(n, INT_MAX);     //len of smallest valid subarray ending at i\\n        \\n        unordered_map<int,int> m;\\n        m[0] = -1;\\n        for(int i=0;i<n;i++){\\n            s += arr[i];\\n            if(m.find(s-target) != m.end()){\\n                int j = m[s-target] + 1;\\n                dp[i] = i - (j) + 1;\\n\\n                //we also have a previous array\\n                if(j> 0 && dp[j - 1] != INT_MAX){\\n                    result = min(result, dp[j-1] + dp[i]);\\n                }\\n            }\\n\\n            if(i > 0){dp[i] = min(dp[i], dp[i-1]);}\\n            m[s] = i;\\n        }        \\n        \\n        return result == INT_MAX ? -1 : result;\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697518,
                "title": "python-prefix-sum-solution-min-heap-leetcode-2054",
                "content": "```\\ndef minSumOfLengths(self, arr: List[int], t: int) -> int:\\n\\tpsum = list(accumulate(arr))\\n\\tmp, cans = {0:-1}, []\\n\\tfor i in range(len(psum)):\\n\\t\\tx = psum[i]-t\\n\\t\\tif x in mp:\\n\\t\\t\\tcans.append([mp[x], i])\\n\\t\\tmp[psum[i]] = i\\n\\n\\tq, cur, ans = [], len(arr)+10, len(arr)+10\\n\\tfor s, e in cans:\\n\\t\\twhile(q and q[0][0]<=s):\\n\\t\\t\\tcur = min(cur, heappop(q)[1])\\n\\t\\tans = min(ans, cur+(e-s))\\n\\t\\theappush(q, (e, e-s))\\n\\treturn ans if ans<=len(arr) else -1\\n```\\nSimilar problem:\\n[2054. Two Best Non-Overlapping Events](https://leetcode.com/problems/two-best-non-overlapping-events/discuss/2693097/Python-solution-or-sort-%2B-minheap)",
                "solutionTags": [],
                "code": "```\\ndef minSumOfLengths(self, arr: List[int], t: int) -> int:\\n\\tpsum = list(accumulate(arr))\\n\\tmp, cans = {0:-1}, []\\n\\tfor i in range(len(psum)):\\n\\t\\tx = psum[i]-t\\n\\t\\tif x in mp:\\n\\t\\t\\tcans.append([mp[x], i])\\n\\t\\tmp[psum[i]] = i\\n\\n\\tq, cur, ans = [], len(arr)+10, len(arr)+10\\n\\tfor s, e in cans:\\n\\t\\twhile(q and q[0][0]<=s):\\n\\t\\t\\tcur = min(cur, heappop(q)[1])\\n\\t\\tans = min(ans, cur+(e-s))\\n\\t\\theappush(q, (e, e-s))\\n\\treturn ans if ans<=len(arr) else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2531231,
                "title": "c-memoization-dp-binary-search-prefix-sum",
                "content": "```\\n#define ll long long int\\n    int t[100005][3] ;\\n    ll compute(vector<ll>&presum , ll target , int id  , ll k , int n){\\n        if(k == 0){\\n            return 0 ;\\n        }\\n        if(id >= n){\\n            return INT_MAX ;\\n        }\\n        if(t[id][k] != -1){\\n            return t[id][k] ;\\n        }\\n        ll ans = compute(presum , target , id+1 , k , n) ;\\n        auto lb = lower_bound(presum.begin() , presum.end() , presum[id-1] + target) ;\\n        if(lb != presum.end() && *lb == presum[id-1] + target){\\n            int pos = lb - presum.begin() ;\\n            ans = min(ans , pos-id+1 + compute(presum , target , pos+1 , k-1 , n)) ;\\n        }\\n        return t[id][k] = ans ;\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n= arr.size() ;\\n        \\n        memset(t , -1 , sizeof(t)) ;\\n        vector<ll>presum(n+1,0) ;\\n        for(int i = 1 ; i<=n; i++){\\n            presum[i] = presum[i-1] + arr[i-1] ;\\n        }\\n        ll ans = compute(presum , target , 1 , 2 , n+1) ;\\n        if(ans >= INT_MAX){\\n            return -1 ;\\n        }\\n        return ans ;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long int\\n    int t[100005][3] ;\\n    ll compute(vector<ll>&presum , ll target , int id  , ll k , int n){\\n        if(k == 0){\\n            return 0 ;\\n        }\\n        if(id >= n){\\n            return INT_MAX ;\\n        }\\n        if(t[id][k] != -1){\\n            return t[id][k] ;\\n        }\\n        ll ans = compute(presum , target , id+1 , k , n) ;\\n        auto lb = lower_bound(presum.begin() , presum.end() , presum[id-1] + target) ;\\n        if(lb != presum.end() && *lb == presum[id-1] + target){\\n            int pos = lb - presum.begin() ;\\n            ans = min(ans , pos-id+1 + compute(presum , target , pos+1 , k-1 , n)) ;\\n        }\\n        return t[id][k] = ans ;\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n= arr.size() ;\\n        \\n        memset(t , -1 , sizeof(t)) ;\\n        vector<ll>presum(n+1,0) ;\\n        for(int i = 1 ; i<=n; i++){\\n            presum[i] = presum[i-1] + arr[i-1] ;\\n        }\\n        ll ans = compute(presum , target , 1 , 2 , n+1) ;\\n        if(ans >= INT_MAX){\\n            return -1 ;\\n        }\\n        return ans ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2369685,
                "title": "beats-100-percent-cpp-solutions-very-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int target) {\\n        int pre =0;\\n        int n=nums.size();\\n        vector<pair<int,int>>st;\\n        unordered_map<int,int>m;\\n      \\n        for(int i=0;i<n;i++){\\n            pre+=nums[i];\\n            if(pre==target){\\n                 st.push_back({0,i});\\n            }\\n            if(m.find(pre-target)!=m.end()){\\n                st.push_back({m[pre-target]+1,i});\\n            }\\n            m[pre]=i;\\n        }\\n        if(st.size()==0)return -1;\\n        int res=1e9;\\n        sort(st.begin(),st.end());\\n        vector<int>mini(st.size(),-1);\\n        mini[st.size()-1]=abs(st[st.size()-1].first-st[st.size()-1].second)+1;\\n        for(int i=st.size()-2;i>=0;i--)\\n        {\\n            mini[i]=min(mini[i+1],abs(st[i].first-st[i].second)+1);\\n        }\\n       \\n        for(int i =0;i<st.size()-1;i++){\\n            int l=i+1;\\n            int h =st.size()-1;\\n            int pos =-1;\\n            while(h>=l)\\n            {\\n                int mid=(l+h)/2;\\n                if(st[mid].first>st[i].second){\\n                    pos=mid;\\n                    h=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }\\n            }\\n            if(pos!=-1){\\n                res=min(res,mini[pos]+abs(st[i].first-st[i].second)+1);\\n            }\\n        }\\n        if(res==1e9)return -1;\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int target) {\\n        int pre =0;\\n        int n=nums.size();\\n        vector<pair<int,int>>st;\\n        unordered_map<int,int>m;\\n      \\n        for(int i=0;i<n;i++){\\n            pre+=nums[i];\\n            if(pre==target){\\n                 st.push_back({0,i}",
                "codeTag": "Java"
            },
            {
                "id": 2345696,
                "title": "c-sliding-window-binary-search-preprocessing",
                "content": "* Solution consists mainly of 3 parts.\\n\\n* **Part-1** Using sliding window, get all intervals where `sum == tagret` . `iv` stores `[s,e]` , where interval `summation [s,e]` `== target`.\\n\\n* **Part-2** Get Minimum length of each interval starting from right hand side and store the current minimum length at each index. This vector helps in choosing the optimal second subarray in **part 3**\\n\\n* **Part-3** Pick index `i` as first subarray. To find other subarray length, Find upper bound of ending point of first interval, which is done by `upper_bound` function. At that index `idx`, every subarray after `idx` is good to pick for second subarry. But we want the one with min length. **minLen is pre calculated** which gets us our second subarray in O(1) time.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int target) {\\n\\t//This part of code inserts every interval which sums up to target\\n        vector<array<int,2>> iv ;\\n        for(int s = 0, e = 0 , sum = 0 ; e < nums.size() ; ++e){\\n            sum += nums[e] ;\\n            while(sum > target) sum -= nums[s++];\\n            if(sum == target) iv.push_back({s,e}) ;\\n        }\\n        \\n\\t\\t// In interval , Store minimum upto index say i, from right to left\\n        vector<int> minLen ;\\n        for(int i = iv.size() - 1 ; i >= 0 ; --i ){\\n            if(minLen.empty()) minLen.push_back(iv[i][1] - iv[i][0] + 1) ;\\n            else minLen.push_back(min(minLen.back(),iv[i][1]-iv[i][0] + 1));\\n        }\\n        \\n        reverse(begin(minLen),end(minLen)) ;\\n        \\n\\t\\t//choose index i as first subarray and search for other subarray using binary search and take minimum.\\n        int mini = INT_MAX ;\\n        for(int i = 0 ; i < iv.size() ; ++i ){\\n            int l = iv[i][1] ;\\n            int idx = upper_bound(begin(iv) + i + 1,end(iv),array<int,2>{l,INT_MAX}) - begin(iv) ;\\n            if(idx < iv.size()) mini = min(mini,iv[i][1] - iv[i][0] + 1 + minLen[idx]) ;\\n        }\\n        return mini == INT_MAX ? -1 : mini ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int target) {\\n\\t//This part of code inserts every interval which sums up to target\\n        vector<array<int,2>> iv ;\\n        for(int s = 0, e = 0 , sum = 0 ; e < nums.size() ; ++e){\\n            sum += nums[e] ;\\n            while(sum > target) sum -= nums[s++];\\n            if(sum == target) iv.push_back({s,e}) ;\\n        }\\n        \\n\\t\\t// In interval , Store minimum upto index say i, from right to left\\n        vector<int> minLen ;\\n        for(int i = iv.size() - 1 ; i >= 0 ; --i ){\\n            if(minLen.empty()) minLen.push_back(iv[i][1] - iv[i][0] + 1) ;\\n            else minLen.push_back(min(minLen.back(),iv[i][1]-iv[i][0] + 1));\\n        }\\n        \\n        reverse(begin(minLen),end(minLen)) ;\\n        \\n\\t\\t//choose index i as first subarray and search for other subarray using binary search and take minimum.\\n        int mini = INT_MAX ;\\n        for(int i = 0 ; i < iv.size() ; ++i ){\\n            int l = iv[i][1] ;\\n            int idx = upper_bound(begin(iv) + i + 1,end(iv),array<int,2>{l,INT_MAX}) - begin(iv) ;\\n            if(idx < iv.size()) mini = min(mini,iv[i][1] - iv[i][0] + 1 + minLen[idx]) ;\\n        }\\n        return mini == INT_MAX ? -1 : mini ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214284,
                "title": "o-n-time-o-n-space-a-little-more-intuitive",
                "content": "class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        running_sum = 0\\n        h = {}\\n        h[0] = -1\\n        min_at_index = [float(inf)]*len(arr)\\n        global_min = inf\\n        for i,v in enumerate(arr):\\n            \\n            running_sum += v\\n            \\n            if running_sum - target in h.keys():\\n                #inclusive start_index\\n                start_index = h[running_sum - target] + 1\\n                curr_length = i - start_index + 1\\n                \\n                global_min = min(curr_length + min_at_index[start_index-1],global_min)\\n                min_at_index[i] = min(min_at_index[i-1],curr_length)\\n            else:\\n                min_at_index[i] = min_at_index[i - 1]\\n                \\n            h[running_sum] = i\\n            \\n        if global_min == inf:\\n            return -1\\n        \\n        return global_min",
                "solutionTags": [],
                "code": "class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        running_sum = 0\\n        h = {}",
                "codeTag": "Java"
            },
            {
                "id": 2183623,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int left[n], right[n];\\n        unordered_map<int, int> lft;\\n        unordered_map<int, int> rht;\\n        int mod = 1e8+1;\\n        lft[0] = -1;\\n        rht[0] = n;\\n        int prfx = arr[0];\\n        lft[prfx] = 0;\\n        if(prfx == target)\\n            left[0] = 1;\\n        else\\n            left[0] = mod;\\n        for(int i = 1; i < n; i++)\\n        {\\n            prfx += arr[i];\\n            if(lft.count(prfx-target))\\n            {\\n                left[i] = min(left[i-1],i-lft[prfx-target]);\\n            }\\n            else\\n            {\\n                left[i] = left[i-1];\\n            }\\n            lft[prfx] = i;\\n        }\\n        prfx = arr[n-1];\\n        rht[prfx] = n-1;\\n        if(prfx == target)\\n            right[n-1] = 1;\\n        else\\n            right[n-1] = mod;\\n        for(int i = n-2; i >= 0; i--)\\n        {\\n            prfx += arr[i];\\n            if(rht.count(prfx-target))\\n            {\\n                right[i] = min(right[i+1],rht[prfx-target]-i);\\n            }\\n            else\\n            {\\n                right[i] = right[i+1];\\n            }\\n            rht[prfx] = i;\\n        }\\n        // for(int i = 0; i < n; i++)\\n        // {\\n        //     cout << left[i] << \" \";\\n        // }\\n        int ans = mod;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int v;\\n            if(left[i-1] == mod || right[i] == mod)\\n                v = mod;\\n            else\\n            {\\n                v = left[i-1]+right[i];\\n            }\\n            //cout << v << \" \";\\n            ans = min(v, ans);\\n        }\\n        if(ans == mod) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        int left[n], right[n];\\n        unordered_map<int, int> lft;\\n        unordered_map<int, int> rht;\\n        int mod = 1e8+1;\\n        lft[0] = -1;\\n        rht[0] = n;\\n        int prfx = arr[0];\\n        lft[prfx] = 0;\\n        if(prfx == target)\\n            left[0] = 1;\\n        else\\n            left[0] = mod;\\n        for(int i = 1; i < n; i++)\\n        {\\n            prfx += arr[i];\\n            if(lft.count(prfx-target))\\n            {\\n                left[i] = min(left[i-1],i-lft[prfx-target]);\\n            }\\n            else\\n            {\\n                left[i] = left[i-1];\\n            }\\n            lft[prfx] = i;\\n        }\\n        prfx = arr[n-1];\\n        rht[prfx] = n-1;\\n        if(prfx == target)\\n            right[n-1] = 1;\\n        else\\n            right[n-1] = mod;\\n        for(int i = n-2; i >= 0; i--)\\n        {\\n            prfx += arr[i];\\n            if(rht.count(prfx-target))\\n            {\\n                right[i] = min(right[i+1],rht[prfx-target]-i);\\n            }\\n            else\\n            {\\n                right[i] = right[i+1];\\n            }\\n            rht[prfx] = i;\\n        }\\n        // for(int i = 0; i < n; i++)\\n        // {\\n        //     cout << left[i] << \" \";\\n        // }\\n        int ans = mod;\\n        for(int i = 1; i < n; i++)\\n        {\\n            int v;\\n            if(left[i-1] == mod || right[i] == mod)\\n                v = mod;\\n            else\\n            {\\n                v = left[i-1]+right[i];\\n            }\\n            //cout << v << \" \";\\n            ans = min(v, ans);\\n        }\\n        if(ans == mod) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2111188,
                "title": "python3-sliding-window-based-solution",
                "content": "```\\n\"\"\"https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/\"\"\"\\n\\n\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        left, partial_sum, min_len = 0, 0, float(\\'inf\\')\\n        # records the smallest length of subarry with target sum until index i\\n        min_so_far = [float(\\'inf\\')] * len(arr)\\n        for right, num in enumerate(arr):\\n            partial_sum += num\\n            while partial_sum > target:\\n                partial_sum -= arr[left]\\n                left += 1\\n            if partial_sum == target:\\n                curr_len = right - left + 1\\n                min_len = min(min_len, curr_len + min_so_far[left - 1])\\n                min_so_far[right] = min(curr_len, min_so_far[right - 1])\\n            else:\\n                min_so_far[right] = min_so_far[right - 1]\\n        return min_len if min_len < float(\\'inf\\') else -1\\n",
                "solutionTags": [],
                "code": "```\\n\"\"\"https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/\"\"\"\\n\\n\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        left, partial_sum, min_len = 0, 0, float(\\'inf\\')\\n        # records the smallest length of subarry with target sum until index i\\n        min_so_far = [float(\\'inf\\')] * len(arr)\\n        for right, num in enumerate(arr):\\n            partial_sum += num\\n            while partial_sum > target:\\n                partial_sum -= arr[left]\\n                left += 1\\n            if partial_sum == target:\\n                curr_len = right - left + 1\\n                min_len = min(min_len, curr_len + min_so_far[left - 1])\\n                min_so_far[right] = min(curr_len, min_so_far[right - 1])\\n            else:\\n                min_so_far[right] = min_so_far[right - 1]\\n        return min_len if min_len < float(\\'inf\\') else -1\\n",
                "codeTag": "Java"
            },
            {
                "id": 2074925,
                "title": "python3-dp",
                "content": "```class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        def getDP(a):\\n            dp = [math.inf for _ in range(len(a))]\\n            store = defaultdict(int)\\n            for i, val in enumerate(itertools.accumulate(a)):\\n                if val == target:\\n                    dp[i] = i - 0 + 1\\n                elif val - target in store:\\n                    dp[i] = i - store[val-target]\\n                dp[i] = min(dp[i],dp[i-1])\\n                store[val] = i\\n            return dp\\n        left = getDP(arr)\\n        right = getDP(arr[::-1])[::-1]\\n        ret = math.inf\\n        for i in range(1, len(arr)):\\n            ret = min(ret, left[i-1] + right[i])\\n        return ret if ret != math.inf else -1\\n        \\n",
                "solutionTags": [],
                "code": "```class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        def getDP(a):\\n            dp = [math.inf for _ in range(len(a))]\\n            store = defaultdict(int)\\n            for i, val in enumerate(itertools.accumulate(a)):\\n                if val == target:\\n                    dp[i] = i - 0 + 1\\n                elif val - target in store:\\n                    dp[i] = i - store[val-target]\\n                dp[i] = min(dp[i],dp[i-1])\\n                store[val] = i\\n            return dp\\n        left = getDP(arr)\\n        right = getDP(arr[::-1])[::-1]\\n        ret = math.inf\\n        for i in range(1, len(arr)):\\n            ret = min(ret, left[i-1] + right[i])\\n        return ret if ret != math.inf else -1\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2012654,
                "title": "c-cumulative-property",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        [1   8]\\n        \\n        list of segment pairs which make target values[{1 3} {2 2} {6, 7} {6, 8}]\\n        \\n        [0] = inf                          = 1\\n        [1] = 3 {1, 3} = 1                 = 1\\n        [2] = 1 {2, 2}                     = 1\\n        [3] = inf                          = 2\\n        [4] = inf                          = 2\\n        [5] = inf                          = 2\\n        [6] = min(3 {6, 8} , 2 {6, 7}) = 2 = 2\\n        [7] = inf                          = inf\\n        [8] = inf                          = inf\\n        \\n    */\\n    #define inf 0x3f3f3f3f\\n    \\n    int non_overlapping_min_sub_array_len_from_index[100001];\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        memset(non_overlapping_min_sub_array_len_from_index, inf, sizeof non_overlapping_min_sub_array_len_from_index);\\n        vector <pair<int, int>> targetMakingPairs;\\n        int lf = 0, sum = 0;\\n        for (int rt = 0; rt < arr.size(); rt++) {\\n            sum += arr[rt];\\n            while(sum > target) {\\n                sum -= arr[lf++];\\n            }\\n            if (sum == target) {\\n                targetMakingPairs.push_back({lf, rt});\\n                non_overlapping_min_sub_array_len_from_index[lf] = min(non_overlapping_min_sub_array_len_from_index[lf], rt - lf + 1);\\n            }\\n        }\\n        \\n        if (targetMakingPairs.size() < 2) return -1;\\n        \\n        for (int index = arr.size() - 1; index >= 0; index--) {\\n            non_overlapping_min_sub_array_len_from_index[index] = min(non_overlapping_min_sub_array_len_from_index[index], non_overlapping_min_sub_array_len_from_index[index + 1]);\\n        }\\n\\n        \\n        int result = inf;\\n        for (int pair_id = 0; pair_id < targetMakingPairs.size(); pair_id++) {\\n            result = min(result, targetMakingPairs[pair_id].second - targetMakingPairs[pair_id].first + 1 + non_overlapping_min_sub_array_len_from_index[ targetMakingPairs[pair_id].second + 1 ]);\\n        }\\n        \\n        return result == inf ? -1 : result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        [1   8]\\n        \\n        list of segment pairs which make target values[{1 3} {2 2} {6, 7} {6, 8}]\\n        \\n        [0] = inf                          = 1\\n        [1] = 3 {1, 3} = 1                 = 1\\n        [2] = 1 {2, 2}                     = 1\\n        [3] = inf                          = 2\\n        [4] = inf                          = 2\\n        [5] = inf                          = 2\\n        [6] = min(3 {6, 8} , 2 {6, 7}) = 2 = 2\\n        [7] = inf                          = inf\\n        [8] = inf                          = inf\\n        \\n    */\\n    #define inf 0x3f3f3f3f\\n    \\n    int non_overlapping_min_sub_array_len_from_index[100001];\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        memset(non_overlapping_min_sub_array_len_from_index, inf, sizeof non_overlapping_min_sub_array_len_from_index);\\n        vector <pair<int, int>> targetMakingPairs;\\n        int lf = 0, sum = 0;\\n        for (int rt = 0; rt < arr.size(); rt++) {\\n            sum += arr[rt];\\n            while(sum > target) {\\n                sum -= arr[lf++];\\n            }\\n            if (sum == target) {\\n                targetMakingPairs.push_back({lf, rt});\\n                non_overlapping_min_sub_array_len_from_index[lf] = min(non_overlapping_min_sub_array_len_from_index[lf], rt - lf + 1);\\n            }\\n        }\\n        \\n        if (targetMakingPairs.size() < 2) return -1;\\n        \\n        for (int index = arr.size() - 1; index >= 0; index--) {\\n            non_overlapping_min_sub_array_len_from_index[index] = min(non_overlapping_min_sub_array_len_from_index[index], non_overlapping_min_sub_array_len_from_index[index + 1]);\\n        }\\n\\n        \\n        int result = inf;\\n        for (int pair_id = 0; pair_id < targetMakingPairs.size(); pair_id++) {\\n            result = min(result, targetMakingPairs[pair_id].second - targetMakingPairs[pair_id].first + 1 + non_overlapping_min_sub_array_len_from_index[ targetMakingPairs[pair_id].second + 1 ]);\\n        }\\n        \\n        return result == inf ? -1 : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966883,
                "title": "c-detailed-explanation-dp-clean-concise",
                "content": "# ****Intuition:\\n\\n## We are taking the res variable for storing the min sum of the possibility of  the size of the window .\\n\\n## In the dp array we will store the min length of the possibility of the window .\\n## \\tIF dp[start-1]==INT_MAX , this is the 1st one window which is found , previously there does not exist any window of target . \\n\\n## we storing in the dp[end]=len , to check there exist the any window previously of value target .\\n\\n# ****IF FIND THIS SOLUTION HELPFUL , PLEASE UPVOTE !!!\\n\\n```\\n int minSumOfLengths(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        \\n        int start=0;\\n        \\n        int  res=INT_MAX;\\n        vector<int> dp(n , INT_MAX);\\n        \\n        int len=INT_MAX , curr_len;\\n        \\n        int sum=0;\\n        \\n        for(int end=0;end<n;end++)\\n        {\\n            sum+=nums[end];\\n            \\n            while(sum>target)\\n            {\\n                sum-=nums[start];\\n                start++;\\n            }\\n            \\n            if(sum==target)\\n            {\\n                curr_len=(end-start+1);\\n                \\n                if(start>0 && dp[start-1]!=INT_MAX) // checking  for  the pair existent of 2 \\n                {\\n                    res=min(res , dp[start-1] + curr_len);\\n                }\\n                \\n                len=min(len , curr_len);\\n                \\n                // update the minlength and store in dp array s.t at least one target exist \\n                \\n                \\n                    \\n            }\\n            \\n            dp[end]=len;\\n            \\n        }\\n        \\n        if(res==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        \\n        return res;\\n            \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n int minSumOfLengths(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        \\n        int start=0;\\n        \\n        int  res=INT_MAX;\\n        vector<int> dp(n , INT_MAX);\\n        \\n        int len=INT_MAX , curr_len;\\n        \\n        int sum=0;\\n        \\n        for(int end=0;end<n;end++)\\n        {\\n            sum+=nums[end];\\n            \\n            while(sum>target)\\n            {\\n                sum-=nums[start];\\n                start++;\\n            }\\n            \\n            if(sum==target)\\n            {\\n                curr_len=(end-start+1);\\n                \\n                if(start>0 && dp[start-1]!=INT_MAX) // checking  for  the pair existent of 2 \\n                {\\n                    res=min(res , dp[start-1] + curr_len);\\n                }\\n                \\n                len=min(len , curr_len);\\n                \\n                // update the minlength and store in dp array s.t at least one target exist \\n                \\n                \\n                    \\n            }\\n            \\n            dp[end]=len;\\n            \\n        }\\n        \\n        if(res==INT_MAX)\\n        {\\n            return -1;\\n        }\\n        \\n        return res;\\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1950171,
                "title": "java-two-pointer-one-iteration-one-temporary-array",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {       \\n        int[] left = new int[arr.length+2];\\n        Arrays.fill(left, Integer.MAX_VALUE/2);\\n        \\n        int start = 0;\\n        int end = 0;\\n        int sum = 0;\\n        int result = Integer.MAX_VALUE/2;\\n        while(end < arr.length || sum > target){\\n            if(sum < target){\\n                sum+=arr[end++];\\n            } else {\\n                sum-=arr[start++];\\n            }\\n            if(sum == target){\\n                int len = end - start;\\n                left[end+1] = len;\\n                result = Math.min(result, len + left[start+1]);\\n            }\\n            left[end+1] = Math.min(left[end],left[end+1]);\\n        }\\n        return result == Integer.MAX_VALUE/2 ? -1 : result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {       \\n        int[] left = new int[arr.length+2];\\n        Arrays.fill(left, Integer.MAX_VALUE/2);\\n        \\n        int start = 0;\\n        int end = 0;\\n        int sum = 0;\\n        int result = Integer.MAX_VALUE/2;\\n        while(end < arr.length || sum > target){\\n            if(sum < target){\\n                sum+=arr[end++];\\n            } else {\\n                sum-=arr[start++];\\n            }\\n            if(sum == target){\\n                int len = end - start;\\n                left[end+1] = len;\\n                result = Math.min(result, len + left[start+1]);\\n            }\\n            left[end+1] = Math.min(left[end],left[end+1]);\\n        }\\n        return result == Integer.MAX_VALUE/2 ? -1 : result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861330,
                "title": "prefix-sum-and-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        vector<int> pref(n,INT_MAX),suff(n,INT_MAX);\\n        int j=0,s=0;\\n        for(int i=0;i<n;i++){\\n            s+=arr[i];\\n            while(j<=i && s>target){\\n                s-=arr[j];\\n                j++;\\n            }\\n            if(s==target){\\n                if(i==0){\\n                    pref[i]=(i-j+1);\\n                    continue;\\n                }\\n                pref[i]=min(pref[i-1],i-j+1);\\n            }else{\\n                if(i!=0)\\n                pref[i]=pref[i-1];\\n            }\\n        }\\n        j=n-1,s=0;\\n        for(int i=n-2;i>=0;i--){\\n            s+=arr[i+1];\\n            while(j>i && s>target){\\n                s-=arr[j];\\n                j--;\\n            }\\n            if(s==target){\\n                suff[i]=min(suff[i+1],j-i);\\n            }else{\\n                suff[i]=suff[i+1];\\n            }\\n        }\\n        int minl=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(pref[i]!=INT_MAX && suff[i]!=INT_MAX)\\n             minl=min(minl,pref[i]+suff[i]);\\n        }\\n        return minl==INT_MAX?-1:minl;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        vector<int> pref(n,INT_MAX),suff(n,INT_MAX);\\n        int j=0,s=0;\\n        for(int i=0;i<n;i++){\\n            s+=arr[i];\\n            while(j<=i && s>target){\\n                s-=arr[j];\\n                j++;\\n            }\\n            if(s==target){\\n                if(i==0){\\n                    pref[i]=(i-j+1);\\n                    continue;\\n                }\\n                pref[i]=min(pref[i-1],i-j+1);\\n            }else{\\n                if(i!=0)\\n                pref[i]=pref[i-1];\\n            }\\n        }\\n        j=n-1,s=0;\\n        for(int i=n-2;i>=0;i--){\\n            s+=arr[i+1];\\n            while(j>i && s>target){\\n                s-=arr[j];\\n                j--;\\n            }\\n            if(s==target){\\n                suff[i]=min(suff[i+1],j-i);\\n            }else{\\n                suff[i]=suff[i+1];\\n            }\\n        }\\n        int minl=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(pref[i]!=INT_MAX && suff[i]!=INT_MAX)\\n             minl=min(minl,pref[i]+suff[i]);\\n        }\\n        return minl==INT_MAX?-1:minl;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777583,
                "title": "concise-java-solution",
                "content": "```\\nclass Solution {\\n   public int minSumOfLengths(int[] arr, int target) {\\n       int n = arr.length;\\n       \\n       //best is used to store the length of shortest sub-array with total sum of target up to i inclusively\\n       int best[] = new int[n];\\n       \\n       //initialize the best array\\n       Arrays.fill(best, Integer.MAX_VALUE);\\n       \\n       //for prefix sum\\n       int sum = 0;\\n       \\n       //the starting index of the sliding window\\n       int start = 0;\\n       \\n       //ans is to stored the result\\n       int ans = Integer.MAX_VALUE;\\n       \\n       //bestSoFar is the length of shortest sub-array with total sum of target across arr\\n       int bestSoFar = Integer.MAX_VALUE;\\n       \\n       //i is the ending index of the sliding window\\n       for(int i = 0; i < n; i++){\\n           //calculate the prefix sum up to i\\n           sum += arr[i];\\n           \\n           //move the start to the left while sum > target\\n           while(sum > target){\\n               sum -= arr[start];\\n               start++;\\n           }\\n           if(sum == target){\\n               //the current sliding window is not the first window with the sum of target\\n               if(start > 0 && best[start - 1] != Integer.MAX_VALUE){\\n                    //current sliding window has the length of i - start + 1\\n                    //previous shortest sliding window has the length of best[start - 1]\\n                   ans = Math.min(ans, best[start - 1] + i - start + 1);\\n               }\\n               //to get the shortest length up to i\\n               bestSoFar = Math.min(bestSoFar, i - start + 1);\\n           }\\n           best[i] = bestSoFar;\\n       }\\n       return ans == Integer.MAX_VALUE ? -1 : ans;\\n   }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n   public int minSumOfLengths(int[] arr, int target) {\\n       int n = arr.length;\\n       \\n       //best is used to store the length of shortest sub-array with total sum of target up to i inclusively\\n       int best[] = new int[n];\\n       \\n       //initialize the best array\\n       Arrays.fill(best, Integer.MAX_VALUE);\\n       \\n       //for prefix sum\\n       int sum = 0;\\n       \\n       //the starting index of the sliding window\\n       int start = 0;\\n       \\n       //ans is to stored the result\\n       int ans = Integer.MAX_VALUE;\\n       \\n       //bestSoFar is the length of shortest sub-array with total sum of target across arr\\n       int bestSoFar = Integer.MAX_VALUE;\\n       \\n       //i is the ending index of the sliding window\\n       for(int i = 0; i < n; i++){\\n           //calculate the prefix sum up to i\\n           sum += arr[i];\\n           \\n           //move the start to the left while sum > target\\n           while(sum > target){\\n               sum -= arr[start];\\n               start++;\\n           }\\n           if(sum == target){\\n               //the current sliding window is not the first window with the sum of target\\n               if(start > 0 && best[start - 1] != Integer.MAX_VALUE){\\n                    //current sliding window has the length of i - start + 1\\n                    //previous shortest sliding window has the length of best[start - 1]\\n                   ans = Math.min(ans, best[start - 1] + i - start + 1);\\n               }\\n               //to get the shortest length up to i\\n               bestSoFar = Math.min(bestSoFar, i - start + 1);\\n           }\\n           best[i] = bestSoFar;\\n       }\\n       return ans == Integer.MAX_VALUE ? -1 : ans;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763686,
                "title": "c-two-methods-prefix-and-suffix-arrays-and-prefix-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MAX;\\n        int best_so_far = INT_MAX;\\n        vector<int> left(n + 1, INT_MAX), right(n, INT_MAX);\\n        int i = 0, pref = 0;\\n        for(int j=0; j<n; j++) {\\n            pref += nums[j];\\n            while(pref > k) {\\n                pref -= nums[i++];\\n            }\\n            if(pref == k) {\\n                best_so_far = min(best_so_far, j - i + 1);\\n            }\\n            left[j+1] = best_so_far;\\n        }\\n        i = n-1; best_so_far = INT_MAX;\\n        int suff = 0;\\n        for(int j=n-1; j>=0; j--) {\\n            suff += nums[j];\\n            while(suff > k) {\\n                suff -= nums[i--];\\n            }\\n            if(suff == k) {\\n                best_so_far = min(best_so_far, i - j + 1);\\n            }\\n            right[j] = best_so_far;\\n        }\\n        for(int i=0; i<n; i++) {\\n            res = min((long)res, (long)left[i] + right[i]);\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```\\nDP and prefix\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MAX;\\n        int pref = 0, best_so_far = INT_MAX;\\n        vector<int> dp(n, INT_MAX);\\n        int i = 0;\\n        for(int j=0; j<n; j++) {\\n            pref += nums[j];\\n            while(pref > k) {\\n                pref -= nums[i++];\\n            }\\n            if(pref == k) {\\n                if(i > 0 && dp[i-1] != INT_MAX)\\n                    res = min(res, dp[i-1] + j-i+1);\\n                best_so_far = min(best_so_far, j - i + 1);\\n            }\\n            dp[j] = best_so_far;\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MAX;\\n        int best_so_far = INT_MAX;\\n        vector<int> left(n + 1, INT_MAX), right(n, INT_MAX);\\n        int i = 0, pref = 0;\\n        for(int j=0; j<n; j++) {\\n            pref += nums[j];\\n            while(pref > k) {\\n                pref -= nums[i++];\\n            }\\n            if(pref == k) {\\n                best_so_far = min(best_so_far, j - i + 1);\\n            }\\n            left[j+1] = best_so_far;\\n        }\\n        i = n-1; best_so_far = INT_MAX;\\n        int suff = 0;\\n        for(int j=n-1; j>=0; j--) {\\n            suff += nums[j];\\n            while(suff > k) {\\n                suff -= nums[i--];\\n            }\\n            if(suff == k) {\\n                best_so_far = min(best_so_far, i - j + 1);\\n            }\\n            right[j] = best_so_far;\\n        }\\n        for(int i=0; i<n; i++) {\\n            res = min((long)res, (long)left[i] + right[i]);\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& nums, int k) {\\n        int n = nums.size(), res = INT_MAX;\\n        int pref = 0, best_so_far = INT_MAX;\\n        vector<int> dp(n, INT_MAX);\\n        int i = 0;\\n        for(int j=0; j<n; j++) {\\n            pref += nums[j];\\n            while(pref > k) {\\n                pref -= nums[i++];\\n            }\\n            if(pref == k) {\\n                if(i > 0 && dp[i-1] != INT_MAX)\\n                    res = min(res, dp[i-1] + j-i+1);\\n                best_so_far = min(best_so_far, j - i + 1);\\n            }\\n            dp[j] = best_so_far;\\n        }\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739654,
                "title": "prefix-minimum-array-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self,a,k):\\n        d=[]\\n        s=0\\n        a1={}\\n        for i in range(len(a)):\\n            s+=a[i]\\n            if s==k:\\n                d.append([0,i])\\n            elif s-k in a1:\\n                d.append([a1[s-k]+1,i])\\n            a1[s]=i\\n        if len(d)==0:\\n            return -1\\n        e=[]\\n        for i in range(len(d)):\\n            e.append(d[i][1]-d[i][0]+1)\\n        f=[]\\n        h=e[0]\\n        for i in range(len(e)):\\n            h=min(h,e[i])\\n            f.append(h)\\n        o=-1\\n        for i in range(1,len(d)):\\n            i1=0\\n            j1=i-1\\n            p=-1\\n            while(i1<=j1):\\n                mid=(i1+j1)//2\\n                if d[mid][1]>=d[i][0]:\\n                    j1=mid-1\\n                else:\\n                    p=mid\\n                    i1=mid+1\\n            if p!=-1:\\n                if o==-1:\\n                    o=e[i]+f[p]\\n                else:\\n                    o=min(o,e[i]+f[p])\\n        return o",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "class Solution:\\n    def minSumOfLengths(self,a,k):\\n        d=[]\\n        s=0\\n        a1={}",
                "codeTag": "Java"
            },
            {
                "id": 1673372,
                "title": "combination-of-sliding-window-suffix-sum-and-binary-search",
                "content": "```\\nint minSumOfLengths(vector<int>& arr, int target) {\\n        vector<vector<int>> indices;\\n        int si=0,ei=0,count=0;\\n\\t\\t//using count to store the current sum of values b/w si and ei (both inclusive)\\n        for(;ei < arr.size();ei++){\\n            count+=arr[ei];\\n            while(si <= ei && count > target){\\n                count-=arr[si++];\\n            }\\n            if(count == target){\\n\\t\\t\\t//found a match, so save the indices\\n                indices.push_back({si,ei});\\n                count-=arr[si++];\\n            }\\n        }\\n\\t\\t//storing the length of the minimum subarray so far from the right side in the suffix array\\n        vector<int> suffix(indices.size(),1e9);\\n        int mins=1e9;\\n        for(int i=indices.size()-1;i>-1;i--){\\n            suffix[i] = min(mins,indices[i][1]-indices[i][0]+1);\\n            mins = suffix[i];\\n        }\\n        int ans=1e9;\\n        if(indices.size() == 0)return -1;\\n        for(int i=0;i<indices.size()-1;i++){\\n\\t\\t//for every subarray look for the minimum length subarray towards its right side. \\n\\t\\t//Binary search the subarray with the minimum starting index but not overlapping with the current subarray. \\n\\t\\t//Use the value corresponding to that subarray in the suffix sum as it will be the minimum value.\\n\\t\\t//Keep updating the answer.\\n            int a = binary(indices, i+1,indices.size()-1,indices[i][1],suffix);\\n            if(a!=-1){\\n                ans = min(ans, a + indices[i][1]-indices[i][0]+1 );\\n            }\\n        }\\n        if(ans!=1e9)return ans;\\n        return -1;\\n    }\\n    \\n    int binary(vector<vector<int>>& indices, int si,int ei,int target,vector<int>& suffix){\\n        int ans=-1;\\n        while(si <= ei){\\n            int mid = si + (ei - si)/2;\\n            if(indices[mid][0] > target){\\n                ans = suffix[mid];\\n                ei = mid-1;\\n            }else{\\n                si = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Sliding Window"
                ],
                "code": "```\\nint minSumOfLengths(vector<int>& arr, int target) {\\n        vector<vector<int>> indices;\\n        int si=0,ei=0,count=0;\\n\\t\\t//using count to store the current sum of values b/w si and ei (both inclusive)\\n        for(;ei < arr.size();ei++){\\n            count+=arr[ei];\\n            while(si <= ei && count > target){\\n                count-=arr[si++];\\n            }\\n            if(count == target){\\n\\t\\t\\t//found a match, so save the indices\\n                indices.push_back({si,ei});\\n                count-=arr[si++];\\n            }\\n        }\\n\\t\\t//storing the length of the minimum subarray so far from the right side in the suffix array\\n        vector<int> suffix(indices.size(),1e9);\\n        int mins=1e9;\\n        for(int i=indices.size()-1;i>-1;i--){\\n            suffix[i] = min(mins,indices[i][1]-indices[i][0]+1);\\n            mins = suffix[i];\\n        }\\n        int ans=1e9;\\n        if(indices.size() == 0)return -1;\\n        for(int i=0;i<indices.size()-1;i++){\\n\\t\\t//for every subarray look for the minimum length subarray towards its right side. \\n\\t\\t//Binary search the subarray with the minimum starting index but not overlapping with the current subarray. \\n\\t\\t//Use the value corresponding to that subarray in the suffix sum as it will be the minimum value.\\n\\t\\t//Keep updating the answer.\\n            int a = binary(indices, i+1,indices.size()-1,indices[i][1],suffix);\\n            if(a!=-1){\\n                ans = min(ans, a + indices[i][1]-indices[i][0]+1 );\\n            }\\n        }\\n        if(ans!=1e9)return ans;\\n        return -1;\\n    }\\n    \\n    int binary(vector<vector<int>>& indices, int si,int ei,int target,vector<int>& suffix){\\n        int ans=-1;\\n        while(si <= ei){\\n            int mid = si + (ei - si)/2;\\n            if(indices[mid][0] > target){\\n                ans = suffix[mid];\\n                ei = mid-1;\\n            }else{\\n                si = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1493242,
                "title": "javascript-clean-elegant-o-n-solution-with-comments-faster-than-86",
                "content": "Sliding window solution. `start` is the index of the first element of window. `end` is the index of the last element of window.\\n\\n```\\nconst minSumOfLengths = (arr, target) => {\\n    const minLenSoFar = [];\\n    let start = 0,\\n        sum = 0,\\n        minLen = Infinity,\\n        output = Infinity;\\n    \\n    // Find best solution for each end of window. Save best solution to minLenSoFar[end].\\n    for (let end = 0; end < arr.length; end++) {\\n        sum += arr[end];\\n        \\n        // Keep increasing window start index as long as we are above target\\n        while (sum > target) {\\n            sum -= arr[start];\\n            start++;\\n        }\\n        \\n        if (sum === target) {\\n            const len = end - start + 1;\\n            minLen = Math.min(len, minLen);\\n            if (start > 0) {\\n                const minSumForThisIndex = minLenSoFar[start - 1] + len;\\n                output = Math.min(output, minSumForThisIndex);\\n            }\\n        }\\n\\n        minLenSoFar[end] = minLen;\\n    }\\n\\n    return output === Infinity ? -1 : output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst minSumOfLengths = (arr, target) => {\\n    const minLenSoFar = [];\\n    let start = 0,\\n        sum = 0,\\n        minLen = Infinity,\\n        output = Infinity;\\n    \\n    // Find best solution for each end of window. Save best solution to minLenSoFar[end].\\n    for (let end = 0; end < arr.length; end++) {\\n        sum += arr[end];\\n        \\n        // Keep increasing window start index as long as we are above target\\n        while (sum > target) {\\n            sum -= arr[start];\\n            start++;\\n        }\\n        \\n        if (sum === target) {\\n            const len = end - start + 1;\\n            minLen = Math.min(len, minLen);\\n            if (start > 0) {\\n                const minSumForThisIndex = minLenSoFar[start - 1] + len;\\n                output = Math.min(output, minSumForThisIndex);\\n            }\\n        }\\n\\n        minLenSoFar[end] = minLen;\\n    }\\n\\n    return output === Infinity ? -1 : output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1419143,
                "title": "o-1-space-double-sliding-window",
                "content": "```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        i1, j1, i2, sum1, sum2, min1, min12 = 0, 0, 0, 0, 0, math.inf, math.inf\\n        for j2 in range(n):\\n            sum2 += arr[j2]\\n            while sum2 > target:\\n                sum2 -= arr[i2]\\n                i2 += 1\\n            if sum2 == target:\\n                while j1 < i2:\\n                    sum1 += arr[j1]\\n                    while sum1 > target:\\n                        sum1 -= arr[i1]\\n                        i1 += 1\\n                    if sum1 == target:\\n                        min1 = min(min1, j1 - i1 + 1)\\n                    j1 += 1\\n                min12 = min(min12, min1 + j2 - i2 + 1)\\n        return min12 if min12 < math.inf else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        n = len(arr)\\n        i1, j1, i2, sum1, sum2, min1, min12 = 0, 0, 0, 0, 0, math.inf, math.inf\\n        for j2 in range(n):\\n            sum2 += arr[j2]\\n            while sum2 > target:\\n                sum2 -= arr[i2]\\n                i2 += 1\\n            if sum2 == target:\\n                while j1 < i2:\\n                    sum1 += arr[j1]\\n                    while sum1 > target:\\n                        sum1 -= arr[i1]\\n                        i1 += 1\\n                    if sum1 == target:\\n                        min1 = min(min1, j1 - i1 + 1)\\n                    j1 += 1\\n                min12 = min(min12, min1 + j2 - i2 + 1)\\n        return min12 if min12 < math.inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367462,
                "title": "python3-sliding-window",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        best_at_idx = defaultdict(lambda:float(\\'inf\\'))\\n        n = len(arr)\\n        i,j = 0, 0\\n        curr_sum = 0\\n        curr_best = float(\\'inf\\')\\n        ans = float(\\'inf\\')\\n        while j < n:\\n            curr_sum += arr[j]\\n            \\n            while curr_sum > target:\\n                curr_sum -= arr[i]\\n                i += 1\\n                \\n            if curr_sum == target:\\n                ans = min(ans,best_at_idx[i - 1] + j - i + 1)\\n                curr_best = min(curr_best,j - i + 1)\\n            \\n            best_at_idx[j] = curr_best\\n            j += 1\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        best_at_idx = defaultdict(lambda:float(\\'inf\\'))\\n        n = len(arr)\\n        i,j = 0, 0\\n        curr_sum = 0\\n        curr_best = float(\\'inf\\')\\n        ans = float(\\'inf\\')\\n        while j < n:\\n            curr_sum += arr[j]\\n            \\n            while curr_sum > target:\\n                curr_sum -= arr[i]\\n                i += 1\\n                \\n            if curr_sum == target:\\n                ans = min(ans,best_at_idx[i - 1] + j - i + 1)\\n                curr_best = min(curr_best,j - i + 1)\\n            \\n            best_at_idx[j] = curr_best\\n            j += 1\\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237544,
                "title": "c-prefix-and-suffix-arrays-sliding-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        vector<int>prefix(n+1,INT_MAX);\\n        vector<int>suffix(n,INT_MAX);\\n        int i=0,j=0,sum=0;\\n        while(j<n)\\n        {\\n            sum+=arr[j++];\\n            while(sum>k)\\n            {\\n                sum-=arr[i++];\\n            }\\n            if(sum==k)\\n            {\\n                prefix[j]=min(prefix[j],j-i);\\n            }\\n        }\\n        j=n-1,i=n-1,sum=0;\\n        while(j>=0)\\n        {\\n            sum+=arr[j--];\\n            while(sum>k)\\n            {\\n                sum-=arr[i--];\\n            }\\n            if(sum==k)\\n            {\\n                suffix[j+1]=min(suffix[j+1],i-j);\\n            }\\n        }\\n        int res=INT_MAX;\\n        for(int i=1;i<=n;i++)\\n            prefix[i]=min(prefix[i],prefix[i-1]);\\n        for(int j=n-2;j>=0;j--)\\n            suffix[j]=min(suffix[j+1],suffix[j]);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(prefix[i]!=INT_MAX && suffix[i]!=INT_MAX)\\n            {\\n                res=min(res,prefix[i]+suffix[i]);\\n            }\\n        }\\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int k) \\n    {\\n        int n=arr.size();\\n        vector<int>prefix(n+1,INT_MAX);\\n        vector<int>suffix(n,INT_MAX);\\n        int i=0,j=0,sum=0;\\n        while(j<n)\\n        {\\n            sum+=arr[j++];\\n            while(sum>k)\\n            {\\n                sum-=arr[i++];\\n            }\\n            if(sum==k)\\n            {\\n                prefix[j]=min(prefix[j],j-i);\\n            }\\n        }\\n        j=n-1,i=n-1,sum=0;\\n        while(j>=0)\\n        {\\n            sum+=arr[j--];\\n            while(sum>k)\\n            {\\n                sum-=arr[i--];\\n            }\\n            if(sum==k)\\n            {\\n                suffix[j+1]=min(suffix[j+1],i-j);\\n            }\\n        }\\n        int res=INT_MAX;\\n        for(int i=1;i<=n;i++)\\n            prefix[i]=min(prefix[i],prefix[i-1]);\\n        for(int j=n-2;j>=0;j--)\\n            suffix[j]=min(suffix[j+1],suffix[j]);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(prefix[i]!=INT_MAX && suffix[i]!=INT_MAX)\\n            {\\n                res=min(res,prefix[i]+suffix[i]);\\n            }\\n        }\\n        return res==INT_MAX?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207937,
                "title": "c-solution-dynammic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> prefix(n, INF);\\n        int sum = 0;\\n        unordered_map<int, int> m;\\n        m[0] = -1;\\n        for(int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            if(m.find(sum - target) != m.end()) {\\n                prefix[i] = i - m[sum - target];\\n            }\\n            prefix[i] = min((i == 0 ? INF : prefix[i - 1]), prefix[i]);\\n            m[sum] = i;\\n        }\\n        sum = 0;\\n        m.clear();\\n        m[0] = n;\\n        vector<int> suffix(n, INF);\\n        for(int i = n - 1; i >= 0; i--) {\\n            sum += arr[i];\\n            if(m.find(sum - target) != m.end()) {\\n                suffix[i] = m[sum - target] - i;\\n            }\\n            suffix[i] = min((i == n - 1 ? INF : suffix[i + 1]), suffix[i]);\\n            m[sum] = i;\\n        }\\n        int ans = INF;\\n        for(int i = 0; i < n - 1; i++) {\\n            if(prefix[i] != INF && suffix[i + 1] != INF)\\n                ans = min(ans, prefix[i] + suffix[i + 1]);\\n        }\\n        return ans == INF ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<int> prefix(n, INF);\\n        int sum = 0;\\n        unordered_map<int, int> m;\\n        m[0] = -1;\\n        for(int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            if(m.find(sum - target) != m.end()) {\\n                prefix[i] = i - m[sum - target];\\n            }\\n            prefix[i] = min((i == 0 ? INF : prefix[i - 1]), prefix[i]);\\n            m[sum] = i;\\n        }\\n        sum = 0;\\n        m.clear();\\n        m[0] = n;\\n        vector<int> suffix(n, INF);\\n        for(int i = n - 1; i >= 0; i--) {\\n            sum += arr[i];\\n            if(m.find(sum - target) != m.end()) {\\n                suffix[i] = m[sum - target] - i;\\n            }\\n            suffix[i] = min((i == n - 1 ? INF : suffix[i + 1]), suffix[i]);\\n            m[sum] = i;\\n        }\\n        int ans = INF;\\n        for(int i = 0; i < n - 1; i++) {\\n            if(prefix[i] != INF && suffix[i + 1] != INF)\\n                ans = min(ans, prefix[i] + suffix[i + 1]);\\n        }\\n        return ans == INF ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1196566,
                "title": "python-dp-one-loop",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        prefix_sum = [0 for i in range(len(arr) + 1)]\\n        # the smallest interval that sum to target before position i\\n        shortest_interval = [len(arr) + 1 for i in range(len(arr) + 1)] \\n        sum_map = {0:0} # corresponding indices for prefix sum\\n        shortest = len(arr) + 1\\n        for i in range(len(arr)):\\n            prefix_sum[i + 1] = arr[i] if i == 0 else arr[i] + prefix_sum[i]\\n            sum_map[prefix_sum[i + 1]] = (i + 1)\\n            shortest_interval[i + 1] = shortest_interval[i]\\n            if (prefix_sum[i + 1] - target) in sum_map:\\n\\t\\t\\t\\t# only subarray indexed before sum_map[prefix_sum[i + 1] - target] cannot overlap\\n                last = sum_map[prefix_sum[i + 1] - target]\\n                shortest = min(shortest, shortest_interval[last] + (i + 1 - last))\\n                shortest_interval[i + 1] = min(shortest_interval[i + 1], (i + 1 - last))\\n                    \\n        return (shortest if shortest <= len(arr) else -1)",
                "solutionTags": [],
                "code": "class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        prefix_sum = [0 for i in range(len(arr) + 1)]\\n        # the smallest interval that sum to target before position i\\n        shortest_interval = [len(arr) + 1 for i in range(len(arr) + 1)] \\n        sum_map = {0:0}",
                "codeTag": "Java"
            },
            {
                "id": 1176973,
                "title": "java-o-n-using-hashmap-short-concise-prefix-and-suffix-based-on-hints",
                "content": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] reverseArr(int arr[]){\\n        int n=arr.length;\\n        int reverse[] = new int[n];\\n        for(int i=0;i<n;++i) reverse[i]=arr[n-i-1];\\n        return reverse;\\n    }\\n    public int[] minLengthArrayforEachIndexWithTargetSum(int[] arr, int target){\\n        int n=arr.length;\\n        int ans[] = new int[n];\\n        int prefixSum[] = new int[n]; \\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        for(int i=0;i<n;++i){\\n            prefixSum[i] = (i==0) ? arr[i] : prefixSum[i-1]+arr[i];\\n            int currentLength=n+1;\\n            if(map.containsKey(prefixSum[i]-target)) currentLength=i-map.get(prefixSum[i]-target);\\n            map.put(prefixSum[i], i);\\n            ans[i] = (i==0) ? currentLength : Math.min(currentLength, ans[i-1]);\\n        }\\n        return ans;\\n    }\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n=arr.length, ans=n+1;\\n        int []prefix = minLengthArrayforEachIndexWithTargetSum(arr, target);\\n        arr = reverseArr(arr);\\n        int []suffix = minLengthArrayforEachIndexWithTargetSum(arr, target);\\n        for(int i=0;i<n-1;i++) ans=Math.min(ans, prefix[i]+suffix[n-1-i-1]);\\n        return ans==n+1 ? -1 : ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] reverseArr(int arr[]){\\n        int n=arr.length;\\n        int reverse[] = new int[n];\\n        for(int i=0;i<n;++i) reverse[i]=arr[n-i-1];\\n        return reverse;\\n    }\\n    public int[] minLengthArrayforEachIndexWithTargetSum(int[] arr, int target){\\n        int n=arr.length;\\n        int ans[] = new int[n];\\n        int prefixSum[] = new int[n]; \\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        for(int i=0;i<n;++i){\\n            prefixSum[i] = (i==0) ? arr[i] : prefixSum[i-1]+arr[i];\\n            int currentLength=n+1;\\n            if(map.containsKey(prefixSum[i]-target)) currentLength=i-map.get(prefixSum[i]-target);\\n            map.put(prefixSum[i], i);\\n            ans[i] = (i==0) ? currentLength : Math.min(currentLength, ans[i-1]);\\n        }\\n        return ans;\\n    }\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n=arr.length, ans=n+1;\\n        int []prefix = minLengthArrayforEachIndexWithTargetSum(arr, target);\\n        arr = reverseArr(arr);\\n        int []suffix = minLengthArrayforEachIndexWithTargetSum(arr, target);\\n        for(int i=0;i<n-1;i++) ans=Math.min(ans, prefix[i]+suffix[n-1-i-1]);\\n        return ans==n+1 ? -1 : ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138652,
                "title": "c-sliding-window-no-hash-map-o-n",
                "content": "The idea is to keep 2 indices i and j as the starting point and end point of sliding window.\\nAlso we maintain an array which contain Min size of sliding window that is to left of index.\\n\\nFor indices i and j where the sum of the range == target\\nThe leftMin for index j is minimum of leftMin of j - 1 and current.\\nOur ans will be minimum of leftMin[i] + current.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) \\n    {\\n        vector<long long> leftMin(arr.size() + 1, numeric_limits<int>::max());\\n        int i = 0;\\n        int j = 0;\\n        \\n        long long sum = arr[0];\\n        long long ans = numeric_limits<int>::max();\\n        \\n        while (j < arr.size() )\\n        {\\n            if (sum == target)\\n            {\\n                long long current = j - i + 1;\\n                \\n                leftMin[j + 1] = min(leftMin[j], current);\\n                ans = min(ans, current + leftMin[i]);\\n                \\n                sum -= arr[i];\\n                ++i;\\n                if (++j < arr.size())\\n                    sum += arr[j];\\n            }\\n            else if (sum < target)\\n            {\\n                leftMin[j + 1] = min(leftMin[j], leftMin[j + 1]) ;\\n                if (++j < arr.size())\\n                    sum += arr[j];\\n            }\\n            else\\n            {\\n                sum -= arr[i];\\n                i++;\\n            }\\n        }\\n        \\n        if (ans >= numeric_limits<int>::max())\\n            return -1;\\n        return (int)ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) \\n    {\\n        vector<long long> leftMin(arr.size() + 1, numeric_limits<int>::max());\\n        int i = 0;\\n        int j = 0;\\n        \\n        long long sum = arr[0];\\n        long long ans = numeric_limits<int>::max();\\n        \\n        while (j < arr.size() )\\n        {\\n            if (sum == target)\\n            {\\n                long long current = j - i + 1;\\n                \\n                leftMin[j + 1] = min(leftMin[j], current);\\n                ans = min(ans, current + leftMin[i]);\\n                \\n                sum -= arr[i];\\n                ++i;\\n                if (++j < arr.size())\\n                    sum += arr[j];\\n            }\\n            else if (sum < target)\\n            {\\n                leftMin[j + 1] = min(leftMin[j], leftMin[j + 1]) ;\\n                if (++j < arr.size())\\n                    sum += arr[j];\\n            }\\n            else\\n            {\\n                sum -= arr[i];\\n                i++;\\n            }\\n        }\\n        \\n        if (ans >= numeric_limits<int>::max())\\n            return -1;\\n        return (int)ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1111388,
                "title": "python3-prefix-sum",
                "content": "\\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        ans = inf \\n        best = [inf]*len(arr) # shortest subarray ending at i\\n        prefix = 0\\n        latest = {0: -1}\\n        for i, x in enumerate(arr): \\n            prefix += x\\n            if prefix - target in latest: \\n                ii = latest[prefix - target]\\n                if ii >= 0: \\n                    ans = min(ans, i - ii + best[ii])\\n                best[i] = i - ii\\n            if i: best[i] = min(best[i-1], best[i])\\n            latest[prefix] = i \\n        return ans if ans < inf else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        ans = inf \\n        best = [inf]*len(arr) # shortest subarray ending at i\\n        prefix = 0\\n        latest = {0: -1}\\n        for i, x in enumerate(arr): \\n            prefix += x\\n            if prefix - target in latest: \\n                ii = latest[prefix - target]\\n                if ii >= 0: \\n                    ans = min(ans, i - ii + best[ii])\\n                best[i] = i - ii\\n            if i: best[i] = min(best[i-1], best[i])\\n            latest[prefix] = i \\n        return ans if ans < inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100124,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int i = 0;\\n        int sum = 0;\\n        int ans = Integer.MAX_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        int j = 0;\\n        int[] dp = new int[arr.length];\\n        \\n        while(j < arr.length){\\n            sum += arr[j];\\n            \\n            while(sum > target) sum -= arr[i++];\\n            \\n            if(sum == target){\\n                min = Math.min(min,j-i+1);\\n                if(i > 0 && dp[i-1] != Integer.MAX_VALUE) ans = Math.min(ans, dp[i-1]+(j-i+1));\\n            }\\n            dp[j] = min;\\n            j++;\\n        }\\n        return (ans == Integer.MAX_VALUE)? -1: ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int i = 0;\\n        int sum = 0;\\n        int ans = Integer.MAX_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        int j = 0;\\n        int[] dp = new int[arr.length];\\n        \\n        while(j < arr.length){\\n            sum += arr[j];\\n            \\n            while(sum > target) sum -= arr[i++];\\n            \\n            if(sum == target){\\n                min = Math.min(min,j-i+1);\\n                if(i > 0 && dp[i-1] != Integer.MAX_VALUE) ans = Math.min(ans, dp[i-1]+(j-i+1));\\n            }\\n            dp[j] = min;\\n            j++;\\n        }\\n        return (ans == Integer.MAX_VALUE)? -1: ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090534,
                "title": "javascript-dp-with-sliding-window-o-n-time",
                "content": "```javascript\\nvar minSumOfLengths = function(arr, target) {\\n    const dp = []\\n    let i = 0, j = 0, sum = 0;\\n    let minLen = Infinity;\\n    let output = Infinity;\\n    \\n    while(j < arr.length) {\\n        sum += arr[j];\\n        \\n        while(sum > target) sum -= arr[i++];\\n        \\n        if(sum === target) {\\n            const len = j - i + 1;\\n            minLen = Math.min(len, minLen);\\n            if(i > 0) output = Math.min(output, dp[i-1] + len)\\n        }\\n        dp[j] = minLen;\\n        j++\\n    }\\n    return output === Infinity ? -1 : output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```javascript\\nvar minSumOfLengths = function(arr, target) {\\n    const dp = []\\n    let i = 0, j = 0, sum = 0;\\n    let minLen = Infinity;\\n    let output = Infinity;\\n    \\n    while(j < arr.length) {\\n        sum += arr[j];\\n        \\n        while(sum > target) sum -= arr[i++];\\n        \\n        if(sum === target) {\\n            const len = j - i + 1;\\n            minLen = Math.min(len, minLen);\\n            if(i > 0) output = Math.min(output, dp[i-1] + len)\\n        }\\n        dp[j] = minLen;\\n        j++\\n    }\\n    return output === Infinity ? -1 : output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 963611,
                "title": "c-hashmap-dp-version",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n\\n        unordered_map<int, int> prefixsum_index; // prefixsum_index: key, prefixsum,  value: index\\n        vector<int> smallest_length;  // smallest_length: smallest_length[i] means, from 0 to i, current smallest length of subarray that sum == target, not find, == INT_MAX\\n        int res = INT_MAX; // sum of Two Non-overlapping Sub-arrays lengths (sum == target)\\n        \\n        smallest_length.push_back(INT_MAX);\\n        arr.insert(arr.begin(), 0); // handle edge case: subarray == target start from the first element\\n        \\n\\t\\t// start scan arr, \\n        // save current prefix sum and current index to map, prefixsum_index[curr_sum] = i;\\n        // set current smallest subarray length equal previous value first, smallest_length[i] = smallest_length[i -1]\\n        //      if curr sum - target exist in map, fins a subarray sum == target\\n        //      left_index = prefixsum_index[sum - target]\\n        //      new_length = i - left_index\\n        //      smallest_length[i] should be min(smallest_length[i], new_length)\\n        //      if smallest_length[left_index] not INT_MAX, which mean find target subarray before, update res\\n        //          new_res = smallest_length[left_index] + new_length;\\n        //          res = min(new_res, res)\\n        \\n        int curr_sum = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            curr_sum += arr[i];\\n            prefixsum_index[curr_sum] = i;\\n            if (i != 0) smallest_length.push_back(smallest_length[i-1]);\\n            int sum_target = curr_sum - target;\\n            \\n            if (prefixsum_index.find(sum_target) != prefixsum_index.end()) {\\n                int left_idx = prefixsum_index[sum_target];\\n                int new_len = i - left_idx;\\n                smallest_length[i] = min(smallest_length[i], new_len);\\n                \\n                if (smallest_length[left_idx] != INT_MAX) {\\n                    int new_res = new_len + smallest_length[left_idx];\\n                    res = min(res, new_res);\\n                }\\n                \\n            }  \\n        }\\n        if (res == INT_MAX) return -1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n\\n        unordered_map<int, int> prefixsum_index; // prefixsum_index: key, prefixsum,  value: index\\n        vector<int> smallest_length;  // smallest_length: smallest_length[i] means, from 0 to i, current smallest length of subarray that sum == target, not find, == INT_MAX\\n        int res = INT_MAX; // sum of Two Non-overlapping Sub-arrays lengths (sum == target)\\n        \\n        smallest_length.push_back(INT_MAX);\\n        arr.insert(arr.begin(), 0); // handle edge case: subarray == target start from the first element\\n        \\n\\t\\t// start scan arr, \\n        // save current prefix sum and current index to map, prefixsum_index[curr_sum] = i;\\n        // set current smallest subarray length equal previous value first, smallest_length[i] = smallest_length[i -1]\\n        //      if curr sum - target exist in map, fins a subarray sum == target\\n        //      left_index = prefixsum_index[sum - target]\\n        //      new_length = i - left_index\\n        //      smallest_length[i] should be min(smallest_length[i], new_length)\\n        //      if smallest_length[left_index] not INT_MAX, which mean find target subarray before, update res\\n        //          new_res = smallest_length[left_index] + new_length;\\n        //          res = min(new_res, res)\\n        \\n        int curr_sum = 0;\\n        for (int i = 0; i < arr.size(); i++) {\\n            curr_sum += arr[i];\\n            prefixsum_index[curr_sum] = i;\\n            if (i != 0) smallest_length.push_back(smallest_length[i-1]);\\n            int sum_target = curr_sum - target;\\n            \\n            if (prefixsum_index.find(sum_target) != prefixsum_index.end()) {\\n                int left_idx = prefixsum_index[sum_target];\\n                int new_len = i - left_idx;\\n                smallest_length[i] = min(smallest_length[i], new_len);\\n                \\n                if (smallest_length[left_idx] != INT_MAX) {\\n                    int new_res = new_len + smallest_length[left_idx];\\n                    res = min(res, new_res);\\n                }\\n                \\n            }  \\n        }\\n        if (res == INT_MAX) return -1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957983,
                "title": "java-solution-prefixsum-and-hashmap-two-passes",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int[] leftSum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            leftSum[i] = leftSum[i - 1] + arr[i - 1];\\n        }\\n        int[] rightSum = new int[n + 1];\\n        for (int i = n - 1; i >= 0; i--) {\\n            rightSum[i] = rightSum[i + 1] + arr[i];\\n        }\\n        int[] leftMins = new int[n + 1];\\n        int[] rightMins = new int[n + 1];\\n        int leftMin = Integer.MAX_VALUE / 2;\\n        int rightMin = Integer.MAX_VALUE / 2;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        // populate leftMins\\n        for (int i = 0; i <= n; i++) {\\n            if (map.containsKey(leftSum[i] - target)) {\\n                int len = i - map.get(leftSum[i] - target);\\n                if (len < leftMin) {\\n                    leftMin = len;\\n                }\\n            }\\n            leftMins[i] = leftMin;\\n            map.put(leftSum[i], i);\\n        }\\n        map.clear();\\n        // populate rightMins\\n        for (int i = n; i >= 0; i--) {\\n            if (map.containsKey(rightSum[i] - target)) {\\n                int len = map.get(rightSum[i] - target) - i;\\n                if (len < rightMin) {\\n                    rightMin = len;\\n                }\\n            }\\n            rightMins[i] = rightMin;\\n            map.put(rightSum[i], i);\\n        }\\n        // find answer\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i <= n; i++) {\\n            ans = Math.min(ans, leftMins[i] + rightMins[i]);\\n        }\\n        return ans > n ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length;\\n        int[] leftSum = new int[n + 1];\\n        for (int i = 1; i <= n; i++) {\\n            leftSum[i] = leftSum[i - 1] + arr[i - 1];\\n        }\\n        int[] rightSum = new int[n + 1];\\n        for (int i = n - 1; i >= 0; i--) {\\n            rightSum[i] = rightSum[i + 1] + arr[i];\\n        }\\n        int[] leftMins = new int[n + 1];\\n        int[] rightMins = new int[n + 1];\\n        int leftMin = Integer.MAX_VALUE / 2;\\n        int rightMin = Integer.MAX_VALUE / 2;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        // populate leftMins\\n        for (int i = 0; i <= n; i++) {\\n            if (map.containsKey(leftSum[i] - target)) {\\n                int len = i - map.get(leftSum[i] - target);\\n                if (len < leftMin) {\\n                    leftMin = len;\\n                }\\n            }\\n            leftMins[i] = leftMin;\\n            map.put(leftSum[i], i);\\n        }\\n        map.clear();\\n        // populate rightMins\\n        for (int i = n; i >= 0; i--) {\\n            if (map.containsKey(rightSum[i] - target)) {\\n                int len = map.get(rightSum[i] - target) - i;\\n                if (len < rightMin) {\\n                    rightMin = len;\\n                }\\n            }\\n            rightMins[i] = rightMin;\\n            map.put(rightSum[i], i);\\n        }\\n        // find answer\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i <= n; i++) {\\n            ans = Math.min(ans, leftMins[i] + rightMins[i]);\\n        }\\n        return ans > n ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954275,
                "title": "sliding-window-and-array-in-python",
                "content": "class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        if not arr: return 0\\n        n = len(arr)\\n        \\n        min_lens = [float(\\'inf\\')] * n\\n        \\n        ans = float(\\'inf\\')\\n        sum = 0\\n        s = 0\\n        min_len = float(\\'inf\\')\\n        \\n        for e in range(n):\\n            sum += arr[e]\\n            \\n            while sum > target:\\n                sum -= arr[s]\\n                s += 1\\n            if sum == target:\\n                cur_len = e - s + 1\\n                if s > 0 and min_lens[s-1] != float(\\'-inf\\'):\\n                    ans = min(ans, cur_len+min_lens[s-1])\\n                min_len = min(min_len, cur_len)\\n            min_lens[e] = min_len\\n            \\n        return -1 if ans >= float(\\'inf\\') else ans",
                "solutionTags": [],
                "code": "class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        if not arr: return 0\\n        n = len(arr)\\n        \\n        min_lens = [float(\\'inf\\')] * n\\n        \\n        ans = float(\\'inf\\')\\n        sum = 0\\n        s = 0\\n        min_len = float(\\'inf\\')\\n        \\n        for e in range(n):\\n            sum += arr[e]\\n            \\n            while sum > target:\\n                sum -= arr[s]\\n                s += 1\\n            if sum == target:\\n                cur_len = e - s + 1\\n                if s > 0 and min_lens[s-1] != float(\\'-inf\\'):\\n                    ans = min(ans, cur_len+min_lens[s-1])\\n                min_len = min(min_len, cur_len)\\n            min_lens[e] = min_len\\n            \\n        return -1 if ans >= float(\\'inf\\') else ans",
                "codeTag": "Java"
            },
            {
                "id": 934816,
                "title": "java-priorityqueue-solution-80ms-can-answer-tough-follow-up-of-printing-the-result-subarrays",
                "content": "When the question mentioned the shorted 2, I immediately thought about Priority queue :)\\nThis is not as fast as the sliding window solution, but if you want to know which 2 subarrays are in the result, this is the algorithm to pick.\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        PriorityQueue<SubArray> queue = new PriorityQueue<>();\\n        int lst = -2;\\n        int sum = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1); // Preparing work, the index here is the position one step before the starting subarray\\n        for(int i=0; i<arr.length; i++){\\n            sum+=arr[i]; // get the sum so far\\n            if(map.containsKey(sum-target) && map.get(sum-target)>lst){  \\n                // sum - (sum-target) = target, lst is the last matching starting index, if the result we get is less than lst, the resulting subarray will enclose that subarray, this for sure is not a optimal subarray\\n                int st = map.get(sum-target);\\n                int len = i-map.get(sum-target);\\n                queue.add(new SubArray(st+1, i, len));\\n                lst=st;\\n            }\\n            map.put(sum, i); // put the new sum into the map\\n        }\\n        if(queue.size()<2) return -1; // we need at least 2 subarray to have a solution\\n        List<SubArray> polled = new ArrayList<>(); // the first item in the queue is not necessarily in the result, we poll one at a time and find a valid combination\\n        while(!queue.isEmpty()){\\n            SubArray ano = queue.poll();\\n            for(int i=0; i<polled.size(); i++) {  // this for loop will only kick in starting from the second iteration of the outer while loop\\n                SubArray selected = polled.get(i); // the polled subarrayList is in ascending order, the first match we get will be the solution\\n                if(!selected.overlap(ano)){\\n                    return ano.len+selected.len;\\n                }\\n            }\\n            polled.add(ano);\\n        }\\n        return -1;\\n    }\\n    \\n    public class SubArray implements Comparable<SubArray>{\\n        int st;\\n        int en;\\n        int len;\\n        \\n        public SubArray(int st, int en, int len){\\n            this.st=st;\\n            this.en=en;\\n            this.len=len;\\n        }\\n        \\n        public int compareTo(SubArray ano) {\\n            return this.len - ano.len;\\n        }\\n        \\n        public boolean overlap(SubArray ano) {\\n            if(ano.st>this.en || ano.en<this.st) return false;\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        PriorityQueue<SubArray> queue = new PriorityQueue<>();\\n        int lst = -2;\\n        int sum = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1); // Preparing work, the index here is the position one step before the starting subarray\\n        for(int i=0; i<arr.length; i++){\\n            sum+=arr[i]; // get the sum so far\\n            if(map.containsKey(sum-target) && map.get(sum-target)>lst){  \\n                // sum - (sum-target) = target, lst is the last matching starting index, if the result we get is less than lst, the resulting subarray will enclose that subarray, this for sure is not a optimal subarray\\n                int st = map.get(sum-target);\\n                int len = i-map.get(sum-target);\\n                queue.add(new SubArray(st+1, i, len));\\n                lst=st;\\n            }\\n            map.put(sum, i); // put the new sum into the map\\n        }\\n        if(queue.size()<2) return -1; // we need at least 2 subarray to have a solution\\n        List<SubArray> polled = new ArrayList<>(); // the first item in the queue is not necessarily in the result, we poll one at a time and find a valid combination\\n        while(!queue.isEmpty()){\\n            SubArray ano = queue.poll();\\n            for(int i=0; i<polled.size(); i++) {  // this for loop will only kick in starting from the second iteration of the outer while loop\\n                SubArray selected = polled.get(i); // the polled subarrayList is in ascending order, the first match we get will be the solution\\n                if(!selected.overlap(ano)){\\n                    return ano.len+selected.len;\\n                }\\n            }\\n            polled.add(ano);\\n        }\\n        return -1;\\n    }\\n    \\n    public class SubArray implements Comparable<SubArray>{\\n        int st;\\n        int en;\\n        int len;\\n        \\n        public SubArray(int st, int en, int len){\\n            this.st=st;\\n            this.en=en;\\n            this.len=len;\\n        }\\n        \\n        public int compareTo(SubArray ano) {\\n            return this.len - ano.len;\\n        }\\n        \\n        public boolean overlap(SubArray ano) {\\n            if(ano.st>this.en || ano.en<this.st) return false;\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934525,
                "title": "dp-sliding-window-using-one-array-and-one-pass-98",
                "content": "Inspired by this [brilliant solution](https://leetcode.com/problems/find-two-non-overlapping-sub-arrays-each-with-target-sum/discuss/686105/JAVA-or-Sliding-window-with-only-one-array-or-No-HasMap). Beat 98% in time.\\n\\nNote that we only need to initialize the first result `dp[0]` as `Integer.MAX_VALUE`. Because every subsequent `dp[k]` is updated by the previous `dp[k-1]` and when new valid subarray is found.\\n\\n```java\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int len = arr.length;\\n        if (len < 2) {\\n            return -1;\\n        }\\n        int[] dp = new int[len];\\n        dp[0] = Integer.MAX_VALUE;\\n        int minLen = Integer.MAX_VALUE;\\n        for (int i = 0, j = 0, sum = 0; j < len; j++) {\\n            if (j > 0) {\\n                dp[j] = dp[j - 1];\\n            }\\n            sum += arr[j];\\n            while (sum > target) {\\n                sum -= arr[i++];\\n            }\\n            if (sum == target) {\\n                dp[j] = Math.min(j - i + 1, dp[j]);\\n                if (i > 0 && dp[i - 1] != Integer.MAX_VALUE) {\\n                    minLen = Math.min(j - i + 1 + dp[i - 1], minLen);\\n                }\\n                sum -= arr[i++];\\n            }\\n        }\\n        return minLen == Integer.MAX_VALUE ? -1 : minLen;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int len = arr.length;\\n        if (len < 2) {\\n            return -1;\\n        }\\n        int[] dp = new int[len];\\n        dp[0] = Integer.MAX_VALUE;\\n        int minLen = Integer.MAX_VALUE;\\n        for (int i = 0, j = 0, sum = 0; j < len; j++) {\\n            if (j > 0) {\\n                dp[j] = dp[j - 1];\\n            }\\n            sum += arr[j];\\n            while (sum > target) {\\n                sum -= arr[i++];\\n            }\\n            if (sum == target) {\\n                dp[j] = Math.min(j - i + 1, dp[j]);\\n                if (i > 0 && dp[i - 1] != Integer.MAX_VALUE) {\\n                    minLen = Math.min(j - i + 1 + dp[i - 1], minLen);\\n                }\\n                sum -= arr[i++];\\n            }\\n        }\\n        return minLen == Integer.MAX_VALUE ? -1 : minLen;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 897189,
                "title": "java-o-n-with-one-dp-array-explained",
                "content": "```\\nclass Solution {\\n    /*\\n     * Idea: Use sliding window to figure out subarrays that add up to target.\\n     *       As we go, we want to store in \"dp\" the length of the shortest \\n     *       subarray we\\'ve seen up to the current \"right\" index. Every time \\n     *       we find a new subarray, we add its length to the length of the\\n     *       shortest non-overlapping subarray to its left (i.e. dp[left - 1]. \\n     *       We will try to minimize this computation as we go (variable\\n     *       \"result\").\\n     */\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int left = 0;\\n        int sum = 0;\\n        int dp[] = new int[arr.length];\\n        int result = Integer.MAX_VALUE;\\n        \\n        for (int right = 0; right < arr.length; right++) {\\n            sum += arr[right];\\n            while (sum > target) {\\n                sum -= arr[left++];\\n            }\\n            \\n            if (sum == target) {\\n                int currentLength = right - left + 1;\\n                if (left > 0 && dp[left - 1] != Integer.MAX_VALUE) {\\n                    // If we found an subarray to the left that does not overlap\\n                    // with the current subarray\\n                    result = Math.min(\\n                            result,\\n                            currentLength + dp[left - 1]);\\n                }\\n                \\n                // store in dp[right] the smallest length we have seen so far\\n                dp[right] = Math.min(currentLength, \\n                        right == 0 ? Integer.MAX_VALUE : dp[right - 1]);\\n            } else {\\n                // copy value from previous index if current subarray does not\\n                // add up to target\\n                dp[right] = right == 0 ? Integer.MAX_VALUE : dp[right - 1];\\n            }\\n        }\\n        \\n        return result == Integer.MAX_VALUE ? -1 : result;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n     * Idea: Use sliding window to figure out subarrays that add up to target.\\n     *       As we go, we want to store in \"dp\" the length of the shortest \\n     *       subarray we\\'ve seen up to the current \"right\" index. Every time \\n     *       we find a new subarray, we add its length to the length of the\\n     *       shortest non-overlapping subarray to its left (i.e. dp[left - 1]. \\n     *       We will try to minimize this computation as we go (variable\\n     *       \"result\").\\n     */\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int left = 0;\\n        int sum = 0;\\n        int dp[] = new int[arr.length];\\n        int result = Integer.MAX_VALUE;\\n        \\n        for (int right = 0; right < arr.length; right++) {\\n            sum += arr[right];\\n            while (sum > target) {\\n                sum -= arr[left++];\\n            }\\n            \\n            if (sum == target) {\\n                int currentLength = right - left + 1;\\n                if (left > 0 && dp[left - 1] != Integer.MAX_VALUE) {\\n                    // If we found an subarray to the left that does not overlap\\n                    // with the current subarray\\n                    result = Math.min(\\n                            result,\\n                            currentLength + dp[left - 1]);\\n                }\\n                \\n                // store in dp[right] the smallest length we have seen so far\\n                dp[right] = Math.min(currentLength, \\n                        right == 0 ? Integer.MAX_VALUE : dp[right - 1]);\\n            } else {\\n                // copy value from previous index if current subarray does not\\n                // add up to target\\n                dp[right] = right == 0 ? Integer.MAX_VALUE : dp[right - 1];\\n            }\\n        }\\n        \\n        return result == Integer.MAX_VALUE ? -1 : result;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858789,
                "title": "c-one-pass-window-scan-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int ans = 100001, currSum = 0, preIndex = 0; \\n        vector<int> f(arr.size() + 1, 100001);\\n        for (int i = 0; i < arr.size(); i++) {\\n            for (currSum += arr[i]; currSum > target; currSum -= arr[preIndex++]);\\n            if (currSum == target) {\\n                f[i + 1] = min(i + 1 - preIndex, f[i]);\\n                ans = min(ans, f[preIndex] + i + 1 - preIndex);\\n            } else {\\n                f[i + 1] = f[i];\\n            }\\n        }\\n        return ans >= 100001 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int ans = 100001, currSum = 0, preIndex = 0; \\n        vector<int> f(arr.size() + 1, 100001);\\n        for (int i = 0; i < arr.size(); i++) {\\n            for (currSum += arr[i]; currSum > target; currSum -= arr[preIndex++]);\\n            if (currSum == target) {\\n                f[i + 1] = min(i + 1 - preIndex, f[i]);\\n                ans = min(ans, f[preIndex] + i + 1 - preIndex);\\n            } else {\\n                f[i + 1] = f[i];\\n            }\\n        }\\n        return ans >= 100001 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846565,
                "title": "python-prefix-sum-dp",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def minSumOfLengths(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not arr:\\n            return 0\\n\\n        sum_map = {0:-1}      \\n        min_arr_till = [len(arr) + 1]* len(arr)       \\n        min_subarr_found = len(arr) + 1\\n        cur_sum = 0\\n        min_sum = len(arr) + 1\\n        \\n        for idx, val in enumerate(arr):\\n            cur_sum += val\\n            \\n            if cur_sum - target in sum_map:                \\n                s, e = sum_map[cur_sum - target] , idx\\n                \\n                min_sum = min(min_sum, e-s + min_arr_till[s])\\n                \\n                # Find min_subarr till idx \\n                min_subarr_found = min(min_subarr_found, e-s )\\n                \\n            min_arr_till[idx] = min_subarr_found\\n                \\n            sum_map[cur_sum] = idx\\n        return min_sum if min_sum <= len(arr) else -1\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def minSumOfLengths(self, arr, target):\\n        \"\"\"\\n        :type arr: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not arr:\\n            return 0\\n\\n        sum_map = {0:-1}      \\n        min_arr_till = [len(arr) + 1]* len(arr)       \\n        min_subarr_found = len(arr) + 1\\n        cur_sum = 0\\n        min_sum = len(arr) + 1\\n        \\n        for idx, val in enumerate(arr):\\n            cur_sum += val\\n            \\n            if cur_sum - target in sum_map:                \\n                s, e = sum_map[cur_sum - target] , idx\\n                \\n                min_sum = min(min_sum, e-s + min_arr_till[s])\\n                \\n                # Find min_subarr till idx \\n                min_subarr_found = min(min_subarr_found, e-s )\\n                \\n            min_arr_till[idx] = min_subarr_found\\n                \\n            sum_map[cur_sum] = idx\\n        return min_sum if min_sum <= len(arr) else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808185,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        ans = float(\\'inf\\')\\n        start = 0\\n        subsum = 0\\n        shortest_before = [float(\\'inf\\') for _ in range(len(arr)+1)]\\n        for end in range(len(arr)):\\n            shortest_before[end+1] = shortest_before[end]\\n            subsum += arr[end]\\n            while subsum > target and start < end:\\n                subsum -= arr[start]\\n                start += 1\\n            if subsum == target:\\n                sublen = end - start + 1\\n                ans = min(ans, shortest_before[start] + sublen)    \\n                shortest_before[end+1] = min(shortest_before[end+1], sublen)\\n        if ans == float(\\'inf\\'):\\n            ans = -1\\n        return ans \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        ans = float(\\'inf\\')\\n        start = 0\\n        subsum = 0\\n        shortest_before = [float(\\'inf\\') for _ in range(len(arr)+1)]\\n        for end in range(len(arr)):\\n            shortest_before[end+1] = shortest_before[end]\\n            subsum += arr[end]\\n            while subsum > target and start < end:\\n                subsum -= arr[start]\\n                start += 1\\n            if subsum == target:\\n                sublen = end - start + 1\\n                ans = min(ans, shortest_before[start] + sublen)    \\n                shortest_before[end+1] = min(shortest_before[end+1], sublen)\\n        if ans == float(\\'inf\\'):\\n            ans = -1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 786581,
                "title": "java-o-n-sliding-window-approach",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        \\n        if(arr == null || arr.length == 0);\\n        \\n        int len = arr.length;\\n        int[] endDp = new int[len];\\n        int[] startDp = new int[len];\\n        int start = 0, end = 0, sum = 0;\\n        int minEnd = len+1;\\n        int result = len+1;\\n        \\n        Arrays.fill(endDp, len+1);\\n        Arrays.fill(startDp, len+1);\\n        \\n       while(end < len) {\\n           sum += arr[end];\\n           \\n           while(sum >= target) {\\n               if(sum == target) {\\n                    int size = end-start+1;\\n                    startDp[start] = Math.min(size, startDp[start]);\\n                    endDp[end] = Math.min(size, endDp[end]); \\n               }\\n               \\n               sum -= arr[start];\\n               start++;\\n           }\\n           end++;\\n       }\\n        \\n        \\n        for(int i=0; i<len; i++) {\\n            if(startDp[i] != len+1 && minEnd != len+1)\\n                result = Math.min(result, minEnd + startDp[i]);\\n            if(endDp[i] != len+1) minEnd = Math.min(minEnd, endDp[i]);\\n        }\\n        \\n        return result==len+1 ? -1 : result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        \\n        if(arr == null || arr.length == 0);\\n        \\n        int len = arr.length;\\n        int[] endDp = new int[len];\\n        int[] startDp = new int[len];\\n        int start = 0, end = 0, sum = 0;\\n        int minEnd = len+1;\\n        int result = len+1;\\n        \\n        Arrays.fill(endDp, len+1);\\n        Arrays.fill(startDp, len+1);\\n        \\n       while(end < len) {\\n           sum += arr[end];\\n           \\n           while(sum >= target) {\\n               if(sum == target) {\\n                    int size = end-start+1;\\n                    startDp[start] = Math.min(size, startDp[start]);\\n                    endDp[end] = Math.min(size, endDp[end]); \\n               }\\n               \\n               sum -= arr[start];\\n               start++;\\n           }\\n           end++;\\n       }\\n        \\n        \\n        for(int i=0; i<len; i++) {\\n            if(startDp[i] != len+1 && minEnd != len+1)\\n                result = Math.min(result, minEnd + startDp[i]);\\n            if(endDp[i] != len+1) minEnd = Math.min(minEnd, endDp[i]);\\n        }\\n        \\n        return result==len+1 ? -1 : result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785243,
                "title": "c-intuitive-solution-in-o-n",
                "content": "CONCEPTS USED:\\nPREFIX SUM\\nMAP TO FIND INDEX\\nMINIMUM LENGTH UPDATE \\nFORWARD AND BACKWARD TRAVERSAL OF ARRAYS\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> help(vector<int>&v,int target)\\n    {\\n        int n=v.size();\\n        map<int,int>mp;\\n        mp[0]=-1;\\n        vector<int>ans(n,n+1);\\n        vector<int>prefix(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=n+1;\\n            prefix[i]=(i==0?0:prefix[i-1])+v[i];\\n            int req=prefix[i]-target;\\n            if(mp.find(req)!=mp.end())\\n                l=i-mp[req];\\n            \\n            mp[prefix[i]]=i;\\n            ans[i]=min(l,(i==0?l:ans[i-1]));\\n        }\\n        return ans;\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        vector<int>rev=arr;\\n        reverse(rev.begin(),rev.end());\\n        vector<int>left=help(arr,target);\\n        vector<int>right=help(rev,target);\\n        reverse(right.begin(),right.end());\\n        int ans=INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans=min(ans,left[i]+right[i+1]);\\n        }\\n        return ans<=n?ans:-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> help(vector<int>&v,int target)\\n    {\\n        int n=v.size();\\n        map<int,int>mp;\\n        mp[0]=-1;\\n        vector<int>ans(n,n+1);\\n        vector<int>prefix(n,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            int l=n+1;\\n            prefix[i]=(i==0?0:prefix[i-1])+v[i];\\n            int req=prefix[i]-target;\\n            if(mp.find(req)!=mp.end())\\n                l=i-mp[req];\\n            \\n            mp[prefix[i]]=i;\\n            ans[i]=min(l,(i==0?l:ans[i-1]));\\n        }\\n        return ans;\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        vector<int>rev=arr;\\n        reverse(rev.begin(),rev.end());\\n        vector<int>left=help(arr,target);\\n        vector<int>right=help(rev,target);\\n        reverse(right.begin(),right.end());\\n        int ans=INT_MAX;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            ans=min(ans,left[i]+right[i+1]);\\n        }\\n        return ans<=n?ans:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 771934,
                "title": "c-o-n-solution-two-sliding-windows",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int size = arr.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        \\n        // Slide the window left to right and keep track of the minimum window length where the sum == target at each index\\n        vector<int> fwd (size, INT_MAX);\\n        int start = 0, end = 0, sum = arr[0];\\n        int minLen = INT_MAX;\\n        while (true) {\\n            if (sum == target) {\\n                minLen = min(minLen, end-start+1);\\n                fwd[end] = minLen;\\n                if (end == size-1) {break;}\\n                sum += arr[++end];\\n                continue;\\n            }\\n            \\n            if (sum > target) {\\n                sum -= arr[start++];\\n            } else {\\n                fwd[end] = minLen;\\n                if (end == size-1) {break;}\\n                sum += arr[++end];\\n            }\\n        }\\n        \\n        // Slide the window right to left and keep track of the minimum window length where the sum == target at each index\\n        vector<int> bwd (size, INT_MAX);\\n        start = size-1, end = size-1, sum = arr[size-1];\\n        minLen = INT_MAX;\\n        while (true) {\\n            if (sum == target) {\\n                minLen = min(minLen, end-start+1);\\n                bwd[start] = minLen;\\n                if (start == 0) {break;}\\n                sum += arr[--start];\\n                continue;\\n            }\\n            \\n            if (sum > target) {\\n                sum -= arr[end--];\\n            } else {\\n                bwd[start] = minLen;\\n                if (start == 0) {break;}\\n                sum += arr[--start];\\n            }\\n        }\\n\\n        int result = INT_MAX;\\n        for (int i = 0 ; i < size-1; ++i) {\\n            if (fwd[i] != INT_MAX && bwd[i+1] != INT_MAX) {\\n                result = min(result, fwd[i] + bwd[i+1]);\\n            }\\n        }\\n        \\n        return result == INT_MAX ? -1 : result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int size = arr.size();\\n        if (size == 0) {\\n            return -1;\\n        }\\n        \\n        \\n        // Slide the window left to right and keep track of the minimum window length where the sum == target at each index\\n        vector<int> fwd (size, INT_MAX);\\n        int start = 0, end = 0, sum = arr[0];\\n        int minLen = INT_MAX;\\n        while (true) {\\n            if (sum == target) {\\n                minLen = min(minLen, end-start+1);\\n                fwd[end] = minLen;\\n                if (end == size-1) {break;}\\n                sum += arr[++end];\\n                continue;\\n            }\\n            \\n            if (sum > target) {\\n                sum -= arr[start++];\\n            } else {\\n                fwd[end] = minLen;\\n                if (end == size-1) {break;}\\n                sum += arr[++end];\\n            }\\n        }\\n        \\n        // Slide the window right to left and keep track of the minimum window length where the sum == target at each index\\n        vector<int> bwd (size, INT_MAX);\\n        start = size-1, end = size-1, sum = arr[size-1];\\n        minLen = INT_MAX;\\n        while (true) {\\n            if (sum == target) {\\n                minLen = min(minLen, end-start+1);\\n                bwd[start] = minLen;\\n                if (start == 0) {break;}\\n                sum += arr[--start];\\n                continue;\\n            }\\n            \\n            if (sum > target) {\\n                sum -= arr[end--];\\n            } else {\\n                bwd[start] = minLen;\\n                if (start == 0) {break;}\\n                sum += arr[--start];\\n            }\\n        }\\n\\n        int result = INT_MAX;\\n        for (int i = 0 ; i < size-1; ++i) {\\n            if (fwd[i] != INT_MAX && bwd[i+1] != INT_MAX) {\\n                result = min(result, fwd[i] + bwd[i+1]);\\n            }\\n        }\\n        \\n        return result == INT_MAX ? -1 : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758310,
                "title": "o-n-time-and-o-1-space-solution",
                "content": "```\\n\\npublic int minSumOfLengths(int[] arr, int target) {\\n        int sum = 0, start = 0, end =0;\\n        int[] min1=null, min2=null;\\n        int res = Integer.MAX_VALUE;\\n        for(int i=0;i<arr.length;i++){\\n            sum = sum + arr[i];\\n            while(sum>target && start<i){\\n                sum = sum - arr[start];\\n                start++;\\n            }\\n            \\n            if(sum==target){\\n                end=i;\\n                int len = end-start+1;\\n                \\n                if(min1==null){\\n                    min1 = new int[]{start, end, len};\\n                }else if(min2==null){\\n                    min2 = new int[]{start, end, len};\\n                    res = checkAndUpdate(res, min1, min2);\\n                }else{\\n                    \\n                    res = checkAndUpdate(res, min1, new int[]{start, end, len});\\n                    res = checkAndUpdate(res, min2, new int[]{start, end, len});\\n                    \\n                    if(len < min1[2] && len < min2[2]){\\n                        if(min1[2] > min2[2]){\\n                            min1 = min2;\\n                            min2 = new int[]{start, end, len};\\n                        }else{\\n                            min2 = new int[]{start, end, len};\\n                        }\\n                    }else if(len <min2[2]) {\\n                        min2 = new int[]{start, end, len};\\n                    }else if(len < min1[2]){\\n                        min1 = new int[]{start, end, len};\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return res == Integer.MAX_VALUE ?-1:res;\\n    }\\n    \\n    int checkAndUpdate(int res, int[] min1, int[] min2){\\n        if(min1 != null && min2 != null){\\n                    //is min1 and min2 overlapping\\n                    if((min1[0] <= min2[0] && min1[1]>=min2[0]) || (min1[0] <= min2[1] && min1[1]>=min2[1])){\\n\\n                    }else{\\n                        res = Math.min(res, min1[2]+min2[2]);\\n                    }\\n        }\\n        return res;\\n    }\\n",
                "solutionTags": [],
                "code": "```\\n\\npublic int minSumOfLengths(int[] arr, int target) {\\n        int sum = 0, start = 0, end =0;\\n        int[] min1=null, min2=null;\\n        int res = Integer.MAX_VALUE;\\n        for(int i=0;i<arr.length;i++){\\n            sum = sum + arr[i];\\n            while(sum>target && start<i){\\n                sum = sum - arr[start];\\n                start++;\\n            }\\n            \\n            if(sum==target){\\n                end=i;\\n                int len = end-start+1;\\n                \\n                if(min1==null){\\n                    min1 = new int[]{start, end, len};\\n                }else if(min2==null){\\n                    min2 = new int[]{start, end, len};\\n                    res = checkAndUpdate(res, min1, min2);\\n                }else{\\n                    \\n                    res = checkAndUpdate(res, min1, new int[]{start, end, len});\\n                    res = checkAndUpdate(res, min2, new int[]{start, end, len});\\n                    \\n                    if(len < min1[2] && len < min2[2]){\\n                        if(min1[2] > min2[2]){\\n                            min1 = min2;\\n                            min2 = new int[]{start, end, len};\\n                        }else{\\n                            min2 = new int[]{start, end, len};\\n                        }\\n                    }else if(len <min2[2]) {\\n                        min2 = new int[]{start, end, len};\\n                    }else if(len < min1[2]){\\n                        min1 = new int[]{start, end, len};\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return res == Integer.MAX_VALUE ?-1:res;\\n    }\\n    \\n    int checkAndUpdate(int res, int[] min1, int[] min2){\\n        if(min1 != null && min2 != null){\\n                    //is min1 and min2 overlapping\\n                    if((min1[0] <= min2[0] && min1[1]>=min2[0]) || (min1[0] <= min2[1] && min1[1]>=min2[1])){\\n\\n                    }else{\\n                        res = Math.min(res, min1[2]+min2[2]);\\n                    }\\n        }\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 751038,
                "title": "java-sliding-window-o-n",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        long[] left=new long[arr.length];\\n        long[] right=new long[arr.length];\\n        long leftlen=Integer.MAX_VALUE;\\n        int sum=0;\\n        int start=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            while(sum>target){\\n               sum-=arr[start++];\\n            }\\n            if(sum==target){\\n                leftlen=Math.min(leftlen,i-start+1);\\n            }\\n                left[i]=leftlen;\\n        }\\n        sum=0;\\n        start=arr.length-1;\\n        long rightlen=Integer.MAX_VALUE;\\n        for(int i=arr.length-1;i>=0;i--){\\n            sum+=arr[i];\\n            while(sum>target){\\n               sum-=arr[start--];\\n            }\\n            if(sum==target){\\n                rightlen=Math.min(rightlen,start-i+1);\\n            }\\n           \\n                right[i]=rightlen;\\n        }\\n        // for(int i=0;i<arr.length;i++){\\n        //     System.out.println(left[i]+\" \"+right[i]);\\n        // }\\n       \\n        long max=Integer.MAX_VALUE;\\n        for(int i=1;i<arr.length;i++){\\n            //System.out.println(left[i-1]+right[i]);\\n            max=Math.min(left[i-1]+right[i],max);\\n        }\\n       return (int)(max>=Integer.MAX_VALUE?-1:max);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        long[] left=new long[arr.length];\\n        long[] right=new long[arr.length];\\n        long leftlen=Integer.MAX_VALUE;\\n        int sum=0;\\n        int start=0;\\n        for(int i=0;i<arr.length;i++){\\n            sum+=arr[i];\\n            while(sum>target){\\n               sum-=arr[start++];\\n            }\\n            if(sum==target){\\n                leftlen=Math.min(leftlen,i-start+1);\\n            }\\n                left[i]=leftlen;\\n        }\\n        sum=0;\\n        start=arr.length-1;\\n        long rightlen=Integer.MAX_VALUE;\\n        for(int i=arr.length-1;i>=0;i--){\\n            sum+=arr[i];\\n            while(sum>target){\\n               sum-=arr[start--];\\n            }\\n            if(sum==target){\\n                rightlen=Math.min(rightlen,start-i+1);\\n            }\\n           \\n                right[i]=rightlen;\\n        }\\n        // for(int i=0;i<arr.length;i++){\\n        //     System.out.println(left[i]+\" \"+right[i]);\\n        // }\\n       \\n        long max=Integer.MAX_VALUE;\\n        for(int i=1;i<arr.length;i++){\\n            //System.out.println(left[i-1]+right[i]);\\n            max=Math.min(left[i-1]+right[i],max);\\n        }\\n       return (int)(max>=Integer.MAX_VALUE?-1:max);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727893,
                "title": "python-80-speed-pure-o-n-solution-scheduled-delivery",
                "content": "**Python [80% Speed] - Pure O(n) Solution - Scheduled Delivery**\\n\\nThe code below is a pure O(n) solution for the problem. It tracks the shortest length with sum=target before a given arr[i] value.\\n\\nCuriously enough, Leetcode rated the second code attached as being slightly faster. It uses a O(n) linear scanning pass , followed by a O(r^2) loop searching for the shortest compatible sub-arrays. The good run-times are probably due to the pre-sorting step for the valid ranges, plus all the early exit conditions.\\n\\n```\\n# Solution A: Pure O(n) solution; tracking the best ranges found so far.\\nposInf = float(\\'inf\\')\\nfmin = lambda x,y: x if x<y else y # High Speed min function (33% faster than standard)\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        S = [0]\\n        for x in arr:\\n            S.append( S[-1]+x )\\n        dictS = dict(zip(S,range(len(S))))\\n        #\\n        result,best = posInf, posInf # best is the shortest range before arr[i]\\n        schedule = {} # Schedule of ranges to inject into \"best\"\\n        for i in range(len(arr)):\\n            s = S[i] # sum before adding arr[i]\\n            if (s+target) in dictS:\\n                j = dictS[s+target] - 1 # S-indexes are shifted by one\\n                schedule[j] = j-i+1     # latest is always the best (shortest i for the same j)\\n                result = fmin(result,best+j-i+1)\\n            if i in schedule:\\n                best = fmin(best,schedule[i]) # improve best prev. length\\n        return result if result<posInf else -1\\n```\\n\\n```\\n# Solution B: O(n) Linear Scanning Pass, followed by O(r^2) search among valid ranges\\n#                  (pre-sorting + solid exit conditions for the O(r^2) loop achieve a high Leetcode rating)\\nposInf = float(\\'inf\\')\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        s, seen = 0, {}\\n        found   = []\\n        seen[0] = -1 # (theoretical adjustment) (sum = 0 seen at i = -1)\\n        for i,x in enumerate(arr):\\n            s += x\\n            if s-target in seen:\\n                found.append( [seen[s-target]+1,i] )\\n            seen[s] = i\\n        #\\n        found.sort(key = lambda x: [x[1]-x[0],x]) # sort first by length, then by index\\n        if len(found)<2:\\n            return -1\\n        Lf = len(found)\\n        result = a2 = posInf\\n        for i in range(Lf-1):\\n            i1,j1 = found[i]\\n            a1 = j1-i1+1\\n            if (not i<Lf) or (a1>=a2): # We can\\'t seach for a range bigger than before. If we\\'re using a range of equal length, just exit\\n                break\\n            a2 = posInf\\n            for j in range(i+1,Lf):\\n                i2,j2 = found[j]\\n                if not ( i1<=i2<=j1 or i1<=j2<=j1 ):\\n                    a2 = j2-i2+1 # valid range found\\n                    Lf = j       # make sure you never explore any further than this \\n                    break\\n            if (a1+a2)<result:\\n                result = a1+a2\\n        return result if result<posInf else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Solution A: Pure O(n) solution; tracking the best ranges found so far.\\nposInf = float(\\'inf\\')\\nfmin = lambda x,y: x if x<y else y # High Speed min function (33% faster than standard)\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        S = [0]\\n        for x in arr:\\n            S.append( S[-1]+x )\\n        dictS = dict(zip(S,range(len(S))))\\n        #\\n        result,best = posInf, posInf # best is the shortest range before arr[i]\\n        schedule = {} # Schedule of ranges to inject into \"best\"\\n        for i in range(len(arr)):\\n            s = S[i] # sum before adding arr[i]\\n            if (s+target) in dictS:\\n                j = dictS[s+target] - 1 # S-indexes are shifted by one\\n                schedule[j] = j-i+1     # latest is always the best (shortest i for the same j)\\n                result = fmin(result,best+j-i+1)\\n            if i in schedule:\\n                best = fmin(best,schedule[i]) # improve best prev. length\\n        return result if result<posInf else -1\\n```\n```\\n# Solution B: O(n) Linear Scanning Pass, followed by O(r^2) search among valid ranges\\n#                  (pre-sorting + solid exit conditions for the O(r^2) loop achieve a high Leetcode rating)\\nposInf = float(\\'inf\\')\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        s, seen = 0, {}\\n        found   = []\\n        seen[0] = -1 # (theoretical adjustment) (sum = 0 seen at i = -1)\\n        for i,x in enumerate(arr):\\n            s += x\\n            if s-target in seen:\\n                found.append( [seen[s-target]+1,i] )\\n            seen[s] = i\\n        #\\n        found.sort(key = lambda x: [x[1]-x[0],x]) # sort first by length, then by index\\n        if len(found)<2:\\n            return -1\\n        Lf = len(found)\\n        result = a2 = posInf\\n        for i in range(Lf-1):\\n            i1,j1 = found[i]\\n            a1 = j1-i1+1\\n            if (not i<Lf) or (a1>=a2): # We can\\'t seach for a range bigger than before. If we\\'re using a range of equal length, just exit\\n                break\\n            a2 = posInf\\n            for j in range(i+1,Lf):\\n                i2,j2 = found[j]\\n                if not ( i1<=i2<=j1 or i1<=j2<=j1 ):\\n                    a2 = j2-i2+1 # valid range found\\n                    Lf = j       # make sure you never explore any further than this \\n                    break\\n            if (a1+a2)<result:\\n                result = a1+a2\\n        return result if result<posInf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725446,
                "title": "c-clean-2-pass-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size(), sum = 0, minLen = INT_MAX, result = INT_MAX;\\n        vector<int> leftScan(n);\\n        unordered_map<int, int> lookup1, lookup2;\\n        \\n        lookup1[0] = -1, lookup2[0] = n;        \\n        \\n        // left scan\\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            int diff = sum - target;\\n            \\n            if (lookup1.count(diff))\\n                minLen = min(minLen, i - lookup1[diff]);\\n            \\n            lookup1[sum] = i;\\n            leftScan[i] = minLen;         \\n        }\\n        \\n        sum = 0, minLen = INT_MAX;\\n        \\n        // rightScan\\n        for (int i = n-1; i > 0; i--) {\\n            sum += arr[i];\\n            int diff = sum - target;            \\n            \\n            if (lookup2.count(diff))\\n                minLen = min(minLen, lookup2[diff] - i);\\n                    \\n            lookup2[sum] = i;\\n            \\n            if (leftScan[i-1] != INT_MAX and minLen != INT_MAX)\\n                result = min(result, leftScan[i-1] + minLen);\\n        }\\n        \\n        return result == INT_MAX ? -1 : result;        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size(), sum = 0, minLen = INT_MAX, result = INT_MAX;\\n        vector<int> leftScan(n);\\n        unordered_map<int, int> lookup1, lookup2;\\n        \\n        lookup1[0] = -1, lookup2[0] = n;        \\n        \\n        // left scan\\n        for (int i = 0; i < n; i++) {\\n            sum += arr[i];\\n            int diff = sum - target;\\n            \\n            if (lookup1.count(diff))\\n                minLen = min(minLen, i - lookup1[diff]);\\n            \\n            lookup1[sum] = i;\\n            leftScan[i] = minLen;         \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 722871,
                "title": "solution-using-prefix-sums-and-binary-search",
                "content": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>&a, int t) {int n=a.size(),i,mini=n+1;\\n        int pref_l[n],pref_r[n],l[n],r[n];\\n        for(i=0;i<n;i++)\\n            l[i]=r[i]=n;\\n        for(i=0;i<n;i++)\\n        {\\n            pref_l[i]=a[i];\\n            if(i)\\n                pref_l[i]+=pref_l[i-1];\\n            if(pref_l[i]==t)\\n                l[i]=i+1;\\n            else if(pref_l[i]>t)\\n            {\\n                int index=upper_bound(pref_l,pref_l+i,pref_l[i]-t)-pref_l;\\n                if(index&&pref_l[index-1]==(pref_l[i]-t))\\n                    l[i]=i-index+1;\\n            }\\n            if(i)\\n                l[i]=min(l[i],l[i-1]);\\n        }\\n        for(i=n-1;i>=0;i--)\\n        {\\n            pref_r[i]=a[i];\\n            if(i<n-1)\\n                pref_r[i]+=pref_r[i+1];\\n            if(pref_r[i]==t)\\n                r[i]=n-i;\\n            else if(pref_r[i]>t)\\n            {\\n                int index=lower_bound(pref_r+i,pref_r+n,pref_r[i]-t,greater<int>())-pref_r;\\n                if(index<n&&pref_r[index]==pref_r[i]-t)\\n                    r[i]=index-i;\\n            }\\n            if(i<n-1)\\n                r[i]=min(r[i],r[i+1]);\\n        }\\n        for(i=0;i<n-1;i++)\\n        {\\n            if(l[i]!=n&&r[i+1]!=n)\\n                mini=min(mini,l[i]+r[i+1]);\\n        }\\n        if(mini!=n+1)\\n            return mini;\\n        return -1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSumOfLengths(vector<int>&a, int t) {int n=a.size(),i,mini=n+1;\\n        int pref_l[n],pref_r[n],l[n],r[n];\\n        for(i=0;i<n;i++)\\n            l[i]=r[i]=n;\\n        for(i=0;i<n;i++)\\n        {\\n            pref_l[i]=a[i];\\n            if(i)\\n                pref_l[i]+=pref_l[i-1];\\n            if(pref_l[i]==t)\\n                l[i]=i+1;\\n            else if(pref_l[i]>t)\\n            {\\n                int index=upper_bound(pref_l,pref_l+i,pref_l[i]-t)-pref_l;\\n                if(index&&pref_l[index-1]==(pref_l[i]-t))\\n                    l[i]=i-index+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 716525,
                "title": "javascript-math-solution",
                "content": "Array building shenanigans didn\\'t cut it this time, so I used math instead.\\n\\n_Runtime: 116 ms, faster than 95.60% of JavaScript online submissions_\\n_Memory Usage: 45.5 MB, less than 100.00% of JavaScript online submissions_\\n\\n```javascript\\n/**\\n * Slide in a sub-array from the left and a sub-array from the right\\n * Slide whichever has seen the longest sub-array with the target sum\\u2020\\u2021\\n * Stop when they touch\\n *\\n * \\u2020 When they\\'re equal, slide the right sub-array\\n * \\u2021 In order to give that side a chance to find a shorter matching sub-array\\n *\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nconst minSumOfLengths = (arr, target) => {\\n  // Indices for the heads & tails of the left & right sub-arrays\\n  let [lt, lh, rh, rt] = [0, 0, arr.length - 1, arr.length - 1];\\n  // Sums for the left & right sub-arrays\\n  let [lSum, rSum] = [arr[lh], arr[rh]];\\n  // Lengths of of the shortest left & right sub-arrays with the target sum\\n  let [lMinLen, rMinLen] = [Infinity, Infinity];\\n  // While the left & right sub-arrays (heads) aren\\'t overlapping\\n  while (lh < rh) {\\n    // If the left sub-array sum is too big, contract the left tail\\n    /* \\uD83C\\uDF2E */ while (target < lSum) lSum -= arr[lt++];\\n    // If the right sub-array sum is too big, contract the right tail\\n    /* \\uD83C\\uDF2E */ while (target < rSum) rSum -= arr[rt--];\\n    // If the left sub-array sum is correct, remember its length if shorter\\n    if (lSum === target) lMinLen = Math.min(lMinLen, lh - lt + 1);\\n    // If the right sub-array sum is correct, remember its length if shorter\\n    if (rSum === target) rMinLen = Math.min(rMinLen, rt - rh + 1);\\n    // If the the right sub-array is bigger, extend the right window head\\n    if (lMinLen <= rMinLen) rSum += arr[--rh];\\n    // Else, if the the left sub-array is bigger, extend the left window head\\n    else lSum += arr[++lh];\\n    // Go back to the lines with tacos (\\uD83C\\uDF2E\\uD83C\\uDF2E), they will make more sense now\\n  }\\n  // Return -1 if either sub-array did not find the target sum else the answer\\n  return Infinity === lMinLen + rMinLen ? -1 : lMinLen + rMinLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```javascript\\n/**\\n * Slide in a sub-array from the left and a sub-array from the right\\n * Slide whichever has seen the longest sub-array with the target sum\\u2020\\u2021\\n * Stop when they touch\\n *\\n * \\u2020 When they\\'re equal, slide the right sub-array\\n * \\u2021 In order to give that side a chance to find a shorter matching sub-array\\n *\\n * @param {number[]} arr\\n * @param {number} target\\n * @return {number}\\n */\\nconst minSumOfLengths = (arr, target) => {\\n  // Indices for the heads & tails of the left & right sub-arrays\\n  let [lt, lh, rh, rt] = [0, 0, arr.length - 1, arr.length - 1];\\n  // Sums for the left & right sub-arrays\\n  let [lSum, rSum] = [arr[lh], arr[rh]];\\n  // Lengths of of the shortest left & right sub-arrays with the target sum\\n  let [lMinLen, rMinLen] = [Infinity, Infinity];\\n  // While the left & right sub-arrays (heads) aren\\'t overlapping\\n  while (lh < rh) {\\n    // If the left sub-array sum is too big, contract the left tail\\n    /* \\uD83C\\uDF2E */ while (target < lSum) lSum -= arr[lt++];\\n    // If the right sub-array sum is too big, contract the right tail\\n    /* \\uD83C\\uDF2E */ while (target < rSum) rSum -= arr[rt--];\\n    // If the left sub-array sum is correct, remember its length if shorter\\n    if (lSum === target) lMinLen = Math.min(lMinLen, lh - lt + 1);\\n    // If the right sub-array sum is correct, remember its length if shorter\\n    if (rSum === target) rMinLen = Math.min(rMinLen, rt - rh + 1);\\n    // If the the right sub-array is bigger, extend the right window head\\n    if (lMinLen <= rMinLen) rSum += arr[--rh];\\n    // Else, if the the left sub-array is bigger, extend the left window head\\n    else lSum += arr[++lh];\\n    // Go back to the lines with tacos (\\uD83C\\uDF2E\\uD83C\\uDF2E), they will make more sense now\\n  }\\n  // Return -1 if either sub-array did not find the target sum else the answer\\n  return Infinity === lMinLen + rMinLen ? -1 : lMinLen + rMinLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699937,
                "title": "dp-sliding-window",
                "content": "import java.util.Arrays;\\n\\nclass Solution {\\n\\n    public int minSumOfLengths(int[] arr, int target) {\\n\\t\\n        int n=arr.length, i=0, cur_sum=0;\\n        int[] dp=new int[n];\\n        int inf=Integer.MAX_VALUE;\\n        int min_len=inf;\\n        Arrays.fill(dp,inf);\\n\\n        for (int j=0;j<n;j++){\\n            cur_sum+=arr[j];\\n\\n            if (i<n && cur_sum>target){//if current sum greater thn sum need to reduce subarray from left side\\n\\t\\t\\t\\n                while (cur_sum>target){\\n\\t\\t\\t\\t\\n                    cur_sum-=arr[i++];\\n\\t\\t\\t\\t\\t\\n                }\\n\\n            }\\n\\n            if (cur_sum==target){// subarray sum equal to target found\\n                dp[j]=(j-i)+1;//getting up length of target subarray\\n\\n                if (i-1>=0 && dp[i-1]!=Integer.MAX_VALUE){// geeting up minimum length of two non overlapping sub array\\n                    min_len=Math.min(dp[j]+dp[i-1],min_len);\\n                }\\n            }\\n\\n\\n            if (j-1>=0){// getting up minimum length of target sum subaray so that if in future we get subarray thn we always get minimum sum of two\\n                dp[j]=Math.min(dp[j],dp[j-1]);\\n            }\\n\\n        }\\n        return min_len==inf?-1:min_len;\\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int minSumOfLengths(int[] arr, int target) {\\n\\t\\n        int n=arr.length, i=0, cur_sum=0;\\n        int[] dp=new int[n];\\n        int inf=Integer.MAX_VALUE;\\n        int min_len=inf;\\n        Arrays.fill(dp,inf);\\n\\n        for (int j=0;j<n;j++){\\n            cur_sum+=arr[j];\\n\\n            if (i<n && cur_sum>target){//if current sum greater thn sum need to reduce subarray from left side\\n\\t\\t\\t\\n                while (cur_sum>target){\\n\\t\\t\\t\\t\\n                    cur_sum-=arr[i++];\\n\\t\\t\\t\\t\\t\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 690810,
                "title": "c-solution-with-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int minn(long a, long b) {\\n        if(a > b)\\n            return b;\\n        return a;\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<long> v(n);\\n        int sum = 0;\\n        long result = INT_MAX;\\n        int i = 0, j = 0;\\n        for(int i = 0; i < n; i++)\\n            v[i] = INT_MAX;\\n        while(i < n) {\\n            if(i != 0)\\n                v[i] = v[i - 1];\\n            sum = sum + arr[i];\\n            while(sum > target) {\\n                sum = sum - arr[j];\\n                j++;\\n            }\\n            if(sum == target) {\\n                int len = i - j + 1;\\n                if(i == 0) { \\n                    v[i] = len; \\n                } else {\\n                    v[i] = minn(v[i], len);\\n                }\\n                if(j > 0)\\n                    result = minn(result, v[j - 1] + len);\\n            }\\n            i++;\\n        }\\n        if(result >= INT_MAX)\\n            return -1;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minn(long a, long b) {\\n        if(a > b)\\n            return b;\\n        return a;\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        vector<long> v(n);\\n        int sum = 0;\\n        long result = INT_MAX;\\n        int i = 0, j = 0;\\n        for(int i = 0; i < n; i++)\\n            v[i] = INT_MAX;\\n        while(i < n) {\\n            if(i != 0)\\n                v[i] = v[i - 1];\\n            sum = sum + arr[i];\\n            while(sum > target) {\\n                sum = sum - arr[j];\\n                j++;\\n            }\\n            if(sum == target) {\\n                int len = i - j + 1;\\n                if(i == 0) { \\n                    v[i] = len; \\n                } else {\\n                    v[i] = minn(v[i], len);\\n                }\\n                if(j > 0)\\n                    result = minn(result, v[j - 1] + len);\\n            }\\n            i++;\\n        }\\n        if(result >= INT_MAX)\\n            return -1;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 688624,
                "title": "c-easy-o-n-dp-sliding-combo",
                "content": "The basic idea is to use sliding window approach in order to detect all continiuous subarrays which are equal to target. \\nIn our DP array we store a length of the shortest subarray which we found on interval [0, index]. So if we have found new interval, we can check the length of the shortest prev one on dp[start - 1].\\n\\n```\\nint minSumOfLengths(vector<int>& arr, int target) \\n{\\n\\tvector<int> dp(arr.size() + 1, INT_MAX);\\n\\tint result = INT_MAX;\\n\\n\\tfor (int start = 1, index = 1, sum = 0; index <= arr.size(); ++index)\\n\\t{\\n\\t\\tsum += arr[index - 1];\\n\\t\\tdp[index] = dp[index - 1];\\n\\n\\t\\twhile (start < index && sum > target)\\n\\t\\t\\tsum -= arr[start++ - 1];\\n\\n\\t\\tif (sum == target)\\n\\t\\t{\\n\\t\\t\\tif (dp[start - 1] != INT_MAX)\\n\\t\\t\\t\\tresult = min(result, dp[start - 1] + index - start + 1);\\n\\n\\t\\t\\tdp[index] = min(dp[index], index - start + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn result == INT_MAX ? -1 : result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minSumOfLengths(vector<int>& arr, int target) \\n{\\n\\tvector<int> dp(arr.size() + 1, INT_MAX);\\n\\tint result = INT_MAX;\\n\\n\\tfor (int start = 1, index = 1, sum = 0; index <= arr.size(); ++index)\\n\\t{\\n\\t\\tsum += arr[index - 1];\\n\\t\\tdp[index] = dp[index - 1];\\n\\n\\t\\twhile (start < index && sum > target)\\n\\t\\t\\tsum -= arr[start++ - 1];\\n\\n\\t\\tif (sum == target)\\n\\t\\t{\\n\\t\\t\\tif (dp[start - 1] != INT_MAX)\\n\\t\\t\\t\\tresult = min(result, dp[start - 1] + index - start + 1);\\n\\n\\t\\t\\tdp[index] = min(dp[index], index - start + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn result == INT_MAX ? -1 : result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 688106,
                "title": "swift-o-n",
                "content": "First: we need to create a dictionary with sums up to index `dict[sumTillIndex] = index`\\nSecond: for each index we find the lengths of the subarray with sum = `target` on the left and subarray with sum `target` on the right. If two lengths combined are shorted then previous result - rememeber it as intermediate result.\\n```\\nfinal class Solution {\\n    func minSumOfLengths(_ arr: [Int], _ target: Int) -> Int {\\n        var sum = 0\\n        var dict = [0: -1]\\n        for i in arr.indices {\\n            sum += arr[i]\\n            dict[sum] = i\\n        }\\n\\n        sum = 0\\n        var result = Int.max\\n        var leftLength = Int.max\\n        for i in arr.indices {\\n            sum += arr[i]\\n\\n            if let leftIndex = dict[sum - target] {\\n                leftLength = min(leftLength, i - leftIndex)\\n            }\\n\\n            if let rightIndex = dict[sum + target], leftLength < Int.max {\\n                result = min(result, rightIndex - i + leftLength)\\n            }\\n        }\\n\\n        return result == Int.max ? -1 : result\\n    }\\n}\\n```\\nor if you want to achieve the same with only one run:\\n```\\nfinal class Solution {\\n    func minSumOfLengths(_ arr: [Int], _ target: Int) -> Int {\\n        var result = Int.max\\n        var sum = 0\\n        var dict = [0: -1]\\n        var bestTill = Array(repeating: Int.max, count: arr.count)\\n        var best = Int.max\\n        for i in arr.indices {\\n            sum += arr[i]\\n            if let value = dict[sum - target] {\\n                if value > -1 && bestTill[value] != .max {\\n                    result = min(result, i - value + bestTill[value])\\n                }\\n                best = min(best, i - value)\\n            }\\n\\n            bestTill[i] = best\\n            dict[sum] = i\\n        }\\n\\n        return result == Int.max ? -1 : result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfinal class Solution {\\n    func minSumOfLengths(_ arr: [Int], _ target: Int) -> Int {\\n        var sum = 0\\n        var dict = [0: -1]\\n        for i in arr.indices {\\n            sum += arr[i]\\n            dict[sum] = i\\n        }\\n\\n        sum = 0\\n        var result = Int.max\\n        var leftLength = Int.max\\n        for i in arr.indices {\\n            sum += arr[i]\\n\\n            if let leftIndex = dict[sum - target] {\\n                leftLength = min(leftLength, i - leftIndex)\\n            }\\n\\n            if let rightIndex = dict[sum + target], leftLength < Int.max {\\n                result = min(result, rightIndex - i + leftLength)\\n            }\\n        }\\n\\n        return result == Int.max ? -1 : result\\n    }\\n}\\n```\n```\\nfinal class Solution {\\n    func minSumOfLengths(_ arr: [Int], _ target: Int) -> Int {\\n        var result = Int.max\\n        var sum = 0\\n        var dict = [0: -1]\\n        var bestTill = Array(repeating: Int.max, count: arr.count)\\n        var best = Int.max\\n        for i in arr.indices {\\n            sum += arr[i]\\n            if let value = dict[sum - target] {\\n                if value > -1 && bestTill[value] != .max {\\n                    result = min(result, i - value + bestTill[value])\\n                }\\n                best = min(best, i - value)\\n            }\\n\\n            bestTill[i] = best\\n            dict[sum] = i\\n        }\\n\\n        return result == Int.max ? -1 : result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687852,
                "title": "java-prefix",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] A, int T) {\\n        Map<Integer,Integer>map1=new HashMap<>();\\n        int sum1=0;\\n        int front[]=new int[A.length];\\n        Arrays.fill(front,Integer.MAX_VALUE);\\n        for(int i=0;i<A.length;i++){\\n            sum1+=A[i];\\n            if(map1.containsKey(sum1-T)){\\n                front[i]=i-map1.get(sum1-T);\\n            }\\n            if(sum1==T){\\n                front[i]=Math.min(front[i],i+1);\\n            }\\n            if(i-1>=0)front[i]=Math.min(front[i-1],front[i]);\\n            map1.put(sum1,i);\\n        }\\n        \\n        Map<Integer,Integer>map2=new HashMap<>();\\n        int sum2=0;\\n        int back[]=new int[A.length];\\n        Arrays.fill(back,Integer.MAX_VALUE);\\n        for(int i=A.length-1;i>=0;i--){\\n            sum2+=A[i];\\n            if(map2.containsKey(sum2-T)){\\n                back[i]=map2.get(sum2-T)-i;\\n            }\\n            if(sum2==T){\\n                back[i]=Math.min(back[i],back.length-i);\\n            }\\n            if(i+1<back.length)back[i]=Math.min(back[i+1],back[i]);\\n            map2.put(sum2,i);\\n        }\\n        \\n        \\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<A.length-1;i++){\\n            if(front[i]!=Integer.MAX_VALUE&&back[i+1]!=Integer.MAX_VALUE){\\n                res=Math.min(res,front[i]+back[i+1]);\\n            }\\n        }\\n        if(res==Integer.MAX_VALUE)return -1;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] A, int T) {\\n        Map<Integer,Integer>map1=new HashMap<>();\\n        int sum1=0;\\n        int front[]=new int[A.length];\\n        Arrays.fill(front,Integer.MAX_VALUE);\\n        for(int i=0;i<A.length;i++){\\n            sum1+=A[i];\\n            if(map1.containsKey(sum1-T)){\\n                front[i]=i-map1.get(sum1-T);\\n            }\\n            if(sum1==T){\\n                front[i]=Math.min(front[i],i+1);\\n            }\\n            if(i-1>=0)front[i]=Math.min(front[i-1],front[i]);\\n            map1.put(sum1,i);\\n        }\\n        \\n        Map<Integer,Integer>map2=new HashMap<>();\\n        int sum2=0;\\n        int back[]=new int[A.length];\\n        Arrays.fill(back,Integer.MAX_VALUE);\\n        for(int i=A.length-1;i>=0;i--){\\n            sum2+=A[i];\\n            if(map2.containsKey(sum2-T)){\\n                back[i]=map2.get(sum2-T)-i;\\n            }\\n            if(sum2==T){\\n                back[i]=Math.min(back[i],back.length-i);\\n            }\\n            if(i+1<back.length)back[i]=Math.min(back[i+1],back[i]);\\n            map2.put(sum2,i);\\n        }\\n        \\n        \\n        int res=Integer.MAX_VALUE;\\n        for(int i=0;i<A.length-1;i++){\\n            if(front[i]!=Integer.MAX_VALUE&&back[i+1]!=Integer.MAX_VALUE){\\n                res=Math.min(res,front[i]+back[i+1]);\\n            }\\n        }\\n        if(res==Integer.MAX_VALUE)return -1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687491,
                "title": "c-well-commented-o-n-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n=arr.size();\\n        \\n        //The i-th index of two vectors below will store the minlength of subarray having sum equal to target and ending and starting at i respectively, if there is no such subarray fill it with INT_MAX\\n        vector<int> subarrayEndingAt(n,INT_MAX);\\n        vector<int> subarrayStartingAt(n,INT_MAX);\\n        \\n        \\n        //The classical way of finding the min lenght of subarray ending at index i and having sum equal to target :\\n        //We store the sum of prefixes in a map along with the index the prefix is upto\\n        unordered_map<int,int> mp;\\n        mp[0]=-1;           //to handel cases when prefix is equal to target itself\\n        \\n        //the accumulator of the prefix sums\\n        int curr_prefix_sum=0;\\n        \\n        for(int i=0;i<n;i++){\\n            curr_prefix_sum+=arr[i];\\n            \\n            //check if any such prefix is there in the map which when subtracted from the current prefix results in the target value i.e target + prefix == curr_prefix_sum\\n            //if it is there then it simply means there is a subarray ending at i that has sum equal to target so ve store the length of this subarray at this index\\n            if(mp.count(curr_prefix_sum-target)) subarrayEndingAt[i]=i-mp[curr_prefix_sum-target];\\n            \\n            //we insert the curr_prefix_sum in the map for the further use\\n            mp[curr_prefix_sum]=i;\\n        }\\n        \\n        \\n        //We do the same thing above in the reverse manner / to make it even more effective we can make this second vector from the first vector itself but just to keep it simple we do use the same method int \\n        //reverse direction now using suffixes instead of prefixes\\n        unordered_map<int,int> mp2;\\n        mp2[0]=n;\\n        \\n        int curr_suffix_sum=0;\\n        for(int i=n-1;i>=0;i--){\\n            curr_suffix_sum+=arr[i];\\n            if(mp2.count(curr_suffix_sum-target)) subarrayStartingAt[i]=mp2[curr_suffix_sum-target]-i;\\n            mp2[curr_suffix_sum]=i;\\n        }\\n        \\n        \\n        \\n        \\n        long long ans=INT_MAX;\\n        \\n        //this will store the min length of subarray that has already appeared before the current index\\n        int minEndingBefore=INT_MAX;\\n        \\n        for(int i=0;i<n;i++){\\n            //we take the length of subarray starting at current index and add length of subarray that has already ended and has minimum length and ,update the ans as the minimum of this value or previous answer\\n            ans=min(ans,(long long)subarrayStartingAt[i]+minEndingBefore);\\n            \\n            //updating minEndingBefore for further use\\n            minEndingBefore=min(minEndingBefore,subarrayEndingAt[i]);\\n        }\\n        \\n        \\n        //if there was not any answer and we were just having INT_MAX in array / or just 1 subarray or overlapping subarrays the ans would be greater than INT_MAX so return -1\\n        if(ans>=INT_MAX){\\n            return -1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        \\n        int n=arr.size();\\n        \\n        //The i-th index of two vectors below will store the minlength of subarray having sum equal to target and ending and starting at i respectively, if there is no such subarray fill it with INT_MAX\\n        vector<int> subarrayEndingAt(n,INT_MAX);\\n        vector<int> subarrayStartingAt(n,INT_MAX);\\n        \\n        \\n        //The classical way of finding the min lenght of subarray ending at index i and having sum equal to target :\\n        //We store the sum of prefixes in a map along with the index the prefix is upto\\n        unordered_map<int,int> mp;\\n        mp[0]=-1;           //to handel cases when prefix is equal to target itself\\n        \\n        //the accumulator of the prefix sums\\n        int curr_prefix_sum=0;\\n        \\n        for(int i=0;i<n;i++){\\n            curr_prefix_sum+=arr[i];\\n            \\n            //check if any such prefix is there in the map which when subtracted from the current prefix results in the target value i.e target + prefix == curr_prefix_sum\\n            //if it is there then it simply means there is a subarray ending at i that has sum equal to target so ve store the length of this subarray at this index\\n            if(mp.count(curr_prefix_sum-target)) subarrayEndingAt[i]=i-mp[curr_prefix_sum-target];\\n            \\n            //we insert the curr_prefix_sum in the map for the further use\\n            mp[curr_prefix_sum]=i;\\n        }\\n        \\n        \\n        //We do the same thing above in the reverse manner / to make it even more effective we can make this second vector from the first vector itself but just to keep it simple we do use the same method int \\n        //reverse direction now using suffixes instead of prefixes\\n        unordered_map<int,int> mp2;\\n        mp2[0]=n;\\n        \\n        int curr_suffix_sum=0;\\n        for(int i=n-1;i>=0;i--){\\n            curr_suffix_sum+=arr[i];\\n            if(mp2.count(curr_suffix_sum-target)) subarrayStartingAt[i]=mp2[curr_suffix_sum-target]-i;\\n            mp2[curr_suffix_sum]=i;\\n        }\\n        \\n        \\n        \\n        \\n        long long ans=INT_MAX;\\n        \\n        //this will store the min length of subarray that has already appeared before the current index\\n        int minEndingBefore=INT_MAX;\\n        \\n        for(int i=0;i<n;i++){\\n            //we take the length of subarray starting at current index and add length of subarray that has already ended and has minimum length and ,update the ans as the minimum of this value or previous answer\\n            ans=min(ans,(long long)subarrayStartingAt[i]+minEndingBefore);\\n            \\n            //updating minEndingBefore for further use\\n            minEndingBefore=min(minEndingBefore,subarrayEndingAt[i]);\\n        }\\n        \\n        \\n        //if there was not any answer and we were just having INT_MAX in array / or just 1 subarray or overlapping subarrays the ans would be greater than INT_MAX so return -1\\n        if(ans>=INT_MAX){\\n            return -1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687232,
                "title": "javascript-a-little-slow-comments-welcome",
                "content": "```\\nvar minSumOfLengths = function(arr, target) {\\n    let allSubs = [] // [length:[start,end]]\\n    \\n    let result = Infinity\\n    let currentSum = 0\\n    let left = 0\\n    let right = 0\\n    while (right < arr.length){\\n        currentSum += arr[right]\\n        while (currentSum > target) {\\n            currentSum -= arr[left]\\n            left++\\n        }\\n        if (currentSum === target){\\n            let entry = [right-left+1,[left,right]]\\n            allSubs.push(entry)\\n        }\\n        right++\\n    }\\n    allSubs.sort((a,b) => a[0]-b[0]) \\n    if (allSubs.length < 2) return -1\\n\\n    // shortest 2 intervals not overlapping\\n    for (let i = 0; i < allSubs.length-1; i++){\\n        let first = allSubs[i]\\n        let firstStart = first[1][0]\\n        let firstEnd = first[1][1]\\n        for (let j = i+1; j< allSubs.length; j++){\\n            let second = allSubs[j]\\n            let secondStart = second[1][0]\\n            let secondEnd = second[1][1]\\n            if ((firstEnd < secondStart && firstStart < secondStart) || (secondEnd < firstStart && secondStart < firstStart)){\\n                let currLength = first[0]+second[0]\\n                result = Math.min(result, currLength)\\n                break\\n            } \\n        }\\n    }\\n    return result === Infinity ? -1 : result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minSumOfLengths = function(arr, target) {\\n    let allSubs = [] // [length:[start,end]]\\n    \\n    let result = Infinity\\n    let currentSum = 0\\n    let left = 0\\n    let right = 0\\n    while (right < arr.length){\\n        currentSum += arr[right]\\n        while (currentSum > target) {\\n            currentSum -= arr[left]\\n            left++\\n        }\\n        if (currentSum === target){\\n            let entry = [right-left+1,[left,right]]\\n            allSubs.push(entry)\\n        }\\n        right++\\n    }\\n    allSubs.sort((a,b) => a[0]-b[0]) \\n    if (allSubs.length < 2) return -1\\n\\n    // shortest 2 intervals not overlapping\\n    for (let i = 0; i < allSubs.length-1; i++){\\n        let first = allSubs[i]\\n        let firstStart = first[1][0]\\n        let firstEnd = first[1][1]\\n        for (let j = i+1; j< allSubs.length; j++){\\n            let second = allSubs[j]\\n            let secondStart = second[1][0]\\n            let secondEnd = second[1][1]\\n            if ((firstEnd < secondStart && firstStart < secondStart) || (secondEnd < firstStart && secondStart < firstStart)){\\n                let currLength = first[0]+second[0]\\n                result = Math.min(result, currLength)\\n                break\\n            } \\n        }\\n    }\\n    return result === Infinity ? -1 : result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 687061,
                "title": "java-10-ms-o-n-sliding-window",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int start = arr.length - 1, end = arr.length - 1, sum = 0, minLenSoFar = Integer.MAX_VALUE;\\n\\n\\t\\t// The i\\'th element of this array will hold the minimum length of all subarray\\'s on it\\'s right\\n\\t\\t// whose sum = target.\\n\\t\\tint[] minLen = new int[arr.length];\\n\\n\\t\\t// Start from the end. Keep track of min length of subarray whose sum is equal to target.\\n        for (start = arr.length - 1; start >= 0; start--) {\\n            sum = sum + arr[start];\\n            if (sum != target) {\\n                minLen[start] = minLenSoFar == Integer.MAX_VALUE ? -1 : minLenSoFar;\\n            }\\n            while (sum >= target) {\\n                if (sum == target) {\\n                    minLenSoFar = Math.min(minLenSoFar, end-start+1);\\n                    minLen[start] = minLenSoFar;\\n                }\\n                sum = sum - arr[end];\\n                end--;\\n            }\\n        }\\n        \\n        \\n        int ans = Integer.MAX_VALUE;\\n        start = 0;  sum = 0;\\n\\t\\t// Start from the beginning. For every subarray, whose sum = target, \\n\\t\\t// add the min length of valid subarray from right and update ans.\\n        for (end = 0; end < arr.length-1; end++) {\\n            if (minLen[end+1] == -1) {\\n                break;\\n            }\\n            sum = sum + arr[end];\\n            while (sum >= target) {\\n                if (sum == target) {\\n                    ans = Math.min(ans, (end-start+1) + minLen[end+1]);\\n                }\\n                sum = sum - arr[start];\\n                start++;\\n            }\\n        }\\n        return (ans == Integer.MAX_VALUE) ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int start = arr.length - 1, end = arr.length - 1, sum = 0, minLenSoFar = Integer.MAX_VALUE;\\n\\n\\t\\t// The i\\'th element of this array will hold the minimum length of all subarray\\'s on it\\'s right\\n\\t\\t// whose sum = target.\\n\\t\\tint[] minLen = new int[arr.length];\\n\\n\\t\\t// Start from the end. Keep track of min length of subarray whose sum is equal to target.\\n        for (start = arr.length - 1; start >= 0; start--) {\\n            sum = sum + arr[start];\\n            if (sum != target) {\\n                minLen[start] = minLenSoFar == Integer.MAX_VALUE ? -1 : minLenSoFar;\\n            }\\n            while (sum >= target) {\\n                if (sum == target) {\\n                    minLenSoFar = Math.min(minLenSoFar, end-start+1);\\n                    minLen[start] = minLenSoFar;\\n                }\\n                sum = sum - arr[end];\\n                end--;\\n            }\\n        }\\n        \\n        \\n        int ans = Integer.MAX_VALUE;\\n        start = 0;  sum = 0;\\n\\t\\t// Start from the beginning. For every subarray, whose sum = target, \\n\\t\\t// add the min length of valid subarray from right and update ans.\\n        for (end = 0; end < arr.length-1; end++) {\\n            if (minLen[end+1] == -1) {\\n                break;\\n            }\\n            sum = sum + arr[end];\\n            while (sum >= target) {\\n                if (sum == target) {\\n                    ans = Math.min(ans, (end-start+1) + minLen[end+1]);\\n                }\\n                sum = sum - arr[start];\\n                start++;\\n            }\\n        }\\n        return (ans == Integer.MAX_VALUE) ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 686904,
                "title": "java-super-short-solution",
                "content": "```\\n    public int minSumOfLengths(int[] a, int t) {\\n        int[] map = new int[a.length];\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0, j = 0, sum = 0; i < a.length; i++) {\\n            if(i > 0) map[i] = map[i-1];\\n            sum += a[i];\\n            while(sum > t) sum -= a[j++];\\n            if(sum == t) {\\n                int len = i-j + 1;\\n                if(j > 0 && map[j-1] != 0) res = Math.min(res, len + map[j-1]);\\n                map[i] = len;\\n            }\\n            if(i > 0 && map[i-1] != 0) map[i] = Math.min(map[i], map[i-1]);\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSumOfLengths(int[] a, int t) {\\n        int[] map = new int[a.length];\\n        int res = Integer.MAX_VALUE;\\n        for(int i = 0, j = 0, sum = 0; i < a.length; i++) {\\n            if(i > 0) map[i] = map[i-1];\\n            sum += a[i];\\n            while(sum > t) sum -= a[j++];\\n            if(sum == t) {\\n                int len = i-j + 1;\\n                if(j > 0 && map[j-1] != 0) res = Math.min(res, len + map[j-1]);\\n                map[i] = len;\\n            }\\n            if(i > 0 && map[i-1] != 0) map[i] = Math.min(map[i], map[i-1]);\\n        }\\n        return res == Integer.MAX_VALUE ? -1 : res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 686113,
                "title": "another-javascript-solution",
                "content": "I can only find one solution for JavaScript, so I decided to share mine.\\n```\\nvar minSumOfLengths = function(arr, target) {\\n  let n = arr.length;\\n  let a = [];\\n  let i = 0;\\n  let j = 0;\\n  let sum = 0;\\n  while(i < n) {\\n    sum += arr[i];\\n    while (sum > target) {\\n      sum -= arr[j];\\n      j++;\\n    }\\n    if (sum === target) {\\n      a.push([i-j+1,j,i]);\\n    }\\n    \\n    i++;\\n  }\\n\\n  if (a.length >= 2) {\\n    a.sort((x,y) => x[0] - y[0]);\\n    for(let i = 0; i < a.length-1; i++) {\\n      for(let j = i+1; j < a.length; j++) {\\n        let [v1,j1,i1] = a[i];\\n        let [v2,j2,i2] = a[j];\\n        if (i1 < j2 || j1 > i2) {\\n          return v1 + v2;\\n        }\\n      }\\n    } \\n  }\\n  return -1;\\n};",
                "solutionTags": [],
                "code": "I can only find one solution for JavaScript, so I decided to share mine.\\n```\\nvar minSumOfLengths = function(arr, target) {\\n  let n = arr.length;\\n  let a = [];\\n  let i = 0;\\n  let j = 0;\\n  let sum = 0;\\n  while(i < n) {\\n    sum += arr[i];\\n    while (sum > target) {\\n      sum -= arr[j];\\n      j++;\\n    }\\n    if (sum === target) {\\n      a.push([i-j+1,j,i]);\\n    }\\n    \\n    i++;\\n  }\\n\\n  if (a.length >= 2) {\\n    a.sort((x,y) => x[0] - y[0]);\\n    for(let i = 0; i < a.length-1; i++) {\\n      for(let j = i+1; j < a.length; j++) {\\n        let [v1,j1,i1] = a[i];\\n        let [v2,j2,i2] = a[j];\\n        if (i1 < j2 || j1 > i2) {\\n          return v1 + v2;\\n        }\\n      }\\n    } \\n  }\\n  return -1;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 686079,
                "title": "python-prefix-sum-and-heap",
                "content": "- Collect all potential sub-arrays using prefix sums hash map\\n- Filter out the overlaps, only keep the minimum sub-array among the overlaps\\n- Use max heap with size 2 to find out the minimum two sums\\n- Return the sum of the 2 sums in the heap, if heap doesn\\'t have 2 sums, return -1 as it cannot find 2 sub-arrays\\n\\n```python\\ndef minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        pre_sums = {0: 0}\\n        curr_sum = 0\\n        candidates = [] \\n        \\n        # Collect all potential candidates\\n        for i in range(len(arr)):\\n            curr_sum += arr[i]    \\n            if curr_sum - target in pre_sums:\\n                candidates.append([pre_sums[curr_sum-target], i])\\n            pre_sums[curr_sum] = i + 1\\n            \\n        # Filter out overlaps, keep the minimum among the overlaps\\n        non_overlaps = [] \\n        for start, end in candidates: \\n            if non_overlaps and start <= non_overlaps[-1][1]:\\n                if non_overlaps[-1][1] - non_overlaps[-1][0] + 1 > end - start + 1:\\n                    non_overlaps.pop()\\n                else:\\n                    continue    \\n            non_overlaps.append([start, end])        \\n            \\n        heap = []\\n        for start, end in non_overlaps:\\n            heapq.heappush(heap, -(end-start+1))\\n            if len(heap) > 2:\\n                heapq.heappop(heap)\\n\\t\\t\\t\\t\\n        return -sum(heap) if len(heap) >= 2 else -1\\n```\\n\\nTime: 100%\\nSpace: 25%",
                "solutionTags": [],
                "code": "```python\\ndef minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        pre_sums = {0: 0}\\n        curr_sum = 0\\n        candidates = [] \\n        \\n        # Collect all potential candidates\\n        for i in range(len(arr)):\\n            curr_sum += arr[i]    \\n            if curr_sum - target in pre_sums:\\n                candidates.append([pre_sums[curr_sum-target], i])\\n            pre_sums[curr_sum] = i + 1\\n            \\n        # Filter out overlaps, keep the minimum among the overlaps\\n        non_overlaps = [] \\n        for start, end in candidates: \\n            if non_overlaps and start <= non_overlaps[-1][1]:\\n                if non_overlaps[-1][1] - non_overlaps[-1][0] + 1 > end - start + 1:\\n                    non_overlaps.pop()\\n                else:\\n                    continue    \\n            non_overlaps.append([start, end])        \\n            \\n        heap = []\\n        for start, end in non_overlaps:\\n            heapq.heappush(heap, -(end-start+1))\\n            if len(heap) > 2:\\n                heapq.heappop(heap)\\n\\t\\t\\t\\t\\n        return -sum(heap) if len(heap) >= 2 else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 685858,
                "title": "python-sliding-window",
                "content": "\\tclass Solution:\\n\\t\\tfrom collections import defaultdict\\n\\t\\tdef minSumOfLengths(self, arr: List[int], target: int) -> int:\\n\\t\\t\\td = defaultdict(lambda : float(\\'inf\\'))\\n\\t\\t\\tleft = 0\\n\\t\\t\\ttotal = 0\\n\\t\\t\\tres = float(\\'inf\\')\\n\\t\\t\\tfor right in range(len(arr)):\\n\\t\\t\\t\\ttotal += arr[right]\\n\\t\\t\\t\\twhile total > target:\\n\\t\\t\\t\\t\\ttotal -= arr[left]\\n\\t\\t\\t\\t\\tleft+=1\\n\\n\\t\\t\\t\\tif total == target:\\n\\t\\t\\t\\t\\td[right] = right-left+1\\n\\t\\t\\t\\t\\tres = min(res,d[left-1]+right-left+1)\\n\\t\\t\\t\\td[right] = min(d[right],d[right-1])\\n\\t\\t\\treturn -1 if res == float(\\'inf\\') else res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tfrom collections import defaultdict\\n\\t\\tdef minSumOfLengths(self, arr: List[int], target: int) -> int:\\n\\t\\t\\td = defaultdict(lambda : float(\\'inf\\'))\\n\\t\\t\\tleft = 0\\n\\t\\t\\ttotal = 0\\n\\t\\t\\tres = float(\\'inf\\')\\n\\t\\t\\tfor right in range(len(arr)):\\n\\t\\t\\t\\ttotal += arr[right]\\n\\t\\t\\t\\twhile total > target:\\n\\t\\t\\t\\t\\ttotal -= arr[left]\\n\\t\\t\\t\\t\\tleft+=1\\n\\n\\t\\t\\t\\tif total == target:\\n\\t\\t\\t\\t\\td[right] = right-left+1\\n\\t\\t\\t\\t\\tres = min(res,d[left-1]+right-left+1)\\n\\t\\t\\t\\td[right] = min(d[right],d[right-1])\\n\\t\\t\\treturn -1 if res == float(\\'inf\\') else res",
                "codeTag": "Java"
            },
            {
                "id": 685812,
                "title": "python-two-time-two-pointers-interval-array-no-hashmap-o-n",
                "content": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        m = len(arr)\\n\\t\\t# find all intervals with sum == target\\n        intervals = []\\n        i,j =0,0\\n        summ = 0\\n        while j < m:\\n            summ += arr[j]\\n            j += 1\\n            while i<j and summ >= target:\\n                if summ == target:\\n                    intervals.append((i,j-1))\\n                summ -= arr[i]\\n                i += 1   \\n        if len(intervals) <= 1:\\n            return -1\\n\\t\\t\\n\\t\\t# building mins array. mins[i] = length of minimum length interval \\n\\t\\t# among intervals[i], intervals[i+1], intervals[i+2] ...... intervals[n-1]\\n        n = len(intervals)\\n        mins = [0]*n\\n        mins[n-1] = intervals[n-1][1] - intervals[n-1][0] + 1\\n        for i in range(n-2,-1,-1):\\n            mins[i] = min(intervals[i][1]-intervals[i][0] + 1, mins[i+1])\\n         \\n\\t\\t # sliding window over intervals to find first non overlapping interval j for current interval i \\n\\t\\t # and updating ans if current interval i contributes to ans\\n        ans = 999999999\\n        i,j = 0,1\\n        while j < n:\\n            while j < n and intervals[i][1] >= intervals[j][0]:\\n                j += 1\\n            if j == n:\\n                if ans == 999999999:\\n                    return -1\\n                return ans\\n\\t\\t\\t# ans update\\n            ans = min(intervals[i][1]-intervals[i][0]+1+mins[j],ans)\\n            i += 1\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        m = len(arr)\\n\\t\\t# find all intervals with sum == target\\n        intervals = []\\n        i,j =0,0\\n        summ = 0\\n        while j < m:\\n            summ += arr[j]\\n            j += 1\\n            while i<j and summ >= target:\\n                if summ == target:\\n                    intervals.append((i,j-1))\\n                summ -= arr[i]\\n                i += 1   \\n        if len(intervals) <= 1:\\n            return -1\\n\\t\\t\\n\\t\\t# building mins array. mins[i] = length of minimum length interval \\n\\t\\t# among intervals[i], intervals[i+1], intervals[i+2] ...... intervals[n-1]\\n        n = len(intervals)\\n        mins = [0]*n\\n        mins[n-1] = intervals[n-1][1] - intervals[n-1][0] + 1\\n        for i in range(n-2,-1,-1):\\n            mins[i] = min(intervals[i][1]-intervals[i][0] + 1, mins[i+1])\\n         \\n\\t\\t # sliding window over intervals to find first non overlapping interval j for current interval i \\n\\t\\t # and updating ans if current interval i contributes to ans\\n        ans = 999999999\\n        i,j = 0,1\\n        while j < n:\\n            while j < n and intervals[i][1] >= intervals[j][0]:\\n                j += 1\\n            if j == n:\\n                if ans == 999999999:\\n                    return -1\\n                return ans\\n\\t\\t\\t# ans update\\n            ans = min(intervals[i][1]-intervals[i][0]+1+mins[j],ans)\\n            i += 1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 685675,
                "title": "cpp-prefix-sum-hash-map-naive-solution-easy-to-understand",
                "content": "The following solution is a very easy and naive solution. Though I could not do it in the biweekly contest due to time constraint. I soon understood that prefix sum is to be used.\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        for(int i = 1;i<n;i++)  //Prefix Sum\\n            arr[i]+=arr[i-1];\\n        vector<pair<int,pair<int,int> > > interval;\\n        unordered_map<int,int> mp;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(arr[i] == target)    interval.push_back({i+1,{0,i}});\\n            if(mp.find(arr[i]-target)!=mp.end())    interval.push_back({i-mp[arr[i]-target],{mp[arr[i]-target]+1,i}});\\n\\t\\t\\t\\tmp[arr[i]] = i;\\n        }\\n        int ans = 0;\\n        if(interval.size()<2)   return -1;\\n        sort(interval.begin(),interval.end());\\n\\t\\tans += interval[0].first;\\n        int st = interval[0].second.first;  int en = interval[0].second.second;\\n        for(int i = 1;i<interval.size();i++)   {\\n            int st1 = interval[i].second.first; int en1 = interval[i].second.second;\\n            if(st>st1 and st>en1)\\n                return (ans+interval[i].first);\\n            else if(st1>st and st1>en)\\n                return (ans+interval[i].first);\\n           \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        for(int i = 1;i<n;i++)  //Prefix Sum\\n            arr[i]+=arr[i-1];\\n        vector<pair<int,pair<int,int> > > interval;\\n        unordered_map<int,int> mp;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(arr[i] == target)    interval.push_back({i+1,{0,i}});\\n            if(mp.find(arr[i]-target)!=mp.end())    interval.push_back({i-mp[arr[i]-target],{mp[arr[i]-target]+1,i}});\\n\\t\\t\\t\\tmp[arr[i]] = i;\\n        }\\n        int ans = 0;\\n        if(interval.size()<2)   return -1;\\n        sort(interval.begin(),interval.end());\\n\\t\\tans += interval[0].first;\\n        int st = interval[0].second.first;  int en = interval[0].second.second;\\n        for(int i = 1;i<interval.size();i++)   {\\n            int st1 = interval[i].second.first; int en1 = interval[i].second.second;\\n            if(st>st1 and st>en1)\\n                return (ans+interval[i].first);\\n            else if(st1>st and st1>en)\\n                return (ans+interval[i].first);\\n           \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685641,
                "title": "prefix-sum-with-hashmap-in-java-o-n-time-and-space",
                "content": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n       int n = arr.length;\\n       int []pre = new int[n];\\n       Arrays.fill(pre,n+1);\\n        HashMap<Integer,Integer>prefix = new HashMap<>();\\n        prefix.put(0,-1);\\n        int pref_sum = 0;\\n        int res = n+1;\\n        for(int i=0;i<n;i++){\\n            pref_sum+=arr[i];\\n            if(i>0) pre[i] =pre[i-1];\\n            if(prefix.containsKey(pref_sum - target)){\\n                int val = prefix.get(pref_sum - target);\\n                pre[i] = Math.min(pre[i],i - val);\\n                if(val!=-1 && pre[val]!= n+1){\\n                    res = Math.min(res, pre[val] + i - val);\\n                }\\n            }\\n            prefix.put(pref_sum,i);\\n        }\\n        if(res == n+1) return -1;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n       int n = arr.length;\\n       int []pre = new int[n];\\n       Arrays.fill(pre,n+1);\\n        HashMap<Integer,Integer>prefix = new HashMap<>();\\n        prefix.put(0,-1);\\n        int pref_sum = 0;\\n        int res = n+1;\\n        for(int i=0;i<n;i++){\\n            pref_sum+=arr[i];\\n            if(i>0) pre[i] =pre[i-1];\\n            if(prefix.containsKey(pref_sum - target)){\\n                int val = prefix.get(pref_sum - target);\\n                pre[i] = Math.min(pre[i],i - val);\\n                if(val!=-1 && pre[val]!= n+1){\\n                    res = Math.min(res, pre[val] + i - val);\\n                }\\n            }\\n            prefix.put(pref_sum,i);\\n        }\\n        if(res == n+1) return -1;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685563,
                "title": "golang-sliding-window-solution-with-runnable-tests-on-playground",
                "content": "https://play.golang.org/p/wPd7GMfSrAh\\n\\n```go\\npackage solution\\n\\nimport \"sort\"\\n\\nfunc minSumOfLengths(arr []int, target int) int {\\n\\tsum := 0\\n\\tj := 0\\n\\n\\trr := [][2]int{}\\n\\t// use sliding window, to get list of\\n\\t// subarrays with the target sum\\n\\tfor i, v := range arr {\\n\\t\\tsum += v\\n\\n\\t\\tfor ; sum > target; j++ {\\n\\t\\t\\tsum -= arr[j]\\n\\t\\t}\\n\\n\\t\\tif sum == target {\\n\\t\\t\\trr = append(rr, [2]int{j, i})\\n\\t\\t}\\n\\t}\\n\\n\\tif len(rr) < 2 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\t// helper func to get size of\\n\\t// subarray\\n\\tsize := func(v [2]int) int {\\n\\t\\treturn v[1] - v[0] + 1\\n\\t}\\n\\n\\t// sort list subarrays by their length\\n\\tsort.Slice(rr, func(i, j int) bool {\\n\\t\\tf, s := rr[i], rr[j]\\n\\t\\tfs, ss := size(f), size(s)\\n\\n\\t\\tif fs == ss {\\n\\t\\t\\treturn f[0] < s[0]\\n\\t\\t}\\n\\n\\t\\treturn fs < ss\\n\\t})\\n\\n\\tmin := -1\\n\\t// look for two shortest subarrays that\\n\\t// do not intersect\\n\\tfor i := 0; i < len(rr); i++ {\\n\\t\\tf := rr[i]\\n\\t\\tfs := size(f)\\n\\n\\t\\tfor j := i + 1; j < len(rr); j++ {\\n\\t\\t\\ts := rr[j]\\n\\t\\t\\tss := size(s)\\n\\t\\t\\tl := fs + ss\\n\\n\\t\\t\\t// optimization, not to compute the items\\n\\t\\t\\t// that are already bigger then minimum we found\\n\\t\\t\\t// before\\n\\t\\t\\tif min != -1 && l >= min {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\n\\t\\t\\t// check if two subarrays are intersecting\\n\\t\\t\\tif (s[0] > f[1] && f[0] <= f[1]) || (f[0] > s[1] && s[0] <= s[1]) {\\n\\n\\t\\t\\t\\t// save lenghts of subarrays if it is smaller theen minimum\\n\\t\\t\\t\\tif l < min || min == -1 {\\n\\t\\t\\t\\t\\tmin = l\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn min\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\npackage solution\\n\\nimport \"sort\"\\n\\nfunc minSumOfLengths(arr []int, target int) int {\\n\\tsum := 0\\n\\tj := 0\\n\\n\\trr := [][2]int{}\\n\\t// use sliding window, to get list of\\n\\t// subarrays with the target sum\\n\\tfor i, v := range arr {\\n\\t\\tsum += v\\n\\n\\t\\tfor ; sum > target; j++ {\\n\\t\\t\\tsum -= arr[j]\\n\\t\\t}\\n\\n\\t\\tif sum == target {\\n\\t\\t\\trr = append(rr, [2]int{j, i})\\n\\t\\t}\\n\\t}\\n\\n\\tif len(rr) < 2 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\t// helper func to get size of\\n\\t// subarray\\n\\tsize := func(v [2]int) int {\\n\\t\\treturn v[1] - v[0] + 1\\n\\t}\\n\\n\\t// sort list subarrays by their length\\n\\tsort.Slice(rr, func(i, j int) bool {\\n\\t\\tf, s := rr[i], rr[j]\\n\\t\\tfs, ss := size(f), size(s)\\n\\n\\t\\tif fs == ss {\\n\\t\\t\\treturn f[0] < s[0]\\n\\t\\t}\\n\\n\\t\\treturn fs < ss\\n\\t})\\n\\n\\tmin := -1\\n\\t// look for two shortest subarrays that\\n\\t// do not intersect\\n\\tfor i := 0; i < len(rr); i++ {\\n\\t\\tf := rr[i]\\n\\t\\tfs := size(f)\\n\\n\\t\\tfor j := i + 1; j < len(rr); j++ {\\n\\t\\t\\ts := rr[j]\\n\\t\\t\\tss := size(s)\\n\\t\\t\\tl := fs + ss\\n\\n\\t\\t\\t// optimization, not to compute the items\\n\\t\\t\\t// that are already bigger then minimum we found\\n\\t\\t\\t// before\\n\\t\\t\\tif min != -1 && l >= min {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\n\\t\\t\\t// check if two subarrays are intersecting\\n\\t\\t\\tif (s[0] > f[1] && f[0] <= f[1]) || (f[0] > s[1] && s[0] <= s[1]) {\\n\\n\\t\\t\\t\\t// save lenghts of subarrays if it is smaller theen minimum\\n\\t\\t\\t\\tif l < min || min == -1 {\\n\\t\\t\\t\\t\\tmin = l\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn min\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 685533,
                "title": "python3-faster-than-100-00-prefix-sum-hashmap",
                "content": "```\\nclass Solution:            \\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        # Part 1: find all subarrays with target sum using prefix-sum approach\\n        subarrays = []\\n        prefix_sum = 0\\n        sum2idx = {}\\n        for i in range(len(arr)):\\n            prefix_sum += arr[i]\\n            # check if prefix subarray sums to target\\n            if prefix_sum == target:\\n                length, borders = i + 1, [0, i]\\n                subarrays.append((length, borders))\\n            # check if some subarray with target sum ends at current idx\\n            if prefix_sum - target in sum2idx:\\n                length = i - sum2idx[prefix_sum - target]\\n                borders = (sum2idx[prefix_sum - target] + 1, i)\\n                subarrays.append((length, borders))\\n            # remember index of current prefix sum\\n            sum2idx[prefix_sum] = i\\n\\t\\t# ==============================================================\\n        # Part2: find minimal common length of non-overlapping subarrays\\n        if len(subarrays) < 2:\\n            return -1\\n        subarrays.sort(key=lambda x: x[0])\\n        for i in range(len(subarrays) - 1):\\n            len1, borders1 = subarrays[i]\\n            for j in range(i + 1, len(subarrays)):\\n                len2, borders2 = subarrays[j]\\n                if borders1[1] < borders2[0] or borders1[0] > borders2[1]:\\n                    return len1 + len2\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:            \\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        # Part 1: find all subarrays with target sum using prefix-sum approach\\n        subarrays = []\\n        prefix_sum = 0\\n        sum2idx = {}\\n        for i in range(len(arr)):\\n            prefix_sum += arr[i]\\n            # check if prefix subarray sums to target\\n            if prefix_sum == target:\\n                length, borders = i + 1, [0, i]\\n                subarrays.append((length, borders))\\n            # check if some subarray with target sum ends at current idx\\n            if prefix_sum - target in sum2idx:\\n                length = i - sum2idx[prefix_sum - target]\\n                borders = (sum2idx[prefix_sum - target] + 1, i)\\n                subarrays.append((length, borders))\\n            # remember index of current prefix sum\\n            sum2idx[prefix_sum] = i\\n\\t\\t# ==============================================================\\n        # Part2: find minimal common length of non-overlapping subarrays\\n        if len(subarrays) < 2:\\n            return -1\\n        subarrays.sort(key=lambda x: x[0])\\n        for i in range(len(subarrays) - 1):\\n            len1, borders1 = subarrays[i]\\n            for j in range(i + 1, len(subarrays)):\\n                len2, borders2 = subarrays[j]\\n                if borders1[1] < borders2[0] or borders1[0] > borders2[1]:\\n                    return len1 + len2\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685501,
                "title": "c-o-n-prefix-sum",
                "content": "Do prefix sum from left to right and right to left.\\n\\nright array can be eliminated.\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        \\n        vector<int> left(n);\\n        unordered_map<int, int> preSums;\\n        preSums[0] = -1;\\n        for (int i = 0, preSum = 0, m = INT_MAX; i < n; i++) {\\n            preSum += arr[i];\\n            if (preSums.find(preSum - target) != preSums.end()) {\\n                m = min(m, i - preSums[preSum - target]);\\n            }\\n            left[i] = m;\\n            preSums[preSum] = i;\\n        }\\n        \\n        vector<int> right(n);\\n        unordered_map<int, int> postSums;\\n        postSums[0] = n;\\n        for (int i = n - 1, postSum = 0, m = INT_MAX; i >= 0; i--) {\\n            postSum += arr[i];\\n            if (postSums.find(postSum - target) != postSums.end()) {\\n                m = min(m, postSums[postSum - target] - i);\\n            }\\n            right[i] = m;\\n            postSums[postSum] = i;\\n        }\\n        \\n        int result = INT_MAX;\\n        for (int i = 0; i + 1 < n; i++) {\\n            if (left[i] < INT_MAX && right[i + 1] < INT_MAX) {\\n                result = min(result, left[i] + right[i + 1]);\\n            }\\n        }\\n        if (result == INT_MAX) {\\n            return -1;\\n        } else {\\n            return result;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int n = arr.size();\\n        \\n        vector<int> left(n);\\n        unordered_map<int, int> preSums;\\n        preSums[0] = -1;\\n        for (int i = 0, preSum = 0, m = INT_MAX; i < n; i++) {\\n            preSum += arr[i];\\n            if (preSums.find(preSum - target) != preSums.end()) {\\n                m = min(m, i - preSums[preSum - target]);\\n            }\\n            left[i] = m;\\n            preSums[preSum] = i;\\n        }\\n        \\n        vector<int> right(n);\\n        unordered_map<int, int> postSums;\\n        postSums[0] = n;\\n        for (int i = n - 1, postSum = 0, m = INT_MAX; i >= 0; i--) {\\n            postSum += arr[i];\\n            if (postSums.find(postSum - target) != postSums.end()) {\\n                m = min(m, postSums[postSum - target] - i);\\n            }\\n            right[i] = m;\\n            postSums[postSum] = i;\\n        }\\n        \\n        int result = INT_MAX;\\n        for (int i = 0; i + 1 < n; i++) {\\n            if (left[i] < INT_MAX && right[i + 1] < INT_MAX) {\\n                result = min(result, left[i] + right[i + 1]);\\n            }\\n        }\\n        if (result == INT_MAX) {\\n            return -1;\\n        } else {\\n            return result;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685479,
                "title": "c-sliding-window-binary-search",
                "content": "First find the Intervals having sum equal to target which can be done using sliding window.\\nIncrease the slide on right side till sum is less than target .then again decrease the window till sum exceeds the target and keep checking if sum is equal to target or not. If it is equal store this interval.\\nthen we should also store what is the minium interval length till i\\'th interval which can be easily calculated if we traverse from right side.\\nThis is required because for an interval we can select other interval if and only if other interval is not overlapping with the current interval. So we can select any interval after getting first non-overlapping interval there fore we need to store the min length till here so that we can get min length in O(1)\\n\\nNow all we need is to find non-overlapping interval for ith interval using Binary Search as start will be in increasing order.\\n\\nDo comment any improvements. :-)\\n\\n```\\n#define F first\\n#define S second\\ntypedef pair<int, int> pr;\\ntypedef vector<int> VI;\\ntypedef vector<pr> VP;\\n#define EB emplace_back\\n#define PB push_back\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& v, int target) {\\n        int n = v.size();\\n        int i = 0,j = 0,sum = 0;\\n        VP interval; // stores start and end of an interval\\n        while(true){\\n            int pi = i,pj = j;\\n            if(j < n && sum < target){\\n                sum += v[j];\\n                j++;\\n            }else if(i < n && sum > target){\\n                sum -= v[i];\\n                i++;\\n            }\\n            if(sum == target){\\n                interval.EB(i,j-1); //insert this interval to the interval vector\\n                sum-=v[i];\\n                i++;\\n            }\\n            if(pi==i && pj==j){\\n                break;\\n            }\\n        }\\n        int req=INT_MAX; \\n        int mp[interval.size()]; // stores min till i\\'th interval from right side\\n        for(int i=interval.size()-1;i>=0;i--){\\n            if(i==interval.size()-1){\\n                mp[i]=interval[i].S-interval[i].F+1;\\n            }else{\\n                mp[i]=min(mp[i+1],interval[i].S-interval[i].F+1);\\n            }\\n        }\\n        \\n        for(int i=0;i<interval.size();i++){\\n            int low =i+1,high=interval.size()-1; // for ith interval find first non overlaping interval on right side of it\\n            int reqin=INT_MAX;\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                if(interval[mid].F>interval[i].S){ //means non-overlaping with i\\'th interval\\n                    reqin=min(reqin,mid);\\n                    high=mid-1;\\n                }else{\\n                    low=mid+1;\\n                }\\n            }\\n            if(reqin<interval.size()){ // if we got a a non-overlapping interval\\n                req=min(req,interval[i].S-interval[i].F+1+mp[reqin]); //total length is length of current interval and min length \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//interval on right side of first non-overlapping interval which is stored in mp\\n            }\\n        }\\n        if(req==INT_MAX)req=-1;\\n        return req;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define F first\\n#define S second\\ntypedef pair<int, int> pr;\\ntypedef vector<int> VI;\\ntypedef vector<pr> VP;\\n#define EB emplace_back\\n#define PB push_back\\n\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& v, int target) {\\n        int n = v.size();\\n        int i = 0,j = 0,sum = 0;\\n        VP interval; // stores start and end of an interval\\n        while(true){\\n            int pi = i,pj = j;\\n            if(j < n && sum < target){\\n                sum += v[j];\\n                j++;\\n            }else if(i < n && sum > target){\\n                sum -= v[i];\\n                i++;\\n            }\\n            if(sum == target){\\n                interval.EB(i,j-1); //insert this interval to the interval vector\\n                sum-=v[i];\\n                i++;\\n            }\\n            if(pi==i && pj==j){\\n                break;\\n            }\\n        }\\n        int req=INT_MAX; \\n        int mp[interval.size()]; // stores min till i\\'th interval from right side\\n        for(int i=interval.size()-1;i>=0;i--){\\n            if(i==interval.size()-1){\\n                mp[i]=interval[i].S-interval[i].F+1;\\n            }else{\\n                mp[i]=min(mp[i+1],interval[i].S-interval[i].F+1);\\n            }\\n        }\\n        \\n        for(int i=0;i<interval.size();i++){\\n            int low =i+1,high=interval.size()-1; // for ith interval find first non overlaping interval on right side of it\\n            int reqin=INT_MAX;\\n            while(low<=high){\\n                int mid=low+(high-low)/2;\\n                if(interval[mid].F>interval[i].S){ //means non-overlaping with i\\'th interval\\n                    reqin=min(reqin,mid);\\n                    high=mid-1;\\n                }else{\\n                    low=mid+1;\\n                }\\n            }\\n            if(reqin<interval.size()){ // if we got a a non-overlapping interval\\n                req=min(req,interval[i].S-interval[i].F+1+mp[reqin]); //total length is length of current interval and min length \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//interval on right side of first non-overlapping interval which is stored in mp\\n            }\\n        }\\n        if(req==INT_MAX)req=-1;\\n        return req;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685456,
                "title": "java-sliding-window-one-pass-o-n",
                "content": "Idea is similar to subarry sums equals \\'K\\', you need to find window where sum is \\'target\\' and suppose that window is from A[ind+1...i], then what is the smallest with sum equals \\'target\\' in A[0..ind]. We will be using an array where \\'dp[i]\\' to store the smallest subarray size whose sum equals target upto index \\'i\\'. \\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length - 1;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        int result = Integer.MAX_VALUE;\\n        int[] dp = new int[arr.length];  // dp[i] stores the size of the smallest subarray sum equals \\'k\\' in A[0...i]\\n        int min = Integer.MAX_VALUE;\\n        int sum = 0;\\n        for(int i = 0; i <= n; i++){\\n            sum += arr[i];\\n            if(map.containsKey(sum-target)){\\n                int ind = map.get(sum-target);\\n                int windowSize = i - ind; // Current Size of Window of sum equals Target\\n                \\n                if(ind != -1 && dp[ind] <= arr.length){\\n\\t\\t\\t\\t\\t// If current window is from [ind + 1 ... i], check if there exist a window in A[0..ind]\\n\\t\\t\\t\\t\\t// And we know dp[ind] will store the smallest window upto index = ind;\\n                    result = Math.min(res,windowSize+dp[ind]);\\n                }\\n\\t\\t\\t\\tmin = Math.min(min,windowSize); // Update if this window is smaller than previous smallest window\\n            }\\n            dp[i] = min; // Update dp[i]\\n            map.put(sum,i);\\n        }\\n        if(result > n+1) return -1;\\n        else return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        int n = arr.length - 1;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        map.put(0,-1);\\n        int result = Integer.MAX_VALUE;\\n        int[] dp = new int[arr.length];  // dp[i] stores the size of the smallest subarray sum equals \\'k\\' in A[0...i]\\n        int min = Integer.MAX_VALUE;\\n        int sum = 0;\\n        for(int i = 0; i <= n; i++){\\n            sum += arr[i];\\n            if(map.containsKey(sum-target)){\\n                int ind = map.get(sum-target);\\n                int windowSize = i - ind; // Current Size of Window of sum equals Target\\n                \\n                if(ind != -1 && dp[ind] <= arr.length){\\n\\t\\t\\t\\t\\t// If current window is from [ind + 1 ... i], check if there exist a window in A[0..ind]\\n\\t\\t\\t\\t\\t// And we know dp[ind] will store the smallest window upto index = ind;\\n                    result = Math.min(res,windowSize+dp[ind]);\\n                }\\n\\t\\t\\t\\tmin = Math.min(min,windowSize); // Update if this window is smaller than previous smallest window\\n            }\\n            dp[i] = min; // Update dp[i]\\n            map.put(sum,i);\\n        }\\n        if(result > n+1) return -1;\\n        else return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685447,
                "title": "python-presum-hashmap-dp-with-explanation",
                "content": "For example, arr = [3,1,1,1,5,1,2,1]\\n\\n**Step 1**. Calculate presum, we get\\ncumsum = [0,3,4,5,6,11,12,14,15],\\nHere we add a \"0\" in front of the array.\\n\\n**Step 2**. create a dict D, which consists of indices of all the elements appeared in cumsum except for the first element 0.\\nD = {\\n\\t3: [1],\\n\\t4: [2],\\n\\t5: [3],\\n\\t6: [4],\\n\\t11: [5],\\n\\t12: [6],\\n\\t14: [7],\\n\\t15: [8]\\n}\\n\\n**Step 3**. Use array \"res\" to restore the minimum distance of all elements in cumsum plus \"target\", use \"inf\" to denote that for index i of cumsum, there exists no way such that cumsum[i] + target in {i+1, i+2, ... , n-1}\\nindex of res: [0,1,2,3,4,5,6,7]\\nres = [1,3,inf,inf,inf,2,2,inf]\\n\\n**Step 4**. create dp array, where dp[i] denotes the minimum distance of res[i:]\\n\\n**Step 5**. for all i in range(n), find minimum res[i] + dp[i+res[i]]\\n\\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: list, target: int) -> int:\\n        n = len(arr)\\n        inf = sys.maxsize\\n\\t\\t# calculate presum\\n        cumsum = [0] + list(itertools.accumulate(arr))\\n\\t\\t# D consists of all the indices that appeared in cumsum\\n        D = collections.defaultdict(list)\\n        for i in range(1, n + 1):\\n            D[cumsum[i]].append(i)\\n        res = []\\n        for i in range(n):\\n            if cumsum[i] + target in D:\\n                ind = bisect.bisect_left(D[cumsum[i] + target], i)\\n                res.append(D[cumsum[i] + target][ind] - i)\\n            else:\\n                res.append(inf)\\n        dp = [inf] * n\\n        dp[-1] = res[-1]\\n        for i in range(n - 1)[::-1]:\\n            if dp[i + 1] == inf:\\n                dp[i] = res[i]\\n            else:\\n                if res[i] == inf:\\n                    dp[i] = dp[i + 1]\\n                else:\\n                    dp[i] = min(dp[i + 1], res[i])\\n        ret = inf\\n        for i in range(n):\\n            if res[i] == inf or i + res[i] >= len(dp): continue\\n            ret = min(ret, res[i] + dp[i + res[i]])\\n        if ret == inf: ret = -1\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: list, target: int) -> int:\\n        n = len(arr)\\n        inf = sys.maxsize\\n\\t\\t# calculate presum\\n        cumsum = [0] + list(itertools.accumulate(arr))\\n\\t\\t# D consists of all the indices that appeared in cumsum\\n        D = collections.defaultdict(list)\\n        for i in range(1, n + 1):\\n            D[cumsum[i]].append(i)\\n        res = []\\n        for i in range(n):\\n            if cumsum[i] + target in D:\\n                ind = bisect.bisect_left(D[cumsum[i] + target], i)\\n                res.append(D[cumsum[i] + target][ind] - i)\\n            else:\\n                res.append(inf)\\n        dp = [inf] * n\\n        dp[-1] = res[-1]\\n        for i in range(n - 1)[::-1]:\\n            if dp[i + 1] == inf:\\n                dp[i] = res[i]\\n            else:\\n                if res[i] == inf:\\n                    dp[i] = dp[i + 1]\\n                else:\\n                    dp[i] = min(dp[i + 1], res[i])\\n        ret = inf\\n        for i in range(n):\\n            if res[i] == inf or i + res[i] >= len(dp): continue\\n            ret = min(ret, res[i] + dp[i + res[i]])\\n        if ret == inf: ret = -1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685437,
                "title": "python-3-sub-array-sum-and-heap",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        d={0:-1}\\n        ls=[]\\n        su=0\\n        for i in range(len(arr)):\\n            su+=arr[i]\\n            if(su-target in d):\\n                heapq.heappush(ls,[i-d[su-target],d[su-target]+1,i])\\n            d[su]=i\\n        if(len(ls)<2):\\n            return -1\\n        else:\\n            tmp=[heapq.heappop(ls)]\\n            while(ls):\\n                x=heapq.heappop(ls)\\n                for i in tmp:\\n                    if(i[2]<x[1] or x[2]<i[1] ):\\n                        return i[0]+x[0]\\n                if(x[0]==tmp[-1][0]):\\n                    tmp[-1][1]=max(tmp[-1][1],x[1])\\n                    tmp[-1][2]=min(tmp[-1][2],x[2])\\n                else:\\n                    tmp.append(x)\\n            return -1",
                "solutionTags": [],
                "code": "class Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        d={0:-1}",
                "codeTag": "Java"
            },
            {
                "id": 685396,
                "title": "c-prefix-array-using-vector-pair-for-all-possible-subarrays",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int i=1,j=1,n=arr.size(),sum=0,mini=100000000,Startindi=-1;\\n        vector<int> pre(n+1,0);\\n        pre[0]=0;\\n        for(int i=0;i<n;i++){\\n            pre[i+1]=pre[i]+arr[i];\\n        }\\n        vector<pair<int,int>> vp;\\n        pair<int,int> stInd;\\n        while(j<=n && i<=n){\\n            if(pre[j]-pre[i-1]==target){\\n                vp.push_back({i,j});\\n                mini=min(mini,j-i+1);\\n                if(mini==j-i+1)\\n                    stInd = {i,j};\\n                i++;j++;\\n            }else if(pre[j]-pre[i-1]<target){\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        if(vp.size()==0){\\n            return -1;\\n        }\\n        int c=100000000;\\n        for(int i=0;i<vp.size();i++){\\n            if((stInd.first <= vp[i].first &&  stInd.second >= vp[i].first)||(stInd.first <= vp[i].second &&  stInd.second >= vp[i].second)){\\n                \\n            }else{\\n                c=min(c,vp[i].second-vp[i].first+1);\\n            }\\n        }\\n        if(c==100000000){\\n            return -1;\\n        }    \\n        return mini+c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int i=1,j=1,n=arr.size(),sum=0,mini=100000000,Startindi=-1;\\n        vector<int> pre(n+1,0);\\n        pre[0]=0;\\n        for(int i=0;i<n;i++){\\n            pre[i+1]=pre[i]+arr[i];\\n        }\\n        vector<pair<int,int>> vp;\\n        pair<int,int> stInd;\\n        while(j<=n && i<=n){\\n            if(pre[j]-pre[i-1]==target){\\n                vp.push_back({i,j});\\n                mini=min(mini,j-i+1);\\n                if(mini==j-i+1)\\n                    stInd = {i,j};\\n                i++;j++;\\n            }else if(pre[j]-pre[i-1]<target){\\n                j++;\\n            }else{\\n                i++;\\n            }\\n        }\\n        if(vp.size()==0){\\n            return -1;\\n        }\\n        int c=100000000;\\n        for(int i=0;i<vp.size();i++){\\n            if((stInd.first <= vp[i].first &&  stInd.second >= vp[i].first)||(stInd.first <= vp[i].second &&  stInd.second >= vp[i].second)){\\n                \\n            }else{\\n                c=min(c,vp[i].second-vp[i].first+1);\\n            }\\n        }\\n        if(c==100000000){\\n            return -1;\\n        }    \\n        return mini+c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685348,
                "title": "c-subarray-with-sum-equals-target-twice",
                "content": "In this approach I first find the smallest subarray of sum as target and then remove that, then from the updated array I again find the subarray of sum as target. Finally return the sum of both subarray lengths.\\n```\\nclass Solution {\\npublic:\\n    vector<int> f(vector<int>&A, int s)\\n    {\\n        unordered_map<int, int> mp;\\n        mp[0] = -1;\\n        int sum = 0, len = INT_MAX, si = -1, sj = -1;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            sum += A[i];\\n            if(mp.find(sum - s) != mp.end())\\n            {\\n                int id = mp[sum - s];\\n                int l = i - id;\\n                if(l < len)\\n                {\\n                    len = l;\\n                    si = id + 1;\\n                    sj = i;\\n                }\\n            }\\n            mp[sum] = i;\\n        }\\n        return {si, sj};\\n    }\\n    int minSumOfLengths(vector<int>& A, int target) {        \\n        vector<int> v = f(A, target);\\n        if(v[0] == -1 && v[1] == -1)\\n            return -1;\\n        vector<int> B;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            if(i >= v[0] && i <= v[1])\\n                continue;\\n            B.push_back(A[i]);\\n        }\\n        vector<int> v1 = f(B, target);\\n        if(v1[0] == -1 && v1[1] == -1)\\n            return -1;\\n        return (v[1] - v[0] + 1) + (v1[1] - v1[0] + 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> f(vector<int>&A, int s)\\n    {\\n        unordered_map<int, int> mp;\\n        mp[0] = -1;\\n        int sum = 0, len = INT_MAX, si = -1, sj = -1;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            sum += A[i];\\n            if(mp.find(sum - s) != mp.end())\\n            {\\n                int id = mp[sum - s];\\n                int l = i - id;\\n                if(l < len)\\n                {\\n                    len = l;\\n                    si = id + 1;\\n                    sj = i;\\n                }\\n            }\\n            mp[sum] = i;\\n        }\\n        return {si, sj};\\n    }\\n    int minSumOfLengths(vector<int>& A, int target) {        \\n        vector<int> v = f(A, target);\\n        if(v[0] == -1 && v[1] == -1)\\n            return -1;\\n        vector<int> B;\\n        for(int i = 0; i < A.size(); i++)\\n        {\\n            if(i >= v[0] && i <= v[1])\\n                continue;\\n            B.push_back(A[i]);\\n        }\\n        vector<int> v1 = f(B, target);\\n        if(v1[0] == -1 && v1[1] == -1)\\n            return -1;\\n        return (v[1] - v[0] + 1) + (v1[1] - v1[0] + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685339,
                "title": "two-sliding-windows",
                "content": "**1. Find the first smallest subarray whose sum equals target by sliding window approach.\\n2. Then mark this subarray as visited, and now run a sliding window again to find the second smallest subarray.**\\n\\n***UPDATE : \\nThis solution got accepted during contest. But seems like this solution won\\'t pass some corner cases.***\\n```\\nclass Solution \\n{\\n    public int minSumOfLengths(int[] arr, int target) \\n    {\\n        //------------------------------------------------FIRST SLIDING WINDOW------------------------------------\\n        int start = 0;\\n        int end = 0;\\n        int min = Integer.MAX_VALUE;\\n        int s = -1;\\n        int e = -1;\\n        int sum = 0;\\n        while(end < arr.length)\\n        {\\n            sum += arr[end];\\n            \\n            while(sum > target)\\n                sum -= arr[start++];\\n            \\n            if(sum == target)\\n            {\\n                if(end - start + 1 <= min)\\n                {\\n                    min = end - start + 1;\\n                    s = start;\\n                    e = end;\\n                }\\n            }\\n            \\n            end++;\\n        }\\n        \\n        //if couldn\\'t find a subarray, return -1\\n        if(s == -1 || e == -1)\\n            return -1;\\n        \\n        int ans = min;\\n        //------------------------------------------------MARK THEM AS VISITED------------------------------------\\n        boolean[] vis = new boolean[arr.length];\\n        for(int i=s;i<=e;i++)\\n            vis[i] = true;\\n        \\n        //------------------------------------------------SECOND SLIDING WINDOW------------------------------------\\n        start = 0;\\n        end = 0;\\n        min = Integer.MAX_VALUE;\\n        sum = 0;\\n        while(end < arr.length)\\n        {\\n            //skip the first window\\n            while(vis[end])\\n            {\\n                end++;\\n                start = end;\\n                sum = 0;\\n                \\n                if(end >= arr.length)\\n                    break;\\n            }\\n            \\n            if(end >= arr.length)\\n                break;\\n            \\n            sum += arr[end];\\n            \\n            while(sum > target)\\n                sum -= arr[start++];\\n            \\n            if(sum == target)\\n                min = Math.min(min, end-start+1);\\n             \\n            end++;\\n        }\\n        \\n        if(min == Integer.MAX_VALUE)\\n            return -1;\\n        \\n        ans += min;\\n        return ans;\\n    }\\n}\\n```\\n\\n***Please UpVote if you find this useful***",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int minSumOfLengths(int[] arr, int target) \\n    {\\n        //------------------------------------------------FIRST SLIDING WINDOW------------------------------------\\n        int start = 0;\\n        int end = 0;\\n        int min = Integer.MAX_VALUE;\\n        int s = -1;\\n        int e = -1;\\n        int sum = 0;\\n        while(end < arr.length)\\n        {\\n            sum += arr[end];\\n            \\n            while(sum > target)\\n                sum -= arr[start++];\\n            \\n            if(sum == target)\\n            {\\n                if(end - start + 1 <= min)\\n                {\\n                    min = end - start + 1;\\n                    s = start;\\n                    e = end;\\n                }\\n            }\\n            \\n            end++;\\n        }\\n        \\n        //if couldn\\'t find a subarray, return -1\\n        if(s == -1 || e == -1)\\n            return -1;\\n        \\n        int ans = min;\\n        //------------------------------------------------MARK THEM AS VISITED------------------------------------\\n        boolean[] vis = new boolean[arr.length];\\n        for(int i=s;i<=e;i++)\\n            vis[i] = true;\\n        \\n        //------------------------------------------------SECOND SLIDING WINDOW------------------------------------\\n        start = 0;\\n        end = 0;\\n        min = Integer.MAX_VALUE;\\n        sum = 0;\\n        while(end < arr.length)\\n        {\\n            //skip the first window\\n            while(vis[end])\\n            {\\n                end++;\\n                start = end;\\n                sum = 0;\\n                \\n                if(end >= arr.length)\\n                    break;\\n            }\\n            \\n            if(end >= arr.length)\\n                break;\\n            \\n            sum += arr[end];\\n            \\n            while(sum > target)\\n                sum -= arr[start++];\\n            \\n            if(sum == target)\\n                min = Math.min(min, end-start+1);\\n             \\n            end++;\\n        }\\n        \\n        if(min == Integer.MAX_VALUE)\\n            return -1;\\n        \\n        ans += min;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079805,
                "title": "python3-top-down-dp-prefix-sum",
                "content": "can be shortened but wtv\\n# Code\\n```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        forward = list(itertools.accumulate(arr)) \\n        rev = reversed(arr)\\n        backward = list(itertools.accumulate(rev))\\n        backward.reverse()\\n\\n\\n        fHm = defaultdict(int)\\n        for index, element in enumerate(forward):\\n            fHm[element] = index\\n\\n        @cache\\n        def minFromFront(i): #arr[0], arr[1],...,arr[i]  # min sub from this that sum to target\\n            if i < 0:\\n                return float(\\'inf\\')\\n            if forward[i] == target:\\n                return i + 1\\n            \\n            curr = float(\\'inf\\')\\n            compl = forward[i] - target\\n            if compl in fHm and fHm[compl] < i:\\n                curr = (i - fHm[compl])\\n            curr = min(curr, minFromFront(i-1))\\n            return curr\\n\\n        bHm = defaultdict(int)\\n        for index in range(len(backward)-1,-1,-1):\\n            element = backward[index]\\n            bHm[element] = index\\n\\n        @cache\\n        def minFromBack(i): #arr[i], arr[i+1], ...\\n            if i >= len(bHm):\\n                return float(\\'inf\\')\\n            if backward[i] == target:\\n                return len(backward) - i\\n            curr = float(\\'inf\\')\\n            compl = backward[i] - target\\n            if compl in bHm and bHm[compl] > i:\\n                curr = (bHm[compl] - i)\\n            curr = min(curr, minFromBack(i+1))\\n            return curr\\n\\n\\n        res = float(\\'inf\\')\\n        for i in range(len(arr)):\\n            f = minFromFront(i)\\n            b = minFromBack(i+1)\\n            if f != float(\\'inf\\') and b != float(\\'inf\\'):\\n                res = min(res, f + b)\\n\\n        if res == float(\\'inf\\'): return -1\\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSumOfLengths(self, arr: List[int], target: int) -> int:\\n        \\n        forward = list(itertools.accumulate(arr)) \\n        rev = reversed(arr)\\n        backward = list(itertools.accumulate(rev))\\n        backward.reverse()\\n\\n\\n        fHm = defaultdict(int)\\n        for index, element in enumerate(forward):\\n            fHm[element] = index\\n\\n        @cache\\n        def minFromFront(i): #arr[0], arr[1],...,arr[i]  # min sub from this that sum to target\\n            if i < 0:\\n                return float(\\'inf\\')\\n            if forward[i] == target:\\n                return i + 1\\n            \\n            curr = float(\\'inf\\')\\n            compl = forward[i] - target\\n            if compl in fHm and fHm[compl] < i:\\n                curr = (i - fHm[compl])\\n            curr = min(curr, minFromFront(i-1))\\n            return curr\\n\\n        bHm = defaultdict(int)\\n        for index in range(len(backward)-1,-1,-1):\\n            element = backward[index]\\n            bHm[element] = index\\n\\n        @cache\\n        def minFromBack(i): #arr[i], arr[i+1], ...\\n            if i >= len(bHm):\\n                return float(\\'inf\\')\\n            if backward[i] == target:\\n                return len(backward) - i\\n            curr = float(\\'inf\\')\\n            compl = backward[i] - target\\n            if compl in bHm and bHm[compl] > i:\\n                curr = (bHm[compl] - i)\\n            curr = min(curr, minFromBack(i+1))\\n            return curr\\n\\n\\n        res = float(\\'inf\\')\\n        for i in range(len(arr)):\\n            f = minFromFront(i)\\n            b = minFromBack(i+1)\\n            if f != float(\\'inf\\') and b != float(\\'inf\\'):\\n                res = min(res, f + b)\\n\\n        if res == float(\\'inf\\'): return -1\\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063742,
                "title": "sliding-window-suffix-array-explained-intution-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intution behind this solution comes from the fact that , \"we have to find two non overlaping subarrays \". so we have to start finding the next subarray from the point where our first target is reached.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have two objectives here : \\n(1) how to find the minimum lenth of target subarray from the remaining subarray\\n(2) how we will calculate the answer\\n\\nFor Objective 1 \\n-we will precompute the suffix array using sliding window and maintaining a minimum value (target subarray), we will start iterating from the end of the array\\n\\nFor Objective 2\\n-we will start finding a target subarray from the start, while maintaining the minimum length(from all the previous target subarrays). And once we reach a target subarray we will try to calulate the ans asvnow we know the minimum length of the remaining array( where our current subarray ends) using the suffix array.\\n\\nlook out for the edge cases in the code.\\n\\nWe have our ans here folkes !!!\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int n;\\n    vector<int> suffix;\\n    // making a sufix array\\n    void suffer(vector<int>& arr, int k){\\n        int j = n-1, i = n-1;\\n        int mini = INT_MAX;\\n        int sum = 0;\\n        while(j>=0){\\n            sum+= arr[j];\\n            while(sum>k){\\n                sum-=arr[i];\\n                i--;\\n            }\\n            if(sum == k){\\n                mini = min(mini,i - j+ 1);\\n            }\\n            suffix[j] = mini;\\n            j--;\\n        }\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        n = arr.size();\\n        suffix.resize(n,INT_MAX);\\n\\n        suffer(arr, target);\\n        // we will do sliding window and when a window becomes equal to target we will check for the minimum for index j+1;\\n\\n        int i = 0, j = 0;\\n        int mini = INT_MAX;\\n        int sum = 0, ans = INT_MAX;\\n        \\n        while(j<n){\\n            sum += arr[j];\\n\\n            while(sum> target){\\n                sum-= arr[i];\\n                i++;\\n            }\\n            if(sum == target){\\n                mini = min(mini, j - i+1);\\n                if(j+1<n && suffix[j+1]!= INT_MAX){\\n                ans = min(ans, mini + suffix[j+1]);\\n                }\\n            }\\n            j++;\\n        }\\n        return ans == INT_MAX? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sliding Window",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int n;\\n    vector<int> suffix;\\n    // making a sufix array\\n    void suffer(vector<int>& arr, int k){\\n        int j = n-1, i = n-1;\\n        int mini = INT_MAX;\\n        int sum = 0;\\n        while(j>=0){\\n            sum+= arr[j];\\n            while(sum>k){\\n                sum-=arr[i];\\n                i--;\\n            }\\n            if(sum == k){\\n                mini = min(mini,i - j+ 1);\\n            }\\n            suffix[j] = mini;\\n            j--;\\n        }\\n    }\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        n = arr.size();\\n        suffix.resize(n,INT_MAX);\\n\\n        suffer(arr, target);\\n        // we will do sliding window and when a window becomes equal to target we will check for the minimum for index j+1;\\n\\n        int i = 0, j = 0;\\n        int mini = INT_MAX;\\n        int sum = 0, ans = INT_MAX;\\n        \\n        while(j<n){\\n            sum += arr[j];\\n\\n            while(sum> target){\\n                sum-= arr[i];\\n                i++;\\n            }\\n            if(sum == target){\\n                mini = min(mini, j - i+1);\\n                if(j+1<n && suffix[j+1]!= INT_MAX){\\n                ans = min(ans, mini + suffix[j+1]);\\n                }\\n            }\\n            j++;\\n        }\\n        return ans == INT_MAX? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049809,
                "title": "beats-100-00-of-users-with-javascript-well-explained",
                "content": "# Intuition\\nUse Sliding window and prefix array which keep last best result\\n1) We use sliding window in order to find ALL sub arrays with the sum  equals to target\\n2) In order to find non intersected sub-arrays we keep track of LAST INDEX OF SHORTEST sub array index\\n\\n# Approach\\nImage shows intersected sub array\\nAnd how does \"bestEndWnd\" looks like\\nEvery time we found sub-array we look at the \"bestEndWnd\" to find LAST BEST NON INTERSECTED ARRAY\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/4e8d611f-88e4-4d7c-855e-46abdac4d6f1_1694835064.5654464.png)\\n\\nIn the image once we finished last sub array we can find in O(1) time best non intersected sub array by simply looking at bestEndWnd[11] which is equal to 3\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar minSumOfLengths = function(arr, target) {\\n   let runSum=0, bestEndWnd=Array(arr.length).fill(), ans=Number.MAX_SAFE_INTEGER;\\n   for(let i=0,j=i;j<arr.length;j++){\\n       runSum+=arr[j];\\n       while(i<=j && runSum>target){\\n           runSum-=arr[i++];\\n       }\\n       \\n       if(runSum===target){\\n           bestEndWnd[j]=Math.min(j-1<0?Number.MAX_SAFE_INTEGER:bestEndWnd[j-1], j-i);\\n           if(i-1>=0 && bestEndWnd[i-1]!=Number.MAX_SAFE_INTEGER){\\n               ans=Math.min(ans,bestEndWnd[i-1]+(j-i)+2);\\n           }\\n           runSum-=arr[i];\\n           i++;\\n       }else{\\n           bestEndWnd[j]=j-1>=0?bestEndWnd[j-1]:Number.MAX_SAFE_INTEGER;\\n       }\\n       \\n   }\\n  return ans===Number.MAX_SAFE_INTEGER?-1:ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSumOfLengths = function(arr, target) {\\n   let runSum=0, bestEndWnd=Array(arr.length).fill(), ans=Number.MAX_SAFE_INTEGER;\\n   for(let i=0,j=i;j<arr.length;j++){\\n       runSum+=arr[j];\\n       while(i<=j && runSum>target){\\n           runSum-=arr[i++];\\n       }\\n       \\n       if(runSum===target){\\n           bestEndWnd[j]=Math.min(j-1<0?Number.MAX_SAFE_INTEGER:bestEndWnd[j-1], j-i);\\n           if(i-1>=0 && bestEndWnd[i-1]!=Number.MAX_SAFE_INTEGER){\\n               ans=Math.min(ans,bestEndWnd[i-1]+(j-i)+2);\\n           }\\n           runSum-=arr[i];\\n           i++;\\n       }else{\\n           bestEndWnd[j]=j-1>=0?bestEndWnd[j-1]:Number.MAX_SAFE_INTEGER;\\n       }\\n       \\n   }\\n  return ans===Number.MAX_SAFE_INTEGER?-1:ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046218,
                "title": "hashmap-using-prifixsum-approch-95-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        \\n        int sum=0, x=0;\\n        for(int i:arr){\\n            sum+=i;\\n            map.put(sum, x);\\n            x++;\\n        }\\n\\n        int size = Integer.MAX_VALUE;\\n        int res = Integer.MAX_VALUE;\\n        sum=0;\\n        for(int i=0; i<arr.length; i++){\\n            sum+=arr[i];\\n            if(map.get(sum-target)!=null){\\n                size= Math.min(size, i-map.get(sum-target));\\n            }\\n\\n            if(map.get(sum+target)!=null && size<Integer.MAX_VALUE){\\n                res = Math.min(res, map.get(sum+target)-i+size);\\n            }\\n        }\\n\\n        return res==Integer.MAX_VALUE? -1:res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int minSumOfLengths(int[] arr, int target) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, -1);\\n        \\n        int sum=0, x=0;\\n        for(int i:arr){\\n            sum+=i;\\n            map.put(sum, x);\\n            x++;\\n        }\\n\\n        int size = Integer.MAX_VALUE;\\n        int res = Integer.MAX_VALUE;\\n        sum=0;\\n        for(int i=0; i<arr.length; i++){\\n            sum+=arr[i];\\n            if(map.get(sum-target)!=null){\\n                size= Math.min(size, i-map.get(sum-target));\\n            }\\n\\n            if(map.get(sum+target)!=null && size<Integer.MAX_VALUE){\\n                res = Math.min(res, map.get(sum+target)-i+size);\\n            }\\n        }\\n\\n        return res==Integer.MAX_VALUE? -1:res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976310,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minSumOfLengths(vector<int>& arr, int target) {\\n    int ans = INT_MAX;\\n    int leftLength = INT_MAX;\\n    int prefix = 0;\\n    unordered_map<int, int> prefixToIndex{{0, -1}};\\n\\n    for (int i = 0; i < arr.size(); ++i) {\\n      prefix += arr[i];\\n      prefixToIndex[prefix] = i;\\n    }\\n\\n    prefix = 0;\\n\\n    for (int i = 0; i < arr.size(); ++i) {\\n      prefix += arr[i];\\n      if (const auto it = prefixToIndex.find(prefix - target);\\n          it != prefixToIndex.cend())\\n        leftLength = min(leftLength, i - it->second);\\n      if (leftLength < INT_MAX)\\n        if (const auto it = prefixToIndex.find(prefix + target);\\n            it != prefixToIndex.cend())\\n          ans = min(ans, leftLength + it->second - i);\\n    }\\n\\n    return ans == INT_MAX ? -1 : ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minSumOfLengths(vector<int>& arr, int target) {\\n    int ans = INT_MAX;\\n    int leftLength = INT_MAX;\\n    int prefix = 0;\\n    unordered_map<int, int> prefixToIndex{{0, -1}};\\n\\n    for (int i = 0; i < arr.size(); ++i) {\\n      prefix += arr[i];\\n      prefixToIndex[prefix] = i;\\n    }\\n\\n    prefix = 0;\\n\\n    for (int i = 0; i < arr.size(); ++i) {\\n      prefix += arr[i];\\n      if (const auto it = prefixToIndex.find(prefix - target);\\n          it != prefixToIndex.cend())\\n        leftLength = min(leftLength, i - it->second);\\n      if (leftLength < INT_MAX)\\n        if (const auto it = prefixToIndex.find(prefix + target);\\n            it != prefixToIndex.cend())\\n          ans = min(ans, leftLength + it->second - i);\\n    }\\n\\n    return ans == INT_MAX ? -1 : ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3883966,
                "title": "c-avoid-overlapping-solution",
                "content": "# Intuition\\nFor avoiding the overlapping we take each index, find the possible value in the range less than index i and the value in greater equal than i.\\n\\n# Approach\\ntake index i, the minimum subarry with value target in [0,i) plus the minimum in [i, n-1], we compare this addition for each i from [1, n-1]\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinSumOfLengths(int[] arr, int target)\\n    {\\n        int n = arr.Length;\\n        int ans = Int32.MaxValue;\\n        int[] ltr = new int[n];\\n        int[] rtl = new int[n];\\n        int leftMin = Int32.MaxValue, rightMin = Int32.MaxValue;\\n\\n        int pt1 = 0, pt2 = 0;\\n        int sum = 0;\\n        for (pt2 = 0; pt2 < n - 1; ++pt2)\\n        {\\n            sum += arr[pt2];\\n            while (sum >= target)\\n            {\\n                if (sum == target)\\n                {\\n                    leftMin = Math.Min(leftMin, pt2 - pt1 + 1);\\n                    break;\\n                }\\n\\n                sum -= arr[pt1++];\\n            }\\n\\n            ltr[pt2] = leftMin;\\n        }\\n\\n        pt1 = n - 1;\\n        pt2 = n - 1;\\n        sum = 0;\\n        for (pt2 = n - 1; pt2 >= 1; --pt2)\\n        {\\n            sum += arr[pt2];\\n            while (sum >= target)\\n            {\\n                if (sum == target)\\n                {\\n                    rightMin = Math.Min(rightMin, pt1 - pt2 + 1);\\n                    break;\\n                }\\n\\n                sum -= arr[pt1--];\\n            }\\n\\n            rtl[pt2] = rightMin;\\n        }\\n\\n        for (int i = 1; i < n; ++i)\\n        {\\n            if (ltr[i - 1] != Int32.MaxValue && rtl[i] != Int32.MaxValue)\\n            {\\n                ans = Math.Min(ltr[i - 1] + rtl[i], ans);\\n            }\\n        }\\n\\n        return ans == int.MaxValue ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinSumOfLengths(int[] arr, int target)\\n    {\\n        int n = arr.Length;\\n        int ans = Int32.MaxValue;\\n        int[] ltr = new int[n];\\n        int[] rtl = new int[n];\\n        int leftMin = Int32.MaxValue, rightMin = Int32.MaxValue;\\n\\n        int pt1 = 0, pt2 = 0;\\n        int sum = 0;\\n        for (pt2 = 0; pt2 < n - 1; ++pt2)\\n        {\\n            sum += arr[pt2];\\n            while (sum >= target)\\n            {\\n                if (sum == target)\\n                {\\n                    leftMin = Math.Min(leftMin, pt2 - pt1 + 1);\\n                    break;\\n                }\\n\\n                sum -= arr[pt1++];\\n            }\\n\\n            ltr[pt2] = leftMin;\\n        }\\n\\n        pt1 = n - 1;\\n        pt2 = n - 1;\\n        sum = 0;\\n        for (pt2 = n - 1; pt2 >= 1; --pt2)\\n        {\\n            sum += arr[pt2];\\n            while (sum >= target)\\n            {\\n                if (sum == target)\\n                {\\n                    rightMin = Math.Min(rightMin, pt1 - pt2 + 1);\\n                    break;\\n                }\\n\\n                sum -= arr[pt1--];\\n            }\\n\\n            rtl[pt2] = rightMin;\\n        }\\n\\n        for (int i = 1; i < n; ++i)\\n        {\\n            if (ltr[i - 1] != Int32.MaxValue && rtl[i] != Int32.MaxValue)\\n            {\\n                ans = Math.Min(ltr[i - 1] + rtl[i], ans);\\n            }\\n        }\\n\\n        return ans == int.MaxValue ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873316,
                "title": "c-o-n-time-o-1-space-no-dp-no-hashmap",
                "content": "`(i..j)`is the window to find first minimum length sub-array.\\n`k`marks the end of (possibly) next sub-array, but, starting at`(j + 1)`.\\n\\nIdea is - \\nif you have any other best subarray to minimize the sum of 2 lengths, you are going to see that next 2nd subarray in future as`j`progresses one step at a time.. and you will find`(j+1..k)`. Also by that time, you will have any sub-array, not just`(0..i)`but`(0..j)`to find first minimum length sub-array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int j = 0, i = -1, k = 0, end = arr.size();\\n        int curr_sum = 0, next_sum = 0;\\n        int len1 = INT_MAX, ans = INT_MAX;\\n        while (j < end) {\\n            curr_sum += arr[j];\\n            next_sum -= arr[j];\\n            while (curr_sum > target)\\n                curr_sum -= arr[++i];\\n            if (curr_sum == target)\\n                len1 = min(len1, j - i);\\n\\n            if (len1 != INT_MAX) {\\n                 while (k < end && next_sum < target)\\n                     next_sum += arr[k++];\\n                 if (next_sum == target)\\n                     ans = min(ans, k - 1 - j + len1);\\n            }\\n            ++j;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        int j = 0, i = -1, k = 0, end = arr.size();\\n        int curr_sum = 0, next_sum = 0;\\n        int len1 = INT_MAX, ans = INT_MAX;\\n        while (j < end) {\\n            curr_sum += arr[j];\\n            next_sum -= arr[j];\\n            while (curr_sum > target)\\n                curr_sum -= arr[++i];\\n            if (curr_sum == target)\\n                len1 = min(len1, j - i);\\n\\n            if (len1 != INT_MAX) {\\n                 while (k < end && next_sum < target)\\n                     next_sum += arr[k++];\\n                 if (next_sum == target)\\n                     ans = min(ans, k - 1 - j + len1);\\n            }\\n            ++j;\\n        }\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854038,
                "title": "c-solution-o-nlogn-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        vector<int>psum(arr.size(), 0);\\n        psum[0] = 0;\\n        for(int i=1; i<arr.size(); i++){\\n            psum[i] = arr[i]+psum[i-1];\\n        }\\n        map<int, int> vis;\\n        map<int,vector<pair<int,int>>> subarr;\\n        //a-b=t -> \\n        for(int i=0; i<arr.size(); i++){\\n            vis[target+psum[i]-arr[i]] = i;\\n        }\\n        //subarr[0].push_back({1,2});\\n        for(int i=0; i<arr.size(); i++){\\n            if(vis.find(psum[i])!=vis.end()){\\n                subarr[abs(i - vis[psum[i]])+1].push_back({i,vis[psum[i]]});\\n\\n            }\\n        }\\n        int mini = INT_MAX;\\n        for(auto i : subarr){\\n            cout<<i.first<<\"->\"<<endl;\\n            for(int j=0; j<i.second.size(); j++){\\n                cout<<i.second[j].first<<\" \"<<i.second[j].second<<endl;\\n            }\\n        }\\n        \\n        \\n        \\n        //a+b=t => a = t-b\\n    \\n    return mini;\\n    }\\n};\\n//a,b,c,d,e,f,g,h,i,j\\n//  |___|     |__|\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        vector<int>psum(arr.size(), 0);\\n        psum[0] = 0;\\n        for(int i=1; i<arr.size(); i++){\\n            psum[i] = arr[i]+psum[i-1];\\n        }\\n        map<int, int> vis;\\n        map<int,vector<pair<int,int>>> subarr;\\n        //a-b=t -> \\n        for(int i=0; i<arr.size(); i++){\\n            vis[target+psum[i]-arr[i]] = i;\\n        }\\n        //subarr[0].push_back({1,2});\\n        for(int i=0; i<arr.size(); i++){\\n            if(vis.find(psum[i])!=vis.end()){\\n                subarr[abs(i - vis[psum[i]])+1].push_back({i,vis[psum[i]]});\\n\\n            }\\n        }\\n        int mini = INT_MAX;\\n        for(auto i : subarr){\\n            cout<<i.first<<\"->\"<<endl;\\n            for(int j=0; j<i.second.size(); j++){\\n                cout<<i.second[j].first<<\" \"<<i.second[j].second<<endl;\\n            }\\n        }\\n        \\n        \\n        \\n        //a+b=t => a = t-b\\n    \\n    return mini;\\n    }\\n};\\n//a,b,c,d,e,f,g,h,i,j\\n//  |___|     |__|\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3854029,
                "title": "o-n-solution-using-smallest-subarray-length-with-sum-target-in-prefix-and-suffix",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        vector<int>prefix(arr.size(),0);\\n        int sum = 0;\\n        int mini = 100001;\\n        int start = 0;\\n\\n        for(int i=0; i<arr.size();i++){\\n            sum+=arr[i];\\n            if(sum>=target){\\n                if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n                while(sum>target && start <= i){\\n                   \\n                    sum-=arr[start];\\n                    start++;\\n                     if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n\\n                }\\n            }\\n            prefix[i]=mini;\\n\\n        }\\n\\n        vector<int>suffix(arr.size(),0);\\n        mini = 100001;\\n        sum = 0;\\n        start = 0;\\n        reverse(arr.begin(),arr.end());\\n        for(int i=0; i<arr.size();i++){\\n            sum+=arr[i];\\n            if(sum>=target){\\n                if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n                while(sum>target && start <= i){\\n                   \\n                    sum-=arr[start];\\n                    start++;\\n                     if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n\\n                }\\n            }\\n            suffix[i]=mini;\\n\\n        }\\n        reverse(suffix.begin(),suffix.end());\\n        mini = 100001;\\n\\n        for(int i=1; i<prefix.size(); i++){\\n            mini = min(prefix[i-1]+suffix[i],mini);\\n        }\\n\\n        if(mini == 100001) return -1;\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSumOfLengths(vector<int>& arr, int target) {\\n        vector<int>prefix(arr.size(),0);\\n        int sum = 0;\\n        int mini = 100001;\\n        int start = 0;\\n\\n        for(int i=0; i<arr.size();i++){\\n            sum+=arr[i];\\n            if(sum>=target){\\n                if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n                while(sum>target && start <= i){\\n                   \\n                    sum-=arr[start];\\n                    start++;\\n                     if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n\\n                }\\n            }\\n            prefix[i]=mini;\\n\\n        }\\n\\n        vector<int>suffix(arr.size(),0);\\n        mini = 100001;\\n        sum = 0;\\n        start = 0;\\n        reverse(arr.begin(),arr.end());\\n        for(int i=0; i<arr.size();i++){\\n            sum+=arr[i];\\n            if(sum>=target){\\n                if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n                while(sum>target && start <= i){\\n                   \\n                    sum-=arr[start];\\n                    start++;\\n                     if(sum==target){\\n                    mini = min(mini,abs(i-start)+1);\\n                }\\n\\n                }\\n            }\\n            suffix[i]=mini;\\n\\n        }\\n        reverse(suffix.begin(),suffix.end());\\n        mini = 100001;\\n\\n        for(int i=1; i<prefix.size(); i++){\\n            mini = min(prefix[i-1]+suffix[i],mini);\\n        }\\n\\n        if(mini == 100001) return -1;\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564904,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            },
            {
                "id": 1574908,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            },
            {
                "id": 1753080,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            },
            {
                "id": 1574355,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            },
            {
                "id": 1573926,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            },
            {
                "id": 1573925,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            },
            {
                "id": 2049690,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            },
            {
                "id": 1784855,
                "content": [
                    {
                        "username": "rvpk",
                        "content": "Shouldn\\'t this one be a hard one ?"
                    },
                    {
                        "username": "stefan1096",
                        "content": "This can be solved by maintaining two sliding windows.It is medium~hard if you don't know it but medium if you know it already"
                    },
                    {
                        "username": "srikanth248",
                        "content": "The question says 2 non-overlapping sub arrays.\\n\\nHow can the answer for [1,6,1] target 7 be 4? [1,6] and [6,1] are overlapping sub arrays."
                    },
                    {
                        "username": "FyodorPopov",
                        "content": "Even though the definition of absolute value is often repeated in all problems, there is no definition of overlapping arrays in that exercise...."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "they updated this test case"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Real great question imo !!"
                    },
                    {
                        "username": "khushable",
                        "content": "\\n[1,1,1,2,2,2,4,4]\\n6\\n\\nThis should return len =6 (index 1 thorugh 4) + (index 5 through 6) but test case expects -1"
                    },
                    {
                        "username": "codecrystal",
                        "content": "Shouldn\\'t the answer be [6] + [4,2] = 3 ? The answer provided is -1."
                    },
                    {
                        "username": "helowl",
                        "content": "bro, they asked subarray\\n"
                    },
                    {
                        "username": "Bakushin",
                        "content": "can someone please explain why [3,4] is not inclucded ?"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "The question says 2 non-overlapping sub arrays"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "arr = [2,1,3,3,2,3,1] , Target =6. \\nExpected Output=5, Mine output= 6;\\n\\narr= [2,1,3,3], Target =6\\nExpected Output=-1, MIne Output=-1;\\n\\nMy Code: \\nint minSumOfLengths(vector<int>& arr, int target) {\\n        int n=arr.size();\\n        unordered_map<int,int> mp;\\n        vector<int> len;\\n        int sum=0;\\n        mp[0]=-1;\\n        for(int i=0;i<n;i++){\\n            sum+=arr[i];\\n            mp[sum]=i;\\n            if(mp.count(sum-target)){\\n                len.push_back(i- mp[sum-target]);\\n                mp.clear();\\n                sum=0; mp[0]=i;\\n            }\\n        }\\n        if(len.size()<=1) return -1;\\n        sort(len.begin(),len.end());\\n        return len[0]+len[1];\\n    }"
                    },
                    {
                        "username": "dsalinkdev",
                        "content": "For this input,\n[2,2,4,4,4,4,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1] and target = 20\n\nThe sub-arrays having sum equal to target are: \n[0] - [5], sz 6\n[2] - [6], sz 5\n[3] - [10], sz 8\n[4] - [14], sz 11\n[5] - [18], sz 14\n[6] - [22], sz 17\n[7] - [26], sz 20\n\nShould not the output length of two subarrays should be 11 ?\nWhy expected output is 23?"
                    }
                ]
            }
        ]
    }
]