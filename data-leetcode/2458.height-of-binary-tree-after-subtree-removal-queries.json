[
    {
        "title": "Height of Binary Tree After Subtree Removal Queries",
        "question_content": "You are given the root of a binary tree with n nodes. Each node is assigned a unique value from 1 to n. You are also given an array queries of size m.\nYou have to perform m independent queries on the tree where in the ith query you do the following:\n\n\tRemove the subtree rooted at the node with the value queries[i] from the tree. It is guaranteed that queries[i] will not be equal to the value of the root.\n\nReturn an array answer of size m where answer[i] is the height of the tree after performing the ith query.\nNote:\n\n\tThe queries are independent, so the tree returns to its initial state after each query.\n\tThe height of a tree is the number of edges in the longest simple path from the root to some node in the tree.\n\n&nbsp;\nExample 1:\n\nInput: root = [1,3,4,2,null,6,5,null,null,null,null,null,7], queries = [4]\nOutput: [2]\nExplanation: The diagram above shows the tree after removing the subtree rooted at node with value 4.\nThe height of the tree is 2 (The path 1 -> 3 -> 2).\n\nExample 2:\n\nInput: root = [5,8,9,2,1,3,7,4,6], queries = [3,2,4,8]\nOutput: [3,2,3,2]\nExplanation: We have the following queries:\n- Removing the subtree rooted at node with value 3. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 4).\n- Removing the subtree rooted at node with value 2. The height of the tree becomes 2 (The path 5 -> 8 -> 1).\n- Removing the subtree rooted at node with value 4. The height of the tree becomes 3 (The path 5 -> 8 -> 2 -> 6).\n- Removing the subtree rooted at node with value 8. The height of the tree becomes 2 (The path 5 -> 9 -> 3).\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is n.\n\t2 <= n <= 105\n\t1 <= Node.val <= n\n\tAll the values in the tree are unique.\n\tm == queries.length\n\t1 <= m <= min(n, 104)\n\t1 <= queries[i] <= n\n\tqueries[i] != root.val",
        "solutions": [
            {
                "id": 2757990,
                "title": "python-3-explanation-with-pictures-dfs",
                "content": "Each node has a **depth** and **height**. The longest path passing it has a length equals `depth + height`.\\n\\n![image](https://assets.leetcode.com/users/images/a10e9a89-fb45-45b7-9470-28adc3574d61_1667102453.8528125.png)\\n\\nWhen a node (Let\\'s say **D**) is removed, all of its children are removed as well. So every path that goes through **D** stops by here. However, if **D** has some cousions, then the paths through these cousins will certainly be longer. We should look for the longest path among these paths through the cousins of **D**, which is equivalent to finding the cousin with the largest **height**.\\n\\n![image](https://assets.leetcode.com/users/images/c8438256-94e9-4810-8d60-fdaf73576791_1667102457.8192077.png)\\n\\nTherefore, we store the nodes according to **depth**. For nodes having the same depth, we sort them by their heights and only keep the top 2 of them that having the maximum depth.\\n\\n![image](https://assets.leetcode.com/users/images/b5bfc58a-3dc0-48f3-8348-34cf1bf38c80_1667104420.761939.png)\\n\\n\\nOnce we \\'remove\\' a node from `queries`, we locate all of its cousins, find the one with the maximum height and the job is done.\\n\\n- If the size of `cousins[depth]` is 1, which means that the `removed` node has no cousin, so the longest resting path equals `depth - 1`. \\n- Otherwise, at least one of them is the cousin, we get its depth.\\n\\n\\nTCSC:\\n- Time O(N)\\n- Space O(N)\\n\\n<br>\\n<br>\\n\\n\\n\\n```python\\nclass Solution:\\n    def treeQueries(self, R: Optional[TreeNode], Q: List[int]) -> List[int]:\\n        Depth, Height = collections.defaultdict(int), collections.defaultdict(int)\\n\\n        def dfs(node, depth):\\n            if not node:\\n                return -1\\n            Depth[node.val] = depth\\n            cur = max(dfs(node.left, depth + 1), dfs(node.right, depth + 1)) + 1\\n            Height[node.val] = cur\\n            return cur\\n        dfs(R, 0)\\n\\n        cousins = collections.defaultdict(list) # Group nodes according to their depth. Keep the top 2 heights.\\n        for val, depth in Depth.items():\\n            cousins[depth].append((-Height[val], val))\\n            cousins[depth].sort()\\n            if len(cousins[depth]) > 2:\\n                cousins[depth].pop()\\n\\n        ans = []\\n        for q in Q:\\n            depth = Depth[q]\\n            if len(cousins[depth]) == 1:  # No cousin, path length equals depth - 1.\\n                ans.append(depth - 1)\\n            elif cousins[depth][0][1] == q:  # The removed node has the largest height, look for the node with 2nd largest height.\\n                ans.append(-cousins[depth][1][0] + depth)\\n\\t\\t\\telse:   # Look for the node with the largest height.\\n                ans.append(-cousins[depth][0][0] + depth)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def treeQueries(self, R: Optional[TreeNode], Q: List[int]) -> List[int]:\\n        Depth, Height = collections.defaultdict(int), collections.defaultdict(int)\\n\\n        def dfs(node, depth):\\n            if not node:\\n                return -1\\n            Depth[node.val] = depth\\n            cur = max(dfs(node.left, depth + 1), dfs(node.right, depth + 1)) + 1\\n            Height[node.val] = cur\\n            return cur\\n        dfs(R, 0)\\n\\n        cousins = collections.defaultdict(list) # Group nodes according to their depth. Keep the top 2 heights.\\n        for val, depth in Depth.items():\\n            cousins[depth].append((-Height[val], val))\\n            cousins[depth].sort()\\n            if len(cousins[depth]) > 2:\\n                cousins[depth].pop()\\n\\n        ans = []\\n        for q in Q:\\n            depth = Depth[q]\\n            if len(cousins[depth]) == 1:  # No cousin, path length equals depth - 1.\\n                ans.append(depth - 1)\\n            elif cousins[depth][0][1] == q:  # The removed node has the largest height, look for the node with 2nd largest height.\\n                ans.append(-cousins[depth][1][0] + depth)\\n\\t\\t\\telse:   # Look for the node with the largest height.\\n                ans.append(-cousins[depth][0][0] + depth)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758013,
                "title": "level-depth",
                "content": "I initially solved this problem as O(m * h), but I got TLE when the trie is a vine (so the complexity is O(m * n)). The level-based approach below is O(n + m) for any tree shape.\\n\\nFor each node, we store its `level` and `depth` of its subtree.\\n\\nAlso, for each level, we store largest (`d1`) and second largest (`d2`) depth from all nodes on that level.\\n\\nNow, when we process a query, we can figure out the level and depth of the node.\\n\\nThe result is the level plus a) the largets depth of that level, or b) second largest if the queried node depth is the largest.\\n\\n**C++**\\n```cpp\\nint level[100001] = {}, depth[100001] = {};\\nint d1[100001] = {}, d2[100001] = {};\\nint traverse(TreeNode* n, int l = 0) {\\n    if (n == nullptr)\\n        return 0;\\n    level[n->val] = l;\\n    depth[n->val] = 1 + max(traverse(n->left, l + 1), traverse(n->right, l + 1));   \\n    if (d1[l] < depth[n->val]) {\\n        d2[l] = d1[l];\\n        d1[l] = depth[n->val];\\n    } \\n    else if (d2[l] < depth[n->val])\\n        d2[l] = depth[n->val];\\n    return depth[n->val];\\n};\\nvector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n    traverse(root, 0);\\n    transform(begin(queries), end(queries), begin(queries), [&](int q){\\n        int l = level[q];\\n        return l + (d1[l] == depth[q] ? d2[l] : d1[l]) - 1;\\n    });\\n    return queries;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint level[100001] = {}, depth[100001] = {};\\nint d1[100001] = {}, d2[100001] = {};\\nint traverse(TreeNode* n, int l = 0) {\\n    if (n == nullptr)\\n        return 0;\\n    level[n->val] = l;\\n    depth[n->val] = 1 + max(traverse(n->left, l + 1), traverse(n->right, l + 1));   \\n    if (d1[l] < depth[n->val]) {\\n        d2[l] = d1[l];\\n        d1[l] = depth[n->val];\\n    } \\n    else if (d2[l] < depth[n->val])\\n        d2[l] = depth[n->val];\\n    return depth[n->val];\\n};\\nvector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n    traverse(root, 0);\\n    transform(begin(queries), end(queries), begin(queries), [&](int q){\\n        int l = level[q];\\n        return l + (d1[l] == depth[q] ? d2[l] : d1[l]) - 1;\\n    });\\n    return queries;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2759353,
                "title": "c-python-preoder-and-postorder-dfs",
                "content": "# **Explanation**\\nPre-order dfs the tree (node, left, right),\\nupdate `res[i]` to the max height before node `i` in preorder,\\ncan cover all nodes on the left of node `i` in the tree.\\n\\nPost-order dfs the tree (node, right, left),\\nupdate `res[i]` to the max height before node `i` in postorder,\\ncan cover all nodes on the right of node `i` in the tree.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**C++**\\n```cpp\\n    int preh[100001], posth[100001], maxh;\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        maxh = 0; pre(root, 0);\\n        maxh = 0; post(root, 0);\\n        vector<int> res;\\n        for (int q : queries)\\n            res.push_back(max(preh[q], posth[q]));\\n        return res;\\n    }\\n\\n    void pre(TreeNode* root, int h) {\\n        if (!root) return;\\n        preh[root->val] = maxh;\\n        maxh = max(maxh, h);\\n        pre(root->left, h + 1);\\n        pre(root->right, h + 1);\\n    }\\n\\n    void post(TreeNode* root, int h) {\\n        if (!root) return;\\n        posth[root->val] = maxh;\\n        maxh = max(maxh, h);\\n        post(root->right, h + 1);\\n        post(root->left, h + 1);\\n    }\\n```\\n**Shorter C++**\\n```cpp\\n    int seen[100001], maxh;\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        maxh = 0; dfs(root, 0);\\n        maxh = 0; dfs(root, 0);\\n        vector<int> res;\\n        for (int q : queries)\\n            res.push_back(seen[q]);\\n        return res;\\n    }\\n\\n    void dfs(TreeNode* root, int h) {\\n        if (!root) return;\\n        seen[root->val] = max(seen[root->val], maxh);\\n        maxh = max(maxh, h);\\n        dfs(root->left, h + 1);\\n        dfs(root->right, h + 1);\\n        swap(root->right, root->left);\\n    }\\n```\\n\\n**Python**\\n```py\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        res = defaultdict(int)\\n\\n        def dfs(root, h, maxh):\\n            if not root: return maxh\\n            res[root.val] = max(res[root.val], maxh)\\n            root.left, root.right = root.right, root.left\\n            return dfs(root.right, h + 1, dfs(root.left, h + 1, max(maxh, h)))\\n\\n        dfs(root, 0, 0)\\n        dfs(root, 0, 0)\\n        return [res[q] for q in queries]\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int preh[100001], posth[100001], maxh;\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        maxh = 0; pre(root, 0);\\n        maxh = 0; post(root, 0);\\n        vector<int> res;\\n        for (int q : queries)\\n            res.push_back(max(preh[q], posth[q]));\\n        return res;\\n    }\\n\\n    void pre(TreeNode* root, int h) {\\n        if (!root) return;\\n        preh[root->val] = maxh;\\n        maxh = max(maxh, h);\\n        pre(root->left, h + 1);\\n        pre(root->right, h + 1);\\n    }\\n\\n    void post(TreeNode* root, int h) {\\n        if (!root) return;\\n        posth[root->val] = maxh;\\n        maxh = max(maxh, h);\\n        post(root->right, h + 1);\\n        post(root->left, h + 1);\\n    }\\n```\n```cpp\\n    int seen[100001], maxh;\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        maxh = 0; dfs(root, 0);\\n        maxh = 0; dfs(root, 0);\\n        vector<int> res;\\n        for (int q : queries)\\n            res.push_back(seen[q]);\\n        return res;\\n    }\\n\\n    void dfs(TreeNode* root, int h) {\\n        if (!root) return;\\n        seen[root->val] = max(seen[root->val], maxh);\\n        maxh = max(maxh, h);\\n        dfs(root->left, h + 1);\\n        dfs(root->right, h + 1);\\n        swap(root->right, root->left);\\n    }\\n```\n```py\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        res = defaultdict(int)\\n\\n        def dfs(root, h, maxh):\\n            if not root: return maxh\\n            res[root.val] = max(res[root.val], maxh)\\n            root.left, root.right = root.right, root.left\\n            return dfs(root.right, h + 1, dfs(root.left, h + 1, max(maxh, h)))\\n\\n        dfs(root, 0, 0)\\n        dfs(root, 0, 0)\\n        return [res[q] for q in queries]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2758375,
                "title": "python3-c-clean-9-lines-dfs",
                "content": "**Explanation**:\\n* Find height of each node\\n* Perform a dfs, the parameters are current node, current depth and max height without current node\\n* Max height without current node will be max height elsewhere in the tree or height of sibling node + curr depth\\n\\n**Python3**\\n```   \\n    def treeQueries(self, root, queries, ans = {}) -> List[int]:\\n        @cache\\n        def height(r): return 1 + max(height(r.left), height(r.right)) if r else 0\\n        def dfs(r, depth, mx):\\n            if not r: return\\n            ans[r.val] = mx\\n            dfs(r.left, depth + 1, max(mx, depth + height(r.right)))\\n            dfs(r.right, depth + 1, max(mx, depth + height(r.left)))\\n        dfs(root, 0, 0)\\n        return [ans[v] for v in queries]\\n```\\n**C++**\\n```\\nvector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n\\tunordered_map<int, int> ans; unordered_map<TreeNode*, int> hts; vector<int> res;\\n\\tfunction<int(TreeNode*)> height = [&](TreeNode* r) {\\n\\t\\treturn r ? (hts[r] = 1 + max(height(r->left), height(r->right))) : 0; \\n\\t};\\n\\tfunction<void(TreeNode*,int,int)> dfs = [&](TreeNode* r, int depth, int mx) {\\n\\t\\tif (!r) return;\\n\\t\\tans[r->val] = mx;\\n\\t\\tdfs(r->right, depth + 1, max(mx, depth + hts[r->left]));\\n\\t\\tdfs(r->left, depth + 1, max(mx, depth + hts[r->right]));\\n\\t};\\n\\theight(root); dfs(root, 0, 0);\\n\\tfor (int& v: queries) res.push_back(ans[v]);\\n\\treturn res;\\n}\\n```\\n*Time complexity: O(n)*\\n\\n**Bonus:**\\n**Python3 8 lines**\\n   ```\\n\\t def treeQueries(self, root, queries, ans = {}) -> List[int]:\\n        ht = lru_cache(maxsize = 20000)(lambda r: 1 + max(ht(r.left), ht(r.right)) if r else 0)\\n        def dfs(r, depth, mx):\\n            if not r: return\\n            ans[r.val] = mx\\n            dfs(r.left, depth + 1, max(mx, depth + ht(r.right)))\\n            dfs(r.right, depth + 1, max(mx, depth + ht(r.left)))\\n        dfs(root, 0, 0)\\n        return [ans[v] for v in queries]\\n```",
                "solutionTags": [],
                "code": "```   \\n    def treeQueries(self, root, queries, ans = {}) -> List[int]:\\n        @cache\\n        def height(r): return 1 + max(height(r.left), height(r.right)) if r else 0\\n        def dfs(r, depth, mx):\\n            if not r: return\\n            ans[r.val] = mx\\n            dfs(r.left, depth + 1, max(mx, depth + height(r.right)))\\n            dfs(r.right, depth + 1, max(mx, depth + height(r.left)))\\n        dfs(root, 0, 0)\\n        return [ans[v] for v in queries]\\n```\n```\\nvector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n\\tunordered_map<int, int> ans; unordered_map<TreeNode*, int> hts; vector<int> res;\\n\\tfunction<int(TreeNode*)> height = [&](TreeNode* r) {\\n\\t\\treturn r ? (hts[r] = 1 + max(height(r->left), height(r->right))) : 0; \\n\\t};\\n\\tfunction<void(TreeNode*,int,int)> dfs = [&](TreeNode* r, int depth, int mx) {\\n\\t\\tif (!r) return;\\n\\t\\tans[r->val] = mx;\\n\\t\\tdfs(r->right, depth + 1, max(mx, depth + hts[r->left]));\\n\\t\\tdfs(r->left, depth + 1, max(mx, depth + hts[r->right]));\\n\\t};\\n\\theight(root); dfs(root, 0, 0);\\n\\tfor (int& v: queries) res.push_back(ans[v]);\\n\\treturn res;\\n}\\n```\n```\\n\\t def treeQueries(self, root, queries, ans = {}) -> List[int]:\\n        ht = lru_cache(maxsize = 20000)(lambda r: 1 + max(ht(r.left), ht(r.right)) if r else 0)\\n        def dfs(r, depth, mx):\\n            if not r: return\\n            ans[r.val] = mx\\n            dfs(r.left, depth + 1, max(mx, depth + ht(r.right)))\\n            dfs(r.right, depth + 1, max(mx, depth + ht(r.left)))\\n        dfs(root, 0, 0)\\n        return [ans[v] for v in queries]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2758211,
                "title": "java-2-pass-dfs-with-hashmaps",
                "content": "```\\nclass Solution {\\n    private Map<Integer, Integer> leftMap = new HashMap<>();\\n    private Map<Integer, Integer> rightMap = new HashMap<>();\\n    private Map<Integer, Integer> removed = new HashMap<>();\\n    \\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        populateHeights(root, 0);\\n        calculateRemovedHeights(root, 0);\\n        \\n        int[] output = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            output[i] = removed.get(queries[i]);\\n        }\\n        return output;\\n    }\\n    \\n\\t// height is the max tree height with this node removed\\n    private void calculateRemovedHeights(TreeNode node, int height) {\\n        if (node == null) {\\n            return;\\n        }\\n        removed.put(node.val, height);\\n\\t\\t\\n\\t\\t// for each child, the height when removed is the max of the the height following\\n\\t\\t// the opposite child, or the passed-in height with this node removed\\n        calculateRemovedHeights(node.left, Math.max(height, rightMap.get(node.val)));\\n        calculateRemovedHeights(node.right, Math.max(height, leftMap.get(node.val)));\\n    }\\n    \\n\\t// populate the maps with the total height of the left and right subtree of\\n\\t// each node, and return the larger of the two values\\n    private int populateHeights(TreeNode node, int height) {\\n        if (node == null) {\\n            return height - 1;\\n        }\\n        \\n        leftMap.put(node.val, populateHeights(node.left, height + 1));\\n        rightMap.put(node.val, populateHeights(node.right, height + 1));\\n        \\n        return Math.max(leftMap.get(node.val), rightMap.get(node.val));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private Map<Integer, Integer> leftMap = new HashMap<>();\\n    private Map<Integer, Integer> rightMap = new HashMap<>();\\n    private Map<Integer, Integer> removed = new HashMap<>();\\n    \\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        populateHeights(root, 0);\\n        calculateRemovedHeights(root, 0);\\n        \\n        int[] output = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            output[i] = removed.get(queries[i]);\\n        }\\n        return output;\\n    }\\n    \\n\\t// height is the max tree height with this node removed\\n    private void calculateRemovedHeights(TreeNode node, int height) {\\n        if (node == null) {\\n            return;\\n        }\\n        removed.put(node.val, height);\\n\\t\\t\\n\\t\\t// for each child, the height when removed is the max of the the height following\\n\\t\\t// the opposite child, or the passed-in height with this node removed\\n        calculateRemovedHeights(node.left, Math.max(height, rightMap.get(node.val)));\\n        calculateRemovedHeights(node.right, Math.max(height, leftMap.get(node.val)));\\n    }\\n    \\n\\t// populate the maps with the total height of the left and right subtree of\\n\\t// each node, and return the larger of the two values\\n    private int populateHeights(TreeNode node, int height) {\\n        if (node == null) {\\n            return height - 1;\\n        }\\n        \\n        leftMap.put(node.val, populateHeights(node.left, height + 1));\\n        rightMap.put(node.val, populateHeights(node.right, height + 1));\\n        \\n        return Math.max(leftMap.get(node.val), rightMap.get(node.val));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758115,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> l,r,ans;\\n    int height(TreeNode* root){\\n        if(root==NULL) return 0;\\n        int le = height(root->left);\\n        int re = height(root->right);\\n        l[root->val] = le;                 // Storing maximum height in the left side of current node\\n        r[root->val] = re;                 // Storing maximum height in the right side of current node\\n        return max(le,re)+1;      \\n    }\\n    void fun(TreeNode* root,int MaxSoFar,int depth){\\n        if(root==NULL) return;\\n\\n        ans[root->val] = MaxSoFar;\\n        fun(root->left,max(MaxSoFar,depth+r[root->val]),depth+1);\\n        fun(root->right,max(MaxSoFar,depth+l[root->val]),depth+1);\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& q) {\\n        height(root);\\n        \\n        fun(root->left,r[root->val],1);               // Calling on left side and passing the maximum height of right side of root\\n        fun(root->right,l[root->val],1);              // Calling on right side and passing the maximum height of left side of root\\n        \\n        vector<int> res(q.size());\\n        for(int i = 0;i<q.size();i++){\\n            res[i] = ans[q[i]];\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    unordered_map<int,int> l,r,ans;\\n    int height(TreeNode* root){\\n        if(root==NULL) return 0;\\n        int le = height(root->left);\\n        int re = height(root->right);\\n        l[root->val] = le;                 // Storing maximum height in the left side of current node\\n        r[root->val] = re;                 // Storing maximum height in the right side of current node\\n        return max(le,re)+1;      \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2757998,
                "title": "find-2-maximum-of-each-level",
                "content": "This Question is Pretty much simple, \\nJust read the explanation once,\\n\\nFirst of All you need to find the level, and height of each node of a tree and store them in a map\\nThen store the 2 maximum node of each level\\n\\nNow start traversing in the queries array, suppose \\nthe node you wants to remove is not having the maximum height in its level, \\nthen the removal of that node, doesn\\'t impact in height of tree,\\n\\nthe node you wants to remove is  having the maximum height in its level, \\nthen the removal of that node, impact in height of tree,\\nit decrease the height by\\n(height of that node - 2nd maximum height of that level)\\n\\nso in that case queries[i]=heightOf(queries[i])-2nd maximum height of that level;\\n\\n**Happy coding :)**\\n\\n```\\nclass Solution {\\n    \\n    // for storing the height of each node\\n    Map<Integer,Integer> height=new HashMap<>();\\n    // for storing the level of each node \\n    Map<Integer,Integer> level=new HashMap<>();\\n    // for storing the 2 maximum height of each level \\n    Map<Integer,Queue<Integer>> twoMaximum=new HashMap<>();\\n    \\n    int nodeHeight(TreeNode root,int l){\\n        \\n        if(root==null) return -1;\\n        // adding default priority Queue \\n        twoMaximum.putIfAbsent(l,new PriorityQueue<>());\\n        \\n        int temp=Math.max(nodeHeight(root.left,l+1),nodeHeight(root.right,l+1))+1;\\n        \\n        height.put(root.val,temp);\\n        level.put(root.val,l);\\n        \\n        twoMaximum.get(l).add(temp);\\n        \\n        // updating priority Queue with the 2 maximum height of current level \\n        if(twoMaximum.get(l).size()>2) twoMaximum.get(l).remove();\\n        return temp;\\n    }\\n    public int[] treeQueries(TreeNode root, int[] q) {\\n        \\n        // the height of tree \\n        int h=nodeHeight(root,0);\\n        \\n        for(int i=0;i<q.length;i++){\\n            int lev=level.get(q[i]);\\n            int hh=height.get(q[i]);     \\n            int a=-1,b=-1;\\n            // if there is more then 2 node at the level of query[i]\\n            if(twoMaximum.get(lev).size()==2){\\n                b=twoMaximum.get(lev).remove();\\n                a=twoMaximum.get(lev).remove();\\n                \\n                // if current node has maximum height, in his level then the height of tree will be impacted\\n                // and height of tree will be decrease by heightOf(queries[i])-2nd maximum height of that level;\\n                if(hh==a) q[i]=h-(a-b);\\n                \\n                // else the height of tree remains same \\n                else q[i]=h;\\n                \\n                twoMaximum.get(lev).add(a);\\n                twoMaximum.get(lev).add(b);\\n            }\\n            // if there is only one node at that level \\n            // then the height of tree will be subtracted by the height of current node\\n            else q[i]=h-hh-1;\\n        }\\n        // returning the updated query array \\n        return q;\\n    }\\n}\\n```\\n\\n**Time complexity will be O(N) \\nSpace complexity will be O(N) + O(h) =O(N)**\\n\\n**where ,\\nN is the number of nodes in a tree \\nh is the height of tree**\\n\\n*Please Upvote the post.*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // for storing the height of each node\\n    Map<Integer,Integer> height=new HashMap<>();\\n    // for storing the level of each node \\n    Map<Integer,Integer> level=new HashMap<>();\\n    // for storing the 2 maximum height of each level \\n    Map<Integer,Queue<Integer>> twoMaximum=new HashMap<>();\\n    \\n    int nodeHeight(TreeNode root,int l){\\n        \\n        if(root==null) return -1;\\n        // adding default priority Queue \\n        twoMaximum.putIfAbsent(l,new PriorityQueue<>());\\n        \\n        int temp=Math.max(nodeHeight(root.left,l+1),nodeHeight(root.right,l+1))+1;\\n        \\n        height.put(root.val,temp);\\n        level.put(root.val,l);\\n        \\n        twoMaximum.get(l).add(temp);\\n        \\n        // updating priority Queue with the 2 maximum height of current level \\n        if(twoMaximum.get(l).size()>2) twoMaximum.get(l).remove();\\n        return temp;\\n    }\\n    public int[] treeQueries(TreeNode root, int[] q) {\\n        \\n        // the height of tree \\n        int h=nodeHeight(root,0);\\n        \\n        for(int i=0;i<q.length;i++){\\n            int lev=level.get(q[i]);\\n            int hh=height.get(q[i]);     \\n            int a=-1,b=-1;\\n            // if there is more then 2 node at the level of query[i]\\n            if(twoMaximum.get(lev).size()==2){\\n                b=twoMaximum.get(lev).remove();\\n                a=twoMaximum.get(lev).remove();\\n                \\n                // if current node has maximum height, in his level then the height of tree will be impacted\\n                // and height of tree will be decrease by heightOf(queries[i])-2nd maximum height of that level;\\n                if(hh==a) q[i]=h-(a-b);\\n                \\n                // else the height of tree remains same \\n                else q[i]=h;\\n                \\n                twoMaximum.get(lev).add(a);\\n                twoMaximum.get(lev).add(b);\\n            }\\n            // if there is only one node at that level \\n            // then the height of tree will be subtracted by the height of current node\\n            else q[i]=h-hh-1;\\n        }\\n        // returning the updated query array \\n        return q;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762494,
                "title": "python-c-java-rust-code-as-explanation-bonus-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a Depth First Search approach to compute heights & depths of tree nodes. Time complexity is linear: **O(m+n)**. Space complexity is linear: **O(m+n)**\\n\\n**Comment**. The strategy here is to pre-compute three maps:\\n1. `depths` is a map that stores for each node its depth, i.e., the distance from the top (root) of the tree;\\n2. `height` is a map that stores for each node its height, i.e., the maximal length of a path to the bottom of the tree that starts from this node;\\n3. `levels` is a map that stores for each level (depth) a list of nodes on that level.\\n\\nThe idea of the solution is simple: when we remove a node, the maximal height of the resulting tree is the sum of:\\n* the depth of removed node\\'s parent (i.e., parent\\'s level) and\\n* the maximal height of the **remaining** nodes on the removed node\\'s level.\\n\\n**Python** self-explanatory (and easy-to-read) code that realizes this strategy is presented below.\\n```\\nclass Solution:\\n    \\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n    \\n        height, depths, levels = {}, {}, defaultdict(list)\\n        \\n        def dfs(n, d):\\n            if not n: return 0\\n            h = 1 + max(dfs(n.left, d+1), dfs(n.right, d+1))\\n            levels[d].append(n.val)\\n            height[n.val] = h\\n            depths[n.val] = d\\n            return h\\n        \\n        @functools.cache\\n        def query(q):\\n            max_height = max([height[v] for v in levels[depths[q]] if v != q] or [0])\\n            return depths[q] - 1 + max_height\\n        \\n        dfs(root, 0)     \\n        \\n        return [query(q) for q in queries]\\n```\\n\\nAs a bonus, I provide a more concise solution in various languages. It turns out that we can precompute the result for each possible query right inside the DFS function by using memoization/cache of height.\\n<iframe src=\"https://leetcode.com/playground/iwDQo4e9/shared\" frameBorder=\"0\" width=\"800\" height=\"640\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n    \\n        height, depths, levels = {}, {}, defaultdict(list)\\n        \\n        def dfs(n, d):\\n            if not n: return 0\\n            h = 1 + max(dfs(n.left, d+1), dfs(n.right, d+1))\\n            levels[d].append(n.val)\\n            height[n.val] = h\\n            depths[n.val] = d\\n            return h\\n        \\n        @functools.cache\\n        def query(q):\\n            max_height = max([height[v] for v in levels[depths[q]] if v != q] or [0])\\n            return depths[q] - 1 + max_height\\n        \\n        dfs(root, 0)     \\n        \\n        return [query(q) for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758491,
                "title": "java-c-dfs-preordermirror",
                "content": "### TWO DFS Preorder Mirror to each other.\\nTWO Pass:\\n* One path start from left child node first.\\n* The other path start from right child node first.\\n\\nWhen they reach to the same node [6] (for example), \\nupdate the max level they saw so far. (Does not include current node [6].)\\n\\nD[root->val] = max(left_max_level, right_max_level)\\n\\n![image](https://assets.leetcode.com/users/images/23823656-af4b-48a8-a0b6-ad8111f97229_1667190448.0634913.png)\\n\\n\\n\\n### 2-Pass DFS preorder:  from left and from right, save max level before current node.\\n```\\nclass Solution {\\npublic:\\n    vector<int> D;\\n    int lvl_left = 0;\\n    int lvl_right = 0;\\n    void preorderLeft(TreeNode* root, int level){\\n        if (root == nullptr) return;\\n        D[root->val] = lvl_left;\\n        lvl_left = max(level,lvl_left);\\n        preorderLeft(root->left,level+1);\\n        preorderLeft(root->right,level+1);\\n    }\\n    \\n    void preorderRight(TreeNode* root, int level){\\n        if (root == nullptr) return;\\n        D[root->val] = max(D[root->val], lvl_right);\\n        lvl_right = max(level,lvl_right);\\n        preorderRight(root->right,level+1);\\n        preorderRight(root->left,level+1);\\n    }\\n    \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        D.resize(100001,0);\\n        lvl_left = lvl_right = 0;\\n        preorderLeft(root,0); preorderRight(root,0);\\n        int sz = queries.size();\\n        vector<int> ans(sz,0);\\n        int i=0;\\n        for(int val : queries) {\\n            ans[i++] = D[val];\\n        }\\n        return ans;\\n    } \\n};\\n```\\n\\nJava Version\\n```\\nclass Solution {\\n    private static int leftmax;\\n    private static int rightmax;\\n    private static int[] all_lvl;\\n    \\n    private void dfsLeft(TreeNode root, int level){\\n        if (root==null){\\n            return;\\n        }\\n        all_lvl[root.val] = leftmax;\\n        leftmax = Math.max(level,leftmax);\\n        dfsLeft(root.left, level+1);\\n        dfsLeft(root.right, level+1);\\n    }\\n    private void dfsRight(TreeNode root, int level){\\n        if (root==null){\\n            return;\\n        }\\n        all_lvl[root.val] = Math.max(all_lvl[root.val], rightmax);\\n        rightmax= Math.max(level,rightmax);\\n        dfsRight(root.right, level+1);\\n        dfsRight(root.left, level+1);\\n    }\\n    \\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        leftmax=0;\\n        rightmax=0;\\n        int n = 100001;\\n        all_lvl = new int[n];\\n        dfsLeft(root,0);\\n        dfsRight(root,0);\\n        int m = queries.length;\\n        int [] ans = new int[m];\\n        for(int i = 0; i < m;i++){\\n            ans[i]=all_lvl[queries[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n### Compute Height and Depth, save Top 2 Heights at each level\\n\\n![image](https://assets.leetcode.com/users/images/0740d0aa-9f5c-4872-9007-ce53acaa65e5_1667191979.9969049.png)\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> H;\\n    vector<int> D;\\n    vector<vector<int>> lvl; //O(Height)\\n    // compute height and depth of each nodes.\\n    int n = 0;\\n    int dfs(TreeNode* r, int depth) {\\n        if (r == nullptr) return 0;\\n        D[r->val] = depth;\\n        n = max(n, r->val);\\n        int a = dfs(r->left, depth+1);\\n        int b = dfs(r->right, depth+1);\\n        int h = max(a,b)+1;\\n        H[r->val] = h;\\n        return h;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n       \\n        // DFS: save height and depth\\n        H.resize(100001, 0); //O(N)\\n        D.resize(100001, 0);\\n        int max_lvl = dfs(root, 0) - 1;\\n        \\n        // Save Top 2 heights at each level.\\n        lvl.resize(max_lvl+1, vector<int>(2, 0));\\n        for(int val = 1; val <= n; ++val) {\\n            int d = D[val];\\n            auto & v = lvl[d];\\n            int& a = v[0];\\n            int& b = v[1];\\n            // keep H[a] <= H[b]\\n            if (H[val] > H[a] && H[val] < H[b]) {\\n                a = val;\\n            } else if (H[val] >= H[b]) {\\n                a = b; \\n                b = val;\\n            }\\n        }\\n        \\n        int i = 0;\\n        vector<int> ans(queries.size(), max_lvl);\\n        for(auto x: queries) {\\n            int lvl_cnt = D[x]; \\n            auto& v = lvl[lvl_cnt];\\n            // x is the max height, update with 2nd heightest at this level.\\n            if (x == v[1]) {\\n                ans[i] = lvl_cnt + H[v[0]] - 1;\\n            }\\n            ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> D;\\n    int lvl_left = 0;\\n    int lvl_right = 0;\\n    void preorderLeft(TreeNode* root, int level){\\n        if (root == nullptr) return;\\n        D[root->val] = lvl_left;\\n        lvl_left = max(level,lvl_left);\\n        preorderLeft(root->left,level+1);\\n        preorderLeft(root->right,level+1);\\n    }\\n    \\n    void preorderRight(TreeNode* root, int level){\\n        if (root == nullptr) return;\\n        D[root->val] = max(D[root->val], lvl_right);\\n        lvl_right = max(level,lvl_right);\\n        preorderRight(root->right,level+1);\\n        preorderRight(root->left,level+1);\\n    }\\n    \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        D.resize(100001,0);\\n        lvl_left = lvl_right = 0;\\n        preorderLeft(root,0); preorderRight(root,0);\\n        int sz = queries.size();\\n        vector<int> ans(sz,0);\\n        int i=0;\\n        for(int val : queries) {\\n            ans[i++] = D[val];\\n        }\\n        return ans;\\n    } \\n};\\n```\n```\\nclass Solution {\\n    private static int leftmax;\\n    private static int rightmax;\\n    private static int[] all_lvl;\\n    \\n    private void dfsLeft(TreeNode root, int level){\\n        if (root==null){\\n            return;\\n        }\\n        all_lvl[root.val] = leftmax;\\n        leftmax = Math.max(level,leftmax);\\n        dfsLeft(root.left, level+1);\\n        dfsLeft(root.right, level+1);\\n    }\\n    private void dfsRight(TreeNode root, int level){\\n        if (root==null){\\n            return;\\n        }\\n        all_lvl[root.val] = Math.max(all_lvl[root.val], rightmax);\\n        rightmax= Math.max(level,rightmax);\\n        dfsRight(root.right, level+1);\\n        dfsRight(root.left, level+1);\\n    }\\n    \\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        leftmax=0;\\n        rightmax=0;\\n        int n = 100001;\\n        all_lvl = new int[n];\\n        dfsLeft(root,0);\\n        dfsRight(root,0);\\n        int m = queries.length;\\n        int [] ans = new int[m];\\n        for(int i = 0; i < m;i++){\\n            ans[i]=all_lvl[queries[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> H;\\n    vector<int> D;\\n    vector<vector<int>> lvl; //O(Height)\\n    // compute height and depth of each nodes.\\n    int n = 0;\\n    int dfs(TreeNode* r, int depth) {\\n        if (r == nullptr) return 0;\\n        D[r->val] = depth;\\n        n = max(n, r->val);\\n        int a = dfs(r->left, depth+1);\\n        int b = dfs(r->right, depth+1);\\n        int h = max(a,b)+1;\\n        H[r->val] = h;\\n        return h;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n       \\n        // DFS: save height and depth\\n        H.resize(100001, 0); //O(N)\\n        D.resize(100001, 0);\\n        int max_lvl = dfs(root, 0) - 1;\\n        \\n        // Save Top 2 heights at each level.\\n        lvl.resize(max_lvl+1, vector<int>(2, 0));\\n        for(int val = 1; val <= n; ++val) {\\n            int d = D[val];\\n            auto & v = lvl[d];\\n            int& a = v[0];\\n            int& b = v[1];\\n            // keep H[a] <= H[b]\\n            if (H[val] > H[a] && H[val] < H[b]) {\\n                a = val;\\n            } else if (H[val] >= H[b]) {\\n                a = b; \\n                b = val;\\n            }\\n        }\\n        \\n        int i = 0;\\n        vector<int> ans(queries.size(), max_lvl);\\n        for(auto x: queries) {\\n            int lvl_cnt = D[x]; \\n            auto& v = lvl[lvl_cnt];\\n            // x is the max height, update with 2nd heightest at this level.\\n            if (x == v[1]) {\\n                ans[i] = lvl_cnt + H[v[0]] - 1;\\n            }\\n            ++i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758058,
                "title": "dfs-c-explained-with-picutes",
                "content": "Explanation:\\nAs shown in below picture, we do a pre-order traveral and mark indices.\\n\\n![image](https://assets.leetcode.com/users/images/415ff652-3ef3-4d4a-be3c-0839370ae4b7_1667102528.0020385.png)\\n\\n\\nSimultaneously, store the depths of each node in same order of their indices.\\n![image](https://assets.leetcode.com/users/images/724123cc-18e0-4a05-a912-2e7729c86fad_1667102536.2512622.png)\\nNow, follow the steps to get the answer:\\n1. We calculate the number of nodes under each node using simple dfs in O(n)\\n2. Create two arrays left_max, right_max. Store the prefix maximum in left_max and suffix maximum in right_max.\\n3. Since we have the index of the node and the number of nodes under it, we can easily calculate the subarray of indices that needs to be excluded.\\nFor example, \\nIf we queries[i] = 2,\\nits index is 2.\\n\\nSo we query the maximum in the subarray of (0, 1) and (5, 8)\\nWe excluded (2, 4) because, 2 is starting index and it has 3 nodes under it.\\nFor more calarity, look at picture below:\\n![image](https://assets.leetcode.com/users/images/ecb360db-a62e-49d2-b0c2-c316645af361_1667102688.4487271.png)\\n\\nFinally after max query, we store the answer in array and we return it.\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    int n = 0;\\n    map<int, int> idx_map;\\n    map<int, int> nodes_under_me;\\n    vector<int> depths, right_max, left_max;\\n    void dfs(TreeNode *root, int depth){\\n        if(!root)   return;\\n        idx_map[root->val] = n++;\\n        depths.push_back(depth);\\n        dfs(root -> left, depth + 1);\\n        dfs(root -> right, depth + 1);\\n    }\\n    \\n    int calc_nodes_under_me(TreeNode *root){\\n        if(!root)   return 0;\\n        nodes_under_me[root->val] = calc_nodes_under_me(root->left) + calc_nodes_under_me(root->right) + 1;\\n        return nodes_under_me[root->val];\\n    }\\n    \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int i, st, en, curr_ans;\\n        vector<int> ans;\\n        dfs(root, 0);\\n        calc_nodes_under_me(root);\\n        left_max.push_back(depths[0]);  right_max.push_back(depths[n-1]);\\n        for(i=1;i<n;i++)    left_max.push_back(max(left_max.back(), depths[i])), right_max.push_back(max(right_max.back(), depths[n-i-1]));\\n        reverse(right_max.begin(), right_max.end());\\n        \\n        for(i=0;i<queries.size();i++){\\n            en = idx_map[queries[i]] - 1;\\n            st = en + 1 + nodes_under_me[queries[i]];\\n            curr_ans = left_max[en];\\n            if(st < n)  curr_ans = max(curr_ans, right_max[st]);\\n            ans.push_back(curr_ans);\\n        }        \\n        return ans;\\n    }\\n};\\n```\\n\\nThank you. Encourage me to post such solutions by upvoting this post.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n = 0;\\n    map<int, int> idx_map;\\n    map<int, int> nodes_under_me;\\n    vector<int> depths, right_max, left_max;\\n    void dfs(TreeNode *root, int depth){\\n        if(!root)   return;\\n        idx_map[root->val] = n++;\\n        depths.push_back(depth);\\n        dfs(root -> left, depth + 1);\\n        dfs(root -> right, depth + 1);\\n    }\\n    \\n    int calc_nodes_under_me(TreeNode *root){\\n        if(!root)   return 0;\\n        nodes_under_me[root->val] = calc_nodes_under_me(root->left) + calc_nodes_under_me(root->right) + 1;\\n        return nodes_under_me[root->val];\\n    }\\n    \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int i, st, en, curr_ans;\\n        vector<int> ans;\\n        dfs(root, 0);\\n        calc_nodes_under_me(root);\\n        left_max.push_back(depths[0]);  right_max.push_back(depths[n-1]);\\n        for(i=1;i<n;i++)    left_max.push_back(max(left_max.back(), depths[i])), right_max.push_back(max(right_max.back(), depths[n-i-1]));\\n        reverse(right_max.begin(), right_max.end());\\n        \\n        for(i=0;i<queries.size();i++){\\n            en = idx_map[queries[i]] - 1;\\n            st = en + 1 + nodes_under_me[queries[i]];\\n            curr_ans = left_max[en];\\n            if(st < n)  curr_ans = max(curr_ans, right_max[st]);\\n            ans.push_back(curr_ans);\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758638,
                "title": "eulerian-tour-use-in-problems-of-subtree-removal",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION HELPFUL :)**\\n\\n```\\n/*\\nEULERIAN TOUR: primarily used while handling problems of subtree removal\\nmake a tour during performing a dfs traversal and store it\\n\\nfor a trivial tree: root\\n                    /  \\\\\\n                  left right\\nthe tour will be:root->left->left->right->right->root\\nso every node will appear twice in the tour array once when it is visited for the first time(no left or\\nright subtree of it is visited earlier) and the other when it is visited for the last time(when both left and right subtrees are visited)\\n\\nNOW WHEN A SUBTREE IS REMOVED THE REMAINING TREE THAT WE HAVE WOULD BE THE SUBARRAY BEFORE THE FIRST \\nOCCURENCE OF ROOT AND THE SUBARRAY AFTER THE LAST OCCURENCE OF ROOT\\n\\nNow we will make a prefix-max-height and a suffix-max-height for this tour array and after the removal of\\na subtree the resultant maximum height will be max(prefix_max(first occurence ofsubtree- root-1),suffix_max(last occurence ofsubtree- root+1))\\n*/\\n\\nclass Solution {\\n    vector<int>tour,mhl,mhr;\\n    map<int,int>h,first,last;\\n    void dfs(TreeNode* root,int height)\\n    {\\n        if(!root)return;\\n        h[root->val]=height;\\n        first[root->val]=tour.size();\\n        tour.push_back(root->val);\\n        dfs(root->left,height+1);\\n        dfs(root->right,height+1);\\n        last[root->val]=tour.size();\\n        tour.push_back(root->val);\\n    }\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        dfs(root,0);\\n        mhl=vector<int>(tour.size());\\n        mhr=vector<int>(tour.size());\\n        mhl[0]=mhr[tour.size()-1]=h[root->val];\\n     \\n        for(int i=1;i<tour.size();i++)mhl[i]=max(mhl[i-1],h[tour[i]]);\\n        for(int i=tour.size()-2;i>=0;i--)mhr[i]=max(mhr[i+1],h[tour[i]]);\\n        vector<int>res;\\n        for(int q:queries)\\n        {\\n            res.push_back(max(mhl[first[q]-1],mhr[last[q]+1]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nEULERIAN TOUR: primarily used while handling problems of subtree removal\\nmake a tour during performing a dfs traversal and store it\\n\\nfor a trivial tree: root\\n                    /  \\\\\\n                  left right\\nthe tour will be:root->left->left->right->right->root\\nso every node will appear twice in the tour array once when it is visited for the first time(no left or\\nright subtree of it is visited earlier) and the other when it is visited for the last time(when both left and right subtrees are visited)\\n\\nNOW WHEN A SUBTREE IS REMOVED THE REMAINING TREE THAT WE HAVE WOULD BE THE SUBARRAY BEFORE THE FIRST \\nOCCURENCE OF ROOT AND THE SUBARRAY AFTER THE LAST OCCURENCE OF ROOT\\n\\nNow we will make a prefix-max-height and a suffix-max-height for this tour array and after the removal of\\na subtree the resultant maximum height will be max(prefix_max(first occurence ofsubtree- root-1),suffix_max(last occurence ofsubtree- root+1))\\n*/\\n\\nclass Solution {\\n    vector<int>tour,mhl,mhr;\\n    map<int,int>h,first,last;\\n    void dfs(TreeNode* root,int height)\\n    {\\n        if(!root)return;\\n        h[root->val]=height;\\n        first[root->val]=tour.size();\\n        tour.push_back(root->val);\\n        dfs(root->left,height+1);\\n        dfs(root->right,height+1);\\n        last[root->val]=tour.size();\\n        tour.push_back(root->val);\\n    }\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        dfs(root,0);\\n        mhl=vector<int>(tour.size());\\n        mhr=vector<int>(tour.size());\\n        mhl[0]=mhr[tour.size()-1]=h[root->val];\\n     \\n        for(int i=1;i<tour.size();i++)mhl[i]=max(mhl[i-1],h[tour[i]]);\\n        for(int i=tour.size()-2;i>=0;i--)mhr[i]=max(mhr[i+1],h[tour[i]]);\\n        vector<int>res;\\n        for(int q:queries)\\n        {\\n            res.push_back(max(mhl[first[q]-1],mhr[last[q]+1]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759081,
                "title": "java-very-easy-dfs-memoization-100-faster",
                "content": "\\tint[] h, l, r;\\n\\t// Store the height of each node\\'s left and right child\\n    public int height(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        int lh = height(root.left);\\n        int rh = height(root.right);\\n        \\n        l[root.val] = lh;\\n        r[root.val] = rh;\\n        \\n        return 1+Math.max(lh, rh);\\n    }\\n\\t// Store the max height of each node if deleted\\n    public void solve(TreeNode root, int curmax, int depth){\\n        if(root == null) return;\\n        \\n        h[root.val] = curmax;\\n\\t\\t//max of (current depth + right/left height, maxSoFar)\\n        solve(root.left, Math.max(curmax, depth+r[root.val]), depth+1);\\n        solve(root.right, Math.max(curmax, depth+l[root.val]), depth+1);\\n    }\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        h = new int[100001];\\n        l = new int[100001];\\n        r = new int[100001];\\n        \\n        height(root);\\n        solve(root.left, r[root.val], 1);\\n        solve(root.right, l[root.val], 1);\\n        \\n        int n = queries.length;\\n        int[] q = new int[n];\\n        for(int i=0; i<n; i++){\\n            q[i] = h[queries[i]]; //Query in O(1)\\n        }\\n        return q;\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "\\tint[] h, l, r;\\n\\t// Store the height of each node\\'s left and right child\\n    public int height(TreeNode root){\\n        if(root == null) return 0;\\n        \\n        int lh = height(root.left);\\n        int rh = height(root.right);\\n        \\n        l[root.val] = lh;\\n        r[root.val] = rh;\\n        \\n        return 1+Math.max(lh, rh);\\n    }\\n\\t// Store the max height of each node if deleted\\n    public void solve(TreeNode root, int curmax, int depth){\\n        if(root == null) return;\\n        \\n        h[root.val] = curmax;\\n\\t\\t//max of (current depth + right/left height, maxSoFar)\\n        solve(root.left, Math.max(curmax, depth+r[root.val]), depth+1);\\n        solve(root.right, Math.max(curmax, depth+l[root.val]), depth+1);\\n    }\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        h = new int[100001];\\n        l = new int[100001];\\n        r = new int[100001];\\n        \\n        height(root);\\n        solve(root.left, r[root.val], 1);\\n        solve(root.right, l[root.val], 1);\\n        \\n        int n = queries.length;\\n        int[] q = new int[n];\\n        for(int i=0; i<n; i++){\\n            q[i] = h[queries[i]]; //Query in O(1)\\n        }\\n        return q;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2757974,
                "title": "2-pass-preorder-traversal",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        dp = defaultdict(int)\\n        def preorder(root, h):\\n            if root:\\n                dp[root.val] = max(dp[root.val], self.maxheight)\\n                self.maxheight = max(self.maxheight, h)\\n                preorder(root.left, h + 1)\\n                preorder(root.right, h + 1)\\n        def preorderrev(root, h):\\n            if root:\\n                dp[root.val] = max(dp[root.val], self.maxheight)\\n                self.maxheight = max(self.maxheight, h)\\n                preorderrev(root.right, h + 1)\\n                preorderrev(root.left, h + 1)\\n        self.maxheight = 0\\n        preorder(root, 0)\\n        self.maxheight = 0\\n        preorderrev(root, 0)\\n        res = []\\n        for q in queries:\\n            res.append(dp[q])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        dp = defaultdict(int)\\n        def preorder(root, h):\\n            if root:\\n                dp[root.val] = max(dp[root.val], self.maxheight)\\n                self.maxheight = max(self.maxheight, h)\\n                preorder(root.left, h + 1)\\n                preorder(root.right, h + 1)\\n        def preorderrev(root, h):\\n            if root:\\n                dp[root.val] = max(dp[root.val], self.maxheight)\\n                self.maxheight = max(self.maxheight, h)\\n                preorderrev(root.right, h + 1)\\n                preorderrev(root.left, h + 1)\\n        self.maxheight = 0\\n        preorder(root, 0)\\n        self.maxheight = 0\\n        preorderrev(root, 0)\\n        res = []\\n        for q in queries:\\n            res.append(dp[q])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078705,
                "title": "beats-100-0-ms-16-ms",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int leftMax;\\n    int rightMax;\\n    // HashMap<Integer, Integer> allLevel;\\n    int[] allL;\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        leftMax = 0;\\n        rightMax = 0;\\n        // allLevel = new HashMap<>();\\n        allL = new int[100001];\\n        int[] res = new int[queries.length];\\n        dfsLeft(root, 0);\\n        dfsRight(root, 0);\\n        for(int i = 0; i < queries.length; i++){\\n            res[i] = allL[queries[i]];\\n        }\\n        return res;\\n    }\\n    \\n    public void dfsLeft(TreeNode root, int level){\\n        if(root == null) return;\\n        allL[root.val] = leftMax;\\n        leftMax = Math.max(leftMax, level);\\n        dfsLeft(root.left, level + 1);\\n        dfsLeft(root.right, level + 1);\\n    }\\n    \\n     public void dfsRight(TreeNode root, int level){\\n        if(root == null) return;\\n        allL[root.val] = Math.max(rightMax, allL[root.val]);\\n        rightMax = Math.max(rightMax, level);\\n        dfsRight(root.right, level + 1);\\n        dfsRight(root.left, level + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int leftMax;\\n    int rightMax;\\n    // HashMap<Integer, Integer> allLevel;\\n    int[] allL;\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        leftMax = 0;\\n        rightMax = 0;\\n        // allLevel = new HashMap<>();\\n        allL = new int[100001];\\n        int[] res = new int[queries.length];\\n        dfsLeft(root, 0);\\n        dfsRight(root, 0);\\n        for(int i = 0; i < queries.length; i++){\\n            res[i] = allL[queries[i]];\\n        }\\n        return res;\\n    }\\n    \\n    public void dfsLeft(TreeNode root, int level){\\n        if(root == null) return;\\n        allL[root.val] = leftMax;\\n        leftMax = Math.max(leftMax, level);\\n        dfsLeft(root.left, level + 1);\\n        dfsLeft(root.right, level + 1);\\n    }\\n    \\n     public void dfsRight(TreeNode root, int level){\\n        if(root == null) return;\\n        allL[root.val] = Math.max(rightMax, allL[root.val]);\\n        rightMax = Math.max(rightMax, level);\\n        dfsRight(root.right, level + 1);\\n        dfsRight(root.left, level + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769465,
                "title": "c-height-and-depth-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,int> l,r,h;\\n    int height(TreeNode *root)\\n    {\\n        if(!root) return 0;\\n        \\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n        \\n        l[root->val] = lh;\\n        r[root->val] = rh;\\n        \\n        return max(lh,rh)+1;\\n    }\\n    void solve(TreeNode *root,int maxa,int depth){\\n        if(!root) return;\\n        \\n        h[root->val] = maxa;\\n        \\n        solve(root->left, max(maxa, depth+r[root->val]), depth+1);\\n        solve(root->right, max(maxa, depth+l[root->val]),depth+1);\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        height(root);\\n        solve(root->left, r[root->val], 1);\\n        solve(root->right, l[root->val], 1);\\n        \\n        vector<int> ans;\\n        \\n        for(int i=0;i<queries.size();i++){\\n            ans.push_back(h[queries[i]]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> l,r,h;\\n    int height(TreeNode *root)\\n    {\\n        if(!root) return 0;\\n        \\n        int lh = height(root->left);\\n        int rh = height(root->right);\\n        \\n        l[root->val] = lh;\\n        r[root->val] = rh;\\n        \\n        return max(lh,rh)+1;\\n    }\\n    void solve(TreeNode *root,int maxa,int depth){\\n        if(!root) return;\\n        \\n        h[root->val] = maxa;\\n        \\n        solve(root->left, max(maxa, depth+r[root->val]), depth+1);\\n        solve(root->right, max(maxa, depth+l[root->val]),depth+1);\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        height(root);\\n        solve(root->left, r[root->val], 1);\\n        solve(root->right, l[root->val], 1);\\n        \\n        vector<int> ans;\\n        \\n        for(int i=0;i<queries.size();i++){\\n            ans.push_back(h[queries[i]]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760589,
                "title": "java-custom-tree-node-height-impact",
                "content": "# Intuition\\nFirst of all we are going to created a `CustomTreeNode` that will add the following data for every tree node:\\n* Parent pointer\\n* Right subtree height\\n* Left subtree height\\n\\nWe are also going to create a `Map<Integer, CustomTreeNode>` so we can get direct access of the deleted node.\\n\\nFrom here we are going to traverse upwards and check if by deleting the current node we impacted the parent node maximum height. If we did, we calculate the `deltaOfDeletion` which is basically a number representing how much of the max-height to remove from the next parent.\\n\\nWe do this the whole way up the tree (we have reference to parents) and get the root node height.\\n\\n# Code\\n```\\nclass Solution {\\n    Map<Integer, CustomTreeNode> valToCustomNode = new HashMap<>();\\n\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        CustomTreeNode customRoot = buildCustomTree(null, root); // also sets valToCustomNode - side effect for efficiency\\n        setNodeHeights(customRoot);\\n        int m = queries.length;\\n        int[] res = new int[m];\\n\\n        for (int i = 0; i < m; i++) {\\n            int query = queries[i];\\n\\n            CustomTreeNode impactedNode = valToCustomNode.get(query);\\n            int deltaOfDeletion = impactedNode.treeHeight();\\n\\n            while (impactedNode.parent != null) {\\n                CustomTreeNode parent = impactedNode.parent;\\n                int curNewMaxHeight = 0;\\n\\n\\t\\t\\t\\t// Indicates impactedNode is the *right* node of parent\\n                if (parent.right != null && parent.right.val == impactedNode.val) {\\n                    int newRightHeight = parent.rightTreeHeight - deltaOfDeletion;\\n                    curNewMaxHeight = Math.max(parent.leftTreeHeight, newRightHeight);\\n\\n\\t\\t\\t\\t// Indicates impactedNode is the *left* node of parent\\n                } else {\\n                    int newLeftHeight = parent.leftTreeHeight - deltaOfDeletion;\\n                    curNewMaxHeight = Math.max(newLeftHeight, parent.rightTreeHeight);\\n                }\\n\\n                deltaOfDeletion = parent.treeHeight() - curNewMaxHeight;\\n                impactedNode = parent;\\n\\t\\n\\t\\t\\t\\t// There is no more impact to the deletion. (example: deleted left subtree but right subtree was bigger)\\n                if (deltaOfDeletion == 0) break; // Optimization\\n            }\\n\\n            res[i] = customRoot.treeHeight() - deltaOfDeletion - 1;\\n\\n        }\\n\\n        return res;\\n    }\\n\\n    private CustomTreeNode buildCustomTree(CustomTreeNode parent, TreeNode root) {\\n        if (root == null) return null;\\n\\n        CustomTreeNode node = new CustomTreeNode(root.val, parent);\\n        node.setRightTree(buildCustomTree(node, root.right));\\n        node.setLeftTree(buildCustomTree(node, root.left));\\n        valToCustomNode.put(node.val, node);\\n\\n        return node;\\n    }\\n\\n    private int setNodeHeights(CustomTreeNode node) {\\n        if (node == null) return 0;\\n\\n        int leftNodeHeight = setNodeHeights(node.left);\\n        int rightNodeHeight = setNodeHeights(node.right);\\n        node.leftTreeHeight = 1 + leftNodeHeight;\\n        node.rightTreeHeight = 1 + rightNodeHeight;\\n        return node.treeHeight();\\n\\n    }\\n\\n\\n    class CustomTreeNode {\\n        public int val;\\n        public CustomTreeNode parent;\\n        public CustomTreeNode left;\\n        public CustomTreeNode right;\\n        public int leftTreeHeight;\\n        public int rightTreeHeight;\\n\\n        public CustomTreeNode(int val, CustomTreeNode parent) {\\n            this.val = val;\\n            this.parent = parent;\\n        }\\n\\n        public void setRightTree(CustomTreeNode rightNode) {\\n            this.right = rightNode;\\n        }\\n\\n        public void setLeftTree(CustomTreeNode leftNode) {\\n            this.left = leftNode;\\n        }\\n\\n        public int treeHeight() {\\n            return Math.max(leftTreeHeight, rightTreeHeight);\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"CustomTreeNode{\" +\\n                    \"val=\" + val +\\n                    \", leftTreeHeight=\" + leftTreeHeight +\\n                    \", rightTreeHeight=\" + rightTreeHeight +\\n                    \\'}\\';\\n        }\\n    }\\n}\\n```\\n\\n# Complexity\\nm - queries\\nn - number of nodes\\n\\nAverage case - `m * log(n)`\\nWorst case - `m * n`",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, CustomTreeNode> valToCustomNode = new HashMap<>();\\n\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        CustomTreeNode customRoot = buildCustomTree(null, root); // also sets valToCustomNode - side effect for efficiency\\n        setNodeHeights(customRoot);\\n        int m = queries.length;\\n        int[] res = new int[m];\\n\\n        for (int i = 0; i < m; i++) {\\n            int query = queries[i];\\n\\n            CustomTreeNode impactedNode = valToCustomNode.get(query);\\n            int deltaOfDeletion = impactedNode.treeHeight();\\n\\n            while (impactedNode.parent != null) {\\n                CustomTreeNode parent = impactedNode.parent;\\n                int curNewMaxHeight = 0;\\n\\n\\t\\t\\t\\t// Indicates impactedNode is the *right* node of parent\\n                if (parent.right != null && parent.right.val == impactedNode.val) {\\n                    int newRightHeight = parent.rightTreeHeight - deltaOfDeletion;\\n                    curNewMaxHeight = Math.max(parent.leftTreeHeight, newRightHeight);\\n\\n\\t\\t\\t\\t// Indicates impactedNode is the *left* node of parent\\n                } else {\\n                    int newLeftHeight = parent.leftTreeHeight - deltaOfDeletion;\\n                    curNewMaxHeight = Math.max(newLeftHeight, parent.rightTreeHeight);\\n                }\\n\\n                deltaOfDeletion = parent.treeHeight() - curNewMaxHeight;\\n                impactedNode = parent;\\n\\t\\n\\t\\t\\t\\t// There is no more impact to the deletion. (example: deleted left subtree but right subtree was bigger)\\n                if (deltaOfDeletion == 0) break; // Optimization\\n            }\\n\\n            res[i] = customRoot.treeHeight() - deltaOfDeletion - 1;\\n\\n        }\\n\\n        return res;\\n    }\\n\\n    private CustomTreeNode buildCustomTree(CustomTreeNode parent, TreeNode root) {\\n        if (root == null) return null;\\n\\n        CustomTreeNode node = new CustomTreeNode(root.val, parent);\\n        node.setRightTree(buildCustomTree(node, root.right));\\n        node.setLeftTree(buildCustomTree(node, root.left));\\n        valToCustomNode.put(node.val, node);\\n\\n        return node;\\n    }\\n\\n    private int setNodeHeights(CustomTreeNode node) {\\n        if (node == null) return 0;\\n\\n        int leftNodeHeight = setNodeHeights(node.left);\\n        int rightNodeHeight = setNodeHeights(node.right);\\n        node.leftTreeHeight = 1 + leftNodeHeight;\\n        node.rightTreeHeight = 1 + rightNodeHeight;\\n        return node.treeHeight();\\n\\n    }\\n\\n\\n    class CustomTreeNode {\\n        public int val;\\n        public CustomTreeNode parent;\\n        public CustomTreeNode left;\\n        public CustomTreeNode right;\\n        public int leftTreeHeight;\\n        public int rightTreeHeight;\\n\\n        public CustomTreeNode(int val, CustomTreeNode parent) {\\n            this.val = val;\\n            this.parent = parent;\\n        }\\n\\n        public void setRightTree(CustomTreeNode rightNode) {\\n            this.right = rightNode;\\n        }\\n\\n        public void setLeftTree(CustomTreeNode leftNode) {\\n            this.left = leftNode;\\n        }\\n\\n        public int treeHeight() {\\n            return Math.max(leftTreeHeight, rightTreeHeight);\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"CustomTreeNode{\" +\\n                    \"val=\" + val +\\n                    \", leftTreeHeight=\" + leftTreeHeight +\\n                    \", rightTreeHeight=\" + rightTreeHeight +\\n                    \\'}\\';\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758310,
                "title": "euler-tour-based-solution",
                "content": "* So Basically we create with euler tour array with elements and its depth from root, like for tree as shown : \\n\\t*           \"1\"\\n\\t\\t     \" /   \\\\\"\\n\\t\\t    \"2      3\"\\n\\t\\t   \"/\"\\n\\t\\t  \"4\"\\n* euler tour array is [(1,0),(2,1),(4,2),(4,2),(2,1),(3,1),(3,1),(1,0)]\\n* now lets say if we remove subtree  2 than array from index 1 to 4 is removed so now what is maximum height of tree so basically is the maximum height till from index 0 to 1 (not included) and maximum height from index(5 to 7) so we can maintain a prefix and suffix maximum array upto a particular point \\n* LET ME EXPLAIN THE MY ROUGH ALGO NOW\\n* create a euler tour array as u can see\\n* for each node maintain its starting and ending index in euler tour array \\n* pre and suf have the maximum  in prefix till i and suffix from i to end \\n* So for a particular query we find starting and ending point of subtree with the element and find prefix maxium till start and suffix maximum till end \\nIf u like the explanation please do upvote it motivates me a lot \\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        def solve(node,level):\\n            euler_tour.append((node.val,level))\\n            if node.left:\\n                solve(node.left,level+1)\\n            if node.right:\\n                solve(node.right,level+1)\\n            euler_tour.append((node.val,level))\\n        euler_tour=[]\\n        solve(root,1)\\n        d={}\\n        for i,el in enumerate(euler_tour):\\n            if el[0] in d:\\n                d[el[0]].append(i)\\n            else:\\n                d[el[0]]=[i]\\n        pre=[0]\\n        for el,l in euler_tour:\\n            pre.append(max(pre[-1],l))\\n        suf=[0]\\n        for el,l in euler_tour[::-1]:\\n            suf.append(max(suf[-1],l))\\n        suf=suf[::-1]\\n        ans=[]\\n        \\n        for el in queries:\\n            start,end=d[el]\\n            ans.append(max(pre[start],suf[end+1])-1)\\n        return ans\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        def solve(node,level):\\n            euler_tour.append((node.val,level))\\n            if node.left:\\n                solve(node.left,level+1)\\n            if node.right:\\n                solve(node.right,level+1)\\n            euler_tour.append((node.val,level))\\n        euler_tour=[]\\n        solve(root,1)\\n        d={}\\n        for i,el in enumerate(euler_tour):\\n            if el[0] in d:\\n                d[el[0]].append(i)\\n            else:\\n                d[el[0]]=[i]\\n        pre=[0]\\n        for el,l in euler_tour:\\n            pre.append(max(pre[-1],l))\\n        suf=[0]\\n        for el,l in euler_tour[::-1]:\\n            suf.append(max(suf[-1],l))\\n        suf=suf[::-1]\\n        ans=[]\\n        \\n        for el in queries:\\n            start,end=d[el]\\n            ans.append(max(pre[start],suf[end+1])-1)\\n        return ans\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2758247,
                "title": "time-100-memo-100-preorder-reverse-preorder-node-right-left",
                "content": "The explantion is for preorder we will be storing the maximum height we till its predecessor.\\nsame goes to the reverse preorder. and we are stroing the values in an array\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[100001]={0};\\n    int maxi1=0,maxi2=0;\\n    void dfs(TreeNode *root,int height=0)\\n    {\\n        if(root==NULL)\\n            return;\\n        dp[root->val]=max(maxi2,dp[root->val]);  \\n        maxi2=max(maxi2,height);      \\n        dfs(root->left,height+1);\\n        dfs(root->right,height+1);          \\n    }\\n    \\n    void reversedfs(TreeNode *root,int height=0)\\n    {\\n        \\n        if(root==NULL)\\n        return ;        \\n        dp[root->val]=max(maxi1,dp[root->val]);\\n        maxi1=max(maxi1,height);\\n        reversedfs(root->right,height+1);\\n        reversedfs(root->left,height+1); \\n        return;       \\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) \\n    {\\n        vector<int>ans;\\n        dfs(root,0);\\n        reversedfs(root,0);\\n          \\n        for(int i=0;i<queries.size();i++)\\n        {\\n            ans.push_back(dp[queries[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[100001]={0};\\n    int maxi1=0,maxi2=0;\\n    void dfs(TreeNode *root,int height=0)\\n    {\\n        if(root==NULL)\\n            return;\\n        dp[root->val]=max(maxi2,dp[root->val]);  \\n        maxi2=max(maxi2,height);      \\n        dfs(root->left,height+1);\\n        dfs(root->right,height+1);          \\n    }\\n    \\n    void reversedfs(TreeNode *root,int height=0)\\n    {\\n        \\n        if(root==NULL)\\n        return ;        \\n        dp[root->val]=max(maxi1,dp[root->val]);\\n        maxi1=max(maxi1,height);\\n        reversedfs(root->right,height+1);\\n        reversedfs(root->left,height+1); \\n        return;       \\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) \\n    {\\n        vector<int>ans;\\n        dfs(root,0);\\n        reversedfs(root,0);\\n          \\n        for(int i=0;i<queries.size();i++)\\n        {\\n            ans.push_back(dp[queries[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758202,
                "title": "python-simple-traverse-dp-o-n",
                "content": "The idea is simple, say a node A has left child B and right child C, max depth in the tree after removing C is either:\\n```\\n              X\\n       A            X\\n    B     C      X     X\\n   X X   X X \\n```\\n(1) the max depth within the sub tree of B, or \\n(2) the max depth  in the tree after removing A\\n\\nmax_depth_without_subtree(val) returns max depth in the tree after removing subtree at node with value val. then (1) is done through recursion (with cache/dp to avoid re-computation) while (2) is done by simply storing every node\\'s depth and max depth of its left/right sub tree in one pass by dfs(node, parent, depth).\\n\\ncomplexity is O(n) for 1 pass preprocessing and O(n + #queries) for max_depth_without_subtree(val) on all queries due to the cache, and eventually O(n) since #queries <= n.\\n\\n```\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        node_to_parent = {}\\n        value_to_node = {}\\n        # node to its depth\\n        node_to_depth = {}\\n        # node to max depth of its left and right subtree\\n        node_to_subtree_max_depths = {}\\n        \\n        def traverse(node, parent, depth):\\n            if not node:\\n                return 0\\n            value_to_node[node.val] = node\\n            node_to_parent[node] = parent\\n            node_to_depth[node] = depth\\n            l = dfs(node.left, node, depth+1)\\n            r = dfs(node.right, node, depth+1)\\n            node_to_subtree_max_depths[node] = [l, r]\\n            return max(l, r)+1\\n        \\n        traverse(root, None, 0)\\n        \\n        @cache\\n        def max_depth_without_subtree(val):\\n            node = value_to_node[val]\\n            if node == root:\\n                return -1\\n            parent = node_to_parent[node]\\n            if parent.left == node:\\n                max_depth = node_to_depth[parent] + node_to_subtree_max_depths[parent][1]\\n            else:\\n                max_depth = node_to_depth[parent] + node_to_subtree_max_depths[parent][0]\\n            return max(max_depth, max_depth_without_subtree(parent.val))\\n        \\n        return [max_depth_without_subtree(q) for q in queries] \\n```",
                "solutionTags": [],
                "code": "```\\n              X\\n       A            X\\n    B     C      X     X\\n   X X   X X \\n```\n```\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        node_to_parent = {}\\n        value_to_node = {}\\n        # node to its depth\\n        node_to_depth = {}\\n        # node to max depth of its left and right subtree\\n        node_to_subtree_max_depths = {}\\n        \\n        def traverse(node, parent, depth):\\n            if not node:\\n                return 0\\n            value_to_node[node.val] = node\\n            node_to_parent[node] = parent\\n            node_to_depth[node] = depth\\n            l = dfs(node.left, node, depth+1)\\n            r = dfs(node.right, node, depth+1)\\n            node_to_subtree_max_depths[node] = [l, r]\\n            return max(l, r)+1\\n        \\n        traverse(root, None, 0)\\n        \\n        @cache\\n        def max_depth_without_subtree(val):\\n            node = value_to_node[val]\\n            if node == root:\\n                return -1\\n            parent = node_to_parent[node]\\n            if parent.left == node:\\n                max_depth = node_to_depth[parent] + node_to_subtree_max_depths[parent][1]\\n            else:\\n                max_depth = node_to_depth[parent] + node_to_subtree_max_depths[parent][0]\\n            return max(max_depth, max_depth_without_subtree(parent.val))\\n        \\n        return [max_depth_without_subtree(q) for q in queries] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758038,
                "title": "very-stupid-c-solution-eulerian-tour-on-trees",
                "content": "# Warning\\nThis is definitely not the most optimal solution, not just in time/memory complexity (both O(NlogN)), but also in implementation (as you can see below, it isnt pretty, but I tried to explain it). \\nI used the Euler tour technique on trees, which seems and likely is overkill\\n\\n \\n# Algorithm\\nNow, what the Euler tour technique does on a tree is flatten it into an array. Converting that array into a segtree, you can efficiently make queries on subtrees. \\n\\nI won\\'t go into detail but essentially you order the array indexes (node # -> array index) by the order nodes are visited in a simple dfs. Therefore, for every subtree in the tree, each element in that subtree will lie in a continuous subsegment. (Draw a few examples and try it out).\\n\\nNext, you would make that array into a segtree, so you can query and modfiy values on the array. \\n*In this case, those values are the max depth within the subtree we are querying, and since we arent modfiying, even an RMQ would suffice.\\nhttps://usaco.guide/CPH.pdf#page=174 \\nThis is a nice resource for learning this algorithm, as it becomes trivial for some advanced graph problems. \\n\\n# Intuition \\nThe question is asking us what is the deepest node that is not in the subtree we are querying. Notice that there is only a left and a right we have to query (find the max from), and also notice if you compress the tree into an array, then the nodes that we may get the answer from will lie either to the left or right (or both) from the subsegment that represents the subtree we removed.\\n\\nWe will flatten our tree into an array/RMQ/segtree, and process each query in O(logN)\\n\\n\\nWith a clear idea of our algorithm, the challenge now lies in implementation.\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nint mxn = 1e5 + 5; \\nint n, timer = 0; \\nvector<vector<int>> adj(mxn); \\nvector<int> st(mxn), en(mxn), d(mxn), to(mxn); \\n//to[x] = time x is processed (order) in the dfs, index in the array\\n//set the timer and compute st[x], en[x] = starting index\\n//and ending index of the subtree with head of x\\nvoid dfs(int node, int parent) {\\n    st[to[node]] = timer++;\\n    for (int i : adj[node]) {\\n        if (i != parent) {\\n            dfs(i, node);\\n        }\\n    }\\n    en[to[node]] = timer-1;\\n}\\n\\n//converting each node to the array index\\nvoid make(TreeNode* x, int depth) {\\n    to[x -> val - 1] = n; \\n    n++; \\n    d[to[x -> val - 1]] = depth; \\n    \\n    if (x -> right) {\\n        make(x -> right, depth + 1); \\n    } if (x -> left) {\\n        make(x -> left, depth + 1); \\n    }\\n}\\n\\n//creating the adjacency list for the dfs \\n//This is redundant, you could combine the dfs into this \\n//recursive function to make it more elegant\\nvoid make2(TreeNode* x) {\\n    if (x -> right) {\\n        adj[x -> val - 1].push_back(x -> right -> val - 1);\\n        make2(x -> right); \\n    } if (x -> left) {\\n        adj[x -> val - 1].push_back(x -> left -> val - 1);\\n        make2(x -> left); \\n    }\\n}\\n\\n//This is your classical segtree \\n//Segtree: initialize, make, build, modify, query; \\ntemplate <class T> \\nclass St {\\n    private: \\n    vector<T> t;\\n    int tn; T def = 0; \\n    //operation and initial value\\n    T op(T a, T b) {\\n        return max(a, b); \\n    } \\n    public:\\n    St(T N) { \\n        t = vector<T>(2 * N, 0); \\n        tn = N; \\n    }\\n\\n    void make(vector<T> & a) { \\n        for (int i = 0; i < tn; ++i) t[n+i] = a[i]; \\n    } \\n\\n    void build() {\\n        for (int i = tn - 1; i > 0; --i) t[i] = op(t[i<<1], t[i<<1|1]);\\n    }\\n\\n    void modify(int p, T val) {\\n        for (t[p += tn] = val; p > 1; p >>= 1) t[p>>1] = op(t[p], t[p^1]);\\n    }\\n\\n    //query on [l, r)\\n    T query(int l, int r) {  \\n        T res = def;\\n        for (l += tn, r += tn; l < r; l >>= 1, r >>= 1) {\\n            if (l&1) res = op(res, t[l++]);\\n            if (r&1) res = op(res, t[--r]);\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        //initialize and prepare for making segtree\\n        n = 0; \\n        timer = 0; \\n        make(root, 0);\\n        for (int i = 0; i < n; ++i) {\\n            adj[i].clear();\\n        }\\n        //compress into array\\n        make2(root); \\n        dfs(root -> val - 1, -1); \\n        \\n        //make segtree\\n        St s(n); \\n        vector<int> vd(n); \\n        for (int i = 0; i < n; ++i) {\\n            vd[i] = d[i];\\n        }\\n        s.make(vd);\\n        s.build(); \\n        \\n        vector<int> ans; \\n\\n        //process online queries\\n        for (int i = 0; i < queries.size(); ++i) {\\n            int x = queries[i]; \\n            x--; \\n            int mx = 0; \\n            //if the left of the removed subtree exists, maximise the depth from the [0, left)\\n            if (st[to[x]] > 0) {\\n                mx = max(mx, s.query(0, st[to[x]])); \\n            } \\n            //if the right of the removed subtree exists, maximise the depth from the (right, n)\\n            if (en[to[x]] < n - 1) {\\n                mx = max(mx, s.query(en[to[x]] + 1, n));\\n            }\\n            ans.push_back(mx); \\n        }\\n         \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nint mxn = 1e5 + 5; \\nint n, timer = 0; \\nvector<vector<int>> adj(mxn); \\nvector<int> st(mxn), en(mxn), d(mxn), to(mxn); \\n//to[x] = time x is processed (order) in the dfs, index in the array\\n//set the timer and compute st[x], en[x] = starting index\\n//and ending index of the subtree with head of x\\nvoid dfs(int node, int parent) {\\n    st[to[node]] = timer++;\\n    for (int i : adj[node]) {\\n        if (i != parent) {\\n            dfs(i, node);\\n        }\\n    }\\n    en[to[node]] = timer-1;\\n}\\n\\n//converting each node to the array index\\nvoid make(TreeNode* x, int depth) {\\n    to[x -> val - 1] = n; \\n    n++; \\n    d[to[x -> val - 1]] = depth; \\n    \\n    if (x -> right) {\\n        make(x -> right, depth + 1); \\n    } if (x -> left) {\\n        make(x -> left, depth + 1); \\n    }\\n}\\n\\n//creating the adjacency list for the dfs \\n//This is redundant, you could combine the dfs into this \\n//recursive function to make it more elegant\\nvoid make2(TreeNode* x) {\\n    if (x -> right) {\\n        adj[x -> val - 1].push_back(x -> right -> val - 1);\\n        make2(x -> right); \\n    } if (x -> left) {\\n        adj[x -> val - 1].push_back(x -> left -> val - 1);\\n        make2(x -> left); \\n    }\\n}\\n\\n//This is your classical segtree \\n//Segtree: initialize, make, build, modify, query; \\ntemplate <class T> \\nclass St {\\n    private: \\n    vector<T> t;\\n    int tn; T def = 0; \\n    //operation and initial value\\n    T op(T a, T b) {\\n        return max(a, b); \\n    } \\n    public:\\n    St(T N) { \\n        t = vector<T>(2 * N, 0); \\n        tn = N; \\n    }\\n\\n    void make(vector<T> & a) { \\n        for (int i = 0; i < tn; ++i) t[n+i] = a[i]; \\n    } \\n\\n    void build() {\\n        for (int i = tn - 1; i > 0; --i) t[i] = op(t[i<<1], t[i<<1|1]);\\n    }\\n\\n    void modify(int p, T val) {\\n        for (t[p += tn] = val; p > 1; p >>= 1) t[p>>1] = op(t[p], t[p^1]);\\n    }\\n\\n    //query on [l, r)\\n    T query(int l, int r) {  \\n        T res = def;\\n        for (l += tn, r += tn; l < r; l >>= 1, r >>= 1) {\\n            if (l&1) res = op(res, t[l++]);\\n            if (r&1) res = op(res, t[--r]);\\n        }\\n        return res;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        //initialize and prepare for making segtree\\n        n = 0; \\n        timer = 0; \\n        make(root, 0);\\n        for (int i = 0; i < n; ++i) {\\n            adj[i].clear();\\n        }\\n        //compress into array\\n        make2(root); \\n        dfs(root -> val - 1, -1); \\n        \\n        //make segtree\\n        St s(n); \\n        vector<int> vd(n); \\n        for (int i = 0; i < n; ++i) {\\n            vd[i] = d[i];\\n        }\\n        s.make(vd);\\n        s.build(); \\n        \\n        vector<int> ans; \\n\\n        //process online queries\\n        for (int i = 0; i < queries.size(); ++i) {\\n            int x = queries[i]; \\n            x--; \\n            int mx = 0; \\n            //if the left of the removed subtree exists, maximise the depth from the [0, left)\\n            if (st[to[x]] > 0) {\\n                mx = max(mx, s.query(0, st[to[x]])); \\n            } \\n            //if the right of the removed subtree exists, maximise the depth from the (right, n)\\n            if (en[to[x]] < n - 1) {\\n                mx = max(mx, s.query(en[to[x]] + 1, n));\\n            }\\n            ans.push_back(mx); \\n        }\\n         \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758007,
                "title": "segment-tree-o-nlogn",
                "content": "# Approach\\nDo a dfs traversal to append each depth (from root to leaf) to compute a list `depth`. \\n\\n`pre` and `post` determine the range of element in `depth` list so that all values inside this range are from path rooted at this node. \\n\\nFor each queries, we want to find out the max depth without choosing element from this range, so we use segment tree to query max depth before pre[node] and max depth after pre node, as well as the depth of the parent of this node.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass SegmentTree:\\n    def __init__(self, n, fn): # fn is transformation function\\n        self.n = n\\n        self.fn = fn\\n        self.tree = [0] * (2 * self.n)\\n    \\n    def update(self, idx, val):\\n        idx += self.n\\n        \\n        self.tree[idx] = val\\n        while idx > 1:\\n            idx >>= 1\\n            self.tree[idx] = self.fn(self.tree[2 * idx], self.tree[2 * idx + 1])\\n        \\n    def query(self, lo, hi):\\n        lo += self.n\\n        hi += self.n + 1\\n        res = 0\\n        \\n        while lo < hi:\\n            if lo & 1 == 1:\\n                res = self.fn(res, self.tree[lo])\\n                lo += 1\\n            if hi & 1 == 1:\\n                hi -= 1\\n                res = self.fn(res, self.tree[hi])\\n            lo >>= 1\\n            hi >>= 1\\n        \\n        return res \\n    \\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        pre = defaultdict(int)\\n        post = defaultdict(int)\\n        height = defaultdict(int)\\n        depth = []\\n        \\n        def dfs(node, curr):\\n            if not node: return\\n            \\n            height[node.val] = curr\\n            pre[node.val] = len(depth)\\n            dfs(node.left, curr + 1)\\n            dfs(node.right, curr + 1)\\n            \\n            if len(depth) == pre[node.val]: # node is leaf\\n                post[node.val] = pre[node.val]\\n                depth.append(curr)\\n            else:\\n                post[node.val] = len(depth) - 1\\n            \\n        dfs(root, 0)\\n        seg = SegmentTree(len(depth), max)\\n        for i in range(len(depth)):\\n            seg.update(i, depth[i])\\n        \\n        res = []\\n        for q in queries:\\n            lo, hi = pre[q], post[q]\\n            \\n            d = 0\\n            if lo == 0 and hi == len(depth) - 1:\\n                res.append(height[q] - 1)\\n            elif lo == 0:\\n                res.append(max(seg.query(hi + 1, len(depth) - 1), height[q] - 1))\\n            elif hi == len(depth) - 1:\\n                res.append(max(seg.query(0, lo - 1), height[q] - 1))\\n            else:\\n                res.append(max(seg.query(0, lo - 1), seg.query(hi + 1, len(depth) - 1), height[q] - 1))\\n            \\n        return res        \\n        \\n        \\n        \\n        \\n        \\n        \\n    \\n    \\n    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass SegmentTree:\\n    def __init__(self, n, fn): # fn is transformation function\\n        self.n = n\\n        self.fn = fn\\n        self.tree = [0] * (2 * self.n)\\n    \\n    def update(self, idx, val):\\n        idx += self.n\\n        \\n        self.tree[idx] = val\\n        while idx > 1:\\n            idx >>= 1\\n            self.tree[idx] = self.fn(self.tree[2 * idx], self.tree[2 * idx + 1])\\n        \\n    def query(self, lo, hi):\\n        lo += self.n\\n        hi += self.n + 1\\n        res = 0\\n        \\n        while lo < hi:\\n            if lo & 1 == 1:\\n                res = self.fn(res, self.tree[lo])\\n                lo += 1\\n            if hi & 1 == 1:\\n                hi -= 1\\n                res = self.fn(res, self.tree[hi])\\n            lo >>= 1\\n            hi >>= 1\\n        \\n        return res \\n    \\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        pre = defaultdict(int)\\n        post = defaultdict(int)\\n        height = defaultdict(int)\\n        depth = []\\n        \\n        def dfs(node, curr):\\n            if not node: return\\n            \\n            height[node.val] = curr\\n            pre[node.val] = len(depth)\\n            dfs(node.left, curr + 1)\\n            dfs(node.right, curr + 1)\\n            \\n            if len(depth) == pre[node.val]: # node is leaf\\n                post[node.val] = pre[node.val]\\n                depth.append(curr)\\n            else:\\n                post[node.val] = len(depth) - 1\\n            \\n        dfs(root, 0)\\n        seg = SegmentTree(len(depth), max)\\n        for i in range(len(depth)):\\n            seg.update(i, depth[i])\\n        \\n        res = []\\n        for q in queries:\\n            lo, hi = pre[q], post[q]\\n            \\n            d = 0\\n            if lo == 0 and hi == len(depth) - 1:\\n                res.append(height[q] - 1)\\n            elif lo == 0:\\n                res.append(max(seg.query(hi + 1, len(depth) - 1), height[q] - 1))\\n            elif hi == len(depth) - 1:\\n                res.append(max(seg.query(0, lo - 1), height[q] - 1))\\n            else:\\n                res.append(max(seg.query(0, lo - 1), seg.query(hi + 1, len(depth) - 1), height[q] - 1))\\n            \\n        return res        \\n        \\n        \\n        \\n        \\n        \\n        \\n    \\n    \\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066381,
                "title": "python-simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def treeQueries(self, root, queries):\\n        @lru_cache(None)\\n        def height(node):\\n            if not node:\\n                return -1\\n\\n            return 1 + max(height(node.left),height(node.right))\\n\\n        dict1 = collections.defaultdict(int)\\n\\n        def dfs(node,depth,max_val):\\n            if not node: return \\n\\n            dict1[node.val] = max_val\\n\\n            dfs(node.left,depth+1,max(max_val,depth+1+height(node.right)))\\n            dfs(node.right,depth+1,max(max_val,depth+1+height(node.left)))\\n\\n        dfs(root,0,0)\\n\\n        return [dict1[i] for i in queries]\\n\\n\\n\\n        \\n\\n\\n        \\n\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def treeQueries(self, root, queries):\\n        @lru_cache(None)\\n        def height(node):\\n            if not node:\\n                return -1\\n\\n            return 1 + max(height(node.left),height(node.right))\\n\\n        dict1 = collections.defaultdict(int)\\n\\n        def dfs(node,depth,max_val):\\n            if not node: return \\n\\n            dict1[node.val] = max_val\\n\\n            dfs(node.left,depth+1,max(max_val,depth+1+height(node.right)))\\n            dfs(node.right,depth+1,max(max_val,depth+1+height(node.left)))\\n\\n        dfs(root,0,0)\\n\\n        return [dict1[i] for i in queries]\\n\\n\\n\\n        \\n\\n\\n        \\n\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758503,
                "title": "video-explanation-euler-tour",
                "content": "https://www.youtube.com/watch?v=s62a0uxeRkE",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=s62a0uxeRkE",
                "codeTag": "Unknown"
            },
            {
                "id": 3840544,
                "title": "simple-and-fast-dfs-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach node has a height and a depth associated with it. Height is the number of levels above the node and depth is the number of levels below the node. So the nodes potential contribution to the maximum height of the binary tree is its height + depth (+/- 1 depending on how you track these variables). We will have a max heap for each level of the tree. We will calculate the potential contribution of each nodes height+depth to the max height of the tree and put this value into its levels heap. We put this into the max_heap (depth + height, height, node.val). Finally we have three situations to consider:\\n\\n1, q is the only node on this level. We return the HEIGHT of any of the nodes one level above our level.\\n\\n2, we have more than one node in our lvl, but q is on the top of the heap. We simply lookup the next biggest HEIGHT + DEPTH value in the heap.\\n\\n3, we have more than one node in our lvl and q is not on the top of the heap. We simply add the HEIGHT + DEPTH value from the top of the heap.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) + q * O(logN)\\nO(N) - to precompute the answers\\nO(logN) - per query to look up the answer\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) - the combined heaps hold N nodes\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        node_to_lvl = {}\\n        lvls = defaultdict(list)\\n\\n        def dfs(node, height):\\n            if not node:\\n                return 0\\n            height += 1\\n            left = dfs(node.left, height) + 1\\n            right = dfs(node.right, height) + 1\\n            node_to_lvl[node.val] = height\\n            heapq.heappush(lvls[height], (-max(left, right) - height + 1, height, node.val))\\n            return max(left, right)\\n        \\n        dfs(root, -1)\\n        res = []\\n\\n        for q in queries:\\n            lvl = node_to_lvl[q]\\n            if q == root.val:\\n                res.append(0)\\n            elif len(lvls[lvl]) == 1:\\n                res.append(lvls[lvl - 1][0][1])\\n            elif lvls[lvl][0][2] == q:\\n                temp = heapq.heappop(lvls[lvl])\\n                res.append(-lvls[lvl][0][0])\\n                heapq.heappush(lvls[lvl], temp)\\n            elif lvls[lvl][0][2] != q:\\n                res.append(-lvls[lvl][0][0])\\n        \\n        return res\\n            \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        node_to_lvl = {}\\n        lvls = defaultdict(list)\\n\\n        def dfs(node, height):\\n            if not node:\\n                return 0\\n            height += 1\\n            left = dfs(node.left, height) + 1\\n            right = dfs(node.right, height) + 1\\n            node_to_lvl[node.val] = height\\n            heapq.heappush(lvls[height], (-max(left, right) - height + 1, height, node.val))\\n            return max(left, right)\\n        \\n        dfs(root, -1)\\n        res = []\\n\\n        for q in queries:\\n            lvl = node_to_lvl[q]\\n            if q == root.val:\\n                res.append(0)\\n            elif len(lvls[lvl]) == 1:\\n                res.append(lvls[lvl - 1][0][1])\\n            elif lvls[lvl][0][2] == q:\\n                temp = heapq.heappop(lvls[lvl])\\n                res.append(-lvls[lvl][0][0])\\n                heapq.heappush(lvls[lvl], temp)\\n            elif lvls[lvl][0][2] != q:\\n                res.append(-lvls[lvl][0][0])\\n        \\n        return res\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788629,
                "title": "easy-c-height-and-depth-preorder-traversal",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,int> lheight;\\n    unordered_map<int,int> rheight;\\n    unordered_map<int,int> res;\\n    int findHeight(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return 0;\\n\\n        int left= findHeight(root->left);\\n        int right= findHeight(root->right);\\n\\n        lheight[root->val]= left;\\n        rheight[root->val]= right;\\n\\n        return 1+ max(left, right);\\n\\n    }\\n    void newHeight(TreeNode* root, int maxi, int level)\\n    {\\n        if(root==NULL)\\n        return;\\n        res[root->val]= maxi;\\n        newHeight(root->left, max(maxi, level + rheight[root->val]), level+1);\\n        newHeight(root->right, max(maxi, level + lheight[root->val]), level+1);\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int m= queries.size();\\n        lheight.clear();\\n        rheight.clear();\\n        res.clear();\\n        vector<int> answer(m, 0);\\n        if(root==NULL) return answer;\\n        findHeight(root);\\n        newHeight(root, 0, 0);\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            answer[i]=res[queries[i]];\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,int> lheight;\\n    unordered_map<int,int> rheight;\\n    unordered_map<int,int> res;\\n    int findHeight(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return 0;\\n\\n        int left= findHeight(root->left);\\n        int right= findHeight(root->right);\\n\\n        lheight[root->val]= left;\\n        rheight[root->val]= right;\\n\\n        return 1+ max(left, right);\\n\\n    }\\n    void newHeight(TreeNode* root, int maxi, int level)\\n    {\\n        if(root==NULL)\\n        return;\\n        res[root->val]= maxi;\\n        newHeight(root->left, max(maxi, level + rheight[root->val]), level+1);\\n        newHeight(root->right, max(maxi, level + lheight[root->val]), level+1);\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int m= queries.size();\\n        lheight.clear();\\n        rheight.clear();\\n        res.clear();\\n        vector<int> answer(m, 0);\\n        if(root==NULL) return answer;\\n        findHeight(root);\\n        newHeight(root, 0, 0);\\n\\n        for(int i=0; i<m; i++)\\n        {\\n            answer[i]=res[queries[i]];\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724902,
                "title": "javascript-easy-to-understand-dfs",
                "content": "Inspired by this solution and re-written in JS: https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/discuss/2758375/Python3-C%2B%2B-Clean-9-lines-Dfs\\n\\n```\\nvar treeQueries = function(root, queries) {\\n    if (!root) return [];\\n    \\n    let ans = {};\\n    let heights = {}\\n    \\n    function maxHeight(node) {\\n        if (!node) return 0;\\n        \\n        if (heights[node.val]) return heights[node.val];\\n        \\n        heights[node.val] = 1 + Math.max(maxHeight(node.left), maxHeight(node.right));\\n        \\n        return heights[node.val];\\n    }\\n    \\n    function dfs(node, depth, maxDepthWithoutCurrentNode) {\\n        if (!node) return 0;\\n        \\n        ans[node.val] = maxDepthWithoutCurrentNode;\\n        \\n        // depth + height(node.right)\\n        // Add current depth + depth of opposite child (since we act as if we remove one of the children)\\n        dfs(node.left, depth + 1, Math.max(maxDepthWithoutCurrentNode, depth + maxHeight(node.right)));\\n        dfs(node.right, depth + 1, Math.max(maxDepthWithoutCurrentNode, depth + maxHeight(node.left)));\\n    }\\n    \\n    dfs(root, 0, 0);\\n    \\n    return queries.map(q => ans[q]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar treeQueries = function(root, queries) {\\n    if (!root) return [];\\n    \\n    let ans = {};\\n    let heights = {}\\n    \\n    function maxHeight(node) {\\n        if (!node) return 0;\\n        \\n        if (heights[node.val]) return heights[node.val];\\n        \\n        heights[node.val] = 1 + Math.max(maxHeight(node.left), maxHeight(node.right));\\n        \\n        return heights[node.val];\\n    }\\n    \\n    function dfs(node, depth, maxDepthWithoutCurrentNode) {\\n        if (!node) return 0;\\n        \\n        ans[node.val] = maxDepthWithoutCurrentNode;\\n        \\n        // depth + height(node.right)\\n        // Add current depth + depth of opposite child (since we act as if we remove one of the children)\\n        dfs(node.left, depth + 1, Math.max(maxDepthWithoutCurrentNode, depth + maxHeight(node.right)));\\n        dfs(node.right, depth + 1, Math.max(maxDepthWithoutCurrentNode, depth + maxHeight(node.left)));\\n    }\\n    \\n    dfs(root, 0, 0);\\n    \\n    return queries.map(q => ans[q]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2758421,
                "title": "rust-dfs-with-comments",
                "content": "I attempted to solve this for the 2022-10-30 Weekly Contest 317. Collect a map of the tree node levels, keyed by node value. At the same time, we make another map of the maximum levels of the tree nodes under each node, keyed by level (`levels`). For each query, we can then look up the level of that node. We use the level to look up the other nodes on that level in `levels`. If the queried node is the only node on that level, the resulting tree is `level - 1` high, since we will remove all levels below. If there are other nodes, the result is the maximum of the maximum levels of those nodes.\\n\\nComments:\\n* I first went down the wrong path and had to restart. I was five minutes late when I had a working solution. Too bad, but it was a nice exercise.\\n\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    fn map(node: Option<Rc<RefCell<TreeNode>>>, levels: &mut Vec<Vec<(i32, usize)>>, map: &mut HashMap<i32, usize>, level: usize) -> usize {\\n        if let Some(node_rc) = node {\\n            let node_ref = node_rc.borrow();\\n            if levels.len() == level {\\n                levels.push(vec![]);\\n            }\\n            let max_level = Self::map(node_ref.left.clone(), levels, map, level + 1)\\n                .max(Self::map(node_ref.right.clone(), levels, map, level + 1));\\n            levels[level].push((node_ref.val, max_level));\\n            map.insert(node_ref.val, level);\\n            max_level\\n        } else {\\n            level - 1\\n        }\\n    }\\n\\n    pub fn tree_queries(root: Option<Rc<RefCell<TreeNode>>>, queries: Vec<i32>) -> Vec<i32> {\\n        let mut levels = vec![];\\n        let mut map = HashMap::new();\\n        Self::map(root, &mut levels, &mut map, 0);\\n        queries.into_iter().map(|q| {\\n            let &level = map.get(&q).unwrap();\\n            if levels[level].len() == 1 {\\n                (level - 1) as i32\\n            } else {\\n                levels[level].iter().filter_map(|(val, l)| (*val != q).then(|| {\\n                    *l\\n                })).max().unwrap() as i32\\n            }\\n        }).collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    fn map(node: Option<Rc<RefCell<TreeNode>>>, levels: &mut Vec<Vec<(i32, usize)>>, map: &mut HashMap<i32, usize>, level: usize) -> usize {\\n        if let Some(node_rc) = node {\\n            let node_ref = node_rc.borrow();\\n            if levels.len() == level {\\n                levels.push(vec![]);\\n            }\\n            let max_level = Self::map(node_ref.left.clone(), levels, map, level + 1)\\n                .max(Self::map(node_ref.right.clone(), levels, map, level + 1));\\n            levels[level].push((node_ref.val, max_level));\\n            map.insert(node_ref.val, level);\\n            max_level\\n        } else {\\n            level - 1\\n        }\\n    }\\n\\n    pub fn tree_queries(root: Option<Rc<RefCell<TreeNode>>>, queries: Vec<i32>) -> Vec<i32> {\\n        let mut levels = vec![];\\n        let mut map = HashMap::new();\\n        Self::map(root, &mut levels, &mut map, 0);\\n        queries.into_iter().map(|q| {\\n            let &level = map.get(&q).unwrap();\\n            if levels[level].len() == 1 {\\n                (level - 1) as i32\\n            } else {\\n                levels[level].iter().filter_map(|(val, l)| (*val != q).then(|| {\\n                    *l\\n                })).max().unwrap() as i32\\n            }\\n        }).collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2758353,
                "title": "segment-tree-c-euler-path-explained",
                "content": "Run a euler tour on the tree to find the start time and end time of each node.\\nStore the depth of each node in it\\'s start time. \\nBuild a Segment Tree containing the maximum of ranges.\\nNow for each query  node <b>\\'x\\'</b> then answer will be the  maximum of the maximum of range\\n<b>(1, start[x]-1)</b> and <b>(end[x]+1,totalTime)</b>.\\n\\nSample Code:\\n```\\nstruct SegmentTree {\\n#define lc (C << 1)\\n#define rc (C << 1 | 1)\\n#define M ((L+R)>>1)\\n  struct data {\\n    int sum;\\n    data() :sum(0) {};\\n  };\\n  vector<data>st;\\n  int N;\\n  SegmentTree(int _N) :N(_N) {\\n    st.resize(4 * N);\\n  }\\n  void combine(data& cur, data& l, data& r) {\\n    cur.sum = max(l.sum,r.sum);\\n  }\\n  data Query(int i, int j, int C, int L, int R) {\\n    if (j < L || i > R || L > R) return data();\\n    if (i <= L && R <= j) return st[C];\\n    data ret;\\n    data d1 = Query(i, j, lc, L, M);\\n    data d2 = Query(i, j, rc, M + 1, R);\\n    combine(ret, d1, d2);\\n    return ret;\\n  }\\n  void Update(int i, int j, int val, int C, int L, int R) {\\n    if (j < L || i > R || L > R) return;\\n    if (i <= L && R <= j) {\\n      st[C].sum = val;\\n      return;\\n    }\\n    Update(i, j, val, lc, L, M);\\n    Update(i, j, val, rc, M + 1, R);\\n    combine(st[C], st[lc], st[rc]);\\n  }\\n  void Update(int i, int j, int val) {\\n    Update(i, j, val, 1, 1, N);\\n  }\\n  int Query(int i, int j) {\\n    return Query(i, j, 1, 1, N).sum;\\n  }\\n};\\nclass Solution {\\npublic: \\n    int startTime[100001],endTime[100001];\\n    int arr[100001];\\n    int T;\\n    void dfs(TreeNode* root,int d){\\n        ++T;\\n        startTime[root->val] = T;\\n        arr[T] = d;\\n        if(root->left!=nullptr)dfs(root->left,d+1);\\n        if(root->right!=nullptr) dfs(root->right,d+1);\\n        endTime[root->val] = T;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        T = 0;\\n        dfs(root,0);\\n        SegmentTree st(T);\\n        for(int i=1;i<=T;i++){\\n            st.Update(i,i,arr[i]);\\n        }\\n        vector<int>ret;\\n        for(int&x:queries){\\n            int from = startTime[x];\\n            int till = endTime[x];\\n            int a = st.Query(1,from-1);\\n            int b = st.Query(till+1,T);\\n            ret.push_back(max(a,b));\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nstruct SegmentTree {\\n#define lc (C << 1)\\n#define rc (C << 1 | 1)\\n#define M ((L+R)>>1)\\n  struct data {\\n    int sum;\\n    data() :sum(0) {};\\n  };\\n  vector<data>st;\\n  int N;\\n  SegmentTree(int _N) :N(_N) {\\n    st.resize(4 * N);\\n  }\\n  void combine(data& cur, data& l, data& r) {\\n    cur.sum = max(l.sum,r.sum);\\n  }\\n  data Query(int i, int j, int C, int L, int R) {\\n    if (j < L || i > R || L > R) return data();\\n    if (i <= L && R <= j) return st[C];\\n    data ret;\\n    data d1 = Query(i, j, lc, L, M);\\n    data d2 = Query(i, j, rc, M + 1, R);\\n    combine(ret, d1, d2);\\n    return ret;\\n  }\\n  void Update(int i, int j, int val, int C, int L, int R) {\\n    if (j < L || i > R || L > R) return;\\n    if (i <= L && R <= j) {\\n      st[C].sum = val;\\n      return;\\n    }\\n    Update(i, j, val, lc, L, M);\\n    Update(i, j, val, rc, M + 1, R);\\n    combine(st[C], st[lc], st[rc]);\\n  }\\n  void Update(int i, int j, int val) {\\n    Update(i, j, val, 1, 1, N);\\n  }\\n  int Query(int i, int j) {\\n    return Query(i, j, 1, 1, N).sum;\\n  }\\n};\\nclass Solution {\\npublic: \\n    int startTime[100001],endTime[100001];\\n    int arr[100001];\\n    int T;\\n    void dfs(TreeNode* root,int d){\\n        ++T;\\n        startTime[root->val] = T;\\n        arr[T] = d;\\n        if(root->left!=nullptr)dfs(root->left,d+1);\\n        if(root->right!=nullptr) dfs(root->right,d+1);\\n        endTime[root->val] = T;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        T = 0;\\n        dfs(root,0);\\n        SegmentTree st(T);\\n        for(int i=1;i<=T;i++){\\n            st.Update(i,i,arr[i]);\\n        }\\n        vector<int>ret;\\n        for(int&x:queries){\\n            int from = startTime[x];\\n            int till = endTime[x];\\n            int a = st.Query(1,from-1);\\n            int b = st.Query(till+1,T);\\n            ret.push_back(max(a,b));\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758243,
                "title": "single-traversal-level-order-cpp",
                "content": "Traverse the tree and compute the height of each node, level of each node and in each level store the max 2 heights.\\nIf you remove a node, we have two possibilities. \\n1. It\\'s in the longest path\\n2. It\\'s not in the longest path\\n\\n```\\nclass Solution {\\n    unordered_map<int, int> nodeLevel;\\n    unordered_map<int, pair<int,int>> heights;\\n    unordered_map<int,int> height;\\npublic:\\n    int getHeight(TreeNode* root, int level) {\\n        if (root == nullptr) return 0;\\n        int lh = getHeight(root->left, level + 1);\\n        int rh = getHeight(root->right, level + 1);\\n        int h = 1 + max(lh, rh);\\n        \\n        nodeLevel[root->val] = level;\\n        height[root->val] = h;\\n        \\n        if (heights.count(level)) {\\n            if (heights[level].first <= h) {\\n                pair<int,int> p = {h, heights[level].first};\\n                heights[level] = p;\\n            } else if (heights[level].second < h) {\\n                heights[level].second = h;\\n            }\\n        } else {\\n            heights[level] = {h, 0};\\n        }\\n        return h;\\n    }\\n    \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        getHeight(root, 0);\\n        vector<int> result;\\n        for (auto node: queries) {\\n            int level = nodeLevel[node];\\n            if (height[node] == heights[level].first) {\\n                result.push_back(heights[level].second + level - 1);\\n            } else {\\n                result.push_back(heights[level].first + level - 1);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int, int> nodeLevel;\\n    unordered_map<int, pair<int,int>> heights;\\n    unordered_map<int,int> height;\\npublic:\\n    int getHeight(TreeNode* root, int level) {\\n        if (root == nullptr) return 0;\\n        int lh = getHeight(root->left, level + 1);\\n        int rh = getHeight(root->right, level + 1);\\n        int h = 1 + max(lh, rh);\\n        \\n        nodeLevel[root->val] = level;\\n        height[root->val] = h;\\n        \\n        if (heights.count(level)) {\\n            if (heights[level].first <= h) {\\n                pair<int,int> p = {h, heights[level].first};\\n                heights[level] = p;\\n            } else if (heights[level].second < h) {\\n                heights[level].second = h;\\n            }\\n        } else {\\n            heights[level] = {h, 0};\\n        }\\n        return h;\\n    }\\n    \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        getHeight(root, 0);\\n        vector<int> result;\\n        for (auto node: queries) {\\n            int level = nodeLevel[node];\\n            if (height[node] == heights[level].first) {\\n                result.push_back(heights[level].second + level - 1);\\n            } else {\\n                result.push_back(heights[level].first + level - 1);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760689,
                "title": "well-explained-c-height-level-o-n",
                "content": "# Intuition\\nWhat we need to think is that in what cases will the height of the overall tree be affected by deleting the given node.This leads us to realizing that it depends of the heights of the other nodes at the same level as the given node.It\\'ll become clearer when you see the code\\n\\n# Approach\\nThe code uses a recursive function, height, to traverse the binary tree and calculate the height of each node.\\nIt maintains two vectors, levels and lev, to store information about the levels and heights of the nodes.\\nThe levels vector is a 2D vector, where each row represents a level in the tree. Each row consists of two pairs: the first pair stores the maximum height and its corresponding node value, and the second pair stores the second maximum height and its corresponding node value.\\nThe lev vector is used to store the level of each node.\\nThe height function recursively calculates the height of each node and updates the levels and lev vectors accordingly.\\nOnce the height function has traversed the entire tree, the code processes the queries.\\nFor each query, it retrieves the level and node value.\\nIf the queried node is the left child of its parent (i.e., it is stored in the first pair of the levels vector for its level), the code calculates the height of the node from the root using the heights stored in the first and second pairs of the levels vector.\\nIf the queried node is the right child of its parent (i.e., it is stored in the second pair of the levels vector for its level), the code simply calculates the height of the node from the root as ht - 1, where ht represents the overall height of the tree.\\nThe calculated heights are stored in the ans vector, which is then returned as the result.\\n\\n# Complexity\\n- Time complexity:O(N+Q)   \\nLet\\'s analyze the main operations:\\nTraversing the binary tree to calculate heights: This process has a time complexity of O(N), where N is the number of nodes in the tree.\\nProcessing queries: The code iterates through the queries, and for each query, it performs a constant number of operations. Therefore, the time complexity for processing queries is O(Q), where Q is the number of queries.\\nOverall, the time complexity of the solution is O(N + Q), considering the traversal and query processing steps.\\n\\n- Space complexity:\\nO(N+Q)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<vector<pair<int,int>>> levels(1e5,vector<pair<int,int>>(2,{0,0}));\\n        vector<int> lev(1e5+1,0);\\n        int ht=height(root,0,levels,lev);\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int node=queries[i];\\n            int level=lev[node];\\n            if(levels[level][0].second==node)\\n            {\\n                ans.push_back(ht-levels[level][0].first+levels[level][1].first-1);\\n            }\\n            else\\n            {\\n                ans.push_back(ht-1);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    int height(TreeNode* root,int level,vector<vector<pair<int,int>>> &levels,vector<int> &lev)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        lev[root->val]=level;\\n        int hleft=height(root->left,level+1,levels,lev);\\n        int hright=height(root->right,level+1,levels,lev);\\n        int tmp=1+max(hleft,hright);\\n        if(tmp>levels[level][0].first)\\n           {\\n            levels[level][1]=levels[level][0];\\n            levels[level][0]={tmp,root->val};\\n           }\\n        else if(tmp>levels[level][1].first)\\n            levels[level][1]={tmp,root->val};\\n        return 1+max(hleft,hright);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<vector<pair<int,int>>> levels(1e5,vector<pair<int,int>>(2,{0,0}));\\n        vector<int> lev(1e5+1,0);\\n        int ht=height(root,0,levels,lev);\\n        vector<int> ans;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            int node=queries[i];\\n            int level=lev[node];\\n            if(levels[level][0].second==node)\\n            {\\n                ans.push_back(ht-levels[level][0].first+levels[level][1].first-1);\\n            }\\n            else\\n            {\\n                ans.push_back(ht-1);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    int height(TreeNode* root,int level,vector<vector<pair<int,int>>> &levels,vector<int> &lev)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        lev[root->val]=level;\\n        int hleft=height(root->left,level+1,levels,lev);\\n        int hright=height(root->right,level+1,levels,lev);\\n        int tmp=1+max(hleft,hright);\\n        if(tmp>levels[level][0].first)\\n           {\\n            levels[level][1]=levels[level][0];\\n            levels[level][0]={tmp,root->val};\\n           }\\n        else if(tmp>levels[level][1].first)\\n            levels[level][1]={tmp,root->val};\\n        return 1+max(hleft,hright);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706057,
                "title": "with-drawing-c-single-dfs-record-each-level-s-nodes",
                "content": "# Intuition\\n- `depth` is how many levels are beneath this node. `Height` is how many levels are above.\\n- First, use DFS to find each node\\'s`{height, depth}` and record in a map `mp`.\\n- Second, loop through `mp`, and for each node, we add it to the corresponding height level. The map `nei[height]` records the nodes / neighbors with the same height. \\n    - For example, `nei[2]` has the nodes `[2, 1, 3, 7]`:\\n\\n![IMG_2567A12487B6-1.jpeg](https://assets.leetcode.com/users/images/4ea95d57-0744-42af-b250-9ded99a549bf_1688256211.6916397.jpeg)\\n\\n- Each of the nodes has a depth, which are inserted in the `nei[2]`.\\n- Finally, to remove `node 2`, we index into the corresponding height level and pop `node 2` in that level. So, nodes `[1, 3, 7]` remains. Among them, the max depth is `0`. So the result is `height + remaining max depth`.  \\n- For optimization, we only keep the top two depth for each `nei` height level. Then, when sorting each level, we only sort two elements.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(n)$\\n\\n# Code C++\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, pair<int,int>> mp; // {height, depth}\\n    int depth(TreeNode* cur, int cur_h){\\n        if(cur == NULL){\\n            return -1;\\n        }\\n        int left = depth(cur->left, cur_h + 1);\\n        int right = depth(cur->right, cur_h + 1);\\n        int cur_d = max(left, right) + 1;\\n        mp[cur->val] = {cur_h, cur_d};\\n        // cout << \"Mp \" << cur->val << \", h \" << cur_h << \", d \" << cur_d << endl;\\n        return cur_d;\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        depth(root, 0);\\n        unordered_map<int, vector<int>> nei;\\n\\n        for(auto& [key, val] : mp){\\n            int h = val.first;\\n            int d = val.second;\\n            nei[h].push_back(d);\\n            sort(nei[h].begin(), nei[h].end(), greater<int>());\\n            if(nei[h].size() > 2){\\n                nei[h].pop_back();\\n            }\\n        }\\n\\n\\n        vector<int> res(queries.size());\\n        for(int i = 0; i < queries.size(); i++){\\n            int h = mp[queries[i]].first;\\n            int d = mp[queries[i]].second;\\n            if(nei[h].size() == 1){\\n                res[i] = h - 1;\\n            }else{\\n                if(nei[h][0] == d){\\n                    res[i] = h + nei[h][1];\\n                }else{\\n                    res[i] = h + nei[h][0];\\n                }\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, pair<int,int>> mp; // {height, depth}\\n    int depth(TreeNode* cur, int cur_h){\\n        if(cur == NULL){\\n            return -1;\\n        }\\n        int left = depth(cur->left, cur_h + 1);\\n        int right = depth(cur->right, cur_h + 1);\\n        int cur_d = max(left, right) + 1;\\n        mp[cur->val] = {cur_h, cur_d};\\n        // cout << \"Mp \" << cur->val << \", h \" << cur_h << \", d \" << cur_d << endl;\\n        return cur_d;\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        depth(root, 0);\\n        unordered_map<int, vector<int>> nei;\\n\\n        for(auto& [key, val] : mp){\\n            int h = val.first;\\n            int d = val.second;\\n            nei[h].push_back(d);\\n            sort(nei[h].begin(), nei[h].end(), greater<int>());\\n            if(nei[h].size() > 2){\\n                nei[h].pop_back();\\n            }\\n        }\\n\\n\\n        vector<int> res(queries.size());\\n        for(int i = 0; i < queries.size(); i++){\\n            int h = mp[queries[i]].first;\\n            int d = mp[queries[i]].second;\\n            if(nei[h].size() == 1){\\n                res[i] = h - 1;\\n            }else{\\n                if(nei[h][0] == d){\\n                    res[i] = h + nei[h][1];\\n                }else{\\n                    res[i] = h + nei[h][0];\\n                }\\n            }\\n        }\\n\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3079514,
                "title": "precompute-height-level-depth-for-each-node-beats-83",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        \"\"\"\\n        for every node, store the level and max depth of it\\'s subtree\\n        for every level, store the highest and second highest depth\\n        \"\"\"\\n        depth = {}\\n        level = {}\\n        max_depth_at_each_level = {}\\n        def compute(root, height):\\n            if not root:\\n                return 0\\n            level[root.val] = height\\n            left = compute(root.left, height+1)\\n            right = compute(root.right, height+1)\\n            depth[root.val] = max(left, right)\\n            return 1 + max(left, right)\\n        compute(root, 0)\\n\\n        def compute_max_depth_at_each_level(root):\\n            que = deque([root])\\n            level = 0\\n            while len(que):\\n                for _ in range(len(que)):\\n                    node = que.popleft()\\n                    x = depth[node.val]\\n                    if level in max_depth_at_each_level:\\n                        max_depth_at_each_level[level].append(x)\\n                    else:\\n                        max_depth_at_each_level[level] = [x]\\n                    if node.left:\\n                        que.append(node.left)\\n                    if node.right:\\n                        que.append(node.right)\\n                max_depth_at_each_level[level].sort(reverse=True)\\n                level+=1\\n        compute_max_depth_at_each_level(root)\\n\\n        ans = []\\n        for query in queries:\\n            del_lev = level[query]\\n            if len(max_depth_at_each_level[del_lev]) == 1:\\n                ans.append(del_lev-1)\\n                continue\\n            if depth[query] == max_depth_at_each_level[del_lev][0]:\\n                ans.append(del_lev + max_depth_at_each_level[del_lev][1])\\n            else:\\n                ans.append(del_lev + max_depth_at_each_level[del_lev][0])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        \"\"\"\\n        for every node, store the level and max depth of it\\'s subtree\\n        for every level, store the highest and second highest depth\\n        \"\"\"\\n        depth = {}\\n        level = {}\\n        max_depth_at_each_level = {}\\n        def compute(root, height):\\n            if not root:\\n                return 0\\n            level[root.val] = height\\n            left = compute(root.left, height+1)\\n            right = compute(root.right, height+1)\\n            depth[root.val] = max(left, right)\\n            return 1 + max(left, right)\\n        compute(root, 0)\\n\\n        def compute_max_depth_at_each_level(root):\\n            que = deque([root])\\n            level = 0\\n            while len(que):\\n                for _ in range(len(que)):\\n                    node = que.popleft()\\n                    x = depth[node.val]\\n                    if level in max_depth_at_each_level:\\n                        max_depth_at_each_level[level].append(x)\\n                    else:\\n                        max_depth_at_each_level[level] = [x]\\n                    if node.left:\\n                        que.append(node.left)\\n                    if node.right:\\n                        que.append(node.right)\\n                max_depth_at_each_level[level].sort(reverse=True)\\n                level+=1\\n        compute_max_depth_at_each_level(root)\\n\\n        ans = []\\n        for query in queries:\\n            del_lev = level[query]\\n            if len(max_depth_at_each_level[del_lev]) == 1:\\n                ans.append(del_lev-1)\\n                continue\\n            if depth[query] == max_depth_at_each_level[del_lev][0]:\\n                ans.append(del_lev + max_depth_at_each_level[del_lev][1])\\n            else:\\n                ans.append(del_lev + max_depth_at_each_level[del_lev][0])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769322,
                "title": "explaination-with-dry-run-c-well-commented-code-dfs-hashmap",
                "content": "Solution:\\n1. For removing any node we need to keep track of height of CurrNode(Node that is supposed to be removed) and two max heights at same level of that node.\\n\\n2. Now there can be two cases\\n\\t1. \\tCurrNode has the maxHeight at that level- removing currNode will affect the total height(Node is in the longest path to leaf i.e EULER TOUR). \\n\\t**ans[queries[i]]=totalHeight-Height(currNode)+Height(2nd max height at L)**.\\n\\t**if there is only one node at Level L then consider maxHeight at L-1.**\\n\\t\\n\\t2. \\tSome other Node has maxheight- removing currNode will not affect the total height beacuse currNode is not in the euler tour(Longest path to leaf) **ans[queries[i]]=totalHeight**\\n\\n3.Now we need **height**(longest path from currNode to leaf) and **level**(depth from root node) of currNode.\\n\\n4.Also we need two values  {maxHeight  , 2nd maxHeight } at level L. (use minheap priority queue)\\n5.we can compute above values using single DFS call\\n6.one IMP thing to understand for beginner is top element of minheap will always be 2nd maxHeight we need to swap (a,b) where **a=maxheight and b=2nd MaxHeight**\\n\\n![image](https://assets.leetcode.com/users/images/b0d14e96-1ed3-4da4-9ea1-8f37ac0a9a4c_1667370213.3712142.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/8f55e85c-a88d-4db0-a556-728a24a62de6_1667370239.3102856.jpeg)\\n\\n\\n**Please Upvote if you like the solution**\\n```\\nclass Solution {\\npublic:\\n    map<int,int>height;//node ->height\\n    map<int,int>depth;//node ->depth\\n    map<int,priority_queue <int, vector<int>, greater<int>> >twomax;//level-> <firstmax,secondmax (H)>\\n\\n    int dfsHeightDepth(TreeNode* root,int level){\\n\\n        if(!root) return -1;\\n        //recursive calls for calculating height for left and right subtree\\n        int lheight=dfsHeightDepth(root->left,level+1);\\n        int rheight=dfsHeightDepth(root->right,level+1);\\n        \\n        //store max heigit and depth(level) in map\\n        height[root->val]=max(lheight,rheight)+1;\\n        depth[root->val]=level;\\n        \\n        //maitain priority queue with only 2 elements in it top element will be Node with 2nd max height at perticular level\\n        //2nd node will be max height at peritcular level because it is minheap\\n        twomax[level].push(height[root->val]);\\n        //remove extra nodes from pq\\n        if(twomax[level].size()>2) twomax[level].pop();\\n        \\n        //return computed height\\n        return height[root->val];\\n        \\n\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        \\n        //ans vector\\n        vector<int>ans(queries.size());\\n        \\n        //compute height and depth(level) of tree\\n        int h=dfsHeightDepth(root,0);//calculates height and depth of each node\\n        \\n        for(int i=0;i<queries.size();i++){\\n            //for each query Node calculate level and height\\n            int level=depth[queries[i]];\\n            int heightOfcurrentNode=height[queries[i]];\\n            \\n            int a=-1,b=-1;\\n            if(twomax[level].size()==2){\\n                //beacuse it is minheap top element will be smaller\\n                b=twomax[level].top();twomax[level].pop();\\n                a=twomax[level].top();twomax[level].pop();\\n                \\n                // if currentNode has maxheight then remove its height from total height and add height of 2nd Max Node to total height\\n                if(heightOfcurrentNode==a) ans[i]=h-(a-b); \\n                \\n                //if it is not maxheight node then it should not affect total height computation\\n                else ans[i]=h;  \\n                \\n                //again add popped element back to priority queue\\n                twomax[level].push(b);\\n                twomax[level].push(a);\\n            }\\n            \\n            // if only one node present at that level subtract the heightOfcurrentNode and consider height of (level-1)th max height\\n            else ans[i]=h-heightOfcurrentNode-1;\\n            \\n              \\n        }\\n    \\n        return ans;\\n    }\\n};\\n```\\n**Please Upvote if you like the solution**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int>height;//node ->height\\n    map<int,int>depth;//node ->depth\\n    map<int,priority_queue <int, vector<int>, greater<int>> >twomax;//level-> <firstmax,secondmax (H)>\\n\\n    int dfsHeightDepth(TreeNode* root,int level){\\n\\n        if(!root) return -1;\\n        //recursive calls for calculating height for left and right subtree\\n        int lheight=dfsHeightDepth(root->left,level+1);\\n        int rheight=dfsHeightDepth(root->right,level+1);\\n        \\n        //store max heigit and depth(level) in map\\n        height[root->val]=max(lheight,rheight)+1;\\n        depth[root->val]=level;\\n        \\n        //maitain priority queue with only 2 elements in it top element will be Node with 2nd max height at perticular level\\n        //2nd node will be max height at peritcular level because it is minheap\\n        twomax[level].push(height[root->val]);\\n        //remove extra nodes from pq\\n        if(twomax[level].size()>2) twomax[level].pop();\\n        \\n        //return computed height\\n        return height[root->val];\\n        \\n\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        \\n        //ans vector\\n        vector<int>ans(queries.size());\\n        \\n        //compute height and depth(level) of tree\\n        int h=dfsHeightDepth(root,0);//calculates height and depth of each node\\n        \\n        for(int i=0;i<queries.size();i++){\\n            //for each query Node calculate level and height\\n            int level=depth[queries[i]];\\n            int heightOfcurrentNode=height[queries[i]];\\n            \\n            int a=-1,b=-1;\\n            if(twomax[level].size()==2){\\n                //beacuse it is minheap top element will be smaller\\n                b=twomax[level].top();twomax[level].pop();\\n                a=twomax[level].top();twomax[level].pop();\\n                \\n                // if currentNode has maxheight then remove its height from total height and add height of 2nd Max Node to total height\\n                if(heightOfcurrentNode==a) ans[i]=h-(a-b); \\n                \\n                //if it is not maxheight node then it should not affect total height computation\\n                else ans[i]=h;  \\n                \\n                //again add popped element back to priority queue\\n                twomax[level].push(b);\\n                twomax[level].push(a);\\n            }\\n            \\n            // if only one node present at that level subtract the heightOfcurrentNode and consider height of (level-1)th max height\\n            else ans[i]=h-heightOfcurrentNode-1;\\n            \\n              \\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759223,
                "title": "simple-dfs-solution-using-treemap-java-code-with-video-explanation-in-hindi",
                "content": "**Time Complexity :- O(n.log(n));**\\n\\n**Explanation :-** https://www.youtube.com/watch?v=doCIdDHxgbw\\n\\n**JAVA Code :-**\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    // Time Complexity :- O(n.log(n));\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        int m = maximum_value(root);\\n        int[] depth = new int[m+1];\\n        int[] level = new int[m+1];\\n        \\n        dfs(root,0,depth,level);\\n        \\n        // level -> (depth -> frequency)\\n        TreeMap<Integer,TreeMap<Integer,Integer>> map = new TreeMap<>();\\n        for(int i=1;i<=m;i++) {\\n            int l = level[i];\\n            int v = i;\\n            TreeMap<Integer,Integer> m1;\\n            if(map.containsKey(l)) {\\n                m1 = map.get(l);\\n                if(m1.containsKey(depth[v])) {\\n                    m1.put(depth[v],m1.get(depth[v])+1);\\n                } else {\\n                    m1.put(depth[v],1);\\n                }\\n            } else {\\n                m1 = new TreeMap<>();\\n                m1.put(depth[v],1);\\n            }\\n            map.put(l,m1);\\n        }\\n        \\n        \\n        // System.out.println(map);\\n        for(int i=0;i<queries.length;i++) {\\n            int q = queries[i];\\n            int ans = level[q]-1;\\n            TreeMap<Integer,Integer> m1 = map.get(level[q]);\\n            \\n            if(m1.get(depth[q])==1) {\\n                m1.remove(depth[q]);\\n            } else {\\n                m1.put(depth[q],m1.get(depth[q])-1);\\n            }\\n            \\n            if(m1.size()>0) {\\n                ans+=m1.lastKey();\\n            }\\n            \\n            if(m1.containsKey(depth[q])) {\\n                m1.put(depth[q],m1.get(depth[q])+1);\\n            } else {\\n                m1.put(depth[q],1);\\n            }\\n            \\n            queries[i]=ans;\\n        }\\n        return queries;\\n        \\n    }\\n    \\n    public static int maximum_value(TreeNode root) {\\n        if(root==null) return 0;\\n        int a1 = maximum_value(root.left);\\n        int a2 = maximum_value(root.right);\\n        \\n        return Math.max(a1,Math.max(a2,root.val));\\n    }\\n    \\n    \\n    public static int dfs(TreeNode root,int lvl,int[] depth,int[] level) {\\n        if(root==null) {\\n            return 0;\\n        }\\n        \\n        \\n        level[root.val]=lvl;\\n        \\n        int a1 =dfs(root.left,lvl+1,depth,level);\\n        int a2 =dfs(root.right,lvl+1,depth,level);\\n        \\n        return depth[root.val]=Math.max(a1,a2)+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    // Time Complexity :- O(n.log(n));\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        int m = maximum_value(root);\\n        int[] depth = new int[m+1];\\n        int[] level = new int[m+1];\\n        \\n        dfs(root,0,depth,level);\\n        \\n        // level -> (depth -> frequency)\\n        TreeMap<Integer,TreeMap<Integer,Integer>> map = new TreeMap<>();\\n        for(int i=1;i<=m;i++) {\\n            int l = level[i];\\n            int v = i;\\n            TreeMap<Integer,Integer> m1;\\n            if(map.containsKey(l)) {\\n                m1 = map.get(l);\\n                if(m1.containsKey(depth[v])) {\\n                    m1.put(depth[v],m1.get(depth[v])+1);\\n                } else {\\n                    m1.put(depth[v],1);\\n                }\\n            } else {\\n                m1 = new TreeMap<>();\\n                m1.put(depth[v],1);\\n            }\\n            map.put(l,m1);\\n        }\\n        \\n        \\n        // System.out.println(map);\\n        for(int i=0;i<queries.length;i++) {\\n            int q = queries[i];\\n            int ans = level[q]-1;\\n            TreeMap<Integer,Integer> m1 = map.get(level[q]);\\n            \\n            if(m1.get(depth[q])==1) {\\n                m1.remove(depth[q]);\\n            } else {\\n                m1.put(depth[q],m1.get(depth[q])-1);\\n            }\\n            \\n            if(m1.size()>0) {\\n                ans+=m1.lastKey();\\n            }\\n            \\n            if(m1.containsKey(depth[q])) {\\n                m1.put(depth[q],m1.get(depth[q])+1);\\n            } else {\\n                m1.put(depth[q],1);\\n            }\\n            \\n            queries[i]=ans;\\n        }\\n        return queries;\\n        \\n    }\\n    \\n    public static int maximum_value(TreeNode root) {\\n        if(root==null) return 0;\\n        int a1 = maximum_value(root.left);\\n        int a2 = maximum_value(root.right);\\n        \\n        return Math.max(a1,Math.max(a2,root.val));\\n    }\\n    \\n    \\n    public static int dfs(TreeNode root,int lvl,int[] depth,int[] level) {\\n        if(root==null) {\\n            return 0;\\n        }\\n        \\n        \\n        level[root.val]=lvl;\\n        \\n        int a1 =dfs(root.left,lvl+1,depth,level);\\n        int a2 =dfs(root.right,lvl+1,depth,level);\\n        \\n        return depth[root.val]=Math.max(a1,a2)+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758969,
                "title": "c-euler-tour",
                "content": "**Prerequisite: Eular Tour**\\n\\nFor every node, store the following things:\\n1. Time of discovery (**TOD**)\\n1. Height of node\\n1. No. of nodes/children in its subtree\\n\\n* Once the above parameters are stored, we can find the range of TOD of every node present in any subtree of some node. Ex: suppose that for a node `x`, TOD is `in` and no. of children are `y`, then all the node with TOD between **in** to **in+y** lies in the subtree of node `x`. To find the height of tree, we have to avoid these nodes for any `queries[i] = x`.\\n* To do the above operation and find height in O(1), We need to maintain prefix and suffix array. For each TOD, store its height and compute max height of TOD from `0 to i` in preffix and store max of height of TOD from `i to n` in suffix. Rest will be clear from code.\\n```\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root,map<int,vector<int>> &mp,int h,int &n){\\n        if(!root) return 0;\\n        int no = n++;\\n        int sum = dfs(root->left,mp,h+1,n)+dfs(root->right,mp,h+1,n);\\n        mp[root->val] = {no,h,sum}; // {time of discovery, height of node, no. of children}\\n        return sum+1;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& q) {\\n        map<int,vector<int>> mp;\\n        int x = 0;\\n        dfs(root,mp,0,x);\\n        int n = mp.size();\\n        vector<int> left(n+1,0),right(n+1,0);\\n        \\n        for(auto it = mp.begin(); it!=mp.end();++it){\\n            left[it->second[0]] = it->second[1];\\n            right[it->second[0]] = it->second[1];\\n        }\\n        \\n        for(int i = 1; i<n;++i) left[i] = max(left[i-1],left[i]);\\n        for(int i = n-1;i>=0;--i) right[i] = max(right[i],right[i+1]);\\n        \\n        vector<int> re(q.size(),0);\\n        for(int i = 0; i<q.size();++i){\\n            int l = mp[q[i]][0]-1, h = mp[q[i]][0]+mp[q[i]][2]+1;\\n            if(l>=0) re[i] = left[l];\\n            if(h<n) re[i] = max(re[i],right[h]);\\n        }\\n        return re;\\n    }\\n};\\n```\\n**Upvote if it helps **",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root,map<int,vector<int>> &mp,int h,int &n){\\n        if(!root) return 0;\\n        int no = n++;\\n        int sum = dfs(root->left,mp,h+1,n)+dfs(root->right,mp,h+1,n);\\n        mp[root->val] = {no,h,sum}; // {time of discovery, height of node, no. of children}\\n        return sum+1;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& q) {\\n        map<int,vector<int>> mp;\\n        int x = 0;\\n        dfs(root,mp,0,x);\\n        int n = mp.size();\\n        vector<int> left(n+1,0),right(n+1,0);\\n        \\n        for(auto it = mp.begin(); it!=mp.end();++it){\\n            left[it->second[0]] = it->second[1];\\n            right[it->second[0]] = it->second[1];\\n        }\\n        \\n        for(int i = 1; i<n;++i) left[i] = max(left[i-1],left[i]);\\n        for(int i = n-1;i>=0;--i) right[i] = max(right[i],right[i+1]);\\n        \\n        vector<int> re(q.size(),0);\\n        for(int i = 0; i<q.size();++i){\\n            int l = mp[q[i]][0]-1, h = mp[q[i]][0]+mp[q[i]][2]+1;\\n            if(l>=0) re[i] = left[l];\\n            if(h<n) re[i] = max(re[i],right[h]);\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758578,
                "title": "java-segment-tree",
                "content": "The maximum depth after removal of a subtree will be max of depths of all nodes that are not in that subtree\\n\\nWe find the max by using 2 queries: 1st to find max of depths of all nodes that occur before the current node in preorder traversal and 2nd to find max of depths of all nodes that occur after the subtree in the preorder traversal\\n\\nThe answer is the max of the results of these queries\\n\\nIn preorder traversal, each subtree can be represented by a subarray\\n\\nEg.\\n\\n![image](https://assets.leetcode.com/users/images/ebdd29e7-4cda-44de-bec9-a0b892704e10_1667114353.8077621.png)\\n```\\nlet size(x) be size of subtree rooted at x\\npreorder = [1, 3, 2, 4, 6, 5, 7]\\nsubtree(1) = [1, 3, 2, 4, 6, 5, 7] which is preorder[index(1):index(1)+size(1)]\\nsubtree(3) = [3, 2] which is preorder[index(3):index(3)+size(3)]\\nsubtree(2) = [2] which is preorder[index(2):index(2)+size(2)]\\nsubtree(4) = [4, 6, 5, 7] which is preorder[index(4):index(4)+size(4)]\\nsubtree(6) = [6] which is preorder[index(6):index(6)+size(6)]\\nsubtree(5) = [5, 7] which is preorder[index(5):index(5)+size(5)]\\nsubtree(7) = [7] which is preorder[index(7):index(7)+size(7)]\\n```\\nSegment tree with range maximum query can be used to find max of any subarray in O(log n)\\n<iframe src=\"https://leetcode.com/playground/AHsCYdo9/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nlet size(x) be size of subtree rooted at x\\npreorder = [1, 3, 2, 4, 6, 5, 7]\\nsubtree(1) = [1, 3, 2, 4, 6, 5, 7] which is preorder[index(1):index(1)+size(1)]\\nsubtree(3) = [3, 2] which is preorder[index(3):index(3)+size(3)]\\nsubtree(2) = [2] which is preorder[index(2):index(2)+size(2)]\\nsubtree(4) = [4, 6, 5, 7] which is preorder[index(4):index(4)+size(4)]\\nsubtree(6) = [6] which is preorder[index(6):index(6)+size(6)]\\nsubtree(5) = [5, 7] which is preorder[index(5):index(5)+size(5)]\\nsubtree(7) = [7] which is preorder[index(7):index(7)+size(7)]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2758361,
                "title": "java-simply-traverse-the-tree-twice",
                "content": "# Intuition & Approach\\n\\nJust traverse the tree twice. First time calculate the height of subtrees, and second time calculate the max height without a node.\\n\\nFirst traversal is trivial.\\nSecond traversal is a bit tricky. If we remove left child of root, then the possible max height of the new tree is the height of right child + 1. We can recursively get this \"possible max height\".\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        Map<Integer, Integer> heightsRooted = new HashMap<>();\\n        getHeightRootedAt(root, heightsRooted);\\n\\n        int[] heightsWithout = new int[heightsRooted.size() + 1];\\n        getHeightsWithoutNode(root, 0, 0, heightsWithout, heightsRooted);\\n\\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            result[i] = heightsWithout[queries[i]];\\n        }\\n\\n        return result;\\n    }\\n\\n    private void getHeightsWithoutNode(TreeNode node, int height, int possibleMaxHeight, int[] heightsWithout, Map<Integer, Integer> heightsRooted) {\\n        if (node == null) {\\n            return;\\n        }\\n\\n        int leftHeight = node.left == null ? -1 : heightsRooted.get(node.left.val);\\n        int rightHeight = node.right == null ? -1 : heightsRooted.get(node.right.val);\\n\\n        getHeightsWithoutNode(node.left, height + 1, Math.max(possibleMaxHeight, rightHeight + height + 1), heightsWithout, heightsRooted);\\n        getHeightsWithoutNode(node.right, height + 1, Math.max(possibleMaxHeight, leftHeight + height + 1), heightsWithout, heightsRooted);\\n\\n        heightsWithout[node.val] = Math.max(height - 1, possibleMaxHeight);\\n    }\\n\\n    private int getHeightRootedAt(TreeNode node, Map<Integer, Integer> heightsRooted) {\\n        if (node == null) {\\n            return -1;\\n        }\\n\\n        int maxHeight = 1 + Math.max(getHeightRootedAt(node.left, heightsRooted), getHeightRootedAt(node.right, heightsRooted));\\n        heightsRooted.put(node.val, maxHeight);\\n        return maxHeight;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        Map<Integer, Integer> heightsRooted = new HashMap<>();\\n        getHeightRootedAt(root, heightsRooted);\\n\\n        int[] heightsWithout = new int[heightsRooted.size() + 1];\\n        getHeightsWithoutNode(root, 0, 0, heightsWithout, heightsRooted);\\n\\n        int[] result = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            result[i] = heightsWithout[queries[i]];\\n        }\\n\\n        return result;\\n    }\\n\\n    private void getHeightsWithoutNode(TreeNode node, int height, int possibleMaxHeight, int[] heightsWithout, Map<Integer, Integer> heightsRooted) {\\n        if (node == null) {\\n            return;\\n        }\\n\\n        int leftHeight = node.left == null ? -1 : heightsRooted.get(node.left.val);\\n        int rightHeight = node.right == null ? -1 : heightsRooted.get(node.right.val);\\n\\n        getHeightsWithoutNode(node.left, height + 1, Math.max(possibleMaxHeight, rightHeight + height + 1), heightsWithout, heightsRooted);\\n        getHeightsWithoutNode(node.right, height + 1, Math.max(possibleMaxHeight, leftHeight + height + 1), heightsWithout, heightsRooted);\\n\\n        heightsWithout[node.val] = Math.max(height - 1, possibleMaxHeight);\\n    }\\n\\n    private int getHeightRootedAt(TreeNode node, Map<Integer, Integer> heightsRooted) {\\n        if (node == null) {\\n            return -1;\\n        }\\n\\n        int maxHeight = 1 + Math.max(getHeightRootedAt(node.left, heightsRooted), getHeightRootedAt(node.right, heightsRooted));\\n        heightsRooted.put(node.val, maxHeight);\\n        return maxHeight;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758110,
                "title": "java-preorder-level-order-to-build-look-up-cache",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        HashMap<Integer, Integer> nodeToHeight = new HashMap<Integer, Integer>();\\n        dfsPopulate(root, nodeToHeight);\\n        \\n        HashMap<Integer, Integer> nodeToLevel = new HashMap<Integer, Integer>();\\n        // level to nodeIds sorted by subHeights\\n        HashMap<Integer, List<Integer>> levelToNodeIds = new HashMap<Integer, List<Integer>>();\\n        // populate those caches through level order traverse.\\n        int level = 0;\\n        Deque<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.offer(root);\\n        while(queue.size() > 0) {\\n            ++level;\\n            int size = queue.size();\\n            List<Integer> nodeIdsAtCurLevel = new ArrayList<Integer>();\\n            for(int i = 0; i < size; ++i) {\\n                TreeNode cur = queue.poll();\\n                if(cur.left != null) {\\n                    nodeIdsAtCurLevel.add(cur.left.val);\\n                    nodeToLevel.put(cur.left.val, level);\\n                    queue.offer(cur.left);\\n                }\\n                if(cur.right != null) {\\n                    nodeIdsAtCurLevel.add(cur.right.val);\\n                    nodeToLevel.put(cur.right.val, level);\\n                    queue.offer(cur.right);\\n                }\\n            }\\n            \\n            nodeIdsAtCurLevel = sort(nodeIdsAtCurLevel, nodeToHeight);\\n            levelToNodeIds.put(level, nodeIdsAtCurLevel);\\n        }\\n        \\n        int[] res = new int[queries.length];\\n        for(int i = 0; i < queries.length; ++i) {\\n            Integer curLevel = nodeToLevel.get(queries[i]);\\n            List<Integer> nodeIds = levelToNodeIds.get(curLevel);\\n            int additionalHeight = 0;\\n            for(Integer nodeId : nodeIds) {\\n                if(nodeId != queries[i]) {\\n                    additionalHeight = nodeToHeight.get(nodeId);\\n\\t\\t\\t\\t\\t// no longer need to iterate all list since this is in revere order by sub-height.\\n                    break;\\n                }\\n            }\\n            \\n            res[i] = additionalHeight + curLevel - 1;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private List<Integer> sort(List<Integer>nodeIdsAtCurLevel, HashMap<Integer, Integer>nodeToHeight) {\\n        Collections.sort(nodeIdsAtCurLevel, new Comparator<Integer>() {\\n            @Override\\n            public int compare(Integer i1, Integer i2) {\\n                return nodeToHeight.get(i2) - nodeToHeight.get(i1);\\n            }\\n        });\\n            \\n        return nodeIdsAtCurLevel;\\n    }\\n    \\n    \\n    \\n    private int dfsPopulate(TreeNode root, HashMap<Integer, Integer> nodeToHeight) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        \\n        int left = dfsPopulate(root.left, nodeToHeight);\\n        int right = dfsPopulate(root.right, nodeToHeight);\\n        int height = 1 + Math.max(left, right);\\n        nodeToHeight.put(root.val, height);\\n        return height;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        HashMap<Integer, Integer> nodeToHeight = new HashMap<Integer, Integer>();\\n        dfsPopulate(root, nodeToHeight);\\n        \\n        HashMap<Integer, Integer> nodeToLevel = new HashMap<Integer, Integer>();\\n        // level to nodeIds sorted by subHeights\\n        HashMap<Integer, List<Integer>> levelToNodeIds = new HashMap<Integer, List<Integer>>();\\n        // populate those caches through level order traverse.\\n        int level = 0;\\n        Deque<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.offer(root);\\n        while(queue.size() > 0) {\\n            ++level;\\n            int size = queue.size();\\n            List<Integer> nodeIdsAtCurLevel = new ArrayList<Integer>();\\n            for(int i = 0; i < size; ++i) {\\n                TreeNode cur = queue.poll();\\n                if(cur.left != null) {\\n                    nodeIdsAtCurLevel.add(cur.left.val);\\n                    nodeToLevel.put(cur.left.val, level);\\n                    queue.offer(cur.left);\\n                }\\n                if(cur.right != null) {\\n                    nodeIdsAtCurLevel.add(cur.right.val);\\n                    nodeToLevel.put(cur.right.val, level);\\n                    queue.offer(cur.right);\\n                }\\n            }\\n            \\n            nodeIdsAtCurLevel = sort(nodeIdsAtCurLevel, nodeToHeight);\\n            levelToNodeIds.put(level, nodeIdsAtCurLevel);\\n        }\\n        \\n        int[] res = new int[queries.length];\\n        for(int i = 0; i < queries.length; ++i) {\\n            Integer curLevel = nodeToLevel.get(queries[i]);\\n            List<Integer> nodeIds = levelToNodeIds.get(curLevel);\\n            int additionalHeight = 0;\\n            for(Integer nodeId : nodeIds) {\\n                if(nodeId != queries[i]) {\\n                    additionalHeight = nodeToHeight.get(nodeId);\\n\\t\\t\\t\\t\\t// no longer need to iterate all list since this is in revere order by sub-height.\\n                    break;\\n                }\\n            }\\n            \\n            res[i] = additionalHeight + curLevel - 1;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private List<Integer> sort(List<Integer>nodeIdsAtCurLevel, HashMap<Integer, Integer>nodeToHeight) {\\n        Collections.sort(nodeIdsAtCurLevel, new Comparator<Integer>() {\\n            @Override\\n            public int compare(Integer i1, Integer i2) {\\n                return nodeToHeight.get(i2) - nodeToHeight.get(i1);\\n            }\\n        });\\n            \\n        return nodeIdsAtCurLevel;\\n    }\\n    \\n    \\n    \\n    private int dfsPopulate(TreeNode root, HashMap<Integer, Integer> nodeToHeight) {\\n        if(root == null) {\\n            return 0;\\n        }\\n        \\n        int left = dfsPopulate(root.left, nodeToHeight);\\n        int right = dfsPopulate(root.right, nodeToHeight);\\n        int height = 1 + Math.max(left, right);\\n        nodeToHeight.put(root.val, height);\\n        return height;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757987,
                "title": "c-maps-set-preorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int,int>mp;\\n    map<int,int>height;\\n    map<int,set<pair<int,int>>>mp1;\\n    int check(TreeNode*root,int count)\\n    {\\n        if(!root)return 0;\\n        mp[root->val] = count;\\n        int a = check(root->left,count+1);\\n        int b = check(root->right,count+1);\\n        int c = 1+max(a,b);\\n        int d = count+max(a,b);// This is to find total height of tree because of this node\\n        height[root->val] = d;\\n        mp1[count].insert({d,root->val});\\n        return c;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        mp.clear();\\n        mp1.clear();\\n        height.clear();\\n        check(root,0);\\n        vector<int>ans;\\n        for(auto x:queries)\\n        {\\n            int a = mp[x];\\n            if(mp1[a].size()>1)\\n            {\\n                int x1 = height[x];\\n                auto it = mp1[a].lower_bound({x1,-1});\\n                pair<int,int>p = *it;\\n                mp1[a].erase(it);\\n                auto y = *(mp1[a].rbegin());\\n                ans.push_back(y.first);\\n                mp1[a].insert(p);\\n            }\\n            else\\n            {\\n                ans.push_back(a-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int,int>mp;\\n    map<int,int>height;\\n    map<int,set<pair<int,int>>>mp1;\\n    int check(TreeNode*root,int count)\\n    {\\n        if(!root)return 0;\\n        mp[root->val] = count;\\n        int a = check(root->left,count+1);\\n        int b = check(root->right,count+1);\\n        int c = 1+max(a,b);\\n        int d = count+max(a,b);// This is to find total height of tree because of this node\\n        height[root->val] = d;\\n        mp1[count].insert({d,root->val});\\n        return c;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        mp.clear();\\n        mp1.clear();\\n        height.clear();\\n        check(root,0);\\n        vector<int>ans;\\n        for(auto x:queries)\\n        {\\n            int a = mp[x];\\n            if(mp1[a].size()>1)\\n            {\\n                int x1 = height[x];\\n                auto it = mp1[a].lower_bound({x1,-1});\\n                pair<int,int>p = *it;\\n                mp1[a].erase(it);\\n                auto y = *(mp1[a].rbegin());\\n                ans.push_back(y.first);\\n                mp1[a].insert(p);\\n            }\\n            else\\n            {\\n                ans.push_back(a-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962974,
                "title": "c-level-height-precompute-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the tree to store level and height of each node and then for each level precompute the answer based on node having longest height. \\n\\n# Complexity\\n- Time complexity: O(N+Q)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int traverse(TreeNode* root, unordered_map<int,int>&height,int lv, unordered_map<int,int>&level){\\n\\n        if(root==nullptr) return 0;\\n\\n        if(root->left!=nullptr){\\n            level[root->left->val] = lv;\\n        }\\n\\n         if(root->right!=nullptr){\\n            level[root->right->val] = lv;\\n        }\\n\\n        int l = traverse(root->left,height,lv+1,level);\\n        int r = traverse(root->right,height,lv+1,level);\\n\\n        int h = max(l,r) +1;\\n        height[root->val] = h;\\n        return h;\\n\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n\\n        unordered_map<int,int> height;\\n        unordered_map<int,int> level;\\n\\n        int h = traverse(root,height,1,level);\\n\\n        //group nodes at the same level\\n\\n        unordered_map<int,vector<int>> m;\\n\\n        for(auto i:level){\\n            m[i.second].push_back(i.first);\\n        }\\n\\n        \\n\\n        unordered_map<int,int> del;\\n\\n        for(int i=1;i<h;i++){\\n            //level i\\n            int max = 0;\\n            int secmax = 0;\\n\\n            int maxint = -1;\\n\\n            if(m[i].size()==1){\\n                del[m[i][0]] = level[m[i][0]]-1;\\n                continue;\\n            }\\n\\n            for(int k=0;k<m[i].size();k++){\\n                if(height[m[i][k]]>max) {\\n                    secmax = max;\\n                    max = height[m[i][k]];\\n                    maxint = m[i][k];\\n                }\\n                else if(height[m[i][k]]>secmax) secmax = height[m[i][k]];\\n            }\\n\\n            for(int k=0;k<m[i].size();k++){\\n                if(m[i][k]==maxint) {\\n                    del[m[i][k]] = secmax + level[m[i][k]] -1;\\n                }\\n                else del[m[i][k]] = max + level[m[i][k]] -1;\\n            }\\n        }\\n\\n        vector<int> ans;\\n\\n        for(int i=0;i<queries.size();i++){\\n            \\n             ans.push_back(del[queries[i]]);\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int traverse(TreeNode* root, unordered_map<int,int>&height,int lv, unordered_map<int,int>&level){\\n\\n        if(root==nullptr) return 0;\\n\\n        if(root->left!=nullptr){\\n            level[root->left->val] = lv;\\n        }\\n\\n         if(root->right!=nullptr){\\n            level[root->right->val] = lv;\\n        }\\n\\n        int l = traverse(root->left,height,lv+1,level);\\n        int r = traverse(root->right,height,lv+1,level);\\n\\n        int h = max(l,r) +1;\\n        height[root->val] = h;\\n        return h;\\n\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n\\n        unordered_map<int,int> height;\\n        unordered_map<int,int> level;\\n\\n        int h = traverse(root,height,1,level);\\n\\n        //group nodes at the same level\\n\\n        unordered_map<int,vector<int>> m;\\n\\n        for(auto i:level){\\n            m[i.second].push_back(i.first);\\n        }\\n\\n        \\n\\n        unordered_map<int,int> del;\\n\\n        for(int i=1;i<h;i++){\\n            //level i\\n            int max = 0;\\n            int secmax = 0;\\n\\n            int maxint = -1;\\n\\n            if(m[i].size()==1){\\n                del[m[i][0]] = level[m[i][0]]-1;\\n                continue;\\n            }\\n\\n            for(int k=0;k<m[i].size();k++){\\n                if(height[m[i][k]]>max) {\\n                    secmax = max;\\n                    max = height[m[i][k]];\\n                    maxint = m[i][k];\\n                }\\n                else if(height[m[i][k]]>secmax) secmax = height[m[i][k]];\\n            }\\n\\n            for(int k=0;k<m[i].size();k++){\\n                if(m[i][k]==maxint) {\\n                    del[m[i][k]] = secmax + level[m[i][k]] -1;\\n                }\\n                else del[m[i][k]] = max + level[m[i][k]] -1;\\n            }\\n        }\\n\\n        vector<int> ans;\\n\\n        for(int i=0;i<queries.size();i++){\\n            \\n             ans.push_back(del[queries[i]]);\\n\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937844,
                "title": "level-depth-very-intuitive-postorder-traversal-recursion",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<int, int> levelMap;\\n    unordered_map<int, int> htMap;\\n    set<pair<int,int>> st[100007];\\n    int util(TreeNode* root, int lvl){\\n        if(!root) return 0;\\n        int l = util(root->left,lvl+1);\\n        int r = util(root->right,lvl+1);\\n\\n        levelMap[root->val] = lvl;\\n        htMap[root->val] = max(l,r);\\n        st[lvl].insert({max(l,r),root->val});\\n\\n        return max(l,r)+1;\\n    }\\n    int ht(int num){\\n        int lvl = levelMap[num];\\n        int ht = htMap[num];\\n        // cout<<lvl<<\"--\";\\n        int ret = 0;\\n        \\n        st[lvl].erase({ht,num});\\n        if(st[lvl].size() == 0) ret = ht+1;\\n        else{\\n            auto new_ht = st[lvl].rbegin()->first;\\n        \\n            if(new_ht >= ht)ret = 0;\\n        // cout<<tmp->first<<\" \"<<ht;\\n            else ret = (ht - new_ht);\\n        // cout<<ret<<\" \";\\n        }\\n        st[lvl].insert({ht,num});\\n        return ret;\\n    }\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        levelMap.clear();\\n        // st = set<pair<int,int>>();\\n        int rootHt = util(root,0)-1;\\n        \\n        vector<int> ans;\\n        for(auto q: queries){\\n            ans.push_back(rootHt - ht(q));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<int, int> levelMap;\\n    unordered_map<int, int> htMap;\\n    set<pair<int,int>> st[100007];\\n    int util(TreeNode* root, int lvl){\\n        if(!root) return 0;\\n        int l = util(root->left,lvl+1);\\n        int r = util(root->right,lvl+1);\\n\\n        levelMap[root->val] = lvl;\\n        htMap[root->val] = max(l,r);\\n        st[lvl].insert({max(l,r),root->val});\\n\\n        return max(l,r)+1;\\n    }\\n    int ht(int num){\\n        int lvl = levelMap[num];\\n        int ht = htMap[num];\\n        // cout<<lvl<<\"--\";\\n        int ret = 0;\\n        \\n        st[lvl].erase({ht,num});\\n        if(st[lvl].size() == 0) ret = ht+1;\\n        else{\\n            auto new_ht = st[lvl].rbegin()->first;\\n        \\n            if(new_ht >= ht)ret = 0;\\n        // cout<<tmp->first<<\" \"<<ht;\\n            else ret = (ht - new_ht);\\n        // cout<<ret<<\" \";\\n        }\\n        st[lvl].insert({ht,num});\\n        return ret;\\n    }\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        levelMap.clear();\\n        // st = set<pair<int,int>>();\\n        int rootHt = util(root,0)-1;\\n        \\n        vector<int> ans;\\n        for(auto q: queries){\\n            ans.push_back(rootHt - ht(q));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3926508,
                "title": "iterate-in-reverse-order-in-logn-time-for-each-query",
                "content": "Intuition\\n\\nTo travel in reverse order of the query item and update the heights of the left subtree and right subtree on the go. \\n\\nDon\\'t overkill the problem!\\n```\\nconst int N = 2e5 + 2;\\nclass Solution {\\npublic:\\n\\n    pair<int,int> parent[N];\\n    pair<int,int> m[N];\\n    int dfs(TreeNode *curr,TreeNode *par,bool ileft){\\n            if(curr == NULL) return 0;\\n            int left = dfs(curr->left,curr,true);\\n            int right = dfs(curr->right,curr,false);\\n            if(par != NULL)\\n                parent[curr->val] = {par->val,ileft};\\n            else parent[curr->val] = {-1,ileft};\\n            m[curr->val] = {left,right};\\n            return 1 + max(left,right);\\n    }\\n\\n    int rev(int curr){\\n         int value = 0;\\n         int t = curr;\\n         while(1){\\n             int par = parent[curr].first; \\n             if(par == -1) break;\\n             bool isLeft = parent[curr].second;\\n             if(isLeft){\\n                 value = 1 + max(value,m[par].second);\\n             }\\n             else value = 1 + max(m[par].first,value);\\n             curr = par;\\n         }\\n         return value-1;\\n    }\\n     vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        TreeNode *par = NULL;\\n        dfs(root,par,0);\\n        vector<int>ans;\\n\\n        for(auto &i : queries){\\n            ans.push_back(rev(i));\\n        }\\n        return ans;\\n     }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int N = 2e5 + 2;\\nclass Solution {\\npublic:\\n\\n    pair<int,int> parent[N];\\n    pair<int,int> m[N];\\n    int dfs(TreeNode *curr,TreeNode *par,bool ileft){\\n            if(curr == NULL) return 0;\\n            int left = dfs(curr->left,curr,true);\\n            int right = dfs(curr->right,curr,false);\\n            if(par != NULL)\\n                parent[curr->val] = {par->val,ileft};\\n            else parent[curr->val] = {-1,ileft};\\n            m[curr->val] = {left,right};\\n            return 1 + max(left,right);\\n    }\\n\\n    int rev(int curr){\\n         int value = 0;\\n         int t = curr;\\n         while(1){\\n             int par = parent[curr].first; \\n             if(par == -1) break;\\n             bool isLeft = parent[curr].second;\\n             if(isLeft){\\n                 value = 1 + max(value,m[par].second);\\n             }\\n             else value = 1 + max(m[par].first,value);\\n             curr = par;\\n         }\\n         return value-1;\\n    }\\n     vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        TreeNode *par = NULL;\\n        dfs(root,par,0);\\n        vector<int>ans;\\n\\n        for(auto &i : queries){\\n            ans.push_back(rev(i));\\n        }\\n        return ans;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879981,
                "title": "python3-100-t-85-s-o-n-time-and-space-explained-for-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can think of solving offline query. \\nNot all nodes will affect the height of tree, only those node who are in path of maximum height will affect the height of tree\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet\\'s say leaf node <code> X</code>  is giving the longest height. Now let\\'s say path from root to <code> X</code> is like n1 -> n2 -> n3 -> n4 -> <code> X</code>.\\nSo removing only these node will alter your height. \\nSo we start from root, check the level of left and right, and whichever is greater, removing that will affect the answer. Whichever is lower, removing that won\\'t change our height. \\nWe do recursively to all nodes. \\n<code> curmx </code> is the current maximum height if we remove the curent node.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nO(N)\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], q : List[int]) -> List[int]:\\n        lvl =  defaultdict(int)\\n        mx = 0\\n        def level(node):\\n            nonlocal mx\\n            if not node:\\n                return 0\\n            l = level(node.left)\\n            r = level(node.right)\\n            lvl[node.val] = max(l,r) +1\\n            mx = max(mx, lvl[node.val])\\n            return lvl[node.val]\\n        level(root)\\n        n = len(lvl) + 3\\n        ans = [mx-1 for i in range(n+1)]\\n        curmx = 0\\n        def helper(node, cur):\\n            if not node:\\n                return \\n            nonlocal curmx\\n            # print(node.val)\\n            l,r = 0,0\\n            if node.left:\\n                l = lvl[node.left.val] \\n            if node.right:\\n                r = lvl[node.right.val] \\n            if r > l:\\n                right = node.right.val\\n                curmx = max(curmx, cur + l)\\n                ans[right] = curmx\\n                helper(node.right, cur + 1)\\n            elif l > r:\\n                left = node.left.val\\n                curmx = max(curmx, cur + r)\\n                ans[left] = curmx\\n                helper(node.left, cur + 1)\\n            else:\\n                return\\n        helper(root, 0)\\n        return [ans[i] for i in q]\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], q : List[int]) -> List[int]:\\n        lvl =  defaultdict(int)\\n        mx = 0\\n        def level(node):\\n            nonlocal mx\\n            if not node:\\n                return 0\\n            l = level(node.left)\\n            r = level(node.right)\\n            lvl[node.val] = max(l,r) +1\\n            mx = max(mx, lvl[node.val])\\n            return lvl[node.val]\\n        level(root)\\n        n = len(lvl) + 3\\n        ans = [mx-1 for i in range(n+1)]\\n        curmx = 0\\n        def helper(node, cur):\\n            if not node:\\n                return \\n            nonlocal curmx\\n            # print(node.val)\\n            l,r = 0,0\\n            if node.left:\\n                l = lvl[node.left.val] \\n            if node.right:\\n                r = lvl[node.right.val] \\n            if r > l:\\n                right = node.right.val\\n                curmx = max(curmx, cur + l)\\n                ans[right] = curmx\\n                helper(node.right, cur + 1)\\n            elif l > r:\\n                left = node.left.val\\n                curmx = max(curmx, cur + r)\\n                ans[left] = curmx\\n                helper(node.left, cur + 1)\\n            else:\\n                return\\n        helper(root, 0)\\n        return [ans[i] for i in q]\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814350,
                "title": "appraoch-usingdfs",
                "content": "# Intuition\\nHere we can get the max height after remobing a node by storing the height and depth od each node in the tree and then using this info to \\ncreate a cousins map which basically takes current depth(level) as the key and the top 2 nodes with the maximum height in that level. The ideology ios that if we delete a node in a level, \\n- The max path can be = height of Tree if the node deleted is not the node with maxHeight in that level\\n- The max path can be = depth of current Level+ height of second best node\\n- The max Path can be= depth of current level-1 if only one node in that level\\nSo by this way we can get maxPath for each queries\\n# Approach\\n- in ```height_depthDFS``` we store the hight and depth of each node\\n- first we calculate height of Tree ```height_depthDFS(root,0)```\\n- Now we create and store the top2 nodes with maxHeight in each level\\n    - ```cousins[depth].push_back({heightNodes[node],node});```\\n    - We sort these in descending order\\n    - then remove nodes outside top3 in each iteration as they are not needed\\n- Finally we consder 3 cases which i discussed above\\n    -   ```if(cousins[depthQ].size()==1)```\\n    - ```else if(cousins[depthQ][0].second==q)```\\n    - ```else result.push_back(heightTree);```\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,int>depthNodes;\\n    unordered_map<int,int>heightNodes;\\n    int height_depthDFS(TreeNode*root,int level){\\n        if(!root) return-1;\\n        depthNodes[root->val]=level;\\n        heightNodes[root->val]=1+max(height_depthDFS(root->left,level+1),height_depthDFS(root->right,level+1));\\n        return heightNodes[root->val];\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int heightTree=height_depthDFS(root,0);\\n        vector<int>result;\\n        unordered_map<int,vector<pair<int,int>>>cousins;\\n        for(auto&[node,depth]:depthNodes){\\n            cousins[depth].push_back({heightNodes[node],node});\\n            sort(cousins[depth].begin(),cousins[depth].end(),greater<pair<int,int>>());\\n            if(cousins[depth].size()>2) cousins[depth].pop_back();\\n        }\\n        for(auto&q:queries){\\n            int depthQ=depthNodes[q];\\n            if(cousins[depthQ].size()==1) result.push_back(depthQ-1);\\n            else if(cousins[depthQ][0].second==q) result.push_back(cousins[depthQ][1].first+depthQ);\\n            else result.push_back(heightTree);\\n        }\\n        return result;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```height_depthDFS```\n```height_depthDFS(root,0)```\n```cousins[depth].push_back({heightNodes[node],node});```\n```if(cousins[depthQ].size()==1)```\n```else if(cousins[depthQ][0].second==q)```\n```else result.push_back(heightTree);```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,int>depthNodes;\\n    unordered_map<int,int>heightNodes;\\n    int height_depthDFS(TreeNode*root,int level){\\n        if(!root) return-1;\\n        depthNodes[root->val]=level;\\n        heightNodes[root->val]=1+max(height_depthDFS(root->left,level+1),height_depthDFS(root->right,level+1));\\n        return heightNodes[root->val];\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int heightTree=height_depthDFS(root,0);\\n        vector<int>result;\\n        unordered_map<int,vector<pair<int,int>>>cousins;\\n        for(auto&[node,depth]:depthNodes){\\n            cousins[depth].push_back({heightNodes[node],node});\\n            sort(cousins[depth].begin(),cousins[depth].end(),greater<pair<int,int>>());\\n            if(cousins[depth].size()>2) cousins[depth].pop_back();\\n        }\\n        for(auto&q:queries){\\n            int depthQ=depthNodes[q];\\n            if(cousins[depthQ].size()==1) result.push_back(depthQ-1);\\n            else if(cousins[depthQ][0].second==q) result.push_back(cousins[depthQ][1].first+depthQ);\\n            else result.push_back(heightTree);\\n        }\\n        return result;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773036,
                "title": "c-detailed-explanation-dry-run-level-order-traversal",
                "content": "# Intuition\\nFor this problem my first intuition was to iterate over the queries array and call a RemoveNode function for each of the query nodes. The Remove function would mark the node as null at its parent and calculate the tree\\'s new height after that action. But the problem statement mentions that the state of the tree resets to the original after every query operation. That presented a problem with my initial approach. After this I decided to store multiple deep copies of the original array for every index i in queries array. I did that and ran the code. The code worked for all but last 5 test cases. I changed my approach to not modify the original array but just return the control from the calculateHeight function when finding the query node, but that too required a full travsersal every time a query node is called and hence a time complexity of O(m*n) where m is the query array length and n is the tree node count. \\nI was stuck at this stage for quite some time and decided to see the existing submitted solutions. I found Bakerston\\'s submission here \\nhttps://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/solutions/2757990/python-3-explanation-with-pictures-dfs/\\n\\nI am using his logic but tried to code it in a slighly different way using Level Order Traversal. \\n \\n\\n# Approach\\n\\nUsed the below example for dry run :- \\n\\nroot =\\n[5,8,9,2,1,3,7,4,6]\\n\\nqueries =\\n[3,4,2,8]\\n\\n![image.png](https://assets.leetcode.com/users/images/187736d3-99e1-488c-80bb-52f9bd154b45_1689529471.9606593.png)\\n\\n\\nThe approach I took here makes use of precomputed values which would help us reduce the time complexity from O(m*n) where m = length of queries, n = nodes in tree using the stabdard DFS approach to a time complexity of O(N) where N = node count in the original tree.\\n\\nFirst we populate the structure \\'nodeHeightsMap\\'. It stores the map of tree node to its corresponding height. It makes use of the standard Height finding algorithm. \\n\\nSecond we call the standard \\'Level Order Traversal\\' also known as the Breadth First Search in case of Graphs. Here by making use of the Queue structure we store all the nodes at a particular level in a map structure called \\'LevelByChildren\\', where key is the current level and value is the list of all nodes at that particular level.\\nWhile iterating doing this traversal we also store a mapping of node to level so that we know that what level does a particular node belong to, so that we can later do a look up on that.\\n\\n![image.png](https://assets.leetcode.com/users/images/ebd2b2b2-458f-46f9-889e-7679351cf9ab_1689529514.1232116.png)\\n\\n\\nThirdly we will need sort each list in the \\'LevelByChildrenMap\\' structure by height since we need just 2 largest values for our calculation. You will understand this by going over the point b) in the below passage. \\n\\n![image.png](https://assets.leetcode.com/users/images/2c86e8e4-fae9-4575-ae8e-3a44384ab40f_1689529611.9011755.png)\\n\\n\\nOnce we have all these precomputed values stored it is time for the logic of the problem. \\na) We find all the cousins for that query node. What that means is we pull all the nodes which are at the same level as this node from the map structure \\'LevelByChildrenMap\\'.\\nb) What we are trying to do is if there are more that one cousins at the same level we will use its height to calculate the height of the tree. We do this by adding the node\\'s height + node\\'s depth that would effectively give us the totol tree height.\\nc) In case there is only one node at that level which is the query node, and since we need to remove this, we return \\'level-1\\' level essentially here is the depth of the node. \\nd) One thing to remember here is at every level we just need to maintain just two nodes with max height since both will never be deleted together.\\n\\n**Dry Run** **:-**\\n\\n![image.png](https://assets.leetcode.com/users/images/e1d99f8e-d4c2-42ab-99c8-f57e9d6e5fdb_1689529649.4426959.png)\\n\\n\\n# Complexity\\n- Time complexity: O(N) N is the node count \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) N is the node count\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **If you found my solution and explanation helpful, please consider upvoting it. Your upvote will help rank it higher among other solutions, making it easier for people seeking assistance to find. Feel free to ask any follow-up questions in the comment section. Thank you for reading!**\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int[] TreeQueries(TreeNode root, int[] queries) \\n    {\\n        int[] result = new int[queries.Length];\\n       \\n        Dictionary<int,int> nodeHeightsMap = new();\\n        Dictionary<int,int> nodeLevelMap  = new();\\n        Dictionary<int,List<int>> LevelByChildrenMap = new();\\n\\n        CalculateHeightsOfAllNodes(root,nodeHeightsMap);\\n\\n        LevelOrderTravsersal(root,LevelByChildrenMap,nodeLevelMap);\\n\\n        foreach(KeyValuePair<int,List<int>> entry in LevelByChildrenMap)\\n        {\\n             entry.Value.Sort((a, b) =>\\n                 {\\n                        if (nodeHeightsMap[a] > nodeHeightsMap[b])\\n                        {\\n                            return -1;\\n                        }\\n                        else if (nodeHeightsMap[a] < nodeHeightsMap[b])\\n                        {\\n                            return 1;\\n                        }\\n                        else\\n                        {\\n                            return 0;\\n                        }\\n                 });\\n        }\\n\\n        for(int i = 0 ; i < queries.Length ; i++)\\n        {\\n            int level = nodeLevelMap[queries[i]];\\n            List<int> ChildrenAtLevel = LevelByChildrenMap[level];\\n\\n            if(ChildrenAtLevel.Count == 1)\\n            {\\n               result[i] = level-1;\\n            }\\n            else\\n            {\\n               foreach(int child in ChildrenAtLevel)\\n               {\\n                   if(child != queries[i])\\n                   {\\n                       result[i] = nodeLevelMap[child]+nodeHeightsMap[child];\\n                       break; \\n                   }\\n               }\\n            }\\n        }\\n\\n        return result;\\n    }\\n    public int CalculateHeightsOfAllNodes(TreeNode root,Dictionary<int,int> heights)\\n    {\\n        if(root == null) return -1;\\n\\n        int height = Math.Max(CalculateHeightsOfAllNodes(root.left,heights),CalculateHeightsOfAllNodes(root.right,heights))+1;\\n\\n        heights.Add(root.val,height);\\n\\n        return height;\\n    }\\n    private void LevelOrderTravsersal(TreeNode root,Dictionary<int,List<int>> LevelByChildren,Dictionary<int,int> nodeLevelMap)\\n    {\\n        Queue<TreeNode> queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n        queue.Enqueue(null);\\n        int level = 0;\\n        List<int> curr = new List<int>();\\n        while(queue.Count != 0)\\n        {\\n            TreeNode temp = queue.Dequeue();                   \\n            if(temp != null)\\n            {\\n               curr.Add(temp.val);\\n               nodeLevelMap.Add(temp.val,level);\\n               if(temp.left != null) queue.Enqueue(temp.left);\\n\\n               if(temp.right != null) queue.Enqueue(temp.right);\\n            }\\n            else\\n            {\\n                List<int> newList = new List<int>(curr);\\n                LevelByChildren.Add(level,newList);\\n                level++;             \\n                curr.Clear();\\n                if(queue.Count != 0)\\n                {\\n                   queue.Enqueue(null);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int[] TreeQueries(TreeNode root, int[] queries) \\n    {\\n        int[] result = new int[queries.Length];\\n       \\n        Dictionary<int,int> nodeHeightsMap = new();\\n        Dictionary<int,int> nodeLevelMap  = new();\\n        Dictionary<int,List<int>> LevelByChildrenMap = new();\\n\\n        CalculateHeightsOfAllNodes(root,nodeHeightsMap);\\n\\n        LevelOrderTravsersal(root,LevelByChildrenMap,nodeLevelMap);\\n\\n        foreach(KeyValuePair<int,List<int>> entry in LevelByChildrenMap)\\n        {\\n             entry.Value.Sort((a, b) =>\\n                 {\\n                        if (nodeHeightsMap[a] > nodeHeightsMap[b])\\n                        {\\n                            return -1;\\n                        }\\n                        else if (nodeHeightsMap[a] < nodeHeightsMap[b])\\n                        {\\n                            return 1;\\n                        }\\n                        else\\n                        {\\n                            return 0;\\n                        }\\n                 });\\n        }\\n\\n        for(int i = 0 ; i < queries.Length ; i++)\\n        {\\n            int level = nodeLevelMap[queries[i]];\\n            List<int> ChildrenAtLevel = LevelByChildrenMap[level];\\n\\n            if(ChildrenAtLevel.Count == 1)\\n            {\\n               result[i] = level-1;\\n            }\\n            else\\n            {\\n               foreach(int child in ChildrenAtLevel)\\n               {\\n                   if(child != queries[i])\\n                   {\\n                       result[i] = nodeLevelMap[child]+nodeHeightsMap[child];\\n                       break; \\n                   }\\n               }\\n            }\\n        }\\n\\n        return result;\\n    }\\n    public int CalculateHeightsOfAllNodes(TreeNode root,Dictionary<int,int> heights)\\n    {\\n        if(root == null) return -1;\\n\\n        int height = Math.Max(CalculateHeightsOfAllNodes(root.left,heights),CalculateHeightsOfAllNodes(root.right,heights))+1;\\n\\n        heights.Add(root.val,height);\\n\\n        return height;\\n    }\\n    private void LevelOrderTravsersal(TreeNode root,Dictionary<int,List<int>> LevelByChildren,Dictionary<int,int> nodeLevelMap)\\n    {\\n        Queue<TreeNode> queue = new Queue<TreeNode>();\\n        queue.Enqueue(root);\\n        queue.Enqueue(null);\\n        int level = 0;\\n        List<int> curr = new List<int>();\\n        while(queue.Count != 0)\\n        {\\n            TreeNode temp = queue.Dequeue();                   \\n            if(temp != null)\\n            {\\n               curr.Add(temp.val);\\n               nodeLevelMap.Add(temp.val,level);\\n               if(temp.left != null) queue.Enqueue(temp.left);\\n\\n               if(temp.right != null) queue.Enqueue(temp.right);\\n            }\\n            else\\n            {\\n                List<int> newList = new List<int>(curr);\\n                LevelByChildren.Add(level,newList);\\n                level++;             \\n                curr.Clear();\\n                if(queue.Count != 0)\\n                {\\n                   queue.Enqueue(null);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701953,
                "title": "euler-tour-o-n",
                "content": "# Intuition\\nEuler Sandwich to Precompute the Maximum Tree Levels\\n\\n# Approach\\nEuler Tour is a sandwich list of the root node of a tree surrounding the sub-nodes within that tree.\\n\\ntour: you first create a list of sandwiching Euler Tour list\\nmap_indices: you map the indices of where the starting and ending indices are\\nmap_prefix_suffix: you calculate the prefix and suffix maximum levels.\\ngive_answer: easily computes the maximum level when the subtree is removed.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\nCalculating the tour, indices, prefix, and suffix takes O(N). After that, each iteration of query takes O(1), a simple calculation based on indexing pre-computed numbers.\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# Map (list) node reference, height, other_node_height (if enone, -1)\\n\\ndef tour(euler_tour, node, level):\\n    \"\"\"\\n    This function performs an Euler tour (DFS) on the tree.\\n    :param euler_tour: list that stores the tour (node value, level)\\n    :param node: current node being visited\\n    :param level: level of the current node\\n    :return: None\\n    \"\"\"\\n    if not node:\\n        return\\n\\n    euler_tour.append((node.val, level))\\n    tour(euler_tour, node.left, level + 1)\\n    tour(euler_tour, node.right, level + 1)\\n    euler_tour.append((node.val, level))\\n\\ndef map_indices(indices, euler_tour):\\n    \"\"\"\\n    This function maps node values to their indices in the Euler tour.\\n    :param indices: dictionary that stores node values as keys and a list of indices as values\\n    :param euler_tour: list that stores the Euler tour (node value, level)\\n    :return: None\\n    \"\"\"\\n    for i, item in enumerate(euler_tour):\\n        indices[item[0]] = indices.get(item[0], []) + [i]\\n\\ndef map_prefix_suffix(prefix_max, suffix_max, euler_tour):\\n    \"\"\"\\n    This function creates prefix and suffix maximum arrays based on the levels in the Euler tour.\\n    :param prefix_max: list that stores the maximum level from the start to each index\\n    :param suffix_max: list that stores the maximum level from each index to the end\\n    :param euler_tour: list that stores the Euler tour (node value, level)\\n    :return: None\\n    \"\"\"\\n    max_ind = len(euler_tour) - 1\\n    for i, (_, level) in enumerate(euler_tour):\\n        prefix_max[i] = max(prefix_max[i - 1], level)\\n\\n        _, suffix_level = euler_tour[max_ind - i]\\n        suffix_max[max_ind - i] = max(suffix_max[max_ind - i + 1], suffix_level)\\n\\ndef give_answer(queries, indices, prefix_max, suffix_max):\\n    \"\"\"\\n    This function calculates the answers for the queries.\\n    :param queries: list of queries (node values)\\n    :param indices: dictionary that maps node values to their indices in the Euler tour\\n    :param prefix_max: list that stores the maximum level from the start to each index\\n    :param suffix_max: list that stores the maximum level from each index to the end\\n    :return: list of answers for the queries\\n    \"\"\"\\n    return_answer = []\\n    for query in queries:\\n        start, end = indices[query]\\n        # this includes possibility of list spillover\\n        return_answer += [max(prefix_max[start - 1], suffix_max[end + 1])]\\n    return return_answer\\n\\nclass Solution(object):\\n    def treeQueries(self, root, queries):\\n        \"\"\"\\n        :type root: Optional[TreeNode]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        euler_tour = []\\n        indices = {}    \\n        \\n        tour(euler_tour, root, 0)\\n\\n        map_indices(indices, euler_tour)\\n\\n        prefix_max = [0 for i in range(len(euler_tour) + 1)]\\n        suffix_max = [0 for i in range(len(euler_tour) + 1)]\\n\\n        map_prefix_suffix(prefix_max, suffix_max, euler_tour)\\n\\n        return give_answer(queries, indices, prefix_max, suffix_max)\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# Map (list) node reference, height, other_node_height (if enone, -1)\\n\\ndef tour(euler_tour, node, level):\\n    \"\"\"\\n    This function performs an Euler tour (DFS) on the tree.\\n    :param euler_tour: list that stores the tour (node value, level)\\n    :param node: current node being visited\\n    :param level: level of the current node\\n    :return: None\\n    \"\"\"\\n    if not node:\\n        return\\n\\n    euler_tour.append((node.val, level))\\n    tour(euler_tour, node.left, level + 1)\\n    tour(euler_tour, node.right, level + 1)\\n    euler_tour.append((node.val, level))\\n\\ndef map_indices(indices, euler_tour):\\n    \"\"\"\\n    This function maps node values to their indices in the Euler tour.\\n    :param indices: dictionary that stores node values as keys and a list of indices as values\\n    :param euler_tour: list that stores the Euler tour (node value, level)\\n    :return: None\\n    \"\"\"\\n    for i, item in enumerate(euler_tour):\\n        indices[item[0]] = indices.get(item[0], []) + [i]\\n\\ndef map_prefix_suffix(prefix_max, suffix_max, euler_tour):\\n    \"\"\"\\n    This function creates prefix and suffix maximum arrays based on the levels in the Euler tour.\\n    :param prefix_max: list that stores the maximum level from the start to each index\\n    :param suffix_max: list that stores the maximum level from each index to the end\\n    :param euler_tour: list that stores the Euler tour (node value, level)\\n    :return: None\\n    \"\"\"\\n    max_ind = len(euler_tour) - 1\\n    for i, (_, level) in enumerate(euler_tour):\\n        prefix_max[i] = max(prefix_max[i - 1], level)\\n\\n        _, suffix_level = euler_tour[max_ind - i]\\n        suffix_max[max_ind - i] = max(suffix_max[max_ind - i + 1], suffix_level)\\n\\ndef give_answer(queries, indices, prefix_max, suffix_max):\\n    \"\"\"\\n    This function calculates the answers for the queries.\\n    :param queries: list of queries (node values)\\n    :param indices: dictionary that maps node values to their indices in the Euler tour\\n    :param prefix_max: list that stores the maximum level from the start to each index\\n    :param suffix_max: list that stores the maximum level from each index to the end\\n    :return: list of answers for the queries\\n    \"\"\"\\n    return_answer = []\\n    for query in queries:\\n        start, end = indices[query]\\n        # this includes possibility of list spillover\\n        return_answer += [max(prefix_max[start - 1], suffix_max[end + 1])]\\n    return return_answer\\n\\nclass Solution(object):\\n    def treeQueries(self, root, queries):\\n        \"\"\"\\n        :type root: Optional[TreeNode]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        euler_tour = []\\n        indices = {}    \\n        \\n        tour(euler_tour, root, 0)\\n\\n        map_indices(indices, euler_tour)\\n\\n        prefix_max = [0 for i in range(len(euler_tour) + 1)]\\n        suffix_max = [0 for i in range(len(euler_tour) + 1)]\\n\\n        map_prefix_suffix(prefix_max, suffix_max, euler_tour)\\n\\n        return give_answer(queries, indices, prefix_max, suffix_max)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537679,
                "title": "with-dfs-priority-queue-and-map",
                "content": "\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1.We precompute, depth of all subtrees and their heights.\\n2.Now, the node we have to delete , we need to calculate maximum depth among all nodes among all nodes at same depth that of deleted node .\\n3. add maximum depth to depth of the level.\\n4. answer for each query is ready.\\n5. please upvote!!!\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n int height(TreeNode* root,int h,map<int,priority_queue<pair<int,int>>>&m,map<int,int>&p)\\n{\\n      if(root==NULL)\\n         return(0);\\n       p[root->val]=h;\\n         int x=height(root->left,h+1,m,p);\\n         int y=height(root->right,h+1,m,p);\\n         int ans=max(x,y);\\n         m[h].push(make_pair(ans,root->val));\\n         return(ans+1);\\n\\n}\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        map<int,priority_queue<pair<int,int>>>m;\\n        map<int,int>p;\\n        height(root,0,m,p);\\n        vector<int>ans;\\n        for(auto e:queries)\\n        {\\n            int h=p[e];\\n            int d=0;\\n          if(m[h].size()==1)\\n          {\\n              if(h>0)\\n                ans.push_back(max(0,h-1));\\n                continue;\\n          }\\n          if(m[h].top().second!=e)\\n          {\\n              d=m[h].top().first;\\n          }\\n          else\\n          {\\n              pair<int,int>x=m[h].top();\\n              m[h].pop();\\n              d=m[h].top().first;\\n              m[h].push(x);\\n          }\\n            \\n            ans.push_back(d+h);\\n           \\n        }\\n        return(ans);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n int height(TreeNode* root,int h,map<int,priority_queue<pair<int,int>>>&m,map<int,int>&p)\\n{\\n      if(root==NULL)\\n         return(0);\\n       p[root->val]=h;\\n         int x=height(root->left,h+1,m,p);\\n         int y=height(root->right,h+1,m,p);\\n         int ans=max(x,y);\\n         m[h].push(make_pair(ans,root->val));\\n         return(ans+1);\\n\\n}\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        map<int,priority_queue<pair<int,int>>>m;\\n        map<int,int>p;\\n        height(root,0,m,p);\\n        vector<int>ans;\\n        for(auto e:queries)\\n        {\\n            int h=p[e];\\n            int d=0;\\n          if(m[h].size()==1)\\n          {\\n              if(h>0)\\n                ans.push_back(max(0,h-1));\\n                continue;\\n          }\\n          if(m[h].top().second!=e)\\n          {\\n              d=m[h].top().first;\\n          }\\n          else\\n          {\\n              pair<int,int>x=m[h].top();\\n              m[h].pop();\\n              d=m[h].top().first;\\n              m[h].push(x);\\n          }\\n            \\n            ans.push_back(d+h);\\n           \\n        }\\n        return(ans);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893961,
                "title": "dms-two-times",
                "content": "# Intuition\\nsource:0x3f\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc treeQueries(root *TreeNode, queries []int) []int {\\n    height:=map[*TreeNode]int{}//tree node height\\n    var dfsheight func(*TreeNode)int\\n    dfsheight=func(node *TreeNode) int{\\n        if node==nil{\\n            return 0\\n        }\\n        height[node]=max(dfsheight(node.Left),dfsheight(node.Right))+1\\n        return height[node]\\n    }\\n    dfsheight(root)\\n\\n    ans:=make([]int,len(height)+1)\\n    var dfs func(*TreeNode,int,int)\\n    dfs=func(node *TreeNode,deep,val int){\\n        if node==nil{\\n            return\\n        }\\n        deep+=1\\n        ans[node.Val]=val\\n        dfs(node.Left,deep,max(val,height[node.Right]+deep-1))\\n        dfs(node.Right,deep,max(val,height[node.Left]+deep-1))\\n    }\\n    dfs(root,0,0)\\n\\n    for i,v := range(queries){\\n        queries[i]=ans[v]\\n    }\\n    return queries\\n}\\nfunc max(a,b int)int{if a>b {return a}; return b}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc treeQueries(root *TreeNode, queries []int) []int {\\n    height:=map[*TreeNode]int{}//tree node height\\n    var dfsheight func(*TreeNode)int\\n    dfsheight=func(node *TreeNode) int{\\n        if node==nil{\\n            return 0\\n        }\\n        height[node]=max(dfsheight(node.Left),dfsheight(node.Right))+1\\n        return height[node]\\n    }\\n    dfsheight(root)\\n\\n    ans:=make([]int,len(height)+1)\\n    var dfs func(*TreeNode,int,int)\\n    dfs=func(node *TreeNode,deep,val int){\\n        if node==nil{\\n            return\\n        }\\n        deep+=1\\n        ans[node.Val]=val\\n        dfs(node.Left,deep,max(val,height[node.Right]+deep-1))\\n        dfs(node.Right,deep,max(val,height[node.Left]+deep-1))\\n    }\\n    dfs(root,0,0)\\n\\n    for i,v := range(queries){\\n        queries[i]=ans[v]\\n    }\\n    return queries\\n}\\nfunc max(a,b int)int{if a>b {return a}; return b}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2821844,
                "title": "simple-solution-using-dfs-and-hashmap-c-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore levels of nodes and height of its subtree \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int N; // total nodes\\n    vector<vector<int>> lv; // this will store level and it\\'s maximum heights and only 2 of its point\\n    vector<int> nlv; // this will store value of nodes level \\n    vector<int> nheg; // this will store height of n node\\n    // this function will init all above vectors recursively\\n    int trverse(TreeNode* r,int l){\\n        if(r == NULL) return 0;\\n        // find N \\n        N = max(N,r->val);\\n        // nlv array will contain r->val level\\n        nlv[r->val] = l;\\n        // call for left and right\\n        int lt = trverse(r->left,l+1);\\n        int rt = trverse(r->right,l+1);\\n        // nheg will store height of nth node as root node\\n        nheg[r->val] = max(lt,rt);\\n        // push this node in this level\\n        lv[l].push_back(nheg[r->val]);\\n        if(lv[l].size() == 3){\\n            // find min and remove it\\n            int mi = min({lv[l][0],lv[l][1],lv[l][2]});\\n            if(lv[l][0] == mi) swap(lv[l][2],lv[l][0]);\\n            else if(lv[l][1] == mi) swap(lv[l][2],lv[l][1]);\\n            lv[l].pop_back();\\n        }\\n        return nheg[r->val] + 1;\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        // initalizing size of vectors\\n        lv.resize(1e5);\\n        nheg.resize(1e5+1,0);\\n        nlv.resize(1e5+1,0);\\n        // we can store tree node with their value\\n        N = 0;\\n        nheg[0] = -1;\\n        trverse(root,0); // fill all vectors\\n        vector<int> t(N+1,0); // store values of height if every node is deleted one time\\n        vector<int> ans(queries.size(),0);\\n        for(int i=1;i<=N;i++){\\n            // try removing i\\n            // we are going to search that level\\n            if(nlv[i] == 0) continue; // if i is root node\\n            int new_maxh = -1; // we have to find new max height\\n            bool cnt = 1; // if we have same value for 2 time then avoid only one time\\n            // traverse level of i\\'th node\\n            for(int j : lv[nlv[i]]){\\n                if(j == nheg[i] && cnt){ cnt = 0; continue;}\\n                new_maxh = max(new_maxh, j);\\n            }\\n            // if new max is -1 means no other node at this level so this means we can only have tree height \\n            // if we found another max then add that max height to this level\\n            t[i] = new_maxh == -1 ? nlv[i] - 1 : nlv[i] + new_maxh;\\n        }\\n        // Now just fill answer for queries\\n        for(int i=0;i<queries.size();i++){\\n            ans[i] = t[queries[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int N; // total nodes\\n    vector<vector<int>> lv; // this will store level and it\\'s maximum heights and only 2 of its point\\n    vector<int> nlv; // this will store value of nodes level \\n    vector<int> nheg; // this will store height of n node\\n    // this function will init all above vectors recursively\\n    int trverse(TreeNode* r,int l){\\n        if(r == NULL) return 0;\\n        // find N \\n        N = max(N,r->val);\\n        // nlv array will contain r->val level\\n        nlv[r->val] = l;\\n        // call for left and right\\n        int lt = trverse(r->left,l+1);\\n        int rt = trverse(r->right,l+1);\\n        // nheg will store height of nth node as root node\\n        nheg[r->val] = max(lt,rt);\\n        // push this node in this level\\n        lv[l].push_back(nheg[r->val]);\\n        if(lv[l].size() == 3){\\n            // find min and remove it\\n            int mi = min({lv[l][0],lv[l][1],lv[l][2]});\\n            if(lv[l][0] == mi) swap(lv[l][2],lv[l][0]);\\n            else if(lv[l][1] == mi) swap(lv[l][2],lv[l][1]);\\n            lv[l].pop_back();\\n        }\\n        return nheg[r->val] + 1;\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        // initalizing size of vectors\\n        lv.resize(1e5);\\n        nheg.resize(1e5+1,0);\\n        nlv.resize(1e5+1,0);\\n        // we can store tree node with their value\\n        N = 0;\\n        nheg[0] = -1;\\n        trverse(root,0); // fill all vectors\\n        vector<int> t(N+1,0); // store values of height if every node is deleted one time\\n        vector<int> ans(queries.size(),0);\\n        for(int i=1;i<=N;i++){\\n            // try removing i\\n            // we are going to search that level\\n            if(nlv[i] == 0) continue; // if i is root node\\n            int new_maxh = -1; // we have to find new max height\\n            bool cnt = 1; // if we have same value for 2 time then avoid only one time\\n            // traverse level of i\\'th node\\n            for(int j : lv[nlv[i]]){\\n                if(j == nheg[i] && cnt){ cnt = 0; continue;}\\n                new_maxh = max(new_maxh, j);\\n            }\\n            // if new max is -1 means no other node at this level so this means we can only have tree height \\n            // if we found another max then add that max height to this level\\n            t[i] = new_maxh == -1 ? nlv[i] - 1 : nlv[i] + new_maxh;\\n        }\\n        // Now just fill answer for queries\\n        for(int i=0;i<queries.size();i++){\\n            ans[i] = t[queries[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807828,
                "title": "current-level-pre-stored-depth",
                "content": "Here are the following steps : \\n\\n**Step 1 :** Store the depth of each node by doing the dfs. \\n**Step 2 :** Store the level of each node with maximum and 2nd maximum value with respect to each level.\\n**Step 3 :** Now , iterating through the queries vector check the level with each element and checking the highest value matches the node or the second highest and processing the answer accordingly.\\n**Step 4 :** Store the answer in a vector and return.\\n\\n**C++ Code:**\\n   \\n   \\n   map<int,int>m1;\\n   \\n    vector<int> treeQueries(TreeNode* root, vector<int>& v) {\\n        vector<int>ans;\\n        int a = solve(root);\\n        \\n       queue<TreeNode*>q;\\n        int level{};\\n        map<int,int>m2;\\n        map<int,pair<pair<int,TreeNode*>,pair<int,TreeNode*>>>m3;\\n        q.push(root);\\n        \\n        while(!q.empty()){// Store the level\\'s highest and 2nd highest in map\\n            \\n            int sz = q.size();\\n            \\n            vector<pair<int,TreeNode*>>res;\\n            \\n            for(int i=0;i<sz;i++){\\n                auto it = q.front();\\n                m2[it->val] = level;\\n                res.push_back({m1[it->val],it});\\n                q.pop();\\n                \\n                if(it->left) q.push(it->left);\\n                if(it->right) q.push(it->right);\\n            }\\n            \\n            sort(res.begin(),res.end());\\n            reverse(res.begin(),res.end());\\n            if(res.size()==1)\\n                res.push_back({NULL,0});\\n            \\n            m3[level] = {res[0],res[1]};\\n            \\n            \\n            \\n            level++;\\n        }\\n        \\n        \\n        for(int i=0;i<v.size();i++){//Queries processing to find the answer\\n            int lev = m2[v[i]];\\n            auto a = m3[lev];\\n            \\n            if(a.first.second->val == v[i]){\\n                int c = a.second.first;\\n                ans.push_back(lev+c-1);\\n            }\\n            else{\\n                int c = a.first.first;\\n                ans.push_back(lev+c-1);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int solve(TreeNode* root){// dfs to calculate the depth of each node\\n        \\n        if(root==NULL)\\n            return 0;\\n        \\n        int lt = solve(root->left);\\n        int rt = solve(root->right);\\n        \\n        m1[root->val] = 1 + max(lt,rt);\\n        \\n        return 1 + max(lt,rt);\\n    }\\n\\t\\n\\t\\n**Thank You.**\\t",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "Here are the following steps : \\n\\n**Step 1 :** Store the depth of each node by doing the dfs. \\n**Step 2 :** Store the level of each node with maximum and 2nd maximum value with respect to each level.\\n**Step 3 :** Now , iterating through the queries vector check the level with each element and checking the highest value matches the node or the second highest and processing the answer accordingly.\\n**Step 4 :** Store the answer in a vector and return.\\n\\n**C++ Code:**\\n   \\n   \\n   map<int,int>m1;\\n   \\n    vector<int> treeQueries(TreeNode* root, vector<int>& v) {\\n        vector<int>ans;\\n        int a = solve(root);\\n        \\n       queue<TreeNode*>q;\\n        int level{};\\n        map<int,int>m2;\\n        map<int,pair<pair<int,TreeNode*>,pair<int,TreeNode*>>>m3;\\n        q.push(root);\\n        \\n        while(!q.empty()){// Store the level\\'s highest and 2nd highest in map\\n            \\n            int sz = q.size();\\n            \\n            vector<pair<int,TreeNode*>>res;\\n            \\n            for(int i=0;i<sz;i++){\\n                auto it = q.front();\\n                m2[it->val] = level;\\n                res.push_back({m1[it->val],it});\\n                q.pop();\\n                \\n                if(it->left) q.push(it->left);\\n                if(it->right) q.push(it->right);\\n            }\\n            \\n            sort(res.begin(),res.end());\\n            reverse(res.begin(),res.end());\\n            if(res.size()==1)\\n                res.push_back({NULL,0});\\n            \\n            m3[level] = {res[0],res[1]};\\n            \\n            \\n            \\n            level++;\\n        }\\n        \\n        \\n        for(int i=0;i<v.size();i++){//Queries processing to find the answer\\n            int lev = m2[v[i]];\\n            auto a = m3[lev];\\n            \\n            if(a.first.second->val == v[i]){\\n                int c = a.second.first;\\n                ans.push_back(lev+c-1);\\n            }\\n            else{\\n                int c = a.first.first;\\n                ans.push_back(lev+c-1);\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    int solve(TreeNode* root){// dfs to calculate the depth of each node\\n        \\n        if(root==NULL)\\n            return 0;\\n        \\n        int lt = solve(root->left);\\n        int rt = solve(root->right);\\n        \\n        m1[root->val] = 1 + max(lt,rt);\\n        \\n        return 1 + max(lt,rt);\\n    }\\n\\t\\n\\t\\n**Thank You.**\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2786214,
                "title": "c-dfs-preorder-traversal",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    static const int N = 1e5 + 5;\\npublic:\\n    int dfs(TreeNode* root, int currLvl, vector<int>& lvl, vector<int>& mxPath, vector<vector<int>>& adj) {\\n        if(!root) return currLvl - 1;\\n        lvl[root->val] = currLvl;\\n        int l = dfs(root->left, currLvl + 1, lvl, mxPath, adj);\\n        int r = dfs(root->right, currLvl + 1, lvl, mxPath, adj);\\n        mxPath[root->val] = max(l, r);\\n        if(mxPath[root->val] >= adj[currLvl][1]) {\\n            adj[currLvl][0] = adj[currLvl][1];\\n            adj[currLvl][1] = mxPath[root->val];\\n        }\\n        else if(mxPath[root->val] > adj[currLvl][0])\\n            adj[currLvl][0] = mxPath[root->val];\\n        return mxPath[root->val];\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int> lvl(N, -1), mxPath(N, -1);\\n        vector<vector<int>> adj(N, vector<int>(2, -1));\\n        int height = dfs(root, 0, lvl, mxPath, adj);\\n        vector<int> res;\\n        for(int &query:queries) {\\n            if(mxPath[query] != height) res.push_back(height);\\n            else {\\n                if(adj[lvl[query]][0] != -1) res.push_back(adj[lvl[query]][0]);\\n                else res.push_back(lvl[query] - 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2 * N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    static const int N = 1e5 + 5;\\npublic:\\n    int dfs(TreeNode* root, int currLvl, vector<int>& lvl, vector<int>& mxPath, vector<vector<int>>& adj) {\\n        if(!root) return currLvl - 1;\\n        lvl[root->val] = currLvl;\\n        int l = dfs(root->left, currLvl + 1, lvl, mxPath, adj);\\n        int r = dfs(root->right, currLvl + 1, lvl, mxPath, adj);\\n        mxPath[root->val] = max(l, r);\\n        if(mxPath[root->val] >= adj[currLvl][1]) {\\n            adj[currLvl][0] = adj[currLvl][1];\\n            adj[currLvl][1] = mxPath[root->val];\\n        }\\n        else if(mxPath[root->val] > adj[currLvl][0])\\n            adj[currLvl][0] = mxPath[root->val];\\n        return mxPath[root->val];\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int> lvl(N, -1), mxPath(N, -1);\\n        vector<vector<int>> adj(N, vector<int>(2, -1));\\n        int height = dfs(root, 0, lvl, mxPath, adj);\\n        vector<int> res;\\n        for(int &query:queries) {\\n            if(mxPath[query] != height) res.push_back(height);\\n            else {\\n                if(adj[lvl[query]][0] != -1) res.push_back(adj[lvl[query]][0]);\\n                else res.push_back(lvl[query] - 1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778773,
                "title": "python3-easy-dfs-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        \\n\\t\\t#each node stores (value, max_height to left + own height, max_height to right + own height)\\n        def get_height(root, current):\\n            if not root: return [0, 0]\\n            else:\\n                left = get_height(root.left, current + 1)\\n                right = get_height(root.right, current + 1)\\n                root.val = [root.val, current + max(left), current + max(right)]\\n                return [max(left) + 1, max(right) + 1]\\n           \\n\\t\\t#traverse the tree and store the solution for all subtrees\\n\\t\\t#carry stores the maximum height so far\\n        def gen_sol(root, carry, dicts):\\n            if root.left:\\n                dicts[root.left.val[0]] = max(carry, root.val[2])\\n                gen_sol(root.left, max(carry, root.val[2]), dicts)\\n            if root.right:\\n                dicts[root.right.val[0]] = max(carry, root.val[1])\\n                gen_sol(root.right, max(carry, root.val[1]), dicts)\\n                \\n        dicts = {}\\n        get_height(root, 0)\\n        gen_sol(root, -1, dicts)\\n        \\n        res = []\\n        \\n\\t\\t#get solutions from the dictionary\\n        for element in queries:\\n            res.append(dicts[element])\\n        \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        \\n\\t\\t#each node stores (value, max_height to left + own height, max_height to right + own height)\\n        def get_height(root, current):\\n            if not root: return [0, 0]\\n            else:\\n                left = get_height(root.left, current + 1)\\n                right = get_height(root.right, current + 1)\\n                root.val = [root.val, current + max(left), current + max(right)]\\n                return [max(left) + 1, max(right) + 1]\\n           \\n\\t\\t#traverse the tree and store the solution for all subtrees\\n\\t\\t#carry stores the maximum height so far\\n        def gen_sol(root, carry, dicts):\\n            if root.left:\\n                dicts[root.left.val[0]] = max(carry, root.val[2])\\n                gen_sol(root.left, max(carry, root.val[2]), dicts)\\n            if root.right:\\n                dicts[root.right.val[0]] = max(carry, root.val[1])\\n                gen_sol(root.right, max(carry, root.val[1]), dicts)\\n                \\n        dicts = {}\\n        get_height(root, 0)\\n        gen_sol(root, -1, dicts)\\n        \\n        res = []\\n        \\n\\t\\t#get solutions from the dictionary\\n        for element in queries:\\n            res.append(dicts[element])\\n        \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776760,
                "title": "basic-practice-tree-concepts-level-height-cousin-python",
                "content": "1- Two solution formats (essentially one)\\n```\\nclass Solution:\\n    def treeQueries_v1(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        # 1. get height and depth of each node\\n        # depth: the path length from root to this node\\n        # height: the path length from this node to deepest descedant(s)\\n        depth = collections.defaultdict(int)\\n        height = collections.defaultdict(int)\\n        \\n        def worker(node, d):\\n            if not node:\\n                return -1\\n            depth[node.val] = d\\n            l = worker(node.left, d + 1)\\n            r = worker(node.right, d + 1)\\n            h = max(l, r) + 1\\n            height[node.val] = h\\n            return h\\n        \\n        \\n        \\n        worker(root, 0)\\n        \\n        # 2. find cousins at each level\\n        cousins = collections.defaultdict(list)\\n        for val, d in depth.items():\\n            cousins[d].append((-height[val], val))\\n            cousins[d].sort()\\n            while len(cousins[d]) > 2:\\n                cousins[d].pop()\\n        \\n        # 3. get the return\\n        res = []\\n        for val in queries:\\n            d = depth[val]\\n            csn = cousins[d]\\n            if len(csn) == 1:\\n                res.append(d-1)\\n            elif val == csn[0][1]: # the removed node has max height in csn\\n                res.append(d - csn[1][0])\\n            else:\\n                res.append(d - csn[0][0])\\n        return res\\n    \\n    \\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        # 1. get height and depth of each node\\n        # depth: the path length from root to this node\\n        # height: the path length from this node to deepest descedant(s)\\n        depth = collections.defaultdict(int)\\n        height = collections.defaultdict(int)\\n        \\n        def worker(node, d):\\n            if not node:\\n                return -1\\n            depth[node.val] = d\\n            l = worker(node.left, d + 1)\\n            r = worker(node.right, d + 1)\\n            h = max(l, r) + 1\\n            height[node.val] = h\\n            return h\\n        \\n        \\n        \\n        worker(root, 0)\\n        \\n        # 2. find cousins at each level\\n        cousins = collections.defaultdict(list)\\n        for val, d in depth.items():\\n            heapq.heappush(cousins[d], (height[val], val))\\n            if len(cousins[d]) > 2:\\n                heapq.heappop(cousins[d])\\n        \\n        # 3. get the return\\n        res = []\\n        for val in queries:\\n            d = depth[val]\\n            csn = cousins[d]\\n            if len(csn) == 1:\\n                res.append(d-1)\\n            # the removal val is in csn\\n            elif csn[0][1] == val:\\n                res.append(d + csn[1][0])\\n            elif csn[1][1] == val:\\n                res.append(d + csn[0][0])\\n            # the removal val not in csn\\n            else:\\n                res.append(d + csn[1][0])\\n        return res\\n```\\n2- Video Explanation: [Click Here](https://youtu.be/sAeBg7FNbHo;)\\n\\n3- Analysis or Summary\\n```\\nTreatment: find each node\\'s depth, height, and cousins (need at most 2)\\n\\nIdea: (1) for each node, we could find two pieces of information: depth, heigh\\n      depth d: the path length from whole tree root to the node\\n      height h: the height of the tree rooted at the node\\n      for example, node 5 in example 1 has depth d = 2, height h = 1.\\n      \\n      (2) for each node, find the two (if exist) cousins with the same depth and with largest heights. For example,\\n      for node 5 in example 1, the two highest cousins with depth 2 is Node 5 with height 1, Node 6 with height 0 \\n      (or we can use Node 2 with 0).\\n      \\n      Once a node with val v at depth d is deleted, the longest path for the remaining tree is the path that passes the node\\'s\\n      cousin with largest height h0. And the resulted tree has height = d + h0\\n      \\n      For example in example 2, node 3 is at depth 2, its cousins at this depths with decreasing heights are:\\n      2:1, 1:0, 3:0, 7:0\\n      After deleting this node 1, the remaining tree has height 2 + 1 = 3.\\n      \\n      Remark: it is possible that the val to be deleted is not within the 2 cousin nodes with largest heights.\\n      \\nWe can use sort or minHeap when we find the cousins with larger heights.\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def treeQueries_v1(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        # 1. get height and depth of each node\\n        # depth: the path length from root to this node\\n        # height: the path length from this node to deepest descedant(s)\\n        depth = collections.defaultdict(int)\\n        height = collections.defaultdict(int)\\n        \\n        def worker(node, d):\\n            if not node:\\n                return -1\\n            depth[node.val] = d\\n            l = worker(node.left, d + 1)\\n            r = worker(node.right, d + 1)\\n            h = max(l, r) + 1\\n            height[node.val] = h\\n            return h\\n        \\n        \\n        \\n        worker(root, 0)\\n        \\n        # 2. find cousins at each level\\n        cousins = collections.defaultdict(list)\\n        for val, d in depth.items():\\n            cousins[d].append((-height[val], val))\\n            cousins[d].sort()\\n            while len(cousins[d]) > 2:\\n                cousins[d].pop()\\n        \\n        # 3. get the return\\n        res = []\\n        for val in queries:\\n            d = depth[val]\\n            csn = cousins[d]\\n            if len(csn) == 1:\\n                res.append(d-1)\\n            elif val == csn[0][1]: # the removed node has max height in csn\\n                res.append(d - csn[1][0])\\n            else:\\n                res.append(d - csn[0][0])\\n        return res\\n    \\n    \\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        # 1. get height and depth of each node\\n        # depth: the path length from root to this node\\n        # height: the path length from this node to deepest descedant(s)\\n        depth = collections.defaultdict(int)\\n        height = collections.defaultdict(int)\\n        \\n        def worker(node, d):\\n            if not node:\\n                return -1\\n            depth[node.val] = d\\n            l = worker(node.left, d + 1)\\n            r = worker(node.right, d + 1)\\n            h = max(l, r) + 1\\n            height[node.val] = h\\n            return h\\n        \\n        \\n        \\n        worker(root, 0)\\n        \\n        # 2. find cousins at each level\\n        cousins = collections.defaultdict(list)\\n        for val, d in depth.items():\\n            heapq.heappush(cousins[d], (height[val], val))\\n            if len(cousins[d]) > 2:\\n                heapq.heappop(cousins[d])\\n        \\n        # 3. get the return\\n        res = []\\n        for val in queries:\\n            d = depth[val]\\n            csn = cousins[d]\\n            if len(csn) == 1:\\n                res.append(d-1)\\n            # the removal val is in csn\\n            elif csn[0][1] == val:\\n                res.append(d + csn[1][0])\\n            elif csn[1][1] == val:\\n                res.append(d + csn[0][0])\\n            # the removal val not in csn\\n            else:\\n                res.append(d + csn[1][0])\\n        return res\\n```\n```\\nTreatment: find each node\\'s depth, height, and cousins (need at most 2)\\n\\nIdea: (1) for each node, we could find two pieces of information: depth, heigh\\n      depth d: the path length from whole tree root to the node\\n      height h: the height of the tree rooted at the node\\n      for example, node 5 in example 1 has depth d = 2, height h = 1.\\n      \\n      (2) for each node, find the two (if exist) cousins with the same depth and with largest heights. For example,\\n      for node 5 in example 1, the two highest cousins with depth 2 is Node 5 with height 1, Node 6 with height 0 \\n      (or we can use Node 2 with 0).\\n      \\n      Once a node with val v at depth d is deleted, the longest path for the remaining tree is the path that passes the node\\'s\\n      cousin with largest height h0. And the resulted tree has height = d + h0\\n      \\n      For example in example 2, node 3 is at depth 2, its cousins at this depths with decreasing heights are:\\n      2:1, 1:0, 3:0, 7:0\\n      After deleting this node 1, the remaining tree has height 2 + 1 = 3.\\n      \\n      Remark: it is possible that the val to be deleted is not within the 2 cousin nodes with largest heights.\\n      \\nWe can use sort or minHeap when we find the cousins with larger heights.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762083,
                "title": "java-solution-priorityqueue-hashtable-dfs",
                "content": "```java \\nclass Solution {\\n    int max;\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        max=0;\\n        findMax(root);\\n        int[][] a = new int[max+1][2]; //hashtable to store height and level of each node\\n        \\n        ArrayList<PriorityQueue<Integer>> queue = new ArrayList<>();\\n        int height = height(root,a,0,queue);\\n        \\n        int i=0;\\n        int[] res = new int[queries.length];\\n        for(int query:queries)\\n        {\\n            res[i++]= height - getDiff(queue,a[query][0],a[query][1]);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    private int height(TreeNode root,int[][] a,int level,ArrayList<PriorityQueue<Integer>> queue)  \\n\\t// storing height and level for each node in hashtable & heights at each level in priorityQueue\\n    {\\n        if(root==null)\\n            return -1;\\n        if(queue.size()==level)\\n        queue.add(new PriorityQueue<Integer>(Collections.reverseOrder()));\\n        \\n        int lheight=height(root.left,a,level+1,queue);\\n        int rheight=height(root.right,a,level+1,queue);\\n        int ans = Math.max(lheight,rheight)+1;\\n        \\n        queue.get(level).add(ans);\\n        a[root.val][0]=ans;\\n        a[root.val][1]=level;\\n        return ans;\\n    }\\n    \\n    private void findMax(TreeNode root)  // find hashtable size\\n    {\\n        if(root==null)\\n            return;\\n        if(root.val>max)\\n            max=root.val;\\n        findMax(root.left);\\n        findMax(root.right);\\n    }\\n    \\n    private int getDiff(ArrayList<PriorityQueue<Integer>> queue,int h,int l) //reduced height\\n    {\\n        PriorityQueue<Integer> pq = queue.get(l);\\n        int ans=0;\\n        if(pq.peek()==h)\\n        {\\n            int prev = pq.remove();\\n            if(!pq.isEmpty())\\n                ans = prev-pq.peek();\\n            else\\n                ans = prev+1;\\n            pq.add(prev);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    int max;\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        max=0;\\n        findMax(root);\\n        int[][] a = new int[max+1][2]; //hashtable to store height and level of each node\\n        \\n        ArrayList<PriorityQueue<Integer>> queue = new ArrayList<>();\\n        int height = height(root,a,0,queue);\\n        \\n        int i=0;\\n        int[] res = new int[queries.length];\\n        for(int query:queries)\\n        {\\n            res[i++]= height - getDiff(queue,a[query][0],a[query][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2760795,
                "title": "python3-triple-dict-depth-height-nodes-at-depth",
                "content": "# Intuition\\nI got the idea to use cousin nodes from someone else.\\n\\n# Code\\n```\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        depth = {}\\n        height = {}\\n        nodes_at_depth = {}\\n\\n        max_height = 0\\n\\n        def rec(n, d):\\n            nonlocal max_height\\n            if n is None:\\n                return 0\\n            height_below = max(rec(n.left, d+1), rec(n.right, d+1))\\n            v = n.val\\n            depth[v] = d\\n            h = d + 1 + height_below\\n            height[v] = h\\n            max_height = max(max_height, h)\\n\\n            if d not in nodes_at_depth:\\n                nodes_at_depth[d] = [v]\\n            else:\\n                nodes_at_depth[d].append(v)\\n\\n            return 1 + height_below\\n\\n\\n        rec(root, -1)  # subtract one because the problem reports heights weird\\n        ret = []\\n\\n\\n        for q in queries:\\n            if height[q] >= max_height:\\n                d = depth[q]\\n                for cousin in nodes_at_depth[depth[q]]:\\n                    if cousin != q:  # don\\'t count self, obviously\\n                        d = max(d, height[cousin])\\n                ret.append(d)  \\n            else:\\n                ret.append(max_height)\\n        \\n        return ret\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        depth = {}\\n        height = {}\\n        nodes_at_depth = {}\\n\\n        max_height = 0\\n\\n        def rec(n, d):\\n            nonlocal max_height\\n            if n is None:\\n                return 0\\n            height_below = max(rec(n.left, d+1), rec(n.right, d+1))\\n            v = n.val\\n            depth[v] = d\\n            h = d + 1 + height_below\\n            height[v] = h\\n            max_height = max(max_height, h)\\n\\n            if d not in nodes_at_depth:\\n                nodes_at_depth[d] = [v]\\n            else:\\n                nodes_at_depth[d].append(v)\\n\\n            return 1 + height_below\\n\\n\\n        rec(root, -1)  # subtract one because the problem reports heights weird\\n        ret = []\\n\\n\\n        for q in queries:\\n            if height[q] >= max_height:\\n                d = depth[q]\\n                for cousin in nodes_at_depth[depth[q]]:\\n                    if cousin != q:  # don\\'t count self, obviously\\n                        d = max(d, height[cousin])\\n                ret.append(d)  \\n            else:\\n                ret.append(max_height)\\n        \\n        return ret\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760144,
                "title": "python-3-topological-sort-hashmap",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        par = {} # keep track of parent nodes\\n        height = {} # height for each node\\n        \\n        def dfs(node, level):\\n            if not node:\\n                return\\n            height[node.val] = level\\n            if node.left:\\n                par[node.left.val] = node.val\\n                dfs(node.left, level+1)\\n            if node.right:\\n                par[node.right.val] = node.val\\n                dfs(node.right, level+1)\\n        \\n        dfs(root, 0)\\n        \\n        # Topological sort\\n        deg = defaultdict(int)\\n        for k in par:\\n            deg[par[k]] += 1\\n        # starts from leaf nodes    \\n        q = [k for k in height if not deg[k]]\\n        h = height.copy() # propagate depth to parent nodes\\n            \\n        while q:\\n            cur = q.pop()\\n            if cur not in par: continue\\n            p = par[cur]\\n            deg[p] -= 1\\n            h[p] = max(h[p], h[cur])\\n            if not deg[p]:\\n                q.append(p)\\n        \\n        # for each level, only store top 2 nodes with deepest path\\n        h_node = defaultdict(list)\\n        for k in height:\\n            heappush(h_node[height[k]], (h[k], k))\\n            if len(h_node[height[k]]) > 2:\\n                heappop(h_node[height[k]])\\n        \\n        \\n        ans = []\\n        for q in queries:\\n            # if current level only one node then whole level gone, the height will minus 1\\n            if len(h_node[height[q]]) == 1:\\n                ans.append(height[q] - 1)\\n            # if deleted node equals the node with deepest path at current level, then chose the second deepest\\n            elif q == h_node[height[q]][1][1]:\\n                ans.append(h_node[height[q]][0][0])\\n            # otherwise select the top one\\n            else:\\n                ans.append(h_node[height[q]][1][0])\\n\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Topological Sort"
                ],
                "code": "class Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        par = {}",
                "codeTag": "Java"
            },
            {
                "id": 2759073,
                "title": "cpp-simple-clean-solution",
                "content": "**CPP Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    map<int,pair<int,int>> mp;\\n    map<int,priority_queue<pair<int,int>,vector<pair<int,int>>>> lv;\\n    int create(TreeNode *root,int level){\\n        if(!root) return 0;\\n        int l =0,r = 0;\\n        if(root->left) {\\n            l = create(root->left,level+1);\\n        }\\n        if(root->right) {\\n            r = create(root->right,level+1);\\n        }\\n        mp[root->val] = {max(l,r)+1,level};\\n        lv[level].push({max(l,r)+1,root->val});\\n        return max(l,r)+1;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        create(root,0);\\n        vector<int> res;\\n        for(int q : queries){\\n            int l = mp[q].second;\\n            int h = mp[q].first;\\n            int maxH = 0;\\n            if(lv[l].top().second != q){\\n                res.push_back(l+lv[l].top().first-1);\\n            }else if(lv[l].size() == 1){\\n                res.push_back(l-1);\\n            }else{\\n                pair<int,int> tp = lv[l].top();\\n                lv[l].pop();\\n                res.push_back(l+lv[l].top().first-1);\\n                lv[l].push(tp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,pair<int,int>> mp;\\n    map<int,priority_queue<pair<int,int>,vector<pair<int,int>>>> lv;\\n    int create(TreeNode *root,int level){\\n        if(!root) return 0;\\n        int l =0,r = 0;\\n        if(root->left) {\\n            l = create(root->left,level+1);\\n        }\\n        if(root->right) {\\n            r = create(root->right,level+1);\\n        }\\n        mp[root->val] = {max(l,r)+1,level};\\n        lv[level].push({max(l,r)+1,root->val});\\n        return max(l,r)+1;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        create(root,0);\\n        vector<int> res;\\n        for(int q : queries){\\n            int l = mp[q].second;\\n            int h = mp[q].first;\\n            int maxH = 0;\\n            if(lv[l].top().second != q){\\n                res.push_back(l+lv[l].top().first-1);\\n            }else if(lv[l].size() == 1){\\n                res.push_back(l-1);\\n            }else{\\n                pair<int,int> tp = lv[l].top();\\n                lv[l].pop();\\n                res.push_back(l+lv[l].top().first-1);\\n                lv[l].push(tp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758642,
                "title": "dfs-in-and-out-timers-binary-search-c-comments",
                "content": "```\\nusing pii = pair<int,int>;\\n\\nclass Solution {\\npublic:\\n    // in out time pairs at particular depth\\n    vector<pii> g[100005];\\n    \\n    int in[100005];\\n    int out[100005];\\n    int timer = 0;\\n    \\n    // Max Depth Overall\\n    int mx;\\n\\n    \\n    // Calculating in out times for each vertex\\n    // postorder assignment\\n    void dfs(TreeNode* root, int depth)\\n    {\\n        if(root == nullptr)return;\\n        \\n        in[root -> val] = timer++;\\n\\n        dfs(root -> left,depth + 1);\\n        dfs(root -> right, depth + 1);\\n\\n        out[root -> val] = timer++;\\n\\n        g[depth].push_back({in[root -> val], out[root -> val]});\\n        mx = max(mx,depth);\\n    }\\n\\n    // check for particular height\\n    int check(int mid, int src)\\n    {\\n        if(g[mid].size() == 0) return 0;\\n\\n        // check if first vertex don\\'t lie in subtree of src\\n        if(!(g[mid][0].first >= in[src] && g[mid][0].second <= out[src])) return 1;\\n\\n        // check if last vertex don\\'t lies in subtree of src\\n\\t\\t// Checking first and last is sufficient becase other middle vartices are in range of timings\\n        if(!(g[mid].back().first >= in[src] && g[mid].back().second <= out[src])) return 1;\\n\\n\\n        return 0;\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n\\n        for(int i=0;i;i++)\\n        {\\n            if(g[i].size() == 0)break;\\n            g[i].clear();\\n        }\\n\\n        // resetting \\n        timer = 0;\\n        mx = 0;\\n        dfs(root,0);\\n        \\n        \\n        vector<int> ans;\\n\\n        for(int q:queries)\\n        {\\n            int lo = 0;\\n            int hi = mx;\\n            int h = 1;\\n\\n            while(lo <= hi)\\n            {\\n                int mid = (lo + hi) / 2;\\n\\n                if(check(mid,q))\\n                {\\n                    h = mid;\\n                    lo = mid + 1;\\n                }\\n                else\\n                {\\n                    hi = mid - 1;\\n                }\\n            }\\n\\n            ans.push_back(h);\\n        }\\n\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    // in out time pairs at particular depth\\n    vector<pii> g[100005];\\n    \\n    int in[100005];\\n    int out[100005];\\n    int timer = 0;\\n    \\n    // Max Depth Overall\\n    int mx;\\n\\n    \\n    // Calculating in out times for each vertex\\n    // postorder assignment\\n    void dfs(TreeNode* root, int depth)\\n    {\\n        if(root == nullptr)return;\\n        \\n        in[root -> val] = timer++;\\n\\n        dfs(root -> left,depth + 1);\\n        dfs(root -> right, depth + 1);\\n\\n        out[root -> val] = timer++;\\n\\n        g[depth].push_back({in[root -> val], out[root -> val]}",
                "codeTag": "Java"
            },
            {
                "id": 2758363,
                "title": "euler-tour-bfs-prefix-and-suffix-maximum",
                "content": "1. Converting the entire tree in adjacency list for euler Tour of the tree.\\n2.  Euler tour arranges all the nodes of the subtree in (in and out order)\\n3.  Storing the in and out time of each node.\\n4.  Assigned each node their respective distance from root\\n5.  **Answer: max(Prefix_maximum[0,start-1],suffix_maximum[f+1,end])**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        queue<TreeNode*>q;\\n        vector<int>d(100005, 0); // distance of every node from root\\n        q.push(root);\\n        int r = root->val;\\n        d[r - 1] = 1;\\n        int cnt = 1;\\n        int y = 1;\\n        vector<int>adj[100005]; // constructing a tree for euler tour\\n        {\\n            while (!q.empty())\\n            {\\n                int x = q.size();\\n                y++;\\n                while (x--)\\n                {\\n                    auto p = q.front();\\n                    q.pop();\\n                    if (p->left)\\n                    {\\n                        d[p->left->val - 1] = y;\\n                        adj[p->val - 1].push_back(p->left->val - 1);\\n                        q.push(p->left);\\n                        cnt++;\\n                    }\\n                    if (p->right)\\n                    {\\n                        adj[p->val - 1].push_back(p->right->val - 1);\\n                        d[p->right->val - 1] = y;\\n                        q.push(p->right);\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        vector<int>s; // For storing vertices in euler tour\\n\\n        function<int(int)>dfs = [&](int root)\\n        {\\n            s.push_back(root);\\n            if (adj[root].size() == 0)\\n                return root;\\n\\n            for (int i = 0; i < adj[root].size(); i++) {\\n                int temp = dfs(adj[root][i]);\\n                s.push_back(temp);\\n            }\\n            return root;\\n        };\\n        int temp = dfs(r - 1);\\n        s.push_back(temp);\\n\\n\\n        vector<pair<int, int>> p; // storing in and out time for each node\\n\\n        for (int i = 0; i < 100000 + 5; i++)\\n            p.push_back(make_pair(0, 0));\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (p[s[i]].first == 0)\\n                p[s[i]].first = i + 1;\\n            else\\n                p[s[i]].second = i + 1;\\n        }\\n\\n\\n        vector<int>zz(s.size()); // assigning each node their distance from root\\n        vector<int>pref(s.size()); // Prefix maximum\\n        vector<int>suff(s.size()); //Suffix maximum\\n\\n\\n        // assigning each node their distance from root\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            zz[i] = d[s[i]];\\n        }\\n\\n\\n        // Prefix maximum\\n        pref[0] = zz[0];\\n        for (int i = 1; i < s.size(); i++)\\n        {\\n            pref[i] = max(pref[i - 1], zz[i]);\\n        }\\n\\n        //Suffix maximum\\n        suff[s.size() - 1] = zz[s.size() - 1];\\n        for (int i = s.size() - 2; i >= 0; i--)\\n        {\\n            suff[i] = max(suff[i + 1], zz[i]);\\n        }\\n\\n\\n        vector<int>ans;\\n\\n        for (int i = 0; i < queries.size(); i++)\\n        {\\n            int node = queries[i] - 1;\\n            int e = p[node].first - 1;\\n            int f = p[node].second - 1;\\n            // [e,f] represent in and out time for all node of subtree rooted at node\\n            int y = 0;\\n            y = pref[e - 1]; // max from 0,e-1\\n\\n            y = max(y, suff[f + 1]); // max from f+1,end\\n            ans.push_back(y - 1); // y-1 : Taking root\\'s height as zero\\n        }\\n\\n\\n\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        queue<TreeNode*>q;\\n        vector<int>d(100005, 0); // distance of every node from root\\n        q.push(root);\\n        int r = root->val;\\n        d[r - 1] = 1;\\n        int cnt = 1;\\n        int y = 1;\\n        vector<int>adj[100005]; // constructing a tree for euler tour\\n        {\\n            while (!q.empty())\\n            {\\n                int x = q.size();\\n                y++;\\n                while (x--)\\n                {\\n                    auto p = q.front();\\n                    q.pop();\\n                    if (p->left)\\n                    {\\n                        d[p->left->val - 1] = y;\\n                        adj[p->val - 1].push_back(p->left->val - 1);\\n                        q.push(p->left);\\n                        cnt++;\\n                    }\\n                    if (p->right)\\n                    {\\n                        adj[p->val - 1].push_back(p->right->val - 1);\\n                        d[p->right->val - 1] = y;\\n                        q.push(p->right);\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        vector<int>s; // For storing vertices in euler tour\\n\\n        function<int(int)>dfs = [&](int root)\\n        {\\n            s.push_back(root);\\n            if (adj[root].size() == 0)\\n                return root;\\n\\n            for (int i = 0; i < adj[root].size(); i++) {\\n                int temp = dfs(adj[root][i]);\\n                s.push_back(temp);\\n            }\\n            return root;\\n        };\\n        int temp = dfs(r - 1);\\n        s.push_back(temp);\\n\\n\\n        vector<pair<int, int>> p; // storing in and out time for each node\\n\\n        for (int i = 0; i < 100000 + 5; i++)\\n            p.push_back(make_pair(0, 0));\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (p[s[i]].first == 0)\\n                p[s[i]].first = i + 1;\\n            else\\n                p[s[i]].second = i + 1;\\n        }\\n\\n\\n        vector<int>zz(s.size()); // assigning each node their distance from root\\n        vector<int>pref(s.size()); // Prefix maximum\\n        vector<int>suff(s.size()); //Suffix maximum\\n\\n\\n        // assigning each node their distance from root\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            zz[i] = d[s[i]];\\n        }\\n\\n\\n        // Prefix maximum\\n        pref[0] = zz[0];\\n        for (int i = 1; i < s.size(); i++)\\n        {\\n            pref[i] = max(pref[i - 1], zz[i]);\\n        }\\n\\n        //Suffix maximum\\n        suff[s.size() - 1] = zz[s.size() - 1];\\n        for (int i = s.size() - 2; i >= 0; i--)\\n        {\\n            suff[i] = max(suff[i + 1], zz[i]);\\n        }\\n\\n\\n        vector<int>ans;\\n\\n        for (int i = 0; i < queries.size(); i++)\\n        {\\n            int node = queries[i] - 1;\\n            int e = p[node].first - 1;\\n            int f = p[node].second - 1;\\n            // [e,f] represent in and out time for all node of subtree rooted at node\\n            int y = 0;\\n            y = pref[e - 1]; // max from 0,e-1\\n\\n            y = max(y, suff[f + 1]); // max from f+1,end\\n            ans.push_back(y - 1); // y-1 : Taking root\\'s height as zero\\n        }\\n\\n\\n\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073622,
                "title": "dfs-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  unordered_map<int,int>height;\\n  unordered_map<int,int>ans;\\n    \\n  int solve(TreeNode*root){\\n        \\n      if(!root)return 0;\\n      if(!root->left && !root->right){\\n          height[root->val]=1;\\n          return 1;\\n      }\\n      \\n      int l=solve(root->left);\\n      int r=solve(root->right);\\n      \\n      height[root->val]=max(l,r)+1;\\n      return height[root->val];\\n      \\n    }\\n    \\n    void dfs(TreeNode*root,int depth,int curr){\\n        \\n        if(!root)return;\\n        \\n        if(root->right){\\n            int c=curr;\\n            if(root->left){\\n                c=max(c,height[root->left->val]+depth+1);\\n            }else{\\n                c=max(c,depth+1);\\n            }\\n            ans[root->right->val]=c;\\n            dfs(root->right,depth+1,c);\\n            \\n        }\\n        \\n        if(root->left){\\n            int c=curr;\\n            if(root->right){\\n                c=max(c,height[root->right->val]+depth+1);\\n            }else{\\n                c=max(c,depth+1);\\n            }\\n            ans[root->left->val]=c;\\n            dfs(root->left,depth+1,c);\\n        }\\n        \\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& q) {\\n       \\n        solve(root);\\n        dfs(root,0,1);\\n        vector<int>arr;\\n        for(int i=0;i<q.size();i++){\\n            arr.push_back(ans[q[i]]-1);\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n  unordered_map<int,int>height;\\n  unordered_map<int,int>ans;\\n    \\n  int solve(TreeNode*root){\\n        \\n      if(!root)return 0;\\n      if(!root->left && !root->right){\\n          height[root->val]=1;\\n          return 1;\\n      }\\n      \\n      int l=solve(root->left);\\n      int r=solve(root->right);\\n      \\n      height[root->val]=max(l,r)+1;\\n      return height[root->val];\\n      \\n    }\\n    \\n    void dfs(TreeNode*root,int depth,int curr){\\n        \\n        if(!root)return;\\n        \\n        if(root->right){\\n            int c=curr;\\n            if(root->left){\\n                c=max(c,height[root->left->val]+depth+1);\\n            }else{\\n                c=max(c,depth+1);\\n            }\\n            ans[root->right->val]=c;\\n            dfs(root->right,depth+1,c);\\n            \\n        }\\n        \\n        if(root->left){\\n            int c=curr;\\n            if(root->right){\\n                c=max(c,height[root->right->val]+depth+1);\\n            }else{\\n                c=max(c,depth+1);\\n            }\\n            ans[root->left->val]=c;\\n            dfs(root->left,depth+1,c);\\n        }\\n        \\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& q) {\\n       \\n        solve(root);\\n        dfs(root,0,1);\\n        vector<int>arr;\\n        for(int i=0;i<q.size();i++){\\n            arr.push_back(ans[q[i]]-1);\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057216,
                "title": "dfs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthree steps:\\n1. build 3 dictionary: node->depth, node->height, depth->list(node, height)\\n2. given a query node, find all other nodes of the same depth\\n3. search the other node with max height, return cur_depth + max_height\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        node2depth, node2height = defaultdict(int), defaultdict(int)\\n        depth2heights = defaultdict(list) # all the heights of nodes who\\'s depth is d\\n\\n        def get_height(root, depth):\\n            if not root:\\n                return -1\\n\\n            # set node2depth\\n            node2depth[root.val] = depth\\n\\n            # set node2height\\n            cur_height = max(get_height(root.left, depth+1), get_height(root.right, depth+1)) + 1\\n            node2height[root.val] = cur_height\\n\\n            # set depth2heights\\n            depth2heights[depth].append((cur_height, root.val))\\n            return cur_height \\n\\n        get_height(root, 0)\\n        \\n        # sort depth2height for all type\\n        for depth, heights in depth2heights.items():\\n            heights.sort(reverse=True)\\n\\n        # query\\n        res = []\\n        for val in queries:\\n            cur_depth = node2depth[val]\\n            cur_height = node2height[val]\\n            same_depth_nodes = depth2heights[cur_depth]\\n\\n            if len(same_depth_nodes) == 1:\\n                # case 1: \\n                res.append(cur_depth - 1)\\n            \\n            else:\\n                if same_depth_nodes[0][1] == val:\\n                    # case 2:\\n                    res.append(cur_depth + same_depth_nodes[1][0])\\n                else:\\n                    # case 3:\\n                    res.append(cur_depth + same_depth_nodes[0][0])\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        node2depth, node2height = defaultdict(int), defaultdict(int)\\n        depth2heights = defaultdict(list) # all the heights of nodes who\\'s depth is d\\n\\n        def get_height(root, depth):\\n            if not root:\\n                return -1\\n\\n            # set node2depth\\n            node2depth[root.val] = depth\\n\\n            # set node2height\\n            cur_height = max(get_height(root.left, depth+1), get_height(root.right, depth+1)) + 1\\n            node2height[root.val] = cur_height\\n\\n            # set depth2heights\\n            depth2heights[depth].append((cur_height, root.val))\\n            return cur_height \\n\\n        get_height(root, 0)\\n        \\n        # sort depth2height for all type\\n        for depth, heights in depth2heights.items():\\n            heights.sort(reverse=True)\\n\\n        # query\\n        res = []\\n        for val in queries:\\n            cur_depth = node2depth[val]\\n            cur_height = node2height[val]\\n            same_depth_nodes = depth2heights[cur_depth]\\n\\n            if len(same_depth_nodes) == 1:\\n                # case 1: \\n                res.append(cur_depth - 1)\\n            \\n            else:\\n                if same_depth_nodes[0][1] == val:\\n                    # case 2:\\n                    res.append(cur_depth + same_depth_nodes[1][0])\\n                else:\\n                    # case 3:\\n                    res.append(cur_depth + same_depth_nodes[0][0])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049326,
                "title": "java-with-explanation-one-time-dfs-beats-80-run-time-and-80-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First thing, we get height of each node. We have 2 options:\\n    a. store height of each node from leaf(leaf height = 0) OR\\n    b. store depth of each node from top(root depth = 0)\\n 2. Notice that if we do 1.a, once any subtree is deleted, all the heights above deleted subtree should change\\n 3. But if we do the depths , nothing changes once a subtree is deleted. So we are going to calculate depths\\n 4. How do we use the depth of each node now? Once we delete a subtree, height of tree is max depth of remaining nodes!!\\n 5. Now, we should be proceesing all queries in less run time. i.e not do dfs all over again\\n 6. Write the preorder traversal of the tree in list/array form. Each element in list/array is a Node object which has following info:\\n    a. root value\\n    b. start index and end index of the subtree where this node is the root\\n        - we determine ranges while doing dfs. first time when u see the node is start index and at the end of every recursion we know subtree of the current node ends. So thats the end index of this node\\'s subtree\\n    c. depth of the node as calculated in 1.b\\n 7. Now once we get a query to del, we just go to that node. See the range indices of the subtree in the array,\\n    return the max depth = Max{max depth from left of range, max depth from right of range}\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - for DFS on n nodes, to calculate the leftMaxDepth and rightMaxDepth\\nO(m) - To calculate answer for each of the m queries\\n\\nTotal: O(n+m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n + m)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        List<Node> list = new ArrayList<>();          // pre order list with all node info\\n        Map<Integer, Node> mapper = new HashMap<>();  // <root.val, Node> pairs\\n        dfs(root, 0, list, mapper);\\n\\n        // now have 2 arrays with max depth till running index - one from left, one from right\\n        int n = list.size();\\n        int[] leftMaxDepth = new int[n];\\n        int[] rightMaxDepth = new int[n];\\n        int max = -1;\\n        for(int i = 0; i < n; i++) {\\n            max = Math.max(max, list.get(i).depth);\\n            leftMaxDepth[i] = max;\\n        }\\n        max = -1;\\n        for(int j = n-1; j >= 0; j--) {\\n            max = Math.max(max, list.get(j).depth);\\n            rightMaxDepth[j] = max;\\n        }\\n\\n\\n        //process queries\\n        int[] ans = new int[queries.length];\\n        for(int i = 0; i < queries.length; i++) {\\n            Node node = mapper.get(queries[i]);\\n            int leftIndex = node.subTreeStart;\\n            int rightIndex = node.subTreeEnd;\\n\\n            // answer is max depth from left of the range and right of the range\\n            int lDepth = 0, rDepth = 0;\\n            if(leftIndex - 1 >= 0) lDepth = leftMaxDepth[leftIndex - 1];\\n            if(rightIndex + 1 < n) rDepth = rightMaxDepth[rightIndex + 1];\\n            ans[i] = Math.max(lDepth, rDepth);\\n        }\\n\\n        return ans;\\n    }\\n\\n    // dfs, add every node in preorder fashion to list with ranges of every node\\'s subtree. \\n    // Also adds to Map <Value, Node>\\n    private void dfs(TreeNode root, int depth, List<Node> list, Map<Integer, Node> mapper) {\\n        if(root == null) return;\\n\\n        Node n = new Node(root.val, depth);\\n        mapper.put(root.val, n);\\n        list.add(n);\\n\\n        n.subTreeStart = list.size() - 1;  //0 indexed\\n\\n        dfs(root.left, depth+1, list, mapper);\\n        dfs(root.right, depth+1, list, mapper);\\n\\n        n.subTreeEnd = list.size() - 1;\\n    }\\n\\n    class Node {\\n        int val;\\n        int depth;\\n        int subTreeStart;\\n        int subTreeEnd;\\n        Node(int val, int depth) {\\n            this.val = val;\\n            this.depth = depth;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        List<Node> list = new ArrayList<>();          // pre order list with all node info\\n        Map<Integer, Node> mapper = new HashMap<>();  // <root.val, Node> pairs\\n        dfs(root, 0, list, mapper);\\n\\n        // now have 2 arrays with max depth till running index - one from left, one from right\\n        int n = list.size();\\n        int[] leftMaxDepth = new int[n];\\n        int[] rightMaxDepth = new int[n];\\n        int max = -1;\\n        for(int i = 0; i < n; i++) {\\n            max = Math.max(max, list.get(i).depth);\\n            leftMaxDepth[i] = max;\\n        }\\n        max = -1;\\n        for(int j = n-1; j >= 0; j--) {\\n            max = Math.max(max, list.get(j).depth);\\n            rightMaxDepth[j] = max;\\n        }\\n\\n\\n        //process queries\\n        int[] ans = new int[queries.length];\\n        for(int i = 0; i < queries.length; i++) {\\n            Node node = mapper.get(queries[i]);\\n            int leftIndex = node.subTreeStart;\\n            int rightIndex = node.subTreeEnd;\\n\\n            // answer is max depth from left of the range and right of the range\\n            int lDepth = 0, rDepth = 0;\\n            if(leftIndex - 1 >= 0) lDepth = leftMaxDepth[leftIndex - 1];\\n            if(rightIndex + 1 < n) rDepth = rightMaxDepth[rightIndex + 1];\\n            ans[i] = Math.max(lDepth, rDepth);\\n        }\\n\\n        return ans;\\n    }\\n\\n    // dfs, add every node in preorder fashion to list with ranges of every node\\'s subtree. \\n    // Also adds to Map <Value, Node>\\n    private void dfs(TreeNode root, int depth, List<Node> list, Map<Integer, Node> mapper) {\\n        if(root == null) return;\\n\\n        Node n = new Node(root.val, depth);\\n        mapper.put(root.val, n);\\n        list.add(n);\\n\\n        n.subTreeStart = list.size() - 1;  //0 indexed\\n\\n        dfs(root.left, depth+1, list, mapper);\\n        dfs(root.right, depth+1, list, mapper);\\n\\n        n.subTreeEnd = list.size() - 1;\\n    }\\n\\n    class Node {\\n        int val;\\n        int depth;\\n        int subTreeStart;\\n        int subTreeEnd;\\n        Node(int val, int depth) {\\n            this.val = val;\\n            this.depth = depth;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044370,
                "title": "screw-dfs-descent-along-the-original-longest-path-and-precompute-result",
                "content": "Originally I solved the problem by pre-computing depth of each node and then looked at what happens if particular node is removed. Turns out there is a simpler way to think about this problem.\\nI found ideas on the forum, but I realised that my original approach I took is part of the optimal solution. I am also not a fan of one-liners, since they are pointless on the forum where people are looking for explanations, so here is my take.\\n\\nFirst, notice that given a node in the original longest path, only left or right child will contribute to that path, but not both. Meaning that if any node is removed from alternative path, it does not affect original root height. In other words, by default, removing a node in alternative path changes nothing. The original root height will only chage when we remove a node from the longest path.\\n\\nWhy don\\'t we travel along the longest path and see what happens when node is removed? The new root hight will be second best longest path in the tree! Turns out we can track this second best path while we decent the original root height path. We simply need to know depth of alternative subtree in each node, and the level of the current node (number of levels to get back to the root). The alternative height of the root is just a sum of these two numbers. We just need to keep track of best alternative path until now, since all the nodes that we already visisted stay and not affected by removal of the current node\\n\\n```\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        nodeDepth = {None: -1}\\n        \\n        # find depth for each node\\n        def computeDepth(node):\\n            if not node: return 0\\n            maxDepth = max(computeDepth(node.left), computeDepth(node.right))\\n            nodeDepth[node] = maxDepth\\n            return maxDepth + 1\\n        computeDepth(root)\\n              \\n        # travel the longest path and store alternative best root height if node is removed\\n        result = defaultdict(lambda: nodeDepth[root])\\n        def precompute(node, level, secondBestHeight):\\n            if not node: return\\n            \\n\\t\\t\\t# new height of root if this node is removed. We ue second best height\\n            result[node.val] = secondBestHeight \\n\\t\\t\\t\\n\\t\\t\\t# Descend along the original longest path\\n            if nodeDepth[node.left] > nodeDepth[node.right]:\\n                newSecondBestHeight = level + nodeDepth[node.right] + 1\\n                precompute(node.left, level + 1, max(newSecondBestHeight, secondBestHeight))\\n            else:\\n                newSecondBestHeight = level + nodeDepth[node.left] + 1\\n                precompute(node.right, level + 1, max(newSecondBestHeight, secondBestHeight))\\n            \\n        precompute(root, level=0, secondBestHeight=0)\\n  \\n        return [result[query] for query in queries]\\n```",
                "solutionTags": [],
                "code": "```\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        nodeDepth = {None: -1}\\n        \\n        # find depth for each node\\n        def computeDepth(node):\\n            if not node: return 0\\n            maxDepth = max(computeDepth(node.left), computeDepth(node.right))\\n            nodeDepth[node] = maxDepth\\n            return maxDepth + 1\\n        computeDepth(root)\\n              \\n        # travel the longest path and store alternative best root height if node is removed\\n        result = defaultdict(lambda: nodeDepth[root])\\n        def precompute(node, level, secondBestHeight):\\n            if not node: return\\n            \\n\\t\\t\\t# new height of root if this node is removed. We ue second best height\\n            result[node.val] = secondBestHeight \\n\\t\\t\\t\\n\\t\\t\\t# Descend along the original longest path\\n            if nodeDepth[node.left] > nodeDepth[node.right]:\\n                newSecondBestHeight = level + nodeDepth[node.right] + 1\\n                precompute(node.left, level + 1, max(newSecondBestHeight, secondBestHeight))\\n            else:\\n                newSecondBestHeight = level + nodeDepth[node.left] + 1\\n                precompute(node.right, level + 1, max(newSecondBestHeight, secondBestHeight))\\n            \\n        precompute(root, level=0, secondBestHeight=0)\\n  \\n        return [result[query] for query in queries]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4032483,
                "title": "python-easy-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nStore the answers for every node. The answer for any node would be the depth till now plus the height of the complementary tree (right tree if node is left, and vice versa)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        \\n        @cache\\n        def height(node):\\n            return 0 if not node else 1 + max(height(node.left), height(node.right))\\n        \\n        answer = {}\\n        \\n        def dfs(node, depth, remaining_tree_height_after_current_node_removal):\\n            if not node: return\\n            answer[node.val] = remaining_tree_height_after_current_node_removal\\n            dfs(node.left, depth + 1, max(remaining_tree_height_after_current_node_removal, depth + height(node.right)))\\n            dfs(node.right, depth + 1, max(remaining_tree_height_after_current_node_removal, depth + height(node.left)))\\n\\n        dfs(root, 0, 0)\\n        return map(answer.get, queries)\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        \\n        @cache\\n        def height(node):\\n            return 0 if not node else 1 + max(height(node.left), height(node.right))\\n        \\n        answer = {}\\n        \\n        def dfs(node, depth, remaining_tree_height_after_current_node_removal):\\n            if not node: return\\n            answer[node.val] = remaining_tree_height_after_current_node_removal\\n            dfs(node.left, depth + 1, max(remaining_tree_height_after_current_node_removal, depth + height(node.right)))\\n            dfs(node.right, depth + 1, max(remaining_tree_height_after_current_node_removal, depth + height(node.left)))\\n\\n        dfs(root, 0, 0)\\n        return map(answer.get, queries)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026856,
                "title": "lessons-learned",
                "content": "**Code**:\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    /*\\n    map: level - nodeValueList\\n    map: nodeValue - level\\n    map: nodeValue - height\\n    \\n    */\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        \\n        Map<Integer, Integer> nodeValueHeightMap = new HashMap<>();\\n        dfs(root, nodeValueHeightMap);\\n        \\n        Map<Integer, Integer> nodeValueLevelMap = new HashMap<>();\\n        Map<Integer, Queue<Integer>> levelNodeValuesMap = new HashMap<>();\\n        bfs(root, nodeValueLevelMap, levelNodeValuesMap, nodeValueHeightMap);\\n        \\n        int i = 0;\\n        int[] ans = new int[queries.length];\\n        for (int val : queries) {\\n            System.out.println(\"val = \" + val);\\n            int max = 0;\\n            int level = nodeValueLevelMap.get(val);\\n            \\n            Queue<Integer> sameLevelNodes = levelNodeValuesMap.get(level);\\n            // System.out.println(\"sameLevelNodes.size() = \" + sameLevelNodes.size());\\n            // EDGE CASE: NO COUSIN SCENARIO\\n            if (sameLevelNodes.size() == 1) {\\n                ans[i++] = level - 1;\\n                continue;\\n            }\\n            for (int sameLevelNode : sameLevelNodes) {\\n                // System.out.println(\"sameLevelNode = \" + sameLevelNode);\\n                if (sameLevelNode == val) continue;\\n                int sameLevelNodeLevel = nodeValueLevelMap.get(sameLevelNode);\\n                int sameLevelNodeHeight = nodeValueHeightMap.get(sameLevelNode);\\n                int routeHeight = sameLevelNodeLevel + sameLevelNodeHeight;\\n                max = Math.max(max, routeHeight);\\n            }\\n            ans[i++] = max;\\n        }\\n        return ans;\\n    }\\n    \\n    private void bfs(TreeNode root, Map<Integer, Integer> nodeValueLevelMap, Map<Integer, Queue<Integer>> levelNodeValuesMap, Map<Integer, Integer> nodeValueHeightMap) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        int level = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                TreeNode node = queue.remove();\\n                int val = node.val;\\n                nodeValueLevelMap.put(val, level);\\n                \\n                // OPTIMIZATION: Without leveraging PriorityQueue of capacity 2 (used ArrayList earlier), submission gives TLE\\n                Queue<Integer> nodeValues = levelNodeValuesMap.getOrDefault(level, new PriorityQueue<>((a, b) -> nodeValueHeightMap.get(a) - nodeValueHeightMap.get(b)));\\n                nodeValues.add(val);\\n                if (nodeValues.size() > 2) nodeValues.poll();\\n                \\n                levelNodeValuesMap.put(level, nodeValues);\\n                if (node.left != null) queue.add(node.left);\\n                if (node.right != null) queue.add(node.right);\\n            }\\n            ++level;\\n        }\\n    }\\n    \\n    private int dfs(TreeNode node, Map<Integer, Integer> nodeValueHeightMap) {\\n        if (node == null) return 0;\\n        int left = dfs(node.left, nodeValueHeightMap);\\n        int right = dfs(node.right, nodeValueHeightMap);\\n        int height = Math.max(left, right);\\n        nodeValueHeightMap.put(node.val, height);\\n        return height + 1;\\n    }\\n    \\n}\\n\\n/*\\n\\n    1\\n  -     5\\n       3  -   \\n      2  4\\n*/\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    /*\\n    map: level - nodeValueList\\n    map: nodeValue - level\\n    map: nodeValue - height\\n    \\n    */\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        \\n        Map<Integer, Integer> nodeValueHeightMap = new HashMap<>();\\n        dfs(root, nodeValueHeightMap);\\n        \\n        Map<Integer, Integer> nodeValueLevelMap = new HashMap<>();\\n        Map<Integer, Queue<Integer>> levelNodeValuesMap = new HashMap<>();\\n        bfs(root, nodeValueLevelMap, levelNodeValuesMap, nodeValueHeightMap);\\n        \\n        int i = 0;\\n        int[] ans = new int[queries.length];\\n        for (int val : queries) {\\n            System.out.println(\"val = \" + val);\\n            int max = 0;\\n            int level = nodeValueLevelMap.get(val);\\n            \\n            Queue<Integer> sameLevelNodes = levelNodeValuesMap.get(level);\\n            // System.out.println(\"sameLevelNodes.size() = \" + sameLevelNodes.size());\\n            // EDGE CASE: NO COUSIN SCENARIO\\n            if (sameLevelNodes.size() == 1) {\\n                ans[i++] = level - 1;\\n                continue;\\n            }\\n            for (int sameLevelNode : sameLevelNodes) {\\n                // System.out.println(\"sameLevelNode = \" + sameLevelNode);\\n                if (sameLevelNode == val) continue;\\n                int sameLevelNodeLevel = nodeValueLevelMap.get(sameLevelNode);\\n                int sameLevelNodeHeight = nodeValueHeightMap.get(sameLevelNode);\\n                int routeHeight = sameLevelNodeLevel + sameLevelNodeHeight;\\n                max = Math.max(max, routeHeight);\\n            }\\n            ans[i++] = max;\\n        }\\n        return ans;\\n    }\\n    \\n    private void bfs(TreeNode root, Map<Integer, Integer> nodeValueLevelMap, Map<Integer, Queue<Integer>> levelNodeValuesMap, Map<Integer, Integer> nodeValueHeightMap) {\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        int level = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                TreeNode node = queue.remove();\\n                int val = node.val;\\n                nodeValueLevelMap.put(val, level);\\n                \\n                // OPTIMIZATION: Without leveraging PriorityQueue of capacity 2 (used ArrayList earlier), submission gives TLE\\n                Queue<Integer> nodeValues = levelNodeValuesMap.getOrDefault(level, new PriorityQueue<>((a, b) -> nodeValueHeightMap.get(a) - nodeValueHeightMap.get(b)));\\n                nodeValues.add(val);\\n                if (nodeValues.size() > 2) nodeValues.poll();\\n                \\n                levelNodeValuesMap.put(level, nodeValues);\\n                if (node.left != null) queue.add(node.left);\\n                if (node.right != null) queue.add(node.right);\\n            }\\n            ++level;\\n        }\\n    }\\n    \\n    private int dfs(TreeNode node, Map<Integer, Integer> nodeValueHeightMap) {\\n        if (node == null) return 0;\\n        int left = dfs(node.left, nodeValueHeightMap);\\n        int right = dfs(node.right, nodeValueHeightMap);\\n        int height = Math.max(left, right);\\n        nodeValueHeightMap.put(node.val, height);\\n        return height + 1;\\n    }\\n    \\n}\\n\\n/*\\n\\n    1\\n  -     5\\n       3  -   \\n      2  4\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011849,
                "title": "python-o-n-solution-for-people-who-dont-have-an-iq-of-400",
                "content": "# Intuition\\nRather than doing an O(N) traversal of the whole tree for each query, we want to pre-compute the results somehow. Pre-computing things is a pretty common approach in Leetcode \\'query\\' questions.\\n\\nWe can pre compute the result for each node X by recording the maximum depth of the entire tree when X and none of its children are not in the tree.\\n\\n# Approach\\nWhen we encounter a node in an in-order traversal from left to right, we have not encountered the node or any of its children before, so the maximum depth of any tree we have found so far in the traversal is a potential answer for this node, however this doesn\\'t include paths further on in the traversal that don\\'t include this node, so we need to do it again but from right to left.\\n\\nSo we traverse the tree from left to right, keeping track of the maximum depth we have found so far in a variable on the object, and when we encounter a new node we set the potential answer for this node to be the current maximum depth we have found. We also update the current maximum depth if we need to.\\n\\nAs mentioned before, the answer we have recorded for a node X doesn\\'t current include potential sub-trees further right of the nodes ancestors, so the answers might not all be correct yet.\\n\\nSo we do the same thing again, but from right to left, and if the maximum current depth we find at a node X is higher than the one we found during the left traversal, then we set the answer for the node X to the current maximum depth we found on this traversal instead.\\n\\n# Complexity\\n2 x 0(N) traversals = O(N)\\n\\n- Space complexity:\\nO(N) (dictionary of all node values to their answer)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def set_values_from_left(self, root, depth=0):\\n        if not root:\\n            return\\n\\n        self.best_other_depths[root.val] = max(self.best_other_depths[root.val], self.current_max_depth)\\n\\n        self.current_max_depth = max(self.current_max_depth, depth)\\n\\n        self.set_values_from_left(root.left, depth+1)\\n        self.set_values_from_left(root.right, depth+1)\\n\\n    def set_values_from_right(self, root, depth=0):\\n        if not root:\\n            return\\n\\n        self.best_other_depths[root.val] = max(self.best_other_depths[root.val], self.current_max_depth)\\n\\n        self.current_max_depth = max(self.current_max_depth, depth)\\n\\n        self.set_values_from_right(root.right, depth+1)\\n        self.set_values_from_right(root.left, depth+1)\\n\\n\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        self.best_other_depths = defaultdict(int)\\n\\n        self.current_max_depth = 0\\n        self.set_values_from_left(root)\\n        self.current_max_depth = 0\\n        self.set_values_from_right(root)\\n\\n        return [self.best_other_depths[q] for q in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def set_values_from_left(self, root, depth=0):\\n        if not root:\\n            return\\n\\n        self.best_other_depths[root.val] = max(self.best_other_depths[root.val], self.current_max_depth)\\n\\n        self.current_max_depth = max(self.current_max_depth, depth)\\n\\n        self.set_values_from_left(root.left, depth+1)\\n        self.set_values_from_left(root.right, depth+1)\\n\\n    def set_values_from_right(self, root, depth=0):\\n        if not root:\\n            return\\n\\n        self.best_other_depths[root.val] = max(self.best_other_depths[root.val], self.current_max_depth)\\n\\n        self.current_max_depth = max(self.current_max_depth, depth)\\n\\n        self.set_values_from_right(root.right, depth+1)\\n        self.set_values_from_right(root.left, depth+1)\\n\\n\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        self.best_other_depths = defaultdict(int)\\n\\n        self.current_max_depth = 0\\n        self.set_values_from_left(root)\\n        self.current_max_depth = 0\\n        self.set_values_from_right(root)\\n\\n        return [self.best_other_depths[q] for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011139,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int, int >l ,r , x ;\\n    \\n    int cal(TreeNode* root )\\n    {\\n        if(root==NULL)\\n            return 0 ;\\n        \\n        int ll = cal(root->left ); \\n        int rr = cal(root->right ) ; \\n        \\n        l[root->val] = ll ; \\n        r[root->val] =rr ;\\n        \\n        return 1 + max(ll, rr ) ;\\n    }\\n    \\n   void dfs(TreeNode* root, int maxi , int depth )\\n    {\\n        \\n        if(root==NULL)\\n            return ; \\n       \\n       x[root->val] = maxi ; \\n        \\n       dfs(root->left , max(maxi , depth+r[root->val]), depth+1); \\n        dfs(root->right , max(maxi , depth+l[root->val ]), depth+1 ) ; \\n        \\n        \\n        \\n        \\n    }\\n    \\n        \\n        \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int> ans ; \\n        \\n        cal(root ) ;\\n        \\n        dfs(root->left  , r[root->val] , 1 ) ; \\n        dfs(root->right  , l[root->val] , 1 ) ; \\n\\n        \\n        for(auto it :queries )\\n        {\\n            ans.push_back(x[it]) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, int >l ,r , x ;\\n    \\n    int cal(TreeNode* root )\\n    {\\n        if(root==NULL)\\n            return 0 ;\\n        \\n        int ll = cal(root->left ); \\n        int rr = cal(root->right ) ; \\n        \\n        l[root->val] = ll ; \\n        r[root->val] =rr ;\\n        \\n        return 1 + max(ll, rr ) ;\\n    }\\n    \\n   void dfs(TreeNode* root, int maxi , int depth )\\n    {\\n        \\n        if(root==NULL)\\n            return ; \\n       \\n       x[root->val] = maxi ; \\n        \\n       dfs(root->left , max(maxi , depth+r[root->val]), depth+1); \\n        dfs(root->right , max(maxi , depth+l[root->val ]), depth+1 ) ; \\n        \\n        \\n        \\n        \\n    }\\n    \\n        \\n        \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int> ans ; \\n        \\n        cal(root ) ;\\n        \\n        dfs(root->left  , r[root->val] , 1 ) ; \\n        dfs(root->right  , l[root->val] , 1 ) ; \\n\\n        \\n        for(auto it :queries )\\n        {\\n            ans.push_back(x[it]) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008843,
                "title": "2458-height-of-binary-tree-after-subtree-removal-queries",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    //create three hash map for left, right and removed subtree\\n    private Map<Integer,Integer> left = new HashMap<>();\\n    private Map<Integer,Integer> right = new HashMap<>();\\n    private Map<Integer,Integer> removedSubtree = new HashMap<>();\\n    \\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n    \\n    calculateHeight(root,0);\\n    calculateRemovedHeight(root,0);\\n\\n    int[] result = new int[queries.length];\\n    for(int i=0; i<queries.length; i++)\\n    {\\n        result[i] = removedSubtree.get(queries[i]);\\n    }\\n    return result;\\n    }\\n\\n    // calculate height of all values in tree\\n    public int calculateHeight(TreeNode root, int height){\\n    if(root==null){\\n        return height-1;\\n    }\\n    left.put(root.val, calculateHeight(root.left, height+1));\\n    right.put(root.val, calculateHeight(root.right, height+1));\\n    return Math.max(left.get(root.val),right.get(root.val));\\n    }\\n\\n    // calculate height of all values in tree after removal\\n    public void calculateRemovedHeight(TreeNode root, int height){\\n    if(root==null){\\n        return;\\n    } \\n    removedSubtree.put(root.val, height);\\n    calculateRemovedHeight(root.left, Math.max(height, right.get(root.val)));\\n    calculateRemovedHeight(root.right, Math.max(height, left.get(root.val)));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    //create three hash map for left, right and removed subtree\\n    private Map<Integer,Integer> left = new HashMap<>();\\n    private Map<Integer,Integer> right = new HashMap<>();\\n    private Map<Integer,Integer> removedSubtree = new HashMap<>();\\n    \\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n    \\n    calculateHeight(root,0);\\n    calculateRemovedHeight(root,0);\\n\\n    int[] result = new int[queries.length];\\n    for(int i=0; i<queries.length; i++)\\n    {\\n        result[i] = removedSubtree.get(queries[i]);\\n    }\\n    return result;\\n    }\\n\\n    // calculate height of all values in tree\\n    public int calculateHeight(TreeNode root, int height){\\n    if(root==null){\\n        return height-1;\\n    }\\n    left.put(root.val, calculateHeight(root.left, height+1));\\n    right.put(root.val, calculateHeight(root.right, height+1));\\n    return Math.max(left.get(root.val),right.get(root.val));\\n    }\\n\\n    // calculate height of all values in tree after removal\\n    public void calculateRemovedHeight(TreeNode root, int height){\\n    if(root==null){\\n        return;\\n    } \\n    removedSubtree.put(root.val, height);\\n    calculateRemovedHeight(root.left, Math.max(height, right.get(root.val)));\\n    calculateRemovedHeight(root.right, Math.max(height, left.get(root.val)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986618,
                "title": "dfs-o-n-m-c",
                "content": "# Intuition\\nTraverse binary tree pre-order and store depth of each node in a traversal array. Suppose that we are given a root of a subtree. If we knew the range of that subtree in the pre-order traversal, then hight of the resulting tree is maximum of all the elements to the left and the maximum of all the elements to the right in the traversal array when the subarray representing extent of the subtree is removed.\\n\\n# Approach\\nTraverse binary tree in pre-order and for each node store its subtree extent in the hash map for a quick lookup and store depth of the same node.\\n\\nTo quickly find maximum of the left subarray and right subarray that remains after removal, find two more arrays: all maximums when we scan depths from the left side and maximums when we scam depths from the right side. We can call them prefix_max and suffix_max. Then if we remove subarray depths[i, j], max depths[0, i-1], depths[j+1, n-1] is max of prefix_max[i-1] and suffix_max[j+1, n-1].\\n\\n# Complexity\\n- Time complexity:\\n$$O(n+m)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> h;\\n    vector<int> depths;\\n\\n    int dfs(TreeNode* node, int i, int d) {\\n        depths.push_back(d);\\n\\n        if (node->left == nullptr && node->right == nullptr) {\\n            h[node->val] = {i, i};\\n\\n            return i;\\n        }\\n\\n        int j = i;\\n\\n        if (node->left) {\\n            j = dfs(node->left, i + 1, d + 1);\\n        }\\n\\n        int k = j;\\n\\n        if (node->right) {\\n            k = dfs(node->right, j + 1, d + 1);\\n        }\\n\\n        h[node->val] = {i, k};\\n\\n        return k;\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        dfs(root, 0, 0);\\n        int n = depths.size();\\n        vector<int> prefix_max(n);\\n        vector<int> suffix_max(n);\\n\\n        prefix_max[0] = depths[0];\\n        suffix_max[n-1] = depths[n-1];\\n\\n        for (int i = 1, j = n - 2; i < n && j >= 0; i++, j--) {\\n            prefix_max[i] = max(prefix_max[i-1], depths[i]);\\n            suffix_max[j] = max(suffix_max[j+1], depths[j]);\\n        }\\n\\n        vector<int> result;\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            vector<int> v = h[queries[i]];\\n            int height = INT_MIN;\\n\\n            if (v[0] > 0) {\\n                height = max(height, prefix_max[v[0]-1]);\\n            }\\n\\n            if (v[1] < n - 1) {\\n                height = max(height, suffix_max[v[1]+1]);\\n            }\\n\\n            result.push_back(height);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> h;\\n    vector<int> depths;\\n\\n    int dfs(TreeNode* node, int i, int d) {\\n        depths.push_back(d);\\n\\n        if (node->left == nullptr && node->right == nullptr) {\\n            h[node->val] = {i, i};\\n\\n            return i;\\n        }\\n\\n        int j = i;\\n\\n        if (node->left) {\\n            j = dfs(node->left, i + 1, d + 1);\\n        }\\n\\n        int k = j;\\n\\n        if (node->right) {\\n            k = dfs(node->right, j + 1, d + 1);\\n        }\\n\\n        h[node->val] = {i, k};\\n\\n        return k;\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        dfs(root, 0, 0);\\n        int n = depths.size();\\n        vector<int> prefix_max(n);\\n        vector<int> suffix_max(n);\\n\\n        prefix_max[0] = depths[0];\\n        suffix_max[n-1] = depths[n-1];\\n\\n        for (int i = 1, j = n - 2; i < n && j >= 0; i++, j--) {\\n            prefix_max[i] = max(prefix_max[i-1], depths[i]);\\n            suffix_max[j] = max(suffix_max[j+1], depths[j]);\\n        }\\n\\n        vector<int> result;\\n\\n        for (int i = 0; i < queries.size(); i++) {\\n            vector<int> v = h[queries[i]];\\n            int height = INT_MIN;\\n\\n            if (v[0] > 0) {\\n                height = max(height, prefix_max[v[0]-1]);\\n            }\\n\\n            if (v[1] < n - 1) {\\n                height = max(height, suffix_max[v[1]+1]);\\n            }\\n\\n            result.push_back(height);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981397,
                "title": "just-euler-tour-c",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> depth;\\n    vector<int> euler;\\n    vector<int> st;\\n    vector<int> ed;\\n    int count(TreeNode* root){\\n        if(root==NULL) return 0;\\n        return 1+count(root->left)+count(root->right);\\n    }\\n    void depthoftree(TreeNode* root,int d){\\n        if(!root) return ;\\n        depth[root->val]=d;\\n        if(root->left) depthoftree(root->left,d+1);\\n        if(root->right) depthoftree(root->right,d+1);\\n    }\\n    void eulertour(TreeNode* root,int &timer){\\n        if(!root) return ;\\n        euler.push_back(root->val);\\n        st[root->val]=timer;\\n        if(root->left){\\n            timer++;\\n            eulertour(root->left,timer);\\n        }\\n        if(root->right){\\n            timer++;\\n            eulertour(root->right,timer);\\n        }\\n        ed[root->val]=timer;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int n=count(root);\\n        depth.resize(n+1);\\n        st.resize(n+1);\\n        ed.resize(n+1);\\n        depthoftree(root,0);\\n        int timer=0;\\n        eulertour(root,timer);\\n        for(int i=0;i<euler.size();i++){\\n            euler[i]=depth[euler[i]];\\n        }\\n        vector<int> pf(n+1),sf(n+1);\\n        pf[0]=euler[0];\\n        for(int i=1;i<n;i++) pf[i]=max(euler[i],pf[i-1]);\\n        sf[n-1]=euler[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            sf[i]=max(euler[i],sf[i+1]);\\n        }\\n        vector<int> ans;\\n        for(auto q:queries){\\n            int a=st[q],b=ed[q];\\n            if(a==0 and b==n-1){\\n                ans.push_back(0);\\n            }else if(a==0){\\n                int temp=sf[b+1];\\n                ans.push_back(temp);\\n            }else if(b==n-1){\\n                int temp=pf[a-1];\\n                ans.push_back(temp);\\n            }else{\\n                int temp=max(pf[a-1],sf[b+1]);\\n                ans.push_back(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> depth;\\n    vector<int> euler;\\n    vector<int> st;\\n    vector<int> ed;\\n    int count(TreeNode* root){\\n        if(root==NULL) return 0;\\n        return 1+count(root->left)+count(root->right);\\n    }\\n    void depthoftree(TreeNode* root,int d){\\n        if(!root) return ;\\n        depth[root->val]=d;\\n        if(root->left) depthoftree(root->left,d+1);\\n        if(root->right) depthoftree(root->right,d+1);\\n    }\\n    void eulertour(TreeNode* root,int &timer){\\n        if(!root) return ;\\n        euler.push_back(root->val);\\n        st[root->val]=timer;\\n        if(root->left){\\n            timer++;\\n            eulertour(root->left,timer);\\n        }\\n        if(root->right){\\n            timer++;\\n            eulertour(root->right,timer);\\n        }\\n        ed[root->val]=timer;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int n=count(root);\\n        depth.resize(n+1);\\n        st.resize(n+1);\\n        ed.resize(n+1);\\n        depthoftree(root,0);\\n        int timer=0;\\n        eulertour(root,timer);\\n        for(int i=0;i<euler.size();i++){\\n            euler[i]=depth[euler[i]];\\n        }\\n        vector<int> pf(n+1),sf(n+1);\\n        pf[0]=euler[0];\\n        for(int i=1;i<n;i++) pf[i]=max(euler[i],pf[i-1]);\\n        sf[n-1]=euler[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            sf[i]=max(euler[i],sf[i+1]);\\n        }\\n        vector<int> ans;\\n        for(auto q:queries){\\n            int a=st[q],b=ed[q];\\n            if(a==0 and b==n-1){\\n                ans.push_back(0);\\n            }else if(a==0){\\n                int temp=sf[b+1];\\n                ans.push_back(temp);\\n            }else if(b==n-1){\\n                int temp=pf[a-1];\\n                ans.push_back(temp);\\n            }else{\\n                int temp=max(pf[a-1],sf[b+1]);\\n                ans.push_back(temp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971917,
                "title": "easy-c-soltion",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode* root,int level,map<int,int>&ht,map<int,int>&l, map<int,priority_queue<int,vector<int>,greater<int>>>&topTwo)\\n{\\n    if (root==NULL) return -1;\\n    l[root->val]=level;\\n    ht[root->val]=max(height(root->left,level+1,ht,l,topTwo),height(root->right,level+1,ht,l,topTwo))+1;\\n    topTwo[level].push(ht[root->val]);\\n    if (topTwo[level].size()>2) topTwo[level].pop();\\n    return ht[root->val];\\n}\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) \\n    {\\n        map<int,int>ht;\\n        map<int,int>l;\\n        map<int,priority_queue<int,vector<int>,greater<int>>>topTwo;\\n        vector<int>ans;\\n        \\n        int h=height(root,0,ht,l,topTwo);\\n        for (auto it: ht)\\n        {\\n            cout<<it.first<< \" \"<<it.second<<endl;\\n        }\\n        for (auto it: queries)\\n        {\\n            int hh=ht[it];\\n            int ll=l[it];\\n            if (topTwo[ll].size()==2)\\n            {\\n               int first=topTwo[ll].top();\\n               topTwo[ll].pop();\\n               int second=topTwo[ll].top();\\n               topTwo[ll].pop();\\n               if (hh==second) ans.push_back(h+first-second);\\n               else ans.push_back(h);\\n               topTwo[ll].push(first);\\n               topTwo[ll].push(second);\\n            }\\n            else ans.push_back(h-hh-1);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint height(TreeNode* root,int level,map<int,int>&ht,map<int,int>&l, map<int,priority_queue<int,vector<int>,greater<int>>>&topTwo)\\n{\\n    if (root==NULL) return -1;\\n    l[root->val]=level;\\n    ht[root->val]=max(height(root->left,level+1,ht,l,topTwo),height(root->right,level+1,ht,l,topTwo))+1;\\n    topTwo[level].push(ht[root->val]);\\n    if (topTwo[level].size()>2) topTwo[level].pop();\\n    return ht[root->val];\\n}\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) \\n    {\\n        map<int,int>ht;\\n        map<int,int>l;\\n        map<int,priority_queue<int,vector<int>,greater<int>>>topTwo;\\n        vector<int>ans;\\n        \\n        int h=height(root,0,ht,l,topTwo);\\n        for (auto it: ht)\\n        {\\n            cout<<it.first<< \" \"<<it.second<<endl;\\n        }\\n        for (auto it: queries)\\n        {\\n            int hh=ht[it];\\n            int ll=l[it];\\n            if (topTwo[ll].size()==2)\\n            {\\n               int first=topTwo[ll].top();\\n               topTwo[ll].pop();\\n               int second=topTwo[ll].top();\\n               topTwo[ll].pop();\\n               if (hh==second) ans.push_back(h+first-second);\\n               else ans.push_back(h);\\n               topTwo[ll].push(first);\\n               topTwo[ll].push(second);\\n            }\\n            else ans.push_back(h-hh-1);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3961539,
                "title": "well-commented-euler-tour-start-end-time",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int, int> start, endd, depth; // Maps to store start and end times of nodes in Euler tour, along with their depths\\n    int Time = 0; // Initialize time counter\\n    \\n    void euler(TreeNode* curr, int dep) {\\n        start[curr->val] = ++Time; // Assign start time for current node\\n        depth[start[curr->val]] = dep; // Store the depth corresponding to the start time\\n        if (curr->left)\\n            euler(curr->left, dep + 1); // Recur on the left subtree\\n        if (curr->right)\\n            euler(curr->right, dep + 1); // Recur on the right subtree\\n        endd[curr->val] = Time; // Assign end time for current node\\n    }\\n    \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        Time = 0; // Reset the time counter\\n        euler(root, 0); // Generate Euler tour and store start, end times, and depths\\n        \\n        int n = depth.size(); // Number of nodes\\n        vector<int> pref(n + 2, 0); // Prefix array to store maximum depth in the prefix\\n        vector<int> suff(n + 2, 0); // Suffix array to store maximum depth in the suffix\\n        \\n        for (int i = 1; i < n; i++) {\\n            pref[i] = max(pref[i - 1], depth[i]); // Calculate maximum depth in prefix\\n        }\\n        for (int i = n; i >= 0; i--) {\\n            suff[i] = max(suff[i + 1], depth[i]); // Calculate maximum depth in suffix\\n        }\\n        \\n        int q = queries.size(); // Number of queries\\n        vector<int> ans; // Vector to store answers\\n        \\n        for (auto x : queries) {\\n            int st = start[x] - 1; // Start time for the query node (adjusted for 0-based indexing)\\n            int ed = endd[x] + 1; // End time for the query node (adjusted for 0-based indexing)\\n            ans.push_back(max(pref[st], suff[ed])); // Calculate answer using prefix and suffix arrays\\n        }\\n        return ans; // Return the answers\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<int, int> start, endd, depth; // Maps to store start and end times of nodes in Euler tour, along with their depths\\n    int Time = 0; // Initialize time counter\\n    \\n    void euler(TreeNode* curr, int dep) {\\n        start[curr->val] = ++Time; // Assign start time for current node\\n        depth[start[curr->val]] = dep; // Store the depth corresponding to the start time\\n        if (curr->left)\\n            euler(curr->left, dep + 1); // Recur on the left subtree\\n        if (curr->right)\\n            euler(curr->right, dep + 1); // Recur on the right subtree\\n        endd[curr->val] = Time; // Assign end time for current node\\n    }\\n    \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        Time = 0; // Reset the time counter\\n        euler(root, 0); // Generate Euler tour and store start, end times, and depths\\n        \\n        int n = depth.size(); // Number of nodes\\n        vector<int> pref(n + 2, 0); // Prefix array to store maximum depth in the prefix\\n        vector<int> suff(n + 2, 0); // Suffix array to store maximum depth in the suffix\\n        \\n        for (int i = 1; i < n; i++) {\\n            pref[i] = max(pref[i - 1], depth[i]); // Calculate maximum depth in prefix\\n        }\\n        for (int i = n; i >= 0; i--) {\\n            suff[i] = max(suff[i + 1], depth[i]); // Calculate maximum depth in suffix\\n        }\\n        \\n        int q = queries.size(); // Number of queries\\n        vector<int> ans; // Vector to store answers\\n        \\n        for (auto x : queries) {\\n            int st = start[x] - 1; // Start time for the query node (adjusted for 0-based indexing)\\n            int ed = endd[x] + 1; // End time for the query node (adjusted for 0-based indexing)\\n            ans.push_back(max(pref[st], suff[ed])); // Calculate answer using prefix and suffix arrays\\n        }\\n        return ans; // Return the answers\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955598,
                "title": "java-soln-using-dfs-bfs",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int getNumberOfNodes(TreeNode root){\\n        //Base Case\\n        if(root == null) return 0;\\n        return getNumberOfNodes(root.left) + getNumberOfNodes(root.right)+1;\\n    }\\n\\n    public int fillAndGetHeight(TreeNode root,int [] height){\\n        //Base Case\\n        if(root == null) return -1;\\n        int lHeight = fillAndGetHeight(root.left,height);\\n        int rHeight = fillAndGetHeight(root.right,height);\\n        height[root.val] = Math.max(lHeight,rHeight) + 1;\\n        return height[root.val];\\n    }\\n\\n    public boolean getHeightPath(TreeNode root,int height,Stack<Integer> stack){\\n        //Base Case\\n        if(root == null) return false;\\n        stack.push(root.val);\\n        if(stack.size() == height + 1){\\n            return true;\\n        }\\n        if(getHeightPath(root.left,height,stack) || getHeightPath(root.right,height,stack)){\\n            return true;\\n        }\\n        stack.pop();\\n        return false;\\n    }\\n\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        int n = getNumberOfNodes(root);\\n        int [] height = new int[n+1];\\n        int [] heightAfterRemove = new int[n+1];\\n        int [] output = new int[queries.length];\\n        int rootHeight = fillAndGetHeight(root,height);\\n        int index = 0;\\n        Stack<Integer> maxPath = new Stack<>();\\n        boolean hasPath = getHeightPath(root,rootHeight,maxPath);\\n        Set<Integer> maxPathValues = new HashSet<>();\\n        while(!maxPath.isEmpty()){\\n            maxPathValues.add(maxPath.pop());\\n        }\\n        //Now we can use level order traversal and see the contribution after removing\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        int depth = -1;\\n        while(!queue.isEmpty()){\\n            int maxHeight = depth;\\n            int sMaxHeight = depth;\\n            int size = queue.size();\\n            List<TreeNode> levelNodes = new ArrayList<>();\\n            ++depth;\\n            for(int i = 0 ; i < size ; ++i){\\n                TreeNode front = queue.poll();\\n                levelNodes.add(front);\\n                if(front.left != null){\\n                    queue.offer(front.left);\\n                }\\n                if(front.right != null){\\n                    queue.offer(front.right);\\n                }\\n                int temp = height[front.val] + depth;\\n                if(temp >= maxHeight){\\n                    sMaxHeight = maxHeight;\\n                    maxHeight = temp;\\n                }\\n                else if(temp >= sMaxHeight){\\n                    sMaxHeight = temp;\\n                }\\n            }\\n            for(TreeNode node : levelNodes){\\n//If the node lies in height path in that case removal will assign second max value for that level\\n                if(maxPathValues.contains(node.val)){\\n                    heightAfterRemove[node.val] = sMaxHeight;\\n                }\\n                else{\\n                    heightAfterRemove[node.val] = maxHeight;\\n                }\\n            }\\n        }\\n        for(int q : queries){\\n            output[index++] = heightAfterRemove[q];\\n        }\\n\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int getNumberOfNodes(TreeNode root){\\n        //Base Case\\n        if(root == null) return 0;\\n        return getNumberOfNodes(root.left) + getNumberOfNodes(root.right)+1;\\n    }\\n\\n    public int fillAndGetHeight(TreeNode root,int [] height){\\n        //Base Case\\n        if(root == null) return -1;\\n        int lHeight = fillAndGetHeight(root.left,height);\\n        int rHeight = fillAndGetHeight(root.right,height);\\n        height[root.val] = Math.max(lHeight,rHeight) + 1;\\n        return height[root.val];\\n    }\\n\\n    public boolean getHeightPath(TreeNode root,int height,Stack<Integer> stack){\\n        //Base Case\\n        if(root == null) return false;\\n        stack.push(root.val);\\n        if(stack.size() == height + 1){\\n            return true;\\n        }\\n        if(getHeightPath(root.left,height,stack) || getHeightPath(root.right,height,stack)){\\n            return true;\\n        }\\n        stack.pop();\\n        return false;\\n    }\\n\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        int n = getNumberOfNodes(root);\\n        int [] height = new int[n+1];\\n        int [] heightAfterRemove = new int[n+1];\\n        int [] output = new int[queries.length];\\n        int rootHeight = fillAndGetHeight(root,height);\\n        int index = 0;\\n        Stack<Integer> maxPath = new Stack<>();\\n        boolean hasPath = getHeightPath(root,rootHeight,maxPath);\\n        Set<Integer> maxPathValues = new HashSet<>();\\n        while(!maxPath.isEmpty()){\\n            maxPathValues.add(maxPath.pop());\\n        }\\n        //Now we can use level order traversal and see the contribution after removing\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        int depth = -1;\\n        while(!queue.isEmpty()){\\n            int maxHeight = depth;\\n            int sMaxHeight = depth;\\n            int size = queue.size();\\n            List<TreeNode> levelNodes = new ArrayList<>();\\n            ++depth;\\n            for(int i = 0 ; i < size ; ++i){\\n                TreeNode front = queue.poll();\\n                levelNodes.add(front);\\n                if(front.left != null){\\n                    queue.offer(front.left);\\n                }\\n                if(front.right != null){\\n                    queue.offer(front.right);\\n                }\\n                int temp = height[front.val] + depth;\\n                if(temp >= maxHeight){\\n                    sMaxHeight = maxHeight;\\n                    maxHeight = temp;\\n                }\\n                else if(temp >= sMaxHeight){\\n                    sMaxHeight = temp;\\n                }\\n            }\\n            for(TreeNode node : levelNodes){\\n//If the node lies in height path in that case removal will assign second max value for that level\\n                if(maxPathValues.contains(node.val)){\\n                    heightAfterRemove[node.val] = sMaxHeight;\\n                }\\n                else{\\n                    heightAfterRemove[node.val] = maxHeight;\\n                }\\n            }\\n        }\\n        for(int q : queries){\\n            output[index++] = heightAfterRemove[q];\\n        }\\n\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943015,
                "title": "java-dfs-and-bfs-store-high-per-level",
                "content": "# Intuition\\nStore high of each node. \\nFor each level keep 2 nodes of bigges high.\\n\\nOnce we delete a node, we delete entire subtree of this node. The `h` of tree will be changed only if it\\'s highest subtree on this level. Changed hight will be equlas to the `2th` subtree `high + level`.\\n\\n# Approach\\n1. Run post order DFS to calculate high per node\\n2. Run BFS to store 2 max high per level and level per node\\n3. For each `del` node:\\n3.1. if is `root` high is `0`\\n3.2. get level of the `del` node\\n3.3. get top 2 high for the level\\n3.4. if `del` is not highs on the level, tree high didn\\'t changed\\n3.5. if `del` is highs subtree on the level. calculate high for the second subtree if exists\\n\\n# Complexity\\n- Time complexity: `O(n + m)` where `m` is count of queries\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] que) {\\n        Map<Integer, Integer> h = new HashMap<>();\\n        dfs(root, h);\\n\\n        Map<Integer, PriorityQueue<Integer>> perLevel = new HashMap<>();\\n        Map<Integer, Integer> toLevel = new HashMap<>();\\n        {\\n            LinkedList<TreeNode> queue = new LinkedList<>();\\n            queue.add(root);\\n            int level = 0;\\n            while (!queue.isEmpty()) {\\n                for (int sz=queue.size(); sz > 0; sz--) {\\n                    var node = queue.poll();\\n                    toLevel.put(node.val, level);\\n\\n                    var heap = perLevel.computeIfAbsent(level, key -> new PriorityQueue<>((p, q) -> h.get(p) - h.get(q)));\\n                    heap.add(node.val);\\n                    if (heap.size() > 2) {\\n                        heap.poll();\\n                    }\\n\\n                    if (node.left != null) {\\n                        queue.add(node.left);\\n                    }\\n                    if (node.right != null) {\\n                        queue.add(node.right);\\n                    }\\n                }\\n\\n                level++;\\n            }\\n        }\\n\\n        int rootH = h.get(root.val);\\n        int[] res = new int[que.length];\\n        for (int i=0; i<res.length; i++) {\\n            int val = que[i];\\n            if (val == root.val) continue;\\n\\n            int level = toLevel.get(val);\\n            int currH = h.get(val);\\n            var heap = perLevel.get(level);\\n\\n            int min = heap.poll();\\n            int max = heap.isEmpty() ? min : heap.peek();\\n            heap.add(min);\\n\\n            if (val != max) {\\n                res[i] = rootH;\\n            } else {\\n                if (min != max) {\\n                    res[i] = level + h.get(min);\\n                } else {\\n                    res[i] = level - 1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int dfs(TreeNode node, Map<Integer, Integer> h) {\\n        if (node == null) {\\n            return 0;\\n        }\\n\\n        int left = dfs(node.left, h);\\n        int right = dfs(node.right, h);\\n\\n        int curr = Math.max(left, right);\\n        h.put(node.val, curr);\\n        return curr + 1;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] que) {\\n        Map<Integer, Integer> h = new HashMap<>();\\n        dfs(root, h);\\n\\n        Map<Integer, PriorityQueue<Integer>> perLevel = new HashMap<>();\\n        Map<Integer, Integer> toLevel = new HashMap<>();\\n        {\\n            LinkedList<TreeNode> queue = new LinkedList<>();\\n            queue.add(root);\\n            int level = 0;\\n            while (!queue.isEmpty()) {\\n                for (int sz=queue.size(); sz > 0; sz--) {\\n                    var node = queue.poll();\\n                    toLevel.put(node.val, level);\\n\\n                    var heap = perLevel.computeIfAbsent(level, key -> new PriorityQueue<>((p, q) -> h.get(p) - h.get(q)));\\n                    heap.add(node.val);\\n                    if (heap.size() > 2) {\\n                        heap.poll();\\n                    }\\n\\n                    if (node.left != null) {\\n                        queue.add(node.left);\\n                    }\\n                    if (node.right != null) {\\n                        queue.add(node.right);\\n                    }\\n                }\\n\\n                level++;\\n            }\\n        }\\n\\n        int rootH = h.get(root.val);\\n        int[] res = new int[que.length];\\n        for (int i=0; i<res.length; i++) {\\n            int val = que[i];\\n            if (val == root.val) continue;\\n\\n            int level = toLevel.get(val);\\n            int currH = h.get(val);\\n            var heap = perLevel.get(level);\\n\\n            int min = heap.poll();\\n            int max = heap.isEmpty() ? min : heap.peek();\\n            heap.add(min);\\n\\n            if (val != max) {\\n                res[i] = rootH;\\n            } else {\\n                if (min != max) {\\n                    res[i] = level + h.get(min);\\n                } else {\\n                    res[i] = level - 1;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    private int dfs(TreeNode node, Map<Integer, Integer> h) {\\n        if (node == null) {\\n            return 0;\\n        }\\n\\n        int left = dfs(node.left, h);\\n        int right = dfs(node.right, h);\\n\\n        int curr = Math.max(left, right);\\n        h.put(node.val, curr);\\n        return curr + 1;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908010,
                "title": "dfs-c",
                "content": "class Solution {\\n\\npublic:\\n\\n   const int N = 1e5 + 5;\\n   \\n    vector<int>lvl,mxPath;\\n\\t\\n    vector<vector<int> >adj;\\n    \\n    int dfs(TreeNode*root,int currlvl){\\n        if(!root) return currlvl-1;\\n        \\n        lvl[root->val]=currlvl;\\n        \\n        int l=dfs(root->left,currlvl+1);\\n        \\n        int r=dfs(root->right,currlvl+1);\\n        \\n        mxPath[root->val]=max(l,r);\\n        \\n        if(mxPath[root->val]>=adj[currlvl][1]){\\n            \\n            adj[currlvl][0]=adj[currlvl][1];\\n            \\n            adj[currlvl][1]=mxPath[root->val];\\n        }\\n        \\n        else if(mxPath[root->val]>adj[currlvl][0]){\\n            \\n            adj[currlvl][0]=mxPath[root->val];\\n        }\\n        \\n        return mxPath[root->val];\\n        \\n    }\\n    \\n    \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        \\n        lvl.assign(N,-1);\\n        \\n        mxPath.assign(N,-1);\\n        \\n        adj.assign(N,vector<int>(2,-1));\\n        \\n        int height=dfs(root,0);\\n        \\n        vector<int>ans;\\n        \\n        for(auto it:queries){\\n            \\n            if(mxPath[it]!=height) ans.push_back(height);\\n            \\n            else{\\n                \\n                if(adj[lvl[it]][0]!=-1) ans.push_back(adj[lvl[it]][0]);\\n                \\n                else{\\n                    \\n                    ans.push_back(lvl[it] - 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n   const int N = 1e5 + 5;\\n   \\n    vector<int>lvl,mxPath;\\n\\t\\n    vector<vector<int> >adj;\\n    \\n    int dfs(TreeNode*root,int currlvl){\\n        if(!root) return currlvl-1;\\n        \\n        lvl[root->val]=currlvl;\\n        \\n        int l=dfs(root->left,currlvl+1);\\n        \\n        int r=dfs(root->right,currlvl+1);\\n        \\n        mxPath[root->val]=max(l,r);\\n        \\n        if(mxPath[root->val]>=adj[currlvl][1]){\\n            \\n            adj[currlvl][0]=adj[currlvl][1];\\n            \\n            adj[currlvl][1]=mxPath[root->val];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3880484,
                "title": "2-dfs-first-postorder-then-preorder",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<TreeNode*,pair<int,int>> childrenHeights;\\n    int maxVal = -1;\\n    \\n    int calculateSubtreeHeights(TreeNode* root) {\\n        if(!root) {\\n            return 0;\\n        }\\n        maxVal = max(maxVal, root->val);\\n        int leftHeight = calculateSubtreeHeights(root->left);\\n        int rightHeight = calculateSubtreeHeights(root->right);\\n        childrenHeights[root] = {leftHeight, rightHeight};\\n        return 1 + max(leftHeight, rightHeight);\\n    }\\n    \\n    void preCalculateAns(TreeNode* root, vector<int> &preCalculatedAns, int currMaxHeight = 0, int level = 0) {\\n        if(!root) return;\\n        preCalculatedAns[root->val] = currMaxHeight;\\n        auto [leftHeight, rightHeight] = childrenHeights[root];\\n        preCalculateAns(root->left, preCalculatedAns, max(currMaxHeight, rightHeight + level), level + 1);\\n        preCalculateAns(root->right, preCalculatedAns, max(currMaxHeight, leftHeight + level), level + 1);\\n    }\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        calculateSubtreeHeights(root);\\n        vector<int> preCalculatedAns(maxVal + 1);\\n        preCalculateAns(root, preCalculatedAns);\\n        vector<int> ans;\\n        for(int q : queries) {\\n            ans.push_back(preCalculatedAns[q]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<TreeNode*,pair<int,int>> childrenHeights;\\n    int maxVal = -1;\\n    \\n    int calculateSubtreeHeights(TreeNode* root) {\\n        if(!root) {\\n            return 0;\\n        }\\n        maxVal = max(maxVal, root->val);\\n        int leftHeight = calculateSubtreeHeights(root->left);\\n        int rightHeight = calculateSubtreeHeights(root->right);\\n        childrenHeights[root] = {leftHeight, rightHeight};\\n        return 1 + max(leftHeight, rightHeight);\\n    }\\n    \\n    void preCalculateAns(TreeNode* root, vector<int> &preCalculatedAns, int currMaxHeight = 0, int level = 0) {\\n        if(!root) return;\\n        preCalculatedAns[root->val] = currMaxHeight;\\n        auto [leftHeight, rightHeight] = childrenHeights[root];\\n        preCalculateAns(root->left, preCalculatedAns, max(currMaxHeight, rightHeight + level), level + 1);\\n        preCalculateAns(root->right, preCalculatedAns, max(currMaxHeight, leftHeight + level), level + 1);\\n    }\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        calculateSubtreeHeights(root);\\n        vector<int> preCalculatedAns(maxVal + 1);\\n        preCalculateAns(root, preCalculatedAns);\\n        vector<int> ans;\\n        for(int q : queries) {\\n            ans.push_back(preCalculatedAns[q]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812438,
                "title": "dfs-traverse-tree-twice",
                "content": "# Intuition\\n\\n\\n# Approach\\nTraverse the tree twice, first time to store the total height at each node (left and right subtree), and second time to comput solution\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        queries_set = set(queries)\\n        sol = {}\\n\\n        def get_node_height(nd, cur_depth):\\n            if not nd:\\n                return 0\\n            \\n            l = get_node_height(nd.left, cur_depth + 1)\\n            r = get_node_height(nd.right, cur_depth + 1)\\n\\n            nd.l_height = cur_depth + l\\n            nd.r_height = cur_depth + r\\n\\n            return 1 + max(l, r)\\n        \\n        def get_sol(nd, cur_depth, max_depth_so_far):\\n            if not nd:\\n                return\\n\\n            if nd.val in queries_set:\\n                sol[nd.val] = max(cur_depth - 1, max_depth_so_far)\\n\\n            get_sol(nd.left, cur_depth+1, max(max_depth_so_far, nd.r_height)) \\n            get_sol(nd.right, cur_depth+1, max(max_depth_so_far, nd.l_height))\\n\\n        get_node_height(root, 0)\\n        get_sol(root, 0, 0)\\n\\n        return [sol[query] for query in queries]\\n\\n\\n# [3,5,4,2,4]\\n\\n\\n# [2,1,3,3,3]\\n\\n# [1,0,3,3,3]\\n\\n# 1 -> 0, 3\\n# 5 -> 1,\\n\\n\\n#   1\\n#  3  4\\n# 2  6 5\\n#       7\\n\\n# 2 -> 2, 2\\n# 3 -> 2, 1\\n# 1 -> 2, 3\\n# 4 -> 2, 3\\n# 6 -> 2, 2\\n# 5 -> 2, 3\\n# 7 -> 3, 3\\n\\n#\\n\\n\\n# traverse whole tree twice\\n# depth of subtree -> current depth + remaining depth\\n# store total height of right subtree and left at each node\\n# T O(n), S O(n)\\n\\n# as we traverse down we have to remember the max depth of other subtrees or current depth\\n# use this idea and traverse all nodes store solution for all removal nodes\\n# T O(n), S O(h)\\n\\n# T O(n), S O(n)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        queries_set = set(queries)\\n        sol = {}\\n\\n        def get_node_height(nd, cur_depth):\\n            if not nd:\\n                return 0\\n            \\n            l = get_node_height(nd.left, cur_depth + 1)\\n            r = get_node_height(nd.right, cur_depth + 1)\\n\\n            nd.l_height = cur_depth + l\\n            nd.r_height = cur_depth + r\\n\\n            return 1 + max(l, r)\\n        \\n        def get_sol(nd, cur_depth, max_depth_so_far):\\n            if not nd:\\n                return\\n\\n            if nd.val in queries_set:\\n                sol[nd.val] = max(cur_depth - 1, max_depth_so_far)\\n\\n            get_sol(nd.left, cur_depth+1, max(max_depth_so_far, nd.r_height)) \\n            get_sol(nd.right, cur_depth+1, max(max_depth_so_far, nd.l_height))\\n\\n        get_node_height(root, 0)\\n        get_sol(root, 0, 0)\\n\\n        return [sol[query] for query in queries]\\n\\n\\n# [3,5,4,2,4]\\n\\n\\n# [2,1,3,3,3]\\n\\n# [1,0,3,3,3]\\n\\n# 1 -> 0, 3\\n# 5 -> 1,\\n\\n\\n#   1\\n#  3  4\\n# 2  6 5\\n#       7\\n\\n# 2 -> 2, 2\\n# 3 -> 2, 1\\n# 1 -> 2, 3\\n# 4 -> 2, 3\\n# 6 -> 2, 2\\n# 5 -> 2, 3\\n# 7 -> 3, 3\\n\\n#\\n\\n\\n# traverse whole tree twice\\n# depth of subtree -> current depth + remaining depth\\n# store total height of right subtree and left at each node\\n# T O(n), S O(n)\\n\\n# as we traverse down we have to remember the max depth of other subtrees or current depth\\n# use this idea and traverse all nodes store solution for all removal nodes\\n# T O(n), S O(h)\\n\\n# T O(n), S O(n)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811897,
                "title": "solution-calculating-depths-and-levels",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n\\n\\n        depth = {}\\n\\n        def depths(root): \\n\\n            if root is None:\\n                return -1\\n\\n            depth[root.val] = 1 + max(depths(root.left), depths(root.right))\\n\\n            return depth[root.val] \\n\\n        depths(root) \\n\\n        levels_list = []\\n\\n        levels_dict = {}\\n\\n        def levels(root, level):\\n\\n            if root is None: \\n                return \\n            if len(levels_list) < level + 1:\\n                levels_list.append([])\\n\\n            levels_dict[root.val] = level \\n\\n            levels_list[level].append(root.val) \\n\\n            levels(root.left, level + 1) \\n\\n            levels(root.right, level + 1) \\n\\n        levels(root, 0) \\n\\n        q = len(queries)\\n\\n        answer = [None for i in range(q)]\\n\\n        l = len(levels_list)\\n\\n        level_depths = []\\n\\n        for i in range(l):\\n\\n            level_depths.append([])\\n\\n            for j in range(len(levels_list[i])):\\n\\n                level_depths[i].append(depth[levels_list[i][j]])\\n\\n        for l in level_depths:\\n            l.sort(reverse=True) \\n\\n\\n        for i in range(q):\\n\\n            query = queries[i]\\n\\n            l = levels_dict[query] \\n\\n            max_depth = None \\n            \\n            if len(level_depths[l]) == 1:\\n                answer[i] = l - 1\\n                continue\\n            if level_depths[l][0] == depth[query]:\\n                max_depth = level_depths[l][1] \\n            else:\\n                max_depth = level_depths[l][0] \\n\\n            answer[i] = l + max_depth\\n\\n\\n        return answer\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n\\n\\n        depth = {}\\n\\n        def depths(root): \\n\\n            if root is None:\\n                return -1\\n\\n            depth[root.val] = 1 + max(depths(root.left), depths(root.right))\\n\\n            return depth[root.val] \\n\\n        depths(root) \\n\\n        levels_list = []\\n\\n        levels_dict = {}\\n\\n        def levels(root, level):\\n\\n            if root is None: \\n                return \\n            if len(levels_list) < level + 1:\\n                levels_list.append([])\\n\\n            levels_dict[root.val] = level \\n\\n            levels_list[level].append(root.val) \\n\\n            levels(root.left, level + 1) \\n\\n            levels(root.right, level + 1) \\n\\n        levels(root, 0) \\n\\n        q = len(queries)\\n\\n        answer = [None for i in range(q)]\\n\\n        l = len(levels_list)\\n\\n        level_depths = []\\n\\n        for i in range(l):\\n\\n            level_depths.append([])\\n\\n            for j in range(len(levels_list[i])):\\n\\n                level_depths[i].append(depth[levels_list[i][j]])\\n\\n        for l in level_depths:\\n            l.sort(reverse=True) \\n\\n\\n        for i in range(q):\\n\\n            query = queries[i]\\n\\n            l = levels_dict[query] \\n\\n            max_depth = None \\n            \\n            if len(level_depths[l]) == 1:\\n                answer[i] = l - 1\\n                continue\\n            if level_depths[l][0] == depth[query]:\\n                max_depth = level_depths[l][1] \\n            else:\\n                max_depth = level_depths[l][0] \\n\\n            answer[i] = l + max_depth\\n\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800738,
                "title": "c-2-dfs-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- - We want height of tree without given nodes subtree.\\n- We need to find height of other subtree first and find max among them or level of its parent.\\n- 2 cases:\\n    - Its parent level is max even after removing current node.\\n    - Other Subtree has max level.\\n- For this traverse tree in root-left-right and root-right-left.\\n- One traversal will give Parent height, other traversal will give other subtree max level. Answer for that node will be max of these. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n<!-- - Time complexity: O(2N + Queries.size()) -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- - Space complexity: O(N+ queries.size()) -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void dfsRightFirst(TreeNode* root, unordered_map<int, int> &maxLevelBeforeTraversingElementsSubtree, int level, int &maxi){\\n        if(!root) return;\\n        maxLevelBeforeTraversingElementsSubtree[root->val] = maxi;\\n        maxi = max(maxi, level);\\n\\n        dfsRightFirst(root->right, maxLevelBeforeTraversingElementsSubtree, level+1, maxi);\\n        dfsRightFirst(root->left, maxLevelBeforeTraversingElementsSubtree, level+1, maxi);\\n    }\\n\\n    void dfsLeftFirst(TreeNode* root, unordered_map<int, int> &maxLevelBeforeTraversingElementsSubtree, int level, int &maxi){\\n        if(!root) return;\\n        maxLevelBeforeTraversingElementsSubtree[root->val] = max(maxLevelBeforeTraversingElementsSubtree[root->val], maxi);\\n        maxi = max(maxi, level);\\n\\n        dfsLeftFirst(root->left, maxLevelBeforeTraversingElementsSubtree, level+1, maxi);\\n        dfsLeftFirst(root->right, maxLevelBeforeTraversingElementsSubtree, level+1, maxi);\\n        \\n    }\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int> ans(queries.size());\\n        unordered_map<int, int> maxLevelBeforeTraversingElementsSubtree;\\n        \\n        int maxi = 0;\\n        dfsRightFirst(root, maxLevelBeforeTraversingElementsSubtree, 0, maxi);\\n        maxi = 0;\\n        dfsLeftFirst(root, maxLevelBeforeTraversingElementsSubtree, 0, maxi);\\n\\n        for(int i = 0;i<queries.size();i++){\\n            ans[i] = maxLevelBeforeTraversingElementsSubtree[queries[i]];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void dfsRightFirst(TreeNode* root, unordered_map<int, int> &maxLevelBeforeTraversingElementsSubtree, int level, int &maxi){\\n        if(!root) return;\\n        maxLevelBeforeTraversingElementsSubtree[root->val] = maxi;\\n        maxi = max(maxi, level);\\n\\n        dfsRightFirst(root->right, maxLevelBeforeTraversingElementsSubtree, level+1, maxi);\\n        dfsRightFirst(root->left, maxLevelBeforeTraversingElementsSubtree, level+1, maxi);\\n    }\\n\\n    void dfsLeftFirst(TreeNode* root, unordered_map<int, int> &maxLevelBeforeTraversingElementsSubtree, int level, int &maxi){\\n        if(!root) return;\\n        maxLevelBeforeTraversingElementsSubtree[root->val] = max(maxLevelBeforeTraversingElementsSubtree[root->val], maxi);\\n        maxi = max(maxi, level);\\n\\n        dfsLeftFirst(root->left, maxLevelBeforeTraversingElementsSubtree, level+1, maxi);\\n        dfsLeftFirst(root->right, maxLevelBeforeTraversingElementsSubtree, level+1, maxi);\\n        \\n    }\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int> ans(queries.size());\\n        unordered_map<int, int> maxLevelBeforeTraversingElementsSubtree;\\n        \\n        int maxi = 0;\\n        dfsRightFirst(root, maxLevelBeforeTraversingElementsSubtree, 0, maxi);\\n        maxi = 0;\\n        dfsLeftFirst(root, maxLevelBeforeTraversingElementsSubtree, 0, maxi);\\n\\n        for(int i = 0;i<queries.size();i++){\\n            ans[i] = maxLevelBeforeTraversingElementsSubtree[queries[i]];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794535,
                "title": "dfs-bfs-python-the-fast-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) n is number of nodes\\n\\n- Space complexity:\\n- o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        nodes = collections.defaultdict(lambda: 0)\\n        self.dfs(root, nodes)\\n        \\n        max_height = nodes[root.val]\\n        deletes = collections.defaultdict(lambda: max_height)\\n        queue = deque([root])\\n        deletes[root.val] = 0\\n        while queue:\\n            node = queue.popleft()\\n            left_val = nodes[node.left.val] if node.left else -1\\n            right_val = nodes[node.right.val] if node.right else -1\\n            if left_val < right_val:\\n                deletes[node.right.val] = max(deletes[node.val], max_height - right_val + left_val)\\n                queue.append(node.right)\\n            elif right_val < left_val:\\n                deletes[node.left.val] = max(deletes[node.val], max_height - left_val + right_val)\\n                queue.append(node.left)\\n            else:\\n                continue\\n        print(deletes)\\n        return [deletes[query] for query in queries]\\n\\n\\n\\n    def dfs(self, root, nodes):\\n        if root.left and root.right:\\n            nodes[root.val] = max(self.dfs(root.left, nodes), self.dfs(root.right, nodes)) + 1\\n        elif root.left:\\n            nodes[root.val] = self.dfs(root.left, nodes) + 1\\n        elif root.right:\\n            nodes[root.val] = self.dfs(root.right, nodes) + 1\\n        else:\\n            nodes[root.val] = 0\\n        return nodes[root.val]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        nodes = collections.defaultdict(lambda: 0)\\n        self.dfs(root, nodes)\\n        \\n        max_height = nodes[root.val]\\n        deletes = collections.defaultdict(lambda: max_height)\\n        queue = deque([root])\\n        deletes[root.val] = 0\\n        while queue:\\n            node = queue.popleft()\\n            left_val = nodes[node.left.val] if node.left else -1\\n            right_val = nodes[node.right.val] if node.right else -1\\n            if left_val < right_val:\\n                deletes[node.right.val] = max(deletes[node.val], max_height - right_val + left_val)\\n                queue.append(node.right)\\n            elif right_val < left_val:\\n                deletes[node.left.val] = max(deletes[node.val], max_height - left_val + right_val)\\n                queue.append(node.left)\\n            else:\\n                continue\\n        print(deletes)\\n        return [deletes[query] for query in queries]\\n\\n\\n\\n    def dfs(self, root, nodes):\\n        if root.left and root.right:\\n            nodes[root.val] = max(self.dfs(root.left, nodes), self.dfs(root.right, nodes)) + 1\\n        elif root.left:\\n            nodes[root.val] = self.dfs(root.left, nodes) + 1\\n        elif root.right:\\n            nodes[root.val] = self.dfs(root.right, nodes) + 1\\n        else:\\n            nodes[root.val] = 0\\n        return nodes[root.val]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763302,
                "title": "c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"ffast-math\",\"unroll-loops\",\"no-stack-protector\", \"-foptimize-strlen\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native,f16c\")\\nstatic const int _ = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    \\n    int func(TreeNode *root, int query) {\\n        if(!root || root->val == query)   return -1;\\n        return 1+max(func(root->left, query), func(root->right, query));\\n    }\\n\\n    int func(TreeNode* root, map<int,int> &mp) {  // func for returning max height\\n        if(!root)   return -1;\\n        return mp[root->val] = 1+max(func(root->left, mp), func(root->right, mp));\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        \\n        map<int,int> mp;  //will store height of tree at particular root val\\n        func(root, mp);\\n\\n        map<int,int> quers; \\n        queue<TreeNode*> que;\\n        que.push(root);\\n\\n        int h=0;\\n        while(!que.empty()) {\\n            int n = que.size();\\n            vector<pair<int,int>> temp;   //store height and root val at same level\\n\\n            for(int i=0; i<n; i++) {\\n                TreeNode* x = que.front();\\n\\n                temp.push_back({mp[x->val], x->val});\\n\\n                if(x->left)     que.push(x->left);\\n                if(x->right)     que.push(x->right);\\n                que.pop();\\n            }\\n\\n            //storing possible height into quers if given root is deleted\\n            sort(temp.begin(), temp.end());\\n            if(temp.size()==1)  quers[temp[0].second] = h-1;\\n            else {\\n                for(int j=0;j<n-1; j++) \\n                    quers[temp[j].second] = h+temp[n-1].first;\\n                quers[temp[n-1].second] = h+temp[n-2].first;\\n            }\\n            h++;\\n        }\\n\\n        int m=queries.size();\\n        vector<int> ans;\\n\\n        for(int i=0; i<m; i++) {\\n            ans.push_back(quers[queries[i]]);\\n        }\\n        return ans;\\n\\n\\n        // TLE at 35/40\\n\\n        // int m=queries.size();\\n        // vector<int> ans;\\n\\n        // for(int i=0; i<m; i++) {\\n        //     ans.push_back(func(root,queries[i]));\\n        // }\\n        // return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"ffast-math\",\"unroll-loops\",\"no-stack-protector\", \"-foptimize-strlen\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native,f16c\")\\nstatic const int _ = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    \\n    int func(TreeNode *root, int query) {\\n        if(!root || root->val == query)   return -1;\\n        return 1+max(func(root->left, query), func(root->right, query));\\n    }\\n\\n    int func(TreeNode* root, map<int,int> &mp) {  // func for returning max height\\n        if(!root)   return -1;\\n        return mp[root->val] = 1+max(func(root->left, mp), func(root->right, mp));\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        \\n        map<int,int> mp;  //will store height of tree at particular root val\\n        func(root, mp);\\n\\n        map<int,int> quers; \\n        queue<TreeNode*> que;\\n        que.push(root);\\n\\n        int h=0;\\n        while(!que.empty()) {\\n            int n = que.size();\\n            vector<pair<int,int>> temp;   //store height and root val at same level\\n\\n            for(int i=0; i<n; i++) {\\n                TreeNode* x = que.front();\\n\\n                temp.push_back({mp[x->val], x->val});\\n\\n                if(x->left)     que.push(x->left);\\n                if(x->right)     que.push(x->right);\\n                que.pop();\\n            }\\n\\n            //storing possible height into quers if given root is deleted\\n            sort(temp.begin(), temp.end());\\n            if(temp.size()==1)  quers[temp[0].second] = h-1;\\n            else {\\n                for(int j=0;j<n-1; j++) \\n                    quers[temp[j].second] = h+temp[n-1].first;\\n                quers[temp[n-1].second] = h+temp[n-2].first;\\n            }\\n            h++;\\n        }\\n\\n        int m=queries.size();\\n        vector<int> ans;\\n\\n        for(int i=0; i<m; i++) {\\n            ans.push_back(quers[queries[i]]);\\n        }\\n        return ans;\\n\\n\\n        // TLE at 35/40\\n\\n        // int m=queries.size();\\n        // vector<int> ans;\\n\\n        // for(int i=0; i<m; i++) {\\n        //     ans.push_back(func(root,queries[i]));\\n        // }\\n        // return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3741945,
                "title": "simple-to-understand-version-of-all-the-dfs-solutions",
                "content": "# Intuition\\nI think this a clear version of the intuition behind all the depth-first versions of the answer. This is a memory-intensive solution, but you should be able to grok the main idea of the problem by looking at \"dfs\"; all the other parts are simple setup and caching operations.\\n\\n# Code\\n```\\nimport functools\\nimport itertools as it\\n\\n\\ndef answer(root, queries):\\n\\n  @functools.cache\\n  def height(cnode):\\n    return 1+max(height(cnode.left), height(cnode.right)) if cnode else 0\\n\\n  parent = {None:None}\\n  depth = {None:0}\\n  node_val_lookup = {}\\n  def traverse(cnode, curr_depth=0, curr_parent=None):\\n    nonlocal depth, node_val_lookup\\n    if not cnode: return\\n    depth[cnode] = curr_depth\\n    node_val_lookup[cnode.val] = cnode\\n    parent[cnode] = curr_parent\\n    for child in [cnode.left, cnode.right]:\\n      traverse(child, curr_depth=curr_depth+1, curr_parent=cnode)\\n  traverse(root)\\n\\n  def graph_height_through_node(cnode):\\n    nonlocal parent\\n    return depth[parent[cnode]]+height(cnode)\\n\\n  max_height_when_deleted = {root:0}\\n  def dfs(cnode, parent, sibling):\\n    nonlocal max_height_when_deleted\\n    if not cnode: return\\n\\n    max_height_when_deleted[cnode] = max(\\n      max_height_when_deleted[parent], \\n      graph_height_through_node(sibling), \\n      depth[parent]\\n    )\\n\\n    dfs(cnode.right, cnode, cnode.left)\\n    dfs(cnode.left, cnode, cnode.right)\\n\\n  dfs(root.left, root, root.right)\\n  dfs(root.right, root, root.left)\\n  return [max_height_when_deleted[node_val_lookup[q]] for q in queries]\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        return answer(root, queries)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport functools\\nimport itertools as it\\n\\n\\ndef answer(root, queries):\\n\\n  @functools.cache\\n  def height(cnode):\\n    return 1+max(height(cnode.left), height(cnode.right)) if cnode else 0\\n\\n  parent = {None:None}\\n  depth = {None:0}\\n  node_val_lookup = {}\\n  def traverse(cnode, curr_depth=0, curr_parent=None):\\n    nonlocal depth, node_val_lookup\\n    if not cnode: return\\n    depth[cnode] = curr_depth\\n    node_val_lookup[cnode.val] = cnode\\n    parent[cnode] = curr_parent\\n    for child in [cnode.left, cnode.right]:\\n      traverse(child, curr_depth=curr_depth+1, curr_parent=cnode)\\n  traverse(root)\\n\\n  def graph_height_through_node(cnode):\\n    nonlocal parent\\n    return depth[parent[cnode]]+height(cnode)\\n\\n  max_height_when_deleted = {root:0}\\n  def dfs(cnode, parent, sibling):\\n    nonlocal max_height_when_deleted\\n    if not cnode: return\\n\\n    max_height_when_deleted[cnode] = max(\\n      max_height_when_deleted[parent], \\n      graph_height_through_node(sibling), \\n      depth[parent]\\n    )\\n\\n    dfs(cnode.right, cnode, cnode.left)\\n    dfs(cnode.left, cnode, cnode.right)\\n\\n  dfs(root.left, root, root.right)\\n  dfs(root.right, root, root.left)\\n  return [max_height_when_deleted[node_val_lookup[q]] for q in queries]\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        return answer(root, queries)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3733248,
                "title": "euler-tour-o-n-c",
                "content": "# Complexity\\n- Time complexity:\\n$$O(N)$$\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void eulerTour(TreeNode*root,vector<int>&Tour,int height,unordered_map<int,int>&Height)\\n    {\\n        if(!root) return;\\n        Tour.emplace_back(root->val - 1);\\n        Height[root->val - 1] =  height;\\n        eulerTour(root->left,Tour,height+1,Height);\\n        eulerTour(root->right,Tour,height+1,Height);\\n        Tour.emplace_back(root->val - 1);\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int>Tour;\\n        unordered_map<int,int>Height;\\n        eulerTour(root,Tour,0,Height);\\n\\n        int n = Tour.size();\\n        // Store the starting and ending indices of each sub-tree\\n        vector<pair<int,int>>indices(n,{-1,-1});\\n        for(int i = 0;i<n;i++)\\n        {\\n            int val = Tour[i];\\n            if(indices[val].first==-1) indices[val].first = i;\\n            else indices[val].second = i; \\n        }\\n\\n        // Store the maximum height till each node\\n        vector<int>prefixMax(n,0),suffixMax(n,0);\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(i == 0) \\n            {\\n                prefixMax[i] = Height[Tour[i]];\\n                suffixMax[n-i-1] = Height[Tour[n-i-1]];\\n            }\\n            else\\n            {\\n                prefixMax[i] = max(Height[Tour[i]],prefixMax[i-1]);\\n                suffixMax[n-i-1] = max(Height[Tour[n-i-1]],suffixMax[n-i]);\\n            }\\n\\n        }\\n\\n        // For each query ignore the given sub-tree\\n        vector<int>result;\\n        for(int & query : queries)\\n        {\\n            query--;\\n            int start = indices[query].first;\\n            int end = indices[query].second;\\n            result.emplace_back(max(prefixMax[start-1],suffixMax[end+1]));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void eulerTour(TreeNode*root,vector<int>&Tour,int height,unordered_map<int,int>&Height)\\n    {\\n        if(!root) return;\\n        Tour.emplace_back(root->val - 1);\\n        Height[root->val - 1] =  height;\\n        eulerTour(root->left,Tour,height+1,Height);\\n        eulerTour(root->right,Tour,height+1,Height);\\n        Tour.emplace_back(root->val - 1);\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int>Tour;\\n        unordered_map<int,int>Height;\\n        eulerTour(root,Tour,0,Height);\\n\\n        int n = Tour.size();\\n        // Store the starting and ending indices of each sub-tree\\n        vector<pair<int,int>>indices(n,{-1,-1});\\n        for(int i = 0;i<n;i++)\\n        {\\n            int val = Tour[i];\\n            if(indices[val].first==-1) indices[val].first = i;\\n            else indices[val].second = i; \\n        }\\n\\n        // Store the maximum height till each node\\n        vector<int>prefixMax(n,0),suffixMax(n,0);\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(i == 0) \\n            {\\n                prefixMax[i] = Height[Tour[i]];\\n                suffixMax[n-i-1] = Height[Tour[n-i-1]];\\n            }\\n            else\\n            {\\n                prefixMax[i] = max(Height[Tour[i]],prefixMax[i-1]);\\n                suffixMax[n-i-1] = max(Height[Tour[n-i-1]],suffixMax[n-i]);\\n            }\\n\\n        }\\n\\n        // For each query ignore the given sub-tree\\n        vector<int>result;\\n        for(int & query : queries)\\n        {\\n            query--;\\n            int start = indices[query].first;\\n            int end = indices[query].second;\\n            result.emplace_back(max(prefixMax[start-1],suffixMax[end+1]));\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730419,
                "title": "java-with-explanation-using-one-dfs-depth-height",
                "content": "1. Calculate and store the height and depth of each node in the arrays: **height** and **depth**.\\n2. Use **map** to store the depth and nodes in each depth.\\n3. Sort the **map** values in height decreasing order, that is to say, the first one in the list is the node with the highest height among the nodes in this depth.\\n4. Iterate the queries, there are three situations:\\n - the highest node in the depth is query node itself, and the query node is the only node in this depth: in this case we return **nodeDepth - 1**, we minus one here as this only node will be removed from the tree.\\n - the highest node in the depth is query node itself, and the query node is __not__ the only node in this depth: in this case we return **second highest height + curDepth**.\\n - the highest node in the depth is **not** query node itself, we return the **highest height + curDepth**\\n\\n# Code\\n```\\nclass Solution {\\n    int[] height;\\n    int[] depth;\\n    Map<Integer, List<Integer>> map;\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        this.height = new int[1000001];\\n        this.depth = new int[1000001];\\n        this.map = new HashMap<>();\\n        int[] res = new int[queries.length];\\n\\n        dfs(root, 0);\\n        map.forEach((k, v) -> {\\n            Collections.sort(v, (a, b) -> height[b] - height[a]);\\n        });\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            int curNodeVal = queries[i];\\n            int curHeight = height[curNodeVal];\\n            int curDepth = depth[curNodeVal];\\n\\n            List<Integer> neighbours = map.get(curDepth);\\n            if (neighbours.get(0) == curNodeVal) {\\n                res[i] = neighbours.size() > 1 ? height[neighbours.get(1)] + curDepth : curDepth - 1;\\n            } else {\\n                res[i] = height[neighbours.get(0)] + curDepth;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    public int dfs(TreeNode node, int nodeDepth) {\\n        if (node == null) return -1;\\n        int left = dfs(node.left, nodeDepth + 1);\\n        int right = dfs(node.right, nodeDepth + 1);\\n        int nodeHeight = Math.max(left, right) + 1;\\n        height[node.val] = nodeHeight;\\n        depth[node.val] = nodeDepth;\\n        map.computeIfAbsent(nodeDepth, list -> new ArrayList<>()).add(node.val);\\n\\n        return nodeHeight;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] height;\\n    int[] depth;\\n    Map<Integer, List<Integer>> map;\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        this.height = new int[1000001];\\n        this.depth = new int[1000001];\\n        this.map = new HashMap<>();\\n        int[] res = new int[queries.length];\\n\\n        dfs(root, 0);\\n        map.forEach((k, v) -> {\\n            Collections.sort(v, (a, b) -> height[b] - height[a]);\\n        });\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            int curNodeVal = queries[i];\\n            int curHeight = height[curNodeVal];\\n            int curDepth = depth[curNodeVal];\\n\\n            List<Integer> neighbours = map.get(curDepth);\\n            if (neighbours.get(0) == curNodeVal) {\\n                res[i] = neighbours.size() > 1 ? height[neighbours.get(1)] + curDepth : curDepth - 1;\\n            } else {\\n                res[i] = height[neighbours.get(0)] + curDepth;\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    public int dfs(TreeNode node, int nodeDepth) {\\n        if (node == null) return -1;\\n        int left = dfs(node.left, nodeDepth + 1);\\n        int right = dfs(node.right, nodeDepth + 1);\\n        int nodeHeight = Math.max(left, right) + 1;\\n        height[node.val] = nodeHeight;\\n        depth[node.val] = nodeDepth;\\n        map.computeIfAbsent(nodeDepth, list -> new ArrayList<>()).add(node.val);\\n\\n        return nodeHeight;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729746,
                "title": "o-1-for-each-query-operation-full-explanations",
                "content": "# Intuition\\nO(1) time complexity for each query operation\\n\\n# Approach\\nPrecompute all possible query results using DFS + BFS.\\n\\n# Complexity\\n- Time complexity:\\nO(N+M)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\nclass Solution:\\n    \"\"\"\\n    The hidden objective of the problem is to ensure that each query operation have a time complexity of O(1).\\n    The solution can be divided into two modules:\\n    Module 1: Initialization of dictionaries for all possible queries\\n    1. Compute the height of all nodes using the function self.getHeight(root), which has a time complexity of O(N).\\n    2. Compute the height of the \"residual tree\" after subtree removal queries.\\n    - For each node_i in the query, calculate ResHeight(node_i) using the following formula:\\n        ResHeight(node_i) = level/depth(node_i) + max([height(node_j) for node_j in the same level as node_i])\\n    - To optimize the computation, we only need to find the maximum two heights instead of sorting all heights in the level.\\n    - If height(node_i) is equal to the first highest height in the level, ResHeight(node_i) is calculated as level + second highest height.\\n        Otherwise, ResHeight(node_i) is calculated as level + first highest height.\\n    - The time complexity for computing ResHeight for all nodes is O(N).\\n\\n    Module 2: Iteration through all input queries\\n    The time complexity for this module is denoted as O(M), where M represents the number of input queries.\\n\\n    Overall, the total time complexity of the solution is O(N + M).\\n    \"\"\"\\n    def __init__(self):\\n        self.nodeHeight = {}\\n        self.residualHeights = {}\\n\\n    def initialComputation(self, root):\\n        self.getHeight(root)\\n        self.bfs(root)\\n\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        heights = []\\n        self.initialComputation(root)\\n        for query in queries:\\n            heights.append(self.residualHeights[query])\\n        return heights\\n    \\n    def findMaxTwoHeight(self, heightNodes):\\n        maxTwoHeight = [-1, -1]\\n        for heightNode in heightNodes:\\n            if heightNode >= maxTwoHeight[0]:\\n                maxTwoHeight[1] = maxTwoHeight[0]\\n                maxTwoHeight[0] = heightNode\\n                continue\\n            if heightNode > maxTwoHeight[1]:\\n                maxTwoHeight[1] = heightNode\\n        return maxTwoHeight\\n\\n    def getHeight(self, node):\\n        if node is None:\\n            return -1\\n        self.nodeHeight[node.val] = max(self.getHeight(node.left), self.getHeight(node.right)) + 1\\n        return self.nodeHeight[node.val]\\n\\n    def bfs(self, root: TreeNode):\\n        queue = collections.deque([[root]])\\n        level = 0\\n        while queue:\\n            nextLevelNodes = []\\n            currLevelNodes = queue.popleft()\\n            nodeHeights = [self.nodeHeight[currNode.val] for currNode in currLevelNodes]\\n            maxTwoHeight = self.findMaxTwoHeight(nodeHeights)\\n            for currNode in currLevelNodes:\\n                if self.nodeHeight[currNode.val] == maxTwoHeight[0]:\\n                    self.residualHeights[currNode.val] = maxTwoHeight[1] + level\\n                else:\\n                    self.residualHeights[currNode.val] = maxTwoHeight[0] + level\\n                if currNode.left:\\n                    nextLevelNodes.append(currNode.left)\\n                if currNode.right:\\n                    nextLevelNodes.append(currNode.right)\\n            if nextLevelNodes:\\n                queue.append(nextLevelNodes)\\n            level += 1\\n\\n    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n\\nclass Solution:\\n    \"\"\"\\n    The hidden objective of the problem is to ensure that each query operation have a time complexity of O(1).\\n    The solution can be divided into two modules:\\n    Module 1: Initialization of dictionaries for all possible queries\\n    1. Compute the height of all nodes using the function self.getHeight(root), which has a time complexity of O(N).\\n    2. Compute the height of the \"residual tree\" after subtree removal queries.\\n    - For each node_i in the query, calculate ResHeight(node_i) using the following formula:\\n        ResHeight(node_i) = level/depth(node_i) + max([height(node_j) for node_j in the same level as node_i])\\n    - To optimize the computation, we only need to find the maximum two heights instead of sorting all heights in the level.\\n    - If height(node_i) is equal to the first highest height in the level, ResHeight(node_i) is calculated as level + second highest height.\\n        Otherwise, ResHeight(node_i) is calculated as level + first highest height.\\n    - The time complexity for computing ResHeight for all nodes is O(N).\\n\\n    Module 2: Iteration through all input queries\\n    The time complexity for this module is denoted as O(M), where M represents the number of input queries.\\n\\n    Overall, the total time complexity of the solution is O(N + M).\\n    \"\"\"\\n    def __init__(self):\\n        self.nodeHeight = {}\\n        self.residualHeights = {}\\n\\n    def initialComputation(self, root):\\n        self.getHeight(root)\\n        self.bfs(root)\\n\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        heights = []\\n        self.initialComputation(root)\\n        for query in queries:\\n            heights.append(self.residualHeights[query])\\n        return heights\\n    \\n    def findMaxTwoHeight(self, heightNodes):\\n        maxTwoHeight = [-1, -1]\\n        for heightNode in heightNodes:\\n            if heightNode >= maxTwoHeight[0]:\\n                maxTwoHeight[1] = maxTwoHeight[0]\\n                maxTwoHeight[0] = heightNode\\n                continue\\n            if heightNode > maxTwoHeight[1]:\\n                maxTwoHeight[1] = heightNode\\n        return maxTwoHeight\\n\\n    def getHeight(self, node):\\n        if node is None:\\n            return -1\\n        self.nodeHeight[node.val] = max(self.getHeight(node.left), self.getHeight(node.right)) + 1\\n        return self.nodeHeight[node.val]\\n\\n    def bfs(self, root: TreeNode):\\n        queue = collections.deque([[root]])\\n        level = 0\\n        while queue:\\n            nextLevelNodes = []\\n            currLevelNodes = queue.popleft()\\n            nodeHeights = [self.nodeHeight[currNode.val] for currNode in currLevelNodes]\\n            maxTwoHeight = self.findMaxTwoHeight(nodeHeights)\\n            for currNode in currLevelNodes:\\n                if self.nodeHeight[currNode.val] == maxTwoHeight[0]:\\n                    self.residualHeights[currNode.val] = maxTwoHeight[1] + level\\n                else:\\n                    self.residualHeights[currNode.val] = maxTwoHeight[0] + level\\n                if currNode.left:\\n                    nextLevelNodes.append(currNode.left)\\n                if currNode.right:\\n                    nextLevelNodes.append(currNode.right)\\n            if nextLevelNodes:\\n                queue.append(nextLevelNodes)\\n            level += 1\\n\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705766,
                "title": "a-drawing-of-euler-tour",
                "content": "# A drawing of Euler\\'s Tour \\n- Followed this solution: https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/solutions/3701953/euler-tour/\\n\\n![IMG_8C0B9A584554-1.jpeg](https://assets.leetcode.com/users/images/1254b53d-964d-4764-a5fb-c264bf0cf849_1688241914.5401726.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "# A drawing of Euler\\'s Tour \\n- Followed this solution: https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/solutions/3701953/euler-tour/\\n\\n![IMG_8C0B9A584554-1.jpeg](https://assets.leetcode.com/users/images/1254b53d-964d-4764-a5fb-c264bf0cf849_1688241914.5401726.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3705636,
                "title": "two-dfs-solution-o-n-m",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo DFS to get the heights of each subtree and then use the heights to precompute the answers for every possible query.\\n\\nTo precompute the answer, first get the answer based only on the local subtree, then factor in the rest of the tree through the minimum variable. \\n\\n# Complexity\\n- Time complexity: O(n + m)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        heights = {}\\n        def getHeights(node):\\n            if not node:\\n                return 0\\n            heights[node.val] = max(getHeights(node.left), getHeights(node.right)) + 1\\n            return heights[node.val]\\n        getHeights(root)\\n\\n        precomputed = {}\\n        def precompute(node, layer, minimum):            \\n            if node.left:\\n                precomputed[node.left.val] = max(layer if not node.right else layer + heights[node.right.val], minimum)\\n                precompute(node.left, layer + 1, max(minimum, precomputed[node.left.val]))\\n            if node.right:\\n                precomputed[node.right.val] = max(layer if not node.left else layer + heights[node.left.val], minimum)\\n                precompute(node.right, layer + 1,  max(minimum, precomputed[node.right.val]))\\n        precompute(root, 0, 0)\\n\\n        results = [query for query in queries]\\n        for i in range(len(queries)):\\n            results[i] = precomputed[queries[i]]\\n        return results\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        heights = {}\\n        def getHeights(node):\\n            if not node:\\n                return 0\\n            heights[node.val] = max(getHeights(node.left), getHeights(node.right)) + 1\\n            return heights[node.val]\\n        getHeights(root)\\n\\n        precomputed = {}\\n        def precompute(node, layer, minimum):            \\n            if node.left:\\n                precomputed[node.left.val] = max(layer if not node.right else layer + heights[node.right.val], minimum)\\n                precompute(node.left, layer + 1, max(minimum, precomputed[node.left.val]))\\n            if node.right:\\n                precomputed[node.right.val] = max(layer if not node.left else layer + heights[node.left.val], minimum)\\n                precompute(node.right, layer + 1,  max(minimum, precomputed[node.right.val]))\\n        precompute(root, 0, 0)\\n\\n        results = [query for query in queries]\\n        for i in range(len(queries)):\\n            results[i] = precomputed[queries[i]]\\n        return results\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698635,
                "title": "python3-bfs-dfs-o-n-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N) + O(Q)$$ where Q is the queries, N is the number of nodes.\\n\\n- Space complexity: $$O(N) + O(H) = O(N)$$ where H is the height of the tree, but it is asymptotically smaller than N, so for N going to infinity it becomes negligeble.\\n\\n# Code\\n```\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        self.subtreeSize = {}\\n        self.maxSubtreeSize = 0\\n        self.dfs(root)\\n\\n        self.nodesLevels = {}\\n        self.levelsToSubtreeSizes = {}\\n        q = deque([(root, 0)])\\n        self.nodesLevels[root.val] = 0\\n\\n        while q:\\n            bfsLevel = q[0][1]\\n\\n            # For each level, save the Top 2 subtree sizes of the nodes\\n            if bfsLevel not in self.levelsToSubtreeSizes:\\n                top1Value, top2Value= -11, -12\\n                for node, _ in q:\\n                    size = self.subtreeSize[node.val]\\n                    if size > top1Value:\\n                        top1Value, top2Value = size, top1Value\\n                    elif size > top2Value:\\n                        top2Value = size\\n                # If the level only contains one node, then set top2 = -1\\n                if top2Value < 0:\\n                    top2Value = -1\\n                self.levelsToSubtreeSizes[bfsLevel] = (top1Value, top2Value)\\n            \\n            # Add children to BFS queue, and save their levels\\n            node, bfsLevel = q.popleft()\\n            if node.left:\\n                q.append((node.left, bfsLevel+1))\\n                self.nodesLevels[node.left.val] = bfsLevel+1\\n            if node.right:\\n                q.append((node.right, bfsLevel+1))\\n                self.nodesLevels[node.right.val] = bfsLevel+1\\n\\n        result = []\\n\\n        for nodeToDelete in queries:\\n            level = self.nodesLevels[nodeToDelete]\\n            nodeSize = self.subtreeSize[nodeToDelete]\\n            levelSubtreeSizes = self.levelsToSubtreeSizes[level]\\n            if nodeSize == levelSubtreeSizes[0]:\\n                # Since I delete the subtree corresponding to the highest level, then the highest level of the tree will change\\n                # If there is another node in the same level, then it will become the new longest path\\n                if levelSubtreeSizes[1] != -1:\\n                    result.append(level + levelSubtreeSizes[1])\\n                # If I delete the only child in this level, then the new height of the tree = level - 1\\n                else:\\n                    result.append(level - 1)\\n            else:\\n                # If I delete the node not belonging to the longest path, then the height of the tree doesn\\'t change\\n                result.append(self.maxSubtreeSize)\\n\\n        return result            \\n\\n    def dfs(self, root: TreeNode) -> int:\\n        # Post-order DFS\\n        leftSubtreeSize, rightSubtreeSize  = None, None\\n        if root.left:\\n            leftSubtreeSize = self.dfs(root.left)\\n        if root.right:\\n            rightSubtreeSize = self.dfs(root.right)\\n        \\n        # Calculate the height of the subtree belonging to the current node\\n        if leftSubtreeSize is not None and rightSubtreeSize is not None:\\n            currentSubtreeSize = max(leftSubtreeSize, rightSubtreeSize) + 1\\n        elif leftSubtreeSize is not None:\\n            currentSubtreeSize = leftSubtreeSize + 1\\n        elif rightSubtreeSize is not None:\\n            currentSubtreeSize = rightSubtreeSize + 1\\n        else:\\n            currentSubtreeSize = 0\\n\\n        self.subtreeSize[root.val] = currentSubtreeSize\\n        self.maxSubtreeSize = max(self.maxSubtreeSize, currentSubtreeSize)\\n        return currentSubtreeSize\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        self.subtreeSize = {}\\n        self.maxSubtreeSize = 0\\n        self.dfs(root)\\n\\n        self.nodesLevels = {}\\n        self.levelsToSubtreeSizes = {}\\n        q = deque([(root, 0)])\\n        self.nodesLevels[root.val] = 0\\n\\n        while q:\\n            bfsLevel = q[0][1]\\n\\n            # For each level, save the Top 2 subtree sizes of the nodes\\n            if bfsLevel not in self.levelsToSubtreeSizes:\\n                top1Value, top2Value= -11, -12\\n                for node, _ in q:\\n                    size = self.subtreeSize[node.val]\\n                    if size > top1Value:\\n                        top1Value, top2Value = size, top1Value\\n                    elif size > top2Value:\\n                        top2Value = size\\n                # If the level only contains one node, then set top2 = -1\\n                if top2Value < 0:\\n                    top2Value = -1\\n                self.levelsToSubtreeSizes[bfsLevel] = (top1Value, top2Value)\\n            \\n            # Add children to BFS queue, and save their levels\\n            node, bfsLevel = q.popleft()\\n            if node.left:\\n                q.append((node.left, bfsLevel+1))\\n                self.nodesLevels[node.left.val] = bfsLevel+1\\n            if node.right:\\n                q.append((node.right, bfsLevel+1))\\n                self.nodesLevels[node.right.val] = bfsLevel+1\\n\\n        result = []\\n\\n        for nodeToDelete in queries:\\n            level = self.nodesLevels[nodeToDelete]\\n            nodeSize = self.subtreeSize[nodeToDelete]\\n            levelSubtreeSizes = self.levelsToSubtreeSizes[level]\\n            if nodeSize == levelSubtreeSizes[0]:\\n                # Since I delete the subtree corresponding to the highest level, then the highest level of the tree will change\\n                # If there is another node in the same level, then it will become the new longest path\\n                if levelSubtreeSizes[1] != -1:\\n                    result.append(level + levelSubtreeSizes[1])\\n                # If I delete the only child in this level, then the new height of the tree = level - 1\\n                else:\\n                    result.append(level - 1)\\n            else:\\n                # If I delete the node not belonging to the longest path, then the height of the tree doesn\\'t change\\n                result.append(self.maxSubtreeSize)\\n\\n        return result            \\n\\n    def dfs(self, root: TreeNode) -> int:\\n        # Post-order DFS\\n        leftSubtreeSize, rightSubtreeSize  = None, None\\n        if root.left:\\n            leftSubtreeSize = self.dfs(root.left)\\n        if root.right:\\n            rightSubtreeSize = self.dfs(root.right)\\n        \\n        # Calculate the height of the subtree belonging to the current node\\n        if leftSubtreeSize is not None and rightSubtreeSize is not None:\\n            currentSubtreeSize = max(leftSubtreeSize, rightSubtreeSize) + 1\\n        elif leftSubtreeSize is not None:\\n            currentSubtreeSize = leftSubtreeSize + 1\\n        elif rightSubtreeSize is not None:\\n            currentSubtreeSize = rightSubtreeSize + 1\\n        else:\\n            currentSubtreeSize = 0\\n\\n        self.subtreeSize[root.val] = currentSubtreeSize\\n        self.maxSubtreeSize = max(self.maxSubtreeSize, currentSubtreeSize)\\n        return currentSubtreeSize\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661788,
                "title": "c-tree-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nKeep the 1st Max height and 2nd Max height in that level\\n\\n# Complexity\\n- Time complexity: O(max(m, n))\\n\\n- Space complexity: O(n + m)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    unordered_map<int, int> mapLevel;\\n    unordered_map<int, int> mapHeigh;\\n    unordered_map<int, int> level1stMax;\\n    unordered_map<int, int> level2ndMax;\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int h = dfs(root, 0);\\n        int m = queries.size();\\n        int n = mapLevel.size();\\n        vector<int> ans(n+1, 0);\\n        vector<int> ret(m, 0);\\n\\n        for (int i = 1; i <= n; i++) {\\n            int l = mapLevel[i];\\n\\n            if (mapHeigh[i] != level1stMax[l]) \\n                ans[i] = level1stMax[l] + l - 1;\\n            else\\n                ans[i] = level2ndMax[l] + l - 1;\\n        }\\n\\n        for (int i = 0; i < m; i++) \\n            ret[i] = ans[queries[i]];\\n        \\n        return ret;\\n    }\\n\\n    int dfs(TreeNode* node, int level) {\\n        if (node == nullptr) \\n            return 0;\\n\\n        int l = dfs(node->left, level + 1);\\n        int r = dfs(node->right, level + 1);\\n        int h = max(l, r) + 1;\\n\\n        mapLevel[node->val] = level;\\n        mapHeigh[node->val] = h;\\n\\n        if (level1stMax[level] <= h) {\\n            level2ndMax[level] = level1stMax[level];\\n            level1stMax[level] = h;\\n        } else if (level2ndMax[level] < h) {\\n            level2ndMax[level] = h;\\n        }\\n\\n        return h;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    unordered_map<int, int> mapLevel;\\n    unordered_map<int, int> mapHeigh;\\n    unordered_map<int, int> level1stMax;\\n    unordered_map<int, int> level2ndMax;\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int h = dfs(root, 0);\\n        int m = queries.size();\\n        int n = mapLevel.size();\\n        vector<int> ans(n+1, 0);\\n        vector<int> ret(m, 0);\\n\\n        for (int i = 1; i <= n; i++) {\\n            int l = mapLevel[i];\\n\\n            if (mapHeigh[i] != level1stMax[l]) \\n                ans[i] = level1stMax[l] + l - 1;\\n            else\\n                ans[i] = level2ndMax[l] + l - 1;\\n        }\\n\\n        for (int i = 0; i < m; i++) \\n            ret[i] = ans[queries[i]];\\n        \\n        return ret;\\n    }\\n\\n    int dfs(TreeNode* node, int level) {\\n        if (node == nullptr) \\n            return 0;\\n\\n        int l = dfs(node->left, level + 1);\\n        int r = dfs(node->right, level + 1);\\n        int h = max(l, r) + 1;\\n\\n        mapLevel[node->val] = level;\\n        mapHeigh[node->val] = h;\\n\\n        if (level1stMax[level] <= h) {\\n            level2ndMax[level] = level1stMax[level];\\n            level1stMax[level] = h;\\n        } else if (level2ndMax[level] < h) {\\n            level2ndMax[level] = h;\\n        }\\n\\n        return h;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634912,
                "title": "dfs-hashmap-depth-height",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nheight after removal = depth to the node + max height for subtrees with the depth\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n`int[] height` -- height for each node, the path from the node to leaf.\\n`int[] depth` -- depth for each node, the path from root to the node.\\n`Map<Integer, List<Integer>> map` -- <depth, list of possible subtree height for the depth>, the list is sorted in decreasing order.\\n\\n# Complexity\\nn: number nodes in the tree\\nm: length of the queries\\n- Time complexity: O(n + m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n + m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    int[] depth = new int[100001];\\n    int[] height = new int[100001];\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        dfs(root, 0);\\n        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\\n            Collections.sort(entry.getValue(), (a, b) -> b - a);\\n        }\\n        int[] res = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int n = queries[i];\\n            int d = depth[n];\\n            int h = height[n];\\n            if (map.get(d).size() == 1) {\\n                res[i] = d - 1;\\n            } else if (map.get(d).get(0) == h) {\\n                res[i] = d + map.get(d).get(1);\\n            } else {\\n                res[i] = d + map.get(d).get(0);\\n            }\\n        }\\n        return res;\\n\\n    }\\n\\n    private int dfs(TreeNode root, int d) {\\n        if (root == null) return -1;\\n        int h = Math.max(dfs(root.left, d + 1), dfs(root.right, d + 1)) + 1;\\n        depth[root.val] = d;\\n        height[root.val] = h;\\n        map.computeIfAbsent(d, k -> new ArrayList<>()).add(h);\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    int[] depth = new int[100001];\\n    int[] height = new int[100001];\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        dfs(root, 0);\\n        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\\n            Collections.sort(entry.getValue(), (a, b) -> b - a);\\n        }\\n        int[] res = new int[queries.length];\\n        for (int i = 0; i < queries.length; i++) {\\n            int n = queries[i];\\n            int d = depth[n];\\n            int h = height[n];\\n            if (map.get(d).size() == 1) {\\n                res[i] = d - 1;\\n            } else if (map.get(d).get(0) == h) {\\n                res[i] = d + map.get(d).get(1);\\n            } else {\\n                res[i] = d + map.get(d).get(0);\\n            }\\n        }\\n        return res;\\n\\n    }\\n\\n    private int dfs(TreeNode root, int d) {\\n        if (root == null) return -1;\\n        int h = Math.max(dfs(root.left, d + 1), dfs(root.right, d + 1)) + 1;\\n        depth[root.val] = d;\\n        height[root.val] = h;\\n        map.computeIfAbsent(d, k -> new ArrayList<>()).add(h);\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620583,
                "title": "golang-dfs-solution-caching",
                "content": "# Intuition\\nSince we have multiple queries, we have to find a way to re-use the results of previous traversal.\\nSince all values in tree are unique, we can use a map data structure to cache data with value as key and the aim is to store the height of tree after removing current node in a map to get our answer\\n\\nResult of removing any node, depends on\\na. Depth from root to the parent + Height of subtree consisting of other child (Since we\\'re removing the current node, so height of it\\'s subtree is nullified)\\nb. Or what is max height of tree after removing the parent of current node\\n\\nE.g\\n```\\n        3\\n    1      4\\n2     5  6\\n    7\\n```\\nIn the above tree, if we want to remove node 6, then based on above formula\\na. depth from root to parent = 1 + no subtree for other child, so 0 + 1  = 1\\nb. max height after removing parent is 3 from the other subtree\\n\\nSo max of both comes out to be 3 which is the answer\\n\\nSimilarly if we remove node 5, then\\na. Depth from root to parent = 1 + height of subtree = 1, 1+1 = 2 including the left child i.e. 2\\nb. max height after removing parent is 2\\nSo max stays as 2\\n\\n# Approach\\nCalculate the height at each subtree and cache the results in a map using DFS\\n\\nStart traversing from root using DFS and propage the max height top down and cache the results of removing every node\\n1. If node\\'s left and right child are nil then max height after removing leaf node is max of (max height propagated from the previous call) and (depth)\\n2. If we\\'re removing left child, then max height is\\n    a. Depth + height of right subtree + 1 (to to include right node in height)\\n    b. Or max height propagated from previous call\\n3. Similar logic applies for right child\\n4. Propagate the max height calculated to the child elements\\n5. Once the precomputation is complete, loop over queries and construct the result array based on the calculated data\\n\\n# Complexity\\n- Time complexity:\\nO(n) as we visit every node once in 2 DFS\\n\\n- Space complexity:\\nO(n) as we store height and result from 2 DFS\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc calculateHeight(node *TreeNode, height map[int]int) int {\\n    if node == nil {\\n        return 0\\n    }\\n    if node.Left == nil && node.Right == nil {\\n        height[node.Val] = 0\\n        return 0\\n    }\\n    var lHeight, rHeight int\\n    if node.Left != nil {\\n        lHeight = calculateHeight(node.Left, height)\\n    }\\n    if node.Right != nil {\\n        rHeight = calculateHeight(node.Right, height)\\n    }\\n    height[node.Val] = max(lHeight, rHeight) + 1\\n    return height[node.Val]\\n}\\n\\nfunc treeQuery(node *TreeNode, query, height map[int]int, depth, maxheight int) {\\n    if node == nil {\\n        return\\n    }\\n    if node.Left == nil && node.Right == nil {\\n        query[node.Val] = max(depth, maxheight)\\n        return\\n    }\\n    if node.Left != nil {\\n        currHeight := depth\\n        if node.Right != nil { \\n            currHeight += height[node.Right.Val]+1\\n        }\\n        query[node.Left.Val] = max(currHeight, maxheight)\\n        treeQuery(node.Left, query, height, depth+1, query[node.Left.Val])\\n    }\\n    if node.Right != nil {\\n        currHeight := depth\\n        if node.Left != nil { \\n            currHeight += height[node.Left.Val] + 1\\n        }\\n        query[node.Right.Val] = max(currHeight, maxheight)\\n        treeQuery(node.Right, query, height, depth+1, query[node.Right.Val])\\n    }\\n}\\n\\nfunc max (a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc treeQueries(root *TreeNode, queries []int) []int {\\n    height, queryMap := map[int]int{}, map[int]int{}\\n    calculateHeight(root, height)\\n    treeQuery(root, queryMap, height, 0, 0)\\n    var result = make([]int, len(queries))\\n    for idx, query := range queries {\\n        result[idx] = queryMap[query]\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n        3\\n    1      4\\n2     5  6\\n    7\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc calculateHeight(node *TreeNode, height map[int]int) int {\\n    if node == nil {\\n        return 0\\n    }\\n    if node.Left == nil && node.Right == nil {\\n        height[node.Val] = 0\\n        return 0\\n    }\\n    var lHeight, rHeight int\\n    if node.Left != nil {\\n        lHeight = calculateHeight(node.Left, height)\\n    }\\n    if node.Right != nil {\\n        rHeight = calculateHeight(node.Right, height)\\n    }\\n    height[node.Val] = max(lHeight, rHeight) + 1\\n    return height[node.Val]\\n}\\n\\nfunc treeQuery(node *TreeNode, query, height map[int]int, depth, maxheight int) {\\n    if node == nil {\\n        return\\n    }\\n    if node.Left == nil && node.Right == nil {\\n        query[node.Val] = max(depth, maxheight)\\n        return\\n    }\\n    if node.Left != nil {\\n        currHeight := depth\\n        if node.Right != nil { \\n            currHeight += height[node.Right.Val]+1\\n        }\\n        query[node.Left.Val] = max(currHeight, maxheight)\\n        treeQuery(node.Left, query, height, depth+1, query[node.Left.Val])\\n    }\\n    if node.Right != nil {\\n        currHeight := depth\\n        if node.Left != nil { \\n            currHeight += height[node.Left.Val] + 1\\n        }\\n        query[node.Right.Val] = max(currHeight, maxheight)\\n        treeQuery(node.Right, query, height, depth+1, query[node.Right.Val])\\n    }\\n}\\n\\nfunc max (a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc treeQueries(root *TreeNode, queries []int) []int {\\n    height, queryMap := map[int]int{}, map[int]int{}\\n    calculateHeight(root, height)\\n    treeQuery(root, queryMap, height, 0, 0)\\n    var result = make([]int, len(queries))\\n    for idx, query := range queries {\\n        result[idx] = queryMap[query]\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3606541,
                "title": "it-works-decently",
                "content": "# Intuition\\nstore all the depths and heights. when removing a node just pop the heap for the depth the node is on to get max height. if the max height belongs to the current queried, pop it, get next max and then add it back.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        def dfs(node, depth=0):\\n            if not node:\\n                return 0\\n            height = max(dfs(node.left, depth + 1), dfs(node.right, depth + 1))\\n            heights[node.val] = depth\\n            heapq.heappush(depths[depth], (-height, node.val))\\n            \\n            return height + 1\\n\\n        # store node height at depth level\\n        depths = collections.defaultdict(list)\\n        heights = {}\\n        res = []\\n        dfs(root)\\n\\n        for q in queries:\\n            d = heights[q]\\n            max_h = d - 1\\n            to_add = None\\n            if depths[d][0][1] == q:\\n                to_add = heapq.heappop(depths[d])\\n            if depths[d]:\\n                max_h = max(max_h, d - depths[d][0][0])\\n            if to_add:\\n                heapq.heappush(depths[d], to_add)                \\n            res.append(max_h)\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        def dfs(node, depth=0):\\n            if not node:\\n                return 0\\n            height = max(dfs(node.left, depth + 1), dfs(node.right, depth + 1))\\n            heights[node.val] = depth\\n            heapq.heappush(depths[depth], (-height, node.val))\\n            \\n            return height + 1\\n\\n        # store node height at depth level\\n        depths = collections.defaultdict(list)\\n        heights = {}\\n        res = []\\n        dfs(root)\\n\\n        for q in queries:\\n            d = heights[q]\\n            max_h = d - 1\\n            to_add = None\\n            if depths[d][0][1] == q:\\n                to_add = heapq.heappop(depths[d])\\n            if depths[d]:\\n                max_h = max(max_h, d - depths[d][0][0])\\n            if to_add:\\n                heapq.heappush(depths[d], to_add)                \\n            res.append(max_h)\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593295,
                "title": "storing-height-in-each-level",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int[] left;\\n    int[] right;\\n    int[] remove;\\n\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        left = new int[100001];\\n        right = new int[100001];\\n        remove = new int[100001];\\n        traverse(root, 0);\\n        traverse1(root, 0);\\n        for (int i = 0; i < queries.length; i++) {\\n            queries[i] = remove[queries[i]];\\n        }\\n        return queries;\\n    }\\n\\n    public void traverse1(TreeNode root, int level) {\\n        if (root == null) return;\\n        remove[root.val] = level;\\n        traverse1(root.left, Math.max(right[root.val], level));\\n        traverse1(root.right, Math.max(left[root.val], level));\\n    }\\n\\n    public int traverse(TreeNode root, int level) {\\n        if (root == null) return level - 1;\\n        int leftVal = traverse(root.left, level + 1);\\n        int rightVal = traverse(root.right, level + 1);\\n        left[root.val] = leftVal;\\n        right[root.val] = rightVal;\\n        return Math.max(leftVal, rightVal);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int[] left;\\n    int[] right;\\n    int[] remove;\\n\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        left = new int[100001];\\n        right = new int[100001];\\n        remove = new int[100001];\\n        traverse(root, 0);\\n        traverse1(root, 0);\\n        for (int i = 0; i < queries.length; i++) {\\n            queries[i] = remove[queries[i]];\\n        }\\n        return queries;\\n    }\\n\\n    public void traverse1(TreeNode root, int level) {\\n        if (root == null) return;\\n        remove[root.val] = level;\\n        traverse1(root.left, Math.max(right[root.val], level));\\n        traverse1(root.right, Math.max(left[root.val], level));\\n    }\\n\\n    public int traverse(TreeNode root, int level) {\\n        if (root == null) return level - 1;\\n        int leftVal = traverse(root.left, level + 1);\\n        int rightVal = traverse(root.right, level + 1);\\n        left[root.val] = leftVal;\\n        right[root.val] = rightVal;\\n        return Math.max(leftVal, rightVal);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575328,
                "title": "easy-to-understand-cpp-solution-well-commented-code",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    // create a map\\n    // lvl -> mapping of given node to its level\\n    // height -> mapping of given node to its height(node based)\\n    // h1 -> mapping of level to the highest height at that level\\n    // h2 -> mapping of level to the second highest height at that level\\n    unordered_map<int,int> lvl, height, h1, h2;\\n    \\n    // create a dfs function that map our maps and return height\\n    int dfs(TreeNode* root, int level){\\n\\n        if (!root) return 0;\\n\\n        // map node to level\\n        lvl[root->val] = level;\\n\\n        int leftHeight = dfs(root->left, level+1);\\n        int rightHeight = dfs(root->right, level+1);\\n\\n        int nodeHeight = 1 + max(leftHeight, rightHeight);\\n\\n        // map level to max height at that level in h1 \\n        if (h1[level] < nodeHeight){\\n            h2[level] = h1[level];\\n            h1[level] = nodeHeight;\\n        }\\n\\n        // map level to second max height at that level in h2\\n        else if (h2[level] < nodeHeight){\\n            h2[level] = nodeHeight;\\n        }\\n\\n        // map value of root to height of node\\n        height[root->val] = nodeHeight;\\n\\n        return nodeHeight; \\n    }\\n\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        dfs(root, 0);\\n\\n        transform(begin(queries), end(queries), queries.begin(), [&](int node){\\n\\n            // find the level of given node\\n            int level = lvl[node];\\n\\n            // if the height of node is the maximum at that level\\n            if (h1[level] == height[node]){\\n                // then after removal of it the height of tree is \\n                // second max height + level - 1\\n                return h2[level] + level - 1;\\n            }else{\\n\\n                // max heigth + level - 1 (-1 for node base height)\\n                return h1[level] + level - 1;\\n            }\\n        });\\n\\n        // return answer\\n        return queries;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\n    // create a map\\n    // lvl -> mapping of given node to its level\\n    // height -> mapping of given node to its height(node based)\\n    // h1 -> mapping of level to the highest height at that level\\n    // h2 -> mapping of level to the second highest height at that level\\n    unordered_map<int,int> lvl, height, h1, h2;\\n    \\n    // create a dfs function that map our maps and return height\\n    int dfs(TreeNode* root, int level){\\n\\n        if (!root) return 0;\\n\\n        // map node to level\\n        lvl[root->val] = level;\\n\\n        int leftHeight = dfs(root->left, level+1);\\n        int rightHeight = dfs(root->right, level+1);\\n\\n        int nodeHeight = 1 + max(leftHeight, rightHeight);\\n\\n        // map level to max height at that level in h1 \\n        if (h1[level] < nodeHeight){\\n            h2[level] = h1[level];\\n            h1[level] = nodeHeight;\\n        }\\n\\n        // map level to second max height at that level in h2\\n        else if (h2[level] < nodeHeight){\\n            h2[level] = nodeHeight;\\n        }\\n\\n        // map value of root to height of node\\n        height[root->val] = nodeHeight;\\n\\n        return nodeHeight; \\n    }\\n\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        dfs(root, 0);\\n\\n        transform(begin(queries), end(queries), queries.begin(), [&](int node){\\n\\n            // find the level of given node\\n            int level = lvl[node];\\n\\n            // if the height of node is the maximum at that level\\n            if (h1[level] == height[node]){\\n                // then after removal of it the height of tree is \\n                // second max height + level - 1\\n                return h2[level] + level - 1;\\n            }else{\\n\\n                // max heigth + level - 1 (-1 for node base height)\\n                return h1[level] + level - 1;\\n            }\\n        });\\n\\n        // return answer\\n        return queries;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570788,
                "title": "c-solution-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int, pair<int, int>> mp;\\n    map<int, priority_queue<pair<int, int>, vector<pair<int, int>>>> lv;\\n\\n    int create(TreeNode* root, int level) {\\n        if (!root) return 0;\\n        int l = 0, r = 0;\\n        if (root->left) {\\n            l = create(root->left, level + 1);\\n        }\\n        if (root->right) {\\n            r = create(root->right, level + 1);\\n        }\\n        mp[root->val] = {max(l, r) + 1, level};\\n        lv[level].push({max(l, r) + 1, root->val});\\n        return max(l, r) + 1;\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        create(root, 0);\\n        vector<int> res;\\n        for (int q : queries) {\\n            int l = mp[q].second;\\n            int h = mp[q].first;\\n            int maxH = 0;\\n            if (lv[l].top().second != q) {\\n                res.push_back(l + lv[l].top().first - 1);\\n            } else if (lv[l].size() == 1) {\\n                res.push_back(l - 1);\\n            } else {\\n                pair<int, int> tp = lv[l].top();\\n                lv[l].pop();\\n                res.push_back(l + lv[l].top().first - 1);\\n                lv[l].push(tp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, pair<int, int>> mp;\\n    map<int, priority_queue<pair<int, int>, vector<pair<int, int>>>> lv;\\n\\n    int create(TreeNode* root, int level) {\\n        if (!root) return 0;\\n        int l = 0, r = 0;\\n        if (root->left) {\\n            l = create(root->left, level + 1);\\n        }\\n        if (root->right) {\\n            r = create(root->right, level + 1);\\n        }\\n        mp[root->val] = {max(l, r) + 1, level};\\n        lv[level].push({max(l, r) + 1, root->val});\\n        return max(l, r) + 1;\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        create(root, 0);\\n        vector<int> res;\\n        for (int q : queries) {\\n            int l = mp[q].second;\\n            int h = mp[q].first;\\n            int maxH = 0;\\n            if (lv[l].top().second != q) {\\n                res.push_back(l + lv[l].top().first - 1);\\n            } else if (lv[l].size() == 1) {\\n                res.push_back(l - 1);\\n            } else {\\n                pair<int, int> tp = lv[l].top();\\n                lv[l].pop();\\n                res.push_back(l + lv[l].top().first - 1);\\n                lv[l].push(tp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546171,
                "title": "easy-to-understand-with-comments-code-c-trees",
                "content": "# Code\\n```\\nclass Solution {\\n    int n = 0;\\n    int ht(TreeNode* root, vector<int> &height){\\n        if (!root) return 0;\\n        int l = ht(root->left,height);\\n        int r = ht(root->right,height);\\n        return height[root->val] = max(l,r) + 1;\\n    }\\n    void inorder(TreeNode* root){\\n        if (!root) return;\\n        inorder(root->left);\\n        n++;\\n        inorder(root->right);\\n        return;\\n    }\\n    vector<vector<int>> levelOrder(TreeNode* root, vector<int> &level, vector<int> height){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int l = 0;\\n        vector<vector<int>> ans;\\n        while (q.size()){\\n            int sz = q.size();\\n            vector<pair<int,int>> v;\\n            for (int i = 0; i < sz; i++){\\n                TreeNode* r = q.front();\\n                q.pop();\\n                v.push_back({height[r->val],r->val});\\n                level[r->val] = l;\\n                if (r->left) q.push(r->left);\\n                if (r->right) q.push(r->right);\\n            }\\n            l++;\\n            sort(v.rbegin(),v.rend());\\n            if (v.size() >= 2) ans.push_back({v[1].second,v[0].second});\\n            else ans.push_back({v[0].second});\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        // first calculate the number of nodes of tree\\n        inorder(root);\\n        // cout << n << endl;\\n\\n        // then calculate the the height of each and every subroot of tree\\n        vector<int> height(n + 1);\\n        ht(root,height);\\n\\n        // then calculate the level of each node in levelorder traversal and store the best 2 node in the of every level in the vector<vector<int>> levelHeight;\\n        // for example in test case 2 the heighest subroot of tree are \"2\" and \"1\"/\"3\"/\"7\" so at level 2 (0 based indexing) we store {7,2} heighest at 1 index and lowest at 0 index\\n        vector<int> level(n + 1);\\n        vector<vector<int>> levelHeight = levelOrder(root,level,height);\\n\\n        // for (auto x : height) cout << x << \" \";\\n\\n        vector<int> ans;\\n\\n        for (auto q : queries){\\n            // there can be level where the number of node could possibly be 1 here we have to return the height of tree minus height of the subtree\\n            if (levelHeight[level[q]].size() == 1){\\n                ans.push_back(height[root->val] - height[q] - 1);\\n            }else{\\n                // if the heighest node doesn\\'t match with the query q we will simply return the height of tree as removing subtree will not affect the height of tree\\n                if (levelHeight[level[q]][1] != q){\\n                    ans.push_back(height[root->val] - 1);\\n                }\\n                else{\\n                    // cout << levelHeight[level[q]][0] << \" \" << q << \"\\\\n\";\\n                    ans.push_back(level[levelHeight[level[q]][0]] + height[levelHeight[level[q]][0]] - 1);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int n = 0;\\n    int ht(TreeNode* root, vector<int> &height){\\n        if (!root) return 0;\\n        int l = ht(root->left,height);\\n        int r = ht(root->right,height);\\n        return height[root->val] = max(l,r) + 1;\\n    }\\n    void inorder(TreeNode* root){\\n        if (!root) return;\\n        inorder(root->left);\\n        n++;\\n        inorder(root->right);\\n        return;\\n    }\\n    vector<vector<int>> levelOrder(TreeNode* root, vector<int> &level, vector<int> height){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int l = 0;\\n        vector<vector<int>> ans;\\n        while (q.size()){\\n            int sz = q.size();\\n            vector<pair<int,int>> v;\\n            for (int i = 0; i < sz; i++){\\n                TreeNode* r = q.front();\\n                q.pop();\\n                v.push_back({height[r->val],r->val});\\n                level[r->val] = l;\\n                if (r->left) q.push(r->left);\\n                if (r->right) q.push(r->right);\\n            }\\n            l++;\\n            sort(v.rbegin(),v.rend());\\n            if (v.size() >= 2) ans.push_back({v[1].second,v[0].second});\\n            else ans.push_back({v[0].second});\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        // first calculate the number of nodes of tree\\n        inorder(root);\\n        // cout << n << endl;\\n\\n        // then calculate the the height of each and every subroot of tree\\n        vector<int> height(n + 1);\\n        ht(root,height);\\n\\n        // then calculate the level of each node in levelorder traversal and store the best 2 node in the of every level in the vector<vector<int>> levelHeight;\\n        // for example in test case 2 the heighest subroot of tree are \"2\" and \"1\"/\"3\"/\"7\" so at level 2 (0 based indexing) we store {7,2} heighest at 1 index and lowest at 0 index\\n        vector<int> level(n + 1);\\n        vector<vector<int>> levelHeight = levelOrder(root,level,height);\\n\\n        // for (auto x : height) cout << x << \" \";\\n\\n        vector<int> ans;\\n\\n        for (auto q : queries){\\n            // there can be level where the number of node could possibly be 1 here we have to return the height of tree minus height of the subtree\\n            if (levelHeight[level[q]].size() == 1){\\n                ans.push_back(height[root->val] - height[q] - 1);\\n            }else{\\n                // if the heighest node doesn\\'t match with the query q we will simply return the height of tree as removing subtree will not affect the height of tree\\n                if (levelHeight[level[q]][1] != q){\\n                    ans.push_back(height[root->val] - 1);\\n                }\\n                else{\\n                    // cout << levelHeight[level[q]][0] << \" \" << q << \"\\\\n\";\\n                    ans.push_back(level[levelHeight[level[q]][0]] + height[levelHeight[level[q]][0]] - 1);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3511338,
                "title": "c-solution-with-100-beat-on-memory-and-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\ntypedef struct TreeNode NODE;\\n\\nvoid compute(NODE * curr, int * comp, int * hlist, NODE* p, int height, NODE* sibnode, int level)\\n{\\n    if (curr == NULL)\\n        return;\\n    \\n    if (p == NULL)\\n        comp[curr->val] = -1;\\n    else if ((comp[p->val] == height) ||\\n                ((sibnode != NULL) &&\\n                (hlist[sibnode->val] >= hlist[curr->val])))\\n        comp[curr->val] = height;               \\n    else\\n    {\\n        /* (sibling height + parent node level + 1) > computed value of parent \\n         * then \"v1\"\" else \"comp[parent]\"\"\\n         * Parent level = level -1\\n         * Hence sh + (level -1) + 1 ==> sh + level */\\n        int v1 = ((sibnode == NULL) ? -1 : (hlist[sibnode->val])) + level;\\n        comp[curr->val] = comp[p->val] > v1 ? comp[p->val] : v1;\\n    }\\n\\n    compute(curr->left,  comp, hlist, curr, height, curr->right, level + 1);\\n    compute(curr->right, comp, hlist, curr, height, curr->left, level + 1);\\n}\\n\\nint traverse(NODE * curr, int * hlist)\\n{\\n    if (curr == NULL)\\n        return -1;\\n\\n    int h1 = traverse(curr->left, hlist);\\n    int h2 = traverse(curr->right, hlist);\\n\\n    hlist[curr->val] = ((h1 > h2) ? (h1) : (h2)) + 1;\\n\\n    return hlist[curr->val];\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* treeQueries(struct TreeNode* root, int* queries, int queriesSize, int* returnSize)\\n{\\n    * returnSize = 0;\\n\\n    int * answer = malloc(sizeof(int) * queriesSize);\\n    int * hlist  = malloc(sizeof(int) * 100001);\\n    int * comp = malloc(sizeof(int) * 100001);\\n\\n    int h = traverse(root, hlist);\\n\\n    compute(root, comp, hlist, NULL, h, NULL, 0);\\n\\n    for (int i = 0; i < queriesSize; i++)\\n    {\\n        (*returnSize) ++;\\n        answer[i] = comp[queries[i]];\\n    }\\n\\n    free(hlist);\\n    free(comp);\\n\\n    return answer;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\ntypedef struct TreeNode NODE;\\n\\nvoid compute(NODE * curr, int * comp, int * hlist, NODE* p, int height, NODE* sibnode, int level)\\n{\\n    if (curr == NULL)\\n        return;\\n    \\n    if (p == NULL)\\n        comp[curr->val] = -1;\\n    else if ((comp[p->val] == height) ||\\n                ((sibnode != NULL) &&\\n                (hlist[sibnode->val] >= hlist[curr->val])))\\n        comp[curr->val] = height;               \\n    else\\n    {\\n        /* (sibling height + parent node level + 1) > computed value of parent \\n         * then \"v1\"\" else \"comp[parent]\"\"\\n         * Parent level = level -1\\n         * Hence sh + (level -1) + 1 ==> sh + level */\\n        int v1 = ((sibnode == NULL) ? -1 : (hlist[sibnode->val])) + level;\\n        comp[curr->val] = comp[p->val] > v1 ? comp[p->val] : v1;\\n    }\\n\\n    compute(curr->left,  comp, hlist, curr, height, curr->right, level + 1);\\n    compute(curr->right, comp, hlist, curr, height, curr->left, level + 1);\\n}\\n\\nint traverse(NODE * curr, int * hlist)\\n{\\n    if (curr == NULL)\\n        return -1;\\n\\n    int h1 = traverse(curr->left, hlist);\\n    int h2 = traverse(curr->right, hlist);\\n\\n    hlist[curr->val] = ((h1 > h2) ? (h1) : (h2)) + 1;\\n\\n    return hlist[curr->val];\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* treeQueries(struct TreeNode* root, int* queries, int queriesSize, int* returnSize)\\n{\\n    * returnSize = 0;\\n\\n    int * answer = malloc(sizeof(int) * queriesSize);\\n    int * hlist  = malloc(sizeof(int) * 100001);\\n    int * comp = malloc(sizeof(int) * 100001);\\n\\n    int h = traverse(root, hlist);\\n\\n    compute(root, comp, hlist, NULL, h, NULL, 0);\\n\\n    for (int i = 0; i < queriesSize; i++)\\n    {\\n        (*returnSize) ++;\\n        answer[i] = comp[queries[i]];\\n    }\\n\\n    free(hlist);\\n    free(comp);\\n\\n    return answer;\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3470771,
                "title": "easy-to-understand-way-in-c",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    map<int, int> llvl, rlvl, hlvl;\\npublic:\\n    int  treeHeight(TreeNode* root) {\\n        if(!root) return 0;\\n        \\n        int leftVal = treeHeight(root->left);\\n        int rightVal = treeHeight(root->right);\\n        \\n        llvl[root->val] = leftVal;\\n        rlvl[root->val] = rightVal;\\n\\n        return 1 + max(leftVal, rightVal);\\n    }\\n\\n    void finalHight(TreeNode* root, int maxVal, int depth) {\\n        if(!root) return;\\n\\n        hlvl[root->val] = maxVal;\\n\\n        finalHight(root->left, max(maxVal, depth+rlvl[root->val]), depth+1);\\n        finalHight(root->right, max(maxVal, depth+llvl[root->val]), depth+1);\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int height = treeHeight(root);\\n        finalHight(root->left, rlvl[root->val], 1);\\n        finalHight(root->right, llvl[root->val], 1);\\n\\n        vector<int> ans; \\n        \\n        for(int q : queries) {\\n            int data = hlvl[q];\\n            ans.push_back(data);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    map<int, int> llvl, rlvl, hlvl;\\npublic:\\n    int  treeHeight(TreeNode* root) {\\n        if(!root) return 0;\\n        \\n        int leftVal = treeHeight(root->left);\\n        int rightVal = treeHeight(root->right);\\n        \\n        llvl[root->val] = leftVal;\\n        rlvl[root->val] = rightVal;\\n\\n        return 1 + max(leftVal, rightVal);\\n    }\\n\\n    void finalHight(TreeNode* root, int maxVal, int depth) {\\n        if(!root) return;\\n\\n        hlvl[root->val] = maxVal;\\n\\n        finalHight(root->left, max(maxVal, depth+rlvl[root->val]), depth+1);\\n        finalHight(root->right, max(maxVal, depth+llvl[root->val]), depth+1);\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int height = treeHeight(root);\\n        finalHight(root->left, rlvl[root->val], 1);\\n        finalHight(root->right, llvl[root->val], 1);\\n\\n        vector<int> ans; \\n        \\n        for(int q : queries) {\\n            int data = hlvl[q];\\n            ans.push_back(data);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467825,
                "title": "c-dfs-preprocess-to-record-level-and-height-info",
                "content": "```\\n//preprocess to record node level/height and max/2nd max sub tree height for each level\\nclass Solution {\\n    struct Max2  { int max = -1, max2 = -1; };\\n    unordered_map<int, Max2> level2heights; // max and 2nd max sub tree height with root on this level\\n    unordered_map<int, array<int,2>> node2levelheight; \\n    int dfs(TreeNode* node, int level) {\\n        if(!node) return 0;\\n\\n        int h = max(dfs(node->left, level+1) + !!node->left, dfs(node->right, level+1) + !!node->right);\\n        if(h > level2heights[level].max) {\\n            level2heights[level].max2 = level2heights[level].max;\\n            level2heights[level].max = h;\\n        }\\n        else if(h > level2heights[level].max2)\\n            level2heights[level].max2 = h;\\n\\n        node2levelheight[node->val] = {level, h};\\n        return h;\\n    }\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        dfs(root, 0);\\n        vector<int> ans;\\n        for(auto const& q : queries) {\\n            auto const& [level, h] = node2levelheight[q];\\n            int H = level2heights[level].max; \\n            if(h == H)\\n                H = level2heights[level].max2;  \\n            ans.push_back(level + H);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//preprocess to record node level/height and max/2nd max sub tree height for each level\\nclass Solution {\\n    struct Max2  { int max = -1, max2 = -1; };\\n    unordered_map<int, Max2> level2heights; // max and 2nd max sub tree height with root on this level\\n    unordered_map<int, array<int,2>> node2levelheight; \\n    int dfs(TreeNode* node, int level) {\\n        if(!node) return 0;\\n\\n        int h = max(dfs(node->left, level+1) + !!node->left, dfs(node->right, level+1) + !!node->right);\\n        if(h > level2heights[level].max) {\\n            level2heights[level].max2 = level2heights[level].max;\\n            level2heights[level].max = h;\\n        }\\n        else if(h > level2heights[level].max2)\\n            level2heights[level].max2 = h;\\n\\n        node2levelheight[node->val] = {level, h};\\n        return h;\\n    }\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        dfs(root, 0);\\n        vector<int> ans;\\n        for(auto const& q : queries) {\\n            auto const& [level, h] = node2levelheight[q];\\n            int H = level2heights[level].max; \\n            if(h == H)\\n                H = level2heights[level].max2;  \\n            ans.push_back(level + H);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427863,
                "title": "c-prefix-max-depth-with-preorder-dfs-easy-to-read",
                "content": "# Intuition\\nThe maxPath for each node value is the prefix maxDepth by iterating dfs from left side and the prefix maxDepth by iterating dfs from right side. We can use preorder DFS for that.\\n\\n\\n# Approach\\nFor each TreeNode value compute the maxDepth by iterating ones through the tree left side first, dfs and then again right side first dfs. Iterate over queries and lookup the maxPath for each query, add it to the results array.\\n\\n# Complexity\\n- Time complexity:\\nO(n) with n being the number of tree nodes.\\n\\n- Space complexity:\\nO(n) with n being the number of tree nodes.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> depthMap;\\n    int maxDepth = 0;\\n\\n    void buildLeftDepth(TreeNode* r, int d = 0) {\\n        if (!r) {\\n            return;\\n        }\\n        \\n        depthMap[r->val] = max(d - 1, maxDepth);\\n        maxDepth = max(maxDepth, d);\\n        \\n        buildLeftDepth(r->left, d + 1);\\n        buildLeftDepth(r->right, d + 1);\\n    }\\n\\n    void buildRightDepth(TreeNode* r, int d = 0) {\\n        if (!r) {\\n            return;\\n        }\\n        depthMap[r->val] = max(depthMap[r->val], max(d - 1, maxDepth));\\n        maxDepth = max(maxDepth, d);\\n        buildRightDepth(r->right, d + 1);\\n        buildRightDepth(r->left, d + 1);\\n    }\\n\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        // For each TreeNode value compute the maxDepth by iterating ones through the tree left side first, dfs and then again right side first dfs.\\n        buildLeftDepth(root);\\n        maxDepth = 0;\\n        buildRightDepth(root);\\n        // Iterate over queries and lookup the maxPath for each query, add it to the results array.\\n        vector<int> ans;\\n        for (auto query : queries) {\\n            ans.push_back(depthMap[query]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> depthMap;\\n    int maxDepth = 0;\\n\\n    void buildLeftDepth(TreeNode* r, int d = 0) {\\n        if (!r) {\\n            return;\\n        }\\n        \\n        depthMap[r->val] = max(d - 1, maxDepth);\\n        maxDepth = max(maxDepth, d);\\n        \\n        buildLeftDepth(r->left, d + 1);\\n        buildLeftDepth(r->right, d + 1);\\n    }\\n\\n    void buildRightDepth(TreeNode* r, int d = 0) {\\n        if (!r) {\\n            return;\\n        }\\n        depthMap[r->val] = max(depthMap[r->val], max(d - 1, maxDepth));\\n        maxDepth = max(maxDepth, d);\\n        buildRightDepth(r->right, d + 1);\\n        buildRightDepth(r->left, d + 1);\\n    }\\n\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        // For each TreeNode value compute the maxDepth by iterating ones through the tree left side first, dfs and then again right side first dfs.\\n        buildLeftDepth(root);\\n        maxDepth = 0;\\n        buildRightDepth(root);\\n        // Iterate over queries and lookup the maxPath for each query, add it to the results array.\\n        vector<int> ans;\\n        for (auto query : queries) {\\n            ans.push_back(depthMap[query]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427862,
                "title": "c-prefix-max-depth-with-preorder-dfs-easy-to-read",
                "content": "# Intuition\\nThe maxPath for each node value is the prefix maxDepth by iterating dfs from left side and the prefix maxDepth by iterating dfs from right side. We can use preorder DFS for that.\\n\\n\\n# Approach\\nFor each TreeNode value compute the maxDepth by iterating ones through the tree left side first, dfs and then again right side first dfs. Iterate over queries and lookup the maxPath for each query, add it to the results array.\\n\\n# Complexity\\n- Time complexity:\\nO(n) with n being the number of tree nodes.\\n\\n- Space complexity:\\nO(n) with n being the number of tree nodes.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> depthMap;\\n    int maxDepth = 0;\\n\\n    void buildLeftDepth(TreeNode* r, int d = 0) {\\n        if (!r) {\\n            return;\\n        }\\n        \\n        depthMap[r->val] = max(d - 1, maxDepth);\\n        maxDepth = max(maxDepth, d);\\n        \\n        buildLeftDepth(r->left, d + 1);\\n        buildLeftDepth(r->right, d + 1);\\n    }\\n\\n    void buildRightDepth(TreeNode* r, int d = 0) {\\n        if (!r) {\\n            return;\\n        }\\n        depthMap[r->val] = max(depthMap[r->val], max(d - 1, maxDepth));\\n        maxDepth = max(maxDepth, d);\\n        buildRightDepth(r->right, d + 1);\\n        buildRightDepth(r->left, d + 1);\\n    }\\n\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        // For each TreeNode value compute the maxDepth by iterating ones through the tree left side first, dfs and then again right side first dfs.\\n        buildLeftDepth(root);\\n        maxDepth = 0;\\n        buildRightDepth(root);\\n        // Iterate over queries and lookup the maxPath for each query, add it to the results array.\\n        vector<int> ans;\\n        for (auto query : queries) {\\n            ans.push_back(depthMap[query]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    unordered_map<int, int> depthMap;\\n    int maxDepth = 0;\\n\\n    void buildLeftDepth(TreeNode* r, int d = 0) {\\n        if (!r) {\\n            return;\\n        }\\n        \\n        depthMap[r->val] = max(d - 1, maxDepth);\\n        maxDepth = max(maxDepth, d);\\n        \\n        buildLeftDepth(r->left, d + 1);\\n        buildLeftDepth(r->right, d + 1);\\n    }\\n\\n    void buildRightDepth(TreeNode* r, int d = 0) {\\n        if (!r) {\\n            return;\\n        }\\n        depthMap[r->val] = max(depthMap[r->val], max(d - 1, maxDepth));\\n        maxDepth = max(maxDepth, d);\\n        buildRightDepth(r->right, d + 1);\\n        buildRightDepth(r->left, d + 1);\\n    }\\n\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        // For each TreeNode value compute the maxDepth by iterating ones through the tree left side first, dfs and then again right side first dfs.\\n        buildLeftDepth(root);\\n        maxDepth = 0;\\n        buildRightDepth(root);\\n        // Iterate over queries and lookup the maxPath for each query, add it to the results array.\\n        vector<int> ans;\\n        for (auto query : queries) {\\n            ans.push_back(depthMap[query]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405379,
                "title": "c-straightforward-dfs-bfs-1-d-array",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef struct TreeNode node;\\n\\ntypedef struct QueueNode\\n{\\n  node* add;\\n  int val;\\n  struct QueueNode* next;\\n}Qnode;\\n\\nint cal_and_store(node* root, int* depths, int* max)\\n{\\n  if(!root)\\n    return 0;\\n  int left_depth = cal_and_store(root->left, depths, max);\\n  int right_depth = cal_and_store(root->right, depths, max);\\n  depths[root->val - 1] = 1 + fmax(left_depth, right_depth);\\n  (*max) = (root->val > (*max))?root->val:(*max);\\n  return 1 + fmax(left_depth, right_depth);\\n}\\n\\nint* treeQueries(struct TreeNode* root, int* queries, int queriesSize, int* returnSize)\\n{\\n  int max = 0;\\n  int* depths = (int*)malloc(1000000 * sizeof(int));\\n  int tree_height = cal_and_store(root, depths, &max);\\n  depths = realloc(depths, max * sizeof(int));\\n  int* results = (int*)malloc(max * sizeof(int));\\n  int max1,max2;\\n  max1 = max2 = -1;\\n  Qnode* head = (Qnode*)malloc(sizeof(Qnode));\\n  head->add = root;\\n  head->val = root->val;\\n  head->next = NULL;\\n  Qnode* tail = head;\\n  int level = 1;\\n  int curr_step_reach = 1;\\n  int next_step_reach = 0;\\n  while(head && tail)\\n  {\\n    max1 = max2 = -1;\\n    Qnode* level_start = head;\\n    for(int i = 0; i < curr_step_reach;i++)\\n    {\\n      node* curr_add = head->add;\\n      int curr_val = head->val;\\n      if(depths[curr_val - 1] > max1)\\n      {\\n        max2 = max1;\\n        max1 = depths[curr_val - 1];\\n      }\\n      else if(depths[curr_val - 1] > max2)\\n        max2 = depths[curr_val - 1];\\n      if(curr_add->left)\\n      {\\n        Qnode* temp = (Qnode*)malloc(sizeof(Qnode));\\n        temp->add = curr_add->left;\\n        temp->val = curr_add->left->val;\\n        temp->next = NULL;\\n        tail->next = temp;\\n        tail = temp;\\n        next_step_reach++;\\n      }\\n      if(curr_add->right)\\n      {\\n        Qnode* temp = (Qnode*)malloc(sizeof(Qnode));\\n        temp->add = curr_add->right;\\n        temp->val = curr_add->right->val;\\n        temp->next = NULL;\\n        tail->next = temp;\\n        tail = temp;\\n        next_step_reach++;\\n      }\\n      head = head->next;    \\n    }\\n    if(curr_step_reach == 1)\\n      results[level_start->val - 1] = level - 2;\\n    else\\n    {\\n      for(int i = 0;i < curr_step_reach;i++)\\n      {\\n        int curr_val = level_start->val;\\n        if(depths[curr_val - 1] == max1)\\n          results[curr_val - 1] = level + max2 - 2;\\n        else\\n          results[curr_val - 1] = level + max1 - 2;\\n        level_start = level_start->next;\\n      }\\n    }\\n    level++;\\n    curr_step_reach = next_step_reach;\\n    next_step_reach = 0;\\n  }\\n  results[root->val - 1] = 0;\\n  *returnSize = queriesSize;\\n  int* ans = (int*)malloc(queriesSize * sizeof(int));\\n  for(int i = 0;i < queriesSize;i++)\\n    ans[i] = results[queries[i] - 1];\\n  return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct TreeNode node;\\n\\ntypedef struct QueueNode\\n{\\n  node* add;\\n  int val;\\n  struct QueueNode* next;\\n}Qnode;\\n\\nint cal_and_store(node* root, int* depths, int* max)\\n{\\n  if(!root)\\n    return 0;\\n  int left_depth = cal_and_store(root->left, depths, max);\\n  int right_depth = cal_and_store(root->right, depths, max);\\n  depths[root->val - 1] = 1 + fmax(left_depth, right_depth);\\n  (*max) = (root->val > (*max))?root->val:(*max);\\n  return 1 + fmax(left_depth, right_depth);\\n}\\n\\nint* treeQueries(struct TreeNode* root, int* queries, int queriesSize, int* returnSize)\\n{\\n  int max = 0;\\n  int* depths = (int*)malloc(1000000 * sizeof(int));\\n  int tree_height = cal_and_store(root, depths, &max);\\n  depths = realloc(depths, max * sizeof(int));\\n  int* results = (int*)malloc(max * sizeof(int));\\n  int max1,max2;\\n  max1 = max2 = -1;\\n  Qnode* head = (Qnode*)malloc(sizeof(Qnode));\\n  head->add = root;\\n  head->val = root->val;\\n  head->next = NULL;\\n  Qnode* tail = head;\\n  int level = 1;\\n  int curr_step_reach = 1;\\n  int next_step_reach = 0;\\n  while(head && tail)\\n  {\\n    max1 = max2 = -1;\\n    Qnode* level_start = head;\\n    for(int i = 0; i < curr_step_reach;i++)\\n    {\\n      node* curr_add = head->add;\\n      int curr_val = head->val;\\n      if(depths[curr_val - 1] > max1)\\n      {\\n        max2 = max1;\\n        max1 = depths[curr_val - 1];\\n      }\\n      else if(depths[curr_val - 1] > max2)\\n        max2 = depths[curr_val - 1];\\n      if(curr_add->left)\\n      {\\n        Qnode* temp = (Qnode*)malloc(sizeof(Qnode));\\n        temp->add = curr_add->left;\\n        temp->val = curr_add->left->val;\\n        temp->next = NULL;\\n        tail->next = temp;\\n        tail = temp;\\n        next_step_reach++;\\n      }\\n      if(curr_add->right)\\n      {\\n        Qnode* temp = (Qnode*)malloc(sizeof(Qnode));\\n        temp->add = curr_add->right;\\n        temp->val = curr_add->right->val;\\n        temp->next = NULL;\\n        tail->next = temp;\\n        tail = temp;\\n        next_step_reach++;\\n      }\\n      head = head->next;    \\n    }\\n    if(curr_step_reach == 1)\\n      results[level_start->val - 1] = level - 2;\\n    else\\n    {\\n      for(int i = 0;i < curr_step_reach;i++)\\n      {\\n        int curr_val = level_start->val;\\n        if(depths[curr_val - 1] == max1)\\n          results[curr_val - 1] = level + max2 - 2;\\n        else\\n          results[curr_val - 1] = level + max1 - 2;\\n        level_start = level_start->next;\\n      }\\n    }\\n    level++;\\n    curr_step_reach = next_step_reach;\\n    next_step_reach = 0;\\n  }\\n  results[root->val - 1] = 0;\\n  *returnSize = queriesSize;\\n  int* ans = (int*)malloc(queriesSize * sizeof(int));\\n  for(int i = 0;i < queriesSize;i++)\\n    ans[i] = results[queries[i] - 1];\\n  return ans;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3316702,
                "title": "c-euler-tour-segment-tree",
                "content": "```\\n/**\\n *Definition for a binary tree node.\\n *struct TreeNode {\\n *    int val;\\n *    TreeNode * left;\\n *    TreeNode * right;\\n *    TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n *};\\n */\\nclass Solution\\n{\\n    public:\\n    unordered_map<int, vector < int>> mp;\\n    vector<int> depth;\\n    vector<int> segTree;\\n    int timer = 0;\\n   void dfs(TreeNode *root, int lv)\\n    {\\n        if (root == NULL) return;\\n        depth[timer] = lv;\\n        mp[root->val].push_back(timer++);\\n        dfs(root->left, lv + 1);\\n        dfs(root->right, lv + 1);\\n        depth[timer] = lv;\\n        mp[root->val].push_back(timer++);\\n    }\\n    int count(TreeNode *root)\\n    {\\n        if (root == NULL) return 0;\\n        int left = count(root->left);\\n        int right = count(root->right);\\n        return 1 + left + right;\\n    }\\n    void build(int s, int e, int node, vector<int> &depth)\\n    {\\n        if (s == e)\\n        {\\n            segTree[node] = depth[s];\\n            return;\\n        }\\n        int mid = s + (e - s) / 2;\\n        build(s, mid, (node *2) + 1, depth);\\n        build(mid + 1, e, (node *2) + 2, depth);\\n        segTree[node] = max(segTree[(node *2) + 1], segTree[(node *2) + 2]);\\n    }\\n    int query(int l, int r, int s, int e, int node)\\n    {\\n        if (l <= s && e<= r) return segTree[node];\\n        if (r < s or e < l) return 0;\\n        int mid = s + (e - s) / 2;\\n        int q1 = query(l, r, s, mid, (node *2) + 1);\\n        int q2 = query(l, r, mid + 1, e, (node *2) + 2);\\n        return max(q1, q2);\\n    }\\n    vector<int> treeQueries(TreeNode *root, vector<int> &queries)\\n    {\\n        int nodes = count(root);\\n        int m = (nodes *2);\\n        depth.resize(m, 0);\\n        segTree.resize(m *4, 0);\\n        dfs(root, 0);\\n         build(0, m - 1, 0, depth);\\n        vector<int> res;\\n        for (auto &q: queries)\\n        {\\n            int removedNode = q;\\n            vector<int> xy = mp[removedNode];\\n            int left = xy[0];\\n            int right = xy[1];\\n            int leftHeight = query(0, left - 1, 0, m - 1, 0);\\n            int rightHeight = query(right + 1, m - 1, 0, m - 1, 0);\\n           res.push_back(max(leftHeight, rightHeight));\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n *Definition for a binary tree node.\\n *struct TreeNode {\\n *    int val;\\n *    TreeNode * left;\\n *    TreeNode * right;\\n *    TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n *};\\n */\\nclass Solution\\n{\\n    public:\\n    unordered_map<int, vector < int>> mp;\\n    vector<int> depth;\\n    vector<int> segTree;\\n    int timer = 0;\\n   void dfs(TreeNode *root, int lv)\\n    {\\n        if (root == NULL) return;\\n        depth[timer] = lv;\\n        mp[root->val].push_back(timer++);\\n        dfs(root->left, lv + 1);\\n        dfs(root->right, lv + 1);\\n        depth[timer] = lv;\\n        mp[root->val].push_back(timer++);\\n    }\\n    int count(TreeNode *root)\\n    {\\n        if (root == NULL) return 0;\\n        int left = count(root->left);\\n        int right = count(root->right);\\n        return 1 + left + right;\\n    }\\n    void build(int s, int e, int node, vector<int> &depth)\\n    {\\n        if (s == e)\\n        {\\n            segTree[node] = depth[s];\\n            return;\\n        }\\n        int mid = s + (e - s) / 2;\\n        build(s, mid, (node *2) + 1, depth);\\n        build(mid + 1, e, (node *2) + 2, depth);\\n        segTree[node] = max(segTree[(node *2) + 1], segTree[(node *2) + 2]);\\n    }\\n    int query(int l, int r, int s, int e, int node)\\n    {\\n        if (l <= s && e<= r) return segTree[node];\\n        if (r < s or e < l) return 0;\\n        int mid = s + (e - s) / 2;\\n        int q1 = query(l, r, s, mid, (node *2) + 1);\\n        int q2 = query(l, r, mid + 1, e, (node *2) + 2);\\n        return max(q1, q2);\\n    }\\n    vector<int> treeQueries(TreeNode *root, vector<int> &queries)\\n    {\\n        int nodes = count(root);\\n        int m = (nodes *2);\\n        depth.resize(m, 0);\\n        segTree.resize(m *4, 0);\\n        dfs(root, 0);\\n         build(0, m - 1, 0, depth);\\n        vector<int> res;\\n        for (auto &q: queries)\\n        {\\n            int removedNode = q;\\n            vector<int> xy = mp[removedNode];\\n            int left = xy[0];\\n            int right = xy[1];\\n            int leftHeight = query(0, left - 1, 0, m - 1, 0);\\n            int rightHeight = query(right + 1, m - 1, 0, m - 1, 0);\\n           res.push_back(max(leftHeight, rightHeight));\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307078,
                "title": "cpp-solution-dfs-1d-arrays-97-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int height[100001]={};\\n    int h_del[100001]={};\\nvoid del_dfs(TreeNode* root,int maxi,int h){\\n    if(root==nullptr)  return;\\n    int l=(root->left)?height[root->left->val]:0;\\n    int r=(root->right)?height[root->right->val]:0;\\n    if(root->left){ \\n        int ans=max(maxi,h+1+r);\\n        del_dfs(root->left,ans,h+1);\\n        h_del[root->left->val]=ans;\\n    }\\n    if(root->right){ \\n        int ans=max(maxi,h+1+l);\\n        del_dfs(root->right,ans,h+1);\\n        h_del[root->right->val]=ans;\\n    } \\n}\\n    int dfs(TreeNode* root,int h){\\n        if(root==nullptr) return 0;\\n        int l_s_h=0;\\n        if(root->left){\\n            l_s_h=dfs(root->left,h+1);\\n            height[root->left->val]=l_s_h;   \\n        }\\n        int r_s_h=0;\\n        if(root->right){\\n            r_s_h=dfs(root->right,h+1);\\n            height[root->right->val]=r_s_h;   \\n        }\\n        return 1+max(l_s_h,r_s_h);\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int m=queries.size();\\n        vector<int> ans(m,0);\\n        \\n        int h=dfs(root,-1);\\n        height[root->val]=h;\\n        del_dfs(root,-1,-1);\\n        for(int i=0;i<m;i++){\\n            ans[i]=h_del[queries[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int height[100001]={};\\n    int h_del[100001]={};\\nvoid del_dfs(TreeNode* root,int maxi,int h){\\n    if(root==nullptr)  return;\\n    int l=(root->left)?height[root->left->val]:0;\\n    int r=(root->right)?height[root->right->val]:0;\\n    if(root->left){ \\n        int ans=max(maxi,h+1+r);\\n        del_dfs(root->left,ans,h+1);\\n        h_del[root->left->val]=ans;\\n    }\\n    if(root->right){ \\n        int ans=max(maxi,h+1+l);\\n        del_dfs(root->right,ans,h+1);\\n        h_del[root->right->val]=ans;\\n    } \\n}\\n    int dfs(TreeNode* root,int h){\\n        if(root==nullptr) return 0;\\n        int l_s_h=0;\\n        if(root->left){\\n            l_s_h=dfs(root->left,h+1);\\n            height[root->left->val]=l_s_h;   \\n        }\\n        int r_s_h=0;\\n        if(root->right){\\n            r_s_h=dfs(root->right,h+1);\\n            height[root->right->val]=r_s_h;   \\n        }\\n        return 1+max(l_s_h,r_s_h);\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int m=queries.size();\\n        vector<int> ans(m,0);\\n        \\n        int h=dfs(root,-1);\\n        height[root->val]=h;\\n        del_dfs(root,-1,-1);\\n        for(int i=0;i<m;i++){\\n            ans[i]=h_del[queries[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306774,
                "title": "java-solution-from-huifeng-guan-youtube-video",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://www.youtube.com/watch?v=H-TnT5Z54RM\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int[] depth = new int[100005];\\n    int[] height = new int[100005];\\n    Map<Integer, List<Integer>> d2h = new HashMap();\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        dfsHeight(root, 0);\\n\\n        for (var entry: d2h.entrySet()) {\\n            List<Integer> tmp = entry.getValue();\\n            Collections.sort(tmp, Collections.reverseOrder());\\n            d2h.put(entry.getKey(), tmp);\\n        }\\n        int[] rets = new int[queries.length];\\n        int id = 0;\\n        for (int query: queries) {\\n            int h = height[query];\\n            int d = depth[query];\\n\\n            if (d2h.get(d).size() == 1) {\\n                rets[id] = d - 1;\\n            } else if (d2h.get(d).get(0) == h) {\\n                rets[id] = d2h.get(d).get(1) + d;\\n            } else if (d2h.get(d).get(0) != h) {\\n                rets[id] = d2h.get(d).get(0) + d;\\n            }\\n            id++;\\n        }\\n        return rets;\\n    }\\n\\n    private int dfsHeight(TreeNode node, int d) {\\n        if (node == null) return -1;\\n        int h = Math.max(dfsHeight(node.left, d+1), dfsHeight(node.right, d+1)) + 1;\\n        depth[node.val] = d;\\n        height[node.val] = h;\\n        List<Integer> tmp = d2h.getOrDefault(d, new ArrayList());\\n        tmp.add(h);\\n        d2h.put(d, tmp);\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int[] depth = new int[100005];\\n    int[] height = new int[100005];\\n    Map<Integer, List<Integer>> d2h = new HashMap();\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        dfsHeight(root, 0);\\n\\n        for (var entry: d2h.entrySet()) {\\n            List<Integer> tmp = entry.getValue();\\n            Collections.sort(tmp, Collections.reverseOrder());\\n            d2h.put(entry.getKey(), tmp);\\n        }\\n        int[] rets = new int[queries.length];\\n        int id = 0;\\n        for (int query: queries) {\\n            int h = height[query];\\n            int d = depth[query];\\n\\n            if (d2h.get(d).size() == 1) {\\n                rets[id] = d - 1;\\n            } else if (d2h.get(d).get(0) == h) {\\n                rets[id] = d2h.get(d).get(1) + d;\\n            } else if (d2h.get(d).get(0) != h) {\\n                rets[id] = d2h.get(d).get(0) + d;\\n            }\\n            id++;\\n        }\\n        return rets;\\n    }\\n\\n    private int dfsHeight(TreeNode node, int d) {\\n        if (node == null) return -1;\\n        int h = Math.max(dfsHeight(node.left, d+1), dfsHeight(node.right, d+1)) + 1;\\n        depth[node.val] = d;\\n        height[node.val] = h;\\n        List<Integer> tmp = d2h.getOrDefault(d, new ArrayList());\\n        tmp.add(h);\\n        d2h.put(d, tmp);\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299429,
                "title": "easy-to-understand-c-code",
                "content": "# Code\\n```\\nclass Solution {\\n    unordered_map<int, int> l, r, h;\\n\\n    int calHeight(TreeNode* root) {\\n        if(!root) return 0;\\n\\n        int leftHeight = calHeight(root->left);\\n        int rightHeight = calHeight(root->right);\\n\\n        l[root->val] = leftHeight;\\n        r[root->val] = rightHeight;\\n\\n        return 1 + max(leftHeight, rightHeight);\\n    }\\n\\n    void solve(TreeNode* root, int maxi, int depth) {\\n        if(!root) return;\\n\\n        int nodeRemoved = root->val;\\n        int maxHeight = maxi;\\n\\n        h[nodeRemoved] = maxHeight;\\n\\n        solve(root->left, max(maxi, depth + r[nodeRemoved]), depth+1);\\n        solve(root->right, max(maxi, depth + l[nodeRemoved]), depth+1);\\n    }\\n\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        calHeight(root);\\n\\n        solve(root->left, r[root->val], 1);\\n        solve(root->right, l[root->val], 1);\\n\\n        vector<int> ans;\\n        for(auto it: queries) {\\n            ans.push_back(h[it]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int, int> l, r, h;\\n\\n    int calHeight(TreeNode* root) {\\n        if(!root) return 0;\\n\\n        int leftHeight = calHeight(root->left);\\n        int rightHeight = calHeight(root->right);\\n\\n        l[root->val] = leftHeight;\\n        r[root->val] = rightHeight;\\n\\n        return 1 + max(leftHeight, rightHeight);\\n    }\\n\\n    void solve(TreeNode* root, int maxi, int depth) {\\n        if(!root) return;\\n\\n        int nodeRemoved = root->val;\\n        int maxHeight = maxi;\\n\\n        h[nodeRemoved] = maxHeight;\\n\\n        solve(root->left, max(maxi, depth + r[nodeRemoved]), depth+1);\\n        solve(root->right, max(maxi, depth + l[nodeRemoved]), depth+1);\\n    }\\n\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        calHeight(root);\\n\\n        solve(root->left, r[root->val], 1);\\n        solve(root->right, l[root->val], 1);\\n\\n        vector<int> ans;\\n        for(auto it: queries) {\\n            ans.push_back(h[it]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265218,
                "title": "python-beats-100-memory",
                "content": "# Intuition\\n<!-- Traverse through the tree once to store (node,height) for each node value. Also create a frequency dict of heights. Now for every query we just need to keep updating height dict with every node removal. Final height of tree is max height from height freq dict. If with a node removal its height freq becomes zero, then intuitively there won\\'t be any child nodes left with this node removal. So we can break loop there.-->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        result = []\\n        val_to_node = {}\\n        h_freq = collections.defaultdict(int)\\n\\n        queue = collections.deque()\\n        queue.append((root,0))\\n        while queue:\\n            node,height = queue.popleft()\\n            val_to_node[node.val] = (node,height)\\n            h_freq[height] += 1\\n            if node.left:\\n                queue.append((node.left,height+1))\\n            if node.right:\\n                queue.append((node.right,height+1))    \\n\\n        for query in queries:\\n            flag = 0\\n            node_h = h_freq.copy()\\n            queue = collections.deque()\\n            queue.append((val_to_node[query]))\\n            while queue:\\n                node,nh = queue.popleft()\\n                node_h[nh] -=1 #decrement freq of cur height\\n                if node_h[nh] == 0:\\n                    del node_h[nh]\\n                    result.append(nh-1)\\n                    flag =1 \\n                    break\\n                if node.left:\\n                    queue.append((node.left,nh+1))\\n                if node.right:\\n                    queue.append((node.right, nh +1))    \\n            if flag == 0:\\n                result.append(max(node_h.keys()))    \\n                        \\n        return result\\n            \\n\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        result = []\\n        val_to_node = {}\\n        h_freq = collections.defaultdict(int)\\n\\n        queue = collections.deque()\\n        queue.append((root,0))\\n        while queue:\\n            node,height = queue.popleft()\\n            val_to_node[node.val] = (node,height)\\n            h_freq[height] += 1\\n            if node.left:\\n                queue.append((node.left,height+1))\\n            if node.right:\\n                queue.append((node.right,height+1))    \\n\\n        for query in queries:\\n            flag = 0\\n            node_h = h_freq.copy()\\n            queue = collections.deque()\\n            queue.append((val_to_node[query]))\\n            while queue:\\n                node,nh = queue.popleft()\\n                node_h[nh] -=1 #decrement freq of cur height\\n                if node_h[nh] == 0:\\n                    del node_h[nh]\\n                    result.append(nh-1)\\n                    flag =1 \\n                    break\\n                if node.left:\\n                    queue.append((node.left,nh+1))\\n                if node.right:\\n                    queue.append((node.right, nh +1))    \\n            if flag == 0:\\n                result.append(max(node_h.keys()))    \\n                        \\n        return result\\n            \\n\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249288,
                "title": "c-preprocess-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        withDepth(root, 0);\\n        withoutDepth(root->left, root, 0);\\n        withoutDepth(root->right, root, 0);\\n\\n        vector<int> res;\\n        for(auto q:queries) res.push_back(withoutDepths[q]);\\n        return res;\\n    }\\n\\n    int withDepth(TreeNode* p, int dep){\\n        if(!p) return 0;\\n        auto l = withDepth(p->left, 1+dep), r = withDepth(p->right, 1+dep);\\n        int withDep = max({dep, l, r});\\n        depths[p->val] = dep;\\n        withDepths[p->val] = withDep;\\n        return withDep;\\n    }\\n\\n    void withoutDepth(TreeNode* p, TreeNode* par, int ParWithoutDepth){\\n        if(!p) return;\\n        int res = max(ParWithoutDepth, depths[par->val]);\\n        TreeNode* q =  par->left == p ? par->right : par->left;\\n        if(q) res = max(res, withDepths[q->val]);\\n        withoutDepths[p->val] = res;\\n        withoutDepth(p->left, p, res);\\n        withoutDepth(p->right, p, res);\\n    }\\n\\n    unordered_map<int, int> withoutDepths;\\n    unordered_map<int, int> withDepths;\\n    unordered_map<int, int> depths;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        withDepth(root, 0);\\n        withoutDepth(root->left, root, 0);\\n        withoutDepth(root->right, root, 0);\\n\\n        vector<int> res;\\n        for(auto q:queries) res.push_back(withoutDepths[q]);\\n        return res;\\n    }\\n\\n    int withDepth(TreeNode* p, int dep){\\n        if(!p) return 0;\\n        auto l = withDepth(p->left, 1+dep), r = withDepth(p->right, 1+dep);\\n        int withDep = max({dep, l, r});\\n        depths[p->val] = dep;\\n        withDepths[p->val] = withDep;\\n        return withDep;\\n    }\\n\\n    void withoutDepth(TreeNode* p, TreeNode* par, int ParWithoutDepth){\\n        if(!p) return;\\n        int res = max(ParWithoutDepth, depths[par->val]);\\n        TreeNode* q =  par->left == p ? par->right : par->left;\\n        if(q) res = max(res, withDepths[q->val]);\\n        withoutDepths[p->val] = res;\\n        withoutDepth(p->left, p, res);\\n        withoutDepth(p->right, p, res);\\n    }\\n\\n    unordered_map<int, int> withoutDepths;\\n    unordered_map<int, int> withDepths;\\n    unordered_map<int, int> depths;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192978,
                "title": "fresh-approach-never-discussed-before-using-javascript-beats-94-44-in-rintime",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nvar treeQueries = function (root, queries) {\\n    const heights = {};\\n    let maxHeight = -Infinity\\n    function updateHeights(node) {\\n        let currentNodeHeight;\\n\\n        if (node.left === null && node.right === null)\\n            currentNodeHeight = 0;\\n        else if (node.right === null)\\n            currentNodeHeight = 1 + updateHeights(node.left);\\n        else if (node.left === null)\\n            currentNodeHeight = 1 + updateHeights(node.right);\\n        else\\n            currentNodeHeight = 1 + Math.max(updateHeights(node.left), updateHeights(node.right));\\n\\n        if (maxHeight < currentNodeHeight) maxHeight = currentNodeHeight;\\n        heights[node.val] = currentNodeHeight;\\n        return currentNodeHeight;\\n    }\\n    updateHeights(root);\\n\\n    const heightsAfterNodeRemoval = {};\\n    function updateHeightsAfterRemoval(node, level = 0, bestAlternateHeight = -Infinity) {\\n        if (node.left === null && node.right === null)\\n            return;\\n\\n        if (node.left !== null && node.right === null) {\\n            if (bestAlternateHeight < level)\\n                bestAlternateHeight = level;\\n            heightsAfterNodeRemoval[node.left.val] = bestAlternateHeight;\\n            return updateHeightsAfterRemoval(node.left, level + 1, bestAlternateHeight);\\n        }\\n\\n        if (node.left === null && node.right !== null) {\\n            if (bestAlternateHeight < level)\\n                bestAlternateHeight = level;\\n            heightsAfterNodeRemoval[node.right.val] = bestAlternateHeight;\\n            return updateHeightsAfterRemoval(node.right, level + 1, bestAlternateHeight);\\n        }\\n\\n        const rootToLeafHeightOnLeftNodePath = level + heights[node.left.val] + 1;\\n        const rootToLeafHeightOnRightNodePath = level + heights[node.right.val] + 1;\\n\\n        if (rootToLeafHeightOnLeftNodePath === rootToLeafHeightOnRightNodePath) return;\\n\\n        if (rootToLeafHeightOnLeftNodePath > rootToLeafHeightOnRightNodePath) {\\n            if (bestAlternateHeight < rootToLeafHeightOnRightNodePath)\\n                bestAlternateHeight = rootToLeafHeightOnRightNodePath\\n            heightsAfterNodeRemoval[node.left.val] = bestAlternateHeight;\\n            return updateHeightsAfterRemoval(node.left, level + 1, bestAlternateHeight);\\n        } else {\\n            if (bestAlternateHeight < rootToLeafHeightOnLeftNodePath)\\n                bestAlternateHeight = rootToLeafHeightOnLeftNodePath;\\n            heightsAfterNodeRemoval[node.right.val] = bestAlternateHeight;\\n            return updateHeightsAfterRemoval(node.right, level + 1, bestAlternateHeight);\\n        }\\n\\n    }\\n    updateHeightsAfterRemoval(root);\\n    return queries.map((item) => heightsAfterNodeRemoval[item] !== undefined ? heightsAfterNodeRemoval[item] : maxHeight);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar treeQueries = function (root, queries) {\\n    const heights = {};\\n    let maxHeight = -Infinity\\n    function updateHeights(node) {\\n        let currentNodeHeight;\\n\\n        if (node.left === null && node.right === null)\\n            currentNodeHeight = 0;\\n        else if (node.right === null)\\n            currentNodeHeight = 1 + updateHeights(node.left);\\n        else if (node.left === null)\\n            currentNodeHeight = 1 + updateHeights(node.right);\\n        else\\n            currentNodeHeight = 1 + Math.max(updateHeights(node.left), updateHeights(node.right));\\n\\n        if (maxHeight < currentNodeHeight) maxHeight = currentNodeHeight;\\n        heights[node.val] = currentNodeHeight;\\n        return currentNodeHeight;\\n    }\\n    updateHeights(root);\\n\\n    const heightsAfterNodeRemoval = {};\\n    function updateHeightsAfterRemoval(node, level = 0, bestAlternateHeight = -Infinity) {\\n        if (node.left === null && node.right === null)\\n            return;\\n\\n        if (node.left !== null && node.right === null) {\\n            if (bestAlternateHeight < level)\\n                bestAlternateHeight = level;\\n            heightsAfterNodeRemoval[node.left.val] = bestAlternateHeight;\\n            return updateHeightsAfterRemoval(node.left, level + 1, bestAlternateHeight);\\n        }\\n\\n        if (node.left === null && node.right !== null) {\\n            if (bestAlternateHeight < level)\\n                bestAlternateHeight = level;\\n            heightsAfterNodeRemoval[node.right.val] = bestAlternateHeight;\\n            return updateHeightsAfterRemoval(node.right, level + 1, bestAlternateHeight);\\n        }\\n\\n        const rootToLeafHeightOnLeftNodePath = level + heights[node.left.val] + 1;\\n        const rootToLeafHeightOnRightNodePath = level + heights[node.right.val] + 1;\\n\\n        if (rootToLeafHeightOnLeftNodePath === rootToLeafHeightOnRightNodePath) return;\\n\\n        if (rootToLeafHeightOnLeftNodePath > rootToLeafHeightOnRightNodePath) {\\n            if (bestAlternateHeight < rootToLeafHeightOnRightNodePath)\\n                bestAlternateHeight = rootToLeafHeightOnRightNodePath\\n            heightsAfterNodeRemoval[node.left.val] = bestAlternateHeight;\\n            return updateHeightsAfterRemoval(node.left, level + 1, bestAlternateHeight);\\n        } else {\\n            if (bestAlternateHeight < rootToLeafHeightOnLeftNodePath)\\n                bestAlternateHeight = rootToLeafHeightOnLeftNodePath;\\n            heightsAfterNodeRemoval[node.right.val] = bestAlternateHeight;\\n            return updateHeightsAfterRemoval(node.right, level + 1, bestAlternateHeight);\\n        }\\n\\n    }\\n    updateHeightsAfterRemoval(root);\\n    return queries.map((item) => heightsAfterNodeRemoval[item] !== undefined ? heightsAfterNodeRemoval[item] : maxHeight);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3191304,
                "title": "easy-c-solution-using-map-bfs-dfs-and-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,int> h;\\n    int dfs(TreeNode* root)\\n    {\\n        if(!root)\\n            return 1;\\n        int a=dfs(root->left),b=dfs(root->right);\\n        h[root->val]=max(a,b);\\n        return h[root->val]+1;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int> ans;\\n        h[root->val]=max(dfs(root->left),dfs(root->right));\\n        int hh=h[root->val],c=0;\\n        map<int,int> lvl;\\n        map<int,pair<int,int>> lo;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            priority_queue<int> pq;\\n            while(s--)\\n            {\\n                TreeNode *a=q.front();\\n                q.pop();\\n                lvl[a->val]=c;\\n                pq.push(h[a->val]);\\n                if(a->left)\\n                    q.push(a->left);\\n                if(a->right)\\n                    q.push(a->right);\\n            }\\n            int a=pq.top();\\n            pq.pop();\\n            int b;\\n            if(pq.empty())\\n               b=0;\\n            else\\n               b=pq.top();\\n            lo[c]={a,b};\\n            c++;\\n        }\\n        for(auto t: queries)\\n        {\\n            int l=lvl[t];\\n            int a=lo[l].first,b=lo[l].second;\\n            if(a==h[t])\\n               ans.push_back(hh-(a-b)-1);\\n            else\\n               ans.push_back(hh-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> h;\\n    int dfs(TreeNode* root)\\n    {\\n        if(!root)\\n            return 1;\\n        int a=dfs(root->left),b=dfs(root->right);\\n        h[root->val]=max(a,b);\\n        return h[root->val]+1;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int> ans;\\n        h[root->val]=max(dfs(root->left),dfs(root->right));\\n        int hh=h[root->val],c=0;\\n        map<int,int> lvl;\\n        map<int,pair<int,int>> lo;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            int s=q.size();\\n            priority_queue<int> pq;\\n            while(s--)\\n            {\\n                TreeNode *a=q.front();\\n                q.pop();\\n                lvl[a->val]=c;\\n                pq.push(h[a->val]);\\n                if(a->left)\\n                    q.push(a->left);\\n                if(a->right)\\n                    q.push(a->right);\\n            }\\n            int a=pq.top();\\n            pq.pop();\\n            int b;\\n            if(pq.empty())\\n               b=0;\\n            else\\n               b=pq.top();\\n            lo[c]={a,b};\\n            c++;\\n        }\\n        for(auto t: queries)\\n        {\\n            int l=lvl[t];\\n            int a=lo[l].first,b=lo[l].second;\\n            if(a==h[t])\\n               ans.push_back(hh-(a-b)-1);\\n            else\\n               ans.push_back(hh-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166482,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nstruct SegmentTree {\\n#define lc (C << 1)\\n#define rc (C << 1 | 1)\\n#define M ((L+R)>>1)\\n  struct data {\\n    int sum;\\n    data() :sum(0) {};\\n  };\\n  vector<data>st;\\n  int N;\\n  SegmentTree(int _N) :N(_N) {\\n    st.resize(4 * N);\\n  }\\n  void combine(data& cur, data& l, data& r) {\\n    cur.sum = max(l.sum,r.sum);\\n  }\\n  data Query(int i, int j, int C, int L, int R) {\\n    if (j < L || i > R || L > R) return data();\\n    if (i <= L && R <= j) return st[C];\\n    data ret;\\n    data d1 = Query(i, j, lc, L, M);\\n    data d2 = Query(i, j, rc, M + 1, R);\\n    combine(ret, d1, d2);\\n    return ret;\\n  }\\n  void Update(int i, int j, int val, int C, int L, int R) {\\n    if (j < L || i > R || L > R) return;\\n    if (i <= L && R <= j) {\\n      st[C].sum = val;\\n      return;\\n    }\\n    Update(i, j, val, lc, L, M);\\n    Update(i, j, val, rc, M + 1, R);\\n    combine(st[C], st[lc], st[rc]);\\n  }\\n  void Update(int i, int j, int val) {\\n    Update(i, j, val, 1, 1, N);\\n  }\\n  int Query(int i, int j) {\\n    return Query(i, j, 1, 1, N).sum;\\n  }\\n};\\nclass Solution {\\npublic: \\n    int startTime[100001],endTime[100001];\\n    int arr[100001];\\n    int T;\\n    void dfs(TreeNode* root,int d){\\n        ++T;\\n        startTime[root->val] = T;\\n        arr[T] = d;\\n        if(root->left!=nullptr)dfs(root->left,d+1);\\n        if(root->right!=nullptr) dfs(root->right,d+1);\\n        endTime[root->val] = T;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        T = 0;\\n        dfs(root,0);\\n        SegmentTree st(T);\\n        for(int i=1;i<=T;i++){\\n            st.Update(i,i,arr[i]);\\n        }\\n        vector<int>ret;\\n        for(int&x:queries){\\n            int from = startTime[x];\\n            int till = endTime[x];\\n            int a = st.Query(1,from-1);\\n            int b = st.Query(till+1,T);\\n            ret.push_back(max(a,b));\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nstruct SegmentTree {\\n#define lc (C << 1)\\n#define rc (C << 1 | 1)\\n#define M ((L+R)>>1)\\n  struct data {\\n    int sum;\\n    data() :sum(0) {};\\n  };\\n  vector<data>st;\\n  int N;\\n  SegmentTree(int _N) :N(_N) {\\n    st.resize(4 * N);\\n  }\\n  void combine(data& cur, data& l, data& r) {\\n    cur.sum = max(l.sum,r.sum);\\n  }\\n  data Query(int i, int j, int C, int L, int R) {\\n    if (j < L || i > R || L > R) return data();\\n    if (i <= L && R <= j) return st[C];\\n    data ret;\\n    data d1 = Query(i, j, lc, L, M);\\n    data d2 = Query(i, j, rc, M + 1, R);\\n    combine(ret, d1, d2);\\n    return ret;\\n  }\\n  void Update(int i, int j, int val, int C, int L, int R) {\\n    if (j < L || i > R || L > R) return;\\n    if (i <= L && R <= j) {\\n      st[C].sum = val;\\n      return;\\n    }\\n    Update(i, j, val, lc, L, M);\\n    Update(i, j, val, rc, M + 1, R);\\n    combine(st[C], st[lc], st[rc]);\\n  }\\n  void Update(int i, int j, int val) {\\n    Update(i, j, val, 1, 1, N);\\n  }\\n  int Query(int i, int j) {\\n    return Query(i, j, 1, 1, N).sum;\\n  }\\n};\\nclass Solution {\\npublic: \\n    int startTime[100001],endTime[100001];\\n    int arr[100001];\\n    int T;\\n    void dfs(TreeNode* root,int d){\\n        ++T;\\n        startTime[root->val] = T;\\n        arr[T] = d;\\n        if(root->left!=nullptr)dfs(root->left,d+1);\\n        if(root->right!=nullptr) dfs(root->right,d+1);\\n        endTime[root->val] = T;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        T = 0;\\n        dfs(root,0);\\n        SegmentTree st(T);\\n        for(int i=1;i<=T;i++){\\n            st.Update(i,i,arr[i]);\\n        }\\n        vector<int>ret;\\n        for(int&x:queries){\\n            int from = startTime[x];\\n            int till = endTime[x];\\n            int a = st.Query(1,from-1);\\n            int b = st.Query(till+1,T);\\n            ret.push_back(max(a,b));\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136604,
                "title": "c-two-traversals-one-for-height-and-the-other-to-pass-maxht-to-children",
                "content": "This is the idea for this problem:\\n1. Do a preliminary traversal to get the heights of each subtree and store it in `ht`\\n2. Pass the max height achievable so far to each Node during the second traversal, updating the `htWithout` for the children.\\n3. For each node u:\\n\\t* For the left child, the max height achievable is the longer path between the max before and the path involving u and going down the right child.\\n\\t* Vice versa for the right child\\n\\nWe now have the max height without each respective node, and we can answer the queries in O(1).\\n\\nThere is a mild optimization that can be made here, by making htWithout a vector, and initializing it as after the first traversal with `htWithout.assign(ht.size()+1,0);`. This cuts the runtime by about 50%\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // ht[i] = Height of subtree rooted at i\\n    unordered_map<int,int> ht;\\n    // htWithout[i] = Height of tree without subtree rooted at i\\n    unordered_map<int,int> htWithout;\\n    \\n    // First traversal to get heights\\n    int getHts(TreeNode* u){\\n        if(!u) return -1;\\n        return ht[u->val] = 1+max(getHts(u->left), getHts(u->right));\\n    }\\n    \\n    // Second traveral to pass down the maxHt from the other subtree\\n    void getHtsWithout(TreeNode* u, int maxHt, int depth){\\n        int leftHt = u->left ? 1 + ht[u->left->val] : 0;\\n        int rightHt = u->right ? 1 + ht[u->right->val] : 0;\\n        \\n        // If there is a left child, set htWithout to be the max of maxHt seen so far and the path involving the right child\\n        if(u->left){\\n            int newMax = max(maxHt,depth + rightHt);\\n            htWithout[u->left->val] = newMax;\\n            getHtsWithout(u->left, newMax, depth+1);\\n        }\\n        \\n        // If there is a right child, set htWithout to be the max of maxHt seen so far and the path involving the left child\\n        if(u->right){\\n            int newMax = max(maxHt,depth + leftHt);\\n            htWithout[u->right->val] = newMax;\\n            getHtsWithout(u->right, newMax, depth+1);\\n        }\\n    }\\n    \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        getHts(root);\\n        getHtsWithout(root,0,0);\\n        vector<int> ans;\\n        for(auto&q:queries) ans.push_back(htWithout[q]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // ht[i] = Height of subtree rooted at i\\n    unordered_map<int,int> ht;\\n    // htWithout[i] = Height of tree without subtree rooted at i\\n    unordered_map<int,int> htWithout;\\n    \\n    // First traversal to get heights\\n    int getHts(TreeNode* u){\\n        if(!u) return -1;\\n        return ht[u->val] = 1+max(getHts(u->left), getHts(u->right));\\n    }\\n    \\n    // Second traveral to pass down the maxHt from the other subtree\\n    void getHtsWithout(TreeNode* u, int maxHt, int depth){\\n        int leftHt = u->left ? 1 + ht[u->left->val] : 0;\\n        int rightHt = u->right ? 1 + ht[u->right->val] : 0;\\n        \\n        // If there is a left child, set htWithout to be the max of maxHt seen so far and the path involving the right child\\n        if(u->left){\\n            int newMax = max(maxHt,depth + rightHt);\\n            htWithout[u->left->val] = newMax;\\n            getHtsWithout(u->left, newMax, depth+1);\\n        }\\n        \\n        // If there is a right child, set htWithout to be the max of maxHt seen so far and the path involving the left child\\n        if(u->right){\\n            int newMax = max(maxHt,depth + leftHt);\\n            htWithout[u->right->val] = newMax;\\n            getHtsWithout(u->right, newMax, depth+1);\\n        }\\n    }\\n    \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        getHts(root);\\n        getHtsWithout(root,0,0);\\n        vector<int> ans;\\n        for(auto&q:queries) ans.push_back(htWithout[q]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3109972,
                "title": "c-two-dfs-rounds-with-different-orders",
                "content": "First DFS: traverse the left child then the right child\\nSecond DFS: traverse the right child than the left child\\n\\n```cpp\\nclass Solution {\\npublic:\\n\\tvector<int> treeQueries(TreeNode *root, vector<int> &queries) {\\n\\t\\tmap<int, int> m;\\n\\t\\tint sofar = 0;\\n\\t\\tfunction<void(TreeNode *, int)> dfs1 = [&](TreeNode *node, int level) {\\n\\t\\t\\tm[node->val] = max(m[node->val], sofar);\\n\\t\\t\\tsofar = max(sofar, level);\\n\\t\\t\\tif (node->left != nullptr) dfs1(node->left, level + 1);\\n\\t\\t\\tif (node->right != nullptr) dfs1(node->right, level + 1);\\n\\t\\t};\\n\\t\\tdfs1(root, 0);\\n\\t\\tsofar = 0;\\n\\t\\tfunction<void(TreeNode *, int)> dfs2 = [&](TreeNode *node, int level) {\\n\\t\\t\\tm[node->val] = max(m[node->val], sofar);\\n\\t\\t\\tsofar = max(sofar, level);\\n\\t\\t\\tif (node->right != nullptr) dfs2(node->right, level + 1);\\n\\t\\t\\tif (node->left != nullptr) dfs2(node->left, level + 1);\\n\\t\\t};\\n\\t\\tdfs2(root, 0);\\n\\t\\tvector<int> ans;\\n\\t\\tfor (auto x: queries) ans.push_back(m[x]);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n\\tvector<int> treeQueries(TreeNode *root, vector<int> &queries) {\\n\\t\\tmap<int, int> m;\\n\\t\\tint sofar = 0;\\n\\t\\tfunction<void(TreeNode *, int)> dfs1 = [&](TreeNode *node, int level) {\\n\\t\\t\\tm[node->val] = max(m[node->val], sofar);\\n\\t\\t\\tsofar = max(sofar, level);\\n\\t\\t\\tif (node->left != nullptr) dfs1(node->left, level + 1);\\n\\t\\t\\tif (node->right != nullptr) dfs1(node->right, level + 1);\\n\\t\\t};\\n\\t\\tdfs1(root, 0);\\n\\t\\tsofar = 0;\\n\\t\\tfunction<void(TreeNode *, int)> dfs2 = [&](TreeNode *node, int level) {\\n\\t\\t\\tm[node->val] = max(m[node->val], sofar);\\n\\t\\t\\tsofar = max(sofar, level);\\n\\t\\t\\tif (node->right != nullptr) dfs2(node->right, level + 1);\\n\\t\\t\\tif (node->left != nullptr) dfs2(node->left, level + 1);\\n\\t\\t};\\n\\t\\tdfs2(root, 0);\\n\\t\\tvector<int> ans;\\n\\t\\tfor (auto x: queries) ans.push_back(m[x]);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101098,
                "title": "c-double-dfs-traversal",
                "content": "# Intuition\\nPorted from Java from: https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/solutions/2758361/java-simply-traverse-the-tree-twice/\\n# Approach\\nBefore commenting on this solution, it is worth mentioning that a simple BFS traversal or DFS traversal will get you all the Leetcode test cases except for the last 5 ones. Those will give you \"time limit exceeded\".\\n\\nThis solution first computes the height of **all subtrees** of the given tree and stores them at $$heightsRooted$$:\\n```\\nprivate int GetHeightRootedAt(TreeNode node, Dictionary<int, int> heightsRooted) {\\n    if (node == null) {\\n        return -1;\\n    }\\n\\n    int maxHeight = 1 + Math.Max(GetHeightRootedAt(node.left, heightsRooted), \\n        GetHeightRootedAt(node.right, heightsRooted));\\n    heightsRooted.Add(node.val, maxHeight);\\n    return maxHeight;\\n    }\\n```\\n\\nThen, by using $$heightsRooted$$ for preventing us from repeating previous traversals, we compute all tree heights corresponding to each valid query and store them in $$heightsWithout$$:\\n```\\nprivate void GetHeightsWithoutNode(TreeNode node, int height, int possibleMaxHeight, \\n        int[] heightsWithout, Dictionary<int, int> heightsRooted) {\\n        if (node == null) {\\n            return;\\n        }\\n\\n        int leftHeight = node.left == null ? -1 : heightsRooted[node.left.val];\\n        int rightHeight = node.right == null ? -1 : heightsRooted[node.right.val];\\n\\n        GetHeightsWithoutNode(node.left, height + 1, \\n            Math.Max(possibleMaxHeight,               \\n            rightHeight + height + 1), heightsWithout, heightsRooted);\\n\\n        GetHeightsWithoutNode(node.right, height + 1, \\n            Math.Max(possibleMaxHeight, leftHeight + height + 1), \\n            heightsWithout, heightsRooted);\\n\\n        heightsWithout[node.val] = Math.Max(height - 1, possibleMaxHeight);\\n    }\\n\\n```\\nIf we remove left child from root, then the possible max height of the new tree is the height of right child + 1. \\n```\\nGetHeightsWithoutNode(node.left, height + 1, \\n            Math.Max(...,               \\n                rightHeight + height + 1),\\n                 ...);\\n```\\nIf we remove right child from root, then the possible max height of the new tree is the height of left child + 1. \\n```\\nGetHeightsWithoutNode(node.right, height + 1, \\n            Math.Max(..., \\n                leftHeight + height + 1), \\n            ...);\\n```\\n# Code\\n```\\npublic class Solution {\\n    public int[] TreeQueries(TreeNode root, int[] queries) {\\n        \\n        Dictionary<int, int> heightsRooted = new ();\\n        GetHeightRootedAt(root, heightsRooted);\\n\\n        int[] heightsWithout = new int[heightsRooted.Count+ 1];\\n        GetHeightsWithoutNode(root, 0, 0, heightsWithout, heightsRooted);\\n\\n        int[] result = new int[queries.Length];\\n        for (int i = 0; i < queries.Length; i++) {\\n            result[i] = heightsWithout[queries[i]];\\n        }\\n\\n        return result;\\n    }\\n\\n    private void GetHeightsWithoutNode(TreeNode node, int height, int possibleMaxHeight, \\n        int[] heightsWithout, Dictionary<int, int> heightsRooted) {\\n        if (node == null) {\\n            return;\\n        }\\n\\n        int leftHeight = node.left == null ? -1 : heightsRooted[node.left.val];\\n        int rightHeight = node.right == null ? -1 : heightsRooted[node.right.val];\\n\\n        GetHeightsWithoutNode(node.left, height + 1, \\n            Math.Max(possibleMaxHeight,               \\n            rightHeight + height + 1), heightsWithout, heightsRooted);\\n\\n        GetHeightsWithoutNode(node.right, height + 1, \\n            Math.Max(possibleMaxHeight, leftHeight + height + 1), \\n            heightsWithout, heightsRooted);\\n\\n        heightsWithout[node.val] = Math.Max(height - 1, possibleMaxHeight);\\n    }\\n\\n    private int GetHeightRootedAt(TreeNode node, Dictionary<int, int> heightsRooted) {\\n        if (node == null) {\\n            return -1;\\n        }\\n\\n        int maxHeight = 1 + Math.Max(GetHeightRootedAt(node.left, heightsRooted), \\n            GetHeightRootedAt(node.right, heightsRooted));\\n        heightsRooted.Add(node.val, maxHeight);\\n        return maxHeight;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search"
                ],
                "code": "```\\nprivate int GetHeightRootedAt(TreeNode node, Dictionary<int, int> heightsRooted) {\\n    if (node == null) {\\n        return -1;\\n    }\\n\\n    int maxHeight = 1 + Math.Max(GetHeightRootedAt(node.left, heightsRooted), \\n        GetHeightRootedAt(node.right, heightsRooted));\\n    heightsRooted.Add(node.val, maxHeight);\\n    return maxHeight;\\n    }\\n```\n```\\nprivate void GetHeightsWithoutNode(TreeNode node, int height, int possibleMaxHeight, \\n        int[] heightsWithout, Dictionary<int, int> heightsRooted) {\\n        if (node == null) {\\n            return;\\n        }\\n\\n        int leftHeight = node.left == null ? -1 : heightsRooted[node.left.val];\\n        int rightHeight = node.right == null ? -1 : heightsRooted[node.right.val];\\n\\n        GetHeightsWithoutNode(node.left, height + 1, \\n            Math.Max(possibleMaxHeight,               \\n            rightHeight + height + 1), heightsWithout, heightsRooted);\\n\\n        GetHeightsWithoutNode(node.right, height + 1, \\n            Math.Max(possibleMaxHeight, leftHeight + height + 1), \\n            heightsWithout, heightsRooted);\\n\\n        heightsWithout[node.val] = Math.Max(height - 1, possibleMaxHeight);\\n    }\\n\\n```\n```\\nGetHeightsWithoutNode(node.left, height + 1, \\n            Math.Max(...,               \\n                rightHeight + height + 1),\\n                 ...);\\n```\n```\\nGetHeightsWithoutNode(node.right, height + 1, \\n            Math.Max(..., \\n                leftHeight + height + 1), \\n            ...);\\n```\n```\\npublic class Solution {\\n    public int[] TreeQueries(TreeNode root, int[] queries) {\\n        \\n        Dictionary<int, int> heightsRooted = new ();\\n        GetHeightRootedAt(root, heightsRooted);\\n\\n        int[] heightsWithout = new int[heightsRooted.Count+ 1];\\n        GetHeightsWithoutNode(root, 0, 0, heightsWithout, heightsRooted);\\n\\n        int[] result = new int[queries.Length];\\n        for (int i = 0; i < queries.Length; i++) {\\n            result[i] = heightsWithout[queries[i]];\\n        }\\n\\n        return result;\\n    }\\n\\n    private void GetHeightsWithoutNode(TreeNode node, int height, int possibleMaxHeight, \\n        int[] heightsWithout, Dictionary<int, int> heightsRooted) {\\n        if (node == null) {\\n            return;\\n        }\\n\\n        int leftHeight = node.left == null ? -1 : heightsRooted[node.left.val];\\n        int rightHeight = node.right == null ? -1 : heightsRooted[node.right.val];\\n\\n        GetHeightsWithoutNode(node.left, height + 1, \\n            Math.Max(possibleMaxHeight,               \\n            rightHeight + height + 1), heightsWithout, heightsRooted);\\n\\n        GetHeightsWithoutNode(node.right, height + 1, \\n            Math.Max(possibleMaxHeight, leftHeight + height + 1), \\n            heightsWithout, heightsRooted);\\n\\n        heightsWithout[node.val] = Math.Max(height - 1, possibleMaxHeight);\\n    }\\n\\n    private int GetHeightRootedAt(TreeNode node, Dictionary<int, int> heightsRooted) {\\n        if (node == null) {\\n            return -1;\\n        }\\n\\n        int maxHeight = 1 + Math.Max(GetHeightRootedAt(node.left, heightsRooted), \\n            GetHeightRootedAt(node.right, heightsRooted));\\n        heightsRooted.Add(node.val, maxHeight);\\n        return maxHeight;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065453,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhat if we get the max height in my sibling tree and compare it with the max height if I deleted my parent... \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst I will get the max up and down depth for every node.\\nI will have the `maxHeightAfterDelete` intially has root node equal to 0\\nWe will build this map by check if I delete my parent what is the max height among all trees store it in `maxAfterDeleteMyParent` second thing when we have parent node we have two choices if I have a sibling get the max up depth + max down depth and store it in `maxSiblingHeight` what If I not have a sibling tree so I will get the max down depth for my parent store it in `parentMaxDownDepth`\\nthe answer is simply the max between \\n`maxAfterDeleteMyParent`, \\n(`maxSiblingHeight` if it exits else `parentMaxDownDepth`) \\n\\n\\nFeel free to ask any quesions\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint up(TreeNode* root, unordered_map<TreeNode*, int>& upDepth){\\n    if(!root) return -1;\\n    upDepth[root] = 1 + max(up(root->left, upDepth), up(root->right, upDepth));\\n    return upDepth[root];\\n}\\nvoid down(TreeNode* root, unordered_map<TreeNode*, int>& downDepth, int h = 0){\\n    if(!root) return;\\n    downDepth[root] = h;\\n    down(root->left, downDepth, h + 1);\\n    down(root->right, downDepth, h + 1);\\n}\\nvoid solve(TreeNode* root, TreeNode* parent, unordered_map<TreeNode*, int>& upDepth, unordered_map<TreeNode*, int>& downDepth, unordered_map<int, int>& maxHeightAfterDelete){\\n    if(!root) return;\\n    TreeNode* otherChild = (root == parent->left) ? parent->right : parent->left;\\n    int maxHeight = otherChild ?  upDepth[otherChild] + downDepth[otherChild] : downDepth[parent];\\n    maxHeightAfterDelete[root->val] = max(maxHeightAfterDelete[parent->val],maxHeight);\\n    solve(root->left, root, upDepth,downDepth, maxHeightAfterDelete);\\n    solve(root->right, root, upDepth,downDepth, maxHeightAfterDelete);\\n}    \\nvector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n    unordered_map<TreeNode*, int> upDepth{}, downDepth{};\\n    up(root, upDepth);\\n    down(root, downDepth);\\n    unordered_map<int, int> maxHeightAfterDelete{};\\n    maxHeightAfterDelete[1] = 0;\\n    solve(root->left, root, upDepth, downDepth, maxHeightAfterDelete); \\n    solve(root->right, root, upDepth, downDepth, maxHeightAfterDelete); \\n    vector<int> res{};\\n    for(int n : queries) res.push_back(maxHeightAfterDelete[n]);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint up(TreeNode* root, unordered_map<TreeNode*, int>& upDepth){\\n    if(!root) return -1;\\n    upDepth[root] = 1 + max(up(root->left, upDepth), up(root->right, upDepth));\\n    return upDepth[root];\\n}\\nvoid down(TreeNode* root, unordered_map<TreeNode*, int>& downDepth, int h = 0){\\n    if(!root) return;\\n    downDepth[root] = h;\\n    down(root->left, downDepth, h + 1);\\n    down(root->right, downDepth, h + 1);\\n}\\nvoid solve(TreeNode* root, TreeNode* parent, unordered_map<TreeNode*, int>& upDepth, unordered_map<TreeNode*, int>& downDepth, unordered_map<int, int>& maxHeightAfterDelete){\\n    if(!root) return;\\n    TreeNode* otherChild = (root == parent->left) ? parent->right : parent->left;\\n    int maxHeight = otherChild ?  upDepth[otherChild] + downDepth[otherChild] : downDepth[parent];\\n    maxHeightAfterDelete[root->val] = max(maxHeightAfterDelete[parent->val],maxHeight);\\n    solve(root->left, root, upDepth,downDepth, maxHeightAfterDelete);\\n    solve(root->right, root, upDepth,downDepth, maxHeightAfterDelete);\\n}    \\nvector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n    unordered_map<TreeNode*, int> upDepth{}, downDepth{};\\n    up(root, upDepth);\\n    down(root, downDepth);\\n    unordered_map<int, int> maxHeightAfterDelete{};\\n    maxHeightAfterDelete[1] = 0;\\n    solve(root->left, root, upDepth, downDepth, maxHeightAfterDelete); \\n    solve(root->right, root, upDepth, downDepth, maxHeightAfterDelete); \\n    vector<int> res{};\\n    for(int n : queries) res.push_back(maxHeightAfterDelete[n]);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3048882,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    HashMap<Integer, Integer> leftMap = new HashMap<>();\\n    HashMap<Integer, Integer> rightMap = new HashMap<>();\\n    HashMap<Integer, Integer> hMap = new HashMap<>();\\n    public int getTotalHeight(TreeNode root)\\n    {\\n        if(root == null)\\n            return 0;\\n        \\n        int left = getTotalHeight(root.left);\\n        int right = getTotalHeight(root.right);\\n        leftMap.put(root.val, left);\\n        rightMap.put(root.val, right);\\n        return Math.max(left, right)+1;\\n    }\\n    public void getHeight(TreeNode root, int max, int depth)\\n    {\\n        if(root == null)\\n            return;\\n        hMap.put(root.val, max);\\n        getHeight(root.left, Math.max(depth+rightMap.get(root.val), max), depth+1);\\n        getHeight(root.right, Math.max(depth+leftMap.get(root.val), max), depth+1);\\n    }\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        getTotalHeight(root);\\n        getHeight(root.left, rightMap.get(root.val),1);\\n        getHeight(root.right, leftMap.get(root.val),1);\\n        int[] result = new int[queries.length];\\n        for(int i = 0;i<queries.length;i++)\\n        {\\n            result[i] = hMap.get(queries[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    HashMap<Integer, Integer> leftMap = new HashMap<>();\\n    HashMap<Integer, Integer> rightMap = new HashMap<>();\\n    HashMap<Integer, Integer> hMap = new HashMap<>();\\n    public int getTotalHeight(TreeNode root)\\n    {\\n        if(root == null)\\n            return 0;\\n        \\n        int left = getTotalHeight(root.left);\\n        int right = getTotalHeight(root.right);\\n        leftMap.put(root.val, left);\\n        rightMap.put(root.val, right);\\n        return Math.max(left, right)+1;\\n    }\\n    public void getHeight(TreeNode root, int max, int depth)\\n    {\\n        if(root == null)\\n            return;\\n        hMap.put(root.val, max);\\n        getHeight(root.left, Math.max(depth+rightMap.get(root.val), max), depth+1);\\n        getHeight(root.right, Math.max(depth+leftMap.get(root.val), max), depth+1);\\n    }\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        getTotalHeight(root);\\n        getHeight(root.left, rightMap.get(root.val),1);\\n        getHeight(root.right, leftMap.get(root.val),1);\\n        int[] result = new int[queries.length];\\n        for(int i = 0;i<queries.length;i++)\\n        {\\n            result[i] = hMap.get(queries[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036320,
                "title": "c-level-height-from-leaf-dfs-bfs-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, int> heightFromLeaf;\\n    unordered_map<int, pair<int, int>> levelHeights; // level, {maxHeight,secondMxHeight}\\n    unordered_map<int, int> nodeLevel;\\n    \\n    int getHeightFromLeaf(TreeNode *root) {\\n        if(root == NULL) {\\n            return -1;\\n        }\\n        if(root->left == NULL && root->right == NULL) {\\n            return heightFromLeaf[root->val] = 0;\\n        }\\n        return heightFromLeaf[root->val] = 1 + max(getHeightFromLeaf(root->left), getHeightFromLeaf(root->right));\\n    }\\n\\n    void bfs(TreeNode *root) {\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n        int level = 0;\\n        while(!Q.empty()) {\\n            int sz = Q.size();\\n            level++;\\n            levelHeights[level] = {-1, -2};\\n            while(sz--) {\\n                TreeNode *node = Q.front();\\n                nodeLevel[node->val] = level;\\n                if(heightFromLeaf[node->val] > levelHeights[level].first) {\\n                    levelHeights[level].second = levelHeights[level].first;\\n                    levelHeights[level].first = heightFromLeaf[node->val];\\n                } else if(heightFromLeaf[node->val] == levelHeights[level].first) {\\n                    levelHeights[level].second = levelHeights[level].first;\\n                } else if(heightFromLeaf[node->val] < levelHeights[level].first && \\n                          heightFromLeaf[node->val] > levelHeights[level].second) {\\n                    levelHeights[level].second = heightFromLeaf[node->val];\\n                }\\n                Q.pop();\\n                if(node->left != NULL) {\\n                    Q.push(node->left);\\n                }\\n                if(node->right != NULL) {\\n                    Q.push(node->right);\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        getHeightFromLeaf(root);\\n        bfs(root);\\n        vector<int> ans;\\n        for(int node : queries) {\\n            int nL = nodeLevel[node];\\n            int mxH = levelHeights[nL].first;\\n            int sMxH = levelHeights[nL].second;\\n            int nH = heightFromLeaf[node];\\n            if(nH == mxH) {\\n                int newMxH = sMxH;\\n                int diff = mxH - newMxH;\\n                ans.push_back(heightFromLeaf[root->val] - diff);\\n            } else {\\n                ans.push_back(heightFromLeaf[root->val]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, int> heightFromLeaf;\\n    unordered_map<int, pair<int, int>> levelHeights; // level, {maxHeight,secondMxHeight}\\n    unordered_map<int, int> nodeLevel;\\n    \\n    int getHeightFromLeaf(TreeNode *root) {\\n        if(root == NULL) {\\n            return -1;\\n        }\\n        if(root->left == NULL && root->right == NULL) {\\n            return heightFromLeaf[root->val] = 0;\\n        }\\n        return heightFromLeaf[root->val] = 1 + max(getHeightFromLeaf(root->left), getHeightFromLeaf(root->right));\\n    }\\n\\n    void bfs(TreeNode *root) {\\n        queue<TreeNode*> Q;\\n        Q.push(root);\\n        int level = 0;\\n        while(!Q.empty()) {\\n            int sz = Q.size();\\n            level++;\\n            levelHeights[level] = {-1, -2};\\n            while(sz--) {\\n                TreeNode *node = Q.front();\\n                nodeLevel[node->val] = level;\\n                if(heightFromLeaf[node->val] > levelHeights[level].first) {\\n                    levelHeights[level].second = levelHeights[level].first;\\n                    levelHeights[level].first = heightFromLeaf[node->val];\\n                } else if(heightFromLeaf[node->val] == levelHeights[level].first) {\\n                    levelHeights[level].second = levelHeights[level].first;\\n                } else if(heightFromLeaf[node->val] < levelHeights[level].first && \\n                          heightFromLeaf[node->val] > levelHeights[level].second) {\\n                    levelHeights[level].second = heightFromLeaf[node->val];\\n                }\\n                Q.pop();\\n                if(node->left != NULL) {\\n                    Q.push(node->left);\\n                }\\n                if(node->right != NULL) {\\n                    Q.push(node->right);\\n                }\\n            }\\n        }\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        getHeightFromLeaf(root);\\n        bfs(root);\\n        vector<int> ans;\\n        for(int node : queries) {\\n            int nL = nodeLevel[node];\\n            int mxH = levelHeights[nL].first;\\n            int sMxH = levelHeights[nL].second;\\n            int nH = heightFromLeaf[node];\\n            if(nH == mxH) {\\n                int newMxH = sMxH;\\n                int diff = mxH - newMxH;\\n                ans.push_back(heightFromLeaf[root->val] - diff);\\n            } else {\\n                ans.push_back(heightFromLeaf[root->val]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995921,
                "title": "simple-c-solution-o-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple DFS followed by a BFS\\nfirst we calculate height of each tree using dfs\\nthen using bfs we calculate height of tree if a perticular subtree is cut off\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) for DFS O(N+N) for BFS => O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) for a hashMap to store the computations\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode *root, unordered_map<int, int> &um, int &n, int h){\\n        if(!root){\\n            return h-1;\\n        }\\n        int left=dfs(root->left,um,n,h+1);\\n        int right=dfs(root->right,um,n,h+1);\\n        int x=max(left,right);\\n        um[root->val]=x;\\n        return x;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        unordered_map<int,int> um;\\n        dfs(root,um,root->val,0);\\n        vector<int>  ans;\\n        vector<TreeNode *> crr;\\n        crr.push_back(root);\\n        int lvl=0;\\n        while(crr.size()>0){\\n            vector<TreeNode *>next;\\n                if(crr.size()==1){\\n                    um[crr[0]->val]=lvl-1;\\n                    if(crr[0]->left!=nullptr)    next.push_back(crr[0]->left);\\n                    if(crr[0]->right!=nullptr)    next.push_back(crr[0]->right);\\n                }\\n                else{\\n                    int max=crr[0]->val,max1=INT_MIN;\\n                    for(int i=0;i<crr.size();i++){\\n                        if(um[max]<um[crr[i]->val]) max=crr[i]->val;\\n                        if(crr[i]->left!=nullptr)    next.push_back(crr[i]->left);\\n                        if(crr[i]->right!=nullptr)    next.push_back(crr[i]->right);\\n                    }\\n                    int temp=um[max];\\n                    for(int i=0;i<crr.size();i++){\\n                        if(max1<um[crr[i]->val] && crr[i]->val!=max)    max1=um[crr[i]->val];\\n                        um[crr[i]->val]=temp;\\n                    }\\n                    um[max]=max1;\\n                }\\n            crr=next;\\n            lvl++;\\n        }\\n        // for(auto i:um){\\n        //     cout<<i.first<<\" \" <<i.second<<endl;\\n        // }\\n        for(int i=0;i<queries.size();i++)   ans.push_back(um[queries[i]]);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode *root, unordered_map<int, int> &um, int &n, int h){\\n        if(!root){\\n            return h-1;\\n        }\\n        int left=dfs(root->left,um,n,h+1);\\n        int right=dfs(root->right,um,n,h+1);\\n        int x=max(left,right);\\n        um[root->val]=x;\\n        return x;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        unordered_map<int,int> um;\\n        dfs(root,um,root->val,0);\\n        vector<int>  ans;\\n        vector<TreeNode *> crr;\\n        crr.push_back(root);\\n        int lvl=0;\\n        while(crr.size()>0){\\n            vector<TreeNode *>next;\\n                if(crr.size()==1){\\n                    um[crr[0]->val]=lvl-1;\\n                    if(crr[0]->left!=nullptr)    next.push_back(crr[0]->left);\\n                    if(crr[0]->right!=nullptr)    next.push_back(crr[0]->right);\\n                }\\n                else{\\n                    int max=crr[0]->val,max1=INT_MIN;\\n                    for(int i=0;i<crr.size();i++){\\n                        if(um[max]<um[crr[i]->val]) max=crr[i]->val;\\n                        if(crr[i]->left!=nullptr)    next.push_back(crr[i]->left);\\n                        if(crr[i]->right!=nullptr)    next.push_back(crr[i]->right);\\n                    }\\n                    int temp=um[max];\\n                    for(int i=0;i<crr.size();i++){\\n                        if(max1<um[crr[i]->val] && crr[i]->val!=max)    max1=um[crr[i]->val];\\n                        um[crr[i]->val]=temp;\\n                    }\\n                    um[max]=max1;\\n                }\\n            crr=next;\\n            lvl++;\\n        }\\n        // for(auto i:um){\\n        //     cout<<i.first<<\" \" <<i.second<<endl;\\n        // }\\n        for(int i=0;i<queries.size();i++)   ans.push_back(um[queries[i]]);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2989614,
                "title": "o-n-time-and-space-clean-and-well-commented",
                "content": "```\\nstatic int getNodeHeights(unordered_map<int, int>& nodeHeights, TreeNode* root) noexcept {\\n    if (root == nullptr) {\\n        return -1;\\n    }\\n    return nodeHeights[root->val] = 1 + max(\\n        getNodeHeights(nodeHeights, root->left),\\n        getNodeHeights(nodeHeights, root->right)\\n    );\\n}\\n\\nvector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n    // O(n) - traverse tree and get the height of each node.\\n    unordered_map<int, int> nodeHeights;\\n    const auto treeHeight = getNodeHeights(nodeHeights, root);\\n\\n    // Contains one entry per level for the highest node in\\n    // the level and maps to the height of the tree if that\\n    // node is deleted.\\n    unordered_map<int, int> heightDecrease;\\n\\n    // O(n) - Go level-by-level down the tree.\\n    // The first level is just the root node.\\n    vector<const TreeNode*> nextLevel = { root };\\n    while (!nextLevel.empty()) {\\n        // The next level becomes the current level.\\n        auto currLevel = move(nextLevel);\\n        nextLevel.clear();\\n\\n        // Load the next level from the current level.\\n        for (const auto& node : currLevel) {\\n            if (node->left != nullptr) {\\n                nextLevel.push_back(node->left);\\n            }\\n            if (node->right != nullptr) {\\n                nextLevel.push_back(node->right);\\n            }\\n        }\\n\\n        if (currLevel.size() == 1) {\\n            // If the current level only has one node and that node is removed\\n            // then the tree height is decreased by 1 + the node\\'s height.\\n            const auto singleNodeVal = currLevel[0]->val;\\n            heightDecrease[singleNodeVal] = 1 + nodeHeights[singleNodeVal];\\n        } else {\\n            // If the largest node in a level is removed then the second\\n            // highest node in the level determines the tree\\'s height.\\n            nth_element(\\n                currLevel.begin(), currLevel.begin() + 1,currLevel.end(),\\n                [&](const TreeNode* l, const TreeNode* r) noexcept {\\n                    return nodeHeights[l->val] > nodeHeights[r->val];\\n                }\\n            );\\n            const auto highestNodeVal = currLevel[0]->val;\\n            const auto highestNodeHeight = nodeHeights[highestNodeVal];\\n            const auto secondHighestNodeHeight = nodeHeights[currLevel[1]->val];\\n            heightDecrease[highestNodeVal] = highestNodeHeight - secondHighestNodeHeight;\\n        }\\n    }\\n    \\n    // O(n) - Compute all queries.\\n    vector<int> queryResults;\\n    res.reserve(queries.size());\\n    for (const auto& query : queries) {\\n        // A hight decrease will only happen if the deleted node is the highest\\n        // in the level. If the node is not the highest in the level then naturally\\n        // the tree will remain the same height.\\n        const auto foundDecrease = heightDecrease.find(query);\\n        const auto decrease = (foundDecrease != heightDecrease.cend() ? foundDecrease->second : 0);\\n        queryResults.push_back(treeHeight - decrease);\\n    }\\n    return queryResults;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstatic int getNodeHeights(unordered_map<int, int>& nodeHeights, TreeNode* root) noexcept {\\n    if (root == nullptr) {\\n        return -1;\\n    }\\n    return nodeHeights[root->val] = 1 + max(\\n        getNodeHeights(nodeHeights, root->left),\\n        getNodeHeights(nodeHeights, root->right)\\n    );\\n}\\n\\nvector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n    // O(n) - traverse tree and get the height of each node.\\n    unordered_map<int, int> nodeHeights;\\n    const auto treeHeight = getNodeHeights(nodeHeights, root);\\n\\n    // Contains one entry per level for the highest node in\\n    // the level and maps to the height of the tree if that\\n    // node is deleted.\\n    unordered_map<int, int> heightDecrease;\\n\\n    // O(n) - Go level-by-level down the tree.\\n    // The first level is just the root node.\\n    vector<const TreeNode*> nextLevel = { root };\\n    while (!nextLevel.empty()) {\\n        // The next level becomes the current level.\\n        auto currLevel = move(nextLevel);\\n        nextLevel.clear();\\n\\n        // Load the next level from the current level.\\n        for (const auto& node : currLevel) {\\n            if (node->left != nullptr) {\\n                nextLevel.push_back(node->left);\\n            }\\n            if (node->right != nullptr) {\\n                nextLevel.push_back(node->right);\\n            }\\n        }\\n\\n        if (currLevel.size() == 1) {\\n            // If the current level only has one node and that node is removed\\n            // then the tree height is decreased by 1 + the node\\'s height.\\n            const auto singleNodeVal = currLevel[0]->val;\\n            heightDecrease[singleNodeVal] = 1 + nodeHeights[singleNodeVal];\\n        } else {\\n            // If the largest node in a level is removed then the second\\n            // highest node in the level determines the tree\\'s height.\\n            nth_element(\\n                currLevel.begin(), currLevel.begin() + 1,currLevel.end(),\\n                [&](const TreeNode* l, const TreeNode* r) noexcept {\\n                    return nodeHeights[l->val] > nodeHeights[r->val];\\n                }\\n            );\\n            const auto highestNodeVal = currLevel[0]->val;\\n            const auto highestNodeHeight = nodeHeights[highestNodeVal];\\n            const auto secondHighestNodeHeight = nodeHeights[currLevel[1]->val];\\n            heightDecrease[highestNodeVal] = highestNodeHeight - secondHighestNodeHeight;\\n        }\\n    }\\n    \\n    // O(n) - Compute all queries.\\n    vector<int> queryResults;\\n    res.reserve(queries.size());\\n    for (const auto& query : queries) {\\n        // A hight decrease will only happen if the deleted node is the highest\\n        // in the level. If the node is not the highest in the level then naturally\\n        // the tree will remain the same height.\\n        const auto foundDecrease = heightDecrease.find(query);\\n        const auto decrease = (foundDecrease != heightDecrease.cend() ? foundDecrease->second : 0);\\n        queryResults.push_back(treeHeight - decrease);\\n    }\\n    return queryResults;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2942327,
                "title": "c-solution-using-euler-tour-with-raange-max-query",
                "content": "class Solution {\\npublic:\\n \\tstatic const int mx = 1e6;\\n\\tint inTime[mx];\\n\\tint outTime[mx];\\n \\tint depth[mx];\\n\\tint linearTree[mx];\\n\\tint timer = 1;\\n \\tint n = 0;\\n \\tvector<int>ans;\\n \\tint Depth = 0;\\n \\tvector<vector<int>>table;\\n\\tvoid EulerTour(TreeNode* root) {\\n\\t\\tif (!root)return;\\n\\t\\tinTime[root->val] = timer;\\n\\t\\tlinearTree[timer] = root->val;\\n\\t\\ttimer++;\\n\\t\\tEulerTour(root->left);\\n\\t\\tEulerTour(root->right);\\n\\t\\toutTime[root->val] = timer;\\n\\t\\tlinearTree[timer] = root->val;\\n\\t\\ttimer++;\\n\\t}\\n\\tvoid dfs(TreeNode* root) {\\n\\t\\tif (root == NULL)return;\\n\\t\\tn++;\\n\\t\\tdepth[root->val] = Depth++;\\n\\t\\tdfs(root->left);\\n\\t\\tdfs(root->right);\\n\\t\\tDepth--;\\n\\t}\\n\\n\\tint Query(int l, int r) {\\n\\t\\tint count = r - l + 1;\\n\\t\\tint k = log2(count);\\n\\t\\treturn max(table[k][l], table[k][r - (1 << k) + 1]);\\n\\t}\\n\\n\\tvoid buildSparseTable() {\\n\\n\\t\\tint rowCount = log2(2*n);\\n\\t\\t//int table[rowCount + 1][n];\\n\\t\\ttable.resize(rowCount + 1, vector<int>(2*n));\\n\\t\\tfor (int i = 0; i < 2*n; i++) {\\n\\t\\t\\ttable[0][i] = depth[linearTree[i + 1]];\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i <= rowCount; i++) {\\n\\t\\t\\tfor (int j = 0; (j + (1 << i)) <= 2*n; j++) {\\n\\t\\t\\t\\ttable[i][j] = max(table[i - 1][j], table[i - 1][j + (1 << (i - 1))]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n\\tvector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        \\n\\t\\tdfs(root);\\n\\t\\tEulerTour(root);\\n\\t\\tbuildSparseTable();\\n        timer--;\\n\\t\\tfor (int node : queries) { \\n\\t\\t\\tint l = inTime[node] - 1;\\n\\t\\t\\tint r = outTime[node] - 1;\\n\\t\\t\\tint x = max(Query(0,l-1), Query(r+1, timer-1));\\n\\t\\t\\tans.push_back(x);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n \\tstatic const int mx = 1e6;\\n\\tint inTime[mx];\\n\\tint outTime[mx];\\n \\tint depth[mx];\\n\\tint linearTree[mx];\\n\\tint timer = 1;\\n \\tint n = 0;\\n \\tvector<int>ans;\\n \\tint Depth = 0;\\n \\tvector<vector<int>>table;\\n\\tvoid EulerTour(TreeNode* root) {\\n\\t\\tif (!root)return;\\n\\t\\tinTime[root->val] = timer;\\n\\t\\tlinearTree[timer] = root->val;\\n\\t\\ttimer++;\\n\\t\\tEulerTour(root->left);\\n\\t\\tEulerTour(root->right);\\n\\t\\toutTime[root->val] = timer;\\n\\t\\tlinearTree[timer] = root->val;\\n\\t\\ttimer++;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2932117,
                "title": "java-using-only-2-hashmap-height-and-depth-concept-comments",
                "content": "\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        //HashMap for storing level -> (max height, second max height) of a node on a level\\n        Map<Integer,int[]> levels = new HashMap<>(); // for stoing max and second max value on that level [firstmax, secondmax]\\n       \\n        // HashMap for storing root value -> (Height,depth) of a node\\n        Map<Integer,int[]> map = new HashMap<>();\\n        \\n        // returns the height of the complete tree, (-1) because after deleting there should not link between deleted node and its parent\\n        int max = dfs(root,0,map,levels)-1; \\n        \\n        \\n        int n = queries.length;\\n        for(int i =0;i<n;i++){\\n            int q = queries[i];\\n            int[] node = map.get(q);\\n            int height = node[0];// this gives the height of tree from bottom\\n            int level = node[1]; // this gives the level/depth to which the node belongs\\n            int[] lev = levels.get(level); // this will give [max height,second max height] on that level;\\n            if(lev[0] == height){ // if height of node is max on that node\\n                if(lev[1] != -1)  // if second Max exists on that level, i.e more that one node on the level\\n                    queries[i] = max - Math.abs(lev[0] - lev[1]); \\n                else{   // if secondMax height does not exist, i.e only one node on that level\\n                    queries[i] = max - height-1; // if only one node on the level just delete it from tree\\n                }\\n            }else{\\n                queries[i] = max; // if height of node is not max on that level, that means there are nodes on that level that have height greater\\n            }\\n        }\\n        \\n        return queries; // using the same array for storing answer.\\n    }\\n    //Depth First traversal because we have traverse collecting and manupulating the data and also get he height of the tree\\n    public int dfs(TreeNode root,int level,Map<Integer,int[]> map,Map<Integer,int[]> levels){\\n        if(root == null){\\n            return 0;\\n        }\\n        int left = dfs(root.left,level+1,map,levels);\\n        int right = dfs(root.right,level+1,map,levels);\\n        \\n        int height = Math.max(left,right); // this will give the height of the current node;\\n        \\n        int[] lev = levels.getOrDefault(level,new int[]{-1,-1}); // if there is already a node on the current node\\'s level then just return those values , else return  [max height , second max height] on that level\\n        if(height >= lev[0]){\\n            lev[1] = lev[0];\\n            lev[0] = height;\\n        }else{\\n            lev[1] = Math.max(lev[1],height);\\n        }\\n        // logic to store max and second max from any number set\\n        levels.put(level,lev); // updating the levels map\\n        map.put(root.val,new int[]{height,level});// updating the map, for queiring purpose\\n        \\n        return Math.max(left,right)+1; \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        //HashMap for storing level -> (max height, second max height) of a node on a level\\n        Map<Integer,int[]> levels = new HashMap<>(); // for stoing max and second max value on that level [firstmax, secondmax]\\n       \\n        // HashMap for storing root value -> (Height,depth) of a node\\n        Map<Integer,int[]> map = new HashMap<>();\\n        \\n        // returns the height of the complete tree, (-1) because after deleting there should not link between deleted node and its parent\\n        int max = dfs(root,0,map,levels)-1; \\n        \\n        \\n        int n = queries.length;\\n        for(int i =0;i<n;i++){\\n            int q = queries[i];\\n            int[] node = map.get(q);\\n            int height = node[0];// this gives the height of tree from bottom\\n            int level = node[1]; // this gives the level/depth to which the node belongs\\n            int[] lev = levels.get(level); // this will give [max height,second max height] on that level;\\n            if(lev[0] == height){ // if height of node is max on that node\\n                if(lev[1] != -1)  // if second Max exists on that level, i.e more that one node on the level\\n                    queries[i] = max - Math.abs(lev[0] - lev[1]); \\n                else{   // if secondMax height does not exist, i.e only one node on that level\\n                    queries[i] = max - height-1; // if only one node on the level just delete it from tree\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2922146,
                "title": "python-dfs-level-analysis",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate two data structures:\\n1) level[node.val] = [[distance from bottom],[distance from top]]\\n2) node_level[level] = sorted list of nodes at each level based on distance from bottom and node.val [distance from bottom,node.val]\\n\\nFor each query:\\n1) if the number of nodes at the q level == 1: result = level-1\\n2) if the q == node.val with longest distance from bottom at that level then: result = next longest level else select longest path from the bottom at that level:\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        self.level = defaultdict(list)\\n        self.level[-1] = [-1,0]\\n        self.node_level = defaultdict(list)\\n        def postOrder(root,x):\\n            if root:\\n                x += 1\\n                postOrder(root.left,x)\\n                postOrder(root.right,x)\\n                l = -1\\n                if root.left: l = root.left.val\\n                r = -1\\n                if root.right: r = root.right.val\\n                self.level[root.val] = [max(self.level[l][0],self.level[r][0])+1,x]\\n                insort(self.node_level[x],[self.level[root.val][0],root.val])\\n        \\n        postOrder(root,-1)\\n\\n        ans = []\\n        for q in queries:\\n            nodes = self.node_level[self.level[q][1]]\\n            if len(nodes) == 1:\\n                ans.append(self.level[q][1]-1)\\n            elif nodes[-1][1] == q:\\n                 ans.append(nodes[-2][0]+self.level[q][1])\\n            else:\\n               ans.append(nodes[-1][0]+self.level[q][1])\\n        return(ans)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        self.level = defaultdict(list)\\n        self.level[-1] = [-1,0]\\n        self.node_level = defaultdict(list)\\n        def postOrder(root,x):\\n            if root:\\n                x += 1\\n                postOrder(root.left,x)\\n                postOrder(root.right,x)\\n                l = -1\\n                if root.left: l = root.left.val\\n                r = -1\\n                if root.right: r = root.right.val\\n                self.level[root.val] = [max(self.level[l][0],self.level[r][0])+1,x]\\n                insort(self.node_level[x],[self.level[root.val][0],root.val])\\n        \\n        postOrder(root,-1)\\n\\n        ans = []\\n        for q in queries:\\n            nodes = self.node_level[self.level[q][1]]\\n            if len(nodes) == 1:\\n                ans.append(self.level[q][1]-1)\\n            elif nodes[-1][1] == q:\\n                 ans.append(nodes[-2][0]+self.level[q][1])\\n            else:\\n               ans.append(nodes[-1][0]+self.level[q][1])\\n        return(ans)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886772,
                "title": "c-eular-tour-on-trees",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEular Tour on Trees\\n\\n# Complexity\\n- Time complexity: $$O(n) + O(q)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, pair<int,int>> mp;\\n    vector<int> v;\\n    void solve(TreeNode* root, int h, int &idx){\\n        if(!root) return;\\n        int a = idx;\\n        v.push_back(h);\\n        ++idx;\\n        solve(root->left, h+1, idx);\\n        solve(root->right, h+1, idx);\\n        int b = idx;\\n        v.push_back(h);\\n        mp[root->val] = {a,b};\\n        ++idx;\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        v.clear();\\n        mp.clear();\\n        vector<int> ans;\\n        int idx = 0;\\n        solve(root, 0, idx);\\n        int n = v.size();\\n       vector<int> left(n,0), right(n,0);\\n\\n        left[0] = v[0];\\n       for(int i=1; i<n; ++i){\\n           left[i] = max(left[i-1], v[i]);\\n       }\\n\\n       right[n-1] = v[n-1];\\n       for(int i=n-2; i>=0; --i){\\n           right[i] = max(right[i+1], v[i]);\\n       }\\n\\n       for(auto &q : queries){\\n           auto p = mp[q];\\n           int l = p.first, r = p.second, res = 0;\\n           if(l-1 >= 0){\\n               res = max(res, left[l-1]);\\n           }\\n           if(r+1 < n){\\n               res = max(res, right[r+1]);\\n           }\\n           ans.push_back(res);\\n       }\\n        return ans;\\n\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, pair<int,int>> mp;\\n    vector<int> v;\\n    void solve(TreeNode* root, int h, int &idx){\\n        if(!root) return;\\n        int a = idx;\\n        v.push_back(h);\\n        ++idx;\\n        solve(root->left, h+1, idx);\\n        solve(root->right, h+1, idx);\\n        int b = idx;\\n        v.push_back(h);\\n        mp[root->val] = {a,b};\\n        ++idx;\\n    }\\n\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        v.clear();\\n        mp.clear();\\n        vector<int> ans;\\n        int idx = 0;\\n        solve(root, 0, idx);\\n        int n = v.size();\\n       vector<int> left(n,0), right(n,0);\\n\\n        left[0] = v[0];\\n       for(int i=1; i<n; ++i){\\n           left[i] = max(left[i-1], v[i]);\\n       }\\n\\n       right[n-1] = v[n-1];\\n       for(int i=n-2; i>=0; --i){\\n           right[i] = max(right[i+1], v[i]);\\n       }\\n\\n       for(auto &q : queries){\\n           auto p = mp[q];\\n           int l = p.first, r = p.second, res = 0;\\n           if(l-1 >= 0){\\n               res = max(res, left[l-1]);\\n           }\\n           if(r+1 < n){\\n               res = max(res, right[r+1]);\\n           }\\n           ans.push_back(res);\\n       }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881809,
                "title": "python-dfs-94-time-97-space",
                "content": "``` python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        lvl_lookup = {}\\n        lvl_heights = {}\\n\\n        def dfs(node, level):\\n            lvl_lookup[node.val] = level\\n            left, right = 0, 0\\n            if node.left: left = dfs(node.left, level + 1)\\n            if node.right: right = dfs(node.right, level + 1)\\n            height = max(level, left, right)\\n\\n            if level not in lvl_heights: lvl_heights[level] = []\\n            lvl_heights[level].append([height, node.val])\\n            lvl_heights[level].sort(reverse=True)\\n            # For each level, maintain, at most, the two largest heights\\n            while len(lvl_heights[level]) > 2: lvl_heights[level].pop()\\n\\n            return height\\n        dfs(root, 0)\\n\\n        output = []\\n        for query in queries:\\n            level = lvl_lookup[query]\\n            result = None\\n            for height, node in lvl_heights[level]:\\n                if node != query:\\n                    result = height\\n                    break\\n            if result == None: output.append(level - 1)\\n            else: output.append(result)\\n\\n        return output\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        lvl_lookup = {}\\n        lvl_heights = {}\\n\\n        def dfs(node, level):\\n            lvl_lookup[node.val] = level\\n            left, right = 0, 0\\n            if node.left: left = dfs(node.left, level + 1)\\n            if node.right: right = dfs(node.right, level + 1)\\n            height = max(level, left, right)\\n\\n            if level not in lvl_heights: lvl_heights[level] = []\\n            lvl_heights[level].append([height, node.val])\\n            lvl_heights[level].sort(reverse=True)\\n            # For each level, maintain, at most, the two largest heights\\n            while len(lvl_heights[level]) > 2: lvl_heights[level].pop()\\n\\n            return height\\n        dfs(root, 0)\\n\\n        output = []\\n        for query in queries:\\n            level = lvl_lookup[query]\\n            result = None\\n            for height, node in lvl_heights[level]:\\n                if node != query:\\n                    result = height\\n                    break\\n            if result == None: output.append(level - 1)\\n            else: output.append(result)\\n\\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838088,
                "title": "java-easy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        Map<Integer, int[]> valToLevel = new HashMap<>();\\n        Map<Integer, List<Integer>> levelToList = new HashMap<>();\\n        \\n        dfs(root, 0, valToLevel, levelToList);\\n        \\n        int[] result = new int[queries.length];\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            \\n            List<Integer> list = levelToList.get(valToLevel.get(queries[i])[0]);\\n            if (list.size() == 1) {\\n                result[i] = valToLevel.get(queries[i])[0] - 1;\\n            } else {\\n                result[i] = valToLevel.get(queries[i])[0] + findHeight(list, valToLevel.get(queries[i])[1], valToLevel.get(queries[i])[0]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findHeight(List<Integer> list, int max, int level) {        \\n        if (list.get(1) == max) {\\n            return list.get(0);\\n        } else {\\n            return list.get(1);\\n        }\\n    }\\n    \\n    private int dfs(TreeNode root, int level, Map<Integer, int[]> valToLevel, Map<Integer, List<Integer>> levelToList) {\\n        if (root == null) {\\n            return 0;\\n        }\\n               \\n        \\n        int left = dfs(root.left, level + 1, valToLevel, levelToList);\\n        int right = dfs(root.right, level + 1, valToLevel, levelToList);\\n        \\n        int max = Math.max(left, right);\\n        valToLevel.put(root.val, new int[]{level, max});\\n        \\n        List<Integer> list = levelToList.getOrDefault(level, new ArrayList<>());\\n        \\n        if (list.size() == 0) {\\n            list.add(max);\\n        } else if (list.size() == 1) {\\n            if (list.get(0) > max) {\\n                list.add(0, max);\\n            } else {\\n                list.add(max);\\n            }\\n        } else {\\n            if (list.get(1) < max) {\\n                list.set(0, list.get(1));\\n                list.set(1, max);\\n            } else if (list.get(0) < max) {\\n                list.set(0, max);\\n            }\\n        }\\n        levelToList.put(level, list);\\n        \\n        return max + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        Map<Integer, int[]> valToLevel = new HashMap<>();\\n        Map<Integer, List<Integer>> levelToList = new HashMap<>();\\n        \\n        dfs(root, 0, valToLevel, levelToList);\\n        \\n        int[] result = new int[queries.length];\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            \\n            List<Integer> list = levelToList.get(valToLevel.get(queries[i])[0]);\\n            if (list.size() == 1) {\\n                result[i] = valToLevel.get(queries[i])[0] - 1;\\n            } else {\\n                result[i] = valToLevel.get(queries[i])[0] + findHeight(list, valToLevel.get(queries[i])[1], valToLevel.get(queries[i])[0]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findHeight(List<Integer> list, int max, int level) {        \\n        if (list.get(1) == max) {\\n            return list.get(0);\\n        } else {\\n            return list.get(1);\\n        }\\n    }\\n    \\n    private int dfs(TreeNode root, int level, Map<Integer, int[]> valToLevel, Map<Integer, List<Integer>> levelToList) {\\n        if (root == null) {\\n            return 0;\\n        }\\n               \\n        \\n        int left = dfs(root.left, level + 1, valToLevel, levelToList);\\n        int right = dfs(root.right, level + 1, valToLevel, levelToList);\\n        \\n        int max = Math.max(left, right);\\n        valToLevel.put(root.val, new int[]{level, max});\\n        \\n        List<Integer> list = levelToList.getOrDefault(level, new ArrayList<>());\\n        \\n        if (list.size() == 0) {\\n            list.add(max);\\n        } else if (list.size() == 1) {\\n            if (list.get(0) > max) {\\n                list.add(0, max);\\n            } else {\\n                list.add(max);\\n            }\\n        } else {\\n            if (list.get(1) < max) {\\n                list.set(0, list.get(1));\\n                list.set(1, max);\\n            } else if (list.get(0) < max) {\\n                list.set(0, max);\\n            }\\n        }\\n        levelToList.put(level, list);\\n        \\n        return max + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826961,
                "title": "c-preorder-traversal-dept-of-tree",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    map<int,int> leftMp,rightMp,query;\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int> ans;\\n        checkLevel(root);\\n        solve(root->left,rightMp[root->val],1);\\n        solve(root->right,leftMp[root->val],1);\\n        for(auto& que:queries){\\n            ans.push_back(query[que]);\\n        }\\n        return ans;\\n    }\\n    void solve(TreeNode* root,int maxx,int depth){\\n        if(!root) return;\\n        query[root->val] = maxx;\\n        solve(root->left,max(maxx,depth+rightMp[root->val]),depth+1);\\n        solve(root->right,max(maxx,depth+leftMp[root->val]),depth+1);\\n    }\\n    \\n\\n    int checkLevel(TreeNode* root){\\n        if(!root) return 0;\\n        int left = checkLevel(root->left);\\n        int right = checkLevel(root->right);\\n        leftMp[root->val] = left;\\n        rightMp[root->val] = right;\\n        return 1+max(left,right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    map<int,int> leftMp,rightMp,query;\\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int> ans;\\n        checkLevel(root);\\n        solve(root->left,rightMp[root->val],1);\\n        solve(root->right,leftMp[root->val],1);\\n        for(auto& que:queries){\\n            ans.push_back(query[que]);\\n        }\\n        return ans;\\n    }\\n    void solve(TreeNode* root,int maxx,int depth){\\n        if(!root) return;\\n        query[root->val] = maxx;\\n        solve(root->left,max(maxx,depth+rightMp[root->val]),depth+1);\\n        solve(root->right,max(maxx,depth+leftMp[root->val]),depth+1);\\n    }\\n    \\n\\n    int checkLevel(TreeNode* root){\\n        if(!root) return 0;\\n        int left = checkLevel(root->left);\\n        int right = checkLevel(root->right);\\n        leftMp[root->val] = left;\\n        rightMp[root->val] = right;\\n        return 1+max(left,right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817780,
                "title": "java-keep-track-of-max-depth-below-the-nodes-for-each-level",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        int n = queries.length;\\n        int res[] = new int[n];\\n        \\n        //Node vs depth of node\\n        Map<Integer,Integer> depthMap = new HashMap<>();\\n        \\n        //Node vs max depth below this\\n        Map<Integer,Integer> maxDepthBelow = new HashMap<>();\\n        \\n        //Level vs TreeMap of Max Depth Below vs count of nodes with that depth\\n        Map<Integer,TreeMap<Integer,Integer>> levelMap = new HashMap<>();\\n        fillDepth(root, depthMap, 0);\\n        fillLevel(root, levelMap, maxDepthBelow, 0);\\n        \\n        for(int i = 0; i<n; i++) {\\n            int node = queries[i];\\n            int depthOfNode = depthMap.get(node);\\n            int maxDepthBelowNode = maxDepthBelow.get(node);\\n            TreeMap<Integer,Integer> currentLevel = levelMap.get(depthOfNode);\\n            \\n            if(maxDepthBelowNode == currentLevel.lastKey()) {\\n                if(currentLevel.get(maxDepthBelowNode) > 1)\\n                    res[i] = maxDepthBelowNode;\\n                else {\\n                    Integer prevKey = currentLevel.lowerKey(maxDepthBelowNode);\\n                    \\n                    if(prevKey == null)\\n                        res[i] = depthOfNode - 1;\\n                    else res[i] = prevKey;\\n                }\\n            }\\n            else {\\n                res[i] = currentLevel.lastKey();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void fillDepth(TreeNode root, Map<Integer,Integer> map, int depth) {\\n        if(root == null)\\n            return;\\n        \\n        map.put(root.val, depth);\\n        fillDepth(root.left, map, depth + 1);\\n        fillDepth(root.right, map, depth + 1);\\n        return;\\n    }\\n    \\n    int fillLevel(TreeNode root, Map<Integer,TreeMap<Integer,Integer>> levelMap, Map<Integer,Integer> maxDepthBelow, int depth) {\\n        if(root == null)\\n            return Integer.MIN_VALUE;\\n        \\n        if(root.left == null && root.right == null) {\\n            createLevel(levelMap, depth);\\n            TreeMap<Integer,Integer> currentLevel = levelMap.get(depth);\\n            currentLevel.put(depth, currentLevel.getOrDefault(depth,0) + 1);\\n            levelMap.put(depth, currentLevel);\\n            maxDepthBelow.put(root.val, depth);\\n            return depth;\\n        }\\n        \\n        int maxDepthLeft = fillLevel(root.left, levelMap, maxDepthBelow, depth + 1);\\n        int maxDepthRight = fillLevel(root.right, levelMap, maxDepthBelow, depth + 1);\\n        int maxDepthFromThisNode = Math.max(maxDepthLeft, maxDepthRight);\\n        createLevel(levelMap, depth);\\n        TreeMap<Integer,Integer> currentLevel = levelMap.get(depth);\\n        currentLevel.put(maxDepthFromThisNode, currentLevel.getOrDefault(maxDepthFromThisNode,0) + 1);\\n        levelMap.put(depth, currentLevel);\\n        maxDepthBelow.put(root.val, maxDepthFromThisNode);\\n        return maxDepthFromThisNode;\\n    }\\n    \\n    void createLevel(Map<Integer,TreeMap<Integer,Integer>> levelMap, int level) {\\n        if(levelMap.containsKey(level))\\n            return;\\n        \\n        levelMap.put(level, new TreeMap<>());\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        int n = queries.length;\\n        int res[] = new int[n];\\n        \\n        //Node vs depth of node\\n        Map<Integer,Integer> depthMap = new HashMap<>();\\n        \\n        //Node vs max depth below this\\n        Map<Integer,Integer> maxDepthBelow = new HashMap<>();\\n        \\n        //Level vs TreeMap of Max Depth Below vs count of nodes with that depth\\n        Map<Integer,TreeMap<Integer,Integer>> levelMap = new HashMap<>();\\n        fillDepth(root, depthMap, 0);\\n        fillLevel(root, levelMap, maxDepthBelow, 0);\\n        \\n        for(int i = 0; i<n; i++) {\\n            int node = queries[i];\\n            int depthOfNode = depthMap.get(node);\\n            int maxDepthBelowNode = maxDepthBelow.get(node);\\n            TreeMap<Integer,Integer> currentLevel = levelMap.get(depthOfNode);\\n            \\n            if(maxDepthBelowNode == currentLevel.lastKey()) {\\n                if(currentLevel.get(maxDepthBelowNode) > 1)\\n                    res[i] = maxDepthBelowNode;\\n                else {\\n                    Integer prevKey = currentLevel.lowerKey(maxDepthBelowNode);\\n                    \\n                    if(prevKey == null)\\n                        res[i] = depthOfNode - 1;\\n                    else res[i] = prevKey;\\n                }\\n            }\\n            else {\\n                res[i] = currentLevel.lastKey();\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void fillDepth(TreeNode root, Map<Integer,Integer> map, int depth) {\\n        if(root == null)\\n            return;\\n        \\n        map.put(root.val, depth);\\n        fillDepth(root.left, map, depth + 1);\\n        fillDepth(root.right, map, depth + 1);\\n        return;\\n    }\\n    \\n    int fillLevel(TreeNode root, Map<Integer,TreeMap<Integer,Integer>> levelMap, Map<Integer,Integer> maxDepthBelow, int depth) {\\n        if(root == null)\\n            return Integer.MIN_VALUE;\\n        \\n        if(root.left == null && root.right == null) {\\n            createLevel(levelMap, depth);\\n            TreeMap<Integer,Integer> currentLevel = levelMap.get(depth);\\n            currentLevel.put(depth, currentLevel.getOrDefault(depth,0) + 1);\\n            levelMap.put(depth, currentLevel);\\n            maxDepthBelow.put(root.val, depth);\\n            return depth;\\n        }\\n        \\n        int maxDepthLeft = fillLevel(root.left, levelMap, maxDepthBelow, depth + 1);\\n        int maxDepthRight = fillLevel(root.right, levelMap, maxDepthBelow, depth + 1);\\n        int maxDepthFromThisNode = Math.max(maxDepthLeft, maxDepthRight);\\n        createLevel(levelMap, depth);\\n        TreeMap<Integer,Integer> currentLevel = levelMap.get(depth);\\n        currentLevel.put(maxDepthFromThisNode, currentLevel.getOrDefault(maxDepthFromThisNode,0) + 1);\\n        levelMap.put(depth, currentLevel);\\n        maxDepthBelow.put(root.val, maxDepthFromThisNode);\\n        return maxDepthFromThisNode;\\n    }\\n    \\n    void createLevel(Map<Integer,TreeMap<Integer,Integer>> levelMap, int level) {\\n        if(levelMap.containsKey(level))\\n            return;\\n        \\n        levelMap.put(level, new TreeMap<>());\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806854,
                "title": "intution-python3",
                "content": "The intution behind the problem is:\\nQuestion 1) What happens to the height if we remove the node\\nQuestion 2) Will removing it will affect the path that holds the maximum height\\n\\nMy intution said removing any node that does not lies in the path that holds the maximum height will not affect the result.\\nWhat if we remove any node in the path that holds the maximum height ?\\nAnswer : If we have multiple paths that holds the maximum height then. The removing the nodes from root untill the lowest common ancestor of those paths will affect the result .Hence we shall narrow our search cases between them.\\n\\nLets say a node ```a``` which needs to be removed that lies in our search case and lies as left to its parent.the new height of the tree becomes max(height of the right subtree of the parent, max(heights of the same case nodes that lied in our search case from root to ```a```))\\n```\\n\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        maxHeight = self.computeHeightForEachNodes(-1,root)\\n        commonAncestor = self.getCommonAncestorForMaxHeights(root)\\n        route = self.getRouteToRoot(commonAncestor)\\n        maxCurrent = 0\\n        iterations = 0\\n        dic = {}\\n        if root!=commonAncestor:\\n            while True:\\n                child = root.right if route[iterations]==\\'R\\' else root.left\\n                iterations += 1\\n                dic[child.val] = max(maxCurrent,(root.rightHeight if root.left==child else root.leftHeight) + iterations)\\n                maxCurrent = dic[child.val]\\n                if(child==commonAncestor):\\n                    break\\n                root = child\\n        return [(maxHeight if i not in dic else dic[i])  for i in queries]\\n                \\n    \\n    def computeHeightForEachNodes(self,parent,root):\\n        if root == None:\\n            return -1\\n        root.leftHeight = self.computeHeightForEachNodes(root,root.left)\\n        root.rightHeight = self.computeHeightForEachNodes(root,root.right)\\n        root.parent = parent\\n\\n        return max(root.leftHeight,root.rightHeight) + 1\\n    \\n    def getCommonAncestorForMaxHeights(self,root):\\n        if root.leftHeight==root.rightHeight:\\n            return root\\n        if root.rightHeight > root.leftHeight:\\n            return self.getCommonAncestorForMaxHeights(root.right)\\n        return self.getCommonAncestorForMaxHeights(root.left)\\n    \\n    def getRouteToRoot(self,node):\\n        route = \"\"\\n        parent = node.parent\\n        while parent!=-1:\\n            if parent.left == node:\\n                route += \"L\"\\n            else:\\n                route += \"R\"\\n            node = parent\\n            parent = parent.parent\\n        return route[::-1]\\n        \\n```",
                "solutionTags": [],
                "code": "```a```\n```a```\n```\\n\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        maxHeight = self.computeHeightForEachNodes(-1,root)\\n        commonAncestor = self.getCommonAncestorForMaxHeights(root)\\n        route = self.getRouteToRoot(commonAncestor)\\n        maxCurrent = 0\\n        iterations = 0\\n        dic = {}\\n        if root!=commonAncestor:\\n            while True:\\n                child = root.right if route[iterations]==\\'R\\' else root.left\\n                iterations += 1\\n                dic[child.val] = max(maxCurrent,(root.rightHeight if root.left==child else root.leftHeight) + iterations)\\n                maxCurrent = dic[child.val]\\n                if(child==commonAncestor):\\n                    break\\n                root = child\\n        return [(maxHeight if i not in dic else dic[i])  for i in queries]\\n                \\n    \\n    def computeHeightForEachNodes(self,parent,root):\\n        if root == None:\\n            return -1\\n        root.leftHeight = self.computeHeightForEachNodes(root,root.left)\\n        root.rightHeight = self.computeHeightForEachNodes(root,root.right)\\n        root.parent = parent\\n\\n        return max(root.leftHeight,root.rightHeight) + 1\\n    \\n    def getCommonAncestorForMaxHeights(self,root):\\n        if root.leftHeight==root.rightHeight:\\n            return root\\n        if root.rightHeight > root.leftHeight:\\n            return self.getCommonAncestorForMaxHeights(root.right)\\n        return self.getCommonAncestorForMaxHeights(root.left)\\n    \\n    def getRouteToRoot(self,node):\\n        route = \"\"\\n        parent = node.parent\\n        while parent!=-1:\\n            if parent.left == node:\\n                route += \"L\"\\n            else:\\n                route += \"R\"\\n            node = parent\\n            parent = parent.parent\\n        return route[::-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806793,
                "title": "simple-solution-with-depth-of-leaves",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStoring the depth of the leaves will work.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStoring the depth of the leaves and start and end indices for each subtree. We can then, preprocess the max of prefix and suffix of the depths and get the result by removing the subtree in O(1).\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> depth;\\n    map<int, pair<int, int> > range;\\n    map<int, int> par;\\n    map<int, int> height;\\n\\n    int idx = 0;\\n    void dfs(int d, int p, TreeNode * root) {\\n        if(root == nullptr) return;\\n        par[root->val] = p;\\n        if(root->left == nullptr && root->right == nullptr) {\\n            depth.push_back(d);\\n            range[root->val] = {idx, idx};\\n            idx++;\\n            return;\\n        }\\n        height[root->val] = d;\\n        int startIdx = idx;\\n        dfs(d+1, root->val, root->left);\\n        dfs(d+1, root->val, root->right);\\n        range[root->val] = {startIdx, idx-1};\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n\\n        dfs(0, 0, root);\\n        vector<int> preMax(depth.size()), postMax(depth.size());\\n        preMax[0] = (depth[0]);\\n        for(int i = 1; i<depth.size(); i++) {\\n            preMax[i] = (max(preMax[i-1], depth[i]));\\n        }\\n        postMax[depth.size() - 1] = depth.back();\\n        for(int i = depth.size() -2; i>=0; i--) {\\n            postMax[i] = max(postMax[i+1], depth[i]);\\n        }\\n        int q = queries.size();\\n        int cnt = 0;\\n        vector<int> res;\\n        while(q--) {\\n            int node = queries[cnt++];\\n            int s = range[node].first;\\n            int e = range[node].second;\\n\\n            int ans = height[par[node]];\\n            if(s -1 >= 0)\\n                ans = preMax[s-1];\\n            if(e + 1 < depth.size())\\n                ans = max(ans, postMax[e+1]);\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> depth;\\n    map<int, pair<int, int> > range;\\n    map<int, int> par;\\n    map<int, int> height;\\n\\n    int idx = 0;\\n    void dfs(int d, int p, TreeNode * root) {\\n        if(root == nullptr) return;\\n        par[root->val] = p;\\n        if(root->left == nullptr && root->right == nullptr) {\\n            depth.push_back(d);\\n            range[root->val] = {idx, idx};\\n            idx++;\\n            return;\\n        }\\n        height[root->val] = d;\\n        int startIdx = idx;\\n        dfs(d+1, root->val, root->left);\\n        dfs(d+1, root->val, root->right);\\n        range[root->val] = {startIdx, idx-1};\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n\\n        dfs(0, 0, root);\\n        vector<int> preMax(depth.size()), postMax(depth.size());\\n        preMax[0] = (depth[0]);\\n        for(int i = 1; i<depth.size(); i++) {\\n            preMax[i] = (max(preMax[i-1], depth[i]));\\n        }\\n        postMax[depth.size() - 1] = depth.back();\\n        for(int i = depth.size() -2; i>=0; i--) {\\n            postMax[i] = max(postMax[i+1], depth[i]);\\n        }\\n        int q = queries.size();\\n        int cnt = 0;\\n        vector<int> res;\\n        while(q--) {\\n            int node = queries[cnt++];\\n            int s = range[node].first;\\n            int e = range[node].second;\\n\\n            int ans = height[par[node]];\\n            if(s -1 >= 0)\\n                ans = preMax[s-1];\\n            if(e + 1 < depth.size())\\n                ans = max(ans, postMax[e+1]);\\n            res.push_back(ans);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802684,
                "title": "java-dfs-bfs-priorityqueue-beats-72",
                "content": "```\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        int[] valToHeight = new int[100_001];\\n        int[] valToDepthFromRoot = new int[100_001];\\n        findValToHeight(root, valToHeight,valToDepthFromRoot, 0);\\n        int[] result = new int[queries.length];\\n        Map<Integer, List<Integer>> queriedNodes = new HashMap<>();\\n        for (int i = 0; i < queries.length; i++) {\\n            queriedNodes.computeIfAbsent(queries[i], k->new ArrayList<>()).add(i);\\n        }\\n        PriorityQueue<TreeNode> pq = new PriorityQueue<>((n1, n2)->Integer.compare(valToHeight[n2.val], valToHeight[n1.val]));\\n        pq.offer(root);\\n        while (!pq.isEmpty()) {\\n            int size = pq.size();\\n            int maxHeightInCurLevel = valToHeight[pq.peek().val];\\n            List<TreeNode> curLevel = new ArrayList<>();\\n            \\n            \\n            for (int i = 0; i < size; i++) {\\n                TreeNode curNode = pq.poll();\\n                \\n                if (queriedNodes.containsKey(curNode.val)) {\\n                    int finalVal = -1;\\n                    if (size == 1) {\\n                        finalVal = valToDepthFromRoot[curNode.val] - 1;\\n                    } else if (i == 0) {\\n                        finalVal = valToHeight[pq.peek().val];\\n                    } else {\\n                        finalVal = maxHeightInCurLevel;\\n                    }\\n                    for (int index : queriedNodes.get(curNode.val)) {\\n                        result[index] = finalVal;\\n                    }\\n                }\\n                \\n                if (curNode.left != null) curLevel.add(curNode.left); \\n                if (curNode.right != null) curLevel.add(curNode.right);\\n            }\\n        \\n            pq.addAll(curLevel);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findValToHeight(TreeNode curNode, int[] valToHeight, int[] valToDepthFromRoot, int height) {\\n        if (curNode == null) return 0;\\n        valToDepthFromRoot[curNode.val] = height;\\n        if (curNode.left == null && curNode.right == null) {\\n            valToHeight[curNode.val] = height;\\n            return height; \\n        }\\n        int leftHeight = findValToHeight(curNode.left, valToHeight,valToDepthFromRoot, height+1);\\n        int rightHeight = findValToHeight(curNode.right, valToHeight,valToDepthFromRoot, height+1);\\n        valToHeight[curNode.val] = Math.max(leftHeight, rightHeight);\\n        return valToHeight[curNode.val];\\n    } \\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        int[] valToHeight = new int[100_001];\\n        int[] valToDepthFromRoot = new int[100_001];\\n        findValToHeight(root, valToHeight,valToDepthFromRoot, 0);\\n        int[] result = new int[queries.length];\\n        Map<Integer, List<Integer>> queriedNodes = new HashMap<>();\\n        for (int i = 0; i < queries.length; i++) {\\n            queriedNodes.computeIfAbsent(queries[i], k->new ArrayList<>()).add(i);\\n        }\\n        PriorityQueue<TreeNode> pq = new PriorityQueue<>((n1, n2)->Integer.compare(valToHeight[n2.val], valToHeight[n1.val]));\\n        pq.offer(root);\\n        while (!pq.isEmpty()) {\\n            int size = pq.size();\\n            int maxHeightInCurLevel = valToHeight[pq.peek().val];\\n            List<TreeNode> curLevel = new ArrayList<>();\\n            \\n            \\n            for (int i = 0; i < size; i++) {\\n                TreeNode curNode = pq.poll();\\n                \\n                if (queriedNodes.containsKey(curNode.val)) {\\n                    int finalVal = -1;\\n                    if (size == 1) {\\n                        finalVal = valToDepthFromRoot[curNode.val] - 1;\\n                    } else if (i == 0) {\\n                        finalVal = valToHeight[pq.peek().val];\\n                    } else {\\n                        finalVal = maxHeightInCurLevel;\\n                    }\\n                    for (int index : queriedNodes.get(curNode.val)) {\\n                        result[index] = finalVal;\\n                    }\\n                }\\n                \\n                if (curNode.left != null) curLevel.add(curNode.left); \\n                if (curNode.right != null) curLevel.add(curNode.right);\\n            }\\n        \\n            pq.addAll(curLevel);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int findValToHeight(TreeNode curNode, int[] valToHeight, int[] valToDepthFromRoot, int height) {\\n        if (curNode == null) return 0;\\n        valToDepthFromRoot[curNode.val] = height;\\n        if (curNode.left == null && curNode.right == null) {\\n            valToHeight[curNode.val] = height;\\n            return height; \\n        }\\n        int leftHeight = findValToHeight(curNode.left, valToHeight,valToDepthFromRoot, height+1);\\n        int rightHeight = findValToHeight(curNode.right, valToHeight,valToDepthFromRoot, height+1);\\n        valToHeight[curNode.val] = Math.max(leftHeight, rightHeight);\\n        return valToHeight[curNode.val];\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801033,
                "title": "dfs-bfs-video-walkthrough-python",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/ZtFMdGg2S74)\\n```\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        height, removed_height, dummy, queue, lvl = defaultdict(lambda: -1), defaultdict(lambda: 0), TreeNode(-1), [root], 0\\n        def dfs(root):\\n            if not root: return -1\\n            height[root.val] = 1 + max(dfs(root.left), dfs(root.right))\\n            return height[root.val]\\n        dfs(root)\\n        while queue:\\n            u,v = heapq.nlargest(2, queue + [dummy], key=lambda node: height[node.val])\\n            for node in queue: removed_height[node.val] = lvl + height[u.val] * int(u.val != node.val) + height[v.val] * int(u.val == node.val)\\n            queue, lvl = [child for node in queue for child in [node.left, node.right] if child], lvl + 1\\n        return [removed_height[query] for query in queries]\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        height, removed_height, dummy, queue, lvl = defaultdict(lambda: -1), defaultdict(lambda: 0), TreeNode(-1), [root], 0\\n        def dfs(root):\\n            if not root: return -1\\n            height[root.val] = 1 + max(dfs(root.left), dfs(root.right))\\n            return height[root.val]\\n        dfs(root)\\n        while queue:\\n            u,v = heapq.nlargest(2, queue + [dummy], key=lambda node: height[node.val])\\n            for node in queue: removed_height[node.val] = lvl + height[u.val] * int(u.val != node.val) + height[v.val] * int(u.val == node.val)\\n            queue, lvl = [child for node in queue for child in [node.left, node.right] if child], lvl + 1\\n        return [removed_height[query] for query in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794817,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\npublic class Solution\\n{\\n    private readonly int[] _seen = new int[100001];\\n    private int _maxHeight;\\n\\n    public int[] TreeQueries(TreeNode root, int[] queries)\\n    {\\n        _maxHeight = 0;\\n        Dfs(root, 0);\\n\\n        _maxHeight = 0;\\n        Dfs(root, 0);\\n\\n        return queries.Select(q => _seen[q]).ToArray();\\n    }\\n\\n    private void Dfs(TreeNode root, int h)\\n    {\\n        if (root == null)\\n            return;\\n        \\n        _seen[root.val] = Math.Max(_seen[root.val], _maxHeight);\\n        _maxHeight = Math.Max(_maxHeight, h);\\n        \\n        Dfs(root.left, h + 1);\\n        Dfs(root.right, h + 1);\\n        \\n        (root.right, root.left) = (root.left, root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    private readonly int[] _seen = new int[100001];\\n    private int _maxHeight;\\n\\n    public int[] TreeQueries(TreeNode root, int[] queries)\\n    {\\n        _maxHeight = 0;\\n        Dfs(root, 0);\\n\\n        _maxHeight = 0;\\n        Dfs(root, 0);\\n\\n        return queries.Select(q => _seen[q]).ToArray();\\n    }\\n\\n    private void Dfs(TreeNode root, int h)\\n    {\\n        if (root == null)\\n            return;\\n        \\n        _seen[root.val] = Math.Max(_seen[root.val], _maxHeight);\\n        _maxHeight = Math.Max(_maxHeight, h);\\n        \\n        Dfs(root.left, h + 1);\\n        Dfs(root.right, h + 1);\\n        \\n        (root.right, root.left) = (root.left, root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786475,
                "title": "java-simple-to-understand-solution-using-hashmaps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    HashMap<Integer,Integer> nodeToLevel = new HashMap();\\n    HashMap<Integer,Integer> nodeToDepth = new HashMap();\\n    HashMap<Integer,PriorityQueue<Integer>> levelToNode = new HashMap();      \\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        int[] answer = new int[queries.length];  \\n        findDepth(root);\\n        \\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        int level = 0;\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a,b) -> nodeToDepth.get(b) - nodeToDepth.get(a));\\n            while(size-- > 0){\\n                TreeNode n = queue.poll();\\n                if(n.left != null)\\n                    queue.add(n.left);\\n                if(n.right != null)\\n                    queue.add(n.right);\\n                pq.add(n.val);\\n                nodeToLevel.put(n.val,level);\\n            }\\n            levelToNode.put(level,pq);\\n            level++;\\n        }\\n\\n        for(int i=0;i<queries.length;i++){\\n            int levelOfQuery = nodeToLevel.get(queries[i]);\\n            PriorityQueue<Integer> pq = levelToNode.get(levelOfQuery);\\n            if(pq.size() == 1){\\n                answer[i] = levelOfQuery - 1;\\n                continue;\\n            }\\n            if(pq.peek() == queries[i]){\\n                pq.poll();\\n                answer[i] = levelOfQuery + nodeToDepth.get(pq.peek());\\n                pq.add(queries[i]);          \\n            }\\n            else {\\n                answer[i] = levelOfQuery + nodeToDepth.get(pq.peek());\\n            }\\n        }        \\n        return answer;\\n    }\\n    \\n    public int findDepth(TreeNode node){\\n        if(node == null)\\n            return 0;\\n        int max = Math.max(findDepth(node.left),findDepth(node.right));\\n        nodeToDepth.put(node.val,max);\\n        return max+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    HashMap<Integer,Integer> nodeToLevel = new HashMap();\\n    HashMap<Integer,Integer> nodeToDepth = new HashMap();\\n    HashMap<Integer,PriorityQueue<Integer>> levelToNode = new HashMap();      \\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        int[] answer = new int[queries.length];  \\n        findDepth(root);\\n        \\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        int level = 0;\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            PriorityQueue<Integer> pq = new PriorityQueue<Integer>((a,b) -> nodeToDepth.get(b) - nodeToDepth.get(a));\\n            while(size-- > 0){\\n                TreeNode n = queue.poll();\\n                if(n.left != null)\\n                    queue.add(n.left);\\n                if(n.right != null)\\n                    queue.add(n.right);\\n                pq.add(n.val);\\n                nodeToLevel.put(n.val,level);\\n            }\\n            levelToNode.put(level,pq);\\n            level++;\\n        }\\n\\n        for(int i=0;i<queries.length;i++){\\n            int levelOfQuery = nodeToLevel.get(queries[i]);\\n            PriorityQueue<Integer> pq = levelToNode.get(levelOfQuery);\\n            if(pq.size() == 1){\\n                answer[i] = levelOfQuery - 1;\\n                continue;\\n            }\\n            if(pq.peek() == queries[i]){\\n                pq.poll();\\n                answer[i] = levelOfQuery + nodeToDepth.get(pq.peek());\\n                pq.add(queries[i]);          \\n            }\\n            else {\\n                answer[i] = levelOfQuery + nodeToDepth.get(pq.peek());\\n            }\\n        }        \\n        return answer;\\n    }\\n    \\n    public int findDepth(TreeNode node){\\n        if(node == null)\\n            return 0;\\n        int max = Math.max(findDepth(node.left),findDepth(node.right));\\n        nodeToDepth.put(node.val,max);\\n        return max+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785232,
                "title": "c-o-m-sibling-check",
                "content": "```\\n#define pi pair<int,int>\\n\\nstruct Comp {\\n  bool operator()(const pi &a, const pi &b) {\\n      return a.second<b.second;\\n  }  \\n};\\n\\nclass Solution {\\npublic:\\n    unordered_map<int, int> hdepth; // node -> height  marking\\n    unordered_map<int, priority_queue<pi, vector<pi>, Comp> > siblingcheck; // depth -> siblings,height+depth marking\\n    \\n    int dfs(TreeNode* root, int height) {\\n        if(root == nullptr) \\n            return 0;\\n        \\n        int val = max(dfs(root->left, height+1), dfs(root->right, height+1));\\n        \\n        hdepth[root->val] = height;\\n        siblingcheck[height].push({root->val, height + val });\\n        \\n        return 1+val;\\n    }\\n    \\n    \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        dfs(root,0);\\n        \\n        vector<int> ans;\\n        for(int node: queries) {\\n            int node_height = hdepth[node];\\n            \\n            priority_queue<pi, vector<pi>, Comp> &px = siblingcheck[node_height];\\n            if(px.top().first == node && px.size()>1) {\\n                pair<int,int> temp = px.top();\\n                px.pop();\\n                ans.push_back(px.top().second);\\n                px.push(temp);\\n            }\\n            else if (px.top().first != node )\\n                ans.push_back(px.top().second);\\n            else \\n                ans.push_back(node_height-1);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Depth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define pi pair<int,int>\\n\\nstruct Comp {\\n  bool operator()(const pi &a, const pi &b) {\\n      return a.second<b.second;\\n  }  \\n};\\n\\nclass Solution {\\npublic:\\n    unordered_map<int, int> hdepth; // node -> height  marking\\n    unordered_map<int, priority_queue<pi, vector<pi>, Comp> > siblingcheck; // depth -> siblings,height+depth marking\\n    \\n    int dfs(TreeNode* root, int height) {\\n        if(root == nullptr) \\n            return 0;\\n        \\n        int val = max(dfs(root->left, height+1), dfs(root->right, height+1));\\n        \\n        hdepth[root->val] = height;\\n        siblingcheck[height].push({root->val, height + val });\\n        \\n        return 1+val;\\n    }\\n    \\n    \\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        dfs(root,0);\\n        \\n        vector<int> ans;\\n        for(int node: queries) {\\n            int node_height = hdepth[node];\\n            \\n            priority_queue<pi, vector<pi>, Comp> &px = siblingcheck[node_height];\\n            if(px.top().first == node && px.size()>1) {\\n                pair<int,int> temp = px.top();\\n                px.pop();\\n                ans.push_back(px.top().second);\\n                px.push(temp);\\n            }\\n            else if (px.top().first != node )\\n                ans.push_back(px.top().second);\\n            else \\n                ans.push_back(node_height-1);\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782882,
                "title": "java-2-times-of-dfs-time-o-n-n-node-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1, we can get each node level and it\\'s max depth for O(N) in dfs.\\n2, with the above data, when we do DFS to traverse, we could calculate the outside max level of a node by O(1) calc for each ancestor. \\n3, the outside max level is the height after removal of a node. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1, First DFS, record 2 numbers for each node: the node current level, the maxLevel (leaf node level) under this node. \\n2, Second DFS, For each current node, it\\'s left child\\'s after removal height is max(Max height of removel curent Node, max height under right child). vice versa. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) N is number of node.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) recording data for each node. \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Map<Integer,Integer> numToMaxLevel;\\n    Map<Integer,Integer> numToLevel;\\n    Map<Integer, Integer> removeHeight;\\n\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        numToMaxLevel = new HashMap<>();\\n        numToLevel = new HashMap<>();\\n        dfsMaxLevel(root,0);\\n//        System.out.println(numToMaxLevel);\\n\\n        removeHeight = new HashMap<>();\\n        for(int n: queries){\\n            removeHeight.put(n,-1);\\n        }        \\n        dfsCalc(root,0);\\n//        System.out.println(removeHeight);\\n        \\n        int[] ret = new int[queries.length];\\n        for(int i=0;i<ret.length;i++){\\n            ret[i] = removeHeight.get(queries[i]);\\n        }\\n        return ret;\\n    }\\n\\n    private int dfsMaxLevel(TreeNode root, int level){\\n        if(root==null){\\n            return level - 1;\\n        }else{\\n            numToLevel.put(root.val,level);\\n            int maxLevel = Math.max(dfsMaxLevel(root.left,level+1),dfsMaxLevel(root.right,level+1));\\n            numToMaxLevel.put(root.val,maxLevel);\\n            return maxLevel;\\n        }\\n    }\\n    \\n    private void dfsCalc(TreeNode root, int outsideMaxHeight){\\n        if(root!=null){\\n            if(removeHeight.containsKey(root.val))\\n                removeHeight.put(root.val,outsideMaxHeight);\\n            int leftHeight = Math.max(getMaxHeight(root.left),numToLevel.get(root.val));\\n            int rightHeight = Math.max(getMaxHeight(root.right),numToLevel.get(root.val));\\n            dfsCalc(root.left,Math.max(rightHeight,outsideMaxHeight));\\n            dfsCalc(root.right,Math.max(leftHeight,outsideMaxHeight));\\n        }\\n    }\\n    private int getMaxHeight(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }else{\\n            return numToMaxLevel.get(root.val);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Map<Integer,Integer> numToMaxLevel;\\n    Map<Integer,Integer> numToLevel;\\n    Map<Integer, Integer> removeHeight;\\n\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        numToMaxLevel = new HashMap<>();\\n        numToLevel = new HashMap<>();\\n        dfsMaxLevel(root,0);\\n//        System.out.println(numToMaxLevel);\\n\\n        removeHeight = new HashMap<>();\\n        for(int n: queries){\\n            removeHeight.put(n,-1);\\n        }        \\n        dfsCalc(root,0);\\n//        System.out.println(removeHeight);\\n        \\n        int[] ret = new int[queries.length];\\n        for(int i=0;i<ret.length;i++){\\n            ret[i] = removeHeight.get(queries[i]);\\n        }\\n        return ret;\\n    }\\n\\n    private int dfsMaxLevel(TreeNode root, int level){\\n        if(root==null){\\n            return level - 1;\\n        }else{\\n            numToLevel.put(root.val,level);\\n            int maxLevel = Math.max(dfsMaxLevel(root.left,level+1),dfsMaxLevel(root.right,level+1));\\n            numToMaxLevel.put(root.val,maxLevel);\\n            return maxLevel;\\n        }\\n    }\\n    \\n    private void dfsCalc(TreeNode root, int outsideMaxHeight){\\n        if(root!=null){\\n            if(removeHeight.containsKey(root.val))\\n                removeHeight.put(root.val,outsideMaxHeight);\\n            int leftHeight = Math.max(getMaxHeight(root.left),numToLevel.get(root.val));\\n            int rightHeight = Math.max(getMaxHeight(root.right),numToLevel.get(root.val));\\n            dfsCalc(root.left,Math.max(rightHeight,outsideMaxHeight));\\n            dfsCalc(root.right,Math.max(leftHeight,outsideMaxHeight));\\n        }\\n    }\\n    private int getMaxHeight(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }else{\\n            return numToMaxLevel.get(root.val);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781760,
                "title": "c-eular-tour",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode*root,vector<int>&euler,vector<int>&height,int &size,int h=0)\\n    {\\n        if(root==NULL) return;\\n        size++;\\n        euler.push_back(root->val);\\n        height.push_back(h);\\n        dfs(root->left,euler,height,size,h+1);\\n        dfs(root->right,euler,height,size,h+1);\\n        euler.push_back(root->val);\\n        height.push_back(h);\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int>euler,height;\\n        int size=0;\\n        dfs(root,euler,height,size);\\n        int e_size=euler.size();\\n        vector<int>left(size+1,-1),right(size+1,-1);\\n        for(int i=0;i<e_size;i++)\\n        {\\n            if(left[euler[i]]!=-1) right[euler[i]]=i;\\n            else left[euler[i]]=i;\\n        }\\n        \\n        vector<int>maxi_left(e_size),maxi_right(e_size);\\n        maxi_left[0]=height[0];\\n        maxi_right[e_size-1]=height[e_size-1];\\n        for(int i=1;i<e_size;i++) maxi_left[i]=max(maxi_left[i-1],height[i]);\\n        for(int i=e_size-2;i>=0;i--) maxi_right[i]=max(maxi_right[i+1],height[i]);\\n        vector<int>ans;\\n        for(auto i:queries)\\n        {\\n            int l=left[i];\\n            int r=right[i];\\n            int maximum=max(maxi_left[l-1],maxi_right[r+1]);\\n            ans.push_back(maximum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode*root,vector<int>&euler,vector<int>&height,int &size,int h=0)\\n    {\\n        if(root==NULL) return;\\n        size++;\\n        euler.push_back(root->val);\\n        height.push_back(h);\\n        dfs(root->left,euler,height,size,h+1);\\n        dfs(root->right,euler,height,size,h+1);\\n        euler.push_back(root->val);\\n        height.push_back(h);\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int>euler,height;\\n        int size=0;\\n        dfs(root,euler,height,size);\\n        int e_size=euler.size();\\n        vector<int>left(size+1,-1),right(size+1,-1);\\n        for(int i=0;i<e_size;i++)\\n        {\\n            if(left[euler[i]]!=-1) right[euler[i]]=i;\\n            else left[euler[i]]=i;\\n        }\\n        \\n        vector<int>maxi_left(e_size),maxi_right(e_size);\\n        maxi_left[0]=height[0];\\n        maxi_right[e_size-1]=height[e_size-1];\\n        for(int i=1;i<e_size;i++) maxi_left[i]=max(maxi_left[i-1],height[i]);\\n        for(int i=e_size-2;i>=0;i--) maxi_right[i]=max(maxi_right[i+1],height[i]);\\n        vector<int>ans;\\n        for(auto i:queries)\\n        {\\n            int l=left[i];\\n            int r=right[i];\\n            int maximum=max(maxi_left[l-1],maxi_right[r+1]);\\n            ans.push_back(maximum);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778945,
                "title": "java-two-maps-treeset-level-depth-easy",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static class Datum {\\n        int val;\\n        int level;\\n        int maxHeight;\\n        \\n        public Datum() {\\n            \\n        }\\n        \\n        public Datum(int val, int level, int maxHeight) {\\n            this.val = val;\\n            this.level = level;\\n            this.maxHeight = maxHeight;\\n        }\\n    }\\n    \\n    private Map<Integer, Datum> nodeMap;\\n    private Map<Integer, TreeSet<Datum>> levelMap;\\n    \\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        nodeMap = new HashMap<>();\\n        levelMap = new HashMap<>();\\n        \\n        walkTree(root, 0);\\n        \\n        int m = queries.length;\\n        int ans[] = new int[m];\\n        \\n        for (int i = 0; i < m; ++i) {\\n            int val = queries[i];\\n            Datum nodeMapDatum = nodeMap.get(val);\\n            int level = nodeMapDatum.level;\\n            \\n            levelMap.get(level).remove(nodeMapDatum);\\n                   \\n            ans[i] = (levelMap.get(level).isEmpty()) ? nodeMapDatum.level - 1 : levelMap.get(level).first().maxHeight;\\n                 \\n            levelMap.get(level).add(nodeMapDatum);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int walkTree(TreeNode node, int level) {\\n        if (node == null) {\\n            return level - 1;\\n        }\\n        \\n        int leftHeight = walkTree(node.left, level + 1);\\n        int rightHeight = walkTree(node.right, level + 1);\\n        int maxHeight = Math.max(leftHeight, rightHeight);\\n        \\n        Datum datum = new Datum(node.val, level, maxHeight);\\n        \\n        nodeMap.put(node.val, datum);\\n        \\n        levelMap.putIfAbsent(level, new TreeSet<>((d1, d2) -> {\\n            if (d1.maxHeight != d2.maxHeight) return d2.maxHeight - d1.maxHeight;\\n            return d1.val - d2.val;\\n        }));\\n        levelMap.get(level).add(datum);\\n        \\n        return maxHeight;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static class Datum {\\n        int val;\\n        int level;\\n        int maxHeight;\\n        \\n        public Datum() {\\n            \\n        }\\n        \\n        public Datum(int val, int level, int maxHeight) {\\n            this.val = val;\\n            this.level = level;\\n            this.maxHeight = maxHeight;\\n        }\\n    }\\n    \\n    private Map<Integer, Datum> nodeMap;\\n    private Map<Integer, TreeSet<Datum>> levelMap;\\n    \\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        nodeMap = new HashMap<>();\\n        levelMap = new HashMap<>();\\n        \\n        walkTree(root, 0);\\n        \\n        int m = queries.length;\\n        int ans[] = new int[m];\\n        \\n        for (int i = 0; i < m; ++i) {\\n            int val = queries[i];\\n            Datum nodeMapDatum = nodeMap.get(val);\\n            int level = nodeMapDatum.level;\\n            \\n            levelMap.get(level).remove(nodeMapDatum);\\n                   \\n            ans[i] = (levelMap.get(level).isEmpty()) ? nodeMapDatum.level - 1 : levelMap.get(level).first().maxHeight;\\n                 \\n            levelMap.get(level).add(nodeMapDatum);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int walkTree(TreeNode node, int level) {\\n        if (node == null) {\\n            return level - 1;\\n        }\\n        \\n        int leftHeight = walkTree(node.left, level + 1);\\n        int rightHeight = walkTree(node.right, level + 1);\\n        int maxHeight = Math.max(leftHeight, rightHeight);\\n        \\n        Datum datum = new Datum(node.val, level, maxHeight);\\n        \\n        nodeMap.put(node.val, datum);\\n        \\n        levelMap.putIfAbsent(level, new TreeSet<>((d1, d2) -> {\\n            if (d1.maxHeight != d2.maxHeight) return d2.maxHeight - d1.maxHeight;\\n            return d1.val - d2.val;\\n        }));\\n        levelMap.get(level).add(datum);\\n        \\n        return maxHeight;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776407,
                "title": "c-rerooting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrecalculate the answers by Rerooting\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    unordered_map<int, int>height;\\n    unordered_map<int, int>ans;\\n    int dfs(TreeNode* root){\\n        if(!root)return -1;\\n        int val = root->val;\\n        return height[val] = 1+max(dfs(root->left), dfs(root->right));\\n    }\\n    void dfs2(TreeNode* root, int up, int cur){\\n        if(!root)return;\\n        int val = root->val;\\n        ans[val] = up;\\n        int rig = cur+(root->right? height[root->right->val]+1 : 0);\\n        int lef = cur+(root->left? height[root->left->val]+1 : 0);\\n        dfs2(root->left, max(up, rig), cur+1);\\n        dfs2(root->right, max(up, lef), cur+1);\\n    }\\n    \\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        dfs(root);\\n        dfs2(root, 0, 0);\\n        vector<int>anss;\\n        for(auto &q:queries){\\n            anss.push_back(ans[q]);\\n        }\\n        return anss;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int, int>height;\\n    unordered_map<int, int>ans;\\n    int dfs(TreeNode* root){\\n        if(!root)return -1;\\n        int val = root->val;\\n        return height[val] = 1+max(dfs(root->left), dfs(root->right));\\n    }\\n    void dfs2(TreeNode* root, int up, int cur){\\n        if(!root)return;\\n        int val = root->val;\\n        ans[val] = up;\\n        int rig = cur+(root->right? height[root->right->val]+1 : 0);\\n        int lef = cur+(root->left? height[root->left->val]+1 : 0);\\n        dfs2(root->left, max(up, rig), cur+1);\\n        dfs2(root->right, max(up, lef), cur+1);\\n    }\\n    \\npublic:\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        dfs(root);\\n        dfs2(root, 0, 0);\\n        vector<int>anss;\\n        for(auto &q:queries){\\n            anss.push_back(ans[q]);\\n        }\\n        return anss;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774596,
                "title": "can-anyone-tell-why-this-is-giving-run-time-error-and-how-to-resolve-it",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getHeight(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int leftAns = 1 + getHeight(root->left);\\n        int rightAns = 1 + getHeight(root->right);\\n        return max(leftAns, rightAns);\\n    }\\n    void deleteNode(TreeNode* root, int value)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        deleteNode(root->left, value);\\n        if(root->val == value)\\n        {\\n            delete root;\\n            return;\\n        }        \\n        \\n        deleteNode(root->right, value);\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<int> ans;\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            TreeNode* temp = root;\\n            deleteNode(temp, queries[i]);\\n            int height = getHeight(temp);\\n            ans.push_back(height);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int getHeight(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        \\n        int leftAns = 1 + getHeight(root->left);\\n        int rightAns = 1 + getHeight(root->right);\\n        return max(leftAns, rightAns);\\n    }\\n    void deleteNode(TreeNode* root, int value)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        deleteNode(root->left, value);\\n        if(root->val == value)\\n        {\\n            delete root;\\n            return;\\n        }        \\n        \\n        deleteNode(root->right, value);\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        \\n        vector<int> ans;\\n        for(int i=0; i<queries.size(); i++)\\n        {\\n            TreeNode* temp = root;\\n            deleteNode(temp, queries[i]);\\n            int height = getHeight(temp);\\n            ans.push_back(height);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774516,
                "title": "java-level-height-with-comments",
                "content": "```\\nclass Solution {\\n    \\n    static int[] h,l,maxH1, maxH2;\\n    \\n    \\n    public int height(TreeNode root, int level){ \\n\\t// Simple function to calculate the height of a tree. \\n\\t// Added level to know the node level.\\n\\t// Just simply filled the values of the array and calculate the height at the tree queries function. \\n        \\n        if(root == null) return -1;\\n        \\n        int left=height(root.left, level + 1);\\n        int right=height(root.right, level + 1);\\n        \\n        h[root.val]=Math.max(left,right) + 1;\\n        l[root.val]=level;\\n        \\n        if(h[root.val] > maxH1[level]) {\\n            maxH2[level]=maxH1[level];\\n            maxH1[level]=h[root.val];\\n        }else if(h[root.val] > maxH2[level]){\\n            maxH2[level]=h[root.val];\\n        }\\n        \\n        return h[root.val];\\n    }\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        h=new int[100001];\\n        l=new int[100001];\\n        maxH1=new int[100001];\\n        maxH2=new int[100001];\\n        Arrays.fill(maxH2,-1);\\n        Arrays.fill(maxH1,-1);\\n        height(root,0);\\n        \\n        for(int i=0;i<queries.length;i++){\\n            \\n            int val=queries[i];\\n            \\n            int hh=h[val];\\n            int lev=l[val];\\n            \\n            int levMaxH1=maxH1[lev];\\n            int levMaxH2=maxH2[lev];\\n            \\n            // Two scenarios to be checked. If the level has only one node or it has node greater than one.\\n            // So to check this we have to keep the value of maxH1 such that we have it does\\n\\t\\t\\t// not include the answer of the height, therefore we can prefill the maxH1 with -1, \\n\\t\\t\\t// since -1 cannot be the height of a node. Now we can get the indication if there more\\n\\t\\t\\t// than one node in a level, then the height of maxH1 will be different that -1.\\n\\t\\t\\t// Otherwise if there is only single node present, the value of maxH1 will remain -1. \\n\\t\\t\\t// This one is the most important scenario.\\n            \\n            if(levMaxH2!=-1){\\n                if(hh==levMaxH1){\\n                    queries[i]=lev + levMaxH2;\\n                }else {\\n                    queries[i]=lev + levMaxH1;\\n                }\\n            }else{\\n                    queries[i]=lev - 1;\\n            }\\n        }\\n        \\n        return queries;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static int[] h,l,maxH1, maxH2;\\n    \\n    \\n    public int height(TreeNode root, int level){ \\n\\t// Simple function to calculate the height of a tree. \\n\\t// Added level to know the node level.\\n\\t// Just simply filled the values of the array and calculate the height at the tree queries function. \\n        \\n        if(root == null) return -1;\\n        \\n        int left=height(root.left, level + 1);\\n        int right=height(root.right, level + 1);\\n        \\n        h[root.val]=Math.max(left,right) + 1;\\n        l[root.val]=level;\\n        \\n        if(h[root.val] > maxH1[level]) {\\n            maxH2[level]=maxH1[level];\\n            maxH1[level]=h[root.val];\\n        }else if(h[root.val] > maxH2[level]){\\n            maxH2[level]=h[root.val];\\n        }\\n        \\n        return h[root.val];\\n    }\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n        h=new int[100001];\\n        l=new int[100001];\\n        maxH1=new int[100001];\\n        maxH2=new int[100001];\\n        Arrays.fill(maxH2,-1);\\n        Arrays.fill(maxH1,-1);\\n        height(root,0);\\n        \\n        for(int i=0;i<queries.length;i++){\\n            \\n            int val=queries[i];\\n            \\n            int hh=h[val];\\n            int lev=l[val];\\n            \\n            int levMaxH1=maxH1[lev];\\n            int levMaxH2=maxH2[lev];\\n            \\n            // Two scenarios to be checked. If the level has only one node or it has node greater than one.\\n            // So to check this we have to keep the value of maxH1 such that we have it does\\n\\t\\t\\t// not include the answer of the height, therefore we can prefill the maxH1 with -1, \\n\\t\\t\\t// since -1 cannot be the height of a node. Now we can get the indication if there more\\n\\t\\t\\t// than one node in a level, then the height of maxH1 will be different that -1.\\n\\t\\t\\t// Otherwise if there is only single node present, the value of maxH1 will remain -1. \\n\\t\\t\\t// This one is the most important scenario.\\n            \\n            if(levMaxH2!=-1){\\n                if(hh==levMaxH1){\\n                    queries[i]=lev + levMaxH2;\\n                }else {\\n                    queries[i]=lev + levMaxH1;\\n                }\\n            }else{\\n                    queries[i]=lev - 1;\\n            }\\n        }\\n        \\n        return queries;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773668,
                "title": "java-using-map",
                "content": "# Intuition\\njust try to store depth and height of each node and try to store all heights at a particular time\\n\\n\\nimport java.util.HashMap;\\nimport java.util.TreeMap;\\nimport java.util.TreeSet;\\n\\nclass TreeNode {\\n    int val;\\n    TreeNode left;\\n    TreeNode right;\\n\\n    TreeNode() {\\n    }\\n\\n    TreeNode(int val) {\\n        this.val = val;\\n    }\\n\\n    TreeNode(int val, TreeNode left, TreeNode right) {\\n        this.val = val;\\n        this.left = left;\\n        this.right = right;\\n    }\\n}\\n\\n\\n\\nclass Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n\\n        HashMap<Integer, TreeMap<Integer,Integer>>map = new HashMap<>();\\n        HashMap<Integer,Integer> pos = new HashMap<>();\\n        HashMap<Integer,Integer> neechesepos = new HashMap<>();\\n        solve(root,0,map,pos,neechesepos);\\n\\n        int m = queries.length;\\n        int j=0;\\n        int[] ans = new int[m];\\n        for (int i:queries){\\n            int d = pos.get(i);\\n            TreeMap<Integer,Integer> treeMap = map.get(d);\\n            int last = treeMap.lastKey();\\n            if (neechesepos.get(i)==last){\\n                if (treeMap.get(last)>1){\\n                    ans[j]= last+pos.get(i);\\n                }else if (treeMap.size()>1){\\n                    Integer  p =treeMap.floorKey(last-1);\\n                    if (p!=null) {\\n                        ans[j] = p + pos.get(i);\\n                    }else{\\n                        ans[j] = pos.get(i);\\n                    }\\n                }else{\\n                    ans[j] = pos.get(i)-1;\\n                }\\n            }else{\\n                ans[j]= last+pos.get(i);\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n\\n    public int solve(TreeNode root,int depth,HashMap<Integer, TreeMap<Integer,Integer>>map,HashMap<Integer,Integer> pos,HashMap<Integer,Integer> neechesepos ){\\n\\n        if (root==null){\\n            return 0;\\n        }\\n\\n        int l = solve(root.left,depth+1,map,pos,neechesepos);\\n        int r = solve(root.right,depth+1,map,pos,neechesepos);\\n        pos.put(root.val,depth);\\n        map.putIfAbsent(depth,new TreeMap<>());\\n        TreeMap<Integer,Integer>temp = map.get(depth);\\n        temp.putIfAbsent(Math.max(l,r),0);\\n        temp.put(Math.max(l,r),temp.get(Math.max(l,r))+1);\\n        map.put(depth,temp);\\n        neechesepos.put(root.val,Math.max(l,r));\\n        return Math.max(l,r)+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] treeQueries(TreeNode root, int[] queries) {\\n\\n        HashMap<Integer, TreeMap<Integer,Integer>>map = new HashMap<>();\\n        HashMap<Integer,Integer> pos = new HashMap<>();\\n        HashMap<Integer,Integer> neechesepos = new HashMap<>();\\n        solve(root,0,map,pos,neechesepos);\\n\\n        int m = queries.length;\\n        int j=0;\\n        int[] ans = new int[m];\\n        for (int i:queries){\\n            int d = pos.get(i);\\n            TreeMap<Integer,Integer> treeMap = map.get(d);\\n            int last = treeMap.lastKey();\\n            if (neechesepos.get(i)==last){\\n                if (treeMap.get(last)>1){\\n                    ans[j]= last+pos.get(i);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2772328,
                "title": "clean-js-solution-euler-tour",
                "content": "Similar Problem: https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/\\n\\n![image](https://assets.leetcode.com/users/images/cf62dabd-f81a-409f-979f-d9070be5f15f_1667446817.5326493.png)\\n\\n\\nSolution:\\n```\\nvar treeQueries = function(root, queries) {\\n    let depth = [];\\n    let nodes = [];\\n    let start = [];\\n    let last = [];\\n    \\n    let tourIndex = 0;\\n    \\n    const visit = (n,d) => {\\n        nodes[tourIndex] = n;\\n        depth[tourIndex] = d;\\n        if(start[n.val] === undefined) {\\n            start[n.val] = tourIndex;\\n        } else {\\n            last[n.val] = tourIndex;\\n        }\\n        tourIndex = tourIndex + 1;\\n    }\\n    \\n    const dfs = (node, depth) => {\\n        if(node === null)\\n            return null;\\n        \\n        visit(node, depth);\\n        \\n        if(node.left) {\\n            dfs(node.left, depth + 1);\\n            visit(node, depth);\\n        }\\n        \\n        if(node.right) {\\n            dfs(node.right, depth + 1);\\n            visit(node, depth);\\n        }\\n    }\\n    \\n    dfs(root, 0);\\n    \\n    let prefixMax = [];\\n    let suffixMax = [];\\n    \\n    for(let i = 0; i < depth.length; i++) {\\n        prefixMax[i] = Math.max(depth[i], (prefixMax[i - 1] ?? -Infinity));\\n    }\\n    \\n    for(let j = depth.length - 1; j >= 0; j--) {\\n        suffixMax[j] = Math.max(depth[j], (suffixMax[j + 1] ?? -Infinity));\\n    }\\n    \\n    let ans = [];\\n    \\n    for(let i = 0; i < queries.length; i++) {\\n        let q = queries[i];\\n        let s = start[q];\\n        let e = last[q] ?? s;\\n        \\n        let bef = prefixMax[s - 1];\\n        let next = suffixMax[e + 1];\\n        \\n        ans.push(Math.max(bef, next));\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar treeQueries = function(root, queries) {\\n    let depth = [];\\n    let nodes = [];\\n    let start = [];\\n    let last = [];\\n    \\n    let tourIndex = 0;\\n    \\n    const visit = (n,d) => {\\n        nodes[tourIndex] = n;\\n        depth[tourIndex] = d;\\n        if(start[n.val] === undefined) {\\n            start[n.val] = tourIndex;\\n        } else {\\n            last[n.val] = tourIndex;\\n        }\\n        tourIndex = tourIndex + 1;\\n    }\\n    \\n    const dfs = (node, depth) => {\\n        if(node === null)\\n            return null;\\n        \\n        visit(node, depth);\\n        \\n        if(node.left) {\\n            dfs(node.left, depth + 1);\\n            visit(node, depth);\\n        }\\n        \\n        if(node.right) {\\n            dfs(node.right, depth + 1);\\n            visit(node, depth);\\n        }\\n    }\\n    \\n    dfs(root, 0);\\n    \\n    let prefixMax = [];\\n    let suffixMax = [];\\n    \\n    for(let i = 0; i < depth.length; i++) {\\n        prefixMax[i] = Math.max(depth[i], (prefixMax[i - 1] ?? -Infinity));\\n    }\\n    \\n    for(let j = depth.length - 1; j >= 0; j--) {\\n        suffixMax[j] = Math.max(depth[j], (suffixMax[j + 1] ?? -Infinity));\\n    }\\n    \\n    let ans = [];\\n    \\n    for(let i = 0; i < queries.length; i++) {\\n        let q = queries[i];\\n        let s = start[q];\\n        let e = last[q] ?? s;\\n        \\n        let bef = prefixMax[s - 1];\\n        let next = suffixMax[e + 1];\\n        \\n        ans.push(Math.max(bef, next));\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2772149,
                "title": "c-easy-dfs",
                "content": "```\\n/*** Inutuion, whenever we want to know min or max for a given node in a positon, since we don\\'t know what lies ahead, so it is always best to travesre twice forward and backward, once we do that we can take the final decision \\n\\nHere idea is the same, traverse preorder left-right and capture the max height seen so far befor the node is visited. Do the same reverse right - left and compare the previous captured heights. Now since we have seen both the side we can confidently give the result which is maximum height seen before visiting a particular node.\\n***/\\n\\nclass Solution {\\npublic:\\n    int maxH = 0;\\n    int height[100001];\\n    void preOrder(TreeNode* node, bool rev, int level) {\\n        if (!node) return;\\n        height[node->val] = max(height[node->val],maxH);\\n        maxH = max(maxH,level);\\n        int curH = 0;\\n        if (rev) {\\n            preOrder(node->right,rev,level+1);\\n            preOrder(node->left,rev,level+1);\\n        } else {\\n            preOrder(node->left,rev,level+1);\\n            preOrder(node->right,rev,level+1);\\n        }\\n        return;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        preOrder(root,false,0);\\n        maxH = 0;\\n        preOrder(root,true,0);\\n        int n = queries.size();\\n        vector<int> result(n,0);\\n        for (int i = 0; i < n; i++) {\\n            result[i] = height[queries[i]];\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*** Inutuion, whenever we want to know min or max for a given node in a positon, since we don\\'t know what lies ahead, so it is always best to travesre twice forward and backward, once we do that we can take the final decision \\n\\nHere idea is the same, traverse preorder left-right and capture the max height seen so far befor the node is visited. Do the same reverse right - left and compare the previous captured heights. Now since we have seen both the side we can confidently give the result which is maximum height seen before visiting a particular node.\\n***/\\n\\nclass Solution {\\npublic:\\n    int maxH = 0;\\n    int height[100001];\\n    void preOrder(TreeNode* node, bool rev, int level) {\\n        if (!node) return;\\n        height[node->val] = max(height[node->val],maxH);\\n        maxH = max(maxH,level);\\n        int curH = 0;\\n        if (rev) {\\n            preOrder(node->right,rev,level+1);\\n            preOrder(node->left,rev,level+1);\\n        } else {\\n            preOrder(node->left,rev,level+1);\\n            preOrder(node->right,rev,level+1);\\n        }\\n        return;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        preOrder(root,false,0);\\n        maxH = 0;\\n        preOrder(root,true,0);\\n        int n = queries.size();\\n        vector<int> result(n,0);\\n        for (int i = 0; i < n; i++) {\\n            result[i] = height[queries[i]];\\n        }\\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772136,
                "title": "c-solution-eular-tour",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numNode(TreeNode* root) {\\n        if (root == nullptr) {\\n            return 0;\\n        }\\n        return numNode(root->left) + numNode(root->right) + 1;\\n    }\\n    int dfs(TreeNode* root, vector<int>& heights, vector<int>& eularTour, int depth) {\\n        if (root == nullptr) {\\n            return 0;\\n        }\\n        int val = root->val;\\n        eularTour.push_back(val);\\n        int l = dfs(root->left, heights, eularTour, depth + 1);\\n        int r = dfs(root->right, heights, eularTour, depth + 1);\\n        eularTour.push_back(val);\\n        heights[val] = depth;\\n        return max(l, r) + 1;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int n = numNode(root);\\n        vector<int> heights(n + 1);\\n        vector<int> eularTour;\\n        dfs(root, heights, eularTour, 0);\\n        int len = eularTour.size();\\n        vector<int> prefixMax(len);\\n        vector<int> suffixMax(len);\\n        prefixMax[0] = heights[eularTour[0]];\\n        suffixMax[len - 1] = heights[eularTour[len - 1]];\\n        for (int i = 1; i < len; i++) {\\n            prefixMax[i] = max(heights[eularTour[i]], prefixMax[i - 1]);\\n        }\\n        for (int i = len - 2; i >= 0; i--) {\\n            suffixMax[i] = max(heights[eularTour[i]], suffixMax[i + 1]);\\n        }\\n        vector<pair<int, int>> pos(n + 1, make_pair(-1, -1));\\n        for (int i = 0; i < len; i++) {\\n            int val = eularTour[i];\\n            if (pos[val].first == -1) {\\n                pos[val].first = i;\\n            } else {\\n                pos[val].second = i;\\n            }\\n        }\\n        int qLen = queries.size();\\n        vector<int> sol(qLen);\\n        for (int i = 0; i < qLen; i++) {\\n            int l = pos[queries[i]].first;\\n            int r = pos[queries[i]].second;\\n            int mx = 0;\\n            if (l - 1 >= 0) {\\n                mx = max(mx, prefixMax[l - 1]);\\n            }\\n            if (r + 1 < len) {\\n                mx = max(mx, suffixMax[r + 1]);\\n            }\\n            sol[i] = mx;\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numNode(TreeNode* root) {\\n        if (root == nullptr) {\\n            return 0;\\n        }\\n        return numNode(root->left) + numNode(root->right) + 1;\\n    }\\n    int dfs(TreeNode* root, vector<int>& heights, vector<int>& eularTour, int depth) {\\n        if (root == nullptr) {\\n            return 0;\\n        }\\n        int val = root->val;\\n        eularTour.push_back(val);\\n        int l = dfs(root->left, heights, eularTour, depth + 1);\\n        int r = dfs(root->right, heights, eularTour, depth + 1);\\n        eularTour.push_back(val);\\n        heights[val] = depth;\\n        return max(l, r) + 1;\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        int n = numNode(root);\\n        vector<int> heights(n + 1);\\n        vector<int> eularTour;\\n        dfs(root, heights, eularTour, 0);\\n        int len = eularTour.size();\\n        vector<int> prefixMax(len);\\n        vector<int> suffixMax(len);\\n        prefixMax[0] = heights[eularTour[0]];\\n        suffixMax[len - 1] = heights[eularTour[len - 1]];\\n        for (int i = 1; i < len; i++) {\\n            prefixMax[i] = max(heights[eularTour[i]], prefixMax[i - 1]);\\n        }\\n        for (int i = len - 2; i >= 0; i--) {\\n            suffixMax[i] = max(heights[eularTour[i]], suffixMax[i + 1]);\\n        }\\n        vector<pair<int, int>> pos(n + 1, make_pair(-1, -1));\\n        for (int i = 0; i < len; i++) {\\n            int val = eularTour[i];\\n            if (pos[val].first == -1) {\\n                pos[val].first = i;\\n            } else {\\n                pos[val].second = i;\\n            }\\n        }\\n        int qLen = queries.size();\\n        vector<int> sol(qLen);\\n        for (int i = 0; i < qLen; i++) {\\n            int l = pos[queries[i]].first;\\n            int r = pos[queries[i]].second;\\n            int mx = 0;\\n            if (l - 1 >= 0) {\\n                mx = max(mx, prefixMax[l - 1]);\\n            }\\n            if (r + 1 < len) {\\n                mx = max(mx, suffixMax[r + 1]);\\n            }\\n            sol[i] = mx;\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771103,
                "title": "java-euler-tour-segment-tree",
                "content": "```\\nclass Solution {\\n    int h[];\\n    public int[] treeQueries(TreeNode root, int[] q) {\\n        int n = count(root) + 1;\\n        h = new int[n];\\n        tour = new int[n * 2];\\n        enter = new int[n];\\n        exit = new int[n];\\n        dfs(root, 0);\\n        SegmentTree obj = new SegmentTree(tour.length);\\n        int ans[] = new int[q.length];\\n        for (int i = 0; i < tour.length; i++) {\\n            obj.update(i, h[tour[i]]);\\n        }\\n        for (int i = 0; i < q.length; i++) {\\n            int l1 = 0, r1 = enter[q[i]], l2 = exit[q[i]], r2 = tour.length;\\n            ans[i] = Math.max(obj.query(l1, r1), obj.query(l2 + 1, r2));\\n        }\\n        return ans;\\n    }\\n\\n    int time = 0;\\n    int enter[], exit[], tour[];\\n    private void dfs(TreeNode root, int d) {\\n        if (root == null) return;\\n        int val = root.val;\\n        h[val] = d;\\n        enter[val] = time;\\n        tour[time++] = val;\\n        dfs(root.left, d + 1);\\n        dfs(root.right, d + 1);\\n        exit[val] = time;\\n        tour[time++] = val;\\n    }\\n\\n    private int count(TreeNode root) {\\n        if (root == null) return 0;\\n        return 1 + count(root.left) + count(root.right);\\n    }\\n\\n    public class SegmentTree {\\n        int N;\\n        int[] seg;\\n\\n        public SegmentTree(int N) {\\n            this.N = N;\\n            this.seg = new int[2*N];\\n        }\\n\\n        void update(int pos, int val) {  // update max\\n            pos += N;\\n            seg[pos] = val;\\n            while (pos > 1) {\\n                pos >>= 1;\\n                seg[pos] = Math.max(seg[2*pos], seg[2*pos+1]);\\n            }\\n        }\\n\\n        // include lo, exclude hi\\n        int query(int lo, int hi) {\\n            lo += N;\\n            hi += N;\\n            int res = 0;\\n            while (lo < hi) {\\n                if ((lo & 1)==1) {\\n                    res = Math.max(res, seg[lo++]);\\n                }\\n                if ((hi & 1)==1) {\\n                    res = Math.max(res, seg[--hi]);\\n                }\\n                lo >>= 1;\\n                hi >>= 1;\\n            }\\n            return res;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int h[];\\n    public int[] treeQueries(TreeNode root, int[] q) {\\n        int n = count(root) + 1;\\n        h = new int[n];\\n        tour = new int[n * 2];\\n        enter = new int[n];\\n        exit = new int[n];\\n        dfs(root, 0);\\n        SegmentTree obj = new SegmentTree(tour.length);\\n        int ans[] = new int[q.length];\\n        for (int i = 0; i < tour.length; i++) {\\n            obj.update(i, h[tour[i]]);\\n        }\\n        for (int i = 0; i < q.length; i++) {\\n            int l1 = 0, r1 = enter[q[i]], l2 = exit[q[i]], r2 = tour.length;\\n            ans[i] = Math.max(obj.query(l1, r1), obj.query(l2 + 1, r2));\\n        }\\n        return ans;\\n    }\\n\\n    int time = 0;\\n    int enter[], exit[], tour[];\\n    private void dfs(TreeNode root, int d) {\\n        if (root == null) return;\\n        int val = root.val;\\n        h[val] = d;\\n        enter[val] = time;\\n        tour[time++] = val;\\n        dfs(root.left, d + 1);\\n        dfs(root.right, d + 1);\\n        exit[val] = time;\\n        tour[time++] = val;\\n    }\\n\\n    private int count(TreeNode root) {\\n        if (root == null) return 0;\\n        return 1 + count(root.left) + count(root.right);\\n    }\\n\\n    public class SegmentTree {\\n        int N;\\n        int[] seg;\\n\\n        public SegmentTree(int N) {\\n            this.N = N;\\n            this.seg = new int[2*N];\\n        }\\n\\n        void update(int pos, int val) {  // update max\\n            pos += N;\\n            seg[pos] = val;\\n            while (pos > 1) {\\n                pos >>= 1;\\n                seg[pos] = Math.max(seg[2*pos], seg[2*pos+1]);\\n            }\\n        }\\n\\n        // include lo, exclude hi\\n        int query(int lo, int hi) {\\n            lo += N;\\n            hi += N;\\n            int res = 0;\\n            while (lo < hi) {\\n                if ((lo & 1)==1) {\\n                    res = Math.max(res, seg[lo++]);\\n                }\\n                if ((hi & 1)==1) {\\n                    res = Math.max(res, seg[--hi]);\\n                }\\n                lo >>= 1;\\n                hi >>= 1;\\n            }\\n            return res;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771030,
                "title": "c-explained-solution",
                "content": "```\\n/* \\nfor each node, calculate height of subtree under it and store in unordered_map ht\\n\\nfinding height of each subtree using dfs in bottum up manner\\n\\nheight of root is maximum\\n\\nfind level of each node from top (using BFS)\\n\\nfor particular level, store height of each node of that level in map mp\\n\\nnow if we are removing node x of level l, than there can be 3 cases -:\\n\\n1-> there can be other node on this level whose ht is greater than x, \\nthan height of tree after removal of x = l+maximum  height of any node of this level other than that of x\\n2-> all nodes of this level have height less than the height of x, \\nso after removal of x, height of tree= l+maximum height of any node of this level other than that of x\\n3-> this node is the only node on this level, than after its removal, height of tree= l-1\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int,int>ht;\\n \\n    unordered_map<int,int>lvl;\\n   \\n    vector<int> treeQueries(TreeNode* root, vector<int>& qr) {\\n    \\n        \\n        dfs(root);\\n        \\n        unordered_map<int,vector<int>>mp;  \\n        \\n        // lvl => {depth under all nodes of that level}\\n        \\n        queue<pair<TreeNode*,int>>q;\\n        \\n        q.push({root,0});\\n                                             \\n        while(!q.empty()){\\n            \\n            int sz=q.size();\\n            \\n            while(sz--){\\n                \\n            TreeNode* node=q.front().first;\\n            \\n            int l=q.front().second;\\n            \\n            q.pop();\\n            \\n            lvl[node->val]=l;\\n                \\n            mp[l].push_back(ht[node->val]);\\n            \\n            if(node->left){\\n                q.push({node->left,l+1});\\n            }\\n            \\n            if(node->right){\\n                q.push({node->right,l+1});\\n            }\\n                \\n        }\\n                        \\n    }\\n        \\n        for(auto &it:mp){\\n            sort(it.second.begin(),it.second.end());\\n        }\\n\\n        \\n        int n=qr.size();\\n        \\n        vector<int>ans;\\n        \\n        int node,l,h,idx,prev;\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            node=qr[i];\\n            \\n            l=lvl[node];\\n            \\n            h=ht[node];\\n            \\n            idx=lower_bound(mp[l].begin(),mp[l].end(),h)-mp[l].begin();\\n                        \\n            prev=idx-1;\\n            \\n            if(idx!=mp[l].size()-1){\\n                ans.push_back(l+mp[l][mp[l].size()-1]);\\n            }\\n            \\n            else if(prev>=0){\\n                ans.push_back(l+mp[l][prev]);\\n            }\\n            else{\\n                ans.push_back(l-1);\\n            }\\n            \\n           \\n        }\\n        \\n       return ans;\\n        \\n    }\\n    \\n    int dfs(TreeNode* root){\\n        if(!root)\\n            return -1;\\n        \\n        int l=dfs(root->left);\\n        \\n        int r=dfs(root->right);\\n        \\n        return ht[root->val]=1+max(l,r);\\n        \\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    unordered_map<int,int>ht;\\n \\n    unordered_map<int,int>lvl;\\n   \\n    vector<int> treeQueries(TreeNode* root, vector<int>& qr) {\\n    \\n        \\n        dfs(root);\\n        \\n        unordered_map<int,vector<int>>mp;  \\n        \\n        // lvl => {depth under all nodes of that level}",
                "codeTag": "Java"
            },
            {
                "id": 2770123,
                "title": "python-not-using-defaultdict",
                "content": "\\n\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        \\n        # Step1. Record the depth and length of each nodes \\n        # depth means the number of edges from root to current node \\n        # length means the maximum number of edges from current node to leaf node \\n             \\n        depth = {}\\n        length = {}\\n        def dfs (node, d):            \\n            if not node:\\n                return -1            \\n            depth[node.val] = d \\n            length[node.val] = max(dfs(node.left, d+1), dfs(node.right, d+1)) + 1\\n            return length[node.val]        \\n        dfs (root, 0)\\n        \\n        # Step2. Record the cousins according to depth\\n        \\n        cousins = {}\\n        for val, d in depth.items():\\n            cousins.setdefault(d, []).append([val, length[val]])\\n        for d, nodes in cousins.items():\\n            cousins[d] = sorted(nodes, key = lambda element : -element[1])\\n                \\n        # Step3. Iterate queries:\\n        \\n        res = []\\n        for num in queries:\\n            d = depth[num]\\n            if cousins[d][0][0] == num :\\n                if len(cousins[d]) == 1:\\n                    res.append(d-1)\\n                else :\\n                    res.append(d+cousins[d][1][1])\\n            else:\\n                res.append(length[root.val])\\n        return res",
                "solutionTags": [],
                "code": "\\n\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        \\n        # Step1. Record the depth and length of each nodes \\n        # depth means the number of edges from root to current node \\n        # length means the maximum number of edges from current node to leaf node \\n             \\n        depth = {}\\n        length = {}\\n        def dfs (node, d):            \\n            if not node:\\n                return -1            \\n            depth[node.val] = d \\n            length[node.val] = max(dfs(node.left, d+1), dfs(node.right, d+1)) + 1\\n            return length[node.val]        \\n        dfs (root, 0)\\n        \\n        # Step2. Record the cousins according to depth\\n        \\n        cousins = {}\\n        for val, d in depth.items():\\n            cousins.setdefault(d, []).append([val, length[val]])\\n        for d, nodes in cousins.items():\\n            cousins[d] = sorted(nodes, key = lambda element : -element[1])\\n                \\n        # Step3. Iterate queries:\\n        \\n        res = []\\n        for num in queries:\\n            d = depth[num]\\n            if cousins[d][0][0] == num :\\n                if len(cousins[d]) == 1:\\n                    res.append(d-1)\\n                else :\\n                    res.append(d+cousins[d][1][1])\\n            else:\\n                res.append(length[root.val])\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2768553,
                "title": "fastest-simple-level-order-traversal-bfs-memorization",
                "content": "\\n\\tclass Solution {\\n\\tpublic:   \\n\\t\\tint xx(TreeNode* root,int mp[]){\\n\\t\\t\\tif(root==NULL) return -1;\\n\\t\\t\\treturn mp[root->val]=max(xx(root->left,mp),xx(root->right,mp))+1;\\n\\t\\t}    \\n\\n\\t\\tvector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n\\t\\t\\tint mp[100001];\\n\\t\\t\\txx(root,mp);\\n\\t\\t\\tqueue<TreeNode*>xx;\\n\\t\\t\\txx.push(root);\\n\\t\\t\\tint t=0;\\n\\t\\t\\twhile(xx.size()){\\n\\t\\t\\t\\tint n=xx.size();\\n\\t\\t\\t\\tqueue<int>yy;\\n\\t\\t\\t\\tint maxx=-1,maxx2=-1;\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tTreeNode* k = xx.front();\\n\\t\\t\\t\\t\\txx.pop();\\n\\t\\t\\t\\t\\tif(k->left!=NULL){\\n\\t\\t\\t\\t\\t\\txx.push(k->left);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(k->right!=NULL){\\n\\t\\t\\t\\t\\t\\txx.push(k->right);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(mp[k->val]>=maxx){\\n\\t\\t\\t\\t\\t\\tmaxx2=maxx;\\n\\t\\t\\t\\t\\t\\tmaxx=mp[k->val];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(maxx2<mp[k->val]){\\n\\t\\t\\t\\t\\t\\tmaxx2=mp[k->val];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tyy.push(k->val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\t\\tint k=yy.front();\\n\\t\\t\\t\\t\\tyy.pop();\\n\\t\\t\\t\\t\\tif(mp[k]==maxx){\\n\\t\\t\\t\\t\\t\\tmp[k]=t+maxx2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tmp[k]=t+maxx;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tt++;\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tfor(int i=0;i<queries.size();i++){\\n\\t\\t\\t\\tans.push_back(mp[queries[i]]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Breadth-First Search",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:   \\n\\t\\tint xx(TreeNode* root,int mp[]){\\n\\t\\t\\tif(root==NULL) return -1;\\n\\t\\t\\treturn mp[root->val]=max(xx(root->left,mp),xx(root->right,mp))+1;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2768272,
                "title": "depths-heights-and-levels-python",
                "content": "```\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        def dfs(node, depth): # -> returns the height\\n            if node is None:\\n                return -1\\n            depths[node.val] = depth\\n            h = max(dfs(node.left, depth + 1), dfs(node.right, depth + 1)) + 1\\n            heights[node.val] = h\\n            return h\\n        \\n        depths = defaultdict(int) # node.val --> depth\\n        heights = defaultdict(int) # node.val --> height\\n        levels = defaultdict(list) # depth --> [(height, node.val)]\\n        dfs(root, 0)\\n        for val, d in depths.items():\\n            levels[d].append((-heights[val], val))\\n            levels[d].sort() # O(1) operations, since the list has only 2 elements at most\\n            if len(levels[d]) > 2:\\n                levels[d].pop()\\n                \\n        ans = []\\n        for q in queries:\\n            d = depths[q]\\n            if len(levels[d]) == 1:\\n                ans.append(d - 1)\\n            elif levels[d][0][1] == q:\\n                ans.append(d - levels[d][1][0])\\n            else:\\n                ans.append(d - levels[d][0][0])\\n        return ans\\n    # Time: O(N + Q) where N is the number of nodes in the tree and Q the number of queries\\n    # Space: O(N + Q) for the depths, heights and levels dictionaries: O(N); and for the output: O(Q)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def treeQueries(self, root: Optional[TreeNode], queries: List[int]) -> List[int]:\\n        def dfs(node, depth): # -> returns the height\\n            if node is None:\\n                return -1\\n            depths[node.val] = depth\\n            h = max(dfs(node.left, depth + 1), dfs(node.right, depth + 1)) + 1\\n            heights[node.val] = h\\n            return h\\n        \\n        depths = defaultdict(int) # node.val --> depth\\n        heights = defaultdict(int) # node.val --> height\\n        levels = defaultdict(list) # depth --> [(height, node.val)]\\n        dfs(root, 0)\\n        for val, d in depths.items():\\n            levels[d].append((-heights[val], val))\\n            levels[d].sort() # O(1) operations, since the list has only 2 elements at most\\n            if len(levels[d]) > 2:\\n                levels[d].pop()\\n                \\n        ans = []\\n        for q in queries:\\n            d = depths[q]\\n            if len(levels[d]) == 1:\\n                ans.append(d - 1)\\n            elif levels[d][0][1] == q:\\n                ans.append(d - levels[d][1][0])\\n            else:\\n                ans.append(d - levels[d][0][0])\\n        return ans\\n    # Time: O(N + Q) where N is the number of nodes in the tree and Q the number of queries\\n    # Space: O(N + Q) for the depths, heights and levels dictionaries: O(N); and for the output: O(Q)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768163,
                "title": "c-level-depth-solution",
                "content": "This solution is based on https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/discuss/2757990/Python-3-Explanation-with-pictures-DFS\\nI\\'ve merely implemented it\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n        void levelOrder(TreeNode* root,unordered_map<int,vector<pair<int,int>>>& mpp,unordered_map<int,int> &mpp2,vector<int>& heights) {\\n        queue<TreeNode*> q;\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        q.push(root);\\n        int depth=0;\\n        while(q.size()!=0)\\n        {\\n            int n=q.size();\\n            vector<pair<int,int>> vec;\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                vec.push_back(pair<int,int>(heights[temp->val],temp->val));\\n                mpp2[temp->val]=depth;\\n                if(temp->left!=NULL)\\n                    q.push(temp->left);\\n                if(temp->right!=NULL)\\n                    q.push(temp->right);\\n            }\\n            sort(vec.begin(),vec.end());\\n            if(vec.size()>=2)\\n                mpp[depth].push_back(vec[vec.size()-2]);\\n             mpp[depth].push_back(vec[vec.size()-1]);\\n            depth++;\\n        }\\n    }\\n    int height(TreeNode* root,vector<int> &heights)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        if(heights[root->val]!=-1)\\n            return heights[root->val];\\n        return heights[root->val]=1+max(height(root->left,heights),height(root->right,heights));\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int> heights(1e5+1,-1);\\n        height(root,heights);\\n        unordered_map<int,vector<pair<int,int>>> mpp; //depth -> [(height,val)]\\n        unordered_map<int,int> mpp2;\\n        levelOrder(root,mpp,mpp2,heights);\\n        vector<int> ans(queries.size());\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            vector<pair<int,int>> t=mpp[mpp2[queries[i]]];\\n            bool temp=false;\\n            for(int j=t.size()-1;j>=0;j--)\\n            {\\n                if(t[j].second!=queries[i])\\n                {\\n                    temp=true;\\n                    ans[i]=t[j].first+mpp2[queries[i]]-1;\\n                    break;\\n                }\\n            }\\n            if(!temp)\\n            {\\n                ans[i]=mpp2[queries[i]]-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease UPVOTE, if it helps and do ask if there is any confusion.",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n        void levelOrder(TreeNode* root,unordered_map<int,vector<pair<int,int>>>& mpp,unordered_map<int,int> &mpp2,vector<int>& heights) {\\n        queue<TreeNode*> q;\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        q.push(root);\\n        int depth=0;\\n        while(q.size()!=0)\\n        {\\n            int n=q.size();\\n            vector<pair<int,int>> vec;\\n            for(int i=0;i<n;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                vec.push_back(pair<int,int>(heights[temp->val],temp->val));\\n                mpp2[temp->val]=depth;\\n                if(temp->left!=NULL)\\n                    q.push(temp->left);\\n                if(temp->right!=NULL)\\n                    q.push(temp->right);\\n            }\\n            sort(vec.begin(),vec.end());\\n            if(vec.size()>=2)\\n                mpp[depth].push_back(vec[vec.size()-2]);\\n             mpp[depth].push_back(vec[vec.size()-1]);\\n            depth++;\\n        }\\n    }\\n    int height(TreeNode* root,vector<int> &heights)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        if(heights[root->val]!=-1)\\n            return heights[root->val];\\n        return heights[root->val]=1+max(height(root->left,heights),height(root->right,heights));\\n    }\\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\\n        vector<int> heights(1e5+1,-1);\\n        height(root,heights);\\n        unordered_map<int,vector<pair<int,int>>> mpp; //depth -> [(height,val)]\\n        unordered_map<int,int> mpp2;\\n        levelOrder(root,mpp,mpp2,heights);\\n        vector<int> ans(queries.size());\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            vector<pair<int,int>> t=mpp[mpp2[queries[i]]];\\n            bool temp=false;\\n            for(int j=t.size()-1;j>=0;j--)\\n            {\\n                if(t[j].second!=queries[i])\\n                {\\n                    temp=true;\\n                    ans[i]=t[j].first+mpp2[queries[i]]-1;\\n                    break;\\n                }\\n            }\\n            if(!temp)\\n            {\\n                ans[i]=mpp2[queries[i]]-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1968605,
                "content": [
                    {
                        "username": "night_sky-02",
                        "content": "Hint 1:What we need to think is that in what cases will the height of the overall tree be affected by deleting the given node.\\nHint 2:It depends on the other nodes on the same level as the given node\\n[Easy to Understand well-explained Solution](https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/solutions/3760689/well-explained-c-height-level-o-n/)"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "It took me 1.5 hour to finish. On white borad, it could be 3 hours."
                    },
                    {
                        "username": "igorbel",
                        "content": "Example 2 seem misleading :\nHow is it possible that after second subtree removal height of tree increased  [3,2,3,2] ? I think the correct answer in the example supposed to be : [3,2,2,2] \n-- never mind \"independent\""
                    },
                    {
                        "username": "ajitsai",
                        "content": "sub tree removal is local to the query. You basically find the depth without considering the subtree in that specific query. "
                    }
                ]
            },
            {
                "id": 1980636,
                "content": [
                    {
                        "username": "night_sky-02",
                        "content": "Hint 1:What we need to think is that in what cases will the height of the overall tree be affected by deleting the given node.\\nHint 2:It depends on the other nodes on the same level as the given node\\n[Easy to Understand well-explained Solution](https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/solutions/3760689/well-explained-c-height-level-o-n/)"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "It took me 1.5 hour to finish. On white borad, it could be 3 hours."
                    },
                    {
                        "username": "igorbel",
                        "content": "Example 2 seem misleading :\nHow is it possible that after second subtree removal height of tree increased  [3,2,3,2] ? I think the correct answer in the example supposed to be : [3,2,2,2] \n-- never mind \"independent\""
                    },
                    {
                        "username": "ajitsai",
                        "content": "sub tree removal is local to the query. You basically find the depth without considering the subtree in that specific query. "
                    }
                ]
            },
            {
                "id": 1984476,
                "content": [
                    {
                        "username": "night_sky-02",
                        "content": "Hint 1:What we need to think is that in what cases will the height of the overall tree be affected by deleting the given node.\\nHint 2:It depends on the other nodes on the same level as the given node\\n[Easy to Understand well-explained Solution](https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/solutions/3760689/well-explained-c-height-level-o-n/)"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "It took me 1.5 hour to finish. On white borad, it could be 3 hours."
                    },
                    {
                        "username": "igorbel",
                        "content": "Example 2 seem misleading :\nHow is it possible that after second subtree removal height of tree increased  [3,2,3,2] ? I think the correct answer in the example supposed to be : [3,2,2,2] \n-- never mind \"independent\""
                    },
                    {
                        "username": "ajitsai",
                        "content": "sub tree removal is local to the query. You basically find the depth without considering the subtree in that specific query. "
                    }
                ]
            }
        ]
    }
]