[
    {
        "title": "Shortest Path in Binary Matrix",
        "question_content": "Given an n x n binary matrix grid, return the length of the shortest clear path in the matrix. If there is no clear path, return -1.\nA clear path in a binary matrix is a path from the top-left cell (i.e., (0, 0)) to the bottom-right cell (i.e., (n - 1, n - 1)) such that:\n\n\tAll the visited cells of the path are 0.\n\tAll the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\n\nThe length of a clear path is the number of visited cells of this path.\n&nbsp;\nExample 1:\n\nInput: grid = [[0,1],[1,0]]\nOutput: 2\n\nExample 2:\n\nInput: grid = [[0,0,0],[1,1,0],[1,1,0]]\nOutput: 4\n\nExample 3:\n\nInput: grid = [[1,0,0],[1,1,0],[1,1,0]]\nOutput: -1\n\n&nbsp;\nConstraints:\n\n\tn == grid.length\n\tn == grid[i].length\n\t1 <= n <= 100\n\tgrid[i][j] is 0 or 1",
        "solutions": [
            {
                "id": 313347,
                "title": "a-search-in-python",
                "content": "An A* search is like a breadth-first seach, except that in each iteration, instead of expanding the cell with the shortest path from the origin, we expand the cell with the lowest overall estimated path length -- this is the distance so far, plus a heuristic (rule-of-thumb) estimate of the remaining distance. As long as the heuristic is [consistent](https://en.wikipedia.org/wiki/Consistent_heuristic), an A* graph-search will find the shortest path. This can be somewhat more efficient than breadth-first-search as we typically don\\'t have to visit nearly as many cells. Intuitively, an A* search has an approximate sense of direction, and uses this sense to guide it towards the target.\\n\\n# Example\\n\\n```\\n[\\n\\t[0,0,0,1,0,0,1,0],\\n\\t[0,0,0,0,0,0,0,0],\\n\\t[1,0,0,1,1,0,1,0],\\n\\t[0,1,1,1,0,0,0,0],\\n\\t[0,0,0,0,0,1,1,1],\\n\\t[1,0,1,0,0,0,0,0],\\n\\t[1,1,0,0,0,1,0,0],\\n\\t[0,0,0,0,0,1,0,0]\\n]\\n```\\n\\nWith this grid, an A* search will expolore only the green cells in this animation:\\n\\n![image](https://assets.leetcode.com/static_assets/posts/giphy.gif)\\n\\nWhereas a BFS will visit *every* cell:\\n\\n![image](https://assets.leetcode.com/users/lxnn/image_1560734489.png)\\n\\n# Implementation\\n\\nWe perform an A* search to find the shortest path, then return it\\'s length, if there is one. Note: I chose to deal with the special case, that the starting cell is a blocking cell, here rather than complicate the search implementation.\\n\\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid):\\n        shortest_path = a_star_graph_search(\\n            start              = (0, 0), \\n            goal_function      = get_goal_function(grid),\\n            successor_function = get_successor_function(grid),\\n            heuristic          = get_heuristic(grid)\\n        )\\n        if shortest_path is None or grid[0][0] == 1:\\n            return -1\\n        else:\\n            return len(shortest_path)\\n```\\n\\n## A* search function\\n\\nThis implementation is somewhat general and will work for other constant-cost search problems, as long as you provide a suitable goal function, successor function, and heuristic.\\n\\n```python\\ndef a_star_graph_search(\\n            start,\\n            goal_function,\\n            successor_function,\\n            heuristic\\n\\t):\\n    visited = set()\\n    came_from = dict()\\n    distance = {start: 0}\\n    frontier = PriorityQueue()\\n    frontier.add(start)\\n    while frontier:\\n        node = frontier.pop()\\n        if node in visited:\\n            continue\\n        if goal_function(node):\\n            return reconstruct_path(came_from, start, node)\\n        visited.add(node)\\n        for successor in successor_function(node):\\n            frontier.add(\\n                successor,\\n                priority = distance[node] + 1 + heuristic(successor)\\n            )\\n            if (successor not in distance\\n                or distance[node] + 1 < distance[successor]):\\n                distance[successor] = distance[node] + 1\\n                came_from[successor] = node\\n    return None\\n\\ndef reconstruct_path(came_from, start, end):\\n    \"\"\"\\n    >>> came_from = {\\'b\\': \\'a\\', \\'c\\': \\'a\\', \\'d\\': \\'c\\', \\'e\\': \\'d\\', \\'f\\': \\'d\\'}\\n    >>> reconstruct_path(came_from, \\'a\\', \\'e\\')\\n    [\\'a\\', \\'c\\', \\'d\\', \\'e\\']\\n    \"\"\"\\n    reverse_path = [end]\\n    while end != start:\\n        end = came_from[end]\\n        reverse_path.append(end)\\n    return list(reversed(reverse_path))\\n```\\n\\n## Goal function\\n\\nWe need a function to check whether we have reached the goal cell:\\n\\n```python\\ndef get_goal_function(grid):\\n    \"\"\"\\n    >>> f = get_goal_function([[0, 0], [0, 0]])\\n    >>> f((0, 0))\\n    False\\n    >>> f((0, 1))\\n    False\\n    >>> f((1, 1))\\n    True\\n    \"\"\"\\n    M = len(grid)\\n    N = len(grid[0])\\n    def is_bottom_right(cell):\\n        return cell == (M-1, N-1)\\n    return is_bottom_right\\n```\\n\\n## Successor function\\n\\nWe also need a function to find the cells adjacent to the current cell:\\n\\n```python\\ndef get_successor_function(grid):\\n    \"\"\"\\n    >>> f = get_successor_function([[0, 0, 0], [0, 1, 0], [1, 0, 0]])\\n    >>> sorted(f((1, 2)))\\n    [(0, 1), (0, 2), (2, 1), (2, 2)]\\n    >>> sorted(f((2, 1)))\\n    [(1, 0), (1, 2), (2, 2)]\\n    \"\"\"\\n    def get_clear_adjacent_cells(cell):\\n        i, j = cell\\n        return (\\n            (i + a, j + b)\\n            for a in (-1, 0, 1)\\n            for b in (-1, 0, 1)\\n            if a != 0 or b != 0\\n            if 0 <= i + a < len(grid)\\n            if 0 <= j + b < len(grid[0])\\n            if grid[i + a][j + b] == 0\\n        )\\n    return get_clear_adjacent_cells\\n```\\n\\n## Heuristic\\n\\nThe chosen heuristic is simply the distance to the goal in a clear grid of the same size. This turns out to be the maximum of the x-distance and y-distance from the goal. This heuristic is [admissible](https://en.wikipedia.org/wiki/Admissible_heuristic) and [consistent](https://en.wikipedia.org/wiki/Consistent_heuristic).\\n\\n```python\\ndef get_heuristic(grid):\\n    \"\"\"\\n    >>> f = get_heuristic([[0, 0], [0, 0]])\\n    >>> f((0, 0))\\n    1\\n    >>> f((0, 1))\\n    1\\n    >>> f((1, 1))\\n    0\\n    \"\"\"\\n    M, N = len(grid), len(grid[0])\\n    (a, b) = goal_cell = (M - 1, N - 1)\\n    def get_clear_path_distance_from_goal(cell):\\n        (i, j) = cell\\n        return max(abs(a - i), abs(b - j))\\n    return get_clear_path_distance_from_goal\\n```\\n\\n## Priority queue\\n\\nThe Python standard library provides a heap data structure, but not a priority-queue, so we need to implement one ourselves.\\n\\n```python\\nfrom heapq import heappush, heappop\\n\\nclass PriorityQueue:\\n    \\n    def __init__(self, iterable=[]):\\n        self.heap = []\\n        for value in iterable:\\n            heappush(self.heap, (0, value))\\n    \\n    def add(self, value, priority=0):\\n        heappush(self.heap, (priority, value))\\n    \\n    def pop(self):\\n        priority, value = heappop(self.heap)\\n        return value\\n    \\n    def __len__(self):\\n        return len(self.heap)\\n```\\n\\nAnd that\\'s it. \\n\\n# Breadth-first search\\n\\nHere is a breadth-first-search implementation, for comparison:\\n\\n```python\\nfrom collections import deque\\n\\ndef breadth_first_search(grid):\\n    N = len(grid)\\n\\n    def is_clear(cell):\\n        return grid[cell[0]][cell[1]] == 0\\n\\n    def get_neighbours(cell):\\n        (i, j) = cell\\n        return (\\n            (i + a, j + b)\\n            for a in (-1, 0, 1)\\n            for b in (-1, 0, 1)\\n            if a != 0 or b != 0\\n            if 0 <= i + a < N\\n            if 0 <= j + b < N\\n            if is_clear( (i + a, j + b) )\\n        )\\n\\n    start = (0, 0)\\n    goal = (N - 1, N - 1)\\n\\n    queue = deque()\\n    if is_clear(start):\\n        queue.append(start)\\n    visited = set()\\n    path_len = {start: 1}\\n\\n    while queue:\\n        cell = queue.popleft()\\n        if cell in visited:\\n            continue\\n        if cell == goal:\\n            return path_len[cell]\\n        visited.add(cell)\\n        for neighbour in get_neighbours(cell):\\n            if neighbour not in path_len:\\n                path_len[neighbour] = path_len[cell] + 1\\n            queue.append(neighbour)\\n\\n    return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n[\\n\\t[0,0,0,1,0,0,1,0],\\n\\t[0,0,0,0,0,0,0,0],\\n\\t[1,0,0,1,1,0,1,0],\\n\\t[0,1,1,1,0,0,0,0],\\n\\t[0,0,0,0,0,1,1,1],\\n\\t[1,0,1,0,0,0,0,0],\\n\\t[1,1,0,0,0,1,0,0],\\n\\t[0,0,0,0,0,1,0,0]\\n]\\n```\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid):\\n        shortest_path = a_star_graph_search(\\n            start              = (0, 0), \\n            goal_function      = get_goal_function(grid),\\n            successor_function = get_successor_function(grid),\\n            heuristic          = get_heuristic(grid)\\n        )\\n        if shortest_path is None or grid[0][0] == 1:\\n            return -1\\n        else:\\n            return len(shortest_path)\\n```\n```python\\ndef a_star_graph_search(\\n            start,\\n            goal_function,\\n            successor_function,\\n            heuristic\\n\\t):\\n    visited = set()\\n    came_from = dict()\\n    distance = {start: 0}\\n    frontier = PriorityQueue()\\n    frontier.add(start)\\n    while frontier:\\n        node = frontier.pop()\\n        if node in visited:\\n            continue\\n        if goal_function(node):\\n            return reconstruct_path(came_from, start, node)\\n        visited.add(node)\\n        for successor in successor_function(node):\\n            frontier.add(\\n                successor,\\n                priority = distance[node] + 1 + heuristic(successor)\\n            )\\n            if (successor not in distance\\n                or distance[node] + 1 < distance[successor]):\\n                distance[successor] = distance[node] + 1\\n                came_from[successor] = node\\n    return None\\n\\ndef reconstruct_path(came_from, start, end):\\n    \"\"\"\\n    >>> came_from = {\\'b\\': \\'a\\', \\'c\\': \\'a\\', \\'d\\': \\'c\\', \\'e\\': \\'d\\', \\'f\\': \\'d\\'}\\n    >>> reconstruct_path(came_from, \\'a\\', \\'e\\')\\n    [\\'a\\', \\'c\\', \\'d\\', \\'e\\']\\n    \"\"\"\\n    reverse_path = [end]\\n    while end != start:\\n        end = came_from[end]\\n        reverse_path.append(end)\\n    return list(reversed(reverse_path))\\n```\n```python\\ndef get_goal_function(grid):\\n    \"\"\"\\n    >>> f = get_goal_function([[0, 0], [0, 0]])\\n    >>> f((0, 0))\\n    False\\n    >>> f((0, 1))\\n    False\\n    >>> f((1, 1))\\n    True\\n    \"\"\"\\n    M = len(grid)\\n    N = len(grid[0])\\n    def is_bottom_right(cell):\\n        return cell == (M-1, N-1)\\n    return is_bottom_right\\n```\n```python\\ndef get_successor_function(grid):\\n    \"\"\"\\n    >>> f = get_successor_function([[0, 0, 0], [0, 1, 0], [1, 0, 0]])\\n    >>> sorted(f((1, 2)))\\n    [(0, 1), (0, 2), (2, 1), (2, 2)]\\n    >>> sorted(f((2, 1)))\\n    [(1, 0), (1, 2), (2, 2)]\\n    \"\"\"\\n    def get_clear_adjacent_cells(cell):\\n        i, j = cell\\n        return (\\n            (i + a, j + b)\\n            for a in (-1, 0, 1)\\n            for b in (-1, 0, 1)\\n            if a != 0 or b != 0\\n            if 0 <= i + a < len(grid)\\n            if 0 <= j + b < len(grid[0])\\n            if grid[i + a][j + b] == 0\\n        )\\n    return get_clear_adjacent_cells\\n```\n```python\\ndef get_heuristic(grid):\\n    \"\"\"\\n    >>> f = get_heuristic([[0, 0], [0, 0]])\\n    >>> f((0, 0))\\n    1\\n    >>> f((0, 1))\\n    1\\n    >>> f((1, 1))\\n    0\\n    \"\"\"\\n    M, N = len(grid), len(grid[0])\\n    (a, b) = goal_cell = (M - 1, N - 1)\\n    def get_clear_path_distance_from_goal(cell):\\n        (i, j) = cell\\n        return max(abs(a - i), abs(b - j))\\n    return get_clear_path_distance_from_goal\\n```\n```python\\nfrom heapq import heappush, heappop\\n\\nclass PriorityQueue:\\n    \\n    def __init__(self, iterable=[]):\\n        self.heap = []\\n        for value in iterable:\\n            heappush(self.heap, (0, value))\\n    \\n    def add(self, value, priority=0):\\n        heappush(self.heap, (priority, value))\\n    \\n    def pop(self):\\n        priority, value = heappop(self.heap)\\n        return value\\n    \\n    def __len__(self):\\n        return len(self.heap)\\n```\n```python\\nfrom collections import deque\\n\\ndef breadth_first_search(grid):\\n    N = len(grid)\\n\\n    def is_clear(cell):\\n        return grid[cell[0]][cell[1]] == 0\\n\\n    def get_neighbours(cell):\\n        (i, j) = cell\\n        return (\\n            (i + a, j + b)\\n            for a in (-1, 0, 1)\\n            for b in (-1, 0, 1)\\n            if a != 0 or b != 0\\n            if 0 <= i + a < N\\n            if 0 <= j + b < N\\n            if is_clear( (i + a, j + b) )\\n        )\\n\\n    start = (0, 0)\\n    goal = (N - 1, N - 1)\\n\\n    queue = deque()\\n    if is_clear(start):\\n        queue.append(start)\\n    visited = set()\\n    path_len = {start: 1}\\n\\n    while queue:\\n        cell = queue.popleft()\\n        if cell in visited:\\n            continue\\n        if cell == goal:\\n            return path_len[cell]\\n        visited.add(cell)\\n        for neighbour in get_neighbours(cell):\\n            if neighbour not in path_len:\\n                path_len[neighbour] = path_len[cell] + 1\\n            queue.append(neighbour)\\n\\n    return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312827,
                "title": "python-concise-bfs",
                "content": "Since it\\'s BFS, we can securely set the visited grid as non-empty to avoid revisiting.\\n```\\ndef shortestPathBinaryMatrix(grid):\\n\\tn = len(grid)\\n\\tif grid[0][0] or grid[n-1][n-1]:\\n\\t\\treturn -1\\n\\tq = [(0, 0, 1)]\\n\\tgrid[0][0] = 1\\n\\tfor i, j, d in q:\\n\\t\\tif i == n-1 and j == n-1: return d\\n\\t\\tfor x, y in ((i-1,j-1),(i-1,j),(i-1,j+1),(i,j-1),(i,j+1),(i+1,j-1),(i+1,j),(i+1,j+1)):\\n\\t\\t\\tif 0 <= x < n and 0 <= y < n and not grid[x][y]:\\n\\t\\t\\t\\tgrid[x][y] = 1\\n\\t\\t\\t\\tq.append((x, y, d+1))\\n\\treturn -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef shortestPathBinaryMatrix(grid):\\n\\tn = len(grid)\\n\\tif grid[0][0] or grid[n-1][n-1]:\\n\\t\\treturn -1\\n\\tq = [(0, 0, 1)]\\n\\tgrid[0][0] = 1\\n\\tfor i, j, d in q:\\n\\t\\tif i == n-1 and j == n-1: return d\\n\\t\\tfor x, y in ((i-1,j-1),(i-1,j),(i-1,j+1),(i,j-1),(i,j+1),(i+1,j-1),(i+1,j),(i+1,j+1)):\\n\\t\\t\\tif 0 <= x < n and 0 <= y < n and not grid[x][y]:\\n\\t\\t\\t\\tgrid[x][y] = 1\\n\\t\\t\\t\\tq.append((x, y, d+1))\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 667137,
                "title": "why-does-dp-not-work",
                "content": "When I approached this problem, I first thought it was a dp problem and found what I thought to be a dp formula:\\n1. dp[0][0] = 1 if grid[0][0] == 0, else infinity/INT_MAX\\n2. dp[i][j] = infinity/INT_MAX if grid[i][j] == 1, else min of it\\'s surrounding neighbors + 1\\n\\nAt the end, return the value at dp[-1][-1] if it is a finite number, else return -1.\\nMy thinking was that for every cell except top left, the number of steps it takes to reach that cell is the minimum of its neighbor + 1 if it\\'s reachable\\n\\nHere is the Python implementation below:\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        dp = [[float(\\'inf\\')] * len(grid[0]) for _ in range(len(grid))]\\n        \\n        def valid(i, j):\\n            return 0 <= i and i < len(grid) and 0 <= j and j < len(grid[row])\\n\\n        def helper(row, col):\\n            i = row - 1\\n            res = float(\\'inf\\')\\n            while i <= row + 1:\\n                j = col - 1\\n                while j <= col + 1:\\n                    if valid(i, j):\\n                        res = min(dp[i][j], res)\\n                    j += 1\\n                i += 1\\n            return res\\n        \\n        if grid[0][0] == 0:\\n            dp[0][0] = 1       \\n        for row in range(len(dp)):\\n            for col in range(len(dp[row])):\\n                if row == 0 and col == 0:\\n                    continue\\n                if grid[row][col] == 0:\\n                    dp[row][col] = helper(row, col) + 1\\n        \\n        return -1 if dp[-1][-1] == float(\\'inf\\') else dp[-1][-1]\\n```\\n\\nIt passes 82/84 test cases and fails https://leetcode.com/submissions/detail/348206665/testcase/, returning -1 when it should return 146. With a test case that big, I can\\'t possibly go through the test case and see where it is going wrong. Can someone explain why my approach doesn\\'t work?",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        dp = [[float(\\'inf\\')] * len(grid[0]) for _ in range(len(grid))]\\n        \\n        def valid(i, j):\\n            return 0 <= i and i < len(grid) and 0 <= j and j < len(grid[row])\\n\\n        def helper(row, col):\\n            i = row - 1\\n            res = float(\\'inf\\')\\n            while i <= row + 1:\\n                j = col - 1\\n                while j <= col + 1:\\n                    if valid(i, j):\\n                        res = min(dp[i][j], res)\\n                    j += 1\\n                i += 1\\n            return res\\n        \\n        if grid[0][0] == 0:\\n            dp[0][0] = 1       \\n        for row in range(len(dp)):\\n            for col in range(len(dp[row])):\\n                if row == 0 and col == 0:\\n                    continue\\n                if grid[row][col] == 0:\\n                    dp[row][col] = helper(row, col) + 1\\n        \\n        return -1 if dp[-1][-1] == float(\\'inf\\') else dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312706,
                "title": "java-bfs",
                "content": "```\\nprivate int dir[][] = new int[][]{{0,1},{0,-1},{1,0},{-1,0},{1,-1},{-1,1},{-1,-1},{1,1}};\\n\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        if(grid[0][0]==1 || grid[m-1][n-1]==1) {\\n            return -1;\\n        }\\n\\n        boolean[][] visited = new boolean[m][n];\\n        visited[0][0] = true;\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0});\\n\\n        int ans=0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int i=0;i<size;i++) {\\n                int[] pop = queue.remove();\\n                if(pop[0]==m-1 && pop[1]==n-1) {\\n                    return ans+1;\\n                }\\n                for (int k=0;k<8;k++) {\\n                    int nextX = dir[k][0]+pop[0];\\n                    int nextY = dir[k][1]+pop[1];\\n\\n                    if(nextX>=0 && nextX<m && nextY>=0 && nextY<n && !visited[nextX][nextY] && grid[nextX][nextY]==0) {\\n                        queue.add(new int[]{nextX,nextY});\\n                        visited[nextX][nextY]=true;\\n                    }\\n\\n                }\\n            }\\n            ans++;\\n        }\\n\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate int dir[][] = new int[][]{{0,1},{0,-1},{1,0},{-1,0},{1,-1},{-1,1},{-1,-1},{1,1}};\\n\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n\\n        int m = grid.length;\\n        int n = grid[0].length;\\n\\n        if(grid[0][0]==1 || grid[m-1][n-1]==1) {\\n            return -1;\\n        }\\n\\n        boolean[][] visited = new boolean[m][n];\\n        visited[0][0] = true;\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.add(new int[]{0,0});\\n\\n        int ans=0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int i=0;i<size;i++) {\\n                int[] pop = queue.remove();\\n                if(pop[0]==m-1 && pop[1]==n-1) {\\n                    return ans+1;\\n                }\\n                for (int k=0;k<8;k++) {\\n                    int nextX = dir[k][0]+pop[0];\\n                    int nextY = dir[k][1]+pop[1];\\n\\n                    if(nextX>=0 && nextX<m && nextY>=0 && nextY<n && !visited[nextX][nextY] && grid[nextX][nextY]==0) {\\n                        queue.add(new int[]{nextX,nextY});\\n                        visited[nextX][nextY]=true;\\n                    }\\n\\n                }\\n            }\\n            ans++;\\n        }\\n\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 312814,
                "title": "simple-bfs-c",
                "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 1;\\n        int row = grid.size();\\n        if (row == 0) return -1;\\n        int col = grid[0].size();\\n        if (col == 0 ) return -1;\\n        if (grid[0][0] != 0 | grid[row-1][col-1] != 0) return -1;\\n        \\n        queue<pair<int, int>> queue;\\n        queue.push(make_pair(0,0));\\n        vector<vector<int>> directions = {{1,1}, {0,1},{1,0},{0,-1},{-1,0},{-1, -1},{1, -1},{-1, 1}};\\n        grid[0][0] = 1;\\n        while(!queue.empty()){\\n            auto curr = queue.front();\\n            int x = curr.first, y = curr.second;\\n            if( x == row -1 && y == col -1) return grid[x][y];\\n            \\n            for(auto direction : directions){\\n                int nx = x + direction[0];\\n                int ny = y + direction[1];\\n                if(nx >= 0 && nx < row && ny >= 0 && ny < col && grid[nx][ny] == 0){\\n                    queue.push(make_pair(nx,ny));\\n                    grid[nx][ny] = grid[x][y] + 1;\\n                }\\n            }\\n            queue.pop();\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 1;\\n        int row = grid.size();\\n        if (row == 0) return -1;\\n        int col = grid[0].size();\\n        if (col == 0 ) return -1;\\n        if (grid[0][0] != 0 | grid[row-1][col-1] != 0) return -1;\\n        \\n        queue<pair<int, int>> queue;\\n        queue.push(make_pair(0,0));\\n        vector<vector<int>> directions = {{1,1}",
                "codeTag": "Java"
            },
            {
                "id": 1063734,
                "title": "c-optimised-bfs-vs-dfs-fastest-solution-to-date-100-time-35ms-99-space-18-3mb",
                "content": "Handbook maze exploration problem and we know we might be better served with a BFS in this case; and if you want to practice more of it, please also [check this somehow similar problem](https://leetcode.com/problems/is-graph-bipartite/), that I discussed [here](https://leetcode.com/problems/is-graph-bipartite/discuss/1065215/).\\n\\nTo do so, we will first of all rule out the edge case in which either the start or target cell are unreachable, to save needless computation and be sure later of some loop invariants.\\n\\nIf that was not the case, then we will declare a few support variables:\\n* `res`, initialised to `2`, since it would normally at least take 2 steps to move from start to target;\\n* `len`, the length of our queue, preset to the value of `1`;\\n* `maxX` and `maxY` as the extremes of our grid (I know it is a square one, but allow me to immolate a couple of bytes to make this solution more general);\\n* `q`, a queue of pairs of integers representing the coordinates and that we will initially set to contain the starting point, pushing `{0, 0}` into it, provided we are not in a single cell maze.\\n\\nIf that is the case (`!maxX && !maxY`), we will then return `1 - (grid[0][0] << 1)`, which is just a cool way to write `grid[0][0] ? -1 : 1`, which in turn means we will have the edge case of a single step only if our single cell is empty, impossible path (`-1`) otherwise.\\n\\nIf that was not the case, we will also then mark the first cell as visited and move on with our main BFS loop, that will run as long as we have elements in the queue (`len !=0`) and that will:\\n* have another inner loop running `len` times in which we:\\n\\t* extract `cx` and `cy` from the top of the queue;\\n\\t* pop the top;\\n\\t* use `cx` and `cy` to loop around all the neighbours, setting the initial value of `x` and `y` to the the maximum between `0` and the current value (`cx` or `cy`, respectively) `- 1`, and the upper limit of the loop as the minimum value between the current value `+ 1` and either `maxX` or `maxY`, included, then:\\n\\t\\t* we computed `maxX` and `maxY` smaller than one step from the actual size to have an easier life here - we will return `res` when `x == maxX && y == maxY` - meaning we reached the target;\\n\\t\\t* alternatively, we will check if `grid[y][x]` is still unexplored and if so, we will mark it and push it into q for the the next loop;\\n* increase `res` by `1`;\\n* update `len` with the current length of the queue.\\n\\nIf we leave the loop, it means no path was found, so we can safely return `-1` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        // support variables\\n        int res = 2, len = 1, maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        queue<pair<int, int>> q;\\n        // edge case: single cell matrix\\n        if (!maxX && !maxY) return 1 - (grid[0][0] << 1);\\n        // adding the starting point\\n        q.push({0, 0});\\n        // marking start as visited\\n        grid[0][0] = -1;\\n        while (len) {\\n            while (len--) {\\n                // reading and popping the coordinates on the front of the queue\\n                auto [cx, cy] = q.front();\\n                q.pop();\\n                for (int x = max(0, cx - 1), lmtX = min(cx + 1, maxX); x <= lmtX; x++) {\\n                    for (int y = max(0, cy - 1), lmtY = min(cy + 1, maxY); y <= lmtY; y++) {\\n                        // check if we reached the target\\n                        if (x == maxX && y == maxY) return res;\\n                        // marking it as visited and adding it to the q if it was still a valid cell\\n                        if (!grid[y][x]) {\\n                            grid[y][x] = -1;\\n                            q.push({x, y});\\n                        }\\n                    }\\n                }\\n            }\\n            // preparing for the next loop\\n            res++;\\n            len = q.size();\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThe brag \\uD83D\\uDE0E :\\n\\n![image](https://assets.leetcode.com/users/images/f0252a59-1383-4aa0-b90a-791f18aac0cc_1613219437.2042842.png)\\n\\nThe fun - getting it with also with a backtracking DFS!\\n\\nLet me anticipate that it just TLEs on bigger maps, but it was still nice to practice with it.\\n\\nNotice that we moved all the support variables to be private class variables and we do need also some less logic to handle edge cases in our main function, which is now limited to assigning values to both `maxX` and `maxY`, then computing the shortest path.\\n\\nMost of the logic goes into our `dfs` helper that will first of all return the current value of  our coordinates and, if they are the ones of the target, then we just  `return res`; otherwise, we:\\n* declare `partRes` as `INT_MAX`;\\n* mark the current cell as visited;\\n* increase `res` by one;\\n* loop through all the visitable adjacent cells and, for each available one, call `dfs` on it and assigning to `partRes` the smaller value between the current one and what was found on that path;\\n* finally we backtrack, specularly to our first operations, unmarking the current cell as visited and\\n* decreasing `res` by `1`.\\n\\nBack in our main function, we overwrite `res` with the final result and return `-1` if it is still `INT_MAX` (ie: no paths found), `res` itself otherwise :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    // support variables\\n    int maxX, maxY, res = 1;\\n    int dfs(vector<vector<int>>& grid, int cx = 0, int cy = 0) {\\n        // check if we reached the target\\n        if (cx == maxX && cy == maxY) return res;\\n        // support variable\\n        int partRes = INT_MAX;\\n        // marking the cell as visited and increasing res\\n        grid[cy][cx] = -1;\\n        res++;\\n        for (int x = max(0, cx - 1), lmtX = min(cx + 1, maxX); x <= lmtX; x++) {\\n            for (int y = max(0, cy - 1), lmtY = min(cy + 1, maxY); y <= lmtY; y++) {\\n                if (!grid[y][x]) {\\n                    partRes = min(partRes, dfs(grid, x, y));\\n                }\\n            }\\n        }\\n        // backtracking the cell as non-visited and decreasing res\\n        grid[cy][cx] = 0;\\n        res--;\\n        return partRes;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        // searching from the starting point\\n        res = dfs(grid);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```\\n\\nI guess we might have had a better luck with a double-ended BFS, moving to diagonals first and stopping as soon as we find a path, though\\uD83E\\uDD14\\n\\nEdit: no, going through diagonal first fails - consider this case for example: `[[0,0,0],[0,1,0],[0,0,0]]`; and then run it with this code:\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    // support variables\\n    int maxX, maxY, res = 1, x, y;\\n    bool found = false;\\n    pair<int, int> dirs[8] = {{1, 1}, {-1, 1}, {1, -1}, {-1, -1}, {0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    void dfs(vector<vector<int>>& grid, int cx = 0, int cy = 0) {\\n        // check if we reached the target\\n        if (cx == maxX && cy == maxY) {\\n            found = true;\\n            return;\\n        }\\n        // marking the cell as visited and increasing res\\n        res++;\\n        grid[cy][cx] = -1;\\n        for (auto dir: dirs) {\\n            x = cx + dir.first, y = cy + dir.second;\\n            if (x >= 0 && x <= maxX && y >= 0 && y <= maxY && !grid[y][x]) {\\n                dfs(grid, x, y);\\n                if (found) return;\\n            }\\n        }\\n        // backtracking the cell as non-visited and decreasing res\\n        grid[cy][cx] = 0;\\n        res--;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        // searching from the starting point\\n        dfs(grid);\\n        return found ? res : -1;\\n    }\\n};\\n```\\n\\nTo fix it would require going back to that cumbersome, heavy backtracking we had above.\\n\\nThe double BFS idea worked better instead and it allowed me to improve both performance and memory usage - same logic as the first example, but despite using 2 queues, we end up filling them up less:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        // support variables\\n        int res = 2, len = 1, maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        queue<pair<int, int>> q1, q2;\\n        bool isStartTurn = true;\\n        // edge case: single cell matrix\\n        if (!maxX && !maxY) return 1 - (grid[0][0] << 1);\\n        // adding the start and ending points\\n        q1.push({0, 0});\\n        q2.push({maxX, maxY});\\n        // marking start and ending points as visited\\n        grid[0][0] = -1;\\n        grid[maxY][maxX] = -2;\\n        while (len) {\\n            while (len--) {\\n                // reading and popping the coordinates on the front of the queue\\n                auto [cx, cy] = (isStartTurn ? q1 : q2).front();\\n                (isStartTurn ? q1 : q2).pop();\\n                for (int x = max(0, cx - 1), lmtX = min(cx + 1, maxX); x <= lmtX; x++) {\\n                    for (int y = max(0, cy - 1), lmtY = min(cy + 1, maxY); y <= lmtY; y++) {\\n                        // check if we reached an already visited cell fromm the other side\\n                        if (grid[y][x] == (isStartTurn ? -2 : -1)) return res;\\n                        // marking it as visited and adding it to the q if it was still a valid cell\\n                        if (!grid[y][x]) {\\n                            grid[y][x] = isStartTurn ? -1 : -2;\\n                            (isStartTurn ? q1 : q2).push({x, y});\\n                        }\\n                    }\\n                }\\n            }\\n            // preparing for the next loop\\n            res++;\\n            isStartTurn = !isStartTurn;\\n            len = (isStartTurn ? q1 : q2).size();\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nToday I forgot I did this already, so I re-coded it from scratch, trying to optimise it in the computation of adjacent cells, going for diagonal firsts, marking them immediately as explored and thus not storing duplicated cells in my queue; it worked pretty well, despite some verbose/duplicated code to check only the necessary condition for out of boundaries cases:\\n\\n```cpp\\nusing pathType = pair<int, int>;\\n\\nclass Solution {\\n    void markAndAdd(vector<vector<int>> &grid, queue<pathType> &q, int x, int y) {\\n        // marking the current node as visited and adding it to q\\n        grid[y][x] = 1;\\n        q.push({x, y});\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>> &grid) {\\n        int res = 0, t = grid.size() - 1, qLen = 1, cx, cy, x, y;\\n        if (grid[0][0] || grid[t][t]) return -1;\\n        queue<pathType> q{{{0, 0}}};\\n        // marking the start as visited\\n        grid[0][0] = 1;\\n        while (qLen) {\\n            res++;\\n            // increasing the counter\\n            while (qLen--) {\\n                // extracting the front of the queue\\n                auto &front = q.front();\\n                cx = front.first;\\n                cy = front.second;\\n                // checking if we had a match\\n                if (cx == t && cy == t) return res;\\n                q.pop();\\n                // adding adjacent unexplored nodes to the queue\\n                // diagonals:\\n                // upper left\\n                x = cx - 1, y = cy - 1;\\n                if (x >= 0 && y >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // upper right\\n                x = cx + 1;\\n                if (x <= t && y >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // lower right\\n                y = cy + 1;\\n                if (x <= t && y <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // lower left\\n                x = cx - 1;\\n                if (x >= 0 && y <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // adjacent ones:\\n                // mid left\\n                y = cy;\\n                if (x >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // mid right\\n                x = cx + 1;\\n                if (x <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // upper mid\\n                x = cx, y = cy - 1;\\n                if (y >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // lower mid\\n                y = cy + 1;\\n                if (y <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n            }\\n            qLen = q.size();\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nBut, wait a moment... We had that sweet double ended BFS idea in mind, right?\\n\\nWell, turns out it works even better with my uber-optimised solutions; and since one year ago, I can do even better, just avoiding painful ternary operators all the time and just swapping queues and markers as we go; `res` is also initialised to be `1` (since we already do one extra step marking `{t, t}` too), unless `t == 0`.\\n\\nThe updated code:\\n\\n```cpp\\nusing pathType = pair<int, int>;\\n\\nclass Solution {\\n    int startMark = -1, endMark = -2;\\n    queue<pathType> q1{{{0, 0}}}, q2;\\n    void markAndAdd(vector<vector<int>> &grid, int x, int y) {\\n        // marking the current node as visited and adding it to q\\n        grid[y][x] = startMark;\\n        q1.push({x, y});\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>> &grid) {\\n        int t = grid.size() - 1, res = bool(t), qLen = 1, cx, cy, x, y, currVal;\\n        if (grid[0][0] || grid[t][t]) return -1;\\n        // marking the start end end as visited\\n        q2.push({t, t});\\n        grid[0][0] = startMark;\\n        grid[t][t] = endMark;\\n        while (qLen) {\\n            // increasing the counter\\n            res++;\\n            while (qLen--) {\\n                // extracting the front of the queue\\n                auto &front = q1.front();\\n                cx = front.first;\\n                cy = front.second;\\n                // checking if we had a match\\n                if (grid[cy][cx] == endMark) return res;\\n                q1.pop();\\n                // adding adjacent unexplored nodes to the queue\\n                // diagonals:\\n                // upper left\\n                x = cx - 1, y = cy - 1;\\n                if (x >= 0 && y >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // upper right\\n                x = cx + 1;\\n                if (x <= t && y >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // lower right\\n                y = cy + 1;\\n                if (x <= t && y <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // lower left\\n                x = cx - 1;\\n                if (x >= 0 && y <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // adjacent ones:\\n                // mid left\\n                y = cy;\\n                if (x >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // mid right\\n                x = cx + 1;\\n                if (x <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // upper mid\\n                x = cx, y = cy - 1;\\n                if (y >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // lower mid\\n                y = cy + 1;\\n                if (y <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n            }\\n            swap(q1, q2);\\n            swap(startMark, endMark);\\n            qLen = q1.size();\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\nThe updated brag:\\n![image](https://assets.leetcode.com/users/images/a6d26f34-fb51-43d4-b962-dd30df623ff1_1652735140.3896632.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        // support variables\\n        int res = 2, len = 1, maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        queue<pair<int, int>> q;\\n        // edge case: single cell matrix\\n        if (!maxX && !maxY) return 1 - (grid[0][0] << 1);\\n        // adding the starting point\\n        q.push({0, 0});\\n        // marking start as visited\\n        grid[0][0] = -1;\\n        while (len) {\\n            while (len--) {\\n                // reading and popping the coordinates on the front of the queue\\n                auto [cx, cy] = q.front();\\n                q.pop();\\n                for (int x = max(0, cx - 1), lmtX = min(cx + 1, maxX); x <= lmtX; x++) {\\n                    for (int y = max(0, cy - 1), lmtY = min(cy + 1, maxY); y <= lmtY; y++) {\\n                        // check if we reached the target\\n                        if (x == maxX && y == maxY) return res;\\n                        // marking it as visited and adding it to the q if it was still a valid cell\\n                        if (!grid[y][x]) {\\n                            grid[y][x] = -1;\\n                            q.push({x, y});\\n                        }\\n                    }\\n                }\\n            }\\n            // preparing for the next loop\\n            res++;\\n            len = q.size();\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\nprivate:\\n    // support variables\\n    int maxX, maxY, res = 1;\\n    int dfs(vector<vector<int>>& grid, int cx = 0, int cy = 0) {\\n        // check if we reached the target\\n        if (cx == maxX && cy == maxY) return res;\\n        // support variable\\n        int partRes = INT_MAX;\\n        // marking the cell as visited and increasing res\\n        grid[cy][cx] = -1;\\n        res++;\\n        for (int x = max(0, cx - 1), lmtX = min(cx + 1, maxX); x <= lmtX; x++) {\\n            for (int y = max(0, cy - 1), lmtY = min(cy + 1, maxY); y <= lmtY; y++) {\\n                if (!grid[y][x]) {\\n                    partRes = min(partRes, dfs(grid, x, y));\\n                }\\n            }\\n        }\\n        // backtracking the cell as non-visited and decreasing res\\n        grid[cy][cx] = 0;\\n        res--;\\n        return partRes;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        // searching from the starting point\\n        res = dfs(grid);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\nprivate:\\n    // support variables\\n    int maxX, maxY, res = 1, x, y;\\n    bool found = false;\\n    pair<int, int> dirs[8] = {{1, 1}, {-1, 1}, {1, -1}, {-1, -1}, {0, 1}, {1, 0}, {0, -1}, {-1, 0}};\\n    void dfs(vector<vector<int>>& grid, int cx = 0, int cy = 0) {\\n        // check if we reached the target\\n        if (cx == maxX && cy == maxY) {\\n            found = true;\\n            return;\\n        }\\n        // marking the cell as visited and increasing res\\n        res++;\\n        grid[cy][cx] = -1;\\n        for (auto dir: dirs) {\\n            x = cx + dir.first, y = cy + dir.second;\\n            if (x >= 0 && x <= maxX && y >= 0 && y <= maxY && !grid[y][x]) {\\n                dfs(grid, x, y);\\n                if (found) return;\\n            }\\n        }\\n        // backtracking the cell as non-visited and decreasing res\\n        grid[cy][cx] = 0;\\n        res--;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        // searching from the starting point\\n        dfs(grid);\\n        return found ? res : -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // edge case: start or end not accessible\\n        if (grid[0][0] || grid.back().back()) return -1;\\n        // support variables\\n        int res = 2, len = 1, maxX = grid[0].size() - 1, maxY = grid.size() - 1;\\n        queue<pair<int, int>> q1, q2;\\n        bool isStartTurn = true;\\n        // edge case: single cell matrix\\n        if (!maxX && !maxY) return 1 - (grid[0][0] << 1);\\n        // adding the start and ending points\\n        q1.push({0, 0});\\n        q2.push({maxX, maxY});\\n        // marking start and ending points as visited\\n        grid[0][0] = -1;\\n        grid[maxY][maxX] = -2;\\n        while (len) {\\n            while (len--) {\\n                // reading and popping the coordinates on the front of the queue\\n                auto [cx, cy] = (isStartTurn ? q1 : q2).front();\\n                (isStartTurn ? q1 : q2).pop();\\n                for (int x = max(0, cx - 1), lmtX = min(cx + 1, maxX); x <= lmtX; x++) {\\n                    for (int y = max(0, cy - 1), lmtY = min(cy + 1, maxY); y <= lmtY; y++) {\\n                        // check if we reached an already visited cell fromm the other side\\n                        if (grid[y][x] == (isStartTurn ? -2 : -1)) return res;\\n                        // marking it as visited and adding it to the q if it was still a valid cell\\n                        if (!grid[y][x]) {\\n                            grid[y][x] = isStartTurn ? -1 : -2;\\n                            (isStartTurn ? q1 : q2).push({x, y});\\n                        }\\n                    }\\n                }\\n            }\\n            // preparing for the next loop\\n            res++;\\n            isStartTurn = !isStartTurn;\\n            len = (isStartTurn ? q1 : q2).size();\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nusing pathType = pair<int, int>;\\n\\nclass Solution {\\n    void markAndAdd(vector<vector<int>> &grid, queue<pathType> &q, int x, int y) {\\n        // marking the current node as visited and adding it to q\\n        grid[y][x] = 1;\\n        q.push({x, y});\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>> &grid) {\\n        int res = 0, t = grid.size() - 1, qLen = 1, cx, cy, x, y;\\n        if (grid[0][0] || grid[t][t]) return -1;\\n        queue<pathType> q{{{0, 0}}};\\n        // marking the start as visited\\n        grid[0][0] = 1;\\n        while (qLen) {\\n            res++;\\n            // increasing the counter\\n            while (qLen--) {\\n                // extracting the front of the queue\\n                auto &front = q.front();\\n                cx = front.first;\\n                cy = front.second;\\n                // checking if we had a match\\n                if (cx == t && cy == t) return res;\\n                q.pop();\\n                // adding adjacent unexplored nodes to the queue\\n                // diagonals:\\n                // upper left\\n                x = cx - 1, y = cy - 1;\\n                if (x >= 0 && y >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // upper right\\n                x = cx + 1;\\n                if (x <= t && y >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // lower right\\n                y = cy + 1;\\n                if (x <= t && y <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // lower left\\n                x = cx - 1;\\n                if (x >= 0 && y <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // adjacent ones:\\n                // mid left\\n                y = cy;\\n                if (x >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // mid right\\n                x = cx + 1;\\n                if (x <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // upper mid\\n                x = cx, y = cy - 1;\\n                if (y >= 0 && !grid[y][x]) markAndAdd(grid, q, x, y);\\n                // lower mid\\n                y = cy + 1;\\n                if (y <= t && !grid[y][x]) markAndAdd(grid, q, x, y);\\n            }\\n            qLen = q.size();\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nusing pathType = pair<int, int>;\\n\\nclass Solution {\\n    int startMark = -1, endMark = -2;\\n    queue<pathType> q1{{{0, 0}}}, q2;\\n    void markAndAdd(vector<vector<int>> &grid, int x, int y) {\\n        // marking the current node as visited and adding it to q\\n        grid[y][x] = startMark;\\n        q1.push({x, y});\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>> &grid) {\\n        int t = grid.size() - 1, res = bool(t), qLen = 1, cx, cy, x, y, currVal;\\n        if (grid[0][0] || grid[t][t]) return -1;\\n        // marking the start end end as visited\\n        q2.push({t, t});\\n        grid[0][0] = startMark;\\n        grid[t][t] = endMark;\\n        while (qLen) {\\n            // increasing the counter\\n            res++;\\n            while (qLen--) {\\n                // extracting the front of the queue\\n                auto &front = q1.front();\\n                cx = front.first;\\n                cy = front.second;\\n                // checking if we had a match\\n                if (grid[cy][cx] == endMark) return res;\\n                q1.pop();\\n                // adding adjacent unexplored nodes to the queue\\n                // diagonals:\\n                // upper left\\n                x = cx - 1, y = cy - 1;\\n                if (x >= 0 && y >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // upper right\\n                x = cx + 1;\\n                if (x <= t && y >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // lower right\\n                y = cy + 1;\\n                if (x <= t && y <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // lower left\\n                x = cx - 1;\\n                if (x >= 0 && y <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // adjacent ones:\\n                // mid left\\n                y = cy;\\n                if (x >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // mid right\\n                x = cx + 1;\\n                if (x <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // upper mid\\n                x = cx, y = cy - 1;\\n                if (y >= 0) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n                // lower mid\\n                y = cy + 1;\\n                if (y <= t) {\\n                    currVal = grid[y][x];\\n                    if (currVal == endMark) return res;\\n                    if (!currVal) markAndAdd(grid, x, y);\\n                }\\n            }\\n            swap(q1, q2);\\n            swap(startMark, endMark);\\n            qLen = q1.size();\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312711,
                "title": "c-bfs",
                "content": "BFS gives us the shortest path, so we will just do that.\\n```\\nint shortestPathBinaryMatrix(vector<vector<int>>& g, int steps = 0) {\\n  queue<pair<int, int>> q;\\n  q.push({ 0, 0 });\\n  while (!q.empty()) {\\n    ++steps;\\n    queue<pair<int, int>> q1;\\n    while (!q.empty()) {\\n      auto c = q.front();\\n      q.pop();\\n      if (c.first >= 0 && c.second >= 0 && c.first < g.size() && c.second < g.size() && !g[c.first][c.second]) {\\n        g[c.first][c.second] = 1;\\n        if (c.first == g.size() - 1 && c.second == g.size() - 1) return steps;\\n        for (auto i = -1; i < 2; ++i)\\n          for (auto j = -1; j < 2; ++j)\\n            if (i != 0 || j != 0) q1.push({ c.first + i, c.second + j });\\n      }\\n    }\\n    swap(q, q1);\\n  }\\n  return -1;\\n}\\n```\\nWe can also check the coordinates before adding them to the queue; it can save some memory and runtinme:\\n```\\nint shortestPathBinaryMatrix(vector<vector<int>>& g, int steps = 0) {\\n  queue<pair<int, int>> q;\\n  q.push({ 0, 0 });\\n  while (!q.empty()) {\\n    ++steps;\\n    queue<pair<int, int>> q1;\\n    while (!q.empty()) {\\n      auto c = q.front();\\n      q.pop();\\n      if (exchange(g[c.first][c.second], 1) == 1) continue;\\n      if (c.first == g.size() - 1 && c.second == g.size() - 1) return steps;\\n      for (auto i = c.first - 1; i <= c.first + 1; ++i)\\n        for (auto j = c.second - 1; j <= c.second + 1; ++j)\\n          if (i != c.first || j != c.second) {\\n            if (i >= 0 && j >= 0 && i < g.size() && j < g.size() && !g[i][j]) {\\n              q1.push({ i, j });\\n            }\\n          }\\n    }\\n    swap(q, q1);\\n  }\\n  return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint shortestPathBinaryMatrix(vector<vector<int>>& g, int steps = 0) {\\n  queue<pair<int, int>> q;\\n  q.push({ 0, 0 });\\n  while (!q.empty()) {\\n    ++steps;\\n    queue<pair<int, int>> q1;\\n    while (!q.empty()) {\\n      auto c = q.front();\\n      q.pop();\\n      if (c.first >= 0 && c.second >= 0 && c.first < g.size() && c.second < g.size() && !g[c.first][c.second]) {\\n        g[c.first][c.second] = 1;\\n        if (c.first == g.size() - 1 && c.second == g.size() - 1) return steps;\\n        for (auto i = -1; i < 2; ++i)\\n          for (auto j = -1; j < 2; ++j)\\n            if (i != 0 || j != 0) q1.push({ c.first + i, c.second + j });\\n      }\\n    }\\n    swap(q, q1);\\n  }\\n  return -1;\\n}\\n```\n```\\nint shortestPathBinaryMatrix(vector<vector<int>>& g, int steps = 0) {\\n  queue<pair<int, int>> q;\\n  q.push({ 0, 0 });\\n  while (!q.empty()) {\\n    ++steps;\\n    queue<pair<int, int>> q1;\\n    while (!q.empty()) {\\n      auto c = q.front();\\n      q.pop();\\n      if (exchange(g[c.first][c.second], 1) == 1) continue;\\n      if (c.first == g.size() - 1 && c.second == g.size() - 1) return steps;\\n      for (auto i = c.first - 1; i <= c.first + 1; ++i)\\n        for (auto j = c.second - 1; j <= c.second + 1; ++j)\\n          if (i != c.first || j != c.second) {\\n            if (i >= 0 && j >= 0 && i < g.size() && j < g.size() && !g[i][j]) {\\n              q1.push({ i, j });\\n            }\\n          }\\n    }\\n    swap(q, q1);\\n  }\\n  return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2043319,
                "title": "why-use-bfs-search-every-possible-path-vs-search-a-possible-path",
                "content": "[Leetcode](https://leetcode.com/) [1091. Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix).\\n\\n# Intuition\\n\\n1. If we want to find **a possible path**, **DFS** will be more efficient. Because DFS will return a possible path if found, while it may not the shortest path.  \\n\\n2. **BFS** will try **every possible path** at the same time. \\n\\n3. If we want to find the shortest of all possible paths, **BFS is more efficient**. It\\'s impossible for DFS to determine which is the shortest before trying all possible paths. \\n\\n# BFS\\n\\nUse BFS to **Level Traversal**.\\n\\n```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return -1;\\n        }\\n\\n        int ans = 0;\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        if (grid[0][0] == 1 || grid[row - 1][col - 1] == 1) {\\n            return -1;\\n        }\\n\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        boolean[][] visited = new boolean[row][col];\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0});\\n        visited[0][0] = true;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            ans++;\\n\\n            for (int i = 0; i < size; i++) {\\n                int[] curPos = queue.poll();\\n\\n                if (curPos[0] == row - 1 && curPos[1] == col - 1) {\\n                    return ans;\\n                }\\n\\n                for (int[] dir : dirs) {\\n                    int nextX = curPos[0] + dir[0];\\n                    int nextY = curPos[1] + dir[1];\\n\\n                    if (nextX < 0 || nextX >= row || nextY < 0 || nextY >= col || visited[nextX][nextY] || grid[nextX][nextY] == 1) {\\n                        continue;\\n                    }\\n\\n                    visited[nextX][nextY] = true;\\n                    queue.offer(new int[]{nextX, nextY});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n^2)$.\\n- **Space Complexity**: $O(n^2)$.\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\\n            return -1;\\n        }\\n\\n        int ans = 0;\\n\\n        int row = grid.length;\\n        int col = grid[0].length;\\n\\n        if (grid[0][0] == 1 || grid[row - 1][col - 1] == 1) {\\n            return -1;\\n        }\\n\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        boolean[][] visited = new boolean[row][col];\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0});\\n        visited[0][0] = true;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            ans++;\\n\\n            for (int i = 0; i < size; i++) {\\n                int[] curPos = queue.poll();\\n\\n                if (curPos[0] == row - 1 && curPos[1] == col - 1) {\\n                    return ans;\\n                }\\n\\n                for (int[] dir : dirs) {\\n                    int nextX = curPos[0] + dir[0];\\n                    int nextY = curPos[1] + dir[1];\\n\\n                    if (nextX < 0 || nextX >= row || nextY < 0 || nextY >= col || visited[nextX][nextY] || grid[nextX][nextY] == 1) {\\n                        continue;\\n                    }\\n\\n                    visited[nextX][nextY] = true;\\n                    queue.offer(new int[]{nextX, nextY});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1063639,
                "title": "python-clean-bfs-explained",
                "content": "In this problem we need to find the shortest path in graph, so the first thing you should think about is **bfs** or breadth first search. We will keep tuples with `3` elements: `(distance, coordinate x, coordinate y)`. On each step we extract element from the left side of our `queue`, check if coordinates equal to ending point and if they are, we return distance. If not, for all `8` neighbours, we check if we can visite them: if we still inside grid, if value of grid is equal to `0` and if it was not visited previously. We add new node to `visited` set and to the end of our queue. (Note, that there is alternative way, where we directly change our grid without using visited set)\\n\\n**Complexity**: time complexity is `O(N^2)`: number of nodes in our graph. If we use visited set, space complexity is also `O(N^2)`. If not, it is just `O(N)`, because during traversal there will always be only nodes with distances `x` and `x+1` any given moment and there can be `O(N)` nodes with every distance.\\n\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid):\\n        N = len(grid)\\n        neibs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]\\n        queue = deque([(1, 0, 0)]) if grid[0][0] == 0 else deque()\\n        visited = set()\\n        \\n        while queue:\\n            dist, x, y = queue.popleft()\\n            if (x, y) == (N-1, N-1): return dist\\n            for dx, dy in neibs:\\n                if 0<=x+dx<N and 0<=y+dy<N and grid[x+dx][y+dy] == 0 and (x+dx, y+dy) not in visited:\\n                    visited.add((x+dx,y+dy))\\n                    queue.append((dist + 1, x+dx, y+dy))\\n                \\n        return -1\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid):\\n        N = len(grid)\\n        neibs = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]\\n        queue = deque([(1, 0, 0)]) if grid[0][0] == 0 else deque()\\n        visited = set()\\n        \\n        while queue:\\n            dist, x, y = queue.popleft()\\n            if (x, y) == (N-1, N-1): return dist\\n            for dx, dy in neibs:\\n                if 0<=x+dx<N and 0<=y+dy<N and grid[x+dx][y+dy] == 0 and (x+dx, y+dy) not in visited:\\n                    visited.add((x+dx,y+dy))\\n                    queue.append((dist + 1, x+dx, y+dy))\\n                \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043347,
                "title": "c-bfs-not-a-dp-problem",
                "content": "* Use BFS approach to find shortest path like we solve for graph problems. You can think of adjacent cells with value = 0 having an undirected edge between them.\\n* Apply BFS and update counter at everly level.\\n* To track levels I have used `nodesPushed`. It is equal to number of nodes in current level.\\n* If you are able to reach `(n-1, n-1)` return its level otherwise return -1.\\n* **Little Optimization :** Rather than keeping visited vector, after we have pushed a node in the queue make its value in `grid` equal to 1. This would make it unavailable to process next time we encounter it. However this method will corrupt the memory. \\n* **DP will not work here** because the way we traverse the matrix in DP will not lead to formulation of correct solution or rather the optimal path. However, BFS will lead to an optimal path.\\n* We can also get our answer by **DFS** but it would be computationaly more expensive and might give TLE on large inputs.\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<vector<int>>& grid, int i, int j, int n, vector<vector<bool>>& visited){\\n        \\n        return (i>=0 and i<n and j>=0 and j<n and grid[i][j]==0 and !visited[i][j]);\\n        \\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        vector<vector<bool>> visited(n, vector<bool> (n, false));\\n        queue<pair<int, int>> q;\\n        int ans = 0;\\n        int nodesPushed;\\n        \\n        if(grid[0][0] == 0){\\n            q.push({0, 0});\\n            visited[0][0] = true;\\n        }\\n                \\n        while(!q.empty()){\\n            \\n            nodesPushed = q.size();\\n            ans++;\\n            \\n            for(int cnt = 0; cnt < nodesPushed; cnt++){\\n                \\n                pair<int, int> frontNode = q.front();\\n                q.pop();\\n            \\n                int i = frontNode.first, j = frontNode.second;\\n\\n                if(i==n-1 and j==n-1) return ans;\\n\\n                for(int k = i - 1; k <= i + 1 ; k++){\\n                    for(int l = j - 1; l <= j + 1; l++){\\n                        if(isValid(grid, k, l, n, visited)){\\n                            q.push({k, l});\\n                            visited[k][l] = true;\\n                        }\\n                    }\\n                }                \\n                \\n            }            \\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isValid(vector<vector<int>>& grid, int i, int j, int n, vector<vector<bool>>& visited){\\n        \\n        return (i>=0 and i<n and j>=0 and j<n and grid[i][j]==0 and !visited[i][j]);\\n        \\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        vector<vector<bool>> visited(n, vector<bool> (n, false));\\n        queue<pair<int, int>> q;\\n        int ans = 0;\\n        int nodesPushed;\\n        \\n        if(grid[0][0] == 0){\\n            q.push({0, 0});\\n            visited[0][0] = true;\\n        }\\n                \\n        while(!q.empty()){\\n            \\n            nodesPushed = q.size();\\n            ans++;\\n            \\n            for(int cnt = 0; cnt < nodesPushed; cnt++){\\n                \\n                pair<int, int> frontNode = q.front();\\n                q.pop();\\n            \\n                int i = frontNode.first, j = frontNode.second;\\n\\n                if(i==n-1 and j==n-1) return ans;\\n\\n                for(int k = i - 1; k <= i + 1 ; k++){\\n                    for(int l = j - 1; l <= j + 1; l++){\\n                        if(isValid(grid, k, l, n, visited)){\\n                            q.push({k, l});\\n                            visited[k][l] = true;\\n                        }\\n                    }\\n                }                \\n                \\n            }            \\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065225,
                "title": "c-bfs-simple-and-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // Helper function to check if point is in grid\\n    bool isValidPoint(int x, int y, int n, int m) {\\n        return x >= 0 && x <= n && y >= 0 && y <= m;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size()-1, m = grid[0].size()-1;\\n        if (grid[0][0] || grid[n][m]) \\n            return -1;\\n        \\n        queue<vector<int> > q;\\n        vector<int> curr;\\n        \\n        q.push({0, 0});\\n        grid[0][0] = 1;\\n        \\n        while (!q.empty() && !grid[n][m]) {\\n            curr = q.front();\\n            q.pop();\\n            \\n            for (int i = 0; i < 8; i++) {\\n                int x = curr[0] + x_points[i];\\n                int y = curr[1] + y_points[i];\\n                \\n                if (isValidPoint(x, y, n, m) && grid[x][y] == 0) {\\n                    grid[x][y] = grid[curr[0]][curr[1]] + 1;\\n                    q.push({x, y});\\n                }\\n            }\\n        }\\n        return grid[n][m] ? grid[n][m] : -1;\\n    }\\n    \\nprivate:\\n    vector<int> x_points = {-1,-1,-1,0,0,1,1,1};\\n    vector<int> y_points = {-1,0,1,-1,1,-1,0,1};\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper function to check if point is in grid\\n    bool isValidPoint(int x, int y, int n, int m) {\\n        return x >= 0 && x <= n && y >= 0 && y <= m;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size()-1, m = grid[0].size()-1;\\n        if (grid[0][0] || grid[n][m]) \\n            return -1;\\n        \\n        queue<vector<int> > q;\\n        vector<int> curr;\\n        \\n        q.push({0, 0});\\n        grid[0][0] = 1;\\n        \\n        while (!q.empty() && !grid[n][m]) {\\n            curr = q.front();\\n            q.pop();\\n            \\n            for (int i = 0; i < 8; i++) {\\n                int x = curr[0] + x_points[i];\\n                int y = curr[1] + y_points[i];\\n                \\n                if (isValidPoint(x, y, n, m) && grid[x][y] == 0) {\\n                    grid[x][y] = grid[curr[0]][curr[1]] + 1;\\n                    q.push({x, y});\\n                }\\n            }\\n        }\\n        return grid[n][m] ? grid[n][m] : -1;\\n    }\\n    \\nprivate:\\n    vector<int> x_points = {-1,-1,-1,0,0,1,1,1};\\n    vector<int> y_points = {-1,0,1,-1,1,-1,0,1};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312846,
                "title": "why-does-this-simple-bfs-give-tle",
                "content": "I wrote a simple BFS which gives TLE. I am seeing that this looks very similar to most of the posts under discussion but cant figure out why it gives TLE. Does anyone have an idea?\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if (grid[0][0] != 0 || grid.back().back() == 1) return -1;\\n        \\n        queue<pair<int, int>> que;\\n        que.push({0, 0});\\n        int di = grid.size()-1, dj = grid[0].size()-1, l = 0;\\n        \\n        vector<pair<int, int>> dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}, {1,1}, {1,-1}, {-1,1}, {-1,-1}};\\n        while (!que.empty()) {\\n            int size = que.size();\\n            l++;\\n            for (int s = 0; s < size; s++) {\\n                auto curr = que.front(); que.pop();\\n                int i = curr.first, j = curr.second;\\n                grid[i][j] = 2;\\n                \\n                if (i == di && j == dj) return l;\\n\\n                for (auto& dir: dirs) {\\n                    int x = i + dir.first, y = j + dir.second;\\n                    if (0 <= x && x < grid.size() && 0 <= y && y < grid[0].size() && grid[x][y] == 0) que.push({x, y});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if (grid[0][0] != 0 || grid.back().back() == 1) return -1;\\n        \\n        queue<pair<int, int>> que;\\n        que.push({0, 0});\\n        int di = grid.size()-1, dj = grid[0].size()-1, l = 0;\\n        \\n        vector<pair<int, int>> dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}, {1,1}, {1,-1}, {-1,1}, {-1,-1}};\\n        while (!que.empty()) {\\n            int size = que.size();\\n            l++;\\n            for (int s = 0; s < size; s++) {\\n                auto curr = que.front(); que.pop();\\n                int i = curr.first, j = curr.second;\\n                grid[i][j] = 2;\\n                \\n                if (i == di && j == dj) return l;\\n\\n                for (auto& dir: dirs) {\\n                    int x = i + dir.first, y = j + dir.second;\\n                    if (0 <= x && x < grid.size() && 0 <= y && y < grid[0].size() && grid[x][y] == 0) que.push({x, y});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046009,
                "title": "this-is-why-dp-and-memoization-fail-illustrated-example",
                "content": "Here\\'s an illustrated example of why memoizing our answers (\"dp top-down\") also won\\'t work. \\n\\nLet\\'s say we define a function **countCellsToTarget(i, j)**, that returns the **minimum number of \\'0\\' cells** that we need to go through in order to get from position (i, j) to our target position (n-1, n-1).\\n\\nGiven the following input: [[0,0,1,0,1,1],[1,0,0,1,0,0],[0,1,0,1,0,0],[1,0,1,0,0,0],[0,1,0,1,0,0],[0,0,0,0,0,0]], with an expected result of 6, depending on the **order** in which we move onto the adjacent cells, we might discover a long path before we actually discover the shortest one. Therefore, memoizing an incorrect result.\\n\\nIn the following example let\\'s imagine that, because of how we defined our directions array, we end up visiting our neighbors in a very strange order (red arrows):\\n\\n![image](https://assets.leetcode.com/users/images/374288bd-cc4a-4e15-874b-3a988a31aa1c_1652746083.7747693.png)\\n\\nEvery time twe visit a cell (painted in red) we mark it as visited, so that we don\\'t visit it again during the same path. Every time we hit a cell that we don\\'t have our result memoized, we start exploring all the different paths from there to our destination.\\n\\nLet\\'s just focus on cell (2,2). Once we get there, our only option is moving to the top. The reason behind this is that we\\'re actually using the **surrounding state** of the current path to calculate the answer to cell (2,2) (that is cells marked as already visited!)\\n\\nFrom cell (1,2) we\\'d start exploring different paths trying to get to the (n-1, n-1) cell:\\n1.  We\\'d first move to the top-left cell (0, 1) leading us to a dead end.\\n2.  Then, we\\'d backtrack to cell (1, 2), and then move to the top-right cell (0, 3) that would get us to the last cell in a path of total length 8 (highlighted in gray).\\n\\nAfter we reach to our target, the solution for cell (2, 2) appears to be 8. At that point we\\'d probably store this solution in our dp array and continue our exploration **based on this premise which is false**, leading us to a wrong answer.\\n\\nAs you can see here, in the shortest path, the solution for cell (2, 2) is actually 4\\n\\n![image](https://assets.leetcode.com/users/images/2e6a4a5f-f035-4222-b4ed-b5e1ce5c1c5f_1652746621.228863.png)\\n\\nThis is the reason why we can\\'t do better than exponential time complexity O(7^(n^2)) when doing a backtracking solution as we cannot get rid of duplicate work by memoizing our answers.\\n\\nUnlike BFS, DFS doesn\\'t guarantee that we choose the shortest path first. So, we might actually take the longest one first and end up finding a path based on the current state of the visited set, and then finding and memoizing an incorrect result.\\n\\nWith memoization enabled, this test case gives WA (returns 8 instead of 6). If we remove the memoization, the backtracking solution takes around 7 seconds to complete but it works fine:\\n\\n**WARNING: this solution is for example purposes only. It won\\'t pass all leetcode test cases!**\\n```\\nclass Solution:\\n    NO_CLEAR_PATH = -1\\n\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        dirs = [(-1, -1), (0, -1), (1, -1), (-1, 0), (1, 0), (-1, 1), (0, 1), (1, 1)]\\n        dp = [[None] * n for _ in range(n)]\\n\\n        def countCellsToTarget(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= n or grid[i][j] == 1: return self.NO_CLEAR_PATH\\n            if (i, j) == (n-1, n-1): return 1\\n            #if dp[i][j] is not None: return dp[i][j] # memoization removed\\n\\n            result = math.inf\\n            grid[i][j] = 1\\n\\n            for di, dj in dirs:\\n                ii, jj = i + di, j + dj\\n\\n                cellsToTarget = countCellsToTarget(ii, jj)\\n                if cellsToTarget < 1: continue\\n                result = min(result, 1 + cellsToTarget)\\n\\n            if result == math.inf: result = self.NO_CLEAR_PATH\\n            grid[i][j] = 0\\n            dp[i][j] = result\\n            return result\\n        \\n        return countCellsToTarget(0, 0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    NO_CLEAR_PATH = -1\\n\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        dirs = [(-1, -1), (0, -1), (1, -1), (-1, 0), (1, 0), (-1, 1), (0, 1), (1, 1)]\\n        dp = [[None] * n for _ in range(n)]\\n\\n        def countCellsToTarget(i, j):\\n            if i < 0 or j < 0 or i >= n or j >= n or grid[i][j] == 1: return self.NO_CLEAR_PATH\\n            if (i, j) == (n-1, n-1): return 1\\n            #if dp[i][j] is not None: return dp[i][j] # memoization removed\\n\\n            result = math.inf\\n            grid[i][j] = 1\\n\\n            for di, dj in dirs:\\n                ii, jj = i + di, j + dj\\n\\n                cellsToTarget = countCellsToTarget(ii, jj)\\n                if cellsToTarget < 1: continue\\n                result = min(result, 1 + cellsToTarget)\\n\\n            if result == math.inf: result = self.NO_CLEAR_PATH\\n            grid[i][j] = 0\\n            dp[i][j] = result\\n            return result\\n        \\n        return countCellsToTarget(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584601,
                "title": "c-easy-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n=g.size();\\n        if(g[0][0] || g[n-1][n-1])return -1;\\n        g[0][0]=1;\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int t=0;\\n        while(q.size()){\\n            int k=q.size();\\n            t++;\\n            while(k--){\\n                int x=q.front().first;\\n                int y=q.front().second;\\n                q.pop();\\n                if(x==n-1 && y==n-1)return t;\\n                int dx[8]={1,-1,0,0,1,1,-1,-1};\\n                int dy[8]={0,0,1,-1,1,-1,1,-1};\\n                for(int i=0;i<8;i++){\\n                    int nx=x+dx[i];\\n                    int ny=y+dy[i];\\n                    if(nx>=0 && nx<n && ny>=0 && ny<n && g[nx][ny]==0){\\n                        g[nx][ny]=1;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/4cfbed27-aa7a-4b04-aa83-47d4734d2c3b_1685596609.7438343.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n=g.size();\\n        if(g[0][0] || g[n-1][n-1])return -1;\\n        g[0][0]=1;\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int t=0;\\n        while(q.size()){\\n            int k=q.size();\\n            t++;\\n            while(k--){\\n                int x=q.front().first;\\n                int y=q.front().second;\\n                q.pop();\\n                if(x==n-1 && y==n-1)return t;\\n                int dx[8]={1,-1,0,0,1,1,-1,-1};\\n                int dy[8]={0,0,1,-1,1,-1,1,-1};\\n                for(int i=0;i<8;i++){\\n                    int nx=x+dx[i];\\n                    int ny=y+dy[i];\\n                    if(nx>=0 && nx<n && ny>=0 && ny<n && g[nx][ny]==0){\\n                        g[nx][ny]=1;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312785,
                "title": "why-does-dfs-not-work",
                "content": "2 example test cases passed, but for             \\n\\t\\t\\t\\t{0,1,0,1,0},\\n                {1,0,0,0,1},\\n                {0,0,1,1,1},\\n                {0,0,0,0,0},\\n                {1,0,1,0,0}\\nit returns 7, however the solution is 6.\\n\\nhere is my java code:\\n```\\nclass Solution {\\n    int[][] dir = {{1,1},{1,-1},{-1,1},{-1,-1},{0,1},{0,-1},{1,0},{-1,0}};\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid[0][0] != 0 || grid[grid.length-1][grid[0].length-1] != 0) return -1;\\n\\t\\t\\n        int n = grid.length, m = grid[0].length;\\n        int[] res = new int[]{Integer.MAX_VALUE};\\n        boolean[][] visited = new boolean[n][m];\\n        \\n        helper(grid, 0, 0, 1, visited, res);\\n        return res[0] == Integer.MAX_VALUE ? -1 : res[0];\\n    }\\n    private void helper(int[][] grid, int i, int j, int len, boolean[][] visited, int[] res) {\\n        int n = grid.length, m = grid[0].length;\\n        if (i == n-1 && j == m-1) {\\n            res[0] = Math.min(res[0], len);\\n            return;\\n        } \\n        if (i < 0 || i >= n || j < 0 ||j >= m || grid[i][j] == 1 || visited[i][j]) return;\\n        visited[i][j] = true;\\n        for (int[] d : dir) {\\n            helper(grid, i+d[0], j+d[1], len+1, visited, res);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dir = {{1,1},{1,-1},{-1,1},{-1,-1},{0,1},{0,-1},{1,0},{-1,0}};\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid[0][0] != 0 || grid[grid.length-1][grid[0].length-1] != 0) return -1;\\n\\t\\t\\n        int n = grid.length, m = grid[0].length;\\n        int[] res = new int[]{Integer.MAX_VALUE};\\n        boolean[][] visited = new boolean[n][m];\\n        \\n        helper(grid, 0, 0, 1, visited, res);\\n        return res[0] == Integer.MAX_VALUE ? -1 : res[0];\\n    }\\n    private void helper(int[][] grid, int i, int j, int len, boolean[][] visited, int[] res) {\\n        int n = grid.length, m = grid[0].length;\\n        if (i == n-1 && j == m-1) {\\n            res[0] = Math.min(res[0], len);\\n            return;\\n        } \\n        if (i < 0 || i >= n || j < 0 ||j >= m || grid[i][j] == 1 || visited[i][j]) return;\\n        visited[i][j] = true;\\n        for (int[] d : dir) {\\n            helper(grid, i+d[0], j+d[1], len+1, visited, res);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063456,
                "title": "shortest-path-in-binary-matrix-js-python-java-c-bfs-solution-w-explanation-beats-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nWhen we\\'re asked about finding the \"shortest path\", the first thing that should come to mind is a **breadth-first solution** (BFS) approach. In a standard graph BFS solution, we set up a **queue** (**q**) and fill it with our starting position (**grid[0][0]**). Then we keep pulling entries from **q**, figuring out the next moves from that position, and input those next moves back into **q**.\\n\\nWhen we\\'re ready to start, we can change **grid[0][0]** to **1**, then as we reach new cells, we can store the distance to that cell in the cell at the same time we add it to the queue. The distance will simply be one more than the distance to the cell we\\'re moving from. This will also eliminate duplicate queue entries by changing visited cells to a non-zero number.\\n\\nThrough the nature of a BFS approach to graph traversal (with non-weighted edges), the first time we reach the end location (**grid[n][n]**) will represent the best possible distance.\\n\\nSince **0 <= i, j <= 100**, both **i** and **j** will fit into **7 bits** each, so we can utilize **bit manipulation** to store both in one integer. With a **bitwise left shift** (**<<**) we can move the value of **j** to the left by **7 bits** before adding it to **i** to allow for both to fit in **14 bits** of an integer.\\n```js\\nBitwise shift example:\\n\\n   i  =  93 (base 10)  =  1011101 (base 2)\\n   j  =  75 (base 10)  =  1001011 (base 2)\\n\\n   j << 7  =  1001011<<<<<<<     // Bitwise left shift moves the value left\\n           =  10010110000000     // And fills in the space with 0s\\n\\n   i:                           1011101 \\n        j << 7:       +  10010110000000\\n                        ----------------\\n   i + (j << 7):      =  10010111011101 (base 2)\\n                      =            9693 (base 10)\\n```\\nTo read **i** from the first **7 bits** of our stored integer again, you can use **bitwise AND** (**&**) and a **bitmask** of **1111111**. The easiest way to get a bitmask of **1111111** is to shift a single bit to the left by **7** (**1 << 7 = 10000000**) and then subtract **1**, rolling it back to all **1**s.\\n```js\\nBitmask example:\\n\\n   1 << 7:               10000000\\n                      -         1\\n                        ----------\\n   (1 << 7) - 1:      =   1111111\\n```\\nThe bitwise AND will only keep any bits that have a **1** in both numbers, thus stripping away anything except the first **7 bits** of data.\\n```js\\nBitwise AND example:\\n\\n      10010111011101\\n   &         1111111\\n     ----------------\\n   =         1011101\\n```\\nTo read the **j** value from our integer, we can just shift it to the right by **7 bits**, which will throw away the first **7 bits** of data corresponding to the **i** value.\\n\\nIf **q** becomes empty without finding a path to the end, then **return -1**.\\n\\n---\\n\\n***Implementation:***\\n\\nIf either the starting point or the ending point are a **1**, then we quickly **return -1**.\\n\\nTo check which moves can be made, we can just iterate over a three-value range for each **i** and **j**, and to make sure that they remain in bounds, we can apply a **max** and **min** to the range.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **88ms / 42.3MB** (beats 100% / 100%).\\n```javascript\\nvar shortestPathBinaryMatrix = function(grid) {\\n    let n = grid.length - 1, q = [0]\\n    if (grid[0][0] || grid[n][n]) return -1\\n    grid[0][0] = 1\\n    while (q.length) {\\n        let curr = q.shift(), i = curr & (1 << 7) - 1, j = curr >> 7\\n        if (i === n && j === n) return grid[n][n]\\n        for (let a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n            for (let b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                if (grid[a][b] === 0)\\n                    grid[a][b] = grid[i][j] + 1, q.push(a + (b << 7))\\n    }\\n    return -1\\n};\\n```\\n\\n---\\n\\n***Python Code:***\\n\\nThe best result for the code below is **656ms / 14.5MB** (beats 70% / 90%).\\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)-1\\n        if grid[0][0] or grid[n][n]: return -1\\n        q, grid[0][0] = [0], 1\\n        while len(q):\\n            curr = q.pop(0)\\n            i, j = curr & ((1 << 7) - 1), curr >> 7\\n            if i == n and j == n: return grid[n][n]\\n            for a in range(max(i-1,0),min(i+2,n+1)):\\n                for b in range(max(j-1,0),min(j+2,n+1)):\\n                    if grid[a][b] == 0:\\n                        grid[a][b] = grid[i][j] + 1\\n                        q.append(a + (b << 7))\\n        return -1\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **8ms / 40.0MB** (beats 100% / 90%).\\n```java\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length - 1;\\n        Queue<Integer> q = new ArrayDeque<Integer>();\\n        q.add(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.remove(), i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n                for (int b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.add(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **36 / 18.0MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = m - 1;\\n        std::queue<int> q;\\n        q.push(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.front();\\n            q.pop();\\n            int i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = std::max(i-1,0); a <= std::min(i+1,n); a++)\\n                for (int b = std::max(j-1,0); b <= std::min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.push(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nBitwise shift example:\\n\\n   i  =  93 (base 10)  =  1011101 (base 2)\\n   j  =  75 (base 10)  =  1001011 (base 2)\\n\\n   j << 7  =  1001011<<<<<<<     // Bitwise left shift moves the value left\\n           =  10010110000000     // And fills in the space with 0s\\n\\n   i:                           1011101 \\n        j << 7:       +  10010110000000\\n                        ----------------\\n   i + (j << 7):      =  10010111011101 (base 2)\\n                      =            9693 (base 10)\\n```\n```js\\nBitmask example:\\n\\n   1 << 7:               10000000\\n                      -         1\\n                        ----------\\n   (1 << 7) - 1:      =   1111111\\n```\n```js\\nBitwise AND example:\\n\\n      10010111011101\\n   &         1111111\\n     ----------------\\n   =         1011101\\n```\n```javascript\\nvar shortestPathBinaryMatrix = function(grid) {\\n    let n = grid.length - 1, q = [0]\\n    if (grid[0][0] || grid[n][n]) return -1\\n    grid[0][0] = 1\\n    while (q.length) {\\n        let curr = q.shift(), i = curr & (1 << 7) - 1, j = curr >> 7\\n        if (i === n && j === n) return grid[n][n]\\n        for (let a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n            for (let b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                if (grid[a][b] === 0)\\n                    grid[a][b] = grid[i][j] + 1, q.push(a + (b << 7))\\n    }\\n    return -1\\n};\\n```\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)-1\\n        if grid[0][0] or grid[n][n]: return -1\\n        q, grid[0][0] = [0], 1\\n        while len(q):\\n            curr = q.pop(0)\\n            i, j = curr & ((1 << 7) - 1), curr >> 7\\n            if i == n and j == n: return grid[n][n]\\n            for a in range(max(i-1,0),min(i+2,n+1)):\\n                for b in range(max(j-1,0),min(j+2,n+1)):\\n                    if grid[a][b] == 0:\\n                        grid[a][b] = grid[i][j] + 1\\n                        q.append(a + (b << 7))\\n        return -1\\n```\n```java\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length - 1;\\n        Queue<Integer> q = new ArrayDeque<Integer>();\\n        q.add(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.remove(), i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n                for (int b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.add(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = m - 1;\\n        std::queue<int> q;\\n        q.push(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.front();\\n            q.pop();\\n            int i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = std::max(i-1,0); a <= std::min(i+1,n); a++)\\n                for (int b = std::max(j-1,0); b <= std::min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.push(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043228,
                "title": "python-simple-bfs-with-explanation",
                "content": "The code will be using **BFS** traversal approach to find the shortest distance to target. The advantage of using **BFS** is that we will be exploring and traversing all the possible paths from source simultaneously. \\n\\nThe below solution has comments included for better understanding\\n\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        # check if source and target are not clear cells\\n        if grid[0][0] != 0 or grid[-1][-1] != 0:\\n            return -1\\n        \\n        N = len(grid)            \\n        # offsets required for all 8 directions\\n        offsets = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\\n        \\n        q = deque()\\n        q.append((0,0)) # starting point\\n        visited = {(0, 0)}\\n        \\n        \\n        # finds unvisited clear cells using 8 offsets\\n        def get_neighbours(x,y):\\n            for x_offset, y_offset in offsets:\\n                new_row = x + x_offset\\n                new_col = y + y_offset\\n                \\n                if 0 <= new_row < N and 0 <= new_col < N and not grid[new_row][new_col] and (new_row, new_col) not in visited:\\n                    yield (new_row, new_col)                                                \\n            \\n        \\n        current_distance = 1 # start with one clear cell\\n        # standard iterative BFS traversal\\n        while q:\\n            length = len(q)\\n            \\n            # loop through all the cells at the same distance\\n            for _ in range(length):\\n                row, col = q.popleft()\\n                \\n                if row == N-1 and col==N-1: # reached target\\n                    return current_distance\\n                \\n                # loop though all valid neignbours\\n                for p in get_neighbours(row, col):\\n                    visited.add(p)\\n                    q.append(p)\\n                                    \\n            current_distance+=1 # update the level or distance from source\\n        \\n        return -1                \\n        \\n```\\n\\n**Time - O(N)** where `N` is the number of cells and we visit each cells exactly once.\\n**Space - O(N)** where `N` is the number of cells. This is required for storing `visited`\\n\\n\\n---\\n\\n***Please upvote if you find it useful***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        # check if source and target are not clear cells\\n        if grid[0][0] != 0 or grid[-1][-1] != 0:\\n            return -1\\n        \\n        N = len(grid)            \\n        # offsets required for all 8 directions\\n        offsets = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\\n        \\n        q = deque()\\n        q.append((0,0)) # starting point\\n        visited = {(0, 0)}\\n        \\n        \\n        # finds unvisited clear cells using 8 offsets\\n        def get_neighbours(x,y):\\n            for x_offset, y_offset in offsets:\\n                new_row = x + x_offset\\n                new_col = y + y_offset\\n                \\n                if 0 <= new_row < N and 0 <= new_col < N and not grid[new_row][new_col] and (new_row, new_col) not in visited:\\n                    yield (new_row, new_col)                                                \\n            \\n        \\n        current_distance = 1 # start with one clear cell\\n        # standard iterative BFS traversal\\n        while q:\\n            length = len(q)\\n            \\n            # loop through all the cells at the same distance\\n            for _ in range(length):\\n                row, col = q.popleft()\\n                \\n                if row == N-1 and col==N-1: # reached target\\n                    return current_distance\\n                \\n                # loop though all valid neignbours\\n                for p in get_neighbours(row, col):\\n                    visited.add(p)\\n                    q.append(p)\\n                                    \\n            current_distance+=1 # update the level or distance from source\\n        \\n        return -1                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461535,
                "title": "javascript-simple-solution-w-comments",
                "content": "```\\n/**\\n * BFS\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 108 ms, faster than 86.30% of JavaScript online submissions for Shortest Path in Binary Matrix.\\n// Memory Usage: 45.5 MB, less than 96.71% of JavaScript online submissions for Shortest Path in Binary Matrix.\\nconst shortestPathBinaryMatrix = grid => {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t\\t[1, 1],\\n\\t\\t[1, -1],\\n\\t\\t[-1, 1],\\n\\t\\t[-1, -1],\\n\\t];\\n\\n\\tif (grid[0][0] === 1) return -1;\\n\\n\\tconst N = grid.length;\\n\\tconst queue = [[0, 0, 1]]; // [row, col, path]\\n\\n\\twhile (queue.length) {\\n\\t\\tconst [row, col, path] = queue.shift();\\n\\n\\t\\tif (row === N - 1 && col === N - 1) return path; // reached destination\\n\\n\\t\\tfor (const [dx, dy] of directions) { // traverse adjacents\\n\\t\\t\\tlet x = row + dx;\\n\\t\\t\\tlet y = col + dy;\\n\\n\\t\\t\\t// if invalid, continue\\n\\t\\t\\tif (x < 0 || x >= N) continue;\\n\\t\\t\\tif (y < 0 || y >= N) continue;\\n\\t\\t\\tif (grid[x][y] !== 0) continue;\\n\\n\\t\\t\\tqueue.push([x, y, path + 1]); // add new path to queue\\n\\t\\t\\tgrid[x][y] = 1; // mark visited\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * BFS\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 108 ms, faster than 86.30% of JavaScript online submissions for Shortest Path in Binary Matrix.\\n// Memory Usage: 45.5 MB, less than 96.71% of JavaScript online submissions for Shortest Path in Binary Matrix.\\nconst shortestPathBinaryMatrix = grid => {\\n\\tconst directions = [\\n\\t\\t[1, 0],\\n\\t\\t[-1, 0],\\n\\t\\t[0, 1],\\n\\t\\t[0, -1],\\n\\t\\t[1, 1],\\n\\t\\t[1, -1],\\n\\t\\t[-1, 1],\\n\\t\\t[-1, -1],\\n\\t];\\n\\n\\tif (grid[0][0] === 1) return -1;\\n\\n\\tconst N = grid.length;\\n\\tconst queue = [[0, 0, 1]]; // [row, col, path]\\n\\n\\twhile (queue.length) {\\n\\t\\tconst [row, col, path] = queue.shift();\\n\\n\\t\\tif (row === N - 1 && col === N - 1) return path; // reached destination\\n\\n\\t\\tfor (const [dx, dy] of directions) { // traverse adjacents\\n\\t\\t\\tlet x = row + dx;\\n\\t\\t\\tlet y = col + dy;\\n\\n\\t\\t\\t// if invalid, continue\\n\\t\\t\\tif (x < 0 || x >= N) continue;\\n\\t\\t\\tif (y < 0 || y >= N) continue;\\n\\t\\t\\tif (grid[x][y] !== 0) continue;\\n\\n\\t\\t\\tqueue.push([x, y, path + 1]); // add new path to queue\\n\\t\\t\\tgrid[x][y] = 1; // mark visited\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 891250,
                "title": "easy-java-solution-using-bfs",
                "content": "class Solution {\\n    \\n    class Pair{\\n        int x;\\n        int y;\\n        int count;\\n        \\n        Pair(int x, int y, int count){\\n            this.x = x;\\n            this.y = y;\\n            this.count = count;\\n        }\\n    }\\n    \\n    \\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        \\n        return BFS(grid, 0, 0, grid.length-1, grid[0].length-1);\\n        \\n    }\\n    \\n    \\n    public int BFS(int grid[][], int start_x, int start_y , int target_x, int target_y){\\n        \\n        Queue<Pair> q = new LinkedList<>();\\n      \\n        q.add(new Pair(start_x, start_y, 1));\\n        \\n        while(q.size()>0){\\n            \\n            Pair rem = q.remove();\\n            int x = rem.x;\\n            int y = rem.y;\\n            int count = rem.count;\\n           \\n    if(x>=0 && y>=0 && x<grid.length && y<grid[0].length && grid[x][y]!=1 ){\\n            \\n            grid[x][y] = 1;\\n                \\n            if(x==target_x && y== target_y)\\n                return rem.count;\\n            \\n            q.add(new Pair(x-1, y, count+1 ));\\n            q.add(new Pair(x-1, y+1, count+1));\\n            q.add(new Pair(x, y+1 , count+1));\\n            q.add(new Pair(x+1, y+1, count+1));\\n            q.add(new Pair(x+1, y, count+1));\\n            q.add(new Pair(x+1, y-1, count+1));\\n            q.add(new Pair(x, y-1, count+1));\\n            q.add(new Pair(x-1, y-1, count+1));\\n                \\n          }\\n    \\n       }\\n        return -1;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    \\n    class Pair{\\n        int x;\\n        int y;\\n        int count;\\n        \\n        Pair(int x, int y, int count){\\n            this.x = x;\\n            this.y = y;\\n            this.count = count;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 313937,
                "title": "posting-my-java-dfs-solution-54ms-to-demonstrate-that-it-is-possible",
                "content": "The idea is to only go deeper if the dp value of one cell or its neibor is updated to a smaller value.\\nThis is one trick for designing DFS: we shall try to gain in each recursion.\\n\\n```\\n    // Transfer the dist value at (r,c) to or from neighbor cells.\\n    // Whenever a cell has a updated (smaller) dist value, a recursive call of grow() will be done on behalf of it.\\n    private void grow(int[][] grid, int[][] dist, int r, int c) {\\n        int m = grid.length, n = grid[0].length;\\n        int d0 = dist[r][c];\\n        for (int i = -1; i <= 1; i++) {\\n            for (int j = -1; j <= 1; j++) {\\n                if (i == 0 && j == 0)\\n                    continue;\\n                int x = r + i;\\n                int y = c + j;\\n                if (x >= 0 && x < m && y >= 0 && y < n) {\\n                    if (grid[x][y] == 1)\\n                        continue;\\n                    int d1 = dist[x][y];\\n                    if (d1 < d0-1) { // get a smaller value from a neighbor; then re-start the process.\\n                        dist[r][c] = d1+1;\\n                        grow(grid, dist, r, c); // TODO some optimization to avoid stack overflow\\n                        return;\\n                    } else if (d1 > d0+1) { // give a smaller value to a neighbor\\n                        dist[x][y] = d0+1;\\n                        grow(grid, dist, x, y);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n]; // dist[i][j]: distance of the cell (i,j) to (0,0)\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dist[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n        dist[0][0] = 1;\\n        if (grid[0][0] == 1 || grid[m-1][n-1] == 1)\\n            return -1;\\n        grow(grid, dist, 0, 0);\\n        return (dist[m-1][n-1] != Integer.MAX_VALUE ? dist[m-1][n-1] : -1);\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    // Transfer the dist value at (r,c) to or from neighbor cells.\\n    // Whenever a cell has a updated (smaller) dist value, a recursive call of grow() will be done on behalf of it.\\n    private void grow(int[][] grid, int[][] dist, int r, int c) {\\n        int m = grid.length, n = grid[0].length;\\n        int d0 = dist[r][c];\\n        for (int i = -1; i <= 1; i++) {\\n            for (int j = -1; j <= 1; j++) {\\n                if (i == 0 && j == 0)\\n                    continue;\\n                int x = r + i;\\n                int y = c + j;\\n                if (x >= 0 && x < m && y >= 0 && y < n) {\\n                    if (grid[x][y] == 1)\\n                        continue;\\n                    int d1 = dist[x][y];\\n                    if (d1 < d0-1) { // get a smaller value from a neighbor; then re-start the process.\\n                        dist[r][c] = d1+1;\\n                        grow(grid, dist, r, c); // TODO some optimization to avoid stack overflow\\n                        return;\\n                    } else if (d1 > d0+1) { // give a smaller value to a neighbor\\n                        dist[x][y] = d0+1;\\n                        grow(grid, dist, x, y);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int m = grid.length, n = grid[0].length;\\n        int[][] dist = new int[m][n]; // dist[i][j]: distance of the cell (i,j) to (0,0)\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                dist[i][j] = Integer.MAX_VALUE;\\n            }\\n        }\\n        dist[0][0] = 1;\\n        if (grid[0][0] == 1 || grid[m-1][n-1] == 1)\\n            return -1;\\n        grow(grid, dist, 0, 0);\\n        return (dist[m-1][n-1] != Integer.MAX_VALUE ? dist[m-1][n-1] : -1);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 312922,
                "title": "java-python-3-concise-bfs-and-dfs-codes-w-o-changing-input",
                "content": "**Method 1: BFS**\\nUpdate:\\nIn case you are not comfortable with the approach by encoding of the coordinates, here is another version (but input `grid` modified):\\n```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        Queue<Integer> q = new LinkedList<>();\\n        if (grid[0][0] == 0) // if starting point not blocked. \\n                q.offer(0);\\n        int n = grid.length;\\n        for (int steps = 1; !q.isEmpty(); ++steps) { // increase one per round of search.\\n            for (int sz = q.size(); sz > 0; --sz) { // breadth control.\\n                int x = q.peek() / n, y = q.poll() % n; // decode.\\n                if (x == n - 1 && y == n - 1) // find shortest path.\\n                    return steps; // return its length.\\n                for (int i = x - 1; i <= x + 1; ++i) {  // traverse 8 neighbors of (x, y)\\n                    for (int j = y - 1; j <= y + 1; ++j) { // (i, j) is neighbor\\'s coordinates.\\n                        if (i >= 0 && i < n && j >= 0 && j < n && grid[i][j] == 0) {\\n                            q.offer(i * n + j); // add it into queue if it is valid, and not blocked or visited.\\n                            grid[i][j] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\n\\n----\\n\\n\\n1. Encode each cell coordinates `(x, y)` to `x * n + y`, where `n = grid[0].length`;\\n2. starting from `(0, 0)`, for each cell, if valid, neither blocked nor visited, put its encoded coordinates into a Queue and a HashSet, the latter of which is used to avoid duplicates.\\n3. BFS search based on the Queue; for each polled out encoded number, decode it and traverse its 8 neighbors.\\n4. repeat 2 and 3 till all cells are visited.\\n\\n**NOTE**: for case `(dx, dy) = (0,0)`, the neighbor is `(x, y)` itself, and it will be filtered out by HashSet and will not be added into Queue again.\\n```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int N = grid.length;\\n        if (grid[0][0] == 1 || grid[N - 1][N - 1] == 1) // if starting/ending point blocked.\\n            return -1;\\n        Set<Integer> seen = new HashSet<>(Arrays.asList(0)); // avoid duplicates. \\n        Queue<Integer> q = new LinkedList<>(seen);\\n        for (int steps = 1; !q.isEmpty(); ++steps) { // increase one per round of search.\\n            for (int sz = q.size(); sz > 0; --sz) { // breadth control.\\n                int x = q.peek() / N, y = q.poll() % N; // decode.\\n                if (x == N - 1 && y == N - 1)  // find shortest path.\\n                    return steps; // return its length. \\n                for (int i = x - 1; i <= x + 1; ++i) {  // traverse 8 neighbors of (x, y)\\n                    for (int j = y - 1; j <= y + 1; ++j) { // (i, j) is neighbor\\'s coordinates.\\n                        if (i >= 0 && i < N && j >= 0 && j < N && grid[i][j] == 0 && seen.add(i * N + j)) {\\n                            q.offer(i * N + j); // add it into queue if it is valid, neither blocked nor visited.\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\\nPut into queue the `tuple(rowNumber, colNumer, steps from source)`.\\n```python\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] or grid[-1][-1]: \\n            return -1\\n        N, q, seen = len(grid), [(0, 0, 1)], set([0])\\n        for x, y, steps in q:\\n            if x == N - 1 and y == N - 1: \\n                return steps;\\n            for i in (x - 1, x, x + 1):\\n                for j in (y - 1, y, y + 1):\\n                    if i >= 0 and i < N and j >= 0 and j < N and grid[i][j] == 0 and i * N + j not in seen:\\n                        seen.add(i * N + j)\\n                        q.append((i, j, steps + 1))\\n        return -1\\n```\\n**Analysis**:\\n\\nTime & space: O(n ^ 2), n = grid.length.\\n\\n----\\n**Method 2: DFS**\\n\\n**Similar to wave propagation on water surface.**\\npropagates shortest path distance among neighbors. Idea inspired by @sunrenjie\\n\\n1. Use a 2d array to store currently found shortest distance from source to the visiting cell. \\n2. In DFS, compare the value of visiting cell with that of its neighbors, update bigger values with smaller values;\\n3. In above 2, keep recursing till the distance values difference between any 2 neighboring cells is no more than 1.\\n----\\n**Q & A:**\\nQ:\\nIn DFS method, why are you checking for this condition --> `Math.abs(d[x][y] - d[r][c]) > 1`\\nA:\\nIt\\'s the recursion termination condition: distance values difference between any 2 neighboring non-blocked cells is no more than 1;  Specifically, if the difference <= 1, then the visiting cell maintains the currently found shortest path distance value, and there is no way to make the distance shorter.\\n\\nFor any 2 neighbors `(x, y)` and `(r, c)`, if the difference between the distance from source `(0, 0)` is bigger than 1,  e.g., `dist[x][y] = 3, dist[r][c] = 7`, then we can change the corresponding path of `dist[r][c]` to the corresponding path of `dist[x][y]` plus the distance from `(x, y)` to its neighbor `(r, c)`. That is, updating `dist[r][c]` to the current shortest path distance: `dist[x][y] + 1 = 4`.\\n```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dist = new int[n][n];\\n        for (int[] row : dist) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        if (grid[0][0] == 0 && grid[n - 1][n - 1] == 0) // if both source and target are clear. \\n            dist[0][0] = 1; // initialize it with 1.\\n        for (int r = 0; r < n; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                dfs(grid, dist, r, c);\\n            }\\n        }\\n        int v = dist[n - 1][n - 1]; // shorest distance from source to target.\\n        return v == Integer.MAX_VALUE ? -1 : v;\\n    }\\n    private void dfs(int[][] g, int[][] d, int x, int y) {\\n        for (int r = x - 1, n = g.length; r <= x + 1; ++r) {\\n            for (int c = y - 1; c <= y + 1; ++c) {\\n                if (r >= 0 && r < n && c >= 0 && c < n && g[r][c] == 0 && Math.abs(d[x][y] - d[r][c]) > 1) {\\n                    if (d[x][y] > d[r][c]) { d[x][y] = d[r][c] + 1; } // if source to (x, y) > source to (r, c ) + 1, update d[x][y].\\n                    else if (g[x][y] == 0) { d[r][c] = d[x][y] + 1; } // otherwise update d[r][c].\\n                    dfs(g, d, r, c);\\n                }\\n            }\\n        }        \\n    }\\n```\\n```python\\n   def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] or grid[-1][-1]: \\n            return -1\\n        N = len(grid)\\n        dist = [[inf] * N for _ in range(N)]\\n        dist[0][0] = 1\\n        \\n        def dfs(grid: List[List[int]], dist: List[List[int]], x: int, y: int) -> None:\\n            for r in (x - 1, x, x + 1):\\n                for c in (y - 1, y, y + 1):\\n                    if r >= 0 and r < N and c >= 0 and c < N and grid[r][c] == 0 and abs(dist[x][y] - dist[r][c]) > 1:\\n                        if dist[x][y] > dist[r][c] + 1:\\n                            dist[x][y] = dist[r][c] + 1\\n                        elif grid[x][y] == 0:\\n                            dist[r][c] = dist[x][y] + 1\\n                        dfs(grid, dist, r, c)\\n                        \\n        for r in range(N):\\n            for c in range(N):     \\n                dfs(grid, dist, r, c)\\n        return dist[-1][-1] if dist[-1][-1] <= N * N else -1\\n```\\n\\n**Analysis**:\\n\\nTime & space: O(n ^ 2), n = grid.length.",
                "solutionTags": [],
                "code": "```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        Queue<Integer> q = new LinkedList<>();\\n        if (grid[0][0] == 0) // if starting point not blocked. \\n                q.offer(0);\\n        int n = grid.length;\\n        for (int steps = 1; !q.isEmpty(); ++steps) { // increase one per round of search.\\n            for (int sz = q.size(); sz > 0; --sz) { // breadth control.\\n                int x = q.peek() / n, y = q.poll() % n; // decode.\\n                if (x == n - 1 && y == n - 1) // find shortest path.\\n                    return steps; // return its length.\\n                for (int i = x - 1; i <= x + 1; ++i) {  // traverse 8 neighbors of (x, y)\\n                    for (int j = y - 1; j <= y + 1; ++j) { // (i, j) is neighbor\\'s coordinates.\\n                        if (i >= 0 && i < n && j >= 0 && j < n && grid[i][j] == 0) {\\n                            q.offer(i * n + j); // add it into queue if it is valid, and not blocked or visited.\\n                            grid[i][j] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int N = grid.length;\\n        if (grid[0][0] == 1 || grid[N - 1][N - 1] == 1) // if starting/ending point blocked.\\n            return -1;\\n        Set<Integer> seen = new HashSet<>(Arrays.asList(0)); // avoid duplicates. \\n        Queue<Integer> q = new LinkedList<>(seen);\\n        for (int steps = 1; !q.isEmpty(); ++steps) { // increase one per round of search.\\n            for (int sz = q.size(); sz > 0; --sz) { // breadth control.\\n                int x = q.peek() / N, y = q.poll() % N; // decode.\\n                if (x == N - 1 && y == N - 1)  // find shortest path.\\n                    return steps; // return its length. \\n                for (int i = x - 1; i <= x + 1; ++i) {  // traverse 8 neighbors of (x, y)\\n                    for (int j = y - 1; j <= y + 1; ++j) { // (i, j) is neighbor\\'s coordinates.\\n                        if (i >= 0 && i < N && j >= 0 && j < N && grid[i][j] == 0 && seen.add(i * N + j)) {\\n                            q.offer(i * N + j); // add it into queue if it is valid, neither blocked nor visited.\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```\n```python\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] or grid[-1][-1]: \\n            return -1\\n        N, q, seen = len(grid), [(0, 0, 1)], set([0])\\n        for x, y, steps in q:\\n            if x == N - 1 and y == N - 1: \\n                return steps;\\n            for i in (x - 1, x, x + 1):\\n                for j in (y - 1, y, y + 1):\\n                    if i >= 0 and i < N and j >= 0 and j < N and grid[i][j] == 0 and i * N + j not in seen:\\n                        seen.add(i * N + j)\\n                        q.append((i, j, steps + 1))\\n        return -1\\n```\n```java\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dist = new int[n][n];\\n        for (int[] row : dist) {\\n            Arrays.fill(row, Integer.MAX_VALUE);\\n        }\\n        if (grid[0][0] == 0 && grid[n - 1][n - 1] == 0) // if both source and target are clear. \\n            dist[0][0] = 1; // initialize it with 1.\\n        for (int r = 0; r < n; ++r) {\\n            for (int c = 0; c < n; ++c) {\\n                dfs(grid, dist, r, c);\\n            }\\n        }\\n        int v = dist[n - 1][n - 1]; // shorest distance from source to target.\\n        return v == Integer.MAX_VALUE ? -1 : v;\\n    }\\n    private void dfs(int[][] g, int[][] d, int x, int y) {\\n        for (int r = x - 1, n = g.length; r <= x + 1; ++r) {\\n            for (int c = y - 1; c <= y + 1; ++c) {\\n                if (r >= 0 && r < n && c >= 0 && c < n && g[r][c] == 0 && Math.abs(d[x][y] - d[r][c]) > 1) {\\n                    if (d[x][y] > d[r][c]) { d[x][y] = d[r][c] + 1; } // if source to (x, y) > source to (r, c ) + 1, update d[x][y].\\n                    else if (g[x][y] == 0) { d[r][c] = d[x][y] + 1; } // otherwise update d[r][c].\\n                    dfs(g, d, r, c);\\n                }\\n            }\\n        }        \\n    }\\n```\n```python\\n   def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] or grid[-1][-1]: \\n            return -1\\n        N = len(grid)\\n        dist = [[inf] * N for _ in range(N)]\\n        dist[0][0] = 1\\n        \\n        def dfs(grid: List[List[int]], dist: List[List[int]], x: int, y: int) -> None:\\n            for r in (x - 1, x, x + 1):\\n                for c in (y - 1, y, y + 1):\\n                    if r >= 0 and r < N and c >= 0 and c < N and grid[r][c] == 0 and abs(dist[x][y] - dist[r][c]) > 1:\\n                        if dist[x][y] > dist[r][c] + 1:\\n                            dist[x][y] = dist[r][c] + 1\\n                        elif grid[x][y] == 0:\\n                            dist[r][c] = dist[x][y] + 1\\n                        dfs(grid, dist, r, c)\\n                        \\n        for r in range(N):\\n            for c in range(N):     \\n                dfs(grid, dist, r, c)\\n        return dist[-1][-1] if dist[-1][-1] <= N * N else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1063562,
                "title": "bfs-clean-code-easy-to-understand-heavily-commented",
                "content": "**With Separate Visited Array**\\n\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] == 1) // check if starting cell itself is blocked -> -1\\n            return -1;\\n        \\n        int m = grid.length, n = grid[0].length; // m = n = N \\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[m][n];\\n\\t\\t\\n\\t\\t// dx dy 8 directional vector\\n        int[] dx = new int[]{1, 1, 0, -1, -1, -1, 0, 1};\\n        int[] dy = new int[]{0, 1, 1, 1, 0, -1, -1, -1};\\n        \\n\\t\\t// initialize from source top left cell\\n        q.add(new int[]{0, 0});\\n        visited[0][0] = true;\\n        int level = 1;\\n        \\n        while(q.size() > 0) {\\n            for(int i = q.size(); i > 0; i--) { // iterate all cells in next level\\n                int[] xy = q.poll();\\n                if(xy[0] == m - 1 && xy[1] == n - 1) // check if reached bottom right most cell\\n                    return level;\\n                for(int j = 0; j < 8; j++) { // loop 8 directiona cells \\n                    int nx = xy[0] + dx[j];\\n                    int ny = xy[1] + dy[j];\\n                    if(nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] && grid[nx][ny] == 0) { // check if next cell coordinates valid\\n                        visited[nx][ny] = true;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n                }\\n            }\\n            \\n            level++; // update level after processing level\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\n**TC - SC - O(mn)**\\n\\n**Without Separate Visited Array**\\nIf you see instead of using separate boolean[][] visited array we can re-use grid for visited mark to save the space.\\n\\n\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] == 1) // check if starting cell itself is blocked -> -1\\n            return -1;\\n        \\n        int m = grid.length, n = grid[0].length; // m = n = N \\n        Queue<int[]> q = new LinkedList<>();\\n        // boolean[][] visited = new boolean[m][n];\\n\\t\\t\\n\\t\\t// dx dy 8 directional vector\\n        int[] dx = new int[]{1, 1, 0, -1, -1, -1, 0, 1};\\n        int[] dy = new int[]{0, 1, 1, 1, 0, -1, -1, -1};\\n        \\n\\t\\t// initialize from source top left cell\\n        q.add(new int[]{0, 0});\\n        grid[0][0] = 1;\\n        int level = 1;\\n        \\n        while(q.size() > 0) {\\n            for(int i = q.size(); i > 0; i--) { // iterate all cells in next level\\n                int[] xy = q.poll();\\n                if(xy[0] == m - 1 && xy[1] == n - 1) // check if reached bottom right most cell\\n                    return level;\\n                for(int j = 0; j < 8; j++) { // loop 8 directiona cells \\n                    int nx = xy[0] + dx[j];\\n                    int ny = xy[1] + dy[j];\\n                    if(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 0) { // check if next cell coordinates valid\\n                        grid[nx][ny] = 1;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n                }\\n            }\\n            \\n            level++; // update level after processing level\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\nIf you like solution **upvote**.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] == 1) // check if starting cell itself is blocked -> -1\\n            return -1;\\n        \\n        int m = grid.length, n = grid[0].length; // m = n = N \\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[m][n];\\n\\t\\t\\n\\t\\t// dx dy 8 directional vector\\n        int[] dx = new int[]{1, 1, 0, -1, -1, -1, 0, 1};\\n        int[] dy = new int[]{0, 1, 1, 1, 0, -1, -1, -1};\\n        \\n\\t\\t// initialize from source top left cell\\n        q.add(new int[]{0, 0});\\n        visited[0][0] = true;\\n        int level = 1;\\n        \\n        while(q.size() > 0) {\\n            for(int i = q.size(); i > 0; i--) { // iterate all cells in next level\\n                int[] xy = q.poll();\\n                if(xy[0] == m - 1 && xy[1] == n - 1) // check if reached bottom right most cell\\n                    return level;\\n                for(int j = 0; j < 8; j++) { // loop 8 directiona cells \\n                    int nx = xy[0] + dx[j];\\n                    int ny = xy[1] + dy[j];\\n                    if(nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] && grid[nx][ny] == 0) { // check if next cell coordinates valid\\n                        visited[nx][ny] = true;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n                }\\n            }\\n            \\n            level++; // update level after processing level\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] == 1) // check if starting cell itself is blocked -> -1\\n            return -1;\\n        \\n        int m = grid.length, n = grid[0].length; // m = n = N \\n        Queue<int[]> q = new LinkedList<>();\\n        // boolean[][] visited = new boolean[m][n];\\n\\t\\t\\n\\t\\t// dx dy 8 directional vector\\n        int[] dx = new int[]{1, 1, 0, -1, -1, -1, 0, 1};\\n        int[] dy = new int[]{0, 1, 1, 1, 0, -1, -1, -1};\\n        \\n\\t\\t// initialize from source top left cell\\n        q.add(new int[]{0, 0});\\n        grid[0][0] = 1;\\n        int level = 1;\\n        \\n        while(q.size() > 0) {\\n            for(int i = q.size(); i > 0; i--) { // iterate all cells in next level\\n                int[] xy = q.poll();\\n                if(xy[0] == m - 1 && xy[1] == n - 1) // check if reached bottom right most cell\\n                    return level;\\n                for(int j = 0; j < 8; j++) { // loop 8 directiona cells \\n                    int nx = xy[0] + dx[j];\\n                    int ny = xy[1] + dy[j];\\n                    if(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 0) { // check if next cell coordinates valid\\n                        grid[nx][ny] = 1;\\n                        q.add(new int[]{nx, ny});\\n                    }\\n                }\\n            }\\n            \\n            level++; // update level after processing level\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541087,
                "title": "easy-and-clear-java-bfs-solution-with-explanation",
                "content": "Why use BFS instead of DFS?\\nBecause it can explore every possible direction at the same time and with same speed, meaning that if any branch reaches the end, it must be the fastest one. So every point will only be visited once at most and we can exit anytime if we reach the end. (Even if there is a second route reaches the same point, it will not be as fast as the first one, so we do not need to think about detours -  which is very difficult to tackle in DFS solutions.)\\nIf total point number is N, Both time and space complexity is O(N).\\n\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        \\n        //initialization for 8 directions, a map(map is the name, it is a Queue for BFS) and row-column boundaries\\n        int[][] dir = {{1,1},{1,0},{0,1},{1,-1},{-1,1},{-1,0},{0,-1},{-1,-1}};\\n        Queue<int[]> map =new LinkedList<>();\\n        int rMax = grid.length;\\n        int cMax = grid[0].length;\\n        \\n        //if start point is blocked, return -1, otherwise give map the start point\\n        if(grid[0][0]==1) return -1; \\n        \\n        //first two parameters are coordinates, third keep track of the distance\\n        map.offer(new int[] {0,0,1});\\n        \\n        while(!map.isEmpty()){\\n            //get current coordinates and distance travelled\\n            int[] location = map.poll();\\n            int r = location[0];\\n            int c = location[1];\\n            int distance = location[2];\\n            \\n            //return if reaches the destination\\n            if(r==rMax-1 && c==cMax-1) return distance;\\n            \\n            //search 8 directions for unexplored points around current point\\n            for(int[] d : dir){\\n                int r2 = r + d[0];\\n                int c2 = c + d[1];\\n                if(r2<rMax && r2>=0 && c2<cMax && c2>=0 && grid[r2][c2]==0){\\n                    //add unexplored point to map and increment distance by 1\\n                    map.offer(new int[] {r2,c2,distance+1});\\n\\t\\t\\t\\t\\t//set this point to 1 as explored\\n                    grid[r2][c2] = 1;\\n                }\\n            }\\n        }   \\n        // whole space searched, cannot reach destination\\n        return -1;\\n    }\\n}\\n```\\n\\nVersion without comments:\\n\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int[][] dir = {{1,1},{1,0},{0,1},{1,-1},{-1,1},{-1,0},{0,-1},{-1,-1}};\\n        Queue<int[]> map =new LinkedList<>();\\n        int rMax = grid.length;\\n        int cMax = grid[0].length;\\n        if(grid[0][0]==1) return -1; \\n        map.offer(new int[] {0,0,1});\\n        while(!map.isEmpty()){\\n            int[] location = map.poll();\\n            int r = location[0];\\n            int c = location[1];\\n            int distance = location[2];\\n            if(r==rMax-1 && c==cMax-1) return distance;\\n            for(int[] d : dir){\\n                int r2 = r + d[0];\\n                int c2 = c + d[1];\\n                if(r2<rMax && r2>=0 && c2<cMax && c2>=0 && grid[r2][c2]==0){\\n                    map.offer(new int[] {r2,c2,distance+1});\\n                    grid[r2][c2] = 1;\\n                }\\n            }\\n        }   \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        \\n        //initialization for 8 directions, a map(map is the name, it is a Queue for BFS) and row-column boundaries\\n        int[][] dir = {{1,1},{1,0},{0,1},{1,-1},{-1,1},{-1,0},{0,-1},{-1,-1}};\\n        Queue<int[]> map =new LinkedList<>();\\n        int rMax = grid.length;\\n        int cMax = grid[0].length;\\n        \\n        //if start point is blocked, return -1, otherwise give map the start point\\n        if(grid[0][0]==1) return -1; \\n        \\n        //first two parameters are coordinates, third keep track of the distance\\n        map.offer(new int[] {0,0,1});\\n        \\n        while(!map.isEmpty()){\\n            //get current coordinates and distance travelled\\n            int[] location = map.poll();\\n            int r = location[0];\\n            int c = location[1];\\n            int distance = location[2];\\n            \\n            //return if reaches the destination\\n            if(r==rMax-1 && c==cMax-1) return distance;\\n            \\n            //search 8 directions for unexplored points around current point\\n            for(int[] d : dir){\\n                int r2 = r + d[0];\\n                int c2 = c + d[1];\\n                if(r2<rMax && r2>=0 && c2<cMax && c2>=0 && grid[r2][c2]==0){\\n                    //add unexplored point to map and increment distance by 1\\n                    map.offer(new int[] {r2,c2,distance+1});\\n\\t\\t\\t\\t\\t//set this point to 1 as explored\\n                    grid[r2][c2] = 1;\\n                }\\n            }\\n        }   \\n        // whole space searched, cannot reach destination\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int[][] dir = {{1,1},{1,0},{0,1},{1,-1},{-1,1},{-1,0},{0,-1},{-1,-1}};\\n        Queue<int[]> map =new LinkedList<>();\\n        int rMax = grid.length;\\n        int cMax = grid[0].length;\\n        if(grid[0][0]==1) return -1; \\n        map.offer(new int[] {0,0,1});\\n        while(!map.isEmpty()){\\n            int[] location = map.poll();\\n            int r = location[0];\\n            int c = location[1];\\n            int distance = location[2];\\n            if(r==rMax-1 && c==cMax-1) return distance;\\n            for(int[] d : dir){\\n                int r2 = r + d[0];\\n                int c2 = c + d[1];\\n                if(r2<rMax && r2>=0 && c2<cMax && c2>=0 && grid[r2][c2]==0){\\n                    map.offer(new int[] {r2,c2,distance+1});\\n                    grid[r2][c2] = 1;\\n                }\\n            }\\n        }   \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442676,
                "title": "python-bfs",
                "content": "A regular BFS question, remember to check the length of grid to be valid and check the start point and end point to be valid.\\n\\n\\n```\\n\\nimport collections\\nclass Solution(object):\\n    def shortestPathBinaryMatrix(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1\\n        visited = set((0, 0))\\n        queue = collections.deque([(0, 0, 1)])\\n        \\n        while queue:\\n            x, y, level = queue.popleft()\\n            if (x, y) == (len(grid) - 1, len(grid[0]) - 1): return level\\n            for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]:\\n                if 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]) and grid[x + dx][y + dy] == 0 and (x + dx, y + dy) not in visited:\\n                    visited.add((x + dx, y + dy))\\n                    queue.append((x + dx, y + dy, level + 1))\\n            \\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "A regular BFS question, remember to check the length of grid to be valid and check the start point and end point to be valid.\\n\\n\\n```\\n\\nimport collections\\nclass Solution(object):\\n    def shortestPathBinaryMatrix(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0] or grid[0][0] == 1 or grid[-1][-1] == 1: return -1\\n        visited = set((0, 0))\\n        queue = collections.deque([(0, 0, 1)])\\n        \\n        while queue:\\n            x, y, level = queue.popleft()\\n            if (x, y) == (len(grid) - 1, len(grid[0]) - 1): return level\\n            for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]:\\n                if 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]) and grid[x + dx][y + dy] == 0 and (x + dx, y + dy) not in visited:\\n                    visited.add((x + dx, y + dy))\\n                    queue.append((x + dx, y + dy, level + 1))\\n            \\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 2044691,
                "title": "c-bfs-explanation-with-comments-daily-leetcoding-challenge-may-day-16",
                "content": "![image](https://assets.leetcode.com/users/images/eb522a64-f2c8-4971-9a25-c646d875e39a_1652702897.407756.jpeg)\\n**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    /*\\n       8 moves, if you are at i,j\\n   \\n\\t   i-1,j-1    i-1,j    i-1,j+1\\n\\t   i,j-1      i,j      i,j+1\\n \\t   i+1,j+1    i+1,j    i+1,j+1\\n    */\\n    \\n    // just check that current i or j inside the boundary and also check it is not having value eqaul to zero\\n    // and also check it is not visited previously\\n    bool check(int i,int j,map<pair<int,int>,bool>& visited,vector<vector<int>>& grid)\\n    {\\n        int n = grid.size();\\n    \\n        // if current i and j follows the given conditions then return true\\n        if(i >= 0 && j >= 0 && i < n && j < n && grid[i][j] != 1 && (visited.find({i,j}) == visited.end()))\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        // if first element of our grid is not zero then return -1\\n        if(grid[0][0] == 1) return -1;\\n        \\n        int n = grid.size();\\n       \\n        // craeting a queue that will store the cordinates and their corresponding path value\\n        queue<vector<int>> Q;\\n        Q.push({0,0,0}); // i,j,dist\\n        \\n        // this map will take care of ecah cell that it is vidites or not\\n        // initially all the cells are false means not visited\\n        map<pair<int,int>,bool> visited;\\n        \\n        // making very first cell is true because we are going to start from here\\n        visited[{0,0}] = true;\\n        \\n        // BFS\\n        while(!Q.empty())\\n        {\\n            // take our the front vector from queue\\n            auto curr = Q.front();\\n            Q.pop();\\n            \\n            // extracting the data information\\n            int i = curr[0],j = curr[1],dist = curr[2];\\n            \\n            // if we reach to the last cell then return the dist+1 because we will also consider current cell value as 1\\n            if(i == n-1 && j == n-1)\\n            {\\n                return dist+1;\\n            }\\n            \\n            // left(check it will be following or not)\\n            if(check(i,j-1,visited,grid))\\n            {\\n                visited[{i,j-1}] = true;\\n                Q.push({i,j-1,dist+1});\\n            }\\n            \\n            // right\\n            if(check(i,j+1,visited,grid))\\n            {\\n                visited[{i,j+1}] = true;\\n                Q.push({i,j+1,dist+1});\\n            }\\n            \\n            // up \\n            if(check(i-1,j,visited,grid))\\n            {\\n                visited[{i-1,j}] = true;\\n                Q.push({i-1,j,dist+1});\\n            }\\n            \\n            // down \\n            if(check(i+1,j,visited,grid))\\n            {\\n                visited[{i+1,j}] = true;\\n                Q.push({i+1,j,dist+1});\\n            }\\n            \\n            // leftUp\\n            if(check(i-1,j-1,visited,grid))\\n            {\\n                visited[{i-1,j-1}] = true;\\n                Q.push({i-1,j-1,dist+1});\\n            }\\n            \\n            // rightUp \\n            if(check(i-1,j+1,visited,grid))\\n            {\\n                visited[{i-1,j+1}] = true;\\n                Q.push({i-1,j+1,dist+1});\\n            }\\n            \\n            // leftDown \\n            if(check(i+1,j-1,visited,grid))\\n            {\\n                visited[{i+1,j-1}] = true;\\n                Q.push({i+1,j-1,dist+1});\\n            }\\n            \\n            // rightDown \\n            if(check(i+1,j+1,visited,grid))\\n            {\\n                visited[{i+1,j+1}] = true;\\n                Q.push({i+1,j+1,dist+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n       8 moves, if you are at i,j\\n   \\n\\t   i-1,j-1    i-1,j    i-1,j+1\\n\\t   i,j-1      i,j      i,j+1\\n \\t   i+1,j+1    i+1,j    i+1,j+1\\n    */\\n    \\n    // just check that current i or j inside the boundary and also check it is not having value eqaul to zero\\n    // and also check it is not visited previously\\n    bool check(int i,int j,map<pair<int,int>,bool>& visited,vector<vector<int>>& grid)\\n    {\\n        int n = grid.size();\\n    \\n        // if current i and j follows the given conditions then return true\\n        if(i >= 0 && j >= 0 && i < n && j < n && grid[i][j] != 1 && (visited.find({i,j}) == visited.end()))\\n        {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        // if first element of our grid is not zero then return -1\\n        if(grid[0][0] == 1) return -1;\\n        \\n        int n = grid.size();\\n       \\n        // craeting a queue that will store the cordinates and their corresponding path value\\n        queue<vector<int>> Q;\\n        Q.push({0,0,0}); // i,j,dist\\n        \\n        // this map will take care of ecah cell that it is vidites or not\\n        // initially all the cells are false means not visited\\n        map<pair<int,int>,bool> visited;\\n        \\n        // making very first cell is true because we are going to start from here\\n        visited[{0,0}] = true;\\n        \\n        // BFS\\n        while(!Q.empty())\\n        {\\n            // take our the front vector from queue\\n            auto curr = Q.front();\\n            Q.pop();\\n            \\n            // extracting the data information\\n            int i = curr[0],j = curr[1],dist = curr[2];\\n            \\n            // if we reach to the last cell then return the dist+1 because we will also consider current cell value as 1\\n            if(i == n-1 && j == n-1)\\n            {\\n                return dist+1;\\n            }\\n            \\n            // left(check it will be following or not)\\n            if(check(i,j-1,visited,grid))\\n            {\\n                visited[{i,j-1}] = true;\\n                Q.push({i,j-1,dist+1});\\n            }\\n            \\n            // right\\n            if(check(i,j+1,visited,grid))\\n            {\\n                visited[{i,j+1}] = true;\\n                Q.push({i,j+1,dist+1});\\n            }\\n            \\n            // up \\n            if(check(i-1,j,visited,grid))\\n            {\\n                visited[{i-1,j}] = true;\\n                Q.push({i-1,j,dist+1});\\n            }\\n            \\n            // down \\n            if(check(i+1,j,visited,grid))\\n            {\\n                visited[{i+1,j}] = true;\\n                Q.push({i+1,j,dist+1});\\n            }\\n            \\n            // leftUp\\n            if(check(i-1,j-1,visited,grid))\\n            {\\n                visited[{i-1,j-1}] = true;\\n                Q.push({i-1,j-1,dist+1});\\n            }\\n            \\n            // rightUp \\n            if(check(i-1,j+1,visited,grid))\\n            {\\n                visited[{i-1,j+1}] = true;\\n                Q.push({i-1,j+1,dist+1});\\n            }\\n            \\n            // leftDown \\n            if(check(i+1,j-1,visited,grid))\\n            {\\n                visited[{i+1,j-1}] = true;\\n                Q.push({i+1,j-1,dist+1});\\n            }\\n            \\n            // rightDown \\n            if(check(i+1,j+1,visited,grid))\\n            {\\n                visited[{i+1,j+1}] = true;\\n                Q.push({i+1,j+1,dist+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 901706,
                "title": "simple-c-with-explanation-and-why-it-s-not-rotten-oranges-problem",
                "content": "It\\'s a simple BFS problem. Basically, visit all the neighboring nodes first and then keep going till all the elements are visited at least once or if you reach the end node ie `(n, m)`\\n\\nWhy is this not a rotten oranges problem? **Major Spoiler alert** if you haven\\'t solved it yet!\\nIn rotten oranges, the key idea is to start from every rotten orange and go till every orange is rotten. Level/depth of the traversal is important. Here, it\\'s a simple BFS which begins at `(0, 0)` and ends at `(n,m)`.\\n\\n**Intuition:**\\nIt can be solved in two ways of the same time complexity. Both **`O(N * M)`**\\n\\n**One way**, is to remember the distance from `(0,0)` to `(n,m)` inside the queue along with the indices as the third element. Ex: `(0, 0, 1)` and thus keep on adding 1s until you reach `(n, m, shortestDistance)` and return `shortestDistance`.\\n\\nBecause I\\'m doing it in-place, I *don\\'t need `visited` array*.\\n\\n```\\n// For explanation check the next code snippet. Idea is exactly same.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector <vector <int>> moves = {{-1,-1}, {-1, 0}, {-1, 1}, {0, -1},{0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n        int n = grid.size() - 1;\\n        int m = grid[0].size() - 1;\\n        queue <vector <int>> que;\\n        if(grid[0][0] || grid[n][m])\\n            return -1;\\n        que.push({0, 0, 1});\\n        while(!que.empty()){\\n            vector <int> top = que.front();\\n            que.pop();\\n            if(top[0] == n && top[1] == m)\\n                return top[2];\\n            for(vector <int> move: moves){\\n                int x = top[0] + move[0], y = top[1] + move[1];\\n                if( 0 <= x && x <= n && 0 <= y && y <= m && grid[x][y] == 0){\\n                    grid[x][y] = 1;  // mark visted\\n                    que.push({x, y, top[2] + 1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n**Another way**, is to propagate the distance to the neighbors based on my current distance. So, just add one to neighbors. This way, there is a slight improvement in memory. Simply do a BFS but for 8 steps with the first step already taken as 1.\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector <vector <int>> moves = {{-1,-1}, {-1, 0}, {-1, 1}, {0, -1},{0, 1}, {1, -1}, {1, 0}, {1, 1}}; // The order doesn\\'t matter.\\n        int n = grid.size() - 1;\\n        int m = grid[0].size() - 1;\\n        queue <vector <int>> que;\\n        if(grid[0][0] || grid[n][m])\\n            return -1;\\n        que.push({0, 0});\\n        grid[0][0] = 1;\\n        while(!que.empty() && !grid[n][m]){ \\n\\t\\t/* If my last node is visited, I exit immediately.\\n\\t\\t* 1. The Fastest path is always the shortest path in BFS \\n\\t\\t*    Hence, The first path to reach the end is the shortest path.\\n\\t\\t*    Early termination is needed here. If there is a lot of\\n\\t\\t*    unvisited nodes in-between that don\\'t lead to the end node, it gives TLE.\\n\\t\\t* 2. Doing a level order(two loops) is also possible. But we don\\'t need to remember the level.\\n\\t\\t*    So one loop will do\\n\\t\\t*/\\n            vector <int> top = que.front();      // Do not use \\'auto\\' here. I gives TLE\\n            que.pop();\\n            for(vector <int> move: moves){       // Do not use \\'auto\\' here. I gives TLE\\n                int x = top[0] + move[0], y = top[1] + move[1];\\n                if(0 <= x && x <= n && 0 <= y && y <= m && grid[x][y] == 0){\\n                    grid[x][y] = grid[top[0]][top[1]] + 1;   // mark visted and propagate the distance\\n                    que.push({x, y});\\n                }\\n            }\\n        }\\n        return grid[n][m] == 0 ? -1 : grid[n][m];   // If the queue terminated without setting (n, m) to a value other than zero, it means it could never reach the end.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n// For explanation check the next code snippet. Idea is exactly same.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector <vector <int>> moves = {{-1,-1}, {-1, 0}, {-1, 1}, {0, -1},{0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n        int n = grid.size() - 1;\\n        int m = grid[0].size() - 1;\\n        queue <vector <int>> que;\\n        if(grid[0][0] || grid[n][m])\\n            return -1;\\n        que.push({0, 0, 1});\\n        while(!que.empty()){\\n            vector <int> top = que.front();\\n            que.pop();\\n            if(top[0] == n && top[1] == m)\\n                return top[2];\\n            for(vector <int> move: moves){\\n                int x = top[0] + move[0], y = top[1] + move[1];\\n                if( 0 <= x && x <= n && 0 <= y && y <= m && grid[x][y] == 0){\\n                    grid[x][y] = 1;  // mark visted\\n                    que.push({x, y, top[2] + 1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector <vector <int>> moves = {{-1,-1}, {-1, 0}, {-1, 1}, {0, -1},{0, 1}, {1, -1}, {1, 0}, {1, 1}}; // The order doesn\\'t matter.\\n        int n = grid.size() - 1;\\n        int m = grid[0].size() - 1;\\n        queue <vector <int>> que;\\n        if(grid[0][0] || grid[n][m])\\n            return -1;\\n        que.push({0, 0});\\n        grid[0][0] = 1;\\n        while(!que.empty() && !grid[n][m]){ \\n\\t\\t/* If my last node is visited, I exit immediately.\\n\\t\\t* 1. The Fastest path is always the shortest path in BFS \\n\\t\\t*    Hence, The first path to reach the end is the shortest path.\\n\\t\\t*    Early termination is needed here. If there is a lot of\\n\\t\\t*    unvisited nodes in-between that don\\'t lead to the end node, it gives TLE.\\n\\t\\t* 2. Doing a level order(two loops) is also possible. But we don\\'t need to remember the level.\\n\\t\\t*    So one loop will do\\n\\t\\t*/\\n            vector <int> top = que.front();      // Do not use \\'auto\\' here. I gives TLE\\n            que.pop();\\n            for(vector <int> move: moves){       // Do not use \\'auto\\' here. I gives TLE\\n                int x = top[0] + move[0], y = top[1] + move[1];\\n                if(0 <= x && x <= n && 0 <= y && y <= m && grid[x][y] == 0){\\n                    grid[x][y] = grid[top[0]][top[1]] + 1;   // mark visted and propagate the distance\\n                    que.push({x, y});\\n                }\\n            }\\n        }\\n        return grid[n][m] == 0 ? -1 : grid[n][m];   // If the queue terminated without setting (n, m) to a value other than zero, it means it could never reach the end.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361508,
                "title": "c-dfs-tle-bfs-work",
                "content": "**Here `DFS` give `TLE` because we search for every path and then take min out of all that paths**\\n**But `BFS` work \\uD83E\\uDD14 why ?**\\n**because we do traverse in `DFS` manner so first time when we get target cell a[n-1][n-1] then this path is always minimum as we do `DFS`**\\n*Both solution are mentioned bellow*\\n****\\n**DFS ->TLE**\\n```\\nclass Solution {\\npublic:\\n\\tint shortestPathBinaryMatrix(vector<vector<int>>&a) {\\n\\t\\tint ans = INT_MAX;\\n\\t\\tint tempans = 0;\\n\\t\\tint n = a.size();\\n\\t\\tif (a[n - 1][n - 1] != 0)\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tsolve(0, 0, n, a, tempans, ans);\\n\\n\\t\\tif (ans == INT_MAX)\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\treturn (ans + 1);\\n\\t}\\n\\n\\tvoid solve(int i, int j, int n, vector<vector<int>>&a, int &tempans, int &ans)\\n\\t{\\n\\t\\tif (i < 0 || j < 0 || i >= n || j >= n || a[i][j] == 1)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse if (i == n - 1 && j == n - 1)\\n\\t\\t{\\n\\t\\t\\tans = min(ans, tempans);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ta[i][j] = 1;\\n\\t\\ttempans++;\\n\\t\\tsolve(i + 1, j, n, a, tempans, ans);\\n\\t\\tsolve(i, j + 1, n, a, tempans, ans);\\n\\t\\tsolve(i - 1, j, n, a, tempans, ans);\\n\\t\\tsolve(i, j - 1, n, a, tempans, ans);\\n\\t\\tsolve(i + 1, j + 1, n, a, tempans, ans);\\n\\t\\tsolve(i + 1, j - 1, n, a, tempans, ans);\\n\\t\\tsolve(i - 1, j + 1, n, a, tempans, ans);\\n\\t\\tsolve(i - 1, j - 1, n, a, tempans, ans);\\n\\t\\ttempans--;\\n\\t\\ta[i][j] = 0;\\n\\t}\\n};\\n```\\n\\n**BFS\\uD83D\\uDE03**\\n```\\nclass Solution {\\npublic:\\n\\n\\tint dirx[8] = {0, 0, 1, -1, 1, 1, -1, -1};\\n\\tint diry[8] = {1, -1, 0, 0, -1, 1, -1, 1};\\n\\n\\tint shortestPathBinaryMatrix(vector<vector<int>>& a) {\\n\\t\\tint n = a.size();\\n\\t\\tif (a[0][0] != 0 || a[n - 1][n - 1] != 0)\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tqueue<pair<int, int>>q;\\n\\t\\tq.push({0, 0});\\n\\t\\tint step = 0;\\n\\t\\tint size = 0;\\n\\t\\tint x , y, newx, newy;\\n\\t\\twhile (!q.empty())\\n\\t\\t{\\n\\t\\t\\tstep++;\\n\\t\\t\\tsize = q.size();\\n\\t\\t\\twhile (size--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tx = q.front().first;\\n\\t\\t\\t\\ty = q.front().second;\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tif (x == n - 1 && y == n - 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn step;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (int i = 0; i < 8; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnewx = x + dirx[i];\\n\\t\\t\\t\\t\\tnewy = y + diry[i];\\n\\t\\t\\t\\t\\tif (newx >= 0 && newx < n && newy >= 0 && newy < n && a[newx][newy] == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ta[newx][newy] = 1;\\n\\t\\t\\t\\t\\t\\tq.push({newx, newy});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n};\\n```\\n\\n**If find helpful upvote it\\u2714**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint shortestPathBinaryMatrix(vector<vector<int>>&a) {\\n\\t\\tint ans = INT_MAX;\\n\\t\\tint tempans = 0;\\n\\t\\tint n = a.size();\\n\\t\\tif (a[n - 1][n - 1] != 0)\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\n\\t\\tsolve(0, 0, n, a, tempans, ans);\\n\\n\\t\\tif (ans == INT_MAX)\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\treturn (ans + 1);\\n\\t}\\n\\n\\tvoid solve(int i, int j, int n, vector<vector<int>>&a, int &tempans, int &ans)\\n\\t{\\n\\t\\tif (i < 0 || j < 0 || i >= n || j >= n || a[i][j] == 1)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\telse if (i == n - 1 && j == n - 1)\\n\\t\\t{\\n\\t\\t\\tans = min(ans, tempans);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\ta[i][j] = 1;\\n\\t\\ttempans++;\\n\\t\\tsolve(i + 1, j, n, a, tempans, ans);\\n\\t\\tsolve(i, j + 1, n, a, tempans, ans);\\n\\t\\tsolve(i - 1, j, n, a, tempans, ans);\\n\\t\\tsolve(i, j - 1, n, a, tempans, ans);\\n\\t\\tsolve(i + 1, j + 1, n, a, tempans, ans);\\n\\t\\tsolve(i + 1, j - 1, n, a, tempans, ans);\\n\\t\\tsolve(i - 1, j + 1, n, a, tempans, ans);\\n\\t\\tsolve(i - 1, j - 1, n, a, tempans, ans);\\n\\t\\ttempans--;\\n\\t\\ta[i][j] = 0;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n\\tint dirx[8] = {0, 0, 1, -1, 1, 1, -1, -1};\\n\\tint diry[8] = {1, -1, 0, 0, -1, 1, -1, 1};\\n\\n\\tint shortestPathBinaryMatrix(vector<vector<int>>& a) {\\n\\t\\tint n = a.size();\\n\\t\\tif (a[0][0] != 0 || a[n - 1][n - 1] != 0)\\n\\t\\t{\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t\\tqueue<pair<int, int>>q;\\n\\t\\tq.push({0, 0});\\n\\t\\tint step = 0;\\n\\t\\tint size = 0;\\n\\t\\tint x , y, newx, newy;\\n\\t\\twhile (!q.empty())\\n\\t\\t{\\n\\t\\t\\tstep++;\\n\\t\\t\\tsize = q.size();\\n\\t\\t\\twhile (size--)\\n\\t\\t\\t{\\n\\t\\t\\t\\tx = q.front().first;\\n\\t\\t\\t\\ty = q.front().second;\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tif (x == n - 1 && y == n - 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treturn step;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (int i = 0; i < 8; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tnewx = x + dirx[i];\\n\\t\\t\\t\\t\\tnewy = y + diry[i];\\n\\t\\t\\t\\t\\tif (newx >= 0 && newx < n && newy >= 0 && newy < n && a[newx][newy] == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\ta[newx][newy] = 1;\\n\\t\\t\\t\\t\\t\\tq.push({newx, newy});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584016,
                "title": "java-bfs-beats-70-18-lines-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse BFS to traverse from the top left corner to the bottom right corner. Consider all 8 directions from the current cell for the next move. Only consider moving to cells with value `0`. Maintain a `seen` boolean map to keep track of cells that have already been added to the BFS queue so as to not process them again. Using BFS will ensure that we reach the bottom right corner in the minimum number of steps possible.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int shortestPathBinaryMatrix(int[][] grid) {\\n    if (grid[0][0] == 1) return -1;\\n\\n    var moves = new int[][] {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};\\n    var n = grid.length;\\n    var seen = new boolean[n][n];\\n    var queue = new ArrayDeque<int[]>();\\n    queue.offer(new int[] {0, 0});\\n\\n    for (var cnt = 1; !queue.isEmpty(); cnt++) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var cell = queue.poll();\\n\\n        if (cell[0] == n-1 && cell[1] == n-1)\\n          return cnt;\\n\\n        for (var move : moves) {\\n          var x = cell[0] + move[0];\\n          var y = cell[1] + move[1];\\n\\n          if (x >= 0 && x < n && y >= 0 && y < n && !seen[x][y] && grid[x][y] == 0) {\\n            seen[x][y] = true;\\n            queue.offer(new int[] {x, y});\\n          }\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n  public int shortestPathBinaryMatrix(int[][] grid) {\\n    if (grid[0][0] == 1) return -1;\\n\\n    var moves = new int[][] {{-1,-1}, {-1,0}, {-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1}};\\n    var n = grid.length;\\n    var seen = new boolean[n][n];\\n    var queue = new ArrayDeque<int[]>();\\n    queue.offer(new int[] {0, 0});\\n\\n    for (var cnt = 1; !queue.isEmpty(); cnt++) {\\n      for (var i = queue.size(); i > 0; i--) {\\n        var cell = queue.poll();\\n\\n        if (cell[0] == n-1 && cell[1] == n-1)\\n          return cnt;\\n\\n        for (var move : moves) {\\n          var x = cell[0] + move[0];\\n          var y = cell[1] + move[1];\\n\\n          if (x >= 0 && x < n && y >= 0 && y < n && !seen[x][y] && grid[x][y] == 0) {\\n            seen[x][y] = true;\\n            queue.offer(new int[] {x, y});\\n          }\\n        }\\n      }\\n    }\\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491524,
                "title": "python-bfs-to-find-shortest-path-in-non-weight-graph-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: BFS**\\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1\\n        \\n        q = deque([(0, 0)])  # pair of (r, c)\\n        dist = 1\\n        while q:\\n            for _ in range(len(q)):\\n                r, c = q.popleft()\\n                if r == m-1 and c == n-1: return dist\\n                for dr in range(-1, 2):\\n                    for dc in range(-1, 2):\\n                        if dr == 0 and dc == 0: continue\\n                        nr, nc = r + dr, c + dc\\n                        if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == 1: continue\\n                        grid[nr][nc] = 1  # marked as visited\\n                        q.append((nr, nc))\\n            dist += 1\\n        return -1\\n```\\n**Complexity**\\n- Time: `O(M * N)`, where `M <= 100` is the number of rows, `N <= 100` is number of columns in the matrix.\\n\\t- BFS cost `O(E + V)`, where `E = 8 * V` is number of edges, `V = M*N` is number of vertices.\\n\\t- So total complexity: `O(8V + V)` = `O(9V)` = `O(9 * M*N)` ~ `O(M*N)`\\n- Space: `O(M * N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        if grid[0][0] == 1 or grid[m-1][n-1] == 1: return -1\\n        \\n        q = deque([(0, 0)])  # pair of (r, c)\\n        dist = 1\\n        while q:\\n            for _ in range(len(q)):\\n                r, c = q.popleft()\\n                if r == m-1 and c == n-1: return dist\\n                for dr in range(-1, 2):\\n                    for dc in range(-1, 2):\\n                        if dr == 0 and dc == 0: continue\\n                        nr, nc = r + dr, c + dc\\n                        if nr < 0 or nr == m or nc < 0 or nc == n or grid[nr][nc] == 1: continue\\n                        grid[nr][nc] = 1  # marked as visited\\n                        q.append((nr, nc))\\n            dist += 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584102,
                "title": "beats-99-video-solution-java-c-python",
                "content": "# Intuition\\nWhenever the problem is about shortest path, the first thing that comes up is BFS.\\n\\n# Approach\\n1. Check if the top-left or bottom-right cell is blocked by checking if their values are 1. If either of these cells is blocked, we return -1 because there is no valid path.\\n2. Initialize the size of the grid and define two arrays, dx and dy, which represent the changes in the x and y coordinates when moving in different directions\\n3. Initiate queue. Each element in the queue is an array containing the x and y coordinates of a cell and the number of steps taken to reach that cell.\\n4. Add 0,0,1 to queue and mark grid[0][0] = 1\\n5. While the queue isnot empty, add all valid positions that can be visited from this cell and increase step by 1\\n6.  Mark all valid positions = 1 (No revisit)\\n7.  if cell = n-1, n-1 return steps\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/VNmujmu3UjA\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid[0][0] == 1 || grid[grid.length - 1][grid[0].length - 1] == 1) {\\n            return -1;\\n        }\\n        \\n        int n = grid.length;\\n        int[]dx = {-1,0,1};\\n        int[]dy = {-1,0,1};\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0, 1});\\n        grid[0][0] = 1;\\n        \\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int x = curr[0];\\n            int y = curr[1];\\n            int steps = curr[2];\\n            \\n            if (x == n - 1 && y == n - 1) {\\n                return steps;\\n            }\\n            \\n            for(int i = 0;i<3;i++){\\n                for(int j = 0;j<3;j++){\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[j];\\n                    if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 0) {\\n                    queue.offer(new int[]{nx, ny, steps + 1});\\n                    grid[nx][ny] = 1;\\n                }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(std::vector<std::vector<int>>& grid) {\\n        if (grid[0][0] == 1 || grid[grid.size() - 1][grid[0].size() - 1] == 1) {\\n            return -1;\\n        }\\n        \\n        int n = grid.size();\\n        std::vector<int> dx = {-1, 0, 1};\\n        std::vector<int> dy = {-1, 0, 1};\\n        \\n        std::queue<std::vector<int>> queue;\\n        queue.push({0, 0, 1});\\n        grid[0][0] = 1;\\n        \\n        while (!queue.empty()) {\\n            std::vector<int> curr = queue.front();\\n            queue.pop();\\n            int x = curr[0];\\n            int y = curr[1];\\n            int steps = curr[2];\\n            \\n            if (x == n - 1 && y == n - 1) {\\n                return steps;\\n            }\\n            \\n            for (int i = 0; i < 3; i++) {\\n                for (int j = 0; j < 3; j++) {\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[j];\\n                    if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 0) {\\n                        queue.push({nx, ny, steps + 1});\\n                        grid[nx][ny] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\\n\\n```\\nfrom typing import List\\nfrom queue import Queue\\n\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] == 1 or grid[-1][-1] == 1:\\n            return -1\\n        \\n        n = len(grid)\\n        dx = [-1, 0, 1]\\n        dy = [-1, 0, 1]\\n        \\n        queue = Queue()\\n        queue.put([0, 0, 1])\\n        grid[0][0] = 1\\n        \\n        while not queue.empty():\\n            x, y, steps = queue.get()\\n            \\n            if x == n - 1 and y == n - 1:\\n                return steps\\n            \\n            for i in range(3):\\n                for j in range(3):\\n                    nx = x + dx[i]\\n                    ny = y + dy[j]\\n                    \\n                    if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0:\\n                        queue.put([nx, ny, steps + 1])\\n                        grid[nx][ny] = 1\\n        \\n        return -1\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid[0][0] == 1 || grid[grid.length - 1][grid[0].length - 1] == 1) {\\n            return -1;\\n        }\\n        \\n        int n = grid.length;\\n        int[]dx = {-1,0,1};\\n        int[]dy = {-1,0,1};\\n        \\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0, 1});\\n        grid[0][0] = 1;\\n        \\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int x = curr[0];\\n            int y = curr[1];\\n            int steps = curr[2];\\n            \\n            if (x == n - 1 && y == n - 1) {\\n                return steps;\\n            }\\n            \\n            for(int i = 0;i<3;i++){\\n                for(int j = 0;j<3;j++){\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[j];\\n                    if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 0) {\\n                    queue.offer(new int[]{nx, ny, steps + 1});\\n                    grid[nx][ny] = 1;\\n                }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(std::vector<std::vector<int>>& grid) {\\n        if (grid[0][0] == 1 || grid[grid.size() - 1][grid[0].size() - 1] == 1) {\\n            return -1;\\n        }\\n        \\n        int n = grid.size();\\n        std::vector<int> dx = {-1, 0, 1};\\n        std::vector<int> dy = {-1, 0, 1};\\n        \\n        std::queue<std::vector<int>> queue;\\n        queue.push({0, 0, 1});\\n        grid[0][0] = 1;\\n        \\n        while (!queue.empty()) {\\n            std::vector<int> curr = queue.front();\\n            queue.pop();\\n            int x = curr[0];\\n            int y = curr[1];\\n            int steps = curr[2];\\n            \\n            if (x == n - 1 && y == n - 1) {\\n                return steps;\\n            }\\n            \\n            for (int i = 0; i < 3; i++) {\\n                for (int j = 0; j < 3; j++) {\\n                    int nx = x + dx[i];\\n                    int ny = y + dy[j];\\n                    if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 0) {\\n                        queue.push({nx, ny, steps + 1});\\n                        grid[nx][ny] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\n```\\nfrom typing import List\\nfrom queue import Queue\\n\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] == 1 or grid[-1][-1] == 1:\\n            return -1\\n        \\n        n = len(grid)\\n        dx = [-1, 0, 1]\\n        dy = [-1, 0, 1]\\n        \\n        queue = Queue()\\n        queue.put([0, 0, 1])\\n        grid[0][0] = 1\\n        \\n        while not queue.empty():\\n            x, y, steps = queue.get()\\n            \\n            if x == n - 1 and y == n - 1:\\n                return steps\\n            \\n            for i in range(3):\\n                for j in range(3):\\n                    nx = x + dx[i]\\n                    ny = y + dy[j]\\n                    \\n                    if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 0:\\n                        queue.put([nx, ny, steps + 1])\\n                        grid[nx][ny] = 1\\n        \\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734015,
                "title": "bfs-tle-resolved",
                "content": "For those people getting TLE while applying bfs solution, your solution might be similar to:\\n(Language may differ but logic might be same i.e removing from queue and then marking it visited)\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        row=grid.length; \\n        col=grid[0].length;\\n\\t\\t\\n        if(grid[0][0]==1 || grid[row-1][col-1]==1) return -1;\\n        \\n\\t\\tint[] dirx={0,1,1,1,0,-1,-1,-1};\\n        int[] diry={-1,-1,0,1,1,1,0,-1};\\n        \\n\\t\\tQueue<Pair> q=new ArrayDeque<>();\\n        \\n\\t\\tif(row-1==0 && col-1==0) return 1;\\n        \\n\\t\\tboolean[][] visited=new boolean[row][col];\\n        \\n        q.add(new Pair(0,0,1));\\n        while(q.size()!=0){\\n            Pair p=q.remove();\\n            int cx=p.x;\\n            int cy=p.y;\\n            visited[cx][cy]=true;\\n            int dist=p.dist;\\n            for(int i=0;i<8;i++){\\n                int x=cx+dirx[i];\\n                int y=cy+diry[i];\\n                if(isValid(x,y) && grid[x][y]!=1 && !visited[x][y]){\\n                    if(x==grid.length-1 && y==grid[0].length-1) return dist+1;\\n                    q.add(new Pair(x,y,dist+1));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    public class Pair{\\n        int x;\\n        int y;\\n        int dist;\\n        Pair(int i,int j,int dist){\\n            x=i;\\n            y=j;\\n            this.dist=dist;\\n        }\\n    }\\n    int row;\\n    int col;\\n    public boolean isValid(int x,int y){\\n        if(x>=row || x<0 || y>=col || y<0) return false;\\n        return true;\\n    }\\n}\\n```\\nso now consider the following part of some large test case:\\n0 0 0\\n0 0 0\\n0 0 0\\nand suppose your visited array for this part to be:\\nT F F\\nF F F\\nF F F\\n\\nLet\\'s suppose you are at the middle element and you removed that element from queue and add all its unvisited neighbouring elements(in the order: N, N-E, E, S, S-E ,W ,N-W ). So for next iteration it will be the turn for mid element in top row (let say element x) , you remove it from queue and add its neighbour.\\n\\nImportant: Note that its left and right element although you have visited them in previous iteration but they are still in the queue and are unvisited in the visited array. Now while adding the neighbouring elements of element x you will again add its left and right element which is a repetetive task.\\n\\nIn large testcases this repetion will result in TLE.\\n\\nTo avoid this repetetion its better to first mark the element as visited and then adding it to the queue as follows:\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        row=grid.length;\\n        col=grid[0].length;\\n        \\n        if(grid[0][0]==1 || grid[row-1][col-1]==1) return -1;\\n        \\n        int[] dirx={0,1,1,1,0,-1,-1,-1};\\n        int[] diry={-1,-1,0,1,1,1,0,-1};\\n        \\n        Queue<Pair> q=new ArrayDeque<>();\\n        \\n        boolean[][] visited=new boolean[row][col];\\n        visited[0][0]=true;\\n        q.add(new Pair(0,0,1));\\n        while(q.size()!=0){\\n            Pair p=q.remove();\\n            int cx=p.x;\\n            int cy=p.y;\\n            if(cx==grid.length-1 && cy==grid[0].length-1) return p.dist;\\n            // visited[cx][cy]=true;    \\n            int dist=p.dist;\\n            for(int i=0;i<8;i++){\\n                int x=cx+dirx[i];\\n                int y=cy+diry[i];\\n                if(isValid(x,y) && grid[x][y]!=1 && !visited[x][y]){\\n                    \\n                    q.add(new Pair(x,y,dist+1));\\n                    visited[x][y]=true;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public class Pair{\\n        int x;\\n        int y;\\n        int dist;\\n        Pair(int i,int j,int dist){\\n            x=i;\\n            y=j;\\n            this.dist=dist;\\n        }\\n    }\\n    \\n    int row;\\n    int col;\\n    \\n    public boolean isValid(int x,int y){\\n        if(x>=row || x<0 || y>=col || y<0) return false;\\n        return true;\\n    }\\n}\\n```\\nHope it helps. If some corrections are required then you can share it comments. Thank You!",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        row=grid.length; \\n        col=grid[0].length;\\n\\t\\t\\n        if(grid[0][0]==1 || grid[row-1][col-1]==1) return -1;\\n        \\n\\t\\tint[] dirx={0,1,1,1,0,-1,-1,-1};\\n        int[] diry={-1,-1,0,1,1,1,0,-1};\\n        \\n\\t\\tQueue<Pair> q=new ArrayDeque<>();\\n        \\n\\t\\tif(row-1==0 && col-1==0) return 1;\\n        \\n\\t\\tboolean[][] visited=new boolean[row][col];\\n        \\n        q.add(new Pair(0,0,1));\\n        while(q.size()!=0){\\n            Pair p=q.remove();\\n            int cx=p.x;\\n            int cy=p.y;\\n            visited[cx][cy]=true;\\n            int dist=p.dist;\\n            for(int i=0;i<8;i++){\\n                int x=cx+dirx[i];\\n                int y=cy+diry[i];\\n                if(isValid(x,y) && grid[x][y]!=1 && !visited[x][y]){\\n                    if(x==grid.length-1 && y==grid[0].length-1) return dist+1;\\n                    q.add(new Pair(x,y,dist+1));\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    public class Pair{\\n        int x;\\n        int y;\\n        int dist;\\n        Pair(int i,int j,int dist){\\n            x=i;\\n            y=j;\\n            this.dist=dist;\\n        }\\n    }\\n    int row;\\n    int col;\\n    public boolean isValid(int x,int y){\\n        if(x>=row || x<0 || y>=col || y<0) return false;\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        row=grid.length;\\n        col=grid[0].length;\\n        \\n        if(grid[0][0]==1 || grid[row-1][col-1]==1) return -1;\\n        \\n        int[] dirx={0,1,1,1,0,-1,-1,-1};\\n        int[] diry={-1,-1,0,1,1,1,0,-1};\\n        \\n        Queue<Pair> q=new ArrayDeque<>();\\n        \\n        boolean[][] visited=new boolean[row][col];\\n        visited[0][0]=true;\\n        q.add(new Pair(0,0,1));\\n        while(q.size()!=0){\\n            Pair p=q.remove();\\n            int cx=p.x;\\n            int cy=p.y;\\n            if(cx==grid.length-1 && cy==grid[0].length-1) return p.dist;\\n            // visited[cx][cy]=true;    \\n            int dist=p.dist;\\n            for(int i=0;i<8;i++){\\n                int x=cx+dirx[i];\\n                int y=cy+diry[i];\\n                if(isValid(x,y) && grid[x][y]!=1 && !visited[x][y]){\\n                    \\n                    q.add(new Pair(x,y,dist+1));\\n                    visited[x][y]=true;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    public class Pair{\\n        int x;\\n        int y;\\n        int dist;\\n        Pair(int i,int j,int dist){\\n            x=i;\\n            y=j;\\n            this.dist=dist;\\n        }\\n    }\\n    \\n    int row;\\n    int col;\\n    \\n    public boolean isValid(int x,int y){\\n        if(x>=row || x<0 || y>=col || y<0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586015,
                "title": "video-explanation-from-basic-bfs-to-problem-simulation-step-by-step-java",
                "content": "# Approach\\nhttps://youtu.be/63z07AcXYhY\\n\\n# Similar Problems:\\nI recommend comparing these problems:\\n- [1102. Path With Maximum Minimum Value](https://leetcode.com/problems/path-with-maximum-minimum-value/)\\n- [1631. Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/description/)\\n- [1293. Shortest Path in a Grid with Obstacles Elimination](https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/description/)\\n- [1368. Minimum Cost to Make at Least One Valid Path in a Grid](https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/description/)\\n- [2093. Minimum Cost to Reach City With Discounts](https://leetcode.com/problems/minimum-cost-to-reach-city-with-discounts/)\\n- [2247. Maximum Cost of Trip With K Highways](https://leetcode.com/problems/maximum-cost-of-trip-with-k-highways/)\\n\\nTheses are the most basic problems for Dijkstra\\'s. We should return to these problems whenever we forget or question why Dijkstra\\'s works.\\n- [787. Cheapest Flights Within K Stops\\n](https://leetcode.com/problems/cheapest-flights-within-k-stops/)\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\nEach cell was guaranteed to be enqueued at most once. This is because a condition for a cell to be enqueued was that it had a zero in the grid, and when enqueuing, we also permanently changed the cell\\'s grid value to be non-zero.\\nThe outer loop ran as long as there were still cells in the queue, dequeuing one each time. Therefore, it ran at most $$N$$ times, giving a time complexity of $$O(N)$$.\\nThe inner loop iterated over the unvisited neighbors of the cell that was dequeued by the outer loop. There were at most $$8$$ neighbors. Identifying the unvisited neighbors is an $$O(1)$$ operation because we treat the $$8$$ as a constant.\\nTherefore, we have a time complexity of $$O(N)$$.\\n\\n- Space complexity: $$O(N)$$\\nThe only additional space we used was the queue. We determined above that at most, we enqueued NNN cells. Therefore, an upper bound on the worst-case space complexity is $$O(N)$$.\\nGiven that BFS will have nodes of at most two unique distances on the queue at any one time, it would be reasonable to wonder if the worst-case space complexity is actually lower. But actually, it turns out that there are cases with massive grids where the number of cells at a single distance is proportional to $$N$$. So even with cells of a single distance on the queue, in the worst case, the space needed is $$O(N)$$.\\n\\n# Breadth-first Search (Overwriting the Input)\\n``` Java []\\nclass Solution {\\n    int ROW, COL;\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        ROW = grid.length;\\n        COL = grid[0].length;\\n        \\n        if (grid[0][0] != 0 || grid[ROW - 1][COL - 1] != 0) {\\n            return -1;\\n        }\\n\\n        Queue<int[]> q = new ArrayDeque<>();\\n        int[][] dirs = new int[][]{{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1}};\\n        q.offer(new int[]{0, 0});\\n        grid[0][0] = 1;\\n        while(!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int row = cur[0];\\n            int col = cur[1];\\n            int distance = grid[row][col];\\n            if(row == ROW-1 && col == COL-1) {\\n                return distance;\\n            }\\n            for(int[] dir : dirs) {\\n                int newRow = row + dir[0];\\n                int newCol = col + dir[1];\\n                if(isBound(newRow, newCol) && grid[newRow][newCol] == 0) {\\n                    q.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = distance + 1;\\n                }\\n            }\\n        }\\n        // destination unreachable\\n        return -1;\\n    }\\n\\n    boolean isBound(int row, int col) {\\n        return row>=0 && row<ROW && col>=0 && col<COL;\\n    }\\n}\\n```\\n\\n# Breadth-first Search (Without Overwriting the Input)\\n\\n``` Java []\\nclass Solution {\\n    int ROW, COL;\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        ROW = grid.length;\\n        COL = grid[0].length;\\n\\n        boolean[][] visited = new boolean[ROW][COL];\\n        \\n        if (grid[0][0] != 0 || grid[ROW - 1][COL - 1] != 0) {\\n            return -1;\\n        }\\n\\n        Queue<int[]> q = new ArrayDeque<>();\\n        int[][] dirs = new int[][]{{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1}};\\n        q.offer(new int[]{0, 0, 1});\\n        visited[0][0] = true;\\n        // grid[0][0] = 1;\\n        while(!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int row = cur[0];\\n            int col = cur[1];\\n            // int distance = grid[row][col];\\n            int distance = cur[2];\\n            if(row == ROW-1 && col == COL-1) {\\n                return distance;\\n            }\\n            for(int[] dir : dirs) {\\n                int newRow = row + dir[0];\\n                int newCol = col + dir[1];\\n                if(isBound(newRow, newCol) && !visited[newRow][newCol] && grid[newRow][newCol] == 0) {\\n                    q.offer(new int[]{newRow, newCol, distance + 1});\\n                    // grid[newRow][newCol] = distance + 1;            \\n                    visited[newRow][newCol] = true;\\n                }\\n            }\\n        }\\n        // destination unreachable\\n        return -1;\\n    }\\n\\n    boolean isBound(int row, int col) {\\n        return row>=0 && row<ROW && col>=0 && col<COL;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "``` Java []\\nclass Solution {\\n    int ROW, COL;\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        ROW = grid.length;\\n        COL = grid[0].length;\\n        \\n        if (grid[0][0] != 0 || grid[ROW - 1][COL - 1] != 0) {\\n            return -1;\\n        }\\n\\n        Queue<int[]> q = new ArrayDeque<>();\\n        int[][] dirs = new int[][]{{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1}};\\n        q.offer(new int[]{0, 0});\\n        grid[0][0] = 1;\\n        while(!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int row = cur[0];\\n            int col = cur[1];\\n            int distance = grid[row][col];\\n            if(row == ROW-1 && col == COL-1) {\\n                return distance;\\n            }\\n            for(int[] dir : dirs) {\\n                int newRow = row + dir[0];\\n                int newCol = col + dir[1];\\n                if(isBound(newRow, newCol) && grid[newRow][newCol] == 0) {\\n                    q.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = distance + 1;\\n                }\\n            }\\n        }\\n        // destination unreachable\\n        return -1;\\n    }\\n\\n    boolean isBound(int row, int col) {\\n        return row>=0 && row<ROW && col>=0 && col<COL;\\n    }\\n}\\n```\n``` Java []\\nclass Solution {\\n    int ROW, COL;\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        ROW = grid.length;\\n        COL = grid[0].length;\\n\\n        boolean[][] visited = new boolean[ROW][COL];\\n        \\n        if (grid[0][0] != 0 || grid[ROW - 1][COL - 1] != 0) {\\n            return -1;\\n        }\\n\\n        Queue<int[]> q = new ArrayDeque<>();\\n        int[][] dirs = new int[][]{{1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1}};\\n        q.offer(new int[]{0, 0, 1});\\n        visited[0][0] = true;\\n        // grid[0][0] = 1;\\n        while(!q.isEmpty()) {\\n            int[] cur = q.poll();\\n            int row = cur[0];\\n            int col = cur[1];\\n            // int distance = grid[row][col];\\n            int distance = cur[2];\\n            if(row == ROW-1 && col == COL-1) {\\n                return distance;\\n            }\\n            for(int[] dir : dirs) {\\n                int newRow = row + dir[0];\\n                int newCol = col + dir[1];\\n                if(isBound(newRow, newCol) && !visited[newRow][newCol] && grid[newRow][newCol] == 0) {\\n                    q.offer(new int[]{newRow, newCol, distance + 1});\\n                    // grid[newRow][newCol] = distance + 1;            \\n                    visited[newRow][newCol] = true;\\n                }\\n            }\\n        }\\n        // destination unreachable\\n        return -1;\\n    }\\n\\n    boolean isBound(int row, int col) {\\n        return row>=0 && row<ROW && col>=0 && col<COL;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585112,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nWe need to find the shortest path starting from the top-left cell to the bottom-right cell and we can travel in 8 directions. We are using the shortest path approach called the Dijkstra\\'s Algorithm. It is a popular algorithm for finding the shortest paths in a weighted graph. It works by starting from a source node and iteratively expanding to neighboring nodes with the smallest known distances, until the shortest path to the target node is found or all reachable nodes have been visited.\\n\\n# Approach\\n\\n1) The function first checks if the starting cell (grid[0][0]) or the destination cell (grid[n-1][n-1]) is blocked (contains a value of 1). If either of them is blocked, it means there is no valid path from the start to the destination, so the function returns -1.\\n\\n\\n3) The starting cell (grid[0][0]) is marked as visited by setting its value to 1.\\n\\n4) A 2D vector neighbours is defined to represent the eight possible adjacent cells in the matrix.\\n\\n5) The while loop continues until the queue is empty. In each iteration, the front element of the queue is retrieved.\\n\\n6) The row (r), column (c), and result (distance) values are extracted from the current element.\\n\\n7) If the current cell is the destination cell (r == n-1 and c == n-1), the function returns the distance result as the shortest path length.\\n\\n8) If the current cell is not the destination, the function checks all eight possible neighbor cells using the neighbours vector.\\n\\n9) For each neighbor cell, if it is within the bounds of the matrix (row >= 0 and row < n and col >= 0 and col < n) and is unvisited (grid[row][col] == 0), it is marked as visited (grid[row][col] = 1) and added to the queue with an increased distance (result + 1).\\n\\n10) After processing all the neighbors, the loop continues until all possible cells are visited or the destination is reached.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\nUPVOTE. Glad to help.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(grid[0][0] or grid[n-1][n-1]) return -1;\\n        queue<vector<int>> queue;\\n        queue.push({0,0,1});\\n        grid[0][0]=1;\\n        vector<vector<int>> neighbours={{-1,-1},{-1,0},{-1,1},\\n        {0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n        while(!queue.empty()){\\n            auto curr=queue.front();\\n            queue.pop();\\n            int r=curr[0];\\n            int c=curr[1];\\n            int result=curr[2];\\n            if(r==n-1 and c==n-1){\\n                return result;\\n            }\\n\\n            for(int i=0;i<8;i++){\\n                int row=r+neighbours[i][0];\\n                int col=c+neighbours[i][1];\\n                if(row>=0 and row<n and col>=0 and col<n and grid[row][col]==0){\\n                    grid[row][col]=1;\\n                    queue.push({row,col,result+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(grid[0][0] or grid[n-1][n-1]) return -1;\\n        queue<vector<int>> queue;\\n        queue.push({0,0,1});\\n        grid[0][0]=1;\\n        vector<vector<int>> neighbours={{-1,-1},{-1,0},{-1,1},\\n        {0,-1},{0,1},{1,-1},{1,0},{1,1}};\\n        while(!queue.empty()){\\n            auto curr=queue.front();\\n            queue.pop();\\n            int r=curr[0];\\n            int c=curr[1];\\n            int result=curr[2];\\n            if(r==n-1 and c==n-1){\\n                return result;\\n            }\\n\\n            for(int i=0;i<8;i++){\\n                int row=r+neighbours[i][0];\\n                int col=c+neighbours[i][1];\\n                if(row>=0 and row<n and col>=0 and col<n and grid[row][col]==0){\\n                    grid[row][col]=1;\\n                    queue.push({row,col,result+1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045115,
                "title": "c-bfs-explanation-through-comments-easy-to-understand",
                "content": "**TC: O(NxN) SC: O(NxN)**\\n\\n```\\nclass Solution {\\npublic:\\n    //Use BFS \\n    \\n    bool isValid(int r, int c, int n, vector<vector<int>> &grid, vector<vector<bool>> &visited)\\n    {\\n        //check boundary condition and assure cell is not visited\\n        return (r>=0 && c>=0 && r<n && c<n && grid[r][c]==0 && !visited[r][c]);\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        int n=grid.size();\\n        queue<pair<int, int>> q; //it stores visited cells \\n        int ans=0;\\n        vector<vector<bool>> visited(n, vector<bool> (n, false)); //it stores status of  the cell\\n        int size;\\n        \\n        if(!grid[0][0]) //if starting cell value is 0, put it into the queue\\n        {\\n            q.push({0,0});\\n            visited[0][0] = true;\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            size = q.size();\\n            ans++;\\n            \\n            //iterate until we cover all stored cells in the queue \\n            for(int cnt=0; cnt<size; cnt++) \\n            {\\n                auto node = q.front(); q.pop();\\n                int i = node.first, j=node.second; //get row and column of the cell\\n                \\n                if(i==n-1 && j==n-1) return ans; //if we reach end cell return ans\\n                \\n                //cover all 8-direction adjacent cell\\n                for(int r=i-1; r<=i+1; r++)\\n                {\\n                    for(int c=j-1; c<=j+1; c++)\\n                    {\\n                        //if cell is valid means not visited \\n                        //put it into the queue and mark visited\\n                        if(isValid(r, c, n, grid, visited))\\n                        {\\n                            q.push({r,c});\\n                            visited[r][c] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //if there is no path exists return -1\\n        return -1;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Use BFS \\n    \\n    bool isValid(int r, int c, int n, vector<vector<int>> &grid, vector<vector<bool>> &visited)\\n    {\\n        //check boundary condition and assure cell is not visited\\n        return (r>=0 && c>=0 && r<n && c<n && grid[r][c]==0 && !visited[r][c]);\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        int n=grid.size();\\n        queue<pair<int, int>> q; //it stores visited cells \\n        int ans=0;\\n        vector<vector<bool>> visited(n, vector<bool> (n, false)); //it stores status of  the cell\\n        int size;\\n        \\n        if(!grid[0][0]) //if starting cell value is 0, put it into the queue\\n        {\\n            q.push({0,0});\\n            visited[0][0] = true;\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            size = q.size();\\n            ans++;\\n            \\n            //iterate until we cover all stored cells in the queue \\n            for(int cnt=0; cnt<size; cnt++) \\n            {\\n                auto node = q.front(); q.pop();\\n                int i = node.first, j=node.second; //get row and column of the cell\\n                \\n                if(i==n-1 && j==n-1) return ans; //if we reach end cell return ans\\n                \\n                //cover all 8-direction adjacent cell\\n                for(int r=i-1; r<=i+1; r++)\\n                {\\n                    for(int c=j-1; c<=j+1; c++)\\n                    {\\n                        //if cell is valid means not visited \\n                        //put it into the queue and mark visited\\n                        if(isValid(r, c, n, grid, visited))\\n                        {\\n                            q.push({r,c});\\n                            visited[r][c] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //if there is no path exists return -1\\n        return -1;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395376,
                "title": "c-bfs-each-line-clearly-explained",
                "content": "# Feel free to post your doubts in comment section\\n* Apply BFS from source node \\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size(); // dimension of grid\\n        int shortestPathLength=INT_MAX;\\n        // return -1 if either sourse or destination is 1\\n        if(grid[0][0]==1 || grid[n-1][n-1]==1) return -1;\\n        \\n        queue<vector<int>> q; // queue for BFS, it store a vector of 3 integers ( row, column, distace from source)\\n        \\n        q.push( {0,0,1} ); // push the source node in queue\\n        grid[0][0]=1; // mark the source as visited \\n        int x[]={0,0,1,-1,1,1,-1,-1};\\n        int y[]={1,-1,0,0,1,-1,1,-1};\\n        while( !q.empty() ){\\n            auto f=q.front(); //front source of queue\\n            q.pop();\\n            // check all the 8 direction adjacent nodes\\n            for( int i=0; i<8; i++ ){\\n                int r=f[0]+x[i] , c=f[1]+y[i] , distance=f[2]+1;\\n                \\n                // check if it is a valid node not visited => not having 1\\n                if( r<0 || c<0 || r>=n || c>=n || grid[r][c]==1 ) continue;\\n                \\n                // push the valid adjacent node into the queue with increased distance      \\n                q.push( {r,c,distance} );\\n                grid[r][c]=1; // mark the node as visited\\n                if(r==n-1 && c==n-1) // store the shortest distance when we reach end node\\n                    shortestPathLength =  distance;\\n            }\\n        }\\n        if( grid[n-1][n-1] != 1 ) return -1; // if we did not reach the end cell\\n        if( n==1 ) return 1; // for the test case [[0]]\\n        return shortestPathLength;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size(); // dimension of grid\\n        int shortestPathLength=INT_MAX;\\n        // return -1 if either sourse or destination is 1\\n        if(grid[0][0]==1 || grid[n-1][n-1]==1) return -1;\\n        \\n        queue<vector<int>> q; // queue for BFS, it store a vector of 3 integers ( row, column, distace from source)\\n        \\n        q.push( {0,0,1} ); // push the source node in queue\\n        grid[0][0]=1; // mark the source as visited \\n        int x[]={0,0,1,-1,1,1,-1,-1};\\n        int y[]={1,-1,0,0,1,-1,1,-1};\\n        while( !q.empty() ){\\n            auto f=q.front(); //front source of queue\\n            q.pop();\\n            // check all the 8 direction adjacent nodes\\n            for( int i=0; i<8; i++ ){\\n                int r=f[0]+x[i] , c=f[1]+y[i] , distance=f[2]+1;\\n                \\n                // check if it is a valid node not visited => not having 1\\n                if( r<0 || c<0 || r>=n || c>=n || grid[r][c]==1 ) continue;\\n                \\n                // push the valid adjacent node into the queue with increased distance      \\n                q.push( {r,c,distance} );\\n                grid[r][c]=1; // mark the node as visited\\n                if(r==n-1 && c==n-1) // store the shortest distance when we reach end node\\n                    shortestPathLength =  distance;\\n            }\\n        }\\n        if( grid[n-1][n-1] != 1 ) return -1; // if we did not reach the end cell\\n        if( n==1 ) return 1; // for the test case [[0]]\\n        return shortestPathLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063876,
                "title": "c-bfs-easy-explanation",
                "content": "**EXPLANATION**\\n- If **starting** or **ending** cell is **blocked** then return -1.\\n- Do **BFS** traversal on grid in **8** directions, using **queue**.\\n- At each iteration, **add 1** to next **unblocked** cell, **```grid[nrow][ncol] = grid[row][col] + 1```**.\\n- If at any point **```row=n-1```** and **```col=n-1```**, that is destination is reached, then return the value of **```grid[n-1][n-1]```**.\\n\\n**CODE IMPLEMENTATION**\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n\\n        // if starting or ending cell is blocked then return -1\\n        if (grid[0][0] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n\\n        queue<pair<int, int>> q;\\n        q.push(make_pair(0,0)); // insert the starting cell\\n        vector<vector<int>> directions = {{1,1}, {0,1},{1,0},{0,-1},{-1,0},{-1, -1},{1, -1},{-1, 1}};\\n        grid[0][0] = 1; // initially  1 step (answer includes the starting cell)\\n\\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n\\n            // if destination already reached then return curr grid cell value\\n            if( row == n -1 && col == n -1)\\n                return grid[row][col];\\n\\n            // iterate for all 8 directions\\n            for(auto direction : directions){\\n                int nrow = row + direction[0];\\n                int ncol = col + direction[1];\\n\\n                // check for valid direction and no obstacle condition\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n && grid[nrow][ncol] == 0){\\n                    q.push(make_pair(nrow,ncol));\\n                    grid[nrow][ncol] = grid[row][col] + 1; // increase value for that cell\\n                }\\n            }\\n\\n            // remove the current row,col from queue as it has been processed completely\\n            q.pop(); \\n        }\\n\\n        // if destination not reached\\n        return -1;\\n    }\\n};\\n```\\n**TIME COMPLEXITY**\\n**O(8*n^2)=O(n^2)** [ *If all cells are \\'0\\', then worst case will happen* ]\\n\\n**SPACE COMPLEXITY**\\n**O(n)**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```grid[nrow][ncol] = grid[row][col] + 1```\n```row=n-1```\n```col=n-1```\n```grid[n-1][n-1]```\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n\\n        // if starting or ending cell is blocked then return -1\\n        if (grid[0][0] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n\\n        queue<pair<int, int>> q;\\n        q.push(make_pair(0,0)); // insert the starting cell\\n        vector<vector<int>> directions = {{1,1}, {0,1},{1,0},{0,-1},{-1,0},{-1, -1},{1, -1},{-1, 1}};\\n        grid[0][0] = 1; // initially  1 step (answer includes the starting cell)\\n\\n        while(!q.empty()){\\n            int row = q.front().first;\\n            int col = q.front().second;\\n\\n            // if destination already reached then return curr grid cell value\\n            if( row == n -1 && col == n -1)\\n                return grid[row][col];\\n\\n            // iterate for all 8 directions\\n            for(auto direction : directions){\\n                int nrow = row + direction[0];\\n                int ncol = col + direction[1];\\n\\n                // check for valid direction and no obstacle condition\\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n && grid[nrow][ncol] == 0){\\n                    q.push(make_pair(nrow,ncol));\\n                    grid[nrow][ncol] = grid[row][col] + 1; // increase value for that cell\\n                }\\n            }\\n\\n            // remove the current row,col from queue as it has been processed completely\\n            q.pop(); \\n        }\\n\\n        // if destination not reached\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373305,
                "title": "easy-peasy-bfs-python-solution",
                "content": "\\tdef shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        if grid[0][0] == 1:\\n            return -1\\n        q = [(0, 0, 1)]\\n        while len(q) > 0:\\n            x, y, d = q.pop(0)\\n            if x == rows-1 and y == cols-1:\\n                return d\\n            for a, b in ((x-1, y-1), (x+1, y+1), (x-1, y), (x+1, y), (x, y-1), (x, y+1), (x-1, y+1), (x+1, y-1)):\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] == 0:\\n                    grid[a][b] = 1\\n                    q.append((a, b, d+1))\\n         \\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\tdef shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        if grid[0][0] == 1:\\n            return -1\\n        q = [(0, 0, 1)]\\n        while len(q) > 0:\\n            x, y, d = q.pop(0)\\n            if x == rows-1 and y == cols-1:\\n                return d\\n            for a, b in ((x-1, y-1), (x+1, y+1), (x-1, y), (x+1, y), (x, y-1), (x, y+1), (x-1, y+1), (x+1, y-1)):\\n                if 0 <= a < rows and 0 <= b < cols and grid[a][b] == 0:\\n                    grid[a][b] = 1\\n                    q.append((a, b, d+1))\\n         \\n        return -1",
                "codeTag": "Python3"
            },
            {
                "id": 318906,
                "title": "a-search-algorithm-faster-than-99-85-of-python3-submissions",
                "content": "Most people use BFS algorithm, but if you need to find shortest path between just two points, then A* search shows better performance.\\n\\nFrom implementation perspective it the same code just swapping the queue with a priority queue.\\nOn each iteration you estimate minimum path to the goal by:\\n\\nf(i,j)=g(i,j)+h(i,j)\\n\\nWhere:\\ng(i,j) = shortest path length found so far from start to (i, j) \\nh(i,j) = estimation to reach goal - bottom-right cell. For cell (i, j) it is calculated simply by max(n - i - 1, n - j - 1).\\n\\nImportant for A* search is that h(i,j) does not overestimate the actual cost to get to the goal.\\n\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        def getNeighbours(i, j):\\n            positions = [[-1,-1], [-1,0], [-1,1],[0,-1], [0,1], [1, -1], [1, 0], [1, 1]]            \\n            for pos in positions:\\n                i1, j1 = i + pos[0], j + pos[1]                \\n                if i1 >= 0 and i1 < n and j1 >= 0 and j1 < n and grid[i1][j1] == 0:\\n                    yield (i1, j1)\\n                    \\n        solution = [[999999] * n for _ in range(n)]\\n        solution[0][0] = 1\\n        if grid[0][0] != 0 or grid[n-1][n-1] != 0:\\n            return -1\\n        \\n        h = []\\n        heapq.heappush(h, (1, (0, 0, 1)))\\n        while h:\\n            est, (i, j, sp) = heapq.heappop(h)            \\n            solution[i][j] = sp\\n            if i == n - 1 and j == n - 1:\\n                break\\n            for i1, j1 in getNeighbours(i, j):\\n                if solution[i1][j1] > sp + 1:\\n                    heapq.heappush(h, (sp + 1 + max(n - i1 - 1, n - j1 - 1), (i1, j1, sp + 1)))\\n                    solution[i1][j1] = solution[i][j] + 1\\n        \\n        if solution[n-1][n-1] == 999999:\\n            return -1\\n        else:\\n            return solution[n-1][n-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        def getNeighbours(i, j):\\n            positions = [[-1,-1], [-1,0], [-1,1],[0,-1], [0,1], [1, -1], [1, 0], [1, 1]]            \\n            for pos in positions:\\n                i1, j1 = i + pos[0], j + pos[1]                \\n                if i1 >= 0 and i1 < n and j1 >= 0 and j1 < n and grid[i1][j1] == 0:\\n                    yield (i1, j1)\\n                    \\n        solution = [[999999] * n for _ in range(n)]\\n        solution[0][0] = 1\\n        if grid[0][0] != 0 or grid[n-1][n-1] != 0:\\n            return -1\\n        \\n        h = []\\n        heapq.heappush(h, (1, (0, 0, 1)))\\n        while h:\\n            est, (i, j, sp) = heapq.heappop(h)            \\n            solution[i][j] = sp\\n            if i == n - 1 and j == n - 1:\\n                break\\n            for i1, j1 in getNeighbours(i, j):\\n                if solution[i1][j1] > sp + 1:\\n                    heapq.heappush(h, (sp + 1 + max(n - i1 - 1, n - j1 - 1), (i1, j1, sp + 1)))\\n                    solution[i1][j1] = solution[i][j] + 1\\n        \\n        if solution[n-1][n-1] == 999999:\\n            return -1\\n        else:\\n            return solution[n-1][n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313252,
                "title": "javascript-solution-bfs",
                "content": "This is actually the question of finding shortest path beween source and distnation in a 2D-array.\\nInstead of moving on 4 direactions, we need to move to 8 directions for this question. \\n>`C_i` and `C_i + 1` are different and share an edge or **corner**\\n\\nWe need keep traking cells that have been visited. Usually we can create a same size 2D-array to mark visited cell, for this question, however, it didn\\'t mention that we can\\'t modifiy original 2D-array, so we can just flip 0 to 1 to mark it as visited.\\n\\n```javascript\\nvar shortestPathBinaryMatrix = function(grid) {  \\n  if (grid[0][0]) return -1;\\n  \\n  const queue = [{ coord: [0, 0], dist: 1 }];\\n  const directs = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]];\\n  const N = grid.length;\\n  const isValidCoord = (x, y) => x >= 0 && x < N && y >= 0 && y < N;\\n  \\n  grid[0][0] = 1;\\n  \\n  while (queue.length) {\\n    const { coord: [x, y], dist } = queue.shift();\\n    \\n    if (x === N - 1 && y === N - 1) {\\n      return dist;\\n    }\\n    \\n    for (let [moveX, moveY] of directs) {\\n      const nextX = x + moveX;\\n      const nextY = y + moveY;\\n      \\n      if (isValidCoord(nextX, nextY) && grid[nextX][nextY] === 0) {\\n        queue.push({ coord: [nextX, nextY], dist: dist + 1 });\\n        grid[nextX][nextY] = 1;\\n      }\\n    }\\n  }\\n  \\n  return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar shortestPathBinaryMatrix = function(grid) {  \\n  if (grid[0][0]) return -1;\\n  \\n  const queue = [{ coord: [0, 0], dist: 1 }];\\n  const directs = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]];\\n  const N = grid.length;\\n  const isValidCoord = (x, y) => x >= 0 && x < N && y >= 0 && y < N;\\n  \\n  grid[0][0] = 1;\\n  \\n  while (queue.length) {\\n    const { coord: [x, y], dist } = queue.shift();\\n    \\n    if (x === N - 1 && y === N - 1) {\\n      return dist;\\n    }\\n    \\n    for (let [moveX, moveY] of directs) {\\n      const nextX = x + moveX;\\n      const nextY = y + moveY;\\n      \\n      if (isValidCoord(nextX, nextY) && grid[nextX][nextY] === 0) {\\n        queue.push({ coord: [nextX, nextY], dist: dist + 1 });\\n        grid[nextX][nextY] = 1;\\n      }\\n    }\\n  }\\n  \\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584648,
                "title": "c-breadth-first-search",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0] != 0 || grid[n-1][n-1] != 0) return -1;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        pair<int,int>dirs[8] = {{0,1},{1,0},{0,-1},{-1,0},{-1,-1},{1,1},{1,-1},{-1,1}};\\n        int dx,dy;\\n        grid[0][0] = 1;\\n        while(!q.empty()){\\n            pair<int,int> curr = q.front();\\n            q.pop();\\n            if(curr.first == n - 1 && curr.second == n-1) return grid[curr.first][curr.second];\\n            for(auto x:dirs){\\n                dx = x.first + curr.first;\\n                dy = x.second + curr.second;\\n                if(dx >= 0 && dy >= 0 && dx < n && dy < n && grid[dx][dy] == 0){\\n                    q.push({dx,dy});\\n                    grid[dx][dy]=grid[curr.first][curr.second]+1; \\n                }\\n            }\\n        }\\n        \\n       return -1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0] != 0 || grid[n-1][n-1] != 0) return -1;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        pair<int,int>dirs[8] = {{0,1},{1,0},{0,-1},{-1,0},{-1,-1},{1,1},{1,-1},{-1,1}};\\n        int dx,dy;\\n        grid[0][0] = 1;\\n        while(!q.empty()){\\n            pair<int,int> curr = q.front();\\n            q.pop();\\n            if(curr.first == n - 1 && curr.second == n-1) return grid[curr.first][curr.second];\\n            for(auto x:dirs){\\n                dx = x.first + curr.first;\\n                dy = x.second + curr.second;\\n                if(dx >= 0 && dy >= 0 && dx < n && dy < n && grid[dx][dy] == 0){\\n                    q.push({dx,dy});\\n                    grid[dx][dy]=grid[curr.first][curr.second]+1; \\n                }\\n            }\\n        }\\n        \\n       return -1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043301,
                "title": "c-bfs-nice-solution",
                "content": "Solved live on stream. link in profile\\n\\n```\\nclass Solution {\\n    bool isOutOfBounds(vector<vector<int>>& grid, int r, int c) {\\n        if(r < 0 || r >= grid.size()) return true;\\n        if(c < 0 || c >= grid[r].size()) return true;    \\n        return false;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<vector<int>> dirs = {\\n            {-1,-1},    {-1,0},     {-1,1},\\n            {0,-1},                 {0,1},\\n            {1,-1},     {1,0},      {1,1}\\n        };\\n        using pii = pair<int,int>;\\n        int ROWS = grid.size();\\n        if(ROWS == 0) return 0;\\n        int COLS = grid[0].size();\\n        queue<pii> q;\\n        if(grid[0][0] == 0) \\n            q.push({0,0});\\n        int steps = 0;\\n        while(!q.empty()) {\\n            int qSize = q.size();\\n            steps++;\\n            for(int i = 0; i < qSize; i++) {\\n                auto [r, c] = q.front();\\n                q.pop();\\n                if(r == ROWS - 1 && c == COLS - 1) return steps;\\n                for(auto& dir : dirs) {\\n                    int dr = dir[0] + r;\\n                    int dc = dir[1] + c;\\n                    if(isOutOfBounds(grid, dr, dc)) continue;\\n                    if(grid[dr][dc] == 1) continue;\\n                    grid[dr][dc] = 1;\\n                    q.push({dr,dc});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isOutOfBounds(vector<vector<int>>& grid, int r, int c) {\\n        if(r < 0 || r >= grid.size()) return true;\\n        if(c < 0 || c >= grid[r].size()) return true;    \\n        return false;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector<vector<int>> dirs = {\\n            {-1,-1},    {-1,0},     {-1,1},\\n            {0,-1},                 {0,1},\\n            {1,-1},     {1,0},      {1,1}\\n        };\\n        using pii = pair<int,int>;\\n        int ROWS = grid.size();\\n        if(ROWS == 0) return 0;\\n        int COLS = grid[0].size();\\n        queue<pii> q;\\n        if(grid[0][0] == 0) \\n            q.push({0,0});\\n        int steps = 0;\\n        while(!q.empty()) {\\n            int qSize = q.size();\\n            steps++;\\n            for(int i = 0; i < qSize; i++) {\\n                auto [r, c] = q.front();\\n                q.pop();\\n                if(r == ROWS - 1 && c == COLS - 1) return steps;\\n                for(auto& dir : dirs) {\\n                    int dr = dir[0] + r;\\n                    int dc = dir[1] + c;\\n                    if(isOutOfBounds(grid, dr, dc)) continue;\\n                    if(grid[dr][dc] == 1) continue;\\n                    grid[dr][dc] = 1;\\n                    q.push({dr,dc});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1725237,
                "title": "java-90-faster-easy-to-understand",
                "content": "```\\n//upvote if you like\\nclass Solution {\\n    public class path{\\n        int x;\\n        int y;\\n        int steps;\\n        public path(int x,int y, int steps){\\n            this.x=x;\\n            this.y=y;\\n            this.steps=steps;\\n        }\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n=grid.length;\\n        if(grid[0][0]==1 || grid[n-1][n-1]==1)\\n            return -1;\\n        \\n        int moves[][]={{0,-1},{0,1},{1,0},{-1,0},{-1,-1},{1,-1},{-1,1},{1,1}};\\n        \\n        Queue<path> q=new LinkedList<>();\\n        q.add(new path(0,0,1));\\n        while(!q.isEmpty()){\\n            path temp=q.poll();\\n            int x=temp.x;\\n            int y=temp.y;\\n            if(x==n-1 && y==n-1)\\n                return temp.steps;\\n            grid[x][y]=1;\\n            for(int i=0;i<8;i++){\\n                int new_x=x+moves[i][0];\\n                int new_y=y+moves[i][1];\\n                if(new_x>=0 && new_x<n && new_y>=0 && new_y<n && grid[new_x][new_y]==0){\\n                    q.add(new path(new_x,new_y,temp.steps+1));\\n                    grid[new_x][new_y]=1;\\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n//upvote if you like\\nclass Solution {\\n    public class path{\\n        int x;\\n        int y;\\n        int steps;\\n        public path(int x,int y, int steps){\\n            this.x=x;\\n            this.y=y;\\n            this.steps=steps;\\n        }\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n=grid.length;\\n        if(grid[0][0]==1 || grid[n-1][n-1]==1)\\n            return -1;\\n        \\n        int moves[][]={{0,-1},{0,1},{1,0},{-1,0},{-1,-1},{1,-1},{-1,1},{1,1}};\\n        \\n        Queue<path> q=new LinkedList<>();\\n        q.add(new path(0,0,1));\\n        while(!q.isEmpty()){\\n            path temp=q.poll();\\n            int x=temp.x;\\n            int y=temp.y;\\n            if(x==n-1 && y==n-1)\\n                return temp.steps;\\n            grid[x][y]=1;\\n            for(int i=0;i<8;i++){\\n                int new_x=x+moves[i][0];\\n                int new_y=y+moves[i][1];\\n                if(new_x>=0 && new_x<n && new_y>=0 && new_y<n && grid[new_x][new_y]==0){\\n                    q.add(new path(new_x,new_y,temp.steps+1));\\n                    grid[new_x][new_y]=1;\\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310526,
                "title": "best-bfs-solution",
                "content": "# Approach\\nDijkstra\\'s Algorithm\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if (n-1 == 0 && grid[0][0] == 0)\\n            return 1;\\n        if (grid[0][0] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n        vector<vector<int>> dist(n, vector<int>(n, 1e9));\\n        queue <pair<int, int>> q;\\n        q.push({0, 0});\\n        dist[0][0] = 1;\\n        int drow[] = {-1, -1, 0, +1, +1, +1, 0, -1};\\n        int dcol[] = {0, +1, +1, +1, 0, -1, -1, -1};\\n        while (!q.empty()) {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            for (int i = 0; i < 8; i++) {\\n                int nrow = row + drow[i];\\n                int ncol = col + dcol[i];\\n                if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < n && grid[nrow][ncol] == 0) {\\n                    if (dist[row][col] + 1 < dist[nrow][ncol]) {\\n                        dist[nrow][ncol] = dist[row][col] + 1;\\n                        if (nrow == n-1 && ncol == n-1)\\n                            return dist[n-1][n-1];\\n                        q.push({nrow, ncol});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if (n-1 == 0 && grid[0][0] == 0)\\n            return 1;\\n        if (grid[0][0] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n        vector<vector<int>> dist(n, vector<int>(n, 1e9));\\n        queue <pair<int, int>> q;\\n        q.push({0, 0});\\n        dist[0][0] = 1;\\n        int drow[] = {-1, -1, 0, +1, +1, +1, 0, -1};\\n        int dcol[] = {0, +1, +1, +1, 0, -1, -1, -1};\\n        while (!q.empty()) {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            for (int i = 0; i < 8; i++) {\\n                int nrow = row + drow[i];\\n                int ncol = col + dcol[i];\\n                if (nrow >= 0 && nrow < n && ncol >= 0 && ncol < n && grid[nrow][ncol] == 0) {\\n                    if (dist[row][col] + 1 < dist[nrow][ncol]) {\\n                        dist[nrow][ncol] = dist[row][col] + 1;\\n                        if (nrow == n-1 && ncol == n-1)\\n                            return dist[n-1][n-1];\\n                        q.push({nrow, ncol});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044798,
                "title": "best-c-solution-single-traversal-east-bfs",
                "content": "**Best BFS Solution :**\\n\\n**T.C -> O(n)      // n = number of paths \\nS.C -> O(n)     // queue** \\n```\\n// Point is responsible to tell you the cnt value at every individual x,y cordinate \\nstruct Point{\\n    int x ;    // x cordinate \\n    int y ;    // y cordinate\\n    int cnt ;  // cnt is the number of cells included in the path at every cordinate x and y \\n};\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        // Since we can move in 8 directions\\n        int dx[8] = {1,1,1,-1,-1,-1,0,0};\\n        int dy[8] = {1,0,-1,1,-1,0,1,-1};\\n        \\n        // Base case : Starting cell is blocked we can\\'t move forward \\n        if( grid[0][0] == 1 ) return -1 ;\\n        \\n        int rows = grid.size() ;\\n        int columns = grid[0].size() ;\\n        \\n        queue<Point> q ;  \\n        q.push({0,0,1}) ;   // We are staring from (0,0) cordinate and the cnt value is 1 \\n        grid[0][0] = -1 ;    // Mark the visited cell as -1 \\n        \\n        while( !q.empty() ){\\n            \\n            Point p = q.front() ;  // BFS Traversal \\n            q.pop() ;\\n            \\n            if( p.x == rows-1 && p.y == columns-1 )  // if we have reached the last right corner \\n                return p.cnt ;\\n            \\n            // Traverse in all 8 directions \\n            for( int i=0 ; i<8 ; i++ ){\\n                \\n                int x = p.x + dx[i] ;     // Iterate in every direction in one by one\\n                int y = p.y + dy[i] ;\\n                \\n                // Always check the boundary limits \\n                if( x>=0 && y>=0 && x<rows && y<columns && grid[x][y]==0 ){\\n                    q.push({ x, y, p.cnt+1 });     // Since you are able to visit the next cell add it into ur path i.e cnt+1 \\n                    grid[x][y] = -1 ;      // Mark this cell as visited \\n                }\\n            }\\n        }  \\n\\t\\t// if we are not able to access any path \\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n// Point is responsible to tell you the cnt value at every individual x,y cordinate \\nstruct Point{\\n    int x ;    // x cordinate \\n    int y ;    // y cordinate\\n    int cnt ;  // cnt is the number of cells included in the path at every cordinate x and y \\n};\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        // Since we can move in 8 directions\\n        int dx[8] = {1,1,1,-1,-1,-1,0,0};\\n        int dy[8] = {1,0,-1,1,-1,0,1,-1};\\n        \\n        // Base case : Starting cell is blocked we can\\'t move forward \\n        if( grid[0][0] == 1 ) return -1 ;\\n        \\n        int rows = grid.size() ;\\n        int columns = grid[0].size() ;\\n        \\n        queue<Point> q ;  \\n        q.push({0,0,1}) ;   // We are staring from (0,0) cordinate and the cnt value is 1 \\n        grid[0][0] = -1 ;    // Mark the visited cell as -1 \\n        \\n        while( !q.empty() ){\\n            \\n            Point p = q.front() ;  // BFS Traversal \\n            q.pop() ;\\n            \\n            if( p.x == rows-1 && p.y == columns-1 )  // if we have reached the last right corner \\n                return p.cnt ;\\n            \\n            // Traverse in all 8 directions \\n            for( int i=0 ; i<8 ; i++ ){\\n                \\n                int x = p.x + dx[i] ;     // Iterate in every direction in one by one\\n                int y = p.y + dy[i] ;\\n                \\n                // Always check the boundary limits \\n                if( x>=0 && y>=0 && x<rows && y<columns && grid[x][y]==0 ){\\n                    q.push({ x, y, p.cnt+1 });     // Since you are able to visit the next cell add it into ur path i.e cnt+1 \\n                    grid[x][y] = -1 ;      // Mark this cell as visited \\n                }\\n            }\\n        }  \\n\\t\\t// if we are not able to access any path \\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043549,
                "title": "two-cpp-solution-bfs",
                "content": "**SOLUTION 1**\\n**Time**: O(mn)O(mn)\\n**Space**: O(mn)O(mn)\\n\\n```\\nclass Solution {\\n public:\\n  int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n    const int n = grid.size();\\n    if (grid[0][0] == 0 && n == 1)\\n      return 1;\\n    if (grid[0][0] == 1 || grid.back().back() == 1)\\n      return -1;\\n\\n    const vector<pair<int, int>> dirs{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},\\n                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};\\n\\n    int ans = 0;\\n    queue<pair<int, int>> q{{{0, 0}}};\\n    vector<vector<bool>> seen(n, vector<bool>(n));\\n    seen[0][0] = true;\\n\\n    while (!q.empty()) {\\n      ++ans;\\n      for (int sz = q.size(); sz > 0; --sz) {\\n        const auto [i, j] = q.front();\\n        q.pop();\\n        for (const auto [dx, dy] : dirs) {\\n          const int x = i + dx;\\n          const int y = j + dy;\\n          if (x < 0 || x == n || y < 0 || y == n)\\n            continue;\\n          if (grid[x][y] != 0 || seen[x][y])\\n            continue;\\n          if (x == n - 1 && y == n - 1)\\n            return ans + 1;\\n          q.emplace(x, y);\\n          seen[x][y] = true;\\n        }\\n      }\\n    }\\n\\n    return -1;\\n  }\\n};\\n\\n```\\n\\n**SOLUTION 2**\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = m - 1;\\n        std::queue<int> q;\\n        q.push(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.front();\\n            q.pop();\\n            int i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = std::max(i-1,0); a <= std::min(i+1,n); a++)\\n                for (int b = std::max(j-1,0); b <= std::min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.push(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n    const int n = grid.size();\\n    if (grid[0][0] == 0 && n == 1)\\n      return 1;\\n    if (grid[0][0] == 1 || grid.back().back() == 1)\\n      return -1;\\n\\n    const vector<pair<int, int>> dirs{{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},\\n                                      {0, 1},   {1, -1}, {1, 0},  {1, 1}};\\n\\n    int ans = 0;\\n    queue<pair<int, int>> q{{{0, 0}}};\\n    vector<vector<bool>> seen(n, vector<bool>(n));\\n    seen[0][0] = true;\\n\\n    while (!q.empty()) {\\n      ++ans;\\n      for (int sz = q.size(); sz > 0; --sz) {\\n        const auto [i, j] = q.front();\\n        q.pop();\\n        for (const auto [dx, dy] : dirs) {\\n          const int x = i + dx;\\n          const int y = j + dy;\\n          if (x < 0 || x == n || y < 0 || y == n)\\n            continue;\\n          if (grid[x][y] != 0 || seen[x][y])\\n            continue;\\n          if (x == n - 1 && y == n - 1)\\n            return ans + 1;\\n          q.emplace(x, y);\\n          seen[x][y] = true;\\n        }\\n      }\\n    }\\n\\n    return -1;\\n  }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = m - 1;\\n        std::queue<int> q;\\n        q.push(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.front();\\n            q.pop();\\n            int i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = std::max(i-1,0); a <= std::min(i+1,n); a++)\\n                for (int b = std::max(j-1,0); b <= std::min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.push(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876564,
                "title": "beat-all-bfs-and-100-clean-code-with-explanation-a-search",
                "content": "If we use BFS, we also can get the answer. But **A * search is far more efficient than BFS in this task** \\nbecause it **searches by priority**, not all nodes of level by level (expanding search space) like BFS. \\nI wrote the most understandable code for everyone and make some explanation in simple words.\\n\\n[A* search](https://en.wikipedia.org/wiki/A*_search_algorithm) is the combination of best-first search and Dijkstra\\'s algorithm.\\nIn my words, it searches by an **evaluation function E(i, j)** consisting of **cost function C(i, j)** and **distance function D(i, j)**\\n```\\nE(i, j) = C(i, j) + D(i, j)\\nC(i, j) : the minimal cost of the current (i, j) # in this task, cost is step\\nD(i, j) : the shortest distance of the current (i, j) to the end\\n```\\nWe use evaluation function to search the priority node first.\\n\\nThere are some tricks I applied.\\n\\n**First, about C(i, j),** \\nwe need to update the minimal cost of the each visited (i, j), \\nbut we don\\'t need to create a new DP table or something. \\nWe can just ***store negative number of cost in the same grid***. It can save some memory and code.\\n\\n**Second, about D(i, j),** \\nwe need to calculate the shortest distance of the current (i, j) to the end. \\nAs the diagonal move is accepted and \\nwe can just **search from the end (n, n),  the shortest distance to the new end (0, 0) becomes max(i, j)**, \\nso we almost don\\'t need calculate anything about distance.\\n\\nCode with clear comments step by step as below\\n```\\nclass Solution: # A* search, best 376 ms\\n    def shortestPathBinaryMatrix(self, grid):\\n        n = len(grid)-1\\n        if grid[0][0] or grid[n][n]: return -1\\n\\t\\t# use iterator to create 8 directions\\n        directions = [x for x in product((-1, 0, 1), repeat=2) if x != (0,0)]\\n\\t\\t\\n        q = [(n + 1, 1, n, n)] # put (evaluation, step, i, j) into q\\n        grid[n][n] = -1 # the step of the start is 1 \\n\\n        while q:\\n            _, step, i, j = heappop(q)\\n            # arrive the end, return minimal step\\n            if (i, j) == (0, 0): return step          \\n\\t\\t\\t\\n            for di, dj in directions:\\n                newI, newJ = i+di, j+dj\\n                # Except grid[i][j] = 1, we need to search and update  \\n                if 0 <= newI <= n and 0 <= newJ <= n and grid[newI][newJ] < 1:\\n                    newStep = step + 1\\n                    # if we have new visit or can have fewer steps, update\\n                    if grid[newI][newJ] == 0 or grid[newI][newJ] < -newStep:\\n                        grid[newI][newJ] = -newStep # store new minimal step\\n                        evaluation = max(newI, newJ) + newStep\\n                        heappush(q, (evaluation, newStep, newI, newJ))\\n        return -1\\n```\\nIn conclusion,\\nwe almost do the same thing(code) as BFS,\\nbut we just add priority into queue and far improve the performance.\\n\\nWelcome suggestion, question, comments.\\nIf you think this post is helpful, ***please upvote. Thanks a lot.***",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nE(i, j) = C(i, j) + D(i, j)\\nC(i, j) : the minimal cost of the current (i, j) # in this task, cost is step\\nD(i, j) : the shortest distance of the current (i, j) to the end\\n```\n```\\nclass Solution: # A* search, best 376 ms\\n    def shortestPathBinaryMatrix(self, grid):\\n        n = len(grid)-1\\n        if grid[0][0] or grid[n][n]: return -1\\n\\t\\t# use iterator to create 8 directions\\n        directions = [x for x in product((-1, 0, 1), repeat=2) if x != (0,0)]\\n\\t\\t\\n        q = [(n + 1, 1, n, n)] # put (evaluation, step, i, j) into q\\n        grid[n][n] = -1 # the step of the start is 1 \\n\\n        while q:\\n            _, step, i, j = heappop(q)\\n            # arrive the end, return minimal step\\n            if (i, j) == (0, 0): return step          \\n\\t\\t\\t\\n            for di, dj in directions:\\n                newI, newJ = i+di, j+dj\\n                # Except grid[i][j] = 1, we need to search and update  \\n                if 0 <= newI <= n and 0 <= newJ <= n and grid[newI][newJ] < 1:\\n                    newStep = step + 1\\n                    # if we have new visit or can have fewer steps, update\\n                    if grid[newI][newJ] == 0 or grid[newI][newJ] < -newStep:\\n                        grid[newI][newJ] = -newStep # store new minimal step\\n                        evaluation = max(newI, newJ) + newStep\\n                        heappush(q, (evaluation, newStep, newI, newJ))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489336,
                "title": "javascript-bfs",
                "content": "```js\\nfunction shortestPathBinaryMatrix(grid) {\\n  if (grid[0][0] === 1) {\\n    return -1;\\n  }\\n  let dirs = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]];\\n  let q = [[0, 0, 1]];\\n  while (q.length) {\\n    let [i, j, length] = q.shift();\\n    if (i === grid.length - 1 && j === grid[0].length - 1) {\\n      return length;\\n    }\\n    for (let [iDiff, jDiff] of dirs) {\\n      let newI = i + iDiff;\\n      let newJ = j + jDiff;\\n      if (newI >= 0 && newJ >= 0 && newI < grid.length && newJ < grid[0].length && !grid[newI][newJ]) {\\n        q.push([newI, newJ, length + 1]);\\n        grid[newI][newJ] = 1;\\n      }\\n    }\\n  }\\n  return -1;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```js\\nfunction shortestPathBinaryMatrix(grid) {\\n  if (grid[0][0] === 1) {\\n    return -1;\\n  }\\n  let dirs = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]];\\n  let q = [[0, 0, 1]];\\n  while (q.length) {\\n    let [i, j, length] = q.shift();\\n    if (i === grid.length - 1 && j === grid[0].length - 1) {\\n      return length;\\n    }\\n    for (let [iDiff, jDiff] of dirs) {\\n      let newI = i + iDiff;\\n      let newJ = j + jDiff;\\n      if (newI >= 0 && newJ >= 0 && newI < grid.length && newJ < grid[0].length && !grid[newI][newJ]) {\\n        q.push([newI, newJ, length + 1]);\\n        grid[newI][newJ] = 1;\\n      }\\n    }\\n  }\\n  return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586842,
                "title": "easy-c-solution-using-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nImagine you are in a maze and want to find the shortest path from the entrance to the exit. You can move in eight possible directions: up, down, left, right, and diagonals.\\n\\nTo solve the maze, you explore neighboring areas one by one, marking visited areas and moving forward. If you reach the exit, you have found the shortest path.\\n\\nIn this process, you use a queue to keep track of areas to explore. You continuously move through the maze, marking visited areas and enqueuing unvisited neighbors for exploration.\\n\\nIf you cannot reach the exit or the maze is blocked at the entrance, there is no valid path.\\n\\nThe code implements this maze-solving strategy using a binary matrix and the BFS algorithm to find the shortest path from the entrance to the exit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code aims to find the shortest path in a maze represented by a binary matrix. It starts from the top-left cell and tries to reach the bottom-right cell, considering eight possible directions of movement. The approach used is a breadth-first search (BFS) algorithm.\\n\\n\\n1. Initialize necessary variables: dimensions of the matrix, current distance from the source, and directions of movement.\\n\\n2. Start BFS from the top-left cell.\\n\\n3. If the starting cell is blocked, there is no valid path.\\n\\n4. Perform BFS until all possible paths are explored:\\n- Explore each cell\\'s neighbors in all eight directions.\\n- Keep track of the distance traveled.\\n- If the target cell is reached, return the distance as the shortest path.\\n- Mark visited cells and enqueue unvisited neighbors for exploration.\\n5. If the target cell is not reached, there is no valid path from the source to the target.\\n\\n# Complexity\\n- Time complexity:O(n * m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n * m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int level = 0;\\n        int dx[]={0,0,1,1,1,-1,-1,-1};\\n        int dy[]={1,-1,0,1,-1,0,1,-1};\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        if(grid[0][0]==1)\\n        {\\n            return -1;\\n        }\\n\\n        while(!q.empty())\\n        {\\n            int l = q.size();\\n            level++;\\n            for(int i = 0; i<l; i++)\\n            {\\n                int x = q.front().first;\\n                int y = q.front().second;\\n\\n                if(x==n-1 && y == m-1)\\n                {\\n                    return level;\\n                }\\n                q.pop();\\n\\n                for(int i = 0; i<8; i++)\\n                {\\n                    int newrow = x+dx[i];\\n                    int newcol = y+dy[i];\\n\\n                    if(newrow>=0 && newrow<n && newcol>=0 && newcol<m && grid[newrow][newcol]==0)\\n                    {\\n                        grid[newrow][newcol]=1;\\n                        q.push({newrow,newcol});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int level = 0;\\n        int dx[]={0,0,1,1,1,-1,-1,-1};\\n        int dy[]={1,-1,0,1,-1,0,1,-1};\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        if(grid[0][0]==1)\\n        {\\n            return -1;\\n        }\\n\\n        while(!q.empty())\\n        {\\n            int l = q.size();\\n            level++;\\n            for(int i = 0; i<l; i++)\\n            {\\n                int x = q.front().first;\\n                int y = q.front().second;\\n\\n                if(x==n-1 && y == m-1)\\n                {\\n                    return level;\\n                }\\n                q.pop();\\n\\n                for(int i = 0; i<8; i++)\\n                {\\n                    int newrow = x+dx[i];\\n                    int newcol = y+dy[i];\\n\\n                    if(newrow>=0 && newrow<n && newcol>=0 && newcol<m && grid[newrow][newcol]==0)\\n                    {\\n                        grid[newrow][newcol]=1;\\n                        q.push({newrow,newcol});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201825,
                "title": "easy-solution-without-dijkstra-only-bfs",
                "content": "# Intuition\\n    Find shortest distance from source(0,0) to all points \\n# Approach\\n Using bfs to find shortest distance from source to all points and in doing so we will find the distance from top left to bottom right corner point. \\n\\n# Complexity\\n- Time complexity:\\n   O(N*N)\\n\\n- Space complexity:\\n   O(N*N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n      if(grid[0][0]!=0) return -1;\\n      int r=grid.length,c=grid[0].length;\\n      int dist[][]=new int[r][c];\\n      for(int i=0;i<r;i++){\\n          for(int j=0;j<c;j++){\\n              dist[i][j]=(int)1e9;\\n          }\\n      }\\n      dist[0][0]=1;\\n      Queue<Trio> q=new LinkedList<>();\\n      q.add(new Trio(0,0,dist[0][0]));\\n        int dx[]={0,1,0,-1,1,-1,-1,1};\\n        int dy[]={1,0,-1,0,1,-1,1,-1};\\n      while(!q.isEmpty()){\\n          Trio temp=q.poll();\\n          int row=temp.ii;\\n          int col=temp.jj;\\n          int cdis=temp.dis;\\n        for(int i=0;i<8;i++){\\n            int nr=row+dx[i];\\n            int nc=col+dy[i];\\n\\n            if(nr>=0&&nr<r&&nc>=0&&nc<c&&grid[nr][nc]==0){\\n                if(cdis+1<dist[nr][nc]){\\n                    dist[nr][nc]=cdis+1;\\n                    q.add(new Trio(nr,nc,dist[nr][nc]));\\n                }\\n            }\\n        }\\n      }  \\n           return dist[r-1][c-1]<(int)1e9?dist[r-1][c-1]:-1; \\n    }\\n    public class Trio{\\n        int ii;\\n        int jj;\\n        int dis;\\n        public Trio(int i,int j,int dis){\\n            this.ii=i;\\n            this.jj=j;\\n            this.dis=dis;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n      if(grid[0][0]!=0) return -1;\\n      int r=grid.length,c=grid[0].length;\\n      int dist[][]=new int[r][c];\\n      for(int i=0;i<r;i++){\\n          for(int j=0;j<c;j++){\\n              dist[i][j]=(int)1e9;\\n          }\\n      }\\n      dist[0][0]=1;\\n      Queue<Trio> q=new LinkedList<>();\\n      q.add(new Trio(0,0,dist[0][0]));\\n        int dx[]={0,1,0,-1,1,-1,-1,1};\\n        int dy[]={1,0,-1,0,1,-1,1,-1};\\n      while(!q.isEmpty()){\\n          Trio temp=q.poll();\\n          int row=temp.ii;\\n          int col=temp.jj;\\n          int cdis=temp.dis;\\n        for(int i=0;i<8;i++){\\n            int nr=row+dx[i];\\n            int nc=col+dy[i];\\n\\n            if(nr>=0&&nr<r&&nc>=0&&nc<c&&grid[nr][nc]==0){\\n                if(cdis+1<dist[nr][nc]){\\n                    dist[nr][nc]=cdis+1;\\n                    q.add(new Trio(nr,nc,dist[nr][nc]));\\n                }\\n            }\\n        }\\n      }  \\n           return dist[r-1][c-1]<(int)1e9?dist[r-1][c-1]:-1; \\n    }\\n    public class Trio{\\n        int ii;\\n        int jj;\\n        int dis;\\n        public Trio(int i,int j,int dis){\\n            this.ii=i;\\n            this.jj=j;\\n            this.dis=dis;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904405,
                "title": "both-bfs-and-dfs-good-concepts-to-learn-from-dfs-beginner-friendly",
                "content": "first we will do through bfs\\nsimple bfs nothing to think for\\n\\n```\\nint shortestPathBinaryMatrix(vector<vector<int>>& a) {\\n        \\n        int n=a.size(),m=a[0].size();\\n//         int k=dfs(0,0,a);\\n//         return k<1e5 ?k:-1 ;\\n        \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        \\n        queue<pair<int,int>>q;\\n        if(a[0][0]==1) return -1;\\n        q.push({0,0});int ans=0;vis[0][0]=1;\\n        \\n        while(!q.empty())\\n        { ans++;\\n            int s=q.size();\\n           while(s--)\\n            { \\n                auto[i,j]=q.front();q.pop();\\n             \\n                if(i==n-1 && j==m-1) return ans;\\n               \\n               // a[i][j]=1;\\n               \\n                for(int k=0;k<8;k++)\\n                {  \\n                    int ni=i+x[k];\\n                    int nj=j+y[k];\\n                    \\n                    if(ni>=0 && nj>=0 && ni<n && nj<m && a[ni][nj]==0 && vis[ni][nj]==0){q.push({ni,nj});vis[ni][nj]=1;}\\n                    \\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n```\\n\\nnow we will have a look at dfs approach\\nhere we will maintain a dist array which will store its distance from origin(0,0)\\nthen we will relax it as well as its adjoining neighbours \\n```\\nvoid dfs(int u,int v,vector<vector<int>>& g,vector<vector<int>>& dist)\\n    {\\n        int n=g.size(),m=g[0].size();\\n        \\n        int d0=dist[u][v];\\n        \\n       for (int x = -1; x <= 1; x++) {\\n            for (int y = -1; y <= 1; y++) {\\n                if (x == 0 && y == 0)\\n                    continue;   \\n            \\n                int i=u+x,j=v+y;\\n                \\n                \\n                \\n            if(i>=0 && i<n && j>=0 && j<m)\\n            {  if(g[i][j]==1)continue;\\n             \\n                int d1=dist[i][j];\\n            \\n            if(d0-1>d1)//checking if it is minimum for u,v\\n            {\\n                dist[u][v]=d1+1;\\n                dfs(u,v,g,dist);\\n            }\\n                else if(d0<d1-1){//checking if it is minimum for i,j\\n                    dist[i][j]=d0+1;\\n                    dfs(i,j,g,dist);\\n                }\\n             \\n            }\\n        \\n        }\\n           \\n       }\\n       \\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        \\n        int i,j,n=g.size(),m=g[0].size();\\n        \\n        vector<vector<int>>dist(n,vector<int>(m,INT_MAX));//dist from ,i,j, to 0,0\\n        \\n        dist[0][0]=1;\\n        \\n            if(g[0][0]==1 || g[n-1][m-1]==1)\\n            {\\n                return -1;\\n            }\\n        \\n        dfs(0,0,g,dist);\\n        \\n        return dist[n-1][m-1]==INT_MAX ? -1:dist[n-1][m-1];\\n        \\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nint shortestPathBinaryMatrix(vector<vector<int>>& a) {\\n        \\n        int n=a.size(),m=a[0].size();\\n//         int k=dfs(0,0,a);\\n//         return k<1e5 ?k:-1 ;\\n        \\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        \\n        queue<pair<int,int>>q;\\n        if(a[0][0]==1) return -1;\\n        q.push({0,0});int ans=0;vis[0][0]=1;\\n        \\n        while(!q.empty())\\n        { ans++;\\n            int s=q.size();\\n           while(s--)\\n            { \\n                auto[i,j]=q.front();q.pop();\\n             \\n                if(i==n-1 && j==m-1) return ans;\\n               \\n               // a[i][j]=1;\\n               \\n                for(int k=0;k<8;k++)\\n                {  \\n                    int ni=i+x[k];\\n                    int nj=j+y[k];\\n                    \\n                    if(ni>=0 && nj>=0 && ni<n && nj<m && a[ni][nj]==0 && vis[ni][nj]==0){q.push({ni,nj});vis[ni][nj]=1;}\\n                    \\n                }\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n```\n```\\nvoid dfs(int u,int v,vector<vector<int>>& g,vector<vector<int>>& dist)\\n    {\\n        int n=g.size(),m=g[0].size();\\n        \\n        int d0=dist[u][v];\\n        \\n       for (int x = -1; x <= 1; x++) {\\n            for (int y = -1; y <= 1; y++) {\\n                if (x == 0 && y == 0)\\n                    continue;   \\n            \\n                int i=u+x,j=v+y;\\n                \\n                \\n                \\n            if(i>=0 && i<n && j>=0 && j<m)\\n            {  if(g[i][j]==1)continue;\\n             \\n                int d1=dist[i][j];\\n            \\n            if(d0-1>d1)//checking if it is minimum for u,v\\n            {\\n                dist[u][v]=d1+1;\\n                dfs(u,v,g,dist);\\n            }\\n                else if(d0<d1-1){//checking if it is minimum for i,j\\n                    dist[i][j]=d0+1;\\n                    dfs(i,j,g,dist);\\n                }\\n             \\n            }\\n        \\n        }\\n           \\n       }\\n       \\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        \\n        int i,j,n=g.size(),m=g[0].size();\\n        \\n        vector<vector<int>>dist(n,vector<int>(m,INT_MAX));//dist from ,i,j, to 0,0\\n        \\n        dist[0][0]=1;\\n        \\n            if(g[0][0]==1 || g[n-1][m-1]==1)\\n            {\\n                return -1;\\n            }\\n        \\n        dfs(0,0,g,dist);\\n        \\n        return dist[n-1][m-1]==INT_MAX ? -1:dist[n-1][m-1];\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1063746,
                "title": "java-solution-with-a-search",
                "content": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int N = grid.length;\\n        \\n        if (grid[0][0] != 0 || grid[N - 1][N - 1] != 0) {\\n            return -1;\\n        }\\n\\n        int directions[][] = {{-1,0},{1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\\n        \\n        Queue<Attempt> attempts = new PriorityQueue<>();\\n        attempts.add(new Attempt(0, 0, 1));\\n        while (!attempts.isEmpty()) {\\n           Attempt attempt = attempts.poll();\\n            \\n           if (attempt.row == N - 1 && attempt.column == N - 1) {\\n               return attempt.step;\\n           } \\n            \\n           for (int[] direction : directions) {\\n               int row = attempt.row + direction[0];\\n               int column = attempt.column + direction[1];\\n               \\n               if (row >= 0 && row < N && column >= 0 && column < N && grid[row][column] == 0) {\\n                   attempts.add(new Attempt(row, column, attempt.step + 1));\\n                   grid[row][column] = -1; \\n                }  \\n           } \\n        }\\n        \\n        return -1;\\n    }\\n    \\n    class Attempt implements Comparable<Attempt> {\\n        int row;\\n        int column;\\n        int step;\\n        \\n        public Attempt (int row, int column, int step) {\\n            this.row = row;\\n            this.column = column;\\n            this.step = step;\\n        }\\n        \\n        @Override\\n        public int compareTo(Attempt other) {\\n            if (this.step == other.step) {\\n                return other.row + other.column - this.row - this.column;\\n            }\\n            \\n            return this.step - other.step;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int N = grid.length;\\n        \\n        if (grid[0][0] != 0 || grid[N - 1][N - 1] != 0) {\\n            return -1;\\n        }\\n\\n        int directions[][] = {{-1,0},{1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\\n        \\n        Queue<Attempt> attempts = new PriorityQueue<>();\\n        attempts.add(new Attempt(0, 0, 1));\\n        while (!attempts.isEmpty()) {\\n           Attempt attempt = attempts.poll();\\n            \\n           if (attempt.row == N - 1 && attempt.column == N - 1) {\\n               return attempt.step;\\n           } \\n            \\n           for (int[] direction : directions) {\\n               int row = attempt.row + direction[0];\\n               int column = attempt.column + direction[1];\\n               \\n               if (row >= 0 && row < N && column >= 0 && column < N && grid[row][column] == 0) {\\n                   attempts.add(new Attempt(row, column, attempt.step + 1));\\n                   grid[row][column] = -1; \\n                }  \\n           } \\n        }\\n        \\n        return -1;\\n    }\\n    \\n    class Attempt implements Comparable<Attempt> {\\n        int row;\\n        int column;\\n        int step;\\n        \\n        public Attempt (int row, int column, int step) {\\n            this.row = row;\\n            this.column = column;\\n            this.step = step;\\n        }\\n        \\n        @Override\\n        public int compareTo(Attempt other) {\\n            if (this.step == other.step) {\\n                return other.row + other.column - this.row - this.column;\\n            }\\n            \\n            return this.step - other.step;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063518,
                "title": "python-solution",
                "content": "My code:\\n\\n```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] != 0:\\n            return -1\\n        n = len(grid)\\n        if n == 1:\\n            if grid[0][0] == 0:\\n                return 1\\n\\n        dq = deque()\\n        dq.append([0, 0])\\n        length = 1\\n        while dq:\\n            length += 1\\n            for _ in range(len(dq)):\\n                x, y = dq.popleft()\\n                for i in [-1, 0, 1]:\\n                    for j in [-1, 0, 1]:\\n                        if i == 0 and j == 0:\\n                            continue\\n                        if 0 <= x + i < n and 0 <= y + j < n and grid[x + i][y + j] == 0:\\n                            if x + i == n - 1 and y + j == n - 1:\\n                                return length\\n                            dq.append([x + i, y + j])\\n                            grid[x + i][y + j] = 1\\n\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\n\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if grid[0][0] != 0:\\n            return -1\\n        n = len(grid)\\n        if n == 1:\\n            if grid[0][0] == 0:\\n                return 1\\n\\n        dq = deque()\\n        dq.append([0, 0])\\n        length = 1\\n        while dq:\\n            length += 1\\n            for _ in range(len(dq)):\\n                x, y = dq.popleft()\\n                for i in [-1, 0, 1]:\\n                    for j in [-1, 0, 1]:\\n                        if i == 0 and j == 0:\\n                            continue\\n                        if 0 <= x + i < n and 0 <= y + j < n and grid[x + i][y + j] == 0:\\n                            if x + i == n - 1 and y + j == n - 1:\\n                                return length\\n                            dq.append([x + i, y + j])\\n                            grid[x + i][y + j] = 1\\n\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352787,
                "title": "easy-java-bfs-beats-cpu-95-and-mem-100",
                "content": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int N = grid.length;\\n        if (grid[0][0] != 0 || grid[N-1][N-1] != 0) {\\n            return -1;\\n        }\\n        int len = 0;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[] {0, 0});\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            len++;\\n            for (int i = 0; i < size; i++) {\\n                int[] n = q.poll();\\n                int r = n[0], c = n[1];\\n                if (r == N-1 && c == N - 1) {\\n                    return len;\\n                }\\n                for (int x = -1; x <= 1; x++) {\\n                    for (int y = -1; y <= 1; y++) {\\n                        int nr = r + x;\\n                        int nc = c + y;\\n                        if (nr >= 0 && nc >= 0 && nr < N && nc < N && grid[nr][nc] == 0) {\\n                            grid[nr][nc] = 2;\\n                            q.add(new int[] {nr, nc});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int N = grid.length;\\n        if (grid[0][0] != 0 || grid[N-1][N-1] != 0) {\\n            return -1;\\n        }\\n        int len = 0;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[] {0, 0});\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            len++;\\n            for (int i = 0; i < size; i++) {\\n                int[] n = q.poll();\\n                int r = n[0], c = n[1];\\n                if (r == N-1 && c == N - 1) {\\n                    return len;\\n                }\\n                for (int x = -1; x <= 1; x++) {\\n                    for (int y = -1; y <= 1; y++) {\\n                        int nr = r + x;\\n                        int nc = c + y;\\n                        if (nr >= 0 && nc >= 0 && nr < N && nc < N && grid[nr][nc] == 0) {\\n                            grid[nr][nc] = 2;\\n                            q.add(new int[] {nr, nc});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584090,
                "title": "shortest-path-in-binary-matrix-optimized-solution-daily-leetcode-challenge",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        // Check if the start or end cell is blocked\\n        if (grid[0][0] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n        \\n        // Create a queue for BFS\\n        queue<pair<int, int>> q;\\n        q.push({0, 0}); // Start from the top-left cell\\n        grid[0][0] = 1; // Mark the start cell as visited\\n        \\n        // 8 possible directions to move\\n        vector<int> dx = {-1, -1, -1, 0, 0, 1, 1, 1};\\n        vector<int> dy = {-1, 0, 1, -1, 1, -1, 0, 1};\\n        \\n        // Perform BFS\\n        while (!q.empty()) {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            q.pop();\\n            \\n            // Check if reached the end cell\\n            if (x == n - 1 && y == n - 1)\\n                return grid[x][y];\\n            \\n            // Explore the 8 adjacent cells\\n            for (int i = 0; i < 8; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                \\n                // Check if the next cell is within the grid boundaries\\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 0) {\\n                    q.push({nx, ny});\\n                    grid[nx][ny] = grid[x][y] + 1; // Mark the next cell as visited and update its distance\\n                }\\n            }\\n        }\\n        \\n        return -1; // No clear path found\\n    }\\n};\\n```\\n\\n**Complexity Analysis**\\nThe time complexity of this algorithm is O(n^2) because in the worst case, we may have to visit every cell in the grid. The space complexity is also O(n^2) because the queue can store at most n^2 cells in the worst case.\\n\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        // Check if the start or end cell is blocked\\n        if (grid[0][0] == 1 || grid[n-1][n-1] == 1)\\n            return -1;\\n        \\n        // Create a queue for BFS\\n        queue<pair<int, int>> q;\\n        q.push({0, 0}); // Start from the top-left cell\\n        grid[0][0] = 1; // Mark the start cell as visited\\n        \\n        // 8 possible directions to move\\n        vector<int> dx = {-1, -1, -1, 0, 0, 1, 1, 1};\\n        vector<int> dy = {-1, 0, 1, -1, 1, -1, 0, 1};\\n        \\n        // Perform BFS\\n        while (!q.empty()) {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            q.pop();\\n            \\n            // Check if reached the end cell\\n            if (x == n - 1 && y == n - 1)\\n                return grid[x][y];\\n            \\n            // Explore the 8 adjacent cells\\n            for (int i = 0; i < 8; i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                \\n                // Check if the next cell is within the grid boundaries\\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 0) {\\n                    q.push({nx, ny});\\n                    grid[nx][ny] = grid[x][y] + 1; // Mark the next cell as visited and update its distance\\n                }\\n            }\\n        }\\n        \\n        return -1; // No clear path found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064056,
                "title": "by-using-dijsktra-algorithm-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid,pair<int,int>s,pair<int,int>d){\\n        if(grid[0][0]==1) return -1;\\n        if(s.first==d.first && s.second==d.second ){\\n            return 1;\\n        }\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        \\n        dist[0][0]=1;\\n        queue<pair<int,pair<int,int>>>q;\\n        int dr[]={-1,-1,0,1,1,1,0,-1};\\n        int dc[]={0,1,1,1,0,-1,-1,-1};\\n        q.push({1,{0,0}});\\n        while(q.empty()==false){\\n            auto it=q.front();\\n            int dis=it.first;\\n            int r=it.second.first;\\n            int c=it.second.second;\\n            q.pop();\\n            for(int i=0;i<8;i++){\\n                int nr=dr[i]+r;\\n                int nc=dc[i]+c;\\n                if(nr>=0 && nc>=0 && nr<n && nc<m && grid[nr][nc]==0 && dis+1<dist[nr][nc]){\\n                    dist[nr][nc]=dis+1;\\n                    if(nr==d.first && nc==d.second){\\n                        return dis+1;\\n                    }\\n                    q.push({1+dis,{nr,nc}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        pair<int,int>s={0,0};\\n        pair<int,int>d={n-1,n-1};\\n        return f(grid,s,d);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& grid,pair<int,int>s,pair<int,int>d){\\n        if(grid[0][0]==1) return -1;\\n        if(s.first==d.first && s.second==d.second ){\\n            return 1;\\n        }\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        \\n        dist[0][0]=1;\\n        queue<pair<int,pair<int,int>>>q;\\n        int dr[]={-1,-1,0,1,1,1,0,-1};\\n        int dc[]={0,1,1,1,0,-1,-1,-1};\\n        q.push({1,{0,0}});\\n        while(q.empty()==false){\\n            auto it=q.front();\\n            int dis=it.first;\\n            int r=it.second.first;\\n            int c=it.second.second;\\n            q.pop();\\n            for(int i=0;i<8;i++){\\n                int nr=dr[i]+r;\\n                int nc=dc[i]+c;\\n                if(nr>=0 && nc>=0 && nr<n && nc<m && grid[nr][nc]==0 && dis+1<dist[nr][nc]){\\n                    dist[nr][nc]=dis+1;\\n                    if(nr==d.first && nc==d.second){\\n                        return dis+1;\\n                    }\\n                    q.push({1+dis,{nr,nc}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        pair<int,int>s={0,0};\\n        pair<int,int>d={n-1,n-1};\\n        return f(grid,s,d);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962468,
                "title": "c-bfs-and-dfs-solution-explained-and-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Start the BFs from the cell (0,0)\\n2. Check the 8 directionally adjancent cells,if there are not visited take it into the queue.\\n3. The first time we encountered the cell (n-1,n-1) is the minium distance.\\n4. IF we don\\'t encounter the cell (n-1,n-1) then there is no clear path.\\n\\n\\n#### BFs Solution\\n```\\nclass Solution {\\nprivate : \\n    typedef vector<vector<int>> vvi; \\n    int xx[8] = {0,0,-1,1,-1,-1,1,1};\\n    int yy[8] = {1,-1,0,0,-1,1,1,-1}; \\n    \\n    \\n    int shortestPathBFs(vvi &grid,int n)\\n    {\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        //distance matrix keeps track of the minimum distance from the cell (0,0) to cell(i,j)\\n        vector<vector<int>> distance(n,vector<int>(n,0));\\n        //intial distance of cell (0,0) is 1\\n        distance[0][0] = 1;\\n        while(!q.empty())\\n        {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            int dist = distance[x][y];\\n            q.pop();\\n            //checking the 8 directionally adjacent cells\\n            for(int i=0; i<8; i++)\\n            {\\n                int nx = x + xx[i],ny = y + yy[i];\\n            //IF the adjacent cell is valid,and it is zero and it is not yet visited,then take into queue.\\n                if(nx >= 0 && nx < n && ny >=0 && ny < n && !grid[nx][ny] && !distance[nx][ny])\\n                {  \\n                    /*If the last cell (n-1,n-1) is visited for the first time,then it is the minimum\\n                    distance so return the distance.*/\\n                    if(nx == n-1 && ny == n-1)\\n                      return dist+1;\\n                    /*updating the distance of current adjacent cell */\\n                    distance[nx][ny] = dist+1;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        /*Returning -1 as the cell (n-1,n-1) cannot be reached*/\\n        return -1;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0])\\n           return -1;\\n        if(n == 1) return 1;\\n        return shortestPathBFs(grid,n);\\n    }\\n};   \\n```\\n### Complexity\\nN is the no of cells in the grid.\\n- Time complexity: `O(8N)`\\nFor each cell there are 8 adjacent cells need to be checked. And the each cell is visited once or twice.\\n\\n- Space complexity: `O(N)`\\nSpace for the distance matrix and the queue.\\n\\n\\n### DFs Solution \\n**Verdict :** Time Limit Exceeded.\\n\\nTLE occurs because in DFs we explores all possible clear paths and takes the path with minimum distance. For finding the all paths, the cell needs to be visited multiple times, so it causes TLE.\\n```\\nclass Solution {\\nprivate : \\n    typedef vector<vector<int>> vvi; \\n    int xx[8] = {0,0,-1,1,-1,-1,1,1};\\n    int yy[8] = {1,-1,0,0,-1,1,1,-1}; \\n    \\n    int shortestPathDFs(int x,int y, vvi &grid,vvi &visited,int n, int cells)\\n    {\\n         if(x == n-1 && y == n-1)\\n           return cells;\\n         int minCells = INT_MAX;\\n         visited[x][y] = 1;\\n         for(int i=0; i<8; i++)\\n         {\\n             int nx = x + xx[i], ny = y + yy[i];\\n             if(nx < n && nx >= 0 && ny < n && ny >=0 && !grid[nx][ny] && !visited[nx][ny]) \\n                  minCells = min(minCells, shortestPathDFs(nx,ny,grid,visited,n,cells+1));\\n         }\\n         visited[x][y] = 0;\\n         return minCells;\\n    }\\n\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0])\\n           return -1;\\n        if(n == 1) return 1;\\n        vector<vector<int>> visited(n,vector<int>(n,0)); \\n        int ans = shortestPathDFs(0,0,grid,visited,n,1);\\n        return ans != INT_MAX ? ans : -1;\\n    }\\n};   \\n```\\nIf you feel it useful please upvote \\uD83D\\uDE0A\\uD83D\\uDE0A.\\nIn case of any queries or suggestions please let me know in the comment section.",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\nprivate : \\n    typedef vector<vector<int>> vvi; \\n    int xx[8] = {0,0,-1,1,-1,-1,1,1};\\n    int yy[8] = {1,-1,0,0,-1,1,1,-1}; \\n    \\n    \\n    int shortestPathBFs(vvi &grid,int n)\\n    {\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        //distance matrix keeps track of the minimum distance from the cell (0,0) to cell(i,j)\\n        vector<vector<int>> distance(n,vector<int>(n,0));\\n        //intial distance of cell (0,0) is 1\\n        distance[0][0] = 1;\\n        while(!q.empty())\\n        {\\n            int x = q.front().first;\\n            int y = q.front().second;\\n            int dist = distance[x][y];\\n            q.pop();\\n            //checking the 8 directionally adjacent cells\\n            for(int i=0; i<8; i++)\\n            {\\n                int nx = x + xx[i],ny = y + yy[i];\\n            //IF the adjacent cell is valid,and it is zero and it is not yet visited,then take into queue.\\n                if(nx >= 0 && nx < n && ny >=0 && ny < n && !grid[nx][ny] && !distance[nx][ny])\\n                {  \\n                    /*If the last cell (n-1,n-1) is visited for the first time,then it is the minimum\\n                    distance so return the distance.*/\\n                    if(nx == n-1 && ny == n-1)\\n                      return dist+1;\\n                    /*updating the distance of current adjacent cell */\\n                    distance[nx][ny] = dist+1;\\n                    q.push({nx,ny});\\n                }\\n            }\\n        }\\n        /*Returning -1 as the cell (n-1,n-1) cannot be reached*/\\n        return -1;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0])\\n           return -1;\\n        if(n == 1) return 1;\\n        return shortestPathBFs(grid,n);\\n    }\\n};   \\n```\n```\\nclass Solution {\\nprivate : \\n    typedef vector<vector<int>> vvi; \\n    int xx[8] = {0,0,-1,1,-1,-1,1,1};\\n    int yy[8] = {1,-1,0,0,-1,1,1,-1}; \\n    \\n    int shortestPathDFs(int x,int y, vvi &grid,vvi &visited,int n, int cells)\\n    {\\n         if(x == n-1 && y == n-1)\\n           return cells;\\n         int minCells = INT_MAX;\\n         visited[x][y] = 1;\\n         for(int i=0; i<8; i++)\\n         {\\n             int nx = x + xx[i], ny = y + yy[i];\\n             if(nx < n && nx >= 0 && ny < n && ny >=0 && !grid[nx][ny] && !visited[nx][ny]) \\n                  minCells = min(minCells, shortestPathDFs(nx,ny,grid,visited,n,cells+1));\\n         }\\n         visited[x][y] = 0;\\n         return minCells;\\n    }\\n\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(grid[0][0])\\n           return -1;\\n        if(n == 1) return 1;\\n        vector<vector<int>> visited(n,vector<int>(n,0)); \\n        int ans = shortestPathDFs(0,0,grid,visited,n,1);\\n        return ans != INT_MAX ? ans : -1;\\n    }\\n};   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679636,
                "title": "simple-bfs-c-standard-code",
                "content": "```\\nint shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(grid[0][0]!=0)return -1;\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        dist[0][0]=1;\\n        queue<pair<int,pair<int,int>>>pq;\\n        pq.push({1,{0,0}});\\n        int dx[8]={-1,-1,0,1,1,1,0,-1};\\n        int dy[8]={0,1,1,1,0,-1,-1,-1};\\n        while(!pq.empty()){\\n            auto top=pq.front();\\n            pq.pop();\\n            int currdis=top.first;\\n            int currx=top.second.first;\\n            int curry=top.second.second;\\n            if(currx==n-1 && curry==m-1)return currdis;\\n            for(int i=0;i<8;i++){\\n                int nextx=currx+dx[i];\\n                int nexty=curry+dy[i];\\n                if(nextx>=0 && nextx<n && nexty>=0 && nexty<m && grid[nextx][nexty]==0 && currdis+1<dist[nextx][nexty])                 {\\n                    //updated distance for current cell\\n                    dist[nextx][nexty]=currdis+1;\\n                    pq.push({currdis+1,{nextx,nexty}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        if(grid[0][0]!=0)return -1;\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        dist[0][0]=1;\\n        queue<pair<int,pair<int,int>>>pq;\\n        pq.push({1,{0,0}});\\n        int dx[8]={-1,-1,0,1,1,1,0,-1};\\n        int dy[8]={0,1,1,1,0,-1,-1,-1};\\n        while(!pq.empty()){\\n            auto top=pq.front();\\n            pq.pop();\\n            int currdis=top.first;\\n            int currx=top.second.first;\\n            int curry=top.second.second;\\n            if(currx==n-1 && curry==m-1)return currdis;\\n            for(int i=0;i<8;i++){\\n                int nextx=currx+dx[i];\\n                int nexty=curry+dy[i];\\n                if(nextx>=0 && nextx<n && nexty>=0 && nexty<m && grid[nextx][nexty]==0 && currdis+1<dist[nextx][nexty])                 {\\n                    //updated distance for current cell\\n                    dist[nextx][nexty]=currdis+1;\\n                    pq.push({currdis+1,{nextx,nexty}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2044591,
                "title": "no-dp",
                "content": "as we can see simply that we have to reach the last block starting from first one,which is kinda similar to dp but it is not it is bfs or dfs, we have to find minnimum steps to reach last step, and we can move in all 8 directions , Now if we think more clearly this question is pretty standard bfs just like orange rotten and other,so moving on ahead, i did same\\n```\\n\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int k[][]={{1,1},{1,0},{-1,-1},{-1,0},{0,-1},{0,1},{-1,1},{1,-1}};\\n      boolean vis[][]= new boolean[grid.length][grid[0].length];\\n        Queue<int[]>p=new LinkedList<>();\\n        if(grid[0][0]==1||grid[grid.length-1][grid[0].length-1]==1)return -1;\\n        int arr[]={0,0};\\n    vis[0][0]=true;\\n        \\n        p.add(arr);\\n       int ans=0;\\n        int l=0;\\n        while(!p.isEmpty()&&l==0){\\n            ans++;\\n            int n=p.size();\\n            for(int i=0;i<n;i++){\\n                for(int t=0;t<8;t++){\\n                    int x=p.peek()[0]+k[t][0];\\n                    int y=p.peek()[1]+k[t][1];\\n                    if(x<0||y<0||x>=grid.length||y>=grid[0].length||grid[x][y]==1||vis[x][y]==true)continue;\\n                    else{\\n                        \\n                        int z[]={x,y};\\n                        p.add(z);\\n                        vis[x][y]=true;\\n                        if(x==grid.length-1&&y==grid[0].length-1){\\n                            l=1;\\n                            ans++;\\n                            break;\\n                        }\\n                    }\\n                }\\n                p.poll();\\n            }\\n        }\\n        //ans++;\\n        if(vis[grid.length-1][grid[0].length-1]!=true)return -1;\\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int k[][]={{1,1},{1,0},{-1,-1},{-1,0},{0,-1},{0,1},{-1,1},{1,-1}};\\n      boolean vis[][]= new boolean[grid.length][grid[0].length];\\n        Queue<int[]>p=new LinkedList<>();\\n        if(grid[0][0]==1||grid[grid.length-1][grid[0].length-1]==1)return -1;\\n        int arr[]={0,0};\\n    vis[0][0]=true;\\n        \\n        p.add(arr);\\n       int ans=0;\\n        int l=0;\\n        while(!p.isEmpty()&&l==0){\\n            ans++;\\n            int n=p.size();\\n            for(int i=0;i<n;i++){\\n                for(int t=0;t<8;t++){\\n                    int x=p.peek()[0]+k[t][0];\\n                    int y=p.peek()[1]+k[t][1];\\n                    if(x<0||y<0||x>=grid.length||y>=grid[0].length||grid[x][y]==1||vis[x][y]==true)continue;\\n                    else{\\n                        \\n                        int z[]={x,y};\\n                        p.add(z);\\n                        vis[x][y]=true;\\n                        if(x==grid.length-1&&y==grid[0].length-1){\\n                            l=1;\\n                            ans++;\\n                            break;\\n                        }\\n                    }\\n                }\\n                p.poll();\\n            }\\n        }\\n        //ans++;\\n        if(vis[grid.length-1][grid[0].length-1]!=true)return -1;\\n        return ans;\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044416,
                "title": "c-easy-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        if(grid[0][0] || grid.back().back())\\n            return -1;\\n        \\n        int start = 1, ans = 2;\\n        int xMax = grid[0].size() - 1;\\n        int yMax = grid.size() - 1;\\n        \\n        if(!xMax && !yMax)\\n            return 1 - (grid[0][0] << 1);\\n        \\n        grid[0][0] = -1;\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        \\n        while(start){\\n            while(start--){\\n                \\n                auto[x, y] = q.front();\\n                q.pop();\\n                \\n                for(int i = max(x - 1, 0), currX = min(x + 1, xMax); i <= currX; i++){\\n                    \\n                    for(int j = max(y - 1, 0), currY = min(y + 1, yMax); j <= currY; j++){\\n                        \\n                        if(i == xMax && j == yMax)\\n                            return ans;\\n                        \\n                        if(!grid[j][i]){\\n                            grid[j][i] = -1;\\n                            q.push({i, j});\\n                        }\\n                    }\\n                }\\n            }\\n            ans++;\\n            start = q.size();\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        if(grid[0][0] || grid.back().back())\\n            return -1;\\n        \\n        int start = 1, ans = 2;\\n        int xMax = grid[0].size() - 1;\\n        int yMax = grid.size() - 1;\\n        \\n        if(!xMax && !yMax)\\n            return 1 - (grid[0][0] << 1);\\n        \\n        grid[0][0] = -1;\\n        \\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        \\n        while(start){\\n            while(start--){\\n                \\n                auto[x, y] = q.front();\\n                q.pop();\\n                \\n                for(int i = max(x - 1, 0), currX = min(x + 1, xMax); i <= currX; i++){\\n                    \\n                    for(int j = max(y - 1, 0), currY = min(y + 1, yMax); j <= currY; j++){\\n                        \\n                        if(i == xMax && j == yMax)\\n                            return ans;\\n                        \\n                        if(!grid[j][i]){\\n                            grid[j][i] = -1;\\n                            q.push({i, j});\\n                        }\\n                    }\\n                }\\n            }\\n            ans++;\\n            start = q.size();\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043369,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] g) {\\n        if(g[0][0]==1)\\n            return -1;\\n        int m=g.length,n=g[0].length,c=0;\\n        Queue<int[]> nm=new LinkedList<>();\\n        nm.offer(new int[] {0,0,1});\\n        int d[][]={{1,1},{-1,-1},{1,0},{-1,0},{0,1},{0,-1},{1,-1},{-1,1}};\\n        while(!(nm.isEmpty()))\\n        {\\n            int l=nm.size();\\n            while(l-->0)\\n            {\\n                int f[]=nm.poll();\\n                if(f[0]==m-1&&f[1]==n-1)\\n                    return f[2];\\n                for(int k[]: d)\\n                {\\n                    int i=f[0]+k[0];\\n                    int j=f[1]+k[1];\\n                    if(i>=0&&j>=0&&i<m&&j<n&&g[i][j]==0)\\n                    {\\n                        nm.offer(new int[] {i,j,f[2]+1});\\n                        g[i][j]=1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] g) {\\n        if(g[0][0]==1)\\n            return -1;\\n        int m=g.length,n=g[0].length,c=0;\\n        Queue<int[]> nm=new LinkedList<>();\\n        nm.offer(new int[] {0,0,1}",
                "codeTag": "Java"
            },
            {
                "id": 823446,
                "title": "javascript-bfs-solution",
                "content": "```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar shortestPathBinaryMatrix = function(grid) {\\n  const m = grid.length || 0\\n  const n = m && grid[0].length || 0\\n  \\n  if (m === 0 || n === 0 || grid[0][0] !== 0) return -1\\n\\n  let step = 1\\n  const queue = [[0, 0]]\\n  const dires = [[-1, 0], [1, 0], [0, 1], [0, -1], [-1, 1], [-1, -1], [1, 1], [1, -1]]\\n  \\n  while (queue.length) {\\n    const size = queue.length\\n    for (let i = 0; i < size; i++) {\\n      const [x, y] = queue.shift()\\n      \\n      if (x === m - 1 && y === n - 1) return step\\n      \\n      for (const [dx, dy] of dires) {\\n        const newX = x + dx, newY = y + dy\\n        if (_withinBound(newX, newY, m, n) && grid[newX][newY] === 0) {\\n          grid[newX][newY] = 1\\n          queue.push([newX, newY])\\n        }\\n      }\\n    }\\n    \\n    step += 1\\n  }\\n  \\n  return -1\\n};\\n  \\nfunction _withinBound(x, y, m, n) {\\n  return 0 <= x && 0 <= y && x < m && y < n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar shortestPathBinaryMatrix = function(grid) {\\n  const m = grid.length || 0\\n  const n = m && grid[0].length || 0\\n  \\n  if (m === 0 || n === 0 || grid[0][0] !== 0) return -1\\n\\n  let step = 1\\n  const queue = [[0, 0]]\\n  const dires = [[-1, 0], [1, 0], [0, 1], [0, -1], [-1, 1], [-1, -1], [1, 1], [1, -1]]\\n  \\n  while (queue.length) {\\n    const size = queue.length\\n    for (let i = 0; i < size; i++) {\\n      const [x, y] = queue.shift()\\n      \\n      if (x === m - 1 && y === n - 1) return step\\n      \\n      for (const [dx, dy] of dires) {\\n        const newX = x + dx, newY = y + dy\\n        if (_withinBound(newX, newY, m, n) && grid[newX][newY] === 0) {\\n          grid[newX][newY] = 1\\n          queue.push([newX, newY])\\n        }\\n      }\\n    }\\n    \\n    step += 1\\n  }\\n  \\n  return -1\\n};\\n  \\nfunction _withinBound(x, y, m, n) {\\n  return 0 <= x && 0 <= y && x < m && y < n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585519,
                "title": "python-simple-python-solution-using-queue-and-bfs",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 785 ms, faster than 21.72% of Python3 online submissions for Shortest Path in Binary Matrix.\\n# Memory Usage: 18 MB, less than 12.33% of Python3 online submissions for Shortest Path in Binary Matrix.\\n\\n\\tclass Solution:\\n\\t\\tdef shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n\\n\\t\\t\\tlength = len(grid)\\n\\n\\t\\t\\tif grid[0][0] == 1 or grid[length - 1][length - 1] == 1:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\tvisited = set((0,0))\\n\\n\\t\\t\\tdirections = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, 1], [1, -1]]\\n\\n\\t\\t\\tqueue = collections.deque([(1,0,0)])\\n\\n\\t\\t\\twhile queue:\\n\\n\\t\\t\\t\\tcurrent_distance, current_position_x , current_position_y = queue.popleft()\\n\\n\\t\\t\\t\\tif current_position_x == length - 1 and current_position_y == length - 1:\\n\\t\\t\\t\\t\\treturn current_distance\\n\\n\\t\\t\\t\\tfor direction in directions:\\n\\n\\t\\t\\t\\t\\tx , y = direction\\n\\n\\t\\t\\t\\t\\tnext_position_x , next_position_y =  current_position_x + x , current_position_y + y\\n\\n\\t\\t\\t\\t\\tif 0 <= current_position_x < length and 0 <= current_position_y < length and grid[current_position_x][current_position_y] == 0 and (next_position_x , next_position_y) not in visited: \\n\\n\\t\\t\\t\\t\\t\\tqueue.append((current_distance + 1 , next_position_x , next_position_y))\\n\\t\\t\\t\\t\\t\\tvisited.add((next_position_x , next_position_y))\\n\\n\\t\\t\\treturn -1\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 785 ms, faster than 21.72% of Python3 online submissions for Shortest Path in Binary Matrix.\\n# Memory Usage: 18 MB, less than 12.33% of Python3 online submissions for Shortest Path in Binary Matrix.\\n\\n\\tclass Solution:\\n\\t\\tdef shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n\\n\\t\\t\\tlength = len(grid)\\n\\n\\t\\t\\tif grid[0][0] == 1 or grid[length - 1][length - 1] == 1:\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\tvisited = set((0,0))\\n\\n\\t\\t\\tdirections = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, 1], [1, -1]]\\n\\n\\t\\t\\tqueue = collections.deque([(1,0,0)])\\n\\n\\t\\t\\twhile queue:\\n\\n\\t\\t\\t\\tcurrent_distance, current_position_x , current_position_y = queue.popleft()\\n\\n\\t\\t\\t\\tif current_position_x == length - 1 and current_position_y == length - 1:\\n\\t\\t\\t\\t\\treturn current_distance\\n\\n\\t\\t\\t\\tfor direction in directions:\\n\\n\\t\\t\\t\\t\\tx , y = direction\\n\\n\\t\\t\\t\\t\\tnext_position_x , next_position_y =  current_position_x + x , current_position_y + y\\n\\n\\t\\t\\t\\t\\tif 0 <= current_position_x < length and 0 <= current_position_y < length and grid[current_position_x][current_position_y] == 0 and (next_position_x , next_position_y) not in visited: \\n\\n\\t\\t\\t\\t\\t\\tqueue.append((current_distance + 1 , next_position_x , next_position_y))\\n\\t\\t\\t\\t\\t\\tvisited.add((next_position_x , next_position_y))\\n\\n\\t\\t\\treturn -1\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3584631,
                "title": "c-easy-understanding-queue-shortest-path-bfs",
                "content": "\\nSimply insert the start 0,0 in queue with distance 0. Traverse through valid neighbours in eight directions and having cell value 0 is a valid cell. Now if the previously stored distance is more then replace with distance of parent +1 and insert in queue with dist+1.\\nThe edge cases are that if the grid[0][0]=1 then we cannot start only so return -1.\\nif the stored distance at last grid is 1e9 then we cannot reach that cell so return -1.\\nAt last number of visited cells is distance of last cell +1.\\n\\n\\n**Please Upvote if you found this Useful !**\\n\\n\\n```\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        if(grid[0][0]!=0) return -1;\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        dist[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int delrow[]={-1,-1,0,1,1,1,0,-1};\\n        int delcol[]={0,-1,-1,-1,0,1,1,1};\\n        while(!q.empty()){\\n            int dis= q.front().first;\\n            int row= q.front().second.first;\\n            int col=q.front().second.second;\\n            q.pop();\\n            for(int i=0; i<8; i++){\\n                int nrow= row+delrow[i];\\n                int ncol= col+ delcol[i];\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==0 &&\\n                  dist[nrow][ncol]>1+dis){\\n                    dist[nrow][ncol]=1+dis;\\n                    q.push({dist[nrow][ncol],{nrow,ncol}});\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        if(dist[n-1][m-1]==1e9) return -1;\\n        return dist[n-1][m-1]+1;\\n        \\n        \\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "\\nSimply insert the start 0,0 in queue with distance 0. Traverse through valid neighbours in eight directions and having cell value 0 is a valid cell. Now if the previously stored distance is more then replace with distance of parent +1 and insert in queue with dist+1.\\nThe edge cases are that if the grid[0][0]=1 then we cannot start only so return -1.\\nif the stored distance at last grid is 1e9 then we cannot reach that cell so return -1.\\nAt last number of visited cells is distance of last cell +1.\\n\\n\\n**Please Upvote if you found this Useful !**\\n\\n\\n```\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int m= grid[0].size();\\n        if(grid[0][0]!=0) return -1;\\n        vector<vector<int>>dist(n,vector<int>(m,1e9));\\n        dist[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int delrow[]={-1,-1,0,1,1,1,0,-1};\\n        int delcol[]={0,-1,-1,-1,0,1,1,1};\\n        while(!q.empty()){\\n            int dis= q.front().first;\\n            int row= q.front().second.first;\\n            int col=q.front().second.second;\\n            q.pop();\\n            for(int i=0; i<8; i++){\\n                int nrow= row+delrow[i];\\n                int ncol= col+ delcol[i];\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==0 &&\\n                  dist[nrow][ncol]>1+dis){\\n                    dist[nrow][ncol]=1+dis;\\n                    q.push({dist[nrow][ncol],{nrow,ncol}});\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        if(dist[n-1][m-1]==1e9) return -1;\\n        return dist[n-1][m-1]+1;\\n        \\n        \\n        \\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3584182,
                "title": "here-s-why-dp-fails-clear-explanation",
                "content": "# C++ RECURSION CODE BUT IT FAILS !\\n```class Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid, int i, int j, vector<vector<bool>>& visited) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 1) {\\n            return INT_MAX;\\n        }\\n        \\n        if (i == m - 1 && j == n - 1) {\\n            return 1;\\n        }\\n        \\n        visited[i][j] = true;\\n        \\n        int diagonal = solve(grid, i + 1, j + 1, visited);\\n        int down = solve(grid, i + 1, j, visited);\\n        int right = solve(grid, i, j + 1, visited);\\n        \\n        visited[i][j] = false;\\n        \\n        int minPath = min(diagonal, min(down, right));\\n        return (minPath == INT_MAX) ? INT_MAX : minPath + 1;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1) {\\n            return -1; // Invalid path\\n        }\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        \\n        int ans = solve(grid, 0, 0, visited);\\n        return (ans == INT_MAX) ? -1 : ans;\\n    }\\n};\\n```\\n# EXPLANATIION WITH TESTCASE\\n![WhatsApp Image 2023-06-01 at 8.07.59 AM.jpeg](https://assets.leetcode.com/users/images/77fd038d-f8ab-4554-a269-496127da48c3_1685587494.6188555.jpeg)\\n\\nHope it will give you a clear understanding of why DP fails !",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```class Solution {\\npublic:\\n    int solve(vector<vector<int>>& grid, int i, int j, vector<vector<bool>>& visited) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 1) {\\n            return INT_MAX;\\n        }\\n        \\n        if (i == m - 1 && j == n - 1) {\\n            return 1;\\n        }\\n        \\n        visited[i][j] = true;\\n        \\n        int diagonal = solve(grid, i + 1, j + 1, visited);\\n        int down = solve(grid, i + 1, j, visited);\\n        int right = solve(grid, i, j + 1, visited);\\n        \\n        visited[i][j] = false;\\n        \\n        int minPath = min(diagonal, min(down, right));\\n        return (minPath == INT_MAX) ? INT_MAX : minPath + 1;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1) {\\n            return -1; // Invalid path\\n        }\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        \\n        int ans = solve(grid, 0, 0, visited);\\n        return (ans == INT_MAX) ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584062,
                "title": "easy-c-code-100-efficient-bfs",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> direction = {{0,1}, {0,-1}, {1,0}, {-1,0}, {1,1}, {-1,-1}, {1,-1}, {-1,1}};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if(grid[0][0] == 1 or grid[m-1][n-1] == 1) return -1;\\n        grid[0][0] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        while(!q.empty()){\\n            auto [x, y] = q.front();\\n            q.pop();\\n            if(x == m-1 and y == n-1) return grid[x][y];\\n            for(auto [x1, y1] : direction){\\n                int newX = x + x1;\\n                int newY = y + y1;\\n                if(newX >= 0 and newX < m and newY >= 0 and newY < n and grid[newX][newY] == 0){\\n                    grid[newX][newY] = grid[x][y]+1;\\n                    q.push({newX, newY});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> direction = {{0,1}, {0,-1}, {1,0}, {-1,0}, {1,1}, {-1,-1}, {1,-1}, {-1,1}};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        if(grid[0][0] == 1 or grid[m-1][n-1] == 1) return -1;\\n        grid[0][0] = 1;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        while(!q.empty()){\\n            auto [x, y] = q.front();\\n            q.pop();\\n            if(x == m-1 and y == n-1) return grid[x][y];\\n            for(auto [x1, y1] : direction){\\n                int newX = x + x1;\\n                int newY = y + y1;\\n                if(newX >= 0 and newX < m and newY >= 0 and newY < n and grid[newX][newY] == 0){\\n                    grid[newX][newY] = grid[x][y]+1;\\n                    q.push({newX, newY});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3158713,
                "title": "java-easy-to-understand-dijkstra-s-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    int first;\\n    int second;\\n    int third;\\n    \\n    Pair(int fst,int scnd,int thrd){\\n        this.first=fst;\\n        this.second=scnd;\\n        this.third=thrd;\\n    }\\n}\\n\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0]!=0) return -1;\\n\\n        \\n        \\n\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        if(grid[0][0]==grid[n-1][n-1] && n==1) return 1;\\n\\n        int dist[][]=new int[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dist[i][j]=(int)1e9;\\n            }\\n        }\\n        \\n        int delRow[]={1,-1,0,0,1,1,-1,-1};\\n        int delCol[]={0,0,1,-1,-1,1,-1,1};\\n        \\n        dist[0][0]=0;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(1,0,0));\\n        \\n        while(!q.isEmpty()){\\n            int dis=q.peek().first;\\n            int row=q.peek().second;\\n            int col=q.peek().third;\\n            q.poll();\\n            \\n            for(int i=0;i<8;i++){\\n                int nrow=row+delRow[i];\\n                int ncol=col+delCol[i];\\n                \\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==0 \\n                && dis+1<dist[nrow][ncol]){\\n                    \\n                    if(nrow==n-1 && ncol==n-1) return dis+1;\\n                    \\n                    q.add(new Pair(dis+1,nrow,ncol));\\n                    dist[nrow][ncol]=dis+1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair{\\n    int first;\\n    int second;\\n    int third;\\n    \\n    Pair(int fst,int scnd,int thrd){\\n        this.first=fst;\\n        this.second=scnd;\\n        this.third=thrd;\\n    }\\n}\\n\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0]!=0) return -1;\\n\\n        \\n        \\n\\n        int n=grid.length;\\n        int m=grid[0].length;\\n\\n        if(grid[0][0]==grid[n-1][n-1] && n==1) return 1;\\n\\n        int dist[][]=new int[n][m];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                dist[i][j]=(int)1e9;\\n            }\\n        }\\n        \\n        int delRow[]={1,-1,0,0,1,1,-1,-1};\\n        int delCol[]={0,0,1,-1,-1,1,-1,1};\\n        \\n        dist[0][0]=0;\\n        \\n        Queue<Pair>q=new LinkedList<>();\\n        q.add(new Pair(1,0,0));\\n        \\n        while(!q.isEmpty()){\\n            int dis=q.peek().first;\\n            int row=q.peek().second;\\n            int col=q.peek().third;\\n            q.poll();\\n            \\n            for(int i=0;i<8;i++){\\n                int nrow=row+delRow[i];\\n                int ncol=col+delCol[i];\\n                \\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && grid[nrow][ncol]==0 \\n                && dis+1<dist[nrow][ncol]){\\n                    \\n                    if(nrow==n-1 && ncol==n-1) return dis+1;\\n                    \\n                    q.add(new Pair(dis+1,nrow,ncol));\\n                    dist[nrow][ncol]=dis+1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127547,
                "title": "ezpz-py-soln-2023",
                "content": "\\n```\\nclass Solution:\\n\\tdef shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n\\t\\trow, col, queue = len(grid), len(grid[0]), deque([(0,0,1)])\\n\\n\\t\\tif grid[0][0] == 1: return -1 # bruh, if it aint 0 then it aint gonna work\\n\\n\\t\\twhile queue:\\n\\t\\t\\tx, y, steps = queue.popleft()\\n\\t\\t\\tif x == row-1 and y == col-1:\\n\\t\\t\\t\\treturn steps\\n\\t\\t\\tfor nx,ny in [[x+1,y+1], [x-1,y-1], [x+1,y-1], [x-1,y+1], [x+1,y], [x-1,y], [x,y+1], [x,y-1]]:\\n\\t\\t\\t\\tif 0<=nx<row and 0<=ny<col and grid[nx][ny] == 0:\\n\\t\\t\\t\\t\\tgrid[nx][ny] = \"X\"\\n\\t\\t\\t\\t\\tqueue.append((nx, ny, steps+1))\\n\\n\\t\\treturn -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n\\t\\trow, col, queue = len(grid), len(grid[0]), deque([(0,0,1)])\\n\\n\\t\\tif grid[0][0] == 1: return -1 # bruh, if it aint 0 then it aint gonna work\\n\\n\\t\\twhile queue:\\n\\t\\t\\tx, y, steps = queue.popleft()\\n\\t\\t\\tif x == row-1 and y == col-1:\\n\\t\\t\\t\\treturn steps\\n\\t\\t\\tfor nx,ny in [[x+1,y+1], [x-1,y-1], [x+1,y-1], [x-1,y+1], [x+1,y], [x-1,y], [x,y+1], [x,y-1]]:\\n\\t\\t\\t\\tif 0<=nx<row and 0<=ny<col and grid[nx][ny] == 0:\\n\\t\\t\\t\\t\\tgrid[nx][ny] = \"X\"\\n\\t\\t\\t\\t\\tqueue.append((nx, ny, steps+1))\\n\\n\\t\\treturn -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554394,
                "title": "java-solution",
                "content": "Solution - \\n```\\nclass Solution {\\n    public class Pair{\\n        int x, y, count;\\n        public Pair(int x, int y, int count){\\n            this.x = x;\\n            this.y = y;\\n            this.count = count;\\n        }\\n    }\\n    \\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] != 0) return -1;\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0, 1));\\n        \\n        int[] drow = {-1, 0, 1, 0, -1, 1, 1, -1};\\n        int[] dcol = {0, -1, 0, 1, -1, 1, -1, 1};\\n        \\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            while(s-- > 0){\\n                Pair curr = q.poll();\\n                int x = curr.x;\\n                int y = curr.y;\\n                int count = curr.count;\\n                \\n                if(x == n-1 && y == m-1)\\n                    return count;\\n                for(int i=0; i<8; i++){\\n                    int nrow = x + drow[i];\\n                    int ncol = y + dcol[i];\\n                    if(nrow >= 0 && ncol >= 0 && nrow < n && ncol < m && grid[nrow][ncol] == 0){\\n                        q.add(new Pair(nrow, ncol, count+1));\\n                        grid[nrow][ncol] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public class Pair{\\n        int x, y, count;\\n        public Pair(int x, int y, int count){\\n            this.x = x;\\n            this.y = y;\\n            this.count = count;\\n        }\\n    }\\n    \\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] != 0) return -1;\\n        \\n        int n = grid.length;\\n        int m = grid[0].length;\\n        \\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(0, 0, 1));\\n        \\n        int[] drow = {-1, 0, 1, 0, -1, 1, 1, -1};\\n        int[] dcol = {0, -1, 0, 1, -1, 1, -1, 1};\\n        \\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            while(s-- > 0){\\n                Pair curr = q.poll();\\n                int x = curr.x;\\n                int y = curr.y;\\n                int count = curr.count;\\n                \\n                if(x == n-1 && y == m-1)\\n                    return count;\\n                for(int i=0; i<8; i++){\\n                    int nrow = x + drow[i];\\n                    int ncol = y + dcol[i];\\n                    if(nrow >= 0 && ncol >= 0 && nrow < n && ncol < m && grid[nrow][ncol] == 0){\\n                        q.add(new Pair(nrow, ncol, count+1));\\n                        grid[nrow][ncol] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906805,
                "title": "template-for-these-kind-of-questions-python-bfs-without-visited-set",
                "content": "**Here is a template to solve these kind of question**\\nIn every question ,we just have to change the conditon for counting the res...\\nrest of the procedure is gonna same for all questions.\\n\\n# CODE\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n         \\n        r=len(grid)\\n        c=len(grid[0])\\n        \\n        # base case\\n        if grid[0][0] or grid[r-1][c-1]:\\n            return -1\\n        \\n#       it\\'s better to define the directioln first instead to define in the bfs main function\\n        direction=[(1,0),(0,1),(-1,0),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)]\\n        \\n#       initialize the queue with starting index and starting shell \\n        q=deque([(0,0,1)])\\n        \\n        while q:\\n            \\n            x,y,no_cell=q.popleft()\\n            \\n#           condition to return the result   \\n            if x==r-1 and y==c-1:\\n                return no_cell\\n\\n            for d in direction:\\n                nx=x+d[0]\\n                ny=y+d[1]\\n                \\n#               check for boundry condition and block places in the grid\\n                if 0<=nx<r and 0<=ny<c and grid[nx][ny]==0:\\n                   \\n#                   changing the grid value so that we don\\'t traverse again through it \\n#                   instead of using the seen/visited set we just change the grid value to mark it as visited \\n                    \\n                    grid[nx][ny]=1\\n                    q.append((nx,ny,no_cell+1))\\n        return -1\\n```\\nr==rows\\nc=columns\\n**Time complexity**:   r.c\\n**Space complexity**: Number of zero in the grid (which eventually added in queue)\\n\\n\\n![image](https://assets.leetcode.com/users/images/da439bd0-8c05-4b2e-a517-987869868a9d_1648911706.9934976.png)\\n\\n\\n**If you like the above content . Please Upvote.... car \\uD83E\\uDD17\\uD83E\\uDD17**\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n         \\n        r=len(grid)\\n        c=len(grid[0])\\n        \\n        # base case\\n        if grid[0][0] or grid[r-1][c-1]:\\n            return -1\\n        \\n#       it\\'s better to define the directioln first instead to define in the bfs main function\\n        direction=[(1,0),(0,1),(-1,0),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)]\\n        \\n#       initialize the queue with starting index and starting shell \\n        q=deque([(0,0,1)])\\n        \\n        while q:\\n            \\n            x,y,no_cell=q.popleft()\\n            \\n#           condition to return the result   \\n            if x==r-1 and y==c-1:\\n                return no_cell\\n\\n            for d in direction:\\n                nx=x+d[0]\\n                ny=y+d[1]\\n                \\n#               check for boundry condition and block places in the grid\\n                if 0<=nx<r and 0<=ny<c and grid[nx][ny]==0:\\n                   \\n#                   changing the grid value so that we don\\'t traverse again through it \\n#                   instead of using the seen/visited set we just change the grid value to mark it as visited \\n                    \\n                    grid[nx][ny]=1\\n                    q.append((nx,ny,no_cell+1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833879,
                "title": "simple-c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dir{{0 , -1} , {0 , 1} , {1 , 0} , {-1 , 0} , {-1 , -1} , {-1 , 1} , {1 , -1} , {1 , 1}};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        // int m = grid[0].size();\\n        if(n == 1 and grid[0][0] == 0)return 1;\\n        if(n == 1 and grid[0][0] == 1)return -1;\\n        if(grid[0][0] == 1 or grid[n-1][n-1] == 1)return -1;\\n        \\n        queue<pair<int , int>>q;\\n        q.push({0 , 0});\\n        vector<vector<bool>>vis(n , vector<bool>(n , 0));\\n        vis[0][0] = true;\\n        int ct = 1;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                auto temp = q.front();\\n                q.pop();\\n                for(int i = 0 ; i < dir.size() ; i++){\\n                    int first = temp.first + dir[i][0];\\n                    int second = temp.second + dir[i][1];\\n                    if(first >= 0 and second >= 0 and first < n and second < n and !vis[first][second] and grid[first][second] == 0){\\n                        if(first == n-1 and  second == n-1){\\n                            return ct + 1;\\n                        }else{\\n                            vis[first][second] = true;\\n                            q.push({first , second});\\n                        }\\n                    }\\n                }\\n            }\\n            ct++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dir{{0 , -1} , {0 , 1} , {1 , 0} , {-1 , 0} , {-1 , -1} , {-1 , 1} , {1 , -1} , {1 , 1}};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        // int m = grid[0].size();\\n        if(n == 1 and grid[0][0] == 0)return 1;\\n        if(n == 1 and grid[0][0] == 1)return -1;\\n        if(grid[0][0] == 1 or grid[n-1][n-1] == 1)return -1;\\n        \\n        queue<pair<int , int>>q;\\n        q.push({0 , 0});\\n        vector<vector<bool>>vis(n , vector<bool>(n , 0));\\n        vis[0][0] = true;\\n        int ct = 1;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                auto temp = q.front();\\n                q.pop();\\n                for(int i = 0 ; i < dir.size() ; i++){\\n                    int first = temp.first + dir[i][0];\\n                    int second = temp.second + dir[i][1];\\n                    if(first >= 0 and second >= 0 and first < n and second < n and !vis[first][second] and grid[first][second] == 0){\\n                        if(first == n-1 and  second == n-1){\\n                            return ct + 1;\\n                        }else{\\n                            vis[first][second] = true;\\n                            q.push({first , second});\\n                        }\\n                    }\\n                }\\n            }\\n            ct++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823962,
                "title": "typescript-bfs-100-88ms",
                "content": "```\\nconst movements = [\\n    { x: 0, y: 1 },\\n    { x: 0, y: -1 },\\n    { y: 0, x: -1 },\\n    { y: 0, x: 1 },\\n    { x: 1, y: 1 },\\n    { x: 1, y: -1 },\\n    { y: 1, x: -1 },\\n    { y: -1, x: -1 },\\n]\\n\\nfunction safeToMove(x: number, y: number, grid: number[][]) {\\n    return x >= 0 && x < grid.length && y >= 0 && y < grid.length && grid[y][x] === 0;\\n}\\n\\nfunction shortestPathBinaryMatrix(grid: number[][]): number {\\n    const n = grid.length - 1;\\n\\n    if (grid[n][n] === 1 || grid[0][0] === 1) return -1;\\n\\n    let shortest = -1;\\n\\n    const queue: { x: number, y: number, count: number }[] = [{ x: 0, y: 0, count: 1 }];\\n    grid[0][0] = 1;\\n\\n    while (queue.length > 0) {\\n        const { x, y, count } = queue.shift()!;\\n        if (x === n && y === n) {\\n            return count;\\n        } else {\\n            for (const movement of movements) {\\n                const nextX = x + movement.x;\\n                const nextY = y + movement.y;\\n\\t\\t\\t\\t\\n                if (safeToMove(nextX, nextY, grid)) {\\n                    queue.push({ x: nextX, y: nextY, count: count + 1 })\\n                    grid[nextY][nextX] = 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    return shortest;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst movements = [\\n    { x: 0, y: 1 },\\n    { x: 0, y: -1 },\\n    { y: 0, x: -1 },\\n    { y: 0, x: 1 },\\n    { x: 1, y: 1 },\\n    { x: 1, y: -1 },\\n    { y: 1, x: -1 },\\n    { y: -1, x: -1 },\\n]\\n\\nfunction safeToMove(x: number, y: number, grid: number[][]) {\\n    return x >= 0 && x < grid.length && y >= 0 && y < grid.length && grid[y][x] === 0;\\n}\\n\\nfunction shortestPathBinaryMatrix(grid: number[][]): number {\\n    const n = grid.length - 1;\\n\\n    if (grid[n][n] === 1 || grid[0][0] === 1) return -1;\\n\\n    let shortest = -1;\\n\\n    const queue: { x: number, y: number, count: number }[] = [{ x: 0, y: 0, count: 1 }];\\n    grid[0][0] = 1;\\n\\n    while (queue.length > 0) {\\n        const { x, y, count } = queue.shift()!;\\n        if (x === n && y === n) {\\n            return count;\\n        } else {\\n            for (const movement of movements) {\\n                const nextX = x + movement.x;\\n                const nextY = y + movement.y;\\n\\t\\t\\t\\t\\n                if (safeToMove(nextX, nextY, grid)) {\\n                    queue.push({ x: nextX, y: nextY, count: count + 1 })\\n                    grid[nextY][nextX] = 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    return shortest;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1643336,
                "title": "c-bfs-mark-the-nodes-as-soon-as-you-push-them-into-queue-to-avoid-tle",
                "content": "\\n```cpp\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if (grid[0][0] == 1) return -1;\\n        queue<pair<int, int>> Q;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        Q.push({0, 0});\\n        grid[0][0] = 1;\\n        int depth = 0;\\n        auto isValid = [&](int a, int b) {\\n            return (a >= 0 && b >= 0 && a < n && b < m);  \\n        };\\n        while(Q.size() > 0) {\\n            int N = (int)Q.size();\\n            ++depth;\\n            while(N--) {\\n                auto node = Q.front();\\n                Q.pop();\\n                if (node.first == n - 1 && node.second == m - 1) return depth;\\n                for (int i = -1; i < 2; ++i) {\\n                    for (int j = -1; j < 2; ++j) {\\n                        if (i == 0 && j == 0) continue;\\n                        int X = i + node.first;\\n                        int Y = j + node.second;\\n                        if (isValid(X, Y) && grid[X][Y] == 0) {\\n                            grid[X][Y] = 1;\\n                            Q.push({X, Y});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if (grid[0][0] == 1) return -1;\\n        queue<pair<int, int>> Q;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        Q.push({0, 0});\\n        grid[0][0] = 1;\\n        int depth = 0;\\n        auto isValid = [&](int a, int b) {\\n            return (a >= 0 && b >= 0 && a < n && b < m);  \\n        };\\n        while(Q.size() > 0) {\\n            int N = (int)Q.size();\\n            ++depth;\\n            while(N--) {\\n                auto node = Q.front();\\n                Q.pop();\\n                if (node.first == n - 1 && node.second == m - 1) return depth;\\n                for (int i = -1; i < 2; ++i) {\\n                    for (int j = -1; j < 2; ++j) {\\n                        if (i == 0 && j == 0) continue;\\n                        int X = i + node.first;\\n                        int Y = j + node.second;\\n                        if (isValid(X, Y) && grid[X][Y] == 0) {\\n                            grid[X][Y] = 1;\\n                            Q.push({X, Y});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602336,
                "title": "simple-bfs-python-solution-with-comments",
                "content": "#Time O(N) where N is the number of cells, Space O(N)\\n\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        def valid(r,c):\\n            return 0<=r<len(grid) and 0<=c<len(grid[0]) and grid[r][c]==0 \\n            \\n        \\n        if grid[0][0]==1 or grid[-1][-1]==1: return -1 #no need to loop it means wither start or end are not valis\\n        \\n        q=deque([(0,0,1)]) #(row,col,moves)\\n        directions=[(1,0),(-1,0),(0,1),(0,-1),(-1,-1),(-1,1),(1,1),(1,-1)]\\n        grid[0][0]=1 #mark first sell visited\\n        while q:\\n            r,c,moves=q.popleft()\\n            if r==len(grid)-1 and c==len(grid[0])-1:\\n                return moves\\n            \\n            for row,col in directions:\\n                newR=r+row\\n                newC=c+col\\n                if valid(newR,newC):\\n                    grid[newR][newC]=1 #mark visited by flipping to one\\n                    q.append((newR,newC,moves+1))\\n        return -1\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        def valid(r,c):\\n            return 0<=r<len(grid) and 0<=c<len(grid[0]) and grid[r][c]==0 \\n            \\n        \\n        if grid[0][0]==1 or grid[-1][-1]==1: return -1 #no need to loop it means wither start or end are not valis\\n        \\n        q=deque([(0,0,1)]) #(row,col,moves)\\n        directions=[(1,0),(-1,0),(0,1),(0,-1),(-1,-1),(-1,1),(1,1),(1,-1)]\\n        grid[0][0]=1 #mark first sell visited\\n        while q:\\n            r,c,moves=q.popleft()\\n            if r==len(grid)-1 and c==len(grid[0])-1:\\n                return moves\\n            \\n            for row,col in directions:\\n                newR=r+row\\n                newC=c+col\\n                if valid(newR,newC):\\n                    grid[newR][newC]=1 #mark visited by flipping to one\\n                    q.append((newR,newC,moves+1))\\n        return -1\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063637,
                "title": "bfs-solution-in-java",
                "content": "```\\nclass Matrix{\\n    int r;\\n    int c;\\n    Matrix(int r,int c){\\n        this.r=r;\\n        this.c=c;\\n    }\\n}\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid.length==0 || grid[0].length==0)\\n            return 0;\\n        \\n        int visited[][]=new int[grid.length][grid[0].length];\\n        for (int[] row : visited) \\n            Arrays.fill(row, -1); \\n        Queue<Matrix> q=new LinkedList<Matrix>();\\n        if(grid[0][0]==0){\\n            q.add(new Matrix(0,0));\\n            visited[0][0]=1;\\n        }\\n        \\n        while(!q.isEmpty()){\\n            Matrix m=q.remove();\\n            int level=visited[m.r][m.c];\\n            int R[]={-1,-1,-1,0,0,1,1,1};\\n            int C[]={-1,0,1,-1,1,-1,0,1};\\n            for(int i=0;i<8;i++){\\n                int currR=m.r+R[i];\\n                int currC=m.c+C[i];\\n                if(currR>=grid.length || currR<0 || currC<0 ||currC>=grid[0].length)\\n                    continue;\\n                if(visited[currR][currC]==-1 && grid[currR][currC]==0)\\n                {\\n                    visited[currR][currC]=level+1;\\n                    q.add(new Matrix(currR,currC));\\n                }\\n            }\\n        }\\n        return visited[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Matrix{\\n    int r;\\n    int c;\\n    Matrix(int r,int c){\\n        this.r=r;\\n        this.c=c;\\n    }\\n}\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid.length==0 || grid[0].length==0)\\n            return 0;\\n        \\n        int visited[][]=new int[grid.length][grid[0].length];\\n        for (int[] row : visited) \\n            Arrays.fill(row, -1); \\n        Queue<Matrix> q=new LinkedList<Matrix>();\\n        if(grid[0][0]==0){\\n            q.add(new Matrix(0,0));\\n            visited[0][0]=1;\\n        }\\n        \\n        while(!q.isEmpty()){\\n            Matrix m=q.remove();\\n            int level=visited[m.r][m.c];\\n            int R[]={-1,-1,-1,0,0,1,1,1};\\n            int C[]={-1,0,1,-1,1,-1,0,1};\\n            for(int i=0;i<8;i++){\\n                int currR=m.r+R[i];\\n                int currC=m.c+C[i];\\n                if(currR>=grid.length || currR<0 || currC<0 ||currC>=grid[0].length)\\n                    continue;\\n                if(visited[currR][currC]==-1 && grid[currR][currC]==0)\\n                {\\n                    visited[currR][currC]=level+1;\\n                    q.add(new Matrix(currR,currC));\\n                }\\n            }\\n        }\\n        return visited[grid.length-1][grid[0].length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063636,
                "title": "try-with-c-a-star",
                "content": "for A star explanations: https://www.redblobgames.com/pathfinding/a-star/introduction.html\\n\\nA star is based on Dijkstra, but extends Dijkstra\\'s priority key to included heuristic cost(next, target) in addition.\\n\\nin Astar we can NOT use hashset to simply skip visited nodes liked BFS did,  because A star uses the heuristic as only kind of assumption, therefore Astar cannot guarantee that costs to visited nodes wouldn\\'t be reduced by newly found paths.\\n\\nfinally for the heuristic(next ,target) , I used max(abs(n-1-x), abs(n-1-y) ), i.e. the larger absolution difference either on x coordiator or on y coordiator\\uFF0Cbut not the manhattan distance since moving on diagonal directions are allowed.\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(!n || grid[0][0]==1 || grid[n-1][n-1]==1) return -1;\\n\\t\\t\\n        return Astar(grid);\\n    }\\n    \\n    int Astar(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq; \\n\\t\\tpq.push({0,0});\\n        int n = grid.size();\\n        int steps=0;\\n        vector<int> distance( n*n, INT_MAX);\\n        distance[0] = 1;\\n        \\n        while( !pq.empty()) {\\n            auto cur = pq.top(); pq.pop();  \\n            steps = distance[cur.second];\\n            int x = cur.second/n;\\n            int y = cur.second%n;  \\n            if ( x==n-1 && y==n-1) return steps;\\n                \\n            for( pair<int, int> p: vector<pair<int,int>>({ {-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1} })) {\\n                int dx = p.first + x;\\n                int dy = p.second +y;\\n                if( dx<0|| dx>=n || dy <0 || dy>=n || grid[dx][dy]==1 ||  distance[dx*n+dy] <= distance[ x*n+ y] +1   ) continue;\\n\\n                distance[dx*n+dy] = distance[ x*n+ y] +1 ;\\n                pq.push( { distance[dx*n+dy] +max(abs(n-1-x), abs(n-1-y))  , dx*n+dy} ); \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        if(!n || grid[0][0]==1 || grid[n-1][n-1]==1) return -1;\\n\\t\\t\\n        return Astar(grid);\\n    }\\n    \\n    int Astar(vector<vector<int>>& grid) {\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> > pq; \\n\\t\\tpq.push({0,0});\\n        int n = grid.size();\\n        int steps=0;\\n        vector<int> distance( n*n, INT_MAX);\\n        distance[0] = 1;\\n        \\n        while( !pq.empty()) {\\n            auto cur = pq.top(); pq.pop();  \\n            steps = distance[cur.second];\\n            int x = cur.second/n;\\n            int y = cur.second%n;  \\n            if ( x==n-1 && y==n-1) return steps;\\n                \\n            for( pair<int, int> p: vector<pair<int,int>>({ {-1,0},{1,0},{0,-1},{0,1},{-1,-1},{-1,1},{1,-1},{1,1} })) {\\n                int dx = p.first + x;\\n                int dy = p.second +y;\\n                if( dx<0|| dx>=n || dy <0 || dy>=n || grid[dx][dy]==1 ||  distance[dx*n+dy] <= distance[ x*n+ y] +1   ) continue;\\n\\n                distance[dx*n+dy] = distance[ x*n+ y] +1 ;\\n                pq.push( { distance[dx*n+dy] +max(abs(n-1-x), abs(n-1-y))  , dx*n+dy} ); \\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063571,
                "title": "js-python-java-c-bfs-solution-w-explanation-beats-100-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nWhen we\\'re asked about finding the \"shortest path\", the first thing that should come to mind is a **breadth-first solution** (BFS) approach. In a standard graph BFS solution, we set up a **queue** (**q**) and fill it with our starting position (**grid[0][0]**). Then we keep pulling entries from **q**, figuring out the next moves from that position, and input those next moves back into **q**.\\n\\nWhen we\\'re ready to start, we can change **grid[0][0]** to **1**, then as we reach new cells, we can store the distance to that cell in the cell at the same time we add it to the queue. The distance will simply be one more than the distance to the cell we\\'re moving from. This will also eliminate duplicate queue entries by changing visited cells to a non-zero number.\\n\\nThrough the nature of a BFS approach to graph traversal (with non-weighted edges), the first time we reach the end location (**grid[n][n]**) will represent the best possible distance.\\n\\nSince **0 <= i, j <= 100**, both **i** and **j** will fit into **7 bits** each, so we can utilize **bit manipulation** to store both in one integer. With a **bitwise left shift** (**<<**) we can move the value of **j** to the left by **7 bits** before adding it to **i** to allow for both to fit in **14 bits** of an integer.\\n```js\\nBitwise shift example:\\n\\n   i  =  93 (base 10)  =  1011101 (base 2)\\n   j  =  75 (base 10)  =  1001011 (base 2)\\n\\n   j << 7  =  1001011<<<<<<<     // Bitwise left shift moves the value left\\n           =  10010110000000     // And fills in the space with 0s\\n\\n   i:                           1011101 \\n        j << 7:       +  10010110000000\\n                        ----------------\\n   i + (j << 7):      =  10010111011101 (base 2)\\n                      =            9693 (base 10)\\n```\\nTo read **i** from the first **7 bits** of our stored integer again, you can use **bitwise AND** (**&**) and a **bitmask** of **1111111**. The easiest way to get a bitmask of **1111111** is to shift a single bit to the left by **7** (**1 << 7 = 10000000**) and then subtract **1**, rolling it back to all **1**s.\\n```js\\nBitmask example:\\n\\n   1 << 7:               10000000\\n                      -         1\\n                        ----------\\n   (1 << 7) - 1:      =   1111111\\n```\\nThe bitwise AND will only keep any bits that have a **1** in both numbers, thus stripping away anything except the first **7 bits** of data.\\n```js\\nBitwise AND example:\\n\\n      10010111011101\\n   &         1111111\\n     ----------------\\n   =         1011101\\n```\\nTo read the **j** value from our integer, we can just shift it to the right by **7 bits**, which will throw away the first **7 bits** of data corresponding to the **i** value.\\n\\nIf **q** becomes empty without finding a path to the end, then **return -1**.\\n\\n---\\n\\n***Implementation:***\\n\\nIf either the starting point or the ending point are a **1**, then we quickly **return -1**.\\n\\nTo check which moves can be made, we can just iterate over a three-value range for each **i** and **j**, and to make sure that they remain in bounds, we can apply a **max** and **min** to the range.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **88ms / 42.3MB** (beats 100% / 100%).\\n```javascript\\nvar shortestPathBinaryMatrix = function(grid) {\\n    let n = grid.length - 1, q = [0]\\n    if (grid[0][0] || grid[n][n]) return -1\\n    grid[0][0] = 1\\n    while (q.length) {\\n        let curr = q.shift(), i = curr & (1 << 7) - 1, j = curr >> 7\\n        if (i === n && j === n) return grid[n][n]\\n        for (let a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n            for (let b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                if (grid[a][b] === 0)\\n                    grid[a][b] = grid[i][j] + 1, q.push(a + (b << 7))\\n    }\\n    return -1\\n};\\n```\\n\\n---\\n\\n***Python Code:***\\n\\nThe best result for the code below is **656ms / 14.5MB** (beats 70% / 90%).\\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)-1\\n        if grid[0][0] or grid[n][n]: return -1\\n        q, grid[0][0] = [0], 1\\n        while len(q):\\n            curr = q.pop(0)\\n            i, j = curr & ((1 << 7) - 1), curr >> 7\\n            if i == n and j == n: return grid[n][n]\\n            for a in range(max(i-1,0),min(i+2,n+1)):\\n                for b in range(max(j-1,0),min(j+2,n+1)):\\n                    if grid[a][b] == 0:\\n                        grid[a][b] = grid[i][j] + 1\\n                        q.append(a + (b << 7))\\n        return -1\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **8ms / 40.0MB** (beats 100% / 90%).\\n```java\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length - 1;\\n        Queue<Integer> q = new ArrayDeque<Integer>();\\n        q.add(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.remove(), i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n                for (int b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.add(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **36 / 18.0MB** (beats 100% / 99%).\\n```c++\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = m - 1;\\n        std::queue<int> q;\\n        q.push(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.front();\\n            q.pop();\\n            int i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = std::max(i-1,0); a <= std::min(i+1,n); a++)\\n                for (int b = std::max(j-1,0); b <= std::min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.push(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nBitwise shift example:\\n\\n   i  =  93 (base 10)  =  1011101 (base 2)\\n   j  =  75 (base 10)  =  1001011 (base 2)\\n\\n   j << 7  =  1001011<<<<<<<     // Bitwise left shift moves the value left\\n           =  10010110000000     // And fills in the space with 0s\\n\\n   i:                           1011101 \\n        j << 7:       +  10010110000000\\n                        ----------------\\n   i + (j << 7):      =  10010111011101 (base 2)\\n                      =            9693 (base 10)\\n```\n```js\\nBitmask example:\\n\\n   1 << 7:               10000000\\n                      -         1\\n                        ----------\\n   (1 << 7) - 1:      =   1111111\\n```\n```js\\nBitwise AND example:\\n\\n      10010111011101\\n   &         1111111\\n     ----------------\\n   =         1011101\\n```\n```javascript\\nvar shortestPathBinaryMatrix = function(grid) {\\n    let n = grid.length - 1, q = [0]\\n    if (grid[0][0] || grid[n][n]) return -1\\n    grid[0][0] = 1\\n    while (q.length) {\\n        let curr = q.shift(), i = curr & (1 << 7) - 1, j = curr >> 7\\n        if (i === n && j === n) return grid[n][n]\\n        for (let a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n            for (let b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                if (grid[a][b] === 0)\\n                    grid[a][b] = grid[i][j] + 1, q.push(a + (b << 7))\\n    }\\n    return -1\\n};\\n```\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)-1\\n        if grid[0][0] or grid[n][n]: return -1\\n        q, grid[0][0] = [0], 1\\n        while len(q):\\n            curr = q.pop(0)\\n            i, j = curr & ((1 << 7) - 1), curr >> 7\\n            if i == n and j == n: return grid[n][n]\\n            for a in range(max(i-1,0),min(i+2,n+1)):\\n                for b in range(max(j-1,0),min(j+2,n+1)):\\n                    if grid[a][b] == 0:\\n                        grid[a][b] = grid[i][j] + 1\\n                        q.append(a + (b << 7))\\n        return -1\\n```\n```java\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length - 1;\\n        Queue<Integer> q = new ArrayDeque<Integer>();\\n        q.add(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.remove(), i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = Math.max(i-1,0); a <= Math.min(i+1,n); a++)\\n                for (int b = Math.max(j-1,0); b <= Math.min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.add(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = m - 1;\\n        std::queue<int> q;\\n        q.push(0);\\n        if (grid[0][0] == 1 || grid[n][n] == 1) return -1;\\n        grid[0][0] = 1;\\n        while (q.size() > 0) {\\n            int curr = q.front();\\n            q.pop();\\n            int i = curr & (1 << 7) - 1, j = curr >> 7;\\n            if (i == n && j == n) return grid[n][n];\\n            for (int a = std::max(i-1,0); a <= std::min(i+1,n); a++)\\n                for (int b = std::max(j-1,0); b <= std::min(j+1,n); b++)\\n                    if (grid[a][b] == 0) {\\n                        grid[a][b] = grid[i][j] + 1;\\n                        q.push(a + (b << 7));\\n                    }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523647,
                "title": "c-breadth-first-search",
                "content": "```\\nclass Solution {\\nprivate:\\n    struct Pos {\\n        int row;\\n        int col;\\n        int dist;\\n    };\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        queue<Pos> q;\\n        q.push(Pos{0, 0, 1});\\n        \\n        while (!q.empty()) {\\n            Pos front = q.front(); q.pop();\\n            \\n            if (front.row >= n || front.row < 0 ||\\n                front.col >= n || front.col < 0 ||\\n                grid[front.row][front.col] == 1) {\\n                continue;\\n            } else if (front.row == n-1 && front.col == n-1) {\\n                return front.dist;\\n            }\\n            \\n            q.push(Pos{front.row+1, front.col, front.dist+1});\\n            q.push(Pos{front.row+1, front.col+1, front.dist+1});\\n            q.push(Pos{front.row+1, front.col-1, front.dist+1});\\n            q.push(Pos{front.row, front.col+1, front.dist+1});\\n            q.push(Pos{front.row, front.col-1, front.dist+1});\\n            q.push(Pos{front.row-1, front.col, front.dist+1});\\n            q.push(Pos{front.row-1, front.col+1, front.dist+1});\\n            q.push(Pos{front.row-1, front.col-1, front.dist+1});\\n            \\n            grid[front.row][front.col] = 1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    struct Pos {\\n        int row;\\n        int col;\\n        int dist;\\n    };\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        queue<Pos> q;\\n        q.push(Pos{0, 0, 1});\\n        \\n        while (!q.empty()) {\\n            Pos front = q.front(); q.pop();\\n            \\n            if (front.row >= n || front.row < 0 ||\\n                front.col >= n || front.col < 0 ||\\n                grid[front.row][front.col] == 1) {\\n                continue;\\n            } else if (front.row == n-1 && front.col == n-1) {\\n                return front.dist;\\n            }\\n            \\n            q.push(Pos{front.row+1, front.col, front.dist+1});\\n            q.push(Pos{front.row+1, front.col+1, front.dist+1});\\n            q.push(Pos{front.row+1, front.col-1, front.dist+1});\\n            q.push(Pos{front.row, front.col+1, front.dist+1});\\n            q.push(Pos{front.row, front.col-1, front.dist+1});\\n            q.push(Pos{front.row-1, front.col, front.dist+1});\\n            q.push(Pos{front.row-1, front.col+1, front.dist+1});\\n            q.push(Pos{front.row-1, front.col-1, front.dist+1});\\n            \\n            grid[front.row][front.col] = 1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405423,
                "title": "python-concise-bfs-memory-usage-better-than-100",
                "content": "Standard BFS using a queue. Use the original grid to store the seen elements.\\n```\\nclass Solution(object):\\n    def shortestPathBinaryMatrix(self, grid):\\n        if grid[0][0] or grid[-1][-1]:\\n            return -1\\n        queue = collections.deque([(0,0,1)])\\n        while queue:\\n            i, j, count = queue.popleft()\\n            if i == len(grid)-1 and j == len(grid[0])-1:\\n                return count\\n            for x, y in ((0,1), (0,-1), (1,0), (-1,0), (1,-1), (-1,1), (1,1), (-1,-1)):\\n                row, col = i + y, j + x\\n                if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and not grid[row][col]:\\n                    queue.append((row, col, count+1))\\n                    grid[row][col] = 1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def shortestPathBinaryMatrix(self, grid):\\n        if grid[0][0] or grid[-1][-1]:\\n            return -1\\n        queue = collections.deque([(0,0,1)])\\n        while queue:\\n            i, j, count = queue.popleft()\\n            if i == len(grid)-1 and j == len(grid[0])-1:\\n                return count\\n            for x, y in ((0,1), (0,-1), (1,0), (-1,0), (1,-1), (-1,1), (1,1), (-1,-1)):\\n                row, col = i + y, j + x\\n                if 0 <= row < len(grid) and 0 <= col < len(grid[0]) and not grid[row][col]:\\n                    queue.append((row, col, count+1))\\n                    grid[row][col] = 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338786,
                "title": "help-submission-fails-but-passes-same-test-case-when-passed-from-console",
                "content": "Hi Guys,\\n\\nI\\'m very stumped by this. Currently when I submit my code, it says I pass all but 3 test cases. The test case it currently says I fail on is this\\n\\n[[0,0,0,0,1,1,1,1,0],[0,1,1,0,0,0,0,1,0],[0,0,1,0,0,0,0,0,0],[1,1,0,0,1,0,0,1,1],[0,0,1,1,1,0,1,0,1],[0,1,0,1,0,0,0,0,0],[0,0,0,1,0,1,0,0,0],[0,1,0,1,1,0,0,0,0],[0,0,0,0,0,1,0,1,0]]\\n\\nIt claims that my submission outputs 12 when the expected answer is 11. However, when I copy that exact test case into my console and just run that specific test case, I get the right answer of 11. Anyone have any idea why this is happening?\\n\\n```\\nclass Solution {\\npublic:\\n    void pushNeighbors(queue<pair<int,int>> & bfs, int r, int c) {\\n        bfs.push(make_pair(r+1, c+1));\\n        bfs.push(make_pair(r, c+1));\\n        bfs.push(make_pair(r-1, c+1));\\n        bfs.push(make_pair(r+1, c));\\n        bfs.push(make_pair(r-1, c));\\n        bfs.push(make_pair(r+1, c-1));\\n        bfs.push(make_pair(r, c-1));\\n        bfs.push(make_pair(r-1, c-1));\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int len, ret = 1, k = grid.size(), visited[k][k] = {0}, r, c;\\n        if (grid[0][0] == 1 || grid[k-1][k-1] == 1) {\\n            return -1;\\n        }\\n        queue<pair<int,int>> bfs;\\n        bfs.push({0,0});\\n        while (!bfs.empty()) {\\n            len = bfs.size(); \\n            for (int i = 0; i < len; i++) {\\n                r = bfs.front().first;\\n                c = bfs.front().second;\\n                bfs.pop();\\n                if (r < 0 || r >= k || c < 0 || c >= k || visited[r][c] == 1) \\n                    continue;\\n                if (r == k-1 && c == k-1)\\n                    return ret;\\n                visited[r][c] = 1;\\n                if(grid[r][c] == 0)\\n                    pushNeighbors(bfs, r, c);\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void pushNeighbors(queue<pair<int,int>> & bfs, int r, int c) {\\n        bfs.push(make_pair(r+1, c+1));\\n        bfs.push(make_pair(r, c+1));\\n        bfs.push(make_pair(r-1, c+1));\\n        bfs.push(make_pair(r+1, c));\\n        bfs.push(make_pair(r-1, c));\\n        bfs.push(make_pair(r+1, c-1));\\n        bfs.push(make_pair(r, c-1));\\n        bfs.push(make_pair(r-1, c-1));\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int len, ret = 1, k = grid.size(), visited[k][k] = {0}, r, c;\\n        if (grid[0][0] == 1 || grid[k-1][k-1] == 1) {\\n            return -1;\\n        }\\n        queue<pair<int,int>> bfs;\\n        bfs.push({0,0});\\n        while (!bfs.empty()) {\\n            len = bfs.size(); \\n            for (int i = 0; i < len; i++) {\\n                r = bfs.front().first;\\n                c = bfs.front().second;\\n                bfs.pop();\\n                if (r < 0 || r >= k || c < 0 || c >= k || visited[r][c] == 1) \\n                    continue;\\n                if (r == k-1 && c == k-1)\\n                    return ret;\\n                visited[r][c] = 1;\\n                if(grid[r][c] == 0)\\n                    pushNeighbors(bfs, r, c);\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586061,
                "title": "dfs-to-bfs-my-step-by-step-thoughts-and-why-dfs-with-memoization-dynamic-programming-fails",
                "content": "# Intuition\\n\\n## First thought: DFS (Simple backtracking and keeping track of visited nodes)\\n- For someone  who hadn\\'t solved shortest path problems like this before, this will seem like a simple DFS/BFS backtracking problem with caching i.e DP.\\n- I choose to solve it using DFS, first coming up with a backtracking solution first, **which gave me TLE.**\\n- TC: O(8^n)\\n- SC: O(n^2) since the longest recursive stack length will be of the length which is of the magnitude equivalent to the entire grid size.\\n\\n```\\nclass Solution:\\n    dirns = []\\n\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        self.dirns = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]] # U, D, L, R, UL, UR, DL, DR\\n        shortestPath = self.recurse(grid, 0,0)\\n\\n        return -1 if shortestPath == float(\\'inf\\') else shortestPath\\n\\n\\n    def recurse(self, A, i, j):\\n        n = len(A) #n x n array\\n        #base cases\\n        if i >= n or j >= n or i < 0 or j < 0 or A[i][j] == 1 or A[i][j] == -1: #out of bounds or no path exists or already visited in current route\\n            return float(\\'inf\\')\\n        \\n        if i == n-1 and j == n-1: #we are on the destination\\n            return 1 if A[i][j] == 0 else float(\\'inf\\')\\n\\n\\n        #recursive case - compute min distance from all 8 dirns\\n        A[i][j] = -1 #marking as already visited in the \\'currently active path\\'\\n        minDist = float(\\'inf\\')\\n        for dirn in self.dirns:\\n            nr = i + dirn[0]\\n            nc = j + dirn[1]\\n            minDist = min(minDist, self.recurse(A, nr, nc))\\n\\n        A[i][j] = 0 #it will always be zero since we have iterated through it\\n        return 1 + minDist\\n\\n```\\n\\n<br>\\n\\n## Second thought: Optimize DFS i.e use DP\\n\\n- I thought simply memoizing the solution would solve my problem, however **the memoized solution failed test cases**.\\n- Here\\'s the memoized solution (Dynamic Programming)\\n\\n```\\nclass Solution:\\n    dirns = []\\n    dp = []\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        #init dirns array and dp array\\n        n = len(grid)\\n        self.dirns = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]] # U, D, L, R, UL, UR, DL, DR\\n        self.dp = [[None for i in range(n)] for j in range(n)]\\n\\n        #compute shortest path\\n        shortestPath = self.recurse(grid, 0,0)\\n        return -1 if shortestPath == float(\\'inf\\') else shortestPath\\n\\n\\n    def recurse(self, A, i, j):\\n        n = len(A) #n x n array\\n        #base cases\\n        if i >= n or j >= n or i < 0 or j < 0 or A[i][j] == 1 or A[i][j] == -1: #out of bounds or no path exists or already visited in current route\\n            return float(\\'inf\\')\\n        \\n        if i == n-1 and j == n-1: #we are on the destination\\n            return 1 if A[i][j] == 0 else float(\\'inf\\')\\n\\n\\n        #recursive case - compute min distance from all 8 dirns\\n        if self.dp[i][j] == None:\\n            A[i][j] = -1 #marking as already visited in the \\'currently active path\\'\\n            minDist = float(\\'inf\\')\\n            for dirn in self.dirns:\\n                nr = i + dirn[0]\\n                nc = j + dirn[1]\\n                minDist = min(minDist, self.recurse(A, nr, nc))\\n\\n            A[i][j] = 0 #it will always be zero since we have iterated through it\\n            self.dp[i][j] = 1 + minDist\\n        \\n        return self.dp[i][j]\\n```\\n\\n## Third Thought: Why does DFS with memoization fail?\\n\\n- I printed out the DP memoization table which made me realize that **DFS with memoization will give you A path, but not THE shortest path for sure each time**\\n- Print out your memoization path for failed test cases to understand this completely.\\n- For eg. the test case below failed (shortest path 10 but result was 11) -> Attached below it is the DP table\\n\\n```\\nTest case:\\n[[0,0,1,0,0,0,0],\\n[0,1,0,0,0,0,1],\\n[0,0,1,0,1,0,0],\\n[0,0,0,1,1,1,0],\\n[1,0,0,1,1,0,0],\\n[1,1,1,1,1,0,1],\\n[0,0,1,0,0,0,0]]\\n\\nDP table:\\n[[11, inf, inf, 7, 7, inf, inf],\\n [10, inf, 8, 7, 6, 6, inf],\\n [10, 9, inf, inf, inf, 5, 5], \\n[10, 10, inf, inf, inf, inf, 4],\\n [inf, inf, inf, inf, inf, 3, 3], \\n[inf, inf, inf, inf, inf, 2, inf], \\n[None, None, inf, inf, inf, 2, None]]\\n\\n```\\n\\n\\n\\n\\n\\n# Correct Approach\\n## BFS (mark visited nodes + nodes currently in queue):\\n- Since BFS naturally branches out depth-first, we will definitively get the shortest path.\\n- Edge cases exist so code is kindof unclean.\\n- Mark [n-1][n-1]th node as \\'1\\' since it\\'s distance would be 1.\\n- Start with a queue of all valid nodes around [n-1][n-1] - for each node check all 8 sides and either \\n    - append unvisited nodes\\n    - ignore invalid nodes or nodes which are currently in the queue\\n    - compare minDistance with valid visit nodes distance\\n- Note: You must mark nodes currently in the queue to prevent them from re-insertion\\n\\n```\\nclass Solution:\\n    from collections import deque\\n\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        #init constants\\n        A = grid\\n        dirns = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]] # U, D, L, R, UL, UR, DL, DR\\n        n = len(A)\\n\\n        #edge case\\n        if (A[0][0] == 1) or (A[n-1][n-1] == 1):\\n            return -1\\n\\n        #setting base distance for n-1,n-1\\n        A[n-1][n-1] = 1\\n\\n        #init queue\\n        queue = deque()\\n        if self.isBound(A, n - 1, n - 2) and A[n - 1][n - 2] == 0:\\n            queue.append([n-1, n-2])\\n        if self.isBound(A, n - 2, n - 1) and A[n - 2][n - 1] == 0:\\n            queue.append([n - 2, n - 1])\\n        if self.isBound(A, n - 2, n - 2) and A[n - 2][n - 2] == 0:\\n            queue.append([n - 2, n - 2])\\n\\n        while len(queue):\\n            #get current node and it\\'s min dist + append neigbours unvisited\\n            curNode = queue.popleft()\\n            r = curNode[0]\\n            c = curNode[1]\\n            minDist = float(\\'inf\\')\\n\\n            #iterate over all 8 neighbors\\n            for dirn in dirns:\\n                nr = r + dirn[0]\\n                nc = c + dirn[1]\\n                \\n                #edge case\\n                if nr == n-1 and nc == n-1:\\n                    minDist = A[nr][nc]\\n                \\n                #normal case\\n                elif self.isBound(A, nr, nc): #if within bounds\\n                    if A[nr][nc] == 0: #unvisited node\\n                        A[nr][nc] = -1\\n                        queue.append([nr, nc])\\n                    elif A[nr][nc] != 1 and A[nr][nc] != -1: #visited node, excluding those currently in queue \\n                        minDist = min(minDist, A[nr][nc])\\n            A[r][c] = minDist + 1\\n\\n        \\n        return A[0][0] if A[0][0] != 0 else -1\\n        \\n\\n\\n    def isBound(self, A, i, j):\\n        n = len(A)\\n        return i >= 0 and i < n and j >= 0 and j < n\\n\\n        \\n```\\n\\n\\n\\n# Complexity\\n- TC: O(n^2) - every node visited at most once\\n\\n\\n- SC: O(n^2) - max size of queue is of this magnitude\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    dirns = []\\n\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        self.dirns = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]] # U, D, L, R, UL, UR, DL, DR\\n        shortestPath = self.recurse(grid, 0,0)\\n\\n        return -1 if shortestPath == float(\\'inf\\') else shortestPath\\n\\n\\n    def recurse(self, A, i, j):\\n        n = len(A) #n x n array\\n        #base cases\\n        if i >= n or j >= n or i < 0 or j < 0 or A[i][j] == 1 or A[i][j] == -1: #out of bounds or no path exists or already visited in current route\\n            return float(\\'inf\\')\\n        \\n        if i == n-1 and j == n-1: #we are on the destination\\n            return 1 if A[i][j] == 0 else float(\\'inf\\')\\n\\n\\n        #recursive case - compute min distance from all 8 dirns\\n        A[i][j] = -1 #marking as already visited in the \\'currently active path\\'\\n        minDist = float(\\'inf\\')\\n        for dirn in self.dirns:\\n            nr = i + dirn[0]\\n            nc = j + dirn[1]\\n            minDist = min(minDist, self.recurse(A, nr, nc))\\n\\n        A[i][j] = 0 #it will always be zero since we have iterated through it\\n        return 1 + minDist\\n\\n```\n```\\nclass Solution:\\n    dirns = []\\n    dp = []\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        #init dirns array and dp array\\n        n = len(grid)\\n        self.dirns = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]] # U, D, L, R, UL, UR, DL, DR\\n        self.dp = [[None for i in range(n)] for j in range(n)]\\n\\n        #compute shortest path\\n        shortestPath = self.recurse(grid, 0,0)\\n        return -1 if shortestPath == float(\\'inf\\') else shortestPath\\n\\n\\n    def recurse(self, A, i, j):\\n        n = len(A) #n x n array\\n        #base cases\\n        if i >= n or j >= n or i < 0 or j < 0 or A[i][j] == 1 or A[i][j] == -1: #out of bounds or no path exists or already visited in current route\\n            return float(\\'inf\\')\\n        \\n        if i == n-1 and j == n-1: #we are on the destination\\n            return 1 if A[i][j] == 0 else float(\\'inf\\')\\n\\n\\n        #recursive case - compute min distance from all 8 dirns\\n        if self.dp[i][j] == None:\\n            A[i][j] = -1 #marking as already visited in the \\'currently active path\\'\\n            minDist = float(\\'inf\\')\\n            for dirn in self.dirns:\\n                nr = i + dirn[0]\\n                nc = j + dirn[1]\\n                minDist = min(minDist, self.recurse(A, nr, nc))\\n\\n            A[i][j] = 0 #it will always be zero since we have iterated through it\\n            self.dp[i][j] = 1 + minDist\\n        \\n        return self.dp[i][j]\\n```\n```\\nTest case:\\n[[0,0,1,0,0,0,0],\\n[0,1,0,0,0,0,1],\\n[0,0,1,0,1,0,0],\\n[0,0,0,1,1,1,0],\\n[1,0,0,1,1,0,0],\\n[1,1,1,1,1,0,1],\\n[0,0,1,0,0,0,0]]\\n\\nDP table:\\n[[11, inf, inf, 7, 7, inf, inf],\\n [10, inf, 8, 7, 6, 6, inf],\\n [10, 9, inf, inf, inf, 5, 5], \\n[10, 10, inf, inf, inf, inf, 4],\\n [inf, inf, inf, inf, inf, 3, 3], \\n[inf, inf, inf, inf, inf, 2, inf], \\n[None, None, inf, inf, inf, 2, None]]\\n\\n```\n```\\nclass Solution:\\n    from collections import deque\\n\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        #init constants\\n        A = grid\\n        dirns = [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]] # U, D, L, R, UL, UR, DL, DR\\n        n = len(A)\\n\\n        #edge case\\n        if (A[0][0] == 1) or (A[n-1][n-1] == 1):\\n            return -1\\n\\n        #setting base distance for n-1,n-1\\n        A[n-1][n-1] = 1\\n\\n        #init queue\\n        queue = deque()\\n        if self.isBound(A, n - 1, n - 2) and A[n - 1][n - 2] == 0:\\n            queue.append([n-1, n-2])\\n        if self.isBound(A, n - 2, n - 1) and A[n - 2][n - 1] == 0:\\n            queue.append([n - 2, n - 1])\\n        if self.isBound(A, n - 2, n - 2) and A[n - 2][n - 2] == 0:\\n            queue.append([n - 2, n - 2])\\n\\n        while len(queue):\\n            #get current node and it\\'s min dist + append neigbours unvisited\\n            curNode = queue.popleft()\\n            r = curNode[0]\\n            c = curNode[1]\\n            minDist = float(\\'inf\\')\\n\\n            #iterate over all 8 neighbors\\n            for dirn in dirns:\\n                nr = r + dirn[0]\\n                nc = c + dirn[1]\\n                \\n                #edge case\\n                if nr == n-1 and nc == n-1:\\n                    minDist = A[nr][nc]\\n                \\n                #normal case\\n                elif self.isBound(A, nr, nc): #if within bounds\\n                    if A[nr][nc] == 0: #unvisited node\\n                        A[nr][nc] = -1\\n                        queue.append([nr, nc])\\n                    elif A[nr][nc] != 1 and A[nr][nc] != -1: #visited node, excluding those currently in queue \\n                        minDist = min(minDist, A[nr][nc])\\n            A[r][c] = minDist + 1\\n\\n        \\n        return A[0][0] if A[0][0] != 0 else -1\\n        \\n\\n\\n    def isBound(self, A, i, j):\\n        n = len(A)\\n        return i >= 0 and i < n and j >= 0 and j < n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585355,
                "title": "c-easy-solution-using-bfs-approach-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The intuition behind the code is to use a BFS algorithm to explore the binary matrix. The BFS algorithm starts at the top-left corner of the matrix and explores all of its neighbors. If a neighbor is the destination node, then the algorithm returns the distance from the source node to the destination node. Otherwise, the algorithm adds the neighbor to the queue and repeats the process. The algorithm terminates when the queue is empty.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initialize a queue and add the top-left corner of the matrix to the queue.\\n- While the queue is not empty:\\n1) Remove the first element from the queue and let it be the current node.\\n2) If the current node is the destination node, then return the distance from the source node to the destination node.\\n3) For each neighbor of the current node:\\n--> If the neighbor is not visited, then add the neighbor to the queue and mark it as visited.\\n- Return -1 if the destination node is not reachable.\\n# Complexity\\n- Time complexity: $$O(N*M)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dirs{{1,1},{0,1},{1,0},{0,-1},{-1,0},{-1,-1},{-1,1},{1,-1}};\\n    \\n    bool isValid(int& x, int& y, int n, int m){\\n        if(x>=0 && x<n && y>=0 && y<m){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if(n==0 || m==0 || grid[0][0] != 0){\\n            return -1;\\n        }\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        grid[0][0] = 1;\\n\\n        int step = 1;\\n        while(!q.empty()){\\n            int N = q.size();\\n            \\n            while(N--){\\n                auto curr = q.front();\\n                q.pop();\\n\\n                int x = curr.first;\\n                int y = curr.second;\\n\\n                if(x == n-1 && y == m-1){\\n                    return step;\\n                }\\n\\n                for(auto dir : dirs){\\n                    int dx = x + dir[0];\\n                    int dy = y + dir[1];\\n\\n                    if(isValid(dx,dy,n,m) && grid[dx][dy] == 0){\\n                        q.push({dx,dy});\\n                        grid[dx][dy] = 1;\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/5f6bb6db-09f4-4851-8cae-8532bafd97e1_1685610542.5999708.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dirs{{1,1},{0,1},{1,0},{0,-1},{-1,0},{-1,-1},{-1,1},{1,-1}};\\n    \\n    bool isValid(int& x, int& y, int n, int m){\\n        if(x>=0 && x<n && y>=0 && y<m){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if(n==0 || m==0 || grid[0][0] != 0){\\n            return -1;\\n        }\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        grid[0][0] = 1;\\n\\n        int step = 1;\\n        while(!q.empty()){\\n            int N = q.size();\\n            \\n            while(N--){\\n                auto curr = q.front();\\n                q.pop();\\n\\n                int x = curr.first;\\n                int y = curr.second;\\n\\n                if(x == n-1 && y == m-1){\\n                    return step;\\n                }\\n\\n                for(auto dir : dirs){\\n                    int dx = x + dir[0];\\n                    int dy = y + dir[1];\\n\\n                    if(isValid(dx,dy,n,m) && grid[dx][dy] == 0){\\n                        q.push({dx,dy});\\n                        grid[dx][dy] = 1;\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585294,
                "title": "c-solution-bfs",
                "content": "**Algorithm**\\n1. simple bfs \\n2. 8 -way traversal using 2- loops (from -1 to 1)\\n3. manipulating the grid itself after the traversal (so that it can\\'t be traversed again)\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] or grid[grid.size()-1][grid[0].size()-1]==1) return -1;\\n        if(grid.size()==1) return 1;\\n        \\n        int dist=1;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                auto [i , j] = q.front();\\n                q.pop();\\n                if(i==grid.size()-1 and j==grid[0].size()-1){\\n                    return dist;\\n                }\\n                for(int k=-1;k<=1;k++){\\n                    for(int l=-1;l<=1;l++){\\n                        int x = i+k;\\n                        int y=  j+l;\\n                        if(x<0 or x>=grid.size() or y<0 or y>= grid[0].size() or grid[x][y]==1)continue;\\n                        q.push({x,y});\\n                        grid[x][y] = 1;\\n                    }\\n                }\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] or grid[grid.size()-1][grid[0].size()-1]==1) return -1;\\n        if(grid.size()==1) return 1;\\n        \\n        int dist=1;\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                auto [i , j] = q.front();\\n                q.pop();\\n                if(i==grid.size()-1 and j==grid[0].size()-1){\\n                    return dist;\\n                }\\n                for(int k=-1;k<=1;k++){\\n                    for(int l=-1;l<=1;l++){\\n                        int x = i+k;\\n                        int y=  j+l;\\n                        if(x<0 or x>=grid.size() or y<0 or y>= grid[0].size() or grid[x][y]==1)continue;\\n                        q.push({x,y});\\n                        grid[x][y] = 1;\\n                    }\\n                }\\n            }\\n            dist++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584707,
                "title": "bfs-c-straight-to-the-point-very-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size();\\n        queue<pair<int,pair<int,int>>>qu;\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        if(grid[0][0] == 1) return -1;\\n        qu.push({0,{0,1}});\\n        int mins = INT_MAX;\\n        visited[0][0] = 1;\\n        while(!qu.empty()){\\n            int r = qu.front().first,c = qu.front().second.first,takentime = qu.front().second.second;\\n            qu.pop();\\n            if(r == m-1 && c==n-1){\\n                mins = min(mins,takentime);\\n                continue;\\n            }\\n            for(int i=-1;i<=1;i++){\\n                for(int z=-1;z<=1;z++){\\n                    int row = r+z,col = c+i;\\n                    if(row == r && col == c) continue;\\n                    else if(row >=0 && row < m && col >= 0 && col<n && grid[row][col] == 0 && !visited[row][col] ){\\n                         visited[row][col] =1;\\n                        qu.push({row,{col,takentime+1}});\\n                    }\\n                }\\n            }\\n        }\\n        return mins == INT_MAX?-1:mins;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(),n = grid[0].size();\\n        queue<pair<int,pair<int,int>>>qu;\\n        vector<vector<int>>visited(m,vector<int>(n,0));\\n        if(grid[0][0] == 1) return -1;\\n        qu.push({0,{0,1}});\\n        int mins = INT_MAX;\\n        visited[0][0] = 1;\\n        while(!qu.empty()){\\n            int r = qu.front().first,c = qu.front().second.first,takentime = qu.front().second.second;\\n            qu.pop();\\n            if(r == m-1 && c==n-1){\\n                mins = min(mins,takentime);\\n                continue;\\n            }\\n            for(int i=-1;i<=1;i++){\\n                for(int z=-1;z<=1;z++){\\n                    int row = r+z,col = c+i;\\n                    if(row == r && col == c) continue;\\n                    else if(row >=0 && row < m && col >= 0 && col<n && grid[row][col] == 0 && !visited[row][col] ){\\n                         visited[row][col] =1;\\n                        qu.push({row,{col,takentime+1}});\\n                    }\\n                }\\n            }\\n        }\\n        return mins == INT_MAX?-1:mins;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584590,
                "title": "java-bfs-complete-explanation-with-images",
                "content": "# Intuition\\nIt is simple breadth first search (BFS) traversal of the matrix.\\n\\nBFS is chosen over depth-first search (DFS) because `DFS may not guarantee finding the shortest path in certain scenarios.`\\n\\nTo illustrate this, let\\'s consider an example. Suppose we have the following binary matrix:\\n\\n<img src = \"https://assets.leetcode.com/users/images/0df0223a-d89f-4b5c-8557-602cd32235ce_1685593391.510974.png\" height=\"500px\" width=\"500px\"></img>\\n\\nDFS may take the following path to reach the destination first.\\n\\n<img src = \"https://assets.leetcode.com/users/images/47f4b121-62b9-481b-8201-f2a8958892e3_1685593347.8459778.png\" height=\"500px\" width=\"500px\"></img>\\n\\nNow, all the nodes in the above path will be marked as visited.\\n\\n<img src = \"https://assets.leetcode.com/users/images/9099e570-1a54-48f3-b8eb-fa3795f71349_1685594258.6301134.png\" height=\"500px\" width=\"500px\"></img>\\n\\n\\nThis results in the other paths passing through these nodes to be ignored. Hence the actual shortest path is ignored.\\n\\n<img src = \"https://assets.leetcode.com/users/images/61c1084a-68ec-4310-9080-9505701a2dcf_1685594331.9876206.png\" height=\"500px\" width=\"500px\"></img>\\n\\nOn the other hand, BFS systematically visits all neighboring cells at the current distance level before moving to the next distance level. This way, it guarantees finding the shortest path if one exists.\\n\\n# Approach\\nIt starts at the source cell `(0,0)` and performs a `BFS traversal`, exploring all reachable neighboring cells which are `0`. It marks the current cell as visited and adds all the unvisited neighbouring `0` cells in the queue.\\n\\nThe process continues until either the bottom-right cell is reached or the queue is empty. If the destination is reached, the distance of that cell is returned as the `length of the shortest path`. Otherwise, if the destination is not reachable, `-1` is returned.\\n\\n# Complexity\\n- Time complexity: $$O(N \\\\times M)$$ \\n\\n- Space complexity: $$O(N \\\\times M)$$ for the queue used for BFS.\\n\\n# Code\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n\\n        if (grid[0][0]==1){\\n            return -1;\\n        }\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0,1});\\n        grid[0][0]=1;\\n        int ct = 0;\\n        while(!q.isEmpty()) {\\n            int[] cur = q.remove();\\n            int i = cur[0];\\n            int j = cur[1];\\n            int ans = cur[2];\\n            if(j==grid[0].length-1 && i==grid.length-1)return ans;\\n            for(int x = -1; x <= 1;x ++) {\\n                for(int y = -1; y <= 1; y ++){\\n                    if(i+x<0 || j+y<0){\\n                        continue;\\n                    }\\n                    if(i+x==grid[0].length || j+y==grid[0].length){\\n                        continue;\\n                    }\\n                    if(grid[i+x][j+y]==0){\\n                        q.add(new int[]{i+x,j+y,ans+1});\\n                        grid[i+x][j+y]=1;\\n                        ct++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n\\n        if (grid[0][0]==1){\\n            return -1;\\n        }\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0,1});\\n        grid[0][0]=1;\\n        int ct = 0;\\n        while(!q.isEmpty()) {\\n            int[] cur = q.remove();\\n            int i = cur[0];\\n            int j = cur[1];\\n            int ans = cur[2];\\n            if(j==grid[0].length-1 && i==grid.length-1)return ans;\\n            for(int x = -1; x <= 1;x ++) {\\n                for(int y = -1; y <= 1; y ++){\\n                    if(i+x<0 || j+y<0){\\n                        continue;\\n                    }\\n                    if(i+x==grid[0].length || j+y==grid[0].length){\\n                        continue;\\n                    }\\n                    if(grid[i+x][j+y]==0){\\n                        q.add(new int[]{i+x,j+y,ans+1});\\n                        grid[i+x][j+y]=1;\\n                        ct++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584180,
                "title": "o-n-2-c-bfs-approach-detailed-explanation-with-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe BFS algorithm is used to explore the grid and find the shortest path from the starting cell to the target cell. It visits cells in a breadth-first manner, i.e., it explores all the neighbors of a cell before moving on to the next level of cells.\\n\\nThe dist matrix is used to store the minimum distance to reach each cell from the starting cell. It is initialized with -1 to indicate that no path has been found yet.\\n\\nBy enqueueing the starting cell (0, 0) with a distance of 1, the BFS algorithm starts exploring the grid from the top-left cell.\\nThe BFS algorithm iteratively visits the cells, updates their distances in the dist matrix, and enqueues their valid neighbors until it reaches the target cell (n-1, n-1) or there are no more reachable cells.\\n\\nIf the distance to the target cell remains -1 after the BFS traversal, it means that there is no valid path from the starting cell to the target cell, so -1 is returned.\\n\\nOtherwise, the distance stored in dist[n-1][n-1] represents the shortest path length from the starting cell to the target cell, which is returned as the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnitialize a dist matrix of the same size as the input grid. Each cell in the dist matrix will store the minimum distance required to reach that cell from the starting cell (0, 0). Initially, all distances are set to -1 to indicate that no path has been found yet.\\n\\nCreate a queue q1 to perform BFS. Enqueue the starting cell (0, 0) into q1 and set its distance as 1 in the dist matrix.\\n\\nWhile the queue is not empty, perform the following steps:\\n\\nDequeue a cell (i, j) from q1.\\nExplore all eight possible neighbors of the current cell in the grid.\\nIf a neighbor cell is valid (within grid boundaries and empty) and its distance is still -1, update its distance in the dist matrix as dist[i][j] + 1 and enqueue the neighbor cell into q1. This step ensures that each cell is visited only once and the distance to reach it is minimized.\\n\\nAfter the BFS traversal, if the distance to the bottom-right cell (n-1, n-1) is still -1, it means no path was found, so return -1. Otherwise, return the distance stored in dist[n-1][n-1], which represents the shortest path length from (0, 0) to (n-1, n-1).\\n\\n# Complexity\\n- Time Complexity:\\nThe code uses a Breadth-First Search (BFS) algorithm to explore the grid. In the worst case, every cell in the grid needs to be visited. Since each cell is visited only once, the time complexity is O(n^2), where n is the size of the grid.\\n\\nSpace Complexity:\\nThe space complexity is determined by the additional data structures used in the code.\\n\\nThe dist matrix has a size of n x n, requiring O(n^2) space.\\nThe q1 queue can store at most n^2 elements in the worst case, as all cells of the grid are enqueued. Therefore, it also requires O(n^2) space.\\nHence, the overall space complexity is O(n^2).\\n\\nIn summary, the time complexity is O(n^2) and the space complexity is O(n^2).\\n\\n# Code\\n```\\nclass Solution {\\n    int n;\\n    \\n    bool isValid(int i, int j, vector<vector<int>>& grid){\\n        if(i>=0 && j>=0 && i<n && j<n && grid[i][j] == 0) return true;\\n        else return false;\\n    }\\n    \\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        n = grid[0].size();\\n        vector<vector<int>> dist(n, vector<int>(n, -1));\\n        \\n        queue<pair<int, int>> q1;\\n        \\n        if(grid[0][0] == 0){\\n            q1.push({0, 0});\\n            dist[0][0] = 1;\\n        }\\n        else return -1;\\n        \\n        vector<int> x = {-1, +1, 0, 0, -1, +1, -1, +1};\\n        vector<int> y = {0, 0, -1, +1, -1, +1, +1, -1};\\n        \\n        while(!q1.empty()){\\n            pair<int, int> curr = q1.front();\\n            q1.pop();\\n            \\n            for(int k=0; k<8; k++){\\n                int newX = curr.first + x[k];\\n                int newY = curr.second + y[k];\\n                \\n                if(isValid(newX, newY, grid) && dist[newX][newY]==-1){\\n                    dist[newX][newY] = dist[curr.first][curr.second]+1;\\n                    q1.push({newX, newY});\\n                }\\n            }\\n        }\\n        \\n        if(dist[n-1][n-1] == -1)\\n            return -1;\\n        \\n        return dist[n-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    \\n    bool isValid(int i, int j, vector<vector<int>>& grid){\\n        if(i>=0 && j>=0 && i<n && j<n && grid[i][j] == 0) return true;\\n        else return false;\\n    }\\n    \\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        n = grid[0].size();\\n        vector<vector<int>> dist(n, vector<int>(n, -1));\\n        \\n        queue<pair<int, int>> q1;\\n        \\n        if(grid[0][0] == 0){\\n            q1.push({0, 0});\\n            dist[0][0] = 1;\\n        }\\n        else return -1;\\n        \\n        vector<int> x = {-1, +1, 0, 0, -1, +1, -1, +1};\\n        vector<int> y = {0, 0, -1, +1, -1, +1, +1, -1};\\n        \\n        while(!q1.empty()){\\n            pair<int, int> curr = q1.front();\\n            q1.pop();\\n            \\n            for(int k=0; k<8; k++){\\n                int newX = curr.first + x[k];\\n                int newY = curr.second + y[k];\\n                \\n                if(isValid(newX, newY, grid) && dist[newX][newY]==-1){\\n                    dist[newX][newY] = dist[curr.first][curr.second]+1;\\n                    q1.push({newX, newY});\\n                }\\n            }\\n        }\\n        \\n        if(dist[n-1][n-1] == -1)\\n            return -1;\\n        \\n        return dist[n-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584112,
                "title": "swift-bfs",
                "content": "**BFS (accepted answer)**\\n```\\nclass Solution {\\n    func shortestPathBinaryMatrix(_ grid: [[Int]]) -> Int {\\n        guard grid[0][0] == 0 else { return -1 }\\n        let deltas = [[-1, -1], [-1, 1], [1,-1], [1,1], [-1,0], [1,0], [0,1], [0,-1]]\\n        var bfs = [[0,0]], pathSize = 1, grid = grid\\n        while !bfs.isEmpty {\\n            guard !bfs.contains([grid.count-1, grid.count-1]) else { return pathSize }\\n            bfs = bfs.flatMap { node in\\n                deltas.compactMap { delta in\\n                    let (x, y) = (node[0] + delta[0], node[1] + delta[1])\\n                    guard grid.indices ~= x && grid.indices ~= y && grid[y][x] == 0 else { return nil }\\n                    grid[y][x] = 1\\n                    return [x,y]\\n                }\\n            }\\n            pathSize += 1\\n        }\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func shortestPathBinaryMatrix(_ grid: [[Int]]) -> Int {\\n        guard grid[0][0] == 0 else { return -1 }\\n        let deltas = [[-1, -1], [-1, 1], [1,-1], [1,1], [-1,0], [1,0], [0,1], [0,-1]]\\n        var bfs = [[0,0]], pathSize = 1, grid = grid\\n        while !bfs.isEmpty {\\n            guard !bfs.contains([grid.count-1, grid.count-1]) else { return pathSize }\\n            bfs = bfs.flatMap { node in\\n                deltas.compactMap { delta in\\n                    let (x, y) = (node[0] + delta[0], node[1] + delta[1])\\n                    guard grid.indices ~= x && grid.indices ~= y && grid[y][x] == 0 else { return nil }\\n                    grid[y][x] = 1\\n                    return [x,y]\\n                }\\n            }\\n            pathSize += 1\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584054,
                "title": "easy-python-solution-using-bfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        vis=[[0]*n for _ in range(m)]\\n        if grid[0][0]==1:\\n            return -1\\n        queue=[(0,0,1)]\\n        vis[0][0]=1\\n        while queue:\\n            x,y,d=queue.pop(0)\\n            if x==m-1 and y==n-1:\\n                return d\\n            # print(x,y,d)\\n            for i in range(-1,2):\\n                for j in range(-1,2):\\n                    if 0<=x+i<m and 0<=y+j<n:\\n                        if vis[x+i][y+j]==0 and grid[x+i][y+j]==0:\\n                            queue.append((x+i,y+j,d+1))\\n                            vis[x+i][y+j]=1\\n        return -1\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        vis=[[0]*n for _ in range(m)]\\n        if grid[0][0]==1:\\n            return -1\\n        queue=[(0,0,1)]\\n        vis[0][0]=1\\n        while queue:\\n            x,y,d=queue.pop(0)\\n            if x==m-1 and y==n-1:\\n                return d\\n            # print(x,y,d)\\n            for i in range(-1,2):\\n                for j in range(-1,2):\\n                    if 0<=x+i<m and 0<=y+j<n:\\n                        if vis[x+i][y+j]==0 and grid[x+i][y+j]==0:\\n                            queue.append((x+i,y+j,d+1))\\n                            vis[x+i][y+j]=1\\n        return -1\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488767,
                "title": "c-dfs-bfs-solutions-t-c-o-n-2-s-c-o-n-2",
                "content": "```\\nclass Solution\\n{\\n\\n    /*\\n        Brute Force - Using DFS\\n        Time Complexity = O(7^(n^2))\\n        Space Complexity = O(n^2)\\n    */\\n\\nprivate:\\n    int n;\\n    int res = INT_MAX;\\n\\n    vector<pair<int, int>> dirc = {{+1, 0}, {-1, 0}, {0, +1}, {0, -1}, {-1, -1}, {-1, +1}, {+1, -1}, {+1, +1}};\\n\\n    bool isSafe(int i, int j, vector<vector<int>> &grid)\\n    {\\n        return i >= 0 and i < n and j >= 0 and j < n and grid[i][j] == 0;\\n    }\\n\\n    void helper(int i, int j, int cellsVisited, vector<vector<int>> &grid)\\n    {\\n        if (i == n - 1 and j == n - 1)\\n        {\\n            res = min(res, cellsVisited);\\n            return;\\n        }\\n\\n        grid[i][j] = 2;\\n\\n        for (auto dir : dirc)\\n        {\\n            int newX = i + dir.first;\\n            int newY = j + dir.second;\\n\\n            if (isSafe(newX, newY, grid))\\n            {\\n                helper(newX, newY, cellsVisited + 1, grid);\\n            }\\n        }\\n\\n        grid[i][j] = 0;\\n    }\\n\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>> &grid)\\n    {\\n        n = grid.size();\\n\\n        if (grid[0][0] || grid[n - 1][n - 1])\\n            return -1;\\n\\n        // i, j, cellsVisited, grid\\n        helper(0, 0, 1, grid);\\n\\n        if (res == INT_MAX)\\n            return -1;\\n\\n        return res;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\n    \\n    /*\\n        Optimal Solution - Using BFS\\n        Time Complexity = O(n^2)\\n        Space Complexity = O(n^2)\\n    */\\n    \\nprivate:\\n    bool isValid(int i, int j, vector<vector<int>>& grid){\\n        return i>=0 and i<grid.size() and j>=0 and j<grid.size() and grid[i][j]==0;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0]) return -1;\\n        \\n        int res;\\n        \\n        queue<pair<int, int>> q1;\\n        q1.push({0, 0});\\n        grid[0][0] = 2;\\n        \\n        int n = grid.size();\\n        \\n        vector<pair<int, int>> dirc = {{+1, 0}, {-1, 0}, {0, +1}, {0, -1},\\n                                       {-1, -1}, {+1, -1}, {-1, +1}, {+1, +1}};\\n        \\n        while(!q1.empty()){\\n            int size = q1.size();\\n            res++;\\n            \\n            while(size--){\\n                int i = q1.front().first;\\n                int j = q1.front().second;\\n                q1.pop();\\n\\n                if(i==n-1 and j==n-1) return res;\\n\\n                for(auto dir : dirc){\\n                    int newX = i+dir.first;\\n                    int newY = j+dir.second;\\n                    \\n                    if(isValid(newX, newY, grid)){\\n                        grid[newX][newY] = 2;\\n                        q1.push({newX, newY});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    /*\\n        Brute Force - Using DFS\\n        Time Complexity = O(7^(n^2))\\n        Space Complexity = O(n^2)\\n    */\\n\\nprivate:\\n    int n;\\n    int res = INT_MAX;\\n\\n    vector<pair<int, int>> dirc = {{+1, 0}, {-1, 0}, {0, +1}, {0, -1}, {-1, -1}, {-1, +1}, {+1, -1}, {+1, +1}};\\n\\n    bool isSafe(int i, int j, vector<vector<int>> &grid)\\n    {\\n        return i >= 0 and i < n and j >= 0 and j < n and grid[i][j] == 0;\\n    }\\n\\n    void helper(int i, int j, int cellsVisited, vector<vector<int>> &grid)\\n    {\\n        if (i == n - 1 and j == n - 1)\\n        {\\n            res = min(res, cellsVisited);\\n            return;\\n        }\\n\\n        grid[i][j] = 2;\\n\\n        for (auto dir : dirc)\\n        {\\n            int newX = i + dir.first;\\n            int newY = j + dir.second;\\n\\n            if (isSafe(newX, newY, grid))\\n            {\\n                helper(newX, newY, cellsVisited + 1, grid);\\n            }\\n        }\\n\\n        grid[i][j] = 0;\\n    }\\n\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>> &grid)\\n    {\\n        n = grid.size();\\n\\n        if (grid[0][0] || grid[n - 1][n - 1])\\n            return -1;\\n\\n        // i, j, cellsVisited, grid\\n        helper(0, 0, 1, grid);\\n\\n        if (res == INT_MAX)\\n            return -1;\\n\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\n    /*\\n        Optimal Solution - Using BFS\\n        Time Complexity = O(n^2)\\n        Space Complexity = O(n^2)\\n    */\\n    \\nprivate:\\n    bool isValid(int i, int j, vector<vector<int>>& grid){\\n        return i>=0 and i<grid.size() and j>=0 and j<grid.size() and grid[i][j]==0;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0]) return -1;\\n        \\n        int res;\\n        \\n        queue<pair<int, int>> q1;\\n        q1.push({0, 0});\\n        grid[0][0] = 2;\\n        \\n        int n = grid.size();\\n        \\n        vector<pair<int, int>> dirc = {{+1, 0}, {-1, 0}, {0, +1}, {0, -1},\\n                                       {-1, -1}, {+1, -1}, {-1, +1}, {+1, +1}};\\n        \\n        while(!q1.empty()){\\n            int size = q1.size();\\n            res++;\\n            \\n            while(size--){\\n                int i = q1.front().first;\\n                int j = q1.front().second;\\n                q1.pop();\\n\\n                if(i==n-1 and j==n-1) return res;\\n\\n                for(auto dir : dirc){\\n                    int newX = i+dir.first;\\n                    int newY = j+dir.second;\\n                    \\n                    if(isValid(newX, newY, grid)){\\n                        grid[newX][newY] = 2;\\n                        q1.push({newX, newY});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218492,
                "title": "beat-97-99-c-easy-optimized-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n       int m= grid.size();\\n       int n= grid[0].size();\\n       vector<vector<int>>visited(m,vector<int>(n,0));\\n     \\n       queue<pair<pair<int,int>,int>>q;  ///queue< row, col, distance>\\n       if(grid[0][0]==1){\\n           return -1;\\n       }\\n       q.push({{0,0},1});\\n        visited[0][0]=1;\\n        int delrow[]= {-1, +1, 0, 0, -1, +1, -1, +1};\\n        int delcol[]= {0, 0, -1, +1, -1, +1, +1, -1};\\n        while(!q.empty()){\\n            auto it= q.front();\\n            q.pop();\\n            int row= it.first.first;\\n            int col= it.first.second;\\n            int distance= it.second;\\n            if(row==m-1 && col==n-1){\\n                return distance;\\n            }\\n            for(int i=0;i<8;i++){\\n                int nrow=row+delrow[i];\\n                int ncol=col+delcol[i];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && grid[nrow][ncol]==0 && !visited[nrow][ncol]){\\n                \\n                    grid[nrow][ncol]=1;\\n                        visited[nrow][ncol]=1;\\n                        q.push({{nrow,ncol},distance+1});\\n                }\\n            }\\n        }\\n\\n    return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n       int m= grid.size();\\n       int n= grid[0].size();\\n       vector<vector<int>>visited(m,vector<int>(n,0));\\n     \\n       queue<pair<pair<int,int>,int>>q;  ///queue< row, col, distance>\\n       if(grid[0][0]==1){\\n           return -1;\\n       }\\n       q.push({{0,0},1});\\n        visited[0][0]=1;\\n        int delrow[]= {-1, +1, 0, 0, -1, +1, -1, +1};\\n        int delcol[]= {0, 0, -1, +1, -1, +1, +1, -1};\\n        while(!q.empty()){\\n            auto it= q.front();\\n            q.pop();\\n            int row= it.first.first;\\n            int col= it.first.second;\\n            int distance= it.second;\\n            if(row==m-1 && col==n-1){\\n                return distance;\\n            }\\n            for(int i=0;i<8;i++){\\n                int nrow=row+delrow[i];\\n                int ncol=col+delcol[i];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && grid[nrow][ncol]==0 && !visited[nrow][ncol]){\\n                \\n                    grid[nrow][ncol]=1;\\n                        visited[nrow][ncol]=1;\\n                        q.push({{nrow,ncol},distance+1});\\n                }\\n            }\\n        }\\n\\n    return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140944,
                "title": "bfs-traversal-clean-code-with-comments-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //solving this question using BFS traversal\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if(n==m && n==1){  //for the edge cases such as [[0]] && [[1]]\\n            if(grid[0][0]) return -1;\\n            return 1;\\n        }\\n        if(grid[0][0]!=0 || grid[n-1][n-1]!=0) return -1;\\n\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<pair<int,int>,int>> q;  //to store grid location and dist simultaneously\\n        q.push({{0,0},1}); //src and initializing dist as 1\\n        vis[0][0]=1;\\n        int ans = INT_MAX;\\n\\n        int dRow[]= {-1,0,1,0,-1,-1,1,1};  //since it is 8 directional connected so all the cases etc. (-1,0),(0,-1)\\n        int dCol[] ={0,-1,0,1,-1,1,1,-1};\\n\\n        while(!q.empty()){\\n            int row = q.front().first.first;  \\n            int col = q.front().first.second;  //generating all the possible grid rows and colums\\n            int dist = q.front().second;\\n            q.pop();\\n            for(int i = 0;i<8;i++){\\n                int nxtRow = row + dRow[i];\\n                int nxtCol = col + dCol[i];\\n                if(nxtRow>=0 && nxtRow<n && nxtCol>=0 && nxtCol<m && !vis[nxtRow][nxtCol] && grid[nxtRow][nxtCol]==0)\\n                { //checking the boundaries and whether node is visited or not and if grid is already 0\\n                    vis[nxtRow][nxtCol]=1;\\n                    if(nxtRow==n-1 && nxtCol==m-1) return min(ans,dist+1); //the destination node\\n                    q.push({{nxtRow,nxtCol},dist+1}); //if the node is not the destination (n-1,m-1) then push it to to queue with increasing the distance\\n                }\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //solving this question using BFS traversal\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        if(n==m && n==1){  //for the edge cases such as [[0]] && [[1]]\\n            if(grid[0][0]) return -1;\\n            return 1;\\n        }\\n        if(grid[0][0]!=0 || grid[n-1][n-1]!=0) return -1;\\n\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<pair<int,int>,int>> q;  //to store grid location and dist simultaneously\\n        q.push({{0,0},1}); //src and initializing dist as 1\\n        vis[0][0]=1;\\n        int ans = INT_MAX;\\n\\n        int dRow[]= {-1,0,1,0,-1,-1,1,1};  //since it is 8 directional connected so all the cases etc. (-1,0),(0,-1)\\n        int dCol[] ={0,-1,0,1,-1,1,1,-1};\\n\\n        while(!q.empty()){\\n            int row = q.front().first.first;  \\n            int col = q.front().first.second;  //generating all the possible grid rows and colums\\n            int dist = q.front().second;\\n            q.pop();\\n            for(int i = 0;i<8;i++){\\n                int nxtRow = row + dRow[i];\\n                int nxtCol = col + dCol[i];\\n                if(nxtRow>=0 && nxtRow<n && nxtCol>=0 && nxtCol<m && !vis[nxtRow][nxtCol] && grid[nxtRow][nxtCol]==0)\\n                { //checking the boundaries and whether node is visited or not and if grid is already 0\\n                    vis[nxtRow][nxtCol]=1;\\n                    if(nxtRow==n-1 && nxtCol==m-1) return min(ans,dist+1); //the destination node\\n                    q.push({{nxtRow,nxtCol},dist+1}); //if the node is not the destination (n-1,m-1) then push it to to queue with increasing the distance\\n                }\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087339,
                "title": "well-commented-bfs-queue",
                "content": "# Intuition\\nMentioned throughout code in form of $$comments$$\\n\\n# Approach\\nBreadth-First-Search by pushing coordinates in queue and then checking neighbours for desired conditions.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans =1;\\n        if (grid[0][0]==1 || grid[n-1][n-1]==1) { return -1; }\\n        queue<pair<int, int>> q;\\n            q.push({0,0});          //pushing the coordinates of \\'0\\' so that we can check in their 8 directions \\n            grid[0][0]=1;           //we will mark this visited by marking it \\'1\\'\\n        while (!q.empty()){\\n            int size = q.size();\\n            //considering it as a level itself and further looking in all directions           \\n            for (int k=0; k<size; k++){\\n                int row = q.front().first;\\n                int col = q.front().second;\\n                grid[row][col]=1;\\n                // cout << row << \" \" << col << endl;\\n                q.pop();\\n                //returning when we have reached the destination\\n                if (row==n-1 && col==n-1){ \\n                    return ans;\\n                }\\n                //a loop to check in all the eight directions of the ones in queue \\n                //and marking them \\'1\\' to avoid repitition\\n                for (int i=row-1; i<row+2; i++){\\n                    for (int j=col-1; j<col+2; j++){\\n                        if (i>=0 && i<n && j>=0 && j<n && grid[i][j]==0){\\n                            q.push({i, j});\\n                            grid[i][j]=1;\\n                        }\\n                    }\\n                }\\n            }\\n            ans ++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans =1;\\n        if (grid[0][0]==1 || grid[n-1][n-1]==1) { return -1; }\\n        queue<pair<int, int>> q;\\n            q.push({0,0});          //pushing the coordinates of \\'0\\' so that we can check in their 8 directions \\n            grid[0][0]=1;           //we will mark this visited by marking it \\'1\\'\\n        while (!q.empty()){\\n            int size = q.size();\\n            //considering it as a level itself and further looking in all directions           \\n            for (int k=0; k<size; k++){\\n                int row = q.front().first;\\n                int col = q.front().second;\\n                grid[row][col]=1;\\n                // cout << row << \" \" << col << endl;\\n                q.pop();\\n                //returning when we have reached the destination\\n                if (row==n-1 && col==n-1){ \\n                    return ans;\\n                }\\n                //a loop to check in all the eight directions of the ones in queue \\n                //and marking them \\'1\\' to avoid repitition\\n                for (int i=row-1; i<row+2; i++){\\n                    for (int j=col-1; j<col+2; j++){\\n                        if (i>=0 && i<n && j>=0 && j<n && grid[i][j]==0){\\n                            q.push({i, j});\\n                            grid[i][j]=1;\\n                        }\\n                    }\\n                }\\n            }\\n            ans ++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3031721,
                "title": "no-dijkstra-s-bfs-easy-explanation",
                "content": "# Intuition\\nIf we examine it closely, this question is just an extension of \"shortest path in an undirected graph with unit weights\".\\n\\n# Approach\\nHere we do not need to use a priority queue like in Dijkstra\\'s because all distances are unit weights. We will do simple BFS traversal in all 8 directions.\\n\\nI have use a queue of pairs of pair, which will store\\n{{row,col}, distance}. everytime we find a smaller distance we will update it and push it into the queue.\\n\\nIn the end if the distance is still infinity it means that the node is unreachable, else we can assume it is reachable and return the shortest distance.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(grid[0][0] || grid[n-1][n-1])\\n        return -1;\\n\\n        vector<vector<int>>dist(n,vector<int>(n,INT_MAX));\\n        dist[0][0]=0;\\n        queue<pair<pair<int,int>,int>>q;\\n        q.push({{0,0},1});\\n\\n        int delrow[]={-1,0,1,0,-1,-1,1,1};\\n        int delcol[]={0,1,0,-1,-1,+1,-1,+1};\\n        while(!q.empty())\\n        {\\n            int row=q.front().first.first;\\n            int col=q.front().first.second;\\n            int dis=q.front().second;\\n            q.pop();\\n            for(int i=0;i<8;i++)\\n            {\\n                int nrow=row+delrow[i];\\n                int ncol=col+delcol[i];\\n\\n                if(nrow>=0 && nrow<n && ncol>=0&& ncol<n && \\n                !grid[nrow][ncol])\\n                {\\n                    if(dis+1<dist[nrow][ncol])\\n                    {\\n                        dist[nrow][ncol]=dis+1;\\n                        q.push({{nrow,ncol},dist[nrow][ncol]});\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(dist[n-1][n-1]==INT_MAX)\\n        return -1;\\n\\n        return dist[n-1][n-1];\\n\\n\\n    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(grid[0][0] || grid[n-1][n-1])\\n        return -1;\\n\\n        vector<vector<int>>dist(n,vector<int>(n,INT_MAX));\\n        dist[0][0]=0;\\n        queue<pair<pair<int,int>,int>>q;\\n        q.push({{0,0},1});\\n\\n        int delrow[]={-1,0,1,0,-1,-1,1,1};\\n        int delcol[]={0,1,0,-1,-1,+1,-1,+1};\\n        while(!q.empty())\\n        {\\n            int row=q.front().first.first;\\n            int col=q.front().first.second;\\n            int dis=q.front().second;\\n            q.pop();\\n            for(int i=0;i<8;i++)\\n            {\\n                int nrow=row+delrow[i];\\n                int ncol=col+delcol[i];\\n\\n                if(nrow>=0 && nrow<n && ncol>=0&& ncol<n && \\n                !grid[nrow][ncol])\\n                {\\n                    if(dis+1<dist[nrow][ncol])\\n                    {\\n                        dist[nrow][ncol]=dis+1;\\n                        q.push({{nrow,ncol},dist[nrow][ncol]});\\n                    }\\n                }\\n            }\\n        }\\n\\n        if(dist[n-1][n-1]==INT_MAX)\\n        return -1;\\n\\n        return dist[n-1][n-1];\\n\\n\\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669984,
                "title": "simple-bfs-striver-approach",
                "content": "```\\nclass Solution {\\n    bool isValid(int row, int col, int n, int m) {\\n        return row >= 0 && row < n && col >= 0 && col < m;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n\\t\\n        if(grid[0][0] == 1) return -1;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\t\\t\\n        vector<vector<int> > distance(n, vector<int> (m, 1e9));\\n        distance[0][0] = 0;\\n        \\n        queue<pair<int, pair<int, int> > > q;\\n        q.push({1,{0, 0}});\\n        \\n        int delrow[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int delcol[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n        \\n        while(!q.empty()) {\\n            auto it = q.front();\\n            int dis = it.first;\\n            int row = it.second.first;\\n            int col = it.second.second;\\n            \\n            q.pop();\\n            \\n            if(row == n - 1 && col == m - 1) return dis;\\n            \\n            for(int k = 0; k < 8; k++) {\\n                int nrow = row + delrow[k];\\n                int ncol = col + delcol[k];\\n                \\n                if(isValid(nrow, ncol, n, m) && grid[nrow][ncol] == 0 && (dis + 1 < distance[nrow][ncol])) {\\n                    distance[nrow][ncol] = dis + 1;\\n                    q.push({dis + 1, {nrow, ncol}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool isValid(int row, int col, int n, int m) {\\n        return row >= 0 && row < n && col >= 0 && col < m;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n\\t\\n        if(grid[0][0] == 1) return -1;\\n        \\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\t\\t\\n        vector<vector<int> > distance(n, vector<int> (m, 1e9));\\n        distance[0][0] = 0;\\n        \\n        queue<pair<int, pair<int, int> > > q;\\n        q.push({1,{0, 0}});\\n        \\n        int delrow[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int delcol[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n        \\n        while(!q.empty()) {\\n            auto it = q.front();\\n            int dis = it.first;\\n            int row = it.second.first;\\n            int col = it.second.second;\\n            \\n            q.pop();\\n            \\n            if(row == n - 1 && col == m - 1) return dis;\\n            \\n            for(int k = 0; k < 8; k++) {\\n                int nrow = row + delrow[k];\\n                int ncol = col + delcol[k];\\n                \\n                if(isValid(nrow, ncol, n, m) && grid[nrow][ncol] == 0 && (dis + 1 < distance[nrow][ncol])) {\\n                    distance[nrow][ncol] = dis + 1;\\n                    q.push({dis + 1, {nrow, ncol}});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045997,
                "title": "c-bfs-solution-easy-to-understand",
                "content": "```\\n//BFS solution\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = 0;\\n        vector<vector<bool>> visited (n, vector<bool>(n, 0));\\n        queue<pair<int, int>> que;\\n        if(!grid[0][0])\\n        {\\n            que.push({0, 0});\\n            visited[0][0] = 1;\\n        }\\n        \\n        //BFS\\n        while(!que.empty())\\n        {\\n            int size = que.size();\\n            ans++;\\n            \\n            //iterate untill we cover all the nodes\\n            while(size--)\\n            {\\n                int i = que.front().first, j = que.front().second;\\n                que.pop();\\n                if(i==n-1 && j==n-1) return ans;\\n                \\n                //find 0 in all 8 directions\\n                for(int r=i-1; r<=i+1; r++)\\n                    {\\n                        for(int c=j-1; c<=j+1; c++)\\n                        {\\n                            if(isValid(r, c, n, grid, visited))\\n                            {\\n                                que.push({r, c});\\n                                visited[r][c] = 1;\\n                            }\\n                        }\\n                    }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    bool isValid(int r, int c, int n, vector<vector<int>>& grid, vector<vector<bool>> &visited){\\n        if(r<0 || c<0 || r>=n || c>=n || visited[r][c]==1 || grid[r][c]!=0)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n//BFS solution\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(), ans = 0;\\n        vector<vector<bool>> visited (n, vector<bool>(n, 0));\\n        queue<pair<int, int>> que;\\n        if(!grid[0][0])\\n        {\\n            que.push({0, 0});\\n            visited[0][0] = 1;\\n        }\\n        \\n        //BFS\\n        while(!que.empty())\\n        {\\n            int size = que.size();\\n            ans++;\\n            \\n            //iterate untill we cover all the nodes\\n            while(size--)\\n            {\\n                int i = que.front().first, j = que.front().second;\\n                que.pop();\\n                if(i==n-1 && j==n-1) return ans;\\n                \\n                //find 0 in all 8 directions\\n                for(int r=i-1; r<=i+1; r++)\\n                    {\\n                        for(int c=j-1; c<=j+1; c++)\\n                        {\\n                            if(isValid(r, c, n, grid, visited))\\n                            {\\n                                que.push({r, c});\\n                                visited[r][c] = 1;\\n                            }\\n                        }\\n                    }\\n                \\n            }\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    bool isValid(int r, int c, int n, vector<vector<int>>& grid, vector<vector<bool>> &visited){\\n        if(r<0 || c<0 || r>=n || c>=n || visited[r][c]==1 || grid[r][c]!=0)\\n            return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045236,
                "title": "c-bfs-explanation",
                "content": "Use BFS to solve this problem. \\nDefine the ```sturct _rc``` for ```queue<_rc>``` and for the 8 directions ```dir```.\\nRun the BFS and return current length of BFS when running algorithm arrive ```grid[n-1][n-1]```\\n\\n\\n```C++\\nclass Solution {\\npublic:\\n    struct _rc{ int row; int col; };\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        queue<_rc> currQ, nextQ;\\n        if(grid[0][0]++>0) return -1;\\n        currQ.push(_rc{0,0});\\n        int n = grid.size(), len = 1;        \\n        vector<_rc> dir = {        \\n            _rc{-1,-1},_rc{-1,+0},_rc{-1,+1},\\n            _rc{+0,-1},           _rc{+0,+1},\\n            _rc{+1,-1},_rc{+1,+0},_rc{+1,+1}\\n        };\\n        while(!currQ.empty()) {\\n            _rc rc = currQ.front();\\n            if(rc.row==n-1 && rc.col==n-1) return len;\\n            currQ.pop();\\n            for(auto& d : dir) {\\n                int row = rc.row+d.row, col = rc.col+d.col;\\n                if( row<0 || col<0 || row>=n || col>=n) continue;\\n                if(grid[row][col]++==0) nextQ.push(_rc{row,col});\\n            }\\n            if(currQ.empty()) { \\n                swap(currQ, nextQ);\\n                len++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```sturct _rc```\n```queue<_rc>```\n```dir```\n```grid[n-1][n-1]```\n```C++\\nclass Solution {\\npublic:\\n    struct _rc{ int row; int col; };\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        queue<_rc> currQ, nextQ;\\n        if(grid[0][0]++>0) return -1;\\n        currQ.push(_rc{0,0});\\n        int n = grid.size(), len = 1;        \\n        vector<_rc> dir = {        \\n            _rc{-1,-1},_rc{-1,+0},_rc{-1,+1},\\n            _rc{+0,-1},           _rc{+0,+1},\\n            _rc{+1,-1},_rc{+1,+0},_rc{+1,+1}\\n        };\\n        while(!currQ.empty()) {\\n            _rc rc = currQ.front();\\n            if(rc.row==n-1 && rc.col==n-1) return len;\\n            currQ.pop();\\n            for(auto& d : dir) {\\n                int row = rc.row+d.row, col = rc.col+d.col;\\n                if( row<0 || col<0 || row>=n || col>=n) continue;\\n                if(grid[row][col]++==0) nextQ.push(_rc{row,col});\\n            }\\n            if(currQ.empty()) { \\n                swap(currQ, nextQ);\\n                len++;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2045196,
                "title": "python3-easy-to-understand-bfs-with-explanation",
                "content": "\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        dirs = [(0,1),(1,0),(1,1),(-1,-1),(-1,0),(0,-1),(-1,1),(1,-1)] # the 8 directions we are allowed for us to move\\n        \\n        if grid[0][0] != 0:\\n            return -1\\n        \\n        que = deque()\\n        que.append((0,0,1))\\n        step = float(\"inf\")\\n        grid[0][0] = 1 # mark (0,0) as visited so as to avoid visiting it again\\n        \\n        # now start iterative bfs\\n        while que:\\n            i,j,st = que.popleft()\\n            \\n            if (i,j) == (n-1,n-1): # we\\'ve reached the last index so... the step we toop must be minimum\\n                step = min(step, st)\\n                continue\\n            \\n            for i_add,j_add in dirs:\\n                new_i = i + i_add\\n                new_j = j + j_add\\n                # first check if the neightbours of (i,j) ar all valid\\n                # their validity is checked if (new_i,new_j) is a within the limits of \\n                # the grid and grid[new_i][new_j] must be 0, since we can only move trough the 0s\\n                \\n                if(0<= new_i< n and \\n                   0 <= new_j < n and \\n                   grid[new_i][new_j] == 0):\\n                    # add every valid neighbours to the que and mark them as visited to \\n                    # avoid visiting them again\\n                    que.append((new_i,new_j,st+1))\\n                    grid[new_i][new_j] = 1\\n        \\n        # if the step is changed from float(\"inf\") then we have reached the\\n        # last index somewere along our bfs\\n        return step if step != float(\"inf\") else -1",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid[0])\\n        dirs = [(0,1),(1,0),(1,1),(-1,-1),(-1,0),(0,-1),(-1,1),(1,-1)] # the 8 directions we are allowed for us to move\\n        \\n        if grid[0][0] != 0:\\n            return -1\\n        \\n        que = deque()\\n        que.append((0,0,1))\\n        step = float(\"inf\")\\n        grid[0][0] = 1 # mark (0,0) as visited so as to avoid visiting it again\\n        \\n        # now start iterative bfs\\n        while que:\\n            i,j,st = que.popleft()\\n            \\n            if (i,j) == (n-1,n-1): # we\\'ve reached the last index so... the step we toop must be minimum\\n                step = min(step, st)\\n                continue\\n            \\n            for i_add,j_add in dirs:\\n                new_i = i + i_add\\n                new_j = j + j_add\\n                # first check if the neightbours of (i,j) ar all valid\\n                # their validity is checked if (new_i,new_j) is a within the limits of \\n                # the grid and grid[new_i][new_j] must be 0, since we can only move trough the 0s\\n                \\n                if(0<= new_i< n and \\n                   0 <= new_j < n and \\n                   grid[new_i][new_j] == 0):\\n                    # add every valid neighbours to the que and mark them as visited to \\n                    # avoid visiting them again\\n                    que.append((new_i,new_j,st+1))\\n                    grid[new_i][new_j] = 1\\n        \\n        # if the step is changed from float(\"inf\") then we have reached the\\n        # last index somewere along our bfs\\n        return step if step != float(\"inf\") else -1",
                "codeTag": "Python3"
            },
            {
                "id": 2044063,
                "title": "simple-bfs-readable-code",
                "content": "```\\nclass Solution {\\n    class Pair{\\n        int row;\\n        int col;\\n        int level;\\n        Pair(int row,int col,int level){\\n            this.row = row;\\n            this.col = col;\\n            this.level = level;\\n        }\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid.length];\\n        int[][] dirs = {{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}};\\n        \\n        Queue<Pair> Q = new ArrayDeque<>();\\n        if(grid[0][0] == 0) Q.add(new Pair(0,0,1));\\n        \\n        int shortestPath = Integer.MAX_VALUE;\\n        while(!Q.isEmpty()){\\n            Pair remove = Q.remove();\\n            int row = remove.row;\\n            int col = remove.col;\\n            int level = remove.level;\\n            if(row == grid.length-1 && col == grid.length-1){\\n                shortestPath = Math.min(shortestPath, level);\\n                continue;\\n            }\\n            for(int[] dir: dirs){\\n                int newRow = row + dir[0];\\n                int newCol = col + dir[1];\\n                if(newRow>=0 \\n                   && newCol >= 0 \\n                   && newRow < grid.length \\n                   && newCol < grid.length \\n                   && !visited[ newRow][ newCol]\\n                   && grid[ newRow][ newCol] == 0)\\n                {\\n                    Q.add(new Pair(newRow, newCol, level+1));\\n                    visited[newRow][newCol] = true;\\n                }\\n            }\\n        }\\n        return (shortestPath == Integer.MAX_VALUE) ? -1: shortestPath;\\n    }\\n}\\n```\\nHappy LeetCoding",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int row;\\n        int col;\\n        int level;\\n        Pair(int row,int col,int level){\\n            this.row = row;\\n            this.col = col;\\n            this.level = level;\\n        }\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        boolean[][] visited = new boolean[grid.length][grid.length];\\n        int[][] dirs = {{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1},{0,-1},{-1,-1}};\\n        \\n        Queue<Pair> Q = new ArrayDeque<>();\\n        if(grid[0][0] == 0) Q.add(new Pair(0,0,1));\\n        \\n        int shortestPath = Integer.MAX_VALUE;\\n        while(!Q.isEmpty()){\\n            Pair remove = Q.remove();\\n            int row = remove.row;\\n            int col = remove.col;\\n            int level = remove.level;\\n            if(row == grid.length-1 && col == grid.length-1){\\n                shortestPath = Math.min(shortestPath, level);\\n                continue;\\n            }\\n            for(int[] dir: dirs){\\n                int newRow = row + dir[0];\\n                int newCol = col + dir[1];\\n                if(newRow>=0 \\n                   && newCol >= 0 \\n                   && newRow < grid.length \\n                   && newCol < grid.length \\n                   && !visited[ newRow][ newCol]\\n                   && grid[ newRow][ newCol] == 0)\\n                {\\n                    Q.add(new Pair(newRow, newCol, level+1));\\n                    visited[newRow][newCol] = true;\\n                }\\n            }\\n        }\\n        return (shortestPath == Integer.MAX_VALUE) ? -1: shortestPath;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043829,
                "title": "clean-and-fast-java-solution",
                "content": "At each `0` we need to check all `8` directions. If any of the `8` places is a `1` or already has been visited we do not need to visit it. \\n\\n**Trick for reducing space**: Mark visited nodes as `1` because if a point is already reached by some other path which takes less number of steps then why visit it again?\\n\\nI have created a `dir`(direction) array and a `isPointValid` functions as helpers\\n\\n```\\nclass Solution {\\n    private int[] dir = {-1,0,-1,-1,1,0,1,1,-1};\\n    private int n;\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        this.n = grid.length;\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        if(grid[0][0] == 0) queue.offer(new int[]{0,0});\\n        grid[0][0] = 1;\\n        int steps = 1;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                int[] cur_point = queue.poll();\\n                int x = cur_point[0];\\n                int y = cur_point[1];\\n                if(x == n-1 && y == n-1) return steps;\\n                for(int d=0;d<dir.length-1;d++){\\n                    int next_x = dir[d] + x;\\n                    int next_y = dir[d+1] + y;\\n                    if(isPointValid(next_x,next_y) && grid[next_x][next_y]==0){\\n                        queue.offer(new int[]{next_x,next_y});\\n                        grid[next_x][next_y] = 1;\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n    private boolean isPointValid(int i, int j){\\n        return i<n && j<n && i>=0 && j>=0;\\n    }\\n}\\n```\\nPlease Upvote if you like the solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] dir = {-1,0,-1,-1,1,0,1,1,-1};\\n    private int n;\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        this.n = grid.length;\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        if(grid[0][0] == 0) queue.offer(new int[]{0,0});\\n        grid[0][0] = 1;\\n        int steps = 1;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0;i<size;i++){\\n                int[] cur_point = queue.poll();\\n                int x = cur_point[0];\\n                int y = cur_point[1];\\n                if(x == n-1 && y == n-1) return steps;\\n                for(int d=0;d<dir.length-1;d++){\\n                    int next_x = dir[d] + x;\\n                    int next_y = dir[d+1] + y;\\n                    if(isPointValid(next_x,next_y) && grid[next_x][next_y]==0){\\n                        queue.offer(new int[]{next_x,next_y});\\n                        grid[next_x][next_y] = 1;\\n                    }\\n                }\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n    private boolean isPointValid(int i, int j){\\n        return i<n && j<n && i>=0 && j>=0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043745,
                "title": "c-easy-understanding-clean-bfs",
                "content": "> BFS Algorithm:\\n\\n```\\n/*\\n   8 moves, if you are at i,j\\n   \\n\\ti-1,j-1    i-1,j    i-1,j+1\\n\\ti,j-1      i,j      i,j+1\\n\\ti+1,j+1    i+1,j    i+1,j+1\\n*/\\n```\\n\\n```\\nclass Solution {\\npublic:\\n // check that i and j will be inside the grid and is not visited already and have not value 1\\n    bool check(int i,int j,map<pair<int,int>,bool>& visited,vector<vector<int>>& grid){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i >= 0 && j >= 0 && i < n && j < m && grid[i][j] != 1 && (visited.find({i,j}) == visited.end())){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<vector<int>> Q;\\n        Q.push({0,0,0}); // i,j,dist\\n        map<pair<int,int>,bool> visited;\\n        visited[{0,0}] = true;\\n        while(!Q.empty()){\\n            auto curr = Q.front();Q.pop();\\n            int i = curr[0],j = curr[1],dist = curr[2];\\n            if(i == n-1 && j == m-1){\\n                return dist+1;\\n            }\\n            // left\\n            if(check(i,j-1,visited,grid)){\\n                visited[{i,j-1}] = true;\\n                Q.push({i,j-1,dist+1});\\n            }\\n            // right\\n            if(check(i,j+1,visited,grid)){\\n                visited[{i,j+1}] = true;\\n                Q.push({i,j+1,dist+1});\\n            }\\n            // up \\n            if(check(i-1,j,visited,grid)){\\n                visited[{i-1,j}] = true;\\n                Q.push({i-1,j,dist+1});\\n            }\\n            // down \\n            if(check(i+1,j,visited,grid)){\\n                visited[{i+1,j}] = true;\\n                Q.push({i+1,j,dist+1});\\n            }\\n            // leftUp\\n            if(check(i-1,j-1,visited,grid)){\\n                visited[{i-1,j-1}] = true;\\n                Q.push({i-1,j-1,dist+1});\\n            }\\n            // rightUp \\n            if(check(i-1,j+1,visited,grid)){\\n                visited[{i-1,j+1}] = true;\\n                Q.push({i-1,j+1,dist+1});\\n            }\\n            // leftDown \\n            if(check(i+1,j-1,visited,grid)){\\n                visited[{i+1,j-1}] = true;\\n                Q.push({i+1,j-1,dist+1});\\n            }\\n            // rightDown \\n            if(check(i+1,j+1,visited,grid)){\\n                visited[{i+1,j+1}] = true;\\n                Q.push({i+1,j+1,dist+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/*\\n   8 moves, if you are at i,j\\n   \\n\\ti-1,j-1    i-1,j    i-1,j+1\\n\\ti,j-1      i,j      i,j+1\\n\\ti+1,j+1    i+1,j    i+1,j+1\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n // check that i and j will be inside the grid and is not visited already and have not value 1\\n    bool check(int i,int j,map<pair<int,int>,bool>& visited,vector<vector<int>>& grid){\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        if(i >= 0 && j >= 0 && i < n && j < m && grid[i][j] != 1 && (visited.find({i,j}) == visited.end())){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        queue<vector<int>> Q;\\n        Q.push({0,0,0}); // i,j,dist\\n        map<pair<int,int>,bool> visited;\\n        visited[{0,0}] = true;\\n        while(!Q.empty()){\\n            auto curr = Q.front();Q.pop();\\n            int i = curr[0],j = curr[1],dist = curr[2];\\n            if(i == n-1 && j == m-1){\\n                return dist+1;\\n            }\\n            // left\\n            if(check(i,j-1,visited,grid)){\\n                visited[{i,j-1}] = true;\\n                Q.push({i,j-1,dist+1});\\n            }\\n            // right\\n            if(check(i,j+1,visited,grid)){\\n                visited[{i,j+1}] = true;\\n                Q.push({i,j+1,dist+1});\\n            }\\n            // up \\n            if(check(i-1,j,visited,grid)){\\n                visited[{i-1,j}] = true;\\n                Q.push({i-1,j,dist+1});\\n            }\\n            // down \\n            if(check(i+1,j,visited,grid)){\\n                visited[{i+1,j}] = true;\\n                Q.push({i+1,j,dist+1});\\n            }\\n            // leftUp\\n            if(check(i-1,j-1,visited,grid)){\\n                visited[{i-1,j-1}] = true;\\n                Q.push({i-1,j-1,dist+1});\\n            }\\n            // rightUp \\n            if(check(i-1,j+1,visited,grid)){\\n                visited[{i-1,j+1}] = true;\\n                Q.push({i-1,j+1,dist+1});\\n            }\\n            // leftDown \\n            if(check(i+1,j-1,visited,grid)){\\n                visited[{i+1,j-1}] = true;\\n                Q.push({i+1,j-1,dist+1});\\n            }\\n            // rightDown \\n            if(check(i+1,j+1,visited,grid)){\\n                visited[{i+1,j+1}] = true;\\n                Q.push({i+1,j+1,dist+1});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043449,
                "title": "easy-and-neat-python-solution",
                "content": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n   \\n        visited = [[0 for _ in range(len(grid))] for _ in range(len(grid))]\\n        queue = deque()\\n        queue.append([0, 0, 1])\\n        \\n        while len(queue) > 0:\\n            x, y, currLength = queue.popleft()\\n            \\n            if x < 0 or x >= len(grid):\\n                continue\\n            if y < 0 or y >= len(grid):\\n                continue\\n            if visited[x][y] == 1:\\n                continue\\n            if grid[x][y] == 1:\\n                continue\\n            if x == len(grid) - 1 and y == len(grid) - 1:\\n                if grid[x][y] == 0:\\n                    return currLength\\n                continue\\n                \\n            visited[x][y] = 1\\n                \\n            for i in range(x-1, x+2):\\n                for j in range(y-1, y+2):\\n                    queue.append([i, j, currLength+1])\\n                    \\n        return -1\\n                \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n   \\n        visited = [[0 for _ in range(len(grid))] for _ in range(len(grid))]\\n        queue = deque()\\n        queue.append([0, 0, 1])\\n        \\n        while len(queue) > 0:\\n            x, y, currLength = queue.popleft()\\n            \\n            if x < 0 or x >= len(grid):\\n                continue\\n            if y < 0 or y >= len(grid):\\n                continue\\n            if visited[x][y] == 1:\\n                continue\\n            if grid[x][y] == 1:\\n                continue\\n            if x == len(grid) - 1 and y == len(grid) - 1:\\n                if grid[x][y] == 0:\\n                    return currLength\\n                continue\\n                \\n            visited[x][y] = 1\\n                \\n            for i in range(x-1, x+2):\\n                for j in range(y-1, y+2):\\n                    queue.append([i, j, currLength+1])\\n                    \\n        return -1\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997421,
                "title": "shouldn-t-be-the-bfs-space-complexity-o-m-n-instead-of-o-m-n",
                "content": "I found many answers state the space complexity of the BFS solution is O(MN), where M is rows and N is cols.\\nBut since we expand to neighbors while removing visited nodes, shouldn\\'t the max space complexity O(M+N)?\\nLet me know if I state anything wrong.\\n\\n```\\nclass Solution {\\npublic:\\n    // O(M * N), O(M + N)\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if (grid.empty() || grid[0].empty()) {\\n            return -1;\\n        }\\n        int m = grid.size(), n = grid[0].size();        \\n        if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1) {\\n            return -1;\\n        }\\n        \\n        queue<pair<int, int>> qs;\\n        qs.push({0, 0});\\n        grid[0][0] = 1;\\n        int step = 1;\\n        while (!qs.empty()) {\\n            int sz = qs.size();\\n            while (sz--) {\\n                pair<int, int> f = qs.front();\\n                qs.pop();\\n                \\n                if (f.first == m - 1 && f.second == n - 1) {\\n                    return step;\\n                }\\n\\n                for (int i = -1; i <= 1; ++i) {\\n                    for (int j = -1; j <= 1; ++j) {\\n                        int newRow = f.first + i, newCol = f.second + j;\\n                        if ((i == 0 && j == 0) || newRow < 0 ||  newRow >= m\\n                            || newCol < 0 ||  newCol >= n || grid[newRow][newCol] == 1) {\\n                            continue;\\n                        }\\n                        qs.push({newRow, newCol});\\n                        grid[newRow][newCol] = 1;                        \\n                    }\\n                }\\n            }\\n            ++step;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // O(M * N), O(M + N)\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if (grid.empty() || grid[0].empty()) {\\n            return -1;\\n        }\\n        int m = grid.size(), n = grid[0].size();        \\n        if (grid[0][0] == 1 || grid[m - 1][n - 1] == 1) {\\n            return -1;\\n        }\\n        \\n        queue<pair<int, int>> qs;\\n        qs.push({0, 0});\\n        grid[0][0] = 1;\\n        int step = 1;\\n        while (!qs.empty()) {\\n            int sz = qs.size();\\n            while (sz--) {\\n                pair<int, int> f = qs.front();\\n                qs.pop();\\n                \\n                if (f.first == m - 1 && f.second == n - 1) {\\n                    return step;\\n                }\\n\\n                for (int i = -1; i <= 1; ++i) {\\n                    for (int j = -1; j <= 1; ++j) {\\n                        int newRow = f.first + i, newCol = f.second + j;\\n                        if ((i == 0 && j == 0) || newRow < 0 ||  newRow >= m\\n                            || newCol < 0 ||  newCol >= n || grid[newRow][newCol] == 1) {\\n                            continue;\\n                        }\\n                        qs.push({newRow, newCol});\\n                        grid[newRow][newCol] = 1;                        \\n                    }\\n                }\\n            }\\n            ++step;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850880,
                "title": "c-well-commented-easy-to-understand-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    // checking weather the index vot violating upper boungs\\n    bool isValid(int x, int y, int xl,  int yl) {\\n        if(x >= 0 && x < xl && y>=0 && y < yl) return true; return false; \\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        // dist 2D vector which will hold distance of source to every other element in the grid\\n        vector<vector<int>> dist(n, vector<int>(n, INT_MAX));\\n        dist[0][0] = 0;\\n        \\n        // handling cases when we can\\'t reach destination if the start or end is not visited\\n        if(grid[n-1][n-1] == 1 || grid[0][0] == 1) return -1;\\n        queue<pair<int, int>> q1;\\n        // pushing src index as from we need to find dist of every other index with src index\\n        q1.push({ 0, 0});\\n        \\n        // as here we can go in any the eight directed which is up, down, left, right, top left, top right, bottom left, bottom right\\n        \\n        vector<int> dx = {1, 0, 0, -1, 1 ,-1 ,1 ,-1};\\n        vector<int> dy = {0, 1, -1, 0, 1, -1, -1 , 1};\\n        \\n        while(!q1.empty()) {\\n            pair<int, int> p1 = q1.front();\\n            q1.pop();\\n            int x = p1.first;\\n            int y = p1.second;\\n            // checking the nerigbours\\n            for(int i=0;i<8;i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                \\n                // checking if neighbour has valid index\\n                if(isValid(nx, ny, n, n)) {\\n                    // checking if any update in path in possible\\n                    if((dist[nx][ny] > dist[x][y] + 1) && grid[nx][ny] == 0) {\\n                        // updating the path length and pushing the index into queue to check if any further update possible                       \\n                        dist[nx][ny] = dist[x][y] + 1;\\n                        q1.push({ nx, ny });\\n                    }  \\n                } \\n                \\n            }\\n            \\n        }\\n        \\n        // if dist[n-1][n-1] is not changed then we return -1 or else we return the number of elements in the shortest path found\\n        return dist[n-1][n-1] == INT_MAX ? -1 : dist[n-1][n-1] + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // checking weather the index vot violating upper boungs\\n    bool isValid(int x, int y, int xl,  int yl) {\\n        if(x >= 0 && x < xl && y>=0 && y < yl) return true; return false; \\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        // dist 2D vector which will hold distance of source to every other element in the grid\\n        vector<vector<int>> dist(n, vector<int>(n, INT_MAX));\\n        dist[0][0] = 0;\\n        \\n        // handling cases when we can\\'t reach destination if the start or end is not visited\\n        if(grid[n-1][n-1] == 1 || grid[0][0] == 1) return -1;\\n        queue<pair<int, int>> q1;\\n        // pushing src index as from we need to find dist of every other index with src index\\n        q1.push({ 0, 0});\\n        \\n        // as here we can go in any the eight directed which is up, down, left, right, top left, top right, bottom left, bottom right\\n        \\n        vector<int> dx = {1, 0, 0, -1, 1 ,-1 ,1 ,-1};\\n        vector<int> dy = {0, 1, -1, 0, 1, -1, -1 , 1};\\n        \\n        while(!q1.empty()) {\\n            pair<int, int> p1 = q1.front();\\n            q1.pop();\\n            int x = p1.first;\\n            int y = p1.second;\\n            // checking the nerigbours\\n            for(int i=0;i<8;i++) {\\n                int nx = x + dx[i];\\n                int ny = y + dy[i];\\n                \\n                // checking if neighbour has valid index\\n                if(isValid(nx, ny, n, n)) {\\n                    // checking if any update in path in possible\\n                    if((dist[nx][ny] > dist[x][y] + 1) && grid[nx][ny] == 0) {\\n                        // updating the path length and pushing the index into queue to check if any further update possible                       \\n                        dist[nx][ny] = dist[x][y] + 1;\\n                        q1.push({ nx, ny });\\n                    }  \\n                } \\n                \\n            }\\n            \\n        }\\n        \\n        // if dist[n-1][n-1] is not changed then we return -1 or else we return the number of elements in the shortest path found\\n        return dist[n-1][n-1] == INT_MAX ? -1 : dist[n-1][n-1] + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816185,
                "title": "why-should-we-use-bfs-in-these-kind-of-problems",
                "content": "\\tAlways use BFS in these kind of problem because bfs always gives the shortest path in undirected, unweighted graph\\n\\t\\n\\t\\n\\tstruct Pair{\\n        int r;\\n        int c;\\n        int dist;\\n    };\\n    vector<vector<int>> dir = {\\n                                {-1,0}, {-1,1},{0,1},{1,1},\\n                                {1,0},{1,-1},{0,-1},{-1,-1}\\n                             };\\n    \\n    bool isSafe(int r,int c,int n,int m){\\n        if(r < 0 or c < 0 or r >= n or c >= m){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        queue<Pair> qu;\\n        if(grid[0][0]==1){\\n            return -1;\\n        }\\n        qu.push({0,0,1});\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        while(!qu.empty()){\\n            \\n            Pair p = qu.front();\\n            qu.pop();\\n            \\n            if(p.r == n-1 and p.c == m-1){\\n                \\n                return p.dist;\\n            }\\n            if(visited[p.r][p.c])continue;\\n            \\n            visited[p.r][p.c] = true;\\n            \\n            for(int i = 0 ;i<dir.size();i++){\\n                int x = p.r + dir[i][0];\\n                int y = p.c + dir[i][1];\\n                \\n                if(isSafe(x,y,n,m) and !visited[x][y] and grid[x][y]==0){\\n                    qu.push({x,y,p.dist + 1});\\n                }\\n            }\\n        \\n        }\\n        return -1;\\n        \\n    }",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "\\tAlways use BFS in these kind of problem because bfs always gives the shortest path in undirected, unweighted graph\\n\\t\\n\\t\\n\\tstruct Pair{\\n        int r;\\n        int c;\\n        int dist;\\n    };\\n    vector<vector<int>> dir = {\\n                                {-1,0}, {-1,1},{0,1},{1,1},\\n                                {1,0},{1,-1},{0,-1},{-1,-1}\\n                             };\\n    \\n    bool isSafe(int r,int c,int n,int m){\\n        if(r < 0 or c < 0 or r >= n or c >= m){\\n            return false;\\n        }\\n        \\n        return true;\\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        queue<Pair> qu;\\n        if(grid[0][0]==1){\\n            return -1;\\n        }\\n        qu.push({0,0,1});\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        vector<vector<bool>> visited(n,vector<bool>(m,false));\\n        while(!qu.empty()){\\n            \\n            Pair p = qu.front();\\n            qu.pop();\\n            \\n            if(p.r == n-1 and p.c == m-1){\\n                \\n                return p.dist;\\n            }\\n            if(visited[p.r][p.c])continue;\\n            \\n            visited[p.r][p.c] = true;\\n            \\n            for(int i = 0 ;i<dir.size();i++){\\n                int x = p.r + dir[i][0];\\n                int y = p.c + dir[i][1];\\n                \\n                if(isSafe(x,y,n,m) and !visited[x][y] and grid[x][y]==0){\\n                    qu.push({x,y,p.dist + 1});\\n                }\\n            }\\n        \\n        }\\n        return -1;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1809171,
                "title": "simple-c-bfs-solution-commented-code",
                "content": "We are just applying BFS to every cell that has 0.\\n**Note:  the first time we visit a cell that would be the minimum distance of that cell from the starting position**\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(); //Taking the grid size\\n        \\n        if(grid[0][0]!=0 || grid[n-1][n-1]!=0)\\n            return -1; //checking if the starting and end positions are 0 .If not then returning -1\\n        \\n        if(n==1)\\n            return 1; //if size of grid is 1 then the answer will be 1 as the starting cell will be the ending cell also.\\n        \\n      \\n        \\n        queue<pair<int,int>> q; //For BFS traversal. passing the starting node\\n        q.push({0,0});\\n        grid[0][0]=1; //initialzing the starting distance as 1 cause the distance from\\n                        // the starting cell will be 1 cell only\\n        \\n        int dirx[8] = {0,1,0,-1,1,-1,1,-1};\\n        int diry[8] = {1,0,-1,0,1,1,-1,-1}; //for checking 8 directions\\n        \\n        while(!q.empty()){\\n            \\n            auto curr = q.front();  //The current position\\n            q.pop();//pop the current position\\n            int row = curr.first;\\n            int col = curr.second;\\n            \\n            for(int i=0;i<8;i++){\\n                int x = dirx[i];\\n                int y= diry[i];\\n                \\n                if(row+x<0||col+y<0||row+x>=n||col+y>=n||grid[row+x][col+y]>=1){\\n                    continue; //if the position goes out of bounds or if its already visited we move to the next position\\n                    //if the grid value is 1 then we cannot move to that cell because\\n                    //we can only move to 0 and if the grid value is greater than 1 then it means \\n                    //it is already visited so we dont need to visit again.\\n                }\\n                \\n                    grid[row+x][col+y] = 1 + grid[row][col]; //if we reach the last cell we return the distance\\n                    if(row+x==n-1&&col+y==n-1)\\n                        return grid[n-1][n-1];\\n                    q.push({row+x,col+y}); //if its not the last cell then we push it into the queue\\n                }\\n                \\n            }\\n            \\n        \\n        \\n        return -1; //if we reach here it means there is no clear path between starting and ending cell\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n = grid.size(); //Taking the grid size\\n        \\n        if(grid[0][0]!=0 || grid[n-1][n-1]!=0)\\n            return -1; //checking if the starting and end positions are 0 .If not then returning -1\\n        \\n        if(n==1)\\n            return 1; //if size of grid is 1 then the answer will be 1 as the starting cell will be the ending cell also.\\n        \\n      \\n        \\n        queue<pair<int,int>> q; //For BFS traversal. passing the starting node\\n        q.push({0,0});\\n        grid[0][0]=1; //initialzing the starting distance as 1 cause the distance from\\n                        // the starting cell will be 1 cell only\\n        \\n        int dirx[8] = {0,1,0,-1,1,-1,1,-1};\\n        int diry[8] = {1,0,-1,0,1,1,-1,-1}; //for checking 8 directions\\n        \\n        while(!q.empty()){\\n            \\n            auto curr = q.front();  //The current position\\n            q.pop();//pop the current position\\n            int row = curr.first;\\n            int col = curr.second;\\n            \\n            for(int i=0;i<8;i++){\\n                int x = dirx[i];\\n                int y= diry[i];\\n                \\n                if(row+x<0||col+y<0||row+x>=n||col+y>=n||grid[row+x][col+y]>=1){\\n                    continue; //if the position goes out of bounds or if its already visited we move to the next position\\n                    //if the grid value is 1 then we cannot move to that cell because\\n                    //we can only move to 0 and if the grid value is greater than 1 then it means \\n                    //it is already visited so we dont need to visit again.\\n                }\\n                \\n                    grid[row+x][col+y] = 1 + grid[row][col]; //if we reach the last cell we return the distance\\n                    if(row+x==n-1&&col+y==n-1)\\n                        return grid[n-1][n-1];\\n                    q.push({row+x,col+y}); //if its not the last cell then we push it into the queue\\n                }\\n                \\n            }\\n            \\n        \\n        \\n        return -1; //if we reach here it means there is no clear path between starting and ending cell\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698121,
                "title": "rust-a",
                "content": "```rust\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\nconst N: &[(isize, isize); 8] = &[\\n    (-1, -1),\\n    (-1, 0),\\n    (-1, 1),\\n    (0, -1),\\n    (0, 1),\\n    (1, -1),\\n    (1, 0),\\n    (1, 1),\\n];\\n\\npub fn shortest_path_binary_matrix(mut grid: Vec<Vec<i32>>) -> i32 {\\n    if grid[0][0] != 0 {\\n        return -1;\\n    }\\n\\n    let mut pq = BinaryHeap::new();\\n    pq.push((Reverse((heuristic(&grid, 0, 0) + 1, 1i32)), (0, 0)));\\n\\n    while let Some((Reverse((_, s)), (r, c))) = pq.pop() {\\n        if grid[r][c] != 0 {\\n            continue;\\n        }\\n        grid[r][c] = 255;\\n\\n        if r == grid.len() - 1 && c == grid[0].len() - 1 {\\n            return s;\\n        }\\n\\n        for (dr, dc) in N.iter().copied() {\\n            let rr = (r as isize) + dr;\\n            if rr < 0 || rr as usize >= grid.len() {\\n                continue;\\n            }\\n\\n            let cc = (c as isize) + dc;\\n            if cc < 0 || cc as usize >= grid[0].len() {\\n                continue;\\n            }\\n\\n            let rr = rr as usize;\\n            let cc = cc as usize;\\n            if grid[rr][cc] != 0 {\\n                continue;\\n            }\\n\\n            let m = heuristic(&grid, rr, cc);\\n            let s = s + 1;\\n            pq.push((Reverse((m + s, s)), (rr, cc)));\\n        }\\n    }\\n\\n    -1\\n}\\n\\nfn heuristic(grid: &Vec<Vec<i32>>, r: usize, c: usize) -> i32 {\\n    const D1: isize = 1;\\n    const D2: isize = 1;\\n\\n    let dx = (grid.len() - r - 1) as isize;\\n    let dy = (grid[0].len() - c - 1) as isize;\\n\\n    (D1 * (dx + dy) + (D2 - 2 * D1) * dx.min(dy)) as i32\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\nconst N: &[(isize, isize); 8] = &[\\n    (-1, -1),\\n    (-1, 0),\\n    (-1, 1),\\n    (0, -1),\\n    (0, 1),\\n    (1, -1),\\n    (1, 0),\\n    (1, 1),\\n];\\n\\npub fn shortest_path_binary_matrix(mut grid: Vec<Vec<i32>>) -> i32 {\\n    if grid[0][0] != 0 {\\n        return -1;\\n    }\\n\\n    let mut pq = BinaryHeap::new();\\n    pq.push((Reverse((heuristic(&grid, 0, 0) + 1, 1i32)), (0, 0)));\\n\\n    while let Some((Reverse((_, s)), (r, c))) = pq.pop() {\\n        if grid[r][c] != 0 {\\n            continue;\\n        }\\n        grid[r][c] = 255;\\n\\n        if r == grid.len() - 1 && c == grid[0].len() - 1 {\\n            return s;\\n        }\\n\\n        for (dr, dc) in N.iter().copied() {\\n            let rr = (r as isize) + dr;\\n            if rr < 0 || rr as usize >= grid.len() {\\n                continue;\\n            }\\n\\n            let cc = (c as isize) + dc;\\n            if cc < 0 || cc as usize >= grid[0].len() {\\n                continue;\\n            }\\n\\n            let rr = rr as usize;\\n            let cc = cc as usize;\\n            if grid[rr][cc] != 0 {\\n                continue;\\n            }\\n\\n            let m = heuristic(&grid, rr, cc);\\n            let s = s + 1;\\n            pq.push((Reverse((m + s, s)), (rr, cc)));\\n        }\\n    }\\n\\n    -1\\n}\\n\\nfn heuristic(grid: &Vec<Vec<i32>>, r: usize, c: usize) -> i32 {\\n    const D1: isize = 1;\\n    const D2: isize = 1;\\n\\n    let dx = (grid.len() - r - 1) as isize;\\n    let dy = (grid[0].len() - c - 1) as isize;\\n\\n    (D1 * (dx + dy) + (D2 - 2 * D1) * dx.min(dy)) as i32\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1663606,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranties of any kind. You can are to use the content as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func shortestPathBinaryMatrix(_ grid: [[Int]]) -> Int {\\n        guard grid[0][0] == 0 else { return -1 }\\n        let row = grid.count, col = grid[0].count\\n        guard grid[row - 1][col - 1] == 0 else { return -1 }\\n        var grid = grid, queue = [(x: 0, y: 0)]\\n        grid[0][0] = 1\\n        \\n        while !queue.isEmpty {\\n            let cur = queue.removeFirst()\\n            if cur.x == row - 1, cur.y == col - 1 { return grid[cur.x][cur.y] }\\n            for (dx,dy) in [(0,1),(0,-1),(1,0),(-1,0),(-1,-1),(-1,1),(1,-1),(1,1)] {\\n                let new = (x: (cur.x + dx), y: (cur.y + dy))\\n                guard new.x >= 0, new.y >= 0, new.x < row, new.y < col, grid[new.x][new.y] == 0 else { continue }\\n                queue.append((new.x, new.y))\\n                grid[new.x][new.y] = grid[cur.x][cur.y] + 1\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.shortestPathBinaryMatrix([[0,1],[1,0]])\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.shortestPathBinaryMatrix([[0,0,0],[1,1,0],[1,1,0]])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    func test2() {\\n        let value = solution.shortestPathBinaryMatrix([[1,0,0],[1,1,0],[1,1,0]])\\n        XCTAssertEqual(value, -1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func shortestPathBinaryMatrix(_ grid: [[Int]]) -> Int {\\n        guard grid[0][0] == 0 else { return -1 }\\n        let row = grid.count, col = grid[0].count\\n        guard grid[row - 1][col - 1] == 0 else { return -1 }\\n        var grid = grid, queue = [(x: 0, y: 0)]\\n        grid[0][0] = 1\\n        \\n        while !queue.isEmpty {\\n            let cur = queue.removeFirst()\\n            if cur.x == row - 1, cur.y == col - 1 { return grid[cur.x][cur.y] }\\n            for (dx,dy) in [(0,1),(0,-1),(1,0),(-1,0),(-1,-1),(-1,1),(1,-1),(1,1)] {\\n                let new = (x: (cur.x + dx), y: (cur.y + dy))\\n                guard new.x >= 0, new.y >= 0, new.x < row, new.y < col, grid[new.x][new.y] == 0 else { continue }\\n                queue.append((new.x, new.y))\\n                grid[new.x][new.y] = grid[cur.x][cur.y] + 1\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.shortestPathBinaryMatrix([[0,1],[1,0]])\\n        XCTAssertEqual(value, 2)\\n    }\\n    \\n    func test1() {\\n        let value = solution.shortestPathBinaryMatrix([[0,0,0],[1,1,0],[1,1,0]])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    func test2() {\\n        let value = solution.shortestPathBinaryMatrix([[1,0,0],[1,1,0],[1,1,0]])\\n        XCTAssertEqual(value, -1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656639,
                "title": "java-easy-to-understand-bfs-dfs",
                "content": "```\\nclass Solution\\n{// dfs passed only 49/88 cases and gave tle on other test cases\\n /*   int n;       \\n    int m;\\n    boolean visit[][];\\n    int count=Integer.MAX_VALUE;\\n    public void dfs(int grid[][],int row,int col,int moves)\\n    {\\n        \\n        if(row<0||row>=n||col<0||col>=n||visit[row][col]||grid[row][col]==1)\\n            return;\\n        if(row==n-1&&col==m-1)\\n        {\\n            count=Math.min(count,moves);\\n            return;\\n        }\\n          visit[row][col]=true;\\n        dfs(grid,row+1,col,moves+1);\\n        dfs(grid,row-1,col,moves+1);\\n        dfs(grid,row+1,col+1,moves+1);\\n        dfs(grid,row+1,col-1,moves+1);\\n        dfs(grid,row,col+1,moves+1);\\n        dfs(grid,row,col-1,moves+1);\\n        dfs(grid,row-1,col+1,moves+1);\\n        dfs(grid,row-1,col-1,moves+1);\\n          visit[row][col]=false;\\n            \\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) \\n    {\\n        n=grid.length;\\n        m=grid[0].length;\\n        visit=new boolean[n][m];\\n        if(grid[0][0]==1||grid[n-1][m-1]==1)\\n            return -1;\\n        dfs(grid,0,0,1);\\n        return count==Integer.MAX_VALUE?-1:count;\\n    }*/\\n    //going with bfs approach now\\n    //BURN BABY BURN!!!!!!\\n    class pair\\n    {\\n        int x;\\n        int y;\\n        int moves;\\n        pair(int x,int y,int moves)\\n        {\\n            this.x=x;\\n            this.y=y;\\n            this.moves=moves;\\n        }\\n    }\\n     public int shortestPathBinaryMatrix(int[][] grid)\\n     {\\n         int dir[][]={{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,-1},{-1,1}};\\n         int n=grid.length;\\n         int m=grid.length;\\n         LinkedList<pair>q=new LinkedList<>();\\n        // int count=Integer.MAX_VALUE;\\n         if(grid[0][0]==1||grid[n-1][m-1]==1)\\n             return -1;\\n         pair np=new pair(0,0,1);\\n         q.add(np);\\n         boolean visit[][]=new boolean[n][m];\\n         visit[0][0]=true;\\n         while(q.size()!=0)\\n         {\\n             pair p=q.poll();\\n             if(p.x==n-1 && p.y==m-1)\\n             {\\n                 return p.moves;\\n             }\\n             for(int dirs[]:dir)\\n             {\\n                 int nx=dirs[0]+p.x;\\n                 int ny=dirs[1]+p.y;\\n                 if(nx<0||nx>=n||ny<0||ny>=m||visit[nx][ny]||grid[nx][ny]==1)\\n                     continue;\\n                 else\\n                 {\\n                     pair c=new pair(nx,ny,p.moves+1);\\n                     q.add(c);\\n                     visit[nx][ny]=true;\\n                 }\\n             }\\n         }\\n         return -1;\\n     }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{// dfs passed only 49/88 cases and gave tle on other test cases\\n /*   int n;       \\n    int m;\\n    boolean visit[][];\\n    int count=Integer.MAX_VALUE;\\n    public void dfs(int grid[][],int row,int col,int moves)\\n    {\\n        \\n        if(row<0||row>=n||col<0||col>=n||visit[row][col]||grid[row][col]==1)\\n            return;\\n        if(row==n-1&&col==m-1)\\n        {\\n            count=Math.min(count,moves);\\n            return;\\n        }\\n          visit[row][col]=true;\\n        dfs(grid,row+1,col,moves+1);\\n        dfs(grid,row-1,col,moves+1);\\n        dfs(grid,row+1,col+1,moves+1);\\n        dfs(grid,row+1,col-1,moves+1);\\n        dfs(grid,row,col+1,moves+1);\\n        dfs(grid,row,col-1,moves+1);\\n        dfs(grid,row-1,col+1,moves+1);\\n        dfs(grid,row-1,col-1,moves+1);\\n          visit[row][col]=false;\\n            \\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) \\n    {\\n        n=grid.length;\\n        m=grid[0].length;\\n        visit=new boolean[n][m];\\n        if(grid[0][0]==1||grid[n-1][m-1]==1)\\n            return -1;\\n        dfs(grid,0,0,1);\\n        return count==Integer.MAX_VALUE?-1:count;\\n    }*/\\n    //going with bfs approach now\\n    //BURN BABY BURN!!!!!!\\n    class pair\\n    {\\n        int x;\\n        int y;\\n        int moves;\\n        pair(int x,int y,int moves)\\n        {\\n            this.x=x;\\n            this.y=y;\\n            this.moves=moves;\\n        }\\n    }\\n     public int shortestPathBinaryMatrix(int[][] grid)\\n     {\\n         int dir[][]={{1,0},{-1,0},{0,1},{0,-1},{1,1},{1,-1},{-1,-1},{-1,1}};\\n         int n=grid.length;\\n         int m=grid.length;\\n         LinkedList<pair>q=new LinkedList<>();\\n        // int count=Integer.MAX_VALUE;\\n         if(grid[0][0]==1||grid[n-1][m-1]==1)\\n             return -1;\\n         pair np=new pair(0,0,1);\\n         q.add(np);\\n         boolean visit[][]=new boolean[n][m];\\n         visit[0][0]=true;\\n         while(q.size()!=0)\\n         {\\n             pair p=q.poll();\\n             if(p.x==n-1 && p.y==m-1)\\n             {\\n                 return p.moves;\\n             }\\n             for(int dirs[]:dir)\\n             {\\n                 int nx=dirs[0]+p.x;\\n                 int ny=dirs[1]+p.y;\\n                 if(nx<0||nx>=n||ny<0||ny>=m||visit[nx][ny]||grid[nx][ny]==1)\\n                     continue;\\n                 else\\n                 {\\n                     pair c=new pair(nx,ny,p.moves+1);\\n                     q.add(c);\\n                     visit[nx][ny]=true;\\n                 }\\n             }\\n         }\\n         return -1;\\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590798,
                "title": "javascript-a-search",
                "content": "```\\nclass Node {\\n    constructor(row, col, value) {\\n        this.row = row\\n        this.col = col\\n        this.value = value\\n        this.g = Infinity\\n        this.h = Infinity\\n        this.f = Infinity\\n        this.parent = null\\n    }\\n}\\nconst initNodes = (grid) => {\\n    const nodes = []\\n    for (let r = 0; r < grid.length; r++) {\\n        nodes.push([])\\n        for (let c = 0; c < grid[0].length; c++) {\\n            nodes[r].push(new Node(r, c, grid[r][c]))\\n        }\\n    }\\n    return nodes\\n}\\nconst calcDistance = (currNode, endNode) => {\\n    return Math.max(endNode.row - currNode.row, endNode.col - currNode.col)\\n}\\nconst getNeighborNodes = (currNode, nodes) => {\\n    const numRows = nodes.length\\n    const numCols = nodes[0].length\\n    const neighbors = []\\n    for (let r = -1; r <= 1; r++) {\\n        for (let c = -1; c <= 1; c++) {\\n            if (r === 0 && c === 0) continue\\n            const row = currNode.row + r\\n            const col = currNode.col + c\\n            \\n            if (row < 0 || row >= numRows || col < 0 || col >= numCols) continue\\n            neighbors.push(nodes[row][col])\\n        }\\n    }\\n    return neighbors\\n}\\nconst getPathLength = (endNode) => {\\n    if (endNode.parent === null) return -1\\n    let pathLength = 0\\n    let currNode = endNode\\n    while (currNode) {\\n        pathLength++\\n        currNode = currNode.parent\\n    }\\n    return pathLength\\n}\\n\\nconst shortestPathBinaryMatrix = (grid) => {\\n    const nodes = initNodes(grid)\\n    const n = grid.length\\n    const startNode = nodes[0][0]\\n    const endNode = nodes[n - 1][n - 1]\\n    \\n    if (startNode === endNode) return 1\\n    if (startNode.value === 1 || endNode.value === 1) return -1\\n    \\n    startNode.g = 0\\n    startNode.h = calcDistance(startNode, endNode)\\n    startNode.f = 0\\n    \\n    const nodesToVisit = [startNode]\\n    const visited = new Set()\\n    while (nodesToVisit.length) {\\n        let currNode = nodesToVisit[0]\\n        let currNodeIdx = 0\\n        for (let i = 0; i < nodesToVisit.length; i++) {\\n            const node = nodesToVisit[i]\\n            if (node.f <= currNode.f) {\\n                currNode = node\\n                currNodeIdx = i\\n            }\\n        }\\n        nodesToVisit.splice(currNodeIdx, 1)\\n        visited.add(currNode)\\n        \\n        if (currNode === endNode) break\\n        \\n        const neighbors = getNeighborNodes(currNode, nodes)\\n        for (const neighbor of neighbors) {\\n            if (neighbor.value === 1 || visited.has(neighbor)) continue\\n            \\n            const distanceToNeighbor = currNode.g + 1\\n            if (distanceToNeighbor >= neighbor.g) continue\\n            \\n            neighbor.g = distanceToNeighbor\\n            neighbor.h = calcDistance(neighbor, endNode)\\n            neighbor.f = neighbor.g + neighbor.h\\n            neighbor.parent = currNode\\n            \\n            if (!nodesToVisit.includes(neighbor)) {\\n                nodesToVisit.push(neighbor)\\n            }\\n        }\\n    }\\n    return getPathLength(endNode)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Node {\\n    constructor(row, col, value) {\\n        this.row = row\\n        this.col = col\\n        this.value = value\\n        this.g = Infinity\\n        this.h = Infinity\\n        this.f = Infinity\\n        this.parent = null\\n    }\\n}\\nconst initNodes = (grid) => {\\n    const nodes = []\\n    for (let r = 0; r < grid.length; r++) {\\n        nodes.push([])\\n        for (let c = 0; c < grid[0].length; c++) {\\n            nodes[r].push(new Node(r, c, grid[r][c]))\\n        }\\n    }\\n    return nodes\\n}\\nconst calcDistance = (currNode, endNode) => {\\n    return Math.max(endNode.row - currNode.row, endNode.col - currNode.col)\\n}\\nconst getNeighborNodes = (currNode, nodes) => {\\n    const numRows = nodes.length\\n    const numCols = nodes[0].length\\n    const neighbors = []\\n    for (let r = -1; r <= 1; r++) {\\n        for (let c = -1; c <= 1; c++) {\\n            if (r === 0 && c === 0) continue\\n            const row = currNode.row + r\\n            const col = currNode.col + c\\n            \\n            if (row < 0 || row >= numRows || col < 0 || col >= numCols) continue\\n            neighbors.push(nodes[row][col])\\n        }\\n    }\\n    return neighbors\\n}\\nconst getPathLength = (endNode) => {\\n    if (endNode.parent === null) return -1\\n    let pathLength = 0\\n    let currNode = endNode\\n    while (currNode) {\\n        pathLength++\\n        currNode = currNode.parent\\n    }\\n    return pathLength\\n}\\n\\nconst shortestPathBinaryMatrix = (grid) => {\\n    const nodes = initNodes(grid)\\n    const n = grid.length\\n    const startNode = nodes[0][0]\\n    const endNode = nodes[n - 1][n - 1]\\n    \\n    if (startNode === endNode) return 1\\n    if (startNode.value === 1 || endNode.value === 1) return -1\\n    \\n    startNode.g = 0\\n    startNode.h = calcDistance(startNode, endNode)\\n    startNode.f = 0\\n    \\n    const nodesToVisit = [startNode]\\n    const visited = new Set()\\n    while (nodesToVisit.length) {\\n        let currNode = nodesToVisit[0]\\n        let currNodeIdx = 0\\n        for (let i = 0; i < nodesToVisit.length; i++) {\\n            const node = nodesToVisit[i]\\n            if (node.f <= currNode.f) {\\n                currNode = node\\n                currNodeIdx = i\\n            }\\n        }\\n        nodesToVisit.splice(currNodeIdx, 1)\\n        visited.add(currNode)\\n        \\n        if (currNode === endNode) break\\n        \\n        const neighbors = getNeighborNodes(currNode, nodes)\\n        for (const neighbor of neighbors) {\\n            if (neighbor.value === 1 || visited.has(neighbor)) continue\\n            \\n            const distanceToNeighbor = currNode.g + 1\\n            if (distanceToNeighbor >= neighbor.g) continue\\n            \\n            neighbor.g = distanceToNeighbor\\n            neighbor.h = calcDistance(neighbor, endNode)\\n            neighbor.f = neighbor.g + neighbor.h\\n            neighbor.parent = currNode\\n            \\n            if (!nodesToVisit.includes(neighbor)) {\\n                nodesToVisit.push(neighbor)\\n            }\\n        }\\n    }\\n    return getPathLength(endNode)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239182,
                "title": "java-bfs-and-dfs-solution",
                "content": "class Solution {\\n    \\n\\tpublic int shortestPathBinaryMatrix(int[][] grid) {\\n        int[][] dirs = {\\n            {-1, +0}, \\n            {+0, +1}, \\n            {+0, -1},  \\n            {+1, +1},  \\n            {+1, -1},  \\n            {-1, +1},  \\n            {+1, +0},  \\n            {-1, -1},  \\n        };\\n        \\n        // BFS Accepted\\n        int y = bfs(grid, dirs);\\n        return y == Integer.MAX_VALUE?-1:y;\\n        \\n        // DFS Solution will give TLE\\n        // int x = dfs(0, 0, grid, dirs);\\n        // return x == Integer.MAX_VALUE?-1:x;\\n    }\\n    \\n    public int bfs(int[][] g, int[][] dirs){\\n        \\n        int min = Integer.MAX_VALUE;\\n        \\n        int r = g.length, c = g[0].length;\\n        boolean[][] vis  = new boolean[r][c];\\n        \\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0, 1});\\n        \\n        if(g[0][0] == 1) return -1;\\n        \\n        vis[0][0] = true;\\n        \\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-->0){\\n                int[] rem = q.remove();\\n                if(rem[0] == r-1 && rem[1] == c-1) min = Math.min(min, rem[2]);\\n                \\n                if(rem[2]<min) {\\n                    for(int[] d:dirs){\\n                        int x = rem[0]+d[0];\\n                        int y = rem[1]+d[1];\\n                        if(x<0 || y<0 || x>=g.length || y>=g[0].length || g[x][y] == 1 || vis[x][y]) continue;\\n                        q.add(new int[]{x, y, rem[2]+1});\\n                        vis[x][y] = true;\\n                    }    \\n                }\\n                \\n            }\\n        }\\n        \\n        return min;\\n        \\n    }\\n    \\n    public int dfs(int r, int c, int[][] g, int[][] dirs){\\n        \\n        if(r<0 || c<0 || r>=g.length || c>=g[0].length || g[r][c] == 1) return Integer.MAX_VALUE;\\n        if(r == g.length-1 && c == g[0].length-1) return 1;\\n        \\n        \\n        g[r][c] = 1;\\n        \\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int[] d:dirs){\\n            min = Math.min(min, dfs(r+d[0], c+d[1], g, dirs));\\n        }\\n        \\n        g[r][c] = 0;\\n        \\n        if(min != Integer.MAX_VALUE) return min + 1;\\n        else return Integer.MAX_VALUE;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n\\tpublic int shortestPathBinaryMatrix(int[][] grid) {\\n        int[][] dirs = {\\n            {-1, +0}",
                "codeTag": "Java"
            },
            {
                "id": 1158840,
                "title": "java-bfs-solution-easy-to-understand",
                "content": "mark visited cell as \\'1\\'\\n```\\nclass Solution {\\n    private int[][] dirs = new int[][]{{0,1}, {0,-1}, {1,0}, {-1,0}, {1,1}, {-1,-1}, {1,-1}, {-1, 1}};\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        // BFS\\n        if (grid[0][0] != 0 || grid[grid.length - 1][grid[0].length - 1] != 0) return -1;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{0, 0});\\n        int res = 1;\\n        grid[0][0] = 1;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] cur = q.poll();\\n                if (cur[0] == grid.length - 1 && cur[1] == grid[0].length - 1) return res;\\n                for (int[] dir : dirs) {\\n                    int x = dir[0] + cur[0];\\n                    int y = dir[1] + cur[1];\\n                    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == 1) continue;\\n                    q.offer(new int[]{x, y});\\n                    grid[x][y] = 1;\\n                }\\n            }\\n            res ++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private int[][] dirs = new int[][]{{0,1}, {0,-1}, {1,0}, {-1,0}, {1,1}, {-1,-1}, {1,-1}, {-1, 1}};\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        // BFS\\n        if (grid[0][0] != 0 || grid[grid.length - 1][grid[0].length - 1] != 0) return -1;\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{0, 0});\\n        int res = 1;\\n        grid[0][0] = 1;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            while (size-- > 0) {\\n                int[] cur = q.poll();\\n                if (cur[0] == grid.length - 1 && cur[1] == grid[0].length - 1) return res;\\n                for (int[] dir : dirs) {\\n                    int x = dir[0] + cur[0];\\n                    int y = dir[1] + cur[1];\\n                    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == 1) continue;\\n                    q.offer(new int[]{x, y});\\n                    grid[x][y] = 1;\\n                }\\n            }\\n            res ++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109622,
                "title": "c-short-bfs-beginner-friendly-code-faster-than-95-76",
                "content": "Dont get panic By seeing those if conditions! Just 8 directions!!!\\nTo avoid coming back to same place we will change the 0 to 1.\\nBFS\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int ans=1,m=grid.size(),n=grid[0].size();\\n        if(grid[0][0]||grid[m-1][n-1]) return -1;\\n        if(m==1&&n==1&&grid[0][0]==0) return 1;\\n        queue<pair<int,int>> q;grid[0][0]=1;q.push({0,0});\\n        while(q.size())\\n        {\\n            int sz=q.size();\\n            ans++;\\n            while(sz--)\\n            {\\n                auto p=q.front();q.pop();\\n                int r=p.first,c=p.second;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//to reach the last block 1st three are the only ways, So they are enough to get return ans;\\n\\t\\t\\t\\t\\n                if(r+1<m)           if(r+1==m-1&&c==n-1)return ans;else if(!grid[r+1][c]) grid[r+1][c]=1,q.push({r+1,c});\\n                if(c+1<n)           if(r==m-1&&c+1==n-1)return ans;else if(!grid[r][c+1]) grid[r][c+1]=1,q.push({r,c+1});\\n                if(r+1<m&&c+1<n)    if(r+1==m-1&&c+1==n-1)return ans;else if(!grid[r+1][c+1]) grid[r+1][c+1]=1,q.push({r+1,c+1});\\n                if(c-1>=0)          if(!grid[r][c-1]) grid[r][c-1]=1,q.push({r,c-1});\\n                if(r-1>=0)          if(!grid[r-1][c]) grid[r-1][c]=1,q.push({r-1,c});\\n                if(r+1<m&&c-1>=0)   if(!grid[r+1][c-1]) grid[r+1][c-1]=1,q.push({r+1,c-1});\\n                if(r-1>=0&&c+1<n)   if(!grid[r-1][c+1]) grid[r-1][c+1]=1,q.push({r-1,c+1});\\n                if(r-1>=0&&c-1>=0)  if(!grid[r-1][c-1]) grid[r-1][c-1]=1,q.push({r-1,c-1});\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int ans=1,m=grid.size(),n=grid[0].size();\\n        if(grid[0][0]||grid[m-1][n-1]) return -1;\\n        if(m==1&&n==1&&grid[0][0]==0) return 1;\\n        queue<pair<int,int>> q;grid[0][0]=1;q.push({0,0}",
                "codeTag": "Java"
            },
            {
                "id": 1064125,
                "title": "c-solution-bfs-with-comments",
                "content": "```\\npublic class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        if (grid[0][0] == 1) return -1; \\n        \\n        int r = grid.Length;\\n        int c = grid[0].Length;\\n        \\n        var q = new Queue<(int x, int y)>();\\n        int result = 0;\\n        \\n        q.Enqueue((0,0)); // starting point\\n        \\n        while (q.Count > 0)\\n        {\\n            int count = q.Count;\\n            result++; // count a step each time that the eight sides are processed\\n            for (int i = 0; i < count; i++)\\n            {\\n                var p = q.Dequeue();\\n                // check if out of range, blocked or visited\\n                if (p.x < 0 || p.x >= r || p.y < 0 || p.y >= c ||\\n                    grid[p.x][p.y] != 0) \\n                    continue;\\n                \\n\\t\\t\\t\\t// check if found the end\\n                if (p.x == r-1 && p.y == c-1) return result;\\n                \\n               \\n                grid[p.x][p.y] = -1; // visited\\n                \\n                q.Enqueue((p.x+1, p.y)); // right\\n                q.Enqueue((p.x+1, p.y+1)); // right/down\\n                q.Enqueue((p.x, p.y+1)); // down\\n                q.Enqueue((p.x-1, p.y+1)); // left/down\\n                q.Enqueue((p.x-1, p.y)); // left\\n                q.Enqueue((p.x-1, p.y-1)); // left/up\\n                q.Enqueue((p.x, p.y-1)); // up\\n                q.Enqueue((p.x+1, p.y-1)); // right/up                \\n            }\\n        }        \\n        return -1;         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        if (grid[0][0] == 1) return -1; \\n        \\n        int r = grid.Length;\\n        int c = grid[0].Length;\\n        \\n        var q = new Queue<(int x, int y)>();\\n        int result = 0;\\n        \\n        q.Enqueue((0,0)); // starting point\\n        \\n        while (q.Count > 0)\\n        {\\n            int count = q.Count;\\n            result++; // count a step each time that the eight sides are processed\\n            for (int i = 0; i < count; i++)\\n            {\\n                var p = q.Dequeue();\\n                // check if out of range, blocked or visited\\n                if (p.x < 0 || p.x >= r || p.y < 0 || p.y >= c ||\\n                    grid[p.x][p.y] != 0) \\n                    continue;\\n                \\n\\t\\t\\t\\t// check if found the end\\n                if (p.x == r-1 && p.y == c-1) return result;\\n                \\n               \\n                grid[p.x][p.y] = -1; // visited\\n                \\n                q.Enqueue((p.x+1, p.y)); // right\\n                q.Enqueue((p.x+1, p.y+1)); // right/down\\n                q.Enqueue((p.x, p.y+1)); // down\\n                q.Enqueue((p.x-1, p.y+1)); // left/down\\n                q.Enqueue((p.x-1, p.y)); // left\\n                q.Enqueue((p.x-1, p.y-1)); // left/up\\n                q.Enqueue((p.x, p.y-1)); // up\\n                q.Enqueue((p.x+1, p.y-1)); // right/up                \\n            }\\n        }        \\n        return -1;         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063531,
                "title": "shortest-path-bfs-tle-help-required",
                "content": "I don\\'t why I am getting TLE. Please help me to find the mistake.\\nProblem [link](https://leetcode.com/problems/shortest-path-in-binary-matrix/)\\n**Solved** \\nThanks to @colinyoyo26\\n```c++\\nclass Solution {\\npublic:\\n    int m, n;\\n    int dx[8] = {-1, -1, -1, 1, 1, 1, 0 , 0};\\n    int dy[8] = {-1, 1, 0, -1, 0, 1,  1, -1};\\n    \\n    bool isValid(int x, int y, vector<vector<int>>& grid)\\n    {\\n        if( x<0 || x>=m)\\n            return false;\\n        if( y<0 || y>=n)\\n            return false;\\n        return grid[x][y]==0;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        if(grid[0][0])\\n            return -1;\\n        \\n        if(grid[m-1][n-1])\\n            return -1;\\n        \\n        if(m==1 && n==1)\\n            return 1;\\n        \\n        queue<pair<int, int> > q;\\n        q.push({0,0});\\n        \\n        int cnt = 0;\\n        \\n        while(!q.empty())\\n        {\\n            cnt++;\\n            int N = q.size();\\n            for(int j=1;j<=N;j++)\\n            {\\n                pair<int, int> curr = q.front(); q.pop();\\n                int x = curr.first, y = curr.second;\\n\\n                grid[x][y] = 1;     /// mistake, it can be updated inside second for loop\\n\\t\\t\\t\\t                          /// to avoid more number of iterations\\n                for(int i=0;i<8;i++)\\n                    if( isValid(x+dx[i], y+dy[i], grid ))\\n                    {\\n                        if(x+dx[i]==m-1 && y+dy[i]==n-1)\\n                            return cnt+1;\\n                         q.push( { x+dx[i], y+dy[i] } );  \\n                    }  \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int m, n;\\n    int dx[8] = {-1, -1, -1, 1, 1, 1, 0 , 0};\\n    int dy[8] = {-1, 1, 0, -1, 0, 1,  1, -1};\\n    \\n    bool isValid(int x, int y, vector<vector<int>>& grid)\\n    {\\n        if( x<0 || x>=m)\\n            return false;\\n        if( y<0 || y>=n)\\n            return false;\\n        return grid[x][y]==0;\\n    }\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        m = grid.size();\\n        n = grid[0].size();\\n        \\n        if(grid[0][0])\\n            return -1;\\n        \\n        if(grid[m-1][n-1])\\n            return -1;\\n        \\n        if(m==1 && n==1)\\n            return 1;\\n        \\n        queue<pair<int, int> > q;\\n        q.push({0,0});\\n        \\n        int cnt = 0;\\n        \\n        while(!q.empty())\\n        {\\n            cnt++;\\n            int N = q.size();\\n            for(int j=1;j<=N;j++)\\n            {\\n                pair<int, int> curr = q.front(); q.pop();\\n                int x = curr.first, y = curr.second;\\n\\n                grid[x][y] = 1;     /// mistake, it can be updated inside second for loop\\n\\t\\t\\t\\t                          /// to avoid more number of iterations\\n                for(int i=0;i<8;i++)\\n                    if( isValid(x+dx[i], y+dy[i], grid ))\\n                    {\\n                        if(x+dx[i]==m-1 && y+dy[i]==n-1)\\n                            return cnt+1;\\n                         q.push( { x+dx[i], y+dy[i] } );  \\n                    }  \\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033988,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        if (grid == null || grid.Length == 0)\\n            return 0;\\n        else if (grid[0][0] == 1 || grid[grid.Length - 1][grid[0].Length - 1] == 1)\\n            return -1;\\n        \\n        int res = 0;\\n        Queue<int[]> q = new Queue<int[]>();\\n        int[] dx = new int[] { 0, 0, 1, -1, 1, 1, -1, -1 },\\n              dy = new int[] { 1, -1, 0, 0, 1, -1, 1, -1 };\\n        \\n        q.Enqueue(new int[] { 0, 0 });\\n        grid[0][0] = -1;\\n        \\n        while (q.Count > 0)\\n        {\\n            int count = q.Count;\\n            \\n            res++;\\n            \\n            while (count > 0)\\n            {\\n                int[] cur = q.Dequeue();\\n            \\n                if (cur[0] == grid.Length - 1 && cur[1] == grid[0].Length - 1)\\n                    return res;\\n\\n                for (int i = 0; i < 7; i++)\\n                {\\n                    int newX = cur[0] + dx[i],\\n                        newY = cur[1] + dy[i];\\n\\n                    if (newX > -1 && newX < grid.Length && newY > -1 && newY < grid[0].Length && grid[newX][newY] == 0)\\n                    {\\n                        q.Enqueue(new int[] { newX, newY });\\n                        grid[newX][newY] = -1;\\n                    }\\n                }\\n                \\n                count--;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        if (grid == null || grid.Length == 0)\\n            return 0;\\n        else if (grid[0][0] == 1 || grid[grid.Length - 1][grid[0].Length - 1] == 1)\\n            return -1;\\n        \\n        int res = 0;\\n        Queue<int[]> q = new Queue<int[]>();\\n        int[] dx = new int[] { 0, 0, 1, -1, 1, 1, -1, -1 }",
                "codeTag": "Java"
            },
            {
                "id": 1025014,
                "title": "python3-bfs-o-n",
                "content": "**Algo**\\nSearch the grid breadth-first. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        if grid[0][0] == 0: \\n            ans = 0 \\n            grid[0][0] = 1\\n            queue = deque([(0, 0)])\\n            while queue: \\n                ans += 1\\n                for _ in range(len(queue)): \\n                    i, j = queue.popleft()\\n                    if i == j == n-1: return ans\\n                    for ii in range(i-1, i+2): \\n                        for jj in range(j-1, j+2): \\n                            if 0 <= ii < n and 0 <= jj < n and grid[ii][jj] == 0: \\n                                grid[ii][jj] = 1\\n                                queue.append((ii, jj))\\n        return -1 \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        if grid[0][0] == 0: \\n            ans = 0 \\n            grid[0][0] = 1\\n            queue = deque([(0, 0)])\\n            while queue: \\n                ans += 1\\n                for _ in range(len(queue)): \\n                    i, j = queue.popleft()\\n                    if i == j == n-1: return ans\\n                    for ii in range(i-1, i+2): \\n                        for jj in range(j-1, j+2): \\n                            if 0 <= ii < n and 0 <= jj < n and grid[ii][jj] == 0: \\n                                grid[ii][jj] = 1\\n                                queue.append((ii, jj))\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 933852,
                "title": "c-bfs-solution-with-explanation-runtime-96-ms-beats-96",
                "content": "BFS Solution -\\n\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(); // row size\\n        int n = grid[0].size();// column size\\n        \\n        /*If the first value or last value is not zero, path doesn\\'t exist*/\\n        if(grid[0][0] != 0 || grid[m-1][n-1] != 0)\\n            return -1;        \\n        \\n        //Create a queue to store the indexes of the elements with value zero\\n        queue<pair<int, int>> q;\\n        \\n        //Push the starting index\\n        q.push({0,0});\\n        \\n        /* This looks at the 8 surrounding elements \\n        ie. left, right, up, down, and 4 diagonals*/\\n        int rows[] = {0,0,1,-1,1,1,-1,-1};\\n        int cols[] = {1,-1,0,0,1,-1,-1,1};\\n        //Intialize this to 0 to count the number of steps\\n        int l = 0;\\n        \\n        while(!q.empty()){\\n            l++; //increment the steps taken\\n            int k = q.size();\\n            \\n            //cx, cy = current indexes | tx, ty = traversed indexes\\n            int cx, cy, tx, ty; \\n            \\n            while(k--){\\n                cx = q.front().first; //get the x value\\n                cy = q.front().second; //get the y value\\n                q.pop(); //pop the element\\n                \\n                /*\\n                Check if the current value is the end point\\n                If it is the end point, we need not check other paths to end point.\\n                */\\n                if(cx == m-1 && cy == n-1)\\n                    return l; \\n                \\n                //Check the surrounding elements\\n                for(int i=0; i<8; i++){\\n                    tx = cx + rows[i];\\n                    ty = cy + cols[i];\\n                    \\n                    //If the element is inside the limits and  is 0, push int queue\\n                    if(tx>=0 && tx<m && ty>=0 && ty<n && grid[tx][ty] == 0){\\n                        grid[cx][cy] = 1; //Change the current value to 1\\n                        grid[tx][ty] = 1; //Change the surrounding element to 1\\n                        q.push({tx,ty}); //push the indexes into the queue\\n                    }\\n                }\\n            }\\n        }\\n        /*\\n        Check if the end point value is 1, if it is 1, that means we found a path\\n        */\\n       return  grid[m-1][n-1] == 1 ?  l :  -1; \\n    }\\n};\\n```\\n\\nSimilar Problems - \\nhttps://leetcode.com/problems/01-matrix/\\nhttps://leetcode.com/problems/as-far-from-land-as-possible/\\nhttps://leetcode.com/problems/rotting-oranges/\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int m = grid.size(); // row size\\n        int n = grid[0].size();// column size\\n        \\n        /*If the first value or last value is not zero, path doesn\\'t exist*/\\n        if(grid[0][0] != 0 || grid[m-1][n-1] != 0)\\n            return -1;        \\n        \\n        //Create a queue to store the indexes of the elements with value zero\\n        queue<pair<int, int>> q;\\n        \\n        //Push the starting index\\n        q.push({0,0});\\n        \\n        /* This looks at the 8 surrounding elements \\n        ie. left, right, up, down, and 4 diagonals*/\\n        int rows[] = {0,0,1,-1,1,1,-1,-1};\\n        int cols[] = {1,-1,0,0,1,-1,-1,1};\\n        //Intialize this to 0 to count the number of steps\\n        int l = 0;\\n        \\n        while(!q.empty()){\\n            l++; //increment the steps taken\\n            int k = q.size();\\n            \\n            //cx, cy = current indexes | tx, ty = traversed indexes\\n            int cx, cy, tx, ty; \\n            \\n            while(k--){\\n                cx = q.front().first; //get the x value\\n                cy = q.front().second; //get the y value\\n                q.pop(); //pop the element\\n                \\n                /*\\n                Check if the current value is the end point\\n                If it is the end point, we need not check other paths to end point.\\n                */\\n                if(cx == m-1 && cy == n-1)\\n                    return l; \\n                \\n                //Check the surrounding elements\\n                for(int i=0; i<8; i++){\\n                    tx = cx + rows[i];\\n                    ty = cy + cols[i];\\n                    \\n                    //If the element is inside the limits and  is 0, push int queue\\n                    if(tx>=0 && tx<m && ty>=0 && ty<n && grid[tx][ty] == 0){\\n                        grid[cx][cy] = 1; //Change the current value to 1\\n                        grid[tx][ty] = 1; //Change the surrounding element to 1\\n                        q.push({tx,ty}); //push the indexes into the queue\\n                    }\\n                }\\n            }\\n        }\\n        /*\\n        Check if the end point value is 1, if it is 1, that means we found a path\\n        */\\n       return  grid[m-1][n-1] == 1 ?  l :  -1; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926988,
                "title": "swift-bfs-solution",
                "content": "```swift\\nclass Solution {\\n    func shortestPathBinaryMatrix(_ grid: [[Int]]) -> Int {\\n        let R = grid.count, C = grid[0].count\\n        if grid[0][0] == 1 || grid[R-1][C-1] == 1 { return -1 }\\n\\n        var grid = grid\\n        var points: Set<[Int]> = [[0, 0]]\\n        var res = 0\\n        while !points.isEmpty {\\n            res += 1\\n            points.forEach { grid[$0[0]][$0[1]] = 2 }\\n\\n            var nexts = Set<[Int]>()\\n            for point in points {\\n                let x = point[0], y = point[1]\\n                if x == R - 1 && y == C - 1 { return res }\\n                for dx in -1...1 { for dy in -1...1 {\\n                    let nx = x + dx, ny = y + dy\\n                    if nx >= 0 && nx < R && ny >= 0 && ny < C\\n                       && grid[nx][ny] == 0 {\\n                        nexts.insert([nx, ny])\\n                    }\\n                }}\\n            }\\n            points = nexts\\n        }\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nclass Solution {\\n    func shortestPathBinaryMatrix(_ grid: [[Int]]) -> Int {\\n        let R = grid.count, C = grid[0].count\\n        if grid[0][0] == 1 || grid[R-1][C-1] == 1 { return -1 }\\n\\n        var grid = grid\\n        var points: Set<[Int]> = [[0, 0]]\\n        var res = 0\\n        while !points.isEmpty {\\n            res += 1\\n            points.forEach { grid[$0[0]][$0[1]] = 2 }\\n\\n            var nexts = Set<[Int]>()\\n            for point in points {\\n                let x = point[0], y = point[1]\\n                if x == R - 1 && y == C - 1 { return res }\\n                for dx in -1...1 { for dy in -1...1 {\\n                    let nx = x + dx, ny = y + dy\\n                    if nx >= 0 && nx < R && ny >= 0 && ny < C\\n                       && grid[nx][ny] == 0 {\\n                        nexts.insert([nx, ny])\\n                    }\\n                }}\\n            }\\n            points = nexts\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 731983,
                "title": "javascript-classic-bfs-with-tracking-visited-nodes-with-comments",
                "content": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar shortestPathBinaryMatrix = function(grid) {\\n    \\n    /*\\n       Classic BFS with level traversal.\\n       Time:  O(m*n)\\n       Space: O(m*n)\\n    */\\n    \\n    \\n    // Edge cases\\n    //   empty grid\\n    if(grid.length == 0){\\n        return -1;\\n    }\\n    //   blocked starting point\\n    if(grid[0][0] == 1){\\n        return -1;\\n    }\\n    \\n    // \\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    // moving directions\\n    const DIR = [\\n        // \\n        [0,1],\\n        [0,-1],\\n        [1,0],\\n        [-1,0],\\n        // diagonals\\n        [1,1],\\n        [-1,1],\\n        [1,-1],\\n        [-1,-1],\\n    ];\\n    \\n    // define target\\n    const target = {row: m-1, col: n-1};\\n        \\n    // preventing double visits\\n    // could be replaced with changing original grid\\n    // by changing visited 0 cells to 1\\n    const _seen = new Set();\\n    const seen$ = (r, c) => _seen.has(r*n+c);\\n    const visit$ = (r, c) => {\\n        _seen.add(r*n+c);\\n        return {row: r, col: c};\\n    }\\n    \\n    const q = [visit$(0,0)];\\n    \\n    let path  = 0\\n    \\n    while(q.length>0){\\n        path++;    \\n        // level traversal: in our case level it is steps in the grid\\n        for(let i=q.length;i>0;i--){\\n            let {row, col} = q.shift();\\n            \\n            // if target found - return current step\\n            // since it is BFS the very first occurences will be\\n            // at the shortest path\\n            if(row == target.row && col == target.col){\\n                return path;\\n            }\\n            \\n            for(let d of DIR){\\n                \\n                let nr = row + d[0];\\n                let nc = col + d[1];\\n                \\n                // bounds check\\n                if(nr < 0 || nc < 0 || nr >=m || nc >= n){\\n                    continue;\\n                }\\n                \\n                // ignore visited\\n                if(seen$(nr, nc)){\\n                    continue;\\n                }\\n                \\n                // visit only empty cells\\n                if(grid[nr][nc] == 0){\\n                    q.push(visit$(nr, nc));\\n                }\\n            }\\n        }\\n    }\\n    \\n    // all possible ways have been checked and no target achieved\\n    return -1;\\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar shortestPathBinaryMatrix = function(grid) {\\n    \\n    /*\\n       Classic BFS with level traversal.\\n       Time:  O(m*n)\\n       Space: O(m*n)\\n    */\\n    \\n    \\n    // Edge cases\\n    //   empty grid\\n    if(grid.length == 0){\\n        return -1;\\n    }\\n    //   blocked starting point\\n    if(grid[0][0] == 1){\\n        return -1;\\n    }\\n    \\n    // \\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    // moving directions\\n    const DIR = [\\n        // \\n        [0,1],\\n        [0,-1],\\n        [1,0],\\n        [-1,0],\\n        // diagonals\\n        [1,1],\\n        [-1,1],\\n        [1,-1],\\n        [-1,-1],\\n    ];\\n    \\n    // define target\\n    const target = {row: m-1, col: n-1};\\n        \\n    // preventing double visits\\n    // could be replaced with changing original grid\\n    // by changing visited 0 cells to 1\\n    const _seen = new Set();\\n    const seen$ = (r, c) => _seen.has(r*n+c);\\n    const visit$ = (r, c) => {\\n        _seen.add(r*n+c);\\n        return {row: r, col: c};\\n    }\\n    \\n    const q = [visit$(0,0)];\\n    \\n    let path  = 0\\n    \\n    while(q.length>0){\\n        path++;    \\n        // level traversal: in our case level it is steps in the grid\\n        for(let i=q.length;i>0;i--){\\n            let {row, col} = q.shift();\\n            \\n            // if target found - return current step\\n            // since it is BFS the very first occurences will be\\n            // at the shortest path\\n            if(row == target.row && col == target.col){\\n                return path;\\n            }\\n            \\n            for(let d of DIR){\\n                \\n                let nr = row + d[0];\\n                let nc = col + d[1];\\n                \\n                // bounds check\\n                if(nr < 0 || nc < 0 || nr >=m || nc >= n){\\n                    continue;\\n                }\\n                \\n                // ignore visited\\n                if(seen$(nr, nc)){\\n                    continue;\\n                }\\n                \\n                // visit only empty cells\\n                if(grid[nr][nc] == 0){\\n                    q.push(visit$(nr, nc));\\n                }\\n            }\\n        }\\n    }\\n    \\n    // all possible ways have been checked and no target achieved\\n    return -1;\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 691808,
                "title": "c-a-search-priority-queue",
                "content": "The A* search algorithm sounded as if it would be a good fit here. I think it could outperform Dijkstra/BFS in many cases.\\n\\nHere\\'s my C++ implementation:\\n```\\n#include <queue>\\n#include <vector>\\n#include <array>\\n#include <iterator>\\n#include <utility>\\n#include <climits>\\n\\nnamespace {\\n\\nconst std::array<std::pair<int, int>, 8> neighbours = {{\\n    { 1,  1},\\n    { 0,  1},\\n    { 1,  0},\\n    {-1,  1},\\n    { 1, -1},\\n    { 0, -1},\\n    {-1,  0},\\n    {-1, -1},\\n}};\\n\\nstruct square {\\n    int g_score{INT_MAX};\\n    int f_score{INT_MAX};\\n    bool in_open_set{false};\\n};\\n    \\nusing square_iterator = std::vector<square>::iterator;\\nauto lowest_f_score_cmp = [](const square_iterator lhs, const square_iterator rhs) {\\n    return lhs->f_score > rhs->f_score;\\n};\\n\\nusing p_queue = std::priority_queue<square_iterator,\\n                                    std::vector<square_iterator>,\\n                                    decltype(lowest_f_score_cmp)>;\\n\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(const std::vector<std::vector<int>>& grid) {\\n        int n_rows = grid.size();\\n        if (n_rows == 0)\\n            return -1;\\n        int n_cols = grid[0].size();\\n        if (n_cols == 0 || grid[0][0] != 0 || grid[n_rows-1][n_cols-1] != 0)\\n            return -1;\\n        \\n        auto h = [n_rows, n_cols](int r, int c) {\\n            auto r_dist = (n_rows - 1) - r;\\n            auto c_dist = (n_cols - 1) - c;\\n            return std::max(r_dist, c_dist);\\n        };\\n        \\n        std::vector<square> squares(n_rows * n_cols);\\n        auto get_square = [&squares, n_cols](int r, int c) {\\n            return squares.begin() + (r * n_cols + c);\\n        };\\n        auto get_rc = [&squares, n_cols](square_iterator it) {\\n            auto idx = std::distance(squares.begin(), it);\\n            return std::make_pair<int, int>(idx / n_cols, idx % n_cols);\\n        };\\n        \\n        auto start = get_square(0, 0);\\n        start->g_score = 1;\\n        start->f_score = h(0, 0);\\n        \\n        auto dest = get_square(n_rows - 1, n_cols - 1);\\n         \\n        p_queue open_set(lowest_f_score_cmp);\\n        start->in_open_set = true;\\n        open_set.push(start);\\n        \\n        while (!open_set.empty()) {\\n            auto current = open_set.top();\\n            if (current == dest)\\n                return dest->g_score;\\n\\n            open_set.pop();\\n            if (!current->in_open_set)\\n                continue;\\n            current->in_open_set = false;\\n            \\n            auto [curr_r, curr_c] = get_rc(current);\\n            for (const auto & n : neighbours) {\\n                auto r = curr_r + n.first;\\n                auto c = curr_c + n.second;\\n                if (r >= 0  && r < n_rows && c >= 0 && c < n_cols && grid[r][c] == 0) {\\n                    auto neighbour = get_square(r, c);\\n                    auto tentative_g_score = current->g_score + 1;\\n                    if (tentative_g_score < neighbour->g_score) {\\n                        neighbour->g_score = tentative_g_score;\\n                        neighbour->f_score = neighbour->g_score + h(r, c);\\n                        neighbour->in_open_set = true;\\n                        open_set.push(neighbour);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <queue>\\n#include <vector>\\n#include <array>\\n#include <iterator>\\n#include <utility>\\n#include <climits>\\n\\nnamespace {\\n\\nconst std::array<std::pair<int, int>, 8> neighbours = {{\\n    { 1,  1},\\n    { 0,  1},\\n    { 1,  0},\\n    {-1,  1},\\n    { 1, -1},\\n    { 0, -1},\\n    {-1,  0},\\n    {-1, -1},\\n}};\\n\\nstruct square {\\n    int g_score{INT_MAX};\\n    int f_score{INT_MAX};\\n    bool in_open_set{false};\\n};\\n    \\nusing square_iterator = std::vector<square>::iterator;\\nauto lowest_f_score_cmp = [](const square_iterator lhs, const square_iterator rhs) {\\n    return lhs->f_score > rhs->f_score;\\n};\\n\\nusing p_queue = std::priority_queue<square_iterator,\\n                                    std::vector<square_iterator>,\\n                                    decltype(lowest_f_score_cmp)>;\\n\\n    \\n}\\n\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(const std::vector<std::vector<int>>& grid) {\\n        int n_rows = grid.size();\\n        if (n_rows == 0)\\n            return -1;\\n        int n_cols = grid[0].size();\\n        if (n_cols == 0 || grid[0][0] != 0 || grid[n_rows-1][n_cols-1] != 0)\\n            return -1;\\n        \\n        auto h = [n_rows, n_cols](int r, int c) {\\n            auto r_dist = (n_rows - 1) - r;\\n            auto c_dist = (n_cols - 1) - c;\\n            return std::max(r_dist, c_dist);\\n        };\\n        \\n        std::vector<square> squares(n_rows * n_cols);\\n        auto get_square = [&squares, n_cols](int r, int c) {\\n            return squares.begin() + (r * n_cols + c);\\n        };\\n        auto get_rc = [&squares, n_cols](square_iterator it) {\\n            auto idx = std::distance(squares.begin(), it);\\n            return std::make_pair<int, int>(idx / n_cols, idx % n_cols);\\n        };\\n        \\n        auto start = get_square(0, 0);\\n        start->g_score = 1;\\n        start->f_score = h(0, 0);\\n        \\n        auto dest = get_square(n_rows - 1, n_cols - 1);\\n         \\n        p_queue open_set(lowest_f_score_cmp);\\n        start->in_open_set = true;\\n        open_set.push(start);\\n        \\n        while (!open_set.empty()) {\\n            auto current = open_set.top();\\n            if (current == dest)\\n                return dest->g_score;\\n\\n            open_set.pop();\\n            if (!current->in_open_set)\\n                continue;\\n            current->in_open_set = false;\\n            \\n            auto [curr_r, curr_c] = get_rc(current);\\n            for (const auto & n : neighbours) {\\n                auto r = curr_r + n.first;\\n                auto c = curr_c + n.second;\\n                if (r >= 0  && r < n_rows && c >= 0 && c < n_cols && grid[r][c] == 0) {\\n                    auto neighbour = get_square(r, c);\\n                    auto tentative_g_score = current->g_score + 1;\\n                    if (tentative_g_score < neighbour->g_score) {\\n                        neighbour->g_score = tentative_g_score;\\n                        neighbour->f_score = neighbour->g_score + h(r, c);\\n                        neighbour->in_open_set = true;\\n                        open_set.push(neighbour);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 359287,
                "title": "java-bfs-20-ms-faster-than-73-32-48-7-mb-less-than-100-00",
                "content": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0 || grid[0][0] == 1) {\\n            return -1;\\n        }\\n        int n = grid.length;\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[n][n];\\n        q.offer(new int[]{0, 0});\\n        visited[0][0] = true;\\n        int steps = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            ++steps;\\n            for (int i = 0; i < size; ++i) {\\n                int[] p = q.poll();\\n                if (p[0] == n - 1 && p[1] == n - 1) {\\n                    return steps;\\n                }\\n                for (int a = -1; a <= 1; ++a) {\\n                    for (int b = -1; b <= 1; ++b) {\\n                        if (a == 0 && b == 0) {\\n                            continue;\\n                        }\\n                        int x = a + p[0];\\n                        int y = b + p[1];\\n                        if (0 <= x && x < n && 0 <= y && y < n && grid[x][y] == 0 && !visited[x][y]) {\\n                            q.offer(new int[]{x, y});\\n                            visited[x][y] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if (grid == null || grid.length == 0 || grid[0].length == 0 || grid[0][0] == 1) {\\n            return -1;\\n        }\\n        int n = grid.length;\\n        Queue<int[]> q = new LinkedList<>();\\n        boolean[][] visited = new boolean[n][n];\\n        q.offer(new int[]{0, 0});\\n        visited[0][0] = true;\\n        int steps = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            ++steps;\\n            for (int i = 0; i < size; ++i) {\\n                int[] p = q.poll();\\n                if (p[0] == n - 1 && p[1] == n - 1) {\\n                    return steps;\\n                }\\n                for (int a = -1; a <= 1; ++a) {\\n                    for (int b = -1; b <= 1; ++b) {\\n                        if (a == 0 && b == 0) {\\n                            continue;\\n                        }\\n                        int x = a + p[0];\\n                        int y = b + p[1];\\n                        if (0 <= x && x < n && 0 <= y && y < n && grid[x][y] == 0 && !visited[x][y]) {\\n                            q.offer(new int[]{x, y});\\n                            visited[x][y] = true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589114,
                "title": "c-easy-to-understand-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1)\\n            return -1;\\n        \\n        int s = grid.size();\\n        if(grid[s-1][s-1] != 0)\\n            return -1;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push({{0, 0}, 1});\\n        grid[0][0] = -1;\\n\\n        int drow[] = {-1, 0, +1, 0, 1, -1, -1, 1};\\n        int dcol[] = {0, 1, 0, -1, 1, 1, -1, -1}; \\n\\n        while(!q.empty()){\\n            auto val = q.front();\\n            int i = val.first.first;\\n            int j = val.first.second;\\n            int path = val.second;\\n            q.pop();\\n\\n            if(i == s-1 && j == s-1)\\n                return path;\\n\\n            for(int idx=0;idx<8;idx++){\\n                int row = i + drow[idx];\\n                int col = j + dcol[idx];\\n\\n                if(row >= 0 && row < s && col >= 0 && col < s && grid[row][col] == 0){\\n                    grid[row][col] = -1;\\n                    q.push({{row, col}, path+1});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1)\\n            return -1;\\n        \\n        int s = grid.size();\\n        if(grid[s-1][s-1] != 0)\\n            return -1;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push({{0, 0}, 1});\\n        grid[0][0] = -1;\\n\\n        int drow[] = {-1, 0, +1, 0, 1, -1, -1, 1};\\n        int dcol[] = {0, 1, 0, -1, 1, 1, -1, -1}; \\n\\n        while(!q.empty()){\\n            auto val = q.front();\\n            int i = val.first.first;\\n            int j = val.first.second;\\n            int path = val.second;\\n            q.pop();\\n\\n            if(i == s-1 && j == s-1)\\n                return path;\\n\\n            for(int idx=0;idx<8;idx++){\\n                int row = i + drow[idx];\\n                int col = j + dcol[idx];\\n\\n                if(row >= 0 && row < s && col >= 0 && col < s && grid[row][col] == 0){\\n                    grid[row][col] = -1;\\n                    q.push({{row, col}, path+1});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3587122,
                "title": "simple-c-2-approach-bfs-dijkstra-easy-solution",
                "content": "Approach 1 -> using BFS\\nApproach 2 -> using Dijkstra Algo\\n\\n# Code\\n**BFS **\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>directions {{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1}};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n = g.size();\\n        if(g[0][0] || g[n-1][n-1]) return -1;\\n\\n        auto isSafe = [&](int x,int y){\\n            return x>=0 && x<n && y>=0 && y<n;\\n        }; // this is known as Lambda in Cpp\\n\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        g[0][0]=1;\\n        int dis = 0;\\n        while(!q.empty()){\\n            dis++;\\n            int k = q.size();\\n            while(k--){\\n                auto curr = q.front();\\n                q.pop();\\n                int x = curr.first , y = curr.second;\\n\\n                if(x==n-1 && y==n-1)return dis;\\n\\n                for(auto &dir : directions){\\n                    int nx = x + dir[0];\\n                    int ny = y + dir[1];\\n\\n                    if( isSafe(nx,ny) && g[nx][ny]==0 ){\\n                        q.push({nx,ny});\\n                        g[nx][ny] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\\n\\n***Dijkstra ***\\n```\\nclass Solution {\\npublic:\\n\\n    typedef pair<int,pair<int,int>>P;\\n    vector<vector<int>>directions {{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1}};\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n = g.size();\\n        if(g[0][0] || g[n-1][n-1]) return -1;\\n\\n        auto isSafe = [&](int x,int y){\\n            return x>=0 && x<n && y>=0 && y<n;\\n        }; // this is known as Lambda in Cpp\\n\\n        vector<vector<int>>result(n,vector<int>(n,INT_MAX));\\n\\n        priority_queue<P,vector<P>,greater<P>>pq;\\n        pq.push({0,{0,0}});\\n        result[0][0] = 0;\\n\\n        while(!pq.empty()){\\n            int d = pq.top().first;\\n            auto node = pq.top().second;\\n            int x = node.first , y = node.second;\\n            pq.pop();\\n\\n            for(auto &dir: directions){\\n                int nx = x+dir[0];\\n                int ny = y+dir[1];\\n\\n                if(isSafe(nx,ny)&& g[nx][ny]==0 && d+1<result[nx][ny]){\\n                    pq.push({d+1,{nx,ny}});\\n                    result[nx][ny] = d+1;\\n                } \\n            }\\n        }\\n        if(result[n-1][n-1] == INT_MAX) return -1;\\n        return result[n-1][n-1]+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>directions {{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1}};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n = g.size();\\n        if(g[0][0] || g[n-1][n-1]) return -1;\\n\\n        auto isSafe = [&](int x,int y){\\n            return x>=0 && x<n && y>=0 && y<n;\\n        }; // this is known as Lambda in Cpp\\n\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        g[0][0]=1;\\n        int dis = 0;\\n        while(!q.empty()){\\n            dis++;\\n            int k = q.size();\\n            while(k--){\\n                auto curr = q.front();\\n                q.pop();\\n                int x = curr.first , y = curr.second;\\n\\n                if(x==n-1 && y==n-1)return dis;\\n\\n                for(auto &dir : directions){\\n                    int nx = x + dir[0];\\n                    int ny = y + dir[1];\\n\\n                    if( isSafe(nx,ny) && g[nx][ny]==0 ){\\n                        q.push({nx,ny});\\n                        g[nx][ny] = 1;\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n\\n    typedef pair<int,pair<int,int>>P;\\n    vector<vector<int>>directions {{0,-1},{-1,-1},{-1,0},{-1,1},{0,1},{1,1},{1,0},{1,-1}};\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n = g.size();\\n        if(g[0][0] || g[n-1][n-1]) return -1;\\n\\n        auto isSafe = [&](int x,int y){\\n            return x>=0 && x<n && y>=0 && y<n;\\n        }; // this is known as Lambda in Cpp\\n\\n        vector<vector<int>>result(n,vector<int>(n,INT_MAX));\\n\\n        priority_queue<P,vector<P>,greater<P>>pq;\\n        pq.push({0,{0,0}});\\n        result[0][0] = 0;\\n\\n        while(!pq.empty()){\\n            int d = pq.top().first;\\n            auto node = pq.top().second;\\n            int x = node.first , y = node.second;\\n            pq.pop();\\n\\n            for(auto &dir: directions){\\n                int nx = x+dir[0];\\n                int ny = y+dir[1];\\n\\n                if(isSafe(nx,ny)&& g[nx][ny]==0 && d+1<result[nx][ny]){\\n                    pq.push({d+1,{nx,ny}});\\n                    result[nx][ny] = d+1;\\n                } \\n            }\\n        }\\n        if(result[n-1][n-1] == INT_MAX) return -1;\\n        return result[n-1][n-1]+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586869,
                "title": "python-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n\\n        lengthOfGrid = len(grid)\\n        queue = deque([(0,0,1)])\\n        visited = set((0,0))\\n        direct = [[0,1], [1,0],[0,-1], [-1,0],\\n                    [1,1],[-1,-1],[1,-1],[-1,1]]\\n        while queue:\\n            row, column, lengthOfPosition = queue.popleft()\\n            if min(row, column) < 0 or max(row, column) >= lengthOfGrid or grid[row][column]:\\n                continue\\n            if row == lengthOfGrid -1 and column == lengthOfGrid - 1:\\n                return lengthOfPosition\\n            for directRow, directColumn in direct:\\n                if (row + directRow, column + directColumn) not in visited:\\n                    queue.append((row + directRow, column+ directColumn, lengthOfPosition + 1))\\n                    visited.add((row + directRow, column + directColumn))\\n        \\n        return -1\\n            \\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n\\n        lengthOfGrid = len(grid)\\n        queue = deque([(0,0,1)])\\n        visited = set((0,0))\\n        direct = [[0,1], [1,0],[0,-1], [-1,0],\\n                    [1,1],[-1,-1],[1,-1],[-1,1]]\\n        while queue:\\n            row, column, lengthOfPosition = queue.popleft()\\n            if min(row, column) < 0 or max(row, column) >= lengthOfGrid or grid[row][column]:\\n                continue\\n            if row == lengthOfGrid -1 and column == lengthOfGrid - 1:\\n                return lengthOfPosition\\n            for directRow, directColumn in direct:\\n                if (row + directRow, column + directColumn) not in visited:\\n                    queue.append((row + directRow, column+ directColumn, lengthOfPosition + 1))\\n                    visited.add((row + directRow, column + directColumn))\\n        \\n        return -1\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586421,
                "title": "simple-bfs-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n=g.size();\\n        if(g[0][0] || g[n-1][n-1])\\n        {\\n            return -1;\\n        }\\n        g[0][0]=1;\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int t=0;\\n        while(q.size()){\\n            int k=q.size();\\n            t++;\\n            while(k--){\\n                int x=q.front().first;\\n                int y=q.front().second;\\n                q.pop();\\n                if(x==n-1 && y==n-1)return t;\\n                int dx[8]={1,-1,0,0,1,1,-1,-1};\\n                int dy[8]={0,0,1,-1,1,-1,1,-1};\\n                for(int i=0;i<8;i++){\\n                    int nx=x+dx[i];\\n                    int ny=y+dy[i];\\n                    if(nx>=0 && nx<n && ny>=0 && ny<n && g[nx][ny]==0){\\n                        g[nx][ny]=1;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& g) {\\n        int n=g.size();\\n        if(g[0][0] || g[n-1][n-1])\\n        {\\n            return -1;\\n        }\\n        g[0][0]=1;\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        int t=0;\\n        while(q.size()){\\n            int k=q.size();\\n            t++;\\n            while(k--){\\n                int x=q.front().first;\\n                int y=q.front().second;\\n                q.pop();\\n                if(x==n-1 && y==n-1)return t;\\n                int dx[8]={1,-1,0,0,1,1,-1,-1};\\n                int dy[8]={0,0,1,-1,1,-1,1,-1};\\n                for(int i=0;i<8;i++){\\n                    int nx=x+dx[i];\\n                    int ny=y+dy[i];\\n                    if(nx>=0 && nx<n && ny>=0 && ny<n && g[nx][ny]==0){\\n                        g[nx][ny]=1;\\n                        q.push({nx,ny});\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586246,
                "title": "c-bfs",
                "content": "\\n\\n# Complexity\\n- Time complexity : O(M*N)\\n\\n- Space complexity: O(M*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<pair<int,int>,int>>q;\\n        if(grid[0][0]==1)return-1;\\n        if(grid[0][0]==0&&m==1&&n==1)return 1;\\n\\n        q.push({{0,0},1});\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        while(!q.empty()){\\n        int x=q.front().first.first;\\n        int  y=q.front().first.second;\\n        int a=q.front().second;\\n        q.pop();\\n        for(int i=-1;i<=1;i++){\\n            for(int j=-1;j<=1;j++){\\n                int nr=x+i;\\n                int nc=y+j;\\n                if(nr>=0&&nc>=0&&nr<n&&nc<m&&vis[nr][nc]==0&&grid[nr][nc]==0){\\n                    if(nr==n-1&&nc==m-1)return a+1;\\n                    vis[nr][nc]=1;\\n                    q.push({{nr,nc},a+1});\\n\\n                }\\n            }\\n        }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        queue<pair<pair<int,int>,int>>q;\\n        if(grid[0][0]==1)return-1;\\n        if(grid[0][0]==0&&m==1&&n==1)return 1;\\n\\n        q.push({{0,0},1});\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        while(!q.empty()){\\n        int x=q.front().first.first;\\n        int  y=q.front().first.second;\\n        int a=q.front().second;\\n        q.pop();\\n        for(int i=-1;i<=1;i++){\\n            for(int j=-1;j<=1;j++){\\n                int nr=x+i;\\n                int nc=y+j;\\n                if(nr>=0&&nc>=0&&nr<n&&nc<m&&vis[nr][nc]==0&&grid[nr][nc]==0){\\n                    if(nr==n-1&&nc==m-1)return a+1;\\n                    vis[nr][nc]=1;\\n                    q.push({{nr,nc},a+1});\\n\\n                }\\n            }\\n        }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586160,
                "title": "crystal-clear-solution-using-java",
                "content": "# The algorithm is pretty simple :\\n- If the starting indices i.e. (0,0) cell value is 1 then you can immediately return -1 as the answer. Because we can\\'t even reach the first cell.\\n- Now run BFS algorithm by maintaing a queue which must store three value they are  (i,j) which the dimensions of a cell and a variable named value. You use a Pair class to achieve the above mentioned thing.\\n- Now create a pair with 0,0 and value as 1 and add the pair to the queue to run the BFS algo.\\n- The core part of the algorithm starts here. We need to run a loop such that the loop runs until there is no item left in the queue.\\n- Pop an item from the queue and check if it is the last cell , if it is then return the pair\\'s value.\\n- After we\\'ve popped the pair from the queue ,we now traverse all the eight directions of the cell with our conditions to satisfy, they are the direction must be in the bound of the grid and its value must be \\'0\\'.\\n- As you get the new dimensions add them into the queue by creating a pair with their dimensions and value with be the parent\\'s value + 1. \\n- Change the value to 1 because it tells us that you have already visited the array. We use this techinque to prevent the usage of 2d matrix (extra space).\\n- Run the loop until we find our answer or the queue size becomes zero. If that is the case then we need to return -1.\\n\\n---\\n\\n\\n# Code\\n```\\nclass Pair\\n{\\n    int i = 0;\\n    int j = 0;\\n    int value = 0;\\n    Pair(int i,int j,int value)\\n    {\\n        this.i = i;\\n        this.j = j;\\n        this.value = value;\\n    }\\n}\\nclass Solution {\\n    int[] xDir = {0,0,-1,1,-1,1,-1,1};\\n    int[] yDir = {-1,1,0,0,-1,1,1,-1};\\n    public boolean isSafe(int[][] grid,int i ,int j)\\n    {\\n        return(i>=0 && i<grid.length && j>=0 && j<grid[0].length && grid[i][j] != 1);\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n       if(grid[0][0] == 1)  return -1;\\n       int n = grid.length;\\n       Queue<Pair> queue = new LinkedList<>();\\n       queue.offer(new Pair(0,0,1));\\n       while(queue.size() > 0)\\n       {\\n           Pair curr = queue.remove();\\n           int row = curr.i;\\n           int col = curr.j;\\n           int path = curr.value;\\n           if(row == n-1 && col == n-1)\\n           {\\n               return path;\\n           }\\n           for(int k = 0;k<8;k++)\\n           {\\n               int newRow = row+xDir[k];\\n               int newCol = col+yDir[k];\\n               if(isSafe(grid,newRow,newCol))\\n               {\\n                   queue.offer(new Pair(newRow,newCol,path+1));\\n                   grid[newRow][newCol] = 1;\\n               }\\n           }\\n       }\\n       return -1;\\n    }\\n}\\n\\n```\\n\\n---\\n\\n\\n#### *If you\\'ve liked my explanation don\\'t forget to upvote and encourage.* \\n\\n\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Pair\\n{\\n    int i = 0;\\n    int j = 0;\\n    int value = 0;\\n    Pair(int i,int j,int value)\\n    {\\n        this.i = i;\\n        this.j = j;\\n        this.value = value;\\n    }\\n}\\nclass Solution {\\n    int[] xDir = {0,0,-1,1,-1,1,-1,1};\\n    int[] yDir = {-1,1,0,0,-1,1,1,-1};\\n    public boolean isSafe(int[][] grid,int i ,int j)\\n    {\\n        return(i>=0 && i<grid.length && j>=0 && j<grid[0].length && grid[i][j] != 1);\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n       if(grid[0][0] == 1)  return -1;\\n       int n = grid.length;\\n       Queue<Pair> queue = new LinkedList<>();\\n       queue.offer(new Pair(0,0,1));\\n       while(queue.size() > 0)\\n       {\\n           Pair curr = queue.remove();\\n           int row = curr.i;\\n           int col = curr.j;\\n           int path = curr.value;\\n           if(row == n-1 && col == n-1)\\n           {\\n               return path;\\n           }\\n           for(int k = 0;k<8;k++)\\n           {\\n               int newRow = row+xDir[k];\\n               int newCol = col+yDir[k];\\n               if(isSafe(grid,newRow,newCol))\\n               {\\n                   queue.offer(new Pair(newRow,newCol,path+1));\\n                   grid[newRow][newCol] = 1;\\n               }\\n           }\\n       }\\n       return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584725,
                "title": "beautiful-code-easy-to-understand-as-you-read-bfs-java-helper-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNoticed adjacent vertices followed a non-linear & graph topology. \\n\\n**DFS or BFS?**\\nThe order of traversal needed to be in a regular fashion, either depth-first or breadth-first. \\n\\n**Greedy approach**\\n\\nRuled out depth-first traversal on the basis that Greedy approach can be used here. Starting from the levels from the root (0, 0), the shortest path will encounter each vertex first and any path that leads to that same vertex would be a non-optimal path!\\n\\nThis follows from unidirectional graph topology :)\\n \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo amortized BFS on all the possible adjacent vertices. \\n\\nCaveat: Maintain a visited array of seen vertices so far.\\n\\nWhy?\\nAs soon as a vertex is seen, it is already seen following the shortest path. So, just mark it visited as soon as its seen.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    class Vertex {\\n        int row;\\n        int col;\\n        int lenSoFar;\\n\\n        Vertex(int row, int col, int lenSoFar) {\\n            this.row = row;\\n            this.col = col;\\n            this.lenSoFar = lenSoFar;\\n        }\\n    }\\n\\n    public boolean isValid(int row, int col, int N, int [][]grid, boolean [][]isSeen) {\\n        if ( row >= 0 && row < N \\n        && col >= 0 && col < N\\n         && grid[row][col] == 0\\n          && isSeen[row][col] == false) {\\n              isSeen[row][col] = true;\\n              return true;\\n          }\\n        return false;\\n    }\\n\\n    public void printGrid(int [][]grid, int N) {\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                System.out.print(grid[i][j]);\\n            }\\n            System.out.println(\\',\\');\\n        }\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        \\n        int N = grid[0].length;\\n\\n        // printGrid(grid, N);\\n\\n        int len = -1;\\n\\n        boolean[][] isSeen = new boolean[N][N];\\n        Queue<Vertex> adjacentCells = new LinkedList<>();\\n\\n        if (isValid(0, 0, N, grid, isSeen))\\n        {\\n            Vertex root = new Vertex(0, 0, 1);\\n            adjacentCells.add(root);\\n        }\\n\\n        while (adjacentCells.isEmpty() == false) {\\n\\n            Vertex currCell = adjacentCells.remove();\\n            int row = currCell.row, col = currCell.col;\\n\\n            // isSeen[row][col] = true;\\n\\n            // System.out.println(row + \" \" + col);\\n\\n            if (row == N - 1 && col == N - 1)\\n            {\\n                len = currCell.lenSoFar;\\n                break;\\n            }\\n\\n            // Vertex downright, downleft, upright, upleft, up, left, right, down;\\n            if (isValid(row + 1, col + 1, N, grid, isSeen))\\n            {\\n                Vertex downright = new Vertex(row + 1, col + 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(downright);\\n            }\\n\\n            if (isValid(row + 1, col - 1, N, grid, isSeen))\\n            {\\n                Vertex downleft = new Vertex(row + 1, col - 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(downleft);\\n            }\\n\\n            if (isValid(row - 1, col + 1, N, grid, isSeen))\\n            {\\n                Vertex upright = new Vertex(row - 1, col + 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(upright);\\n            }\\n\\n            if (isValid(row - 1, col - 1, N, grid, isSeen))\\n            {\\n                Vertex upleft = new Vertex(row - 1, col - 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(upleft);\\n            }\\n\\n            if (isValid(row - 1, col, N, grid, isSeen))\\n            {\\n                Vertex up = new Vertex(row - 1, col, currCell.lenSoFar + 1);\\n                adjacentCells.add(up);\\n            }\\n\\n            if (isValid(row, col - 1, N, grid, isSeen))\\n            {\\n                Vertex left = new Vertex(row, col - 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(left);\\n            }\\n\\n            if (isValid(row + 1, col, N, grid, isSeen))\\n            {\\n                Vertex down = new Vertex(row + 1, col, currCell.lenSoFar + 1);\\n                adjacentCells.add(down);\\n            }\\n\\n            if (isValid(row, col + 1, N, grid, isSeen))\\n            {\\n                Vertex right = new Vertex(row, col + 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(right);\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Vertex {\\n        int row;\\n        int col;\\n        int lenSoFar;\\n\\n        Vertex(int row, int col, int lenSoFar) {\\n            this.row = row;\\n            this.col = col;\\n            this.lenSoFar = lenSoFar;\\n        }\\n    }\\n\\n    public boolean isValid(int row, int col, int N, int [][]grid, boolean [][]isSeen) {\\n        if ( row >= 0 && row < N \\n        && col >= 0 && col < N\\n         && grid[row][col] == 0\\n          && isSeen[row][col] == false) {\\n              isSeen[row][col] = true;\\n              return true;\\n          }\\n        return false;\\n    }\\n\\n    public void printGrid(int [][]grid, int N) {\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                System.out.print(grid[i][j]);\\n            }\\n            System.out.println(\\',\\');\\n        }\\n    }\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        \\n        int N = grid[0].length;\\n\\n        // printGrid(grid, N);\\n\\n        int len = -1;\\n\\n        boolean[][] isSeen = new boolean[N][N];\\n        Queue<Vertex> adjacentCells = new LinkedList<>();\\n\\n        if (isValid(0, 0, N, grid, isSeen))\\n        {\\n            Vertex root = new Vertex(0, 0, 1);\\n            adjacentCells.add(root);\\n        }\\n\\n        while (adjacentCells.isEmpty() == false) {\\n\\n            Vertex currCell = adjacentCells.remove();\\n            int row = currCell.row, col = currCell.col;\\n\\n            // isSeen[row][col] = true;\\n\\n            // System.out.println(row + \" \" + col);\\n\\n            if (row == N - 1 && col == N - 1)\\n            {\\n                len = currCell.lenSoFar;\\n                break;\\n            }\\n\\n            // Vertex downright, downleft, upright, upleft, up, left, right, down;\\n            if (isValid(row + 1, col + 1, N, grid, isSeen))\\n            {\\n                Vertex downright = new Vertex(row + 1, col + 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(downright);\\n            }\\n\\n            if (isValid(row + 1, col - 1, N, grid, isSeen))\\n            {\\n                Vertex downleft = new Vertex(row + 1, col - 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(downleft);\\n            }\\n\\n            if (isValid(row - 1, col + 1, N, grid, isSeen))\\n            {\\n                Vertex upright = new Vertex(row - 1, col + 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(upright);\\n            }\\n\\n            if (isValid(row - 1, col - 1, N, grid, isSeen))\\n            {\\n                Vertex upleft = new Vertex(row - 1, col - 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(upleft);\\n            }\\n\\n            if (isValid(row - 1, col, N, grid, isSeen))\\n            {\\n                Vertex up = new Vertex(row - 1, col, currCell.lenSoFar + 1);\\n                adjacentCells.add(up);\\n            }\\n\\n            if (isValid(row, col - 1, N, grid, isSeen))\\n            {\\n                Vertex left = new Vertex(row, col - 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(left);\\n            }\\n\\n            if (isValid(row + 1, col, N, grid, isSeen))\\n            {\\n                Vertex down = new Vertex(row + 1, col, currCell.lenSoFar + 1);\\n                adjacentCells.add(down);\\n            }\\n\\n            if (isValid(row, col + 1, N, grid, isSeen))\\n            {\\n                Vertex right = new Vertex(row, col + 1, currCell.lenSoFar + 1);\\n                adjacentCells.add(right);\\n            }\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584719,
                "title": "very-easy-fast-c-soln-bfs-beginner-friendly",
                "content": "### **Please upvote if it helps.**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        int n = grid.size();\\n        if(grid[0][0] != 0 || grid[n-1][n-1] != 0)\\n            return -1;\\n        if(n-1 == 0)\\n            return 1;\\n        grid[0][0] = 1;  \\n        q.push({0,0});\\n        int count = 0;\\n        int flag = 0;\\n        vector<int> r = {0,1,-1,0,1,-1,1,-1};\\n        vector<int> c = {1,0,0,-1,1,1,-1,-1};\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            queue<pair<int,int>> temp;\\n            count++;\\n            while(size--)\\n            {\\n                int row = q.front().first;\\n                int col = q.front().second;\\n                q.pop();\\n                for(int i = 0; i<8; i++)\\n                {\\n                    int x = row + r[i], y = col + c[i];\\n                    if(x == n-1 && y == n-1)\\n                    {\\n                        flag = 1;\\n                        count++;\\n                        break;\\n                    }\\n                    if(x >= 0 && y >= 0 && x < n && y < n)\\n                    {\\n                        if(grid[x][y] == 0)\\n                        {\\n                            temp.push({x,y});\\n                            grid[x][y] = 1;\\n                        }\\n                    }\\n                }\\n                if(flag == 1)\\n                    break;\\n            }\\n            q = temp;\\n            if(flag == 1)\\n                break;\\n        }\\n        if(flag == 0)\\n            return -1;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        queue<pair<int,int>> q;\\n        int n = grid.size();\\n        if(grid[0][0] != 0 || grid[n-1][n-1] != 0)\\n            return -1;\\n        if(n-1 == 0)\\n            return 1;\\n        grid[0][0] = 1;  \\n        q.push({0,0});\\n        int count = 0;\\n        int flag = 0;\\n        vector<int> r = {0,1,-1,0,1,-1,1,-1};\\n        vector<int> c = {1,0,0,-1,1,1,-1,-1};\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            queue<pair<int,int>> temp;\\n            count++;\\n            while(size--)\\n            {\\n                int row = q.front().first;\\n                int col = q.front().second;\\n                q.pop();\\n                for(int i = 0; i<8; i++)\\n                {\\n                    int x = row + r[i], y = col + c[i];\\n                    if(x == n-1 && y == n-1)\\n                    {\\n                        flag = 1;\\n                        count++;\\n                        break;\\n                    }\\n                    if(x >= 0 && y >= 0 && x < n && y < n)\\n                    {\\n                        if(grid[x][y] == 0)\\n                        {\\n                            temp.push({x,y});\\n                            grid[x][y] = 1;\\n                        }\\n                    }\\n                }\\n                if(flag == 1)\\n                    break;\\n            }\\n            q = temp;\\n            if(flag == 1)\\n                break;\\n        }\\n        if(flag == 0)\\n            return -1;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584653,
                "title": "python-short-and-clean-bfs-functional-programming",
                "content": "# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n\\n- Space complexity: $$O(n ^ 2)$$\\n\\nwhere, `n * n is the dimensions of the grid.`\\n\\n# Code\\n```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: list[list[int]]) -> int:\\n        n = len(grid)\\n        start, end = (0, 0), (n - 1, n - 1)\\n\\n        # Helper functions\\n        in_bound = lambda cell: 0 <= cell[0] < n and 0 <= cell[1] < n\\n        grid_get = lambda cell: grid[cell[0]][cell[1]] if in_bound(cell) else 1\\n        all_nbrs = lambda cell: product(range(cell[0] - 1, cell[0] + 2), range(cell[1] - 1, cell[1] + 2))\\n        is_clear = lambda cell, skips: grid_get(cell) == 0 and cell not in skips\\n\\n        if start == end: return -1 if grid_get(start) else 1\\n        queue = deque([] if grid_get(start) else [(start, 1)])\\n        seen = {start}\\n        valid_nbr = partial(is_clear, skips=seen)\\n\\n        while queue:\\n            cell, length = queue.popleft()\\n            valid_nbrs = set(filter(valid_nbr, all_nbrs(cell)))\\n\\n            if end in valid_nbrs: return length + 1\\n            queue.extend(zip(valid_nbrs, repeat(length + 1)))\\n            seen.update(valid_nbrs)\\n        \\n        return -1\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```python\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: list[list[int]]) -> int:\\n        n = len(grid)\\n        start, end = (0, 0), (n - 1, n - 1)\\n\\n        # Helper functions\\n        in_bound = lambda cell: 0 <= cell[0] < n and 0 <= cell[1] < n\\n        grid_get = lambda cell: grid[cell[0]][cell[1]] if in_bound(cell) else 1\\n        all_nbrs = lambda cell: product(range(cell[0] - 1, cell[0] + 2), range(cell[1] - 1, cell[1] + 2))\\n        is_clear = lambda cell, skips: grid_get(cell) == 0 and cell not in skips\\n\\n        if start == end: return -1 if grid_get(start) else 1\\n        queue = deque([] if grid_get(start) else [(start, 1)])\\n        seen = {start}\\n        valid_nbr = partial(is_clear, skips=seen)\\n\\n        while queue:\\n            cell, length = queue.popleft()\\n            valid_nbrs = set(filter(valid_nbr, all_nbrs(cell)))\\n\\n            if end in valid_nbrs: return length + 1\\n            queue.extend(zip(valid_nbrs, repeat(length + 1)))\\n            seen.update(valid_nbrs)\\n        \\n        return -1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584615,
                "title": "easy-java-bfs-solution-beats-98-online-submissions",
                "content": "# Code\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] == 1 || grid[grid.length-1][grid[0].length-1] == 1) return -1;\\n\\n        int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0},{1,1},{-1,-1},{-1,1},{1,-1}};\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0});\\n        grid[0][0] = 1;\\n        int level = 1;\\n\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                int[] curr = q.poll();\\n                if(curr[0] == grid.length-1 && curr[1] == grid[0].length-1) return level;\\n                for(int[] dir : dirs){\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 0){\\n                        q.add(new int[]{x,y});\\n                        grid[x][y] = 1;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        if(grid[0][0] == 1 || grid[grid.length-1][grid[0].length-1] == 1) return -1;\\n\\n        int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0},{1,1},{-1,-1},{-1,1},{1,-1}};\\n\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0,0});\\n        grid[0][0] = 1;\\n        int level = 1;\\n\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                int[] curr = q.poll();\\n                if(curr[0] == grid.length-1 && curr[1] == grid[0].length-1) return level;\\n                for(int[] dir : dirs){\\n                    int x = curr[0] + dir[0];\\n                    int y = curr[1] + dir[1];\\n                    if(x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && grid[x][y] == 0){\\n                        q.add(new int[]{x,y});\\n                        grid[x][y] = 1;\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584396,
                "title": "simple-solution-c-100-runtime-efficient",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n*We\\'ll use simple BFS approach to visit neighbouirng 8 cells in each iteration till we reach the right-bottom cell.*\\n\\n![Screenshot 2023-06-01 092404.png](https://assets.leetcode.com/users/images/a684c3ea-c9d5-48b0-8f53-b3afc60f7b78_1685591665.4052565.png)\\n\\n***While visiting each cell with value \\'0\\', we\\'ll update it\\'s value with the distance so far from the left-top cell. This can help us in avoiding using separate array/hashset to track visited cells.***\\n\\n*We\\'ll use Queues of tuples to push cordinates of each cell to be visited next.*\\n<br>\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2) - as we enqueue at most all N^2 elements in the array in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N^2) - as we push N^2 elements in worst case\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\npublic class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.Length;\\n        //check if top-left and bottom-right cells are 0.\\n        if (grid[0][0] != 0 || grid[n - 1][n - 1 ] != 0)\\n            return -1;\\n\\n        //check if there\\'s only one cell, if yes - check if it is 0\\n        if (n == 1 && grid[0][0] == 0)\\n            return 1;\\n\\n        //Get moves to be made to traverse in 8 directions\\n        List<(int r, int c)> directions = GetDirections();\\n\\n        //Queue to hold cordinates of cell to be visited next\\n        Queue<(int x, int y)> q = new Queue<(int, int)>();\\n        q.Enqueue((0, 0));\\n        grid[0][0] = 1;\\n\\n        while (q.Count > 0)\\n        {\\n            (int cr, int cc) = q.Dequeue();\\n        \\n            //fixed 8 loops - O(1) runtime for this loop\\n            for (int i = 0; i < directions.Count; i++)\\n            {\\n                //neighbouring row-col cell to check\\n                int row = cr + directions[i].r;\\n                int col = cc + directions[i].c;\\n                if (row >= 0 && row < n\\n                    && col >= 0 && col < n && grid[row][col] == 0)\\n                {\\n                    grid[row][col] = grid[cr][cc] + 1;\\n                    //if we have reached bottom-right cell\\n                    if (row == n - 1 && col == n - 1)\\n                        return (grid[row][col]);\\n\\n                    q.Enqueue((row, col));\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private List<(int, int)> GetDirections()\\n    {\\n        List<(int r, int c)> directions = new List<(int, int)>();\\n        directions.Add((-1, -1));\\n        directions.Add((-1, 0));\\n        directions.Add((-1, 1));\\n        directions.Add((0, -1));\\n        directions.Add((0, 1));\\n        directions.Add((1, -1));\\n        directions.Add((1, 0));\\n        directions.Add((1, 1));\\n\\n        return directions;\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach, as it would encourage us more :)\\n![Upvote please - Monkey.jpg](https://assets.leetcode.com/users/images/1dca1454-b7b2-4c9b-a65d-ac809957991a_1685591973.541374.jpeg)\\n",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\npublic class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.Length;\\n        //check if top-left and bottom-right cells are 0.\\n        if (grid[0][0] != 0 || grid[n - 1][n - 1 ] != 0)\\n            return -1;\\n\\n        //check if there\\'s only one cell, if yes - check if it is 0\\n        if (n == 1 && grid[0][0] == 0)\\n            return 1;\\n\\n        //Get moves to be made to traverse in 8 directions\\n        List<(int r, int c)> directions = GetDirections();\\n\\n        //Queue to hold cordinates of cell to be visited next\\n        Queue<(int x, int y)> q = new Queue<(int, int)>();\\n        q.Enqueue((0, 0));\\n        grid[0][0] = 1;\\n\\n        while (q.Count > 0)\\n        {\\n            (int cr, int cc) = q.Dequeue();\\n        \\n            //fixed 8 loops - O(1) runtime for this loop\\n            for (int i = 0; i < directions.Count; i++)\\n            {\\n                //neighbouring row-col cell to check\\n                int row = cr + directions[i].r;\\n                int col = cc + directions[i].c;\\n                if (row >= 0 && row < n\\n                    && col >= 0 && col < n && grid[row][col] == 0)\\n                {\\n                    grid[row][col] = grid[cr][cc] + 1;\\n                    //if we have reached bottom-right cell\\n                    if (row == n - 1 && col == n - 1)\\n                        return (grid[row][col]);\\n\\n                    q.Enqueue((row, col));\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    private List<(int, int)> GetDirections()\\n    {\\n        List<(int r, int c)> directions = new List<(int, int)>();\\n        directions.Add((-1, -1));\\n        directions.Add((-1, 0));\\n        directions.Add((-1, 1));\\n        directions.Add((0, -1));\\n        directions.Add((0, 1));\\n        directions.Add((1, -1));\\n        directions.Add((1, 0));\\n        directions.Add((1, 1));\\n\\n        return directions;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584370,
                "title": "simple-python3-solution-using-bfs-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsearch for the shortest path from the start point to the end point through BFS traversal.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a queue to store the grids to be processed, and initially adds the starting point to the queue. Then, take a grid out of the queue for processing, explore its adjacent grids, and add unvisited adjacent grids to the queue. This process continues until an end point is found or the queue is empty.\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n\\n        # Check if the start/end cell is blocked.\\n        if grid[0][0] != 0 or grid[n-1][n-1] != 0:\\n            return -1\\n\\n        # Create a queue for BFS and enqueue the start cell\\n        queue = deque([(0, 0, 1)])  #(row, col, path_length)\\n\\n        # Offset in 8 directions\\n        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\\n        \\n        # Execute BFS\\n        while queue:\\n\\n            row, col, path_len = queue.popleft()\\n            \\n            # Check if the goal has been reached.\\n            if row == n-1 and col == n-1:\\n                return path_len\\n\\n            # Explore adjacent grids.\\n            for i, j in directions:\\n                neighbour_row = i + row\\n                neighbour_col = j + col\\n\\n                # Check if the adjacent grid is within the grid range and has not been visited\\n                if 0 <= neighbour_row < n and 0 <= neighbour_col < n and grid[neighbour_row][neighbour_col] == 0:\\n                    # Mark adjacent cells as visited (set to 1)\\n                    grid[neighbour_row][neighbour_col] = 1\\n                    queue.append((neighbour_row, neighbour_col, path_len + 1))\\n\\n        # No clear path found\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n\\n        # Check if the start/end cell is blocked.\\n        if grid[0][0] != 0 or grid[n-1][n-1] != 0:\\n            return -1\\n\\n        # Create a queue for BFS and enqueue the start cell\\n        queue = deque([(0, 0, 1)])  #(row, col, path_length)\\n\\n        # Offset in 8 directions\\n        directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\\n        \\n        # Execute BFS\\n        while queue:\\n\\n            row, col, path_len = queue.popleft()\\n            \\n            # Check if the goal has been reached.\\n            if row == n-1 and col == n-1:\\n                return path_len\\n\\n            # Explore adjacent grids.\\n            for i, j in directions:\\n                neighbour_row = i + row\\n                neighbour_col = j + col\\n\\n                # Check if the adjacent grid is within the grid range and has not been visited\\n                if 0 <= neighbour_row < n and 0 <= neighbour_col < n and grid[neighbour_row][neighbour_col] == 0:\\n                    # Mark adjacent cells as visited (set to 1)\\n                    grid[neighbour_row][neighbour_col] = 1\\n                    queue.append((neighbour_row, neighbour_col, path_len + 1))\\n\\n        # No clear path found\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584254,
                "title": "java-solution-for-shortest-path-in-binary-matrix-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The goal is to find the shortest clear path from the top-left cell to the bottom-right cell in the binary matrix.\\n- A clear path consists of cells with a value of 0, and adjacent cells are considered 8-directionally connected.\\n- The BFS algorithm is used to explore cells in a breadth-first manner, starting from the top-left cell and moving towards the bottom-right cell.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The algorithm starts by checking if the top-left and bottom-right cells are obstacles (1). If either of them is an obstacle, there is no clear path, and -1 is returned.\\n1. A directions array is defined to represent the 8 possible directions to explore neighboring cells.\\n1. A queue is initialized, and the top-left cell is added to the queue as the starting point.\\n1. The grid is updated to mark the starting cell as visited.\\n1. A pathLength variable is initialized to track the length of the path.\\n1. The algorithm enters a while loop until the queue becomes empty:\\n- The size of the current level is obtained from the queue.\\n- For each cell in the current level:\\n- If the cell is the bottom-right cell, the pathLength is returned as the shortest clear path.\\n- For each direction in the directions array:\\n- The neighboring cell coordinates are calculated based on the current cell and the direction.\\n- If the neighboring cell is within the grid boundaries, has a value of 0, and hasn\\'t been visited:\\n- The neighboring cell is added to the queue.\\n- The neighboring cell is marked as visited in the grid.\\n7. The pathLength is incremented to move to the next level.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the BFS algorithm is O(V + E), where V is the number of vertices (cells) and E is the number of edges (adjacent connections). In this case, V represents the number of cells in the grid, which is n^2, and E is proportional to V, as each cell has at most 8 neighbors in the 8-directional connectivity. Therefore, the time complexity is O(n^2).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is determined by the queue and the grid. The queue can store at most n^2 cells in the worst case, resulting in O(n^2) space. The grid uses O(n^2) space as well to represent the visited status of each cell. Hence, the overall space complexity is O(n^2).\\n\\n# Code\\n```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n         int n = grid.length;\\n        if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1) {\\n            return -1; // There is no clear path from the start to the end\\n        }\\n\\n        int[][] directions = {\\n            {-1, -1}, {-1, 0}, {-1, 1},\\n            {0, -1},           {0, 1},\\n            {1, -1},  {1, 0},  {1, 1}\\n        };\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0}); // Start from the top-left cell\\n        grid[0][0] = 1; // Mark the starting cell as visited\\n\\n        int pathLength = 1;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int[] cell = queue.poll();\\n                int row = cell[0];\\n                int col = cell[1];\\n\\n                if (row == n - 1 && col == n - 1) {\\n                    return pathLength; // Reached the bottom-right cell, return the path length\\n                }\\n\\n                for (int[] direction : directions) {\\n                    int newRow = row + direction[0];\\n                    int newCol = col + direction[1];\\n\\n                    if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                        queue.offer(new int[]{newRow, newCol});\\n                        grid[newRow][newCol] = 1; // Mark the cell as visited\\n                    }\\n                }\\n            }\\n\\n            pathLength++;\\n        }\\n\\n        return -1; // There is no clear path from the start to the end\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n         int n = grid.length;\\n        if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1) {\\n            return -1; // There is no clear path from the start to the end\\n        }\\n\\n        int[][] directions = {\\n            {-1, -1}, {-1, 0}, {-1, 1},\\n            {0, -1},           {0, 1},\\n            {1, -1},  {1, 0},  {1, 1}\\n        };\\n\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{0, 0}); // Start from the top-left cell\\n        grid[0][0] = 1; // Mark the starting cell as visited\\n\\n        int pathLength = 1;\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int[] cell = queue.poll();\\n                int row = cell[0];\\n                int col = cell[1];\\n\\n                if (row == n - 1 && col == n - 1) {\\n                    return pathLength; // Reached the bottom-right cell, return the path length\\n                }\\n\\n                for (int[] direction : directions) {\\n                    int newRow = row + direction[0];\\n                    int newCol = col + direction[1];\\n\\n                    if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                        queue.offer(new int[]{newRow, newCol});\\n                        grid[newRow][newCol] = 1; // Mark the cell as visited\\n                    }\\n                }\\n            }\\n\\n            pathLength++;\\n        }\\n\\n        return -1; // There is no clear path from the start to the end\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442502,
                "title": "shortest-path-with-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass pair{\\n    int first,second,third;\\n    pair(int first,int second,int third)\\n    {\\n        this.first=first;\\n        this.second=second;\\n        this.third=third;\\n    }\\n}\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n=grid.length;\\n        if(grid[0][0]!=0 || grid[n-1][n-1]!=0){\\n            return -1;\\n        }\\n        if(n-1==0)return 1;\\n        Queue<pair> q =new LinkedList<>();\\n        int dis[][]=new int[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                dis[i][j]=Integer.MAX_VALUE;\\n            }\\n        }\\n        dis[0][0]=0;\\n        q.add(new pair(0,0,0));\\n        int dr[] = {0, -1, -1, -1, 0, 1, 1, 1};\\n        int[] dc = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        while(!q.isEmpty()){\\n            pair p=q.peek();\\n            q.poll();\\n            int k=p.first;\\n            int y=p.second;\\n            int z=p.third;\\n            for(int i=0;i<8;i++)\\n            {\\n                int nr=y+dr[i];\\n                int nc=z+dc[i];\\n                if(nr>=0 && nr<n && nc>=0 && nc<n && grid[nr][nc]==0 && k+1<dis[nr][nc]){\\n                    dis[nr][nc]=k+1;\\n                    if(nr==n-1 && nc==n-1){\\n                        return k+2;\\n                    }\\n                    q.add(new pair(k+1,nr,nc));\\n                }\\n            }\\n        }\\n        return -1;     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass pair{\\n    int first,second,third;\\n    pair(int first,int second,int third)\\n    {\\n        this.first=first;\\n        this.second=second;\\n        this.third=third;\\n    }\\n}\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n=grid.length;\\n        if(grid[0][0]!=0 || grid[n-1][n-1]!=0){\\n            return -1;\\n        }\\n        if(n-1==0)return 1;\\n        Queue<pair> q =new LinkedList<>();\\n        int dis[][]=new int[n][n];\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                dis[i][j]=Integer.MAX_VALUE;\\n            }\\n        }\\n        dis[0][0]=0;\\n        q.add(new pair(0,0,0));\\n        int dr[] = {0, -1, -1, -1, 0, 1, 1, 1};\\n        int[] dc = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        while(!q.isEmpty()){\\n            pair p=q.peek();\\n            q.poll();\\n            int k=p.first;\\n            int y=p.second;\\n            int z=p.third;\\n            for(int i=0;i<8;i++)\\n            {\\n                int nr=y+dr[i];\\n                int nc=z+dc[i];\\n                if(nr>=0 && nr<n && nc>=0 && nc<n && grid[nr][nc]==0 && k+1<dis[nr][nc]){\\n                    dis[nr][nc]=k+1;\\n                    if(nr==n-1 && nc==n-1){\\n                        return k+2;\\n                    }\\n                    q.add(new pair(k+1,nr,nc));\\n                }\\n            }\\n        }\\n        return -1;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3417571,
                "title": "bfs-dijkstra-logic-python-explained",
                "content": "# Intuition\\ncreate a distance matrix of size grid and run a bfs over it\\nfor every new visit of node if we find the curr vist + 1 < prev distance stored then update the distance (as a shorter path is available)\\n`why curr vist + 1 ? Becuase cost of visiting each new cell is 1`\\nreturn the value stored in the last cell as the smallest cost required to reach the path.\\n\\n**NOTE -> unlike other graph questions u can visit here diagonals too so make the directions array accordingly**\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        # BASE CASE ->\\n        if grid[0][0] != 0 or grid[-1][-1] != 0: \\n            return -1\\n\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        directions = [(-1, 0), (0, 1), (1, 0), (0, -1), (1, -1), (-1, -1), (-1, 1), (1, 1)]\\n        q = deque()\\n        distance = [[float(\\'inf\\')] * (COLS) for _ in range(ROWS)]\\n\\n        distance[0][0] = 1 # starting cost is 1\\n        q.append((0, 0, distance[0][0])) #currRow, currCol, currDistance      \\n        \\n        while q:\\n            currRow, currCol, currDistance = q.popleft()\\n            for dr, dc in directions:\\n                r = currRow + dr\\n                c = currCol + dc\\n                if r in range(ROWS) and c in range(COLS) and grid[r][c] == 0:\\n                    if distance[r][c] > currDistance + 1: \\n                        distance[r][c] = currDistance + 1 #update distance if smaller found\\n                        q.append((r, c, distance[r][c]))\\n        if distance[-1][-1] == float(\\'inf\\'): #path not possible\\n            return -1\\n        return distance[-1][-1]\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        # BASE CASE ->\\n        if grid[0][0] != 0 or grid[-1][-1] != 0: \\n            return -1\\n\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        directions = [(-1, 0), (0, 1), (1, 0), (0, -1), (1, -1), (-1, -1), (-1, 1), (1, 1)]\\n        q = deque()\\n        distance = [[float(\\'inf\\')] * (COLS) for _ in range(ROWS)]\\n\\n        distance[0][0] = 1 # starting cost is 1\\n        q.append((0, 0, distance[0][0])) #currRow, currCol, currDistance      \\n        \\n        while q:\\n            currRow, currCol, currDistance = q.popleft()\\n            for dr, dc in directions:\\n                r = currRow + dr\\n                c = currCol + dc\\n                if r in range(ROWS) and c in range(COLS) and grid[r][c] == 0:\\n                    if distance[r][c] > currDistance + 1: \\n                        distance[r][c] = currDistance + 1 #update distance if smaller found\\n                        q.append((r, c, distance[r][c]))\\n        if distance[-1][-1] == float(\\'inf\\'): #path not possible\\n            return -1\\n        return distance[-1][-1]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351602,
                "title": "bfs-dijkstra-approaches",
                "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# BFS\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n= grid.size(); int m= grid[0].size();\\n        int lvl=0;\\n        int dx[]= {0,0,1,1,1,-1,-1,-1};\\n        int dy[]= {1,-1,0,1,-1,0,1,-1};\\n        queue<pair<int,int>> q; \\n        q.push({0,0});\\n        if (grid[0][0]==1)return -1;\\n        \\n        while (!q.empty()){\\n            int sz= q.size();\\n            lvl++;\\n            for (int i=0; i<sz; i++){\\n                int x= q.front().first;\\n                int y= q.front().second;\\n                \\n                if (x==n-1 && y==m-1)return lvl;\\n                q.pop();\\n                for (int it=0; it<8; it++){\\n                    int nr= x+dx[it];\\n                    int nc= y+dy[it];\\n                    if (nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc]==0){\\n                        grid[nr][nc]=1;\\n                        q.push({nr,nc});\\n                        //if (nr==n-1 && nc==m-1)return lvl+1;\\n                    }\\n                }\\n            }\\n            //lvl++;\\n        }\\n        return -1;\\n    }\\n}; \\n```\\n\\n\\n# DIJKSTRA\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int dx[]= {0,0,1,1,1,-1,-1,-1};\\n        int dy[]= {1,-1,0,1,-1,0,1,-1};\\n        if (grid[0][0]==1)return -1;\\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>> > pq;\\n        pq.push({0,{0,0}});\\n        while (!pq.empty()){\\n            auto top= pq.top();\\n            pq.pop();\\n            int dis= top.first;\\n            int x= top.second.first;\\n            int y= top.second.second;\\n            if (x==n-1 && y==n-1)return dis+1;\\n            for (int it=0; it<8; it++){\\n                int xx= x+dx[it];\\n                int yy= y+dy[it];\\n                if (xx>=0 && xx<n && yy>=0 && yy<n && grid[xx][yy]==0){\\n                    pq.push({dis+1,{xx,yy}});\\n                    grid[xx][yy]=1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n= grid.size(); int m= grid[0].size();\\n        int lvl=0;\\n        int dx[]= {0,0,1,1,1,-1,-1,-1};\\n        int dy[]= {1,-1,0,1,-1,0,1,-1};\\n        queue<pair<int,int>> q; \\n        q.push({0,0});\\n        if (grid[0][0]==1)return -1;\\n        \\n        while (!q.empty()){\\n            int sz= q.size();\\n            lvl++;\\n            for (int i=0; i<sz; i++){\\n                int x= q.front().first;\\n                int y= q.front().second;\\n                \\n                if (x==n-1 && y==m-1)return lvl;\\n                q.pop();\\n                for (int it=0; it<8; it++){\\n                    int nr= x+dx[it];\\n                    int nc= y+dy[it];\\n                    if (nr>=0 && nr<n && nc>=0 && nc<m && grid[nr][nc]==0){\\n                        grid[nr][nc]=1;\\n                        q.push({nr,nc});\\n                        //if (nr==n-1 && nc==m-1)return lvl+1;\\n                    }\\n                }\\n            }\\n            //lvl++;\\n        }\\n        return -1;\\n    }\\n}; \\n```\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n= grid.size();\\n        int dx[]= {0,0,1,1,1,-1,-1,-1};\\n        int dy[]= {1,-1,0,1,-1,0,1,-1};\\n        if (grid[0][0]==1)return -1;\\n        priority_queue< pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>> > pq;\\n        pq.push({0,{0,0}});\\n        while (!pq.empty()){\\n            auto top= pq.top();\\n            pq.pop();\\n            int dis= top.first;\\n            int x= top.second.first;\\n            int y= top.second.second;\\n            if (x==n-1 && y==n-1)return dis+1;\\n            for (int it=0; it<8; it++){\\n                int xx= x+dx[it];\\n                int yy= y+dy[it];\\n                if (xx>=0 && xx<n && yy>=0 && yy<n && grid[xx][yy]==0){\\n                    pq.push({dis+1,{xx,yy}});\\n                    grid[xx][yy]=1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204526,
                "title": "c-bfs-implementation-64ms-88-beaten",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe description of the question boils down to finding the shortest path of an unweighted and undirected graph.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThis solution is an implementation of **Breadth First Search** (BFS) where the **visited** and **distance** are 2D arrays. The start index `grid[0][0]` should be checked if it\\'s `1`, in which a solution is **not possible**. \\n\\n##### Breakdown of BFS\\n---\\n1. Push start into the queue, set `visited[start] = true` and `dist[start] = 1`\\n2. Explore all possible edges that the current edge leads to, in this case, it\\'s the 8 possible cells that are adjacent to the current edge\\n3. Add the candidate edges to the queue. Set `distance[new] = distance[current] + 1` and `visited[new] = true`\\n4. Repeat 2-3 until queue is empty\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n    pair<int, int> d[8]{{0,1}, {0,-1}, {-1,-1}, {-1,0}, {-1, 1}, {1,-1}, {1,0}, {1,1}}; // Possible Changes in Location\\n\\n    int v[101][101], dist[101][101]; // Visited (v) and Distance (dist)\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        queue<pair<int, int>> q; // BFS queue\\n        int size = grid.size();\\n\\n        if (grid[0][0]) return -1;\\n\\n        v[0][0] = true; dist[0][0] = 1; q.emplace(0, 0);\\n\\n        while (!q.empty()) {\\n            auto [r, c] = q.front(); q.pop();\\n\\n            for (auto& [dr, dc] : d) {\\n                int nr = r + dr, nc = c + dc;\\n\\n                if (nr >= 0 && nc >= 0 && nr < size && nc < size && !v[nr][nc] && !grid[nr][nc]) {\\n                    v[nr][nc] = 1;\\n                    q.emplace(nr, nc);\\n                    dist[nr][nc] = dist[r][c] + 1;\\n                }\\n            }\\n        }\\n\\n        return (v[size-1][size-1] ? dist[size-1][size-1] : -1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    pair<int, int> d[8]{{0,1}, {0,-1}, {-1,-1}, {-1,0}, {-1, 1}, {1,-1}, {1,0}, {1,1}}; // Possible Changes in Location\\n\\n    int v[101][101], dist[101][101]; // Visited (v) and Distance (dist)\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        queue<pair<int, int>> q; // BFS queue\\n        int size = grid.size();\\n\\n        if (grid[0][0]) return -1;\\n\\n        v[0][0] = true; dist[0][0] = 1; q.emplace(0, 0);\\n\\n        while (!q.empty()) {\\n            auto [r, c] = q.front(); q.pop();\\n\\n            for (auto& [dr, dc] : d) {\\n                int nr = r + dr, nc = c + dc;\\n\\n                if (nr >= 0 && nc >= 0 && nr < size && nc < size && !v[nr][nc] && !grid[nr][nc]) {\\n                    v[nr][nc] = 1;\\n                    q.emplace(nr, nc);\\n                    dist[nr][nc] = dist[r][c] + 1;\\n                }\\n            }\\n        }\\n\\n        return (v[size-1][size-1] ? dist[size-1][size-1] : -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195760,
                "title": "c-using-bfs-t-c-o-n-2-s-c-o-n-2",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity = O(N^2)\\n        Space Complexity = O(N^2)\\n    */\\n    \\n    int m, n;\\n    \\n    bool isValid(int i, int j, vector<vector<int>>& grid){\\n        if(i>=0 && j>=0 && i<m && j<n && grid[i][j] == 0) return true;\\n        else return false;\\n    }\\n    \\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dist(m, vector<int>(n, -1));\\n        \\n        queue<pair<int, int>> q1;\\n        \\n        if(grid[0][0] == 0){\\n            q1.push({0, 0});\\n            dist[0][0] = 1;\\n        }else\\n            return -1;\\n        \\n        // Directions\\n        vector<int> x = {-1, +1, 0, 0, -1, +1, -1, +1};\\n        vector<int> y = {0, 0, -1, +1, -1, +1, +1, -1};\\n        \\n        while(!q1.empty()){\\n            pair<int, int> curr = q1.front();\\n            q1.pop();\\n            \\n            for(int k=0; k<8; k++){\\n                int newX = curr.first + x[k];\\n                int newY = curr.second + y[k];\\n                \\n                if(isValid(newX, newY, grid) && dist[newX][newY]==-1){\\n                    dist[newX][newY] = dist[curr.first][curr.second]+1;\\n                    q1.push({newX, newY});\\n                }\\n            }\\n        }\\n        \\n        if(dist[m-1][n-1] == -1)\\n            return -1;\\n        \\n        return dist[m-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    /*\\n        Time Complexity = O(N^2)\\n        Space Complexity = O(N^2)\\n    */\\n    \\n    int m, n;\\n    \\n    bool isValid(int i, int j, vector<vector<int>>& grid){\\n        if(i>=0 && j>=0 && i<m && j<n && grid[i][j] == 0) return true;\\n        else return false;\\n    }\\n    \\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> dist(m, vector<int>(n, -1));\\n        \\n        queue<pair<int, int>> q1;\\n        \\n        if(grid[0][0] == 0){\\n            q1.push({0, 0});\\n            dist[0][0] = 1;\\n        }else\\n            return -1;\\n        \\n        // Directions\\n        vector<int> x = {-1, +1, 0, 0, -1, +1, -1, +1};\\n        vector<int> y = {0, 0, -1, +1, -1, +1, +1, -1};\\n        \\n        while(!q1.empty()){\\n            pair<int, int> curr = q1.front();\\n            q1.pop();\\n            \\n            for(int k=0; k<8; k++){\\n                int newX = curr.first + x[k];\\n                int newY = curr.second + y[k];\\n                \\n                if(isValid(newX, newY, grid) && dist[newX][newY]==-1){\\n                    dist[newX][newY] = dist[curr.first][curr.second]+1;\\n                    q1.push({newX, newY});\\n                }\\n            }\\n        }\\n        \\n        if(dist[m-1][n-1] == -1)\\n            return -1;\\n        \\n        return dist[m-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126325,
                "title": "bfs-hindi-m-explain-c-easy",
                "content": "# Intuition\\nhar ek node par jana h jo ki 0 h ,aur 0 ke connected path m h\\nhum ise bfs se solve krnege\\n\\n# Approach\\nbfs ka use krke hum solve kr rahe h\\nsteps wise approach solution ke sath commented h\\n# Complexity\\n- Time complexity:\\nO(d) d is the no of zeroes\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // sabhi directions main badhne ke liye\\n    int mr[8][2]={\\n        {1,0},{-1,0},{0,1},{0,-1},{-1,-1},{1,1},{-1,1},{1,-1}\\n    };\\n\\n    // row aur col ka size store krne ke liye\\n    int row,col;\\n\\n    //actual bfs apply krne ke liye\\n    int solve(vector<vector<int>>&grid){\\n\\n        //A grid ka starting ya ending dono hi agar 1 h to hum kabhi path ni bana skte isliye -1 return krdo\\n        if(grid[0][0] || grid[row-1][col-1] ) return -1;\\n\\n        // ab agar grid m sirf ek hi element h to matlab starting or ending ek hi jagah h\\n        // aur ye element 0 hi hoga qki agar 1 hota to phle hi -1 return kr diya hota\\n        // qki ye ek hi element path m h isliye 1 return hoga ( yaha row = col =1  hai)\\n        if(row==col && row == 1) return row;\\n\\n        // check krne ke liye ki hum curr node ko visit kr chuke h ya nahi \\n        vector<vector<bool>> ch(row,vector<bool>(col,false));\\n\\n        // yaha humne queue to pair of pair is liye bana h qki \\n        // main pair group h location of cell or distance staring se \\n        // inner pair humari location bata rha h\\n        // { { x coordinate , y coordinate} , distance starting se }\\n        queue<pair<pair<int,int>,int>> q;\\n\\n        // answer mann liya bahut bada h\\n        int ans=INT_MAX;\\n\\n        // queue m starting position ko push krke uski location ko visited mark kr diya\\n        q.push({{0,0},1});\\n        ch[0][0]=1;\\n\\n        // ab bfs apply krte h\\n        while(!q.empty()){\\n\\n            // queue ke front m node h usse coordinates nikal lete h aur distance bhi \\n            // r humara current x coordinate h\\n            // c humara cuurent y coordinate h\\n            // d humara current node ka starting se dist h\\n            // akhir m humne queue se node pop kr diya\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int d = q.front().second;\\n            q.pop();\\n\\n            // ab curr location se har direction m connected nodes ki location nikalenge \\n            for(int i=0;i<8;i++){\\n\\n                //next location ke x or y coordinates \\n                int x = r + mr[i][0];\\n                int y = c + mr[i][1];\\n\\n                //ab hum check krenge ki humara node grid ke andar hi h na\\n                // aur agar andar h to wo nahi visited hua ho aur nahi usme 1 ho \\n                // matlab ki uska visited false ho aur grid mein x,y location pe 0 ho\\n                if(x<row && y<col && x>=0 && y>=0 && !ch[x][y] && !grid[x][y]){\\n                    \\n                    //agar sari condition sahi h to node ko visited mark krdo\\n                    ch[x][y]=true;\\n\\n                    // check kro agar humare next node destination yane row-1,col-1 node to nahi\\n                    // agar hn to ans, ya dis+1 m se chote distance ko return krdo\\n                    // yaha d+1 isliye kiya h qki d jo h wo current node ka distace h\\n                    // to next node ka distance d+1\\n                    if(x==row-1 && y==col-1 ) return min(ans,d+1);\\n\\n                    //aur agar ye destination ni h to queue m location or increse ki hui distance ka pair banake push krdo\\n                    q.push({{x,y},d+1});\\n                }\\n            }\\n        }\\n\\n        // hume path nahi milega tb hum yaha tk ayenge\\n        // isliye -1 return krdo\\n        return -1;\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n      row = grid.size();\\n      col = grid[0].size();\\n         \\n        return solve(grid);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // sabhi directions main badhne ke liye\\n    int mr[8][2]={\\n        {1,0},{-1,0},{0,1},{0,-1},{-1,-1},{1,1},{-1,1},{1,-1}\\n    };\\n\\n    // row aur col ka size store krne ke liye\\n    int row,col;\\n\\n    //actual bfs apply krne ke liye\\n    int solve(vector<vector<int>>&grid){\\n\\n        //A grid ka starting ya ending dono hi agar 1 h to hum kabhi path ni bana skte isliye -1 return krdo\\n        if(grid[0][0] || grid[row-1][col-1] ) return -1;\\n\\n        // ab agar grid m sirf ek hi element h to matlab starting or ending ek hi jagah h\\n        // aur ye element 0 hi hoga qki agar 1 hota to phle hi -1 return kr diya hota\\n        // qki ye ek hi element path m h isliye 1 return hoga ( yaha row = col =1  hai)\\n        if(row==col && row == 1) return row;\\n\\n        // check krne ke liye ki hum curr node ko visit kr chuke h ya nahi \\n        vector<vector<bool>> ch(row,vector<bool>(col,false));\\n\\n        // yaha humne queue to pair of pair is liye bana h qki \\n        // main pair group h location of cell or distance staring se \\n        // inner pair humari location bata rha h\\n        // { { x coordinate , y coordinate} , distance starting se }\\n        queue<pair<pair<int,int>,int>> q;\\n\\n        // answer mann liya bahut bada h\\n        int ans=INT_MAX;\\n\\n        // queue m starting position ko push krke uski location ko visited mark kr diya\\n        q.push({{0,0},1});\\n        ch[0][0]=1;\\n\\n        // ab bfs apply krte h\\n        while(!q.empty()){\\n\\n            // queue ke front m node h usse coordinates nikal lete h aur distance bhi \\n            // r humara current x coordinate h\\n            // c humara cuurent y coordinate h\\n            // d humara current node ka starting se dist h\\n            // akhir m humne queue se node pop kr diya\\n            int r = q.front().first.first;\\n            int c = q.front().first.second;\\n            int d = q.front().second;\\n            q.pop();\\n\\n            // ab curr location se har direction m connected nodes ki location nikalenge \\n            for(int i=0;i<8;i++){\\n\\n                //next location ke x or y coordinates \\n                int x = r + mr[i][0];\\n                int y = c + mr[i][1];\\n\\n                //ab hum check krenge ki humara node grid ke andar hi h na\\n                // aur agar andar h to wo nahi visited hua ho aur nahi usme 1 ho \\n                // matlab ki uska visited false ho aur grid mein x,y location pe 0 ho\\n                if(x<row && y<col && x>=0 && y>=0 && !ch[x][y] && !grid[x][y]){\\n                    \\n                    //agar sari condition sahi h to node ko visited mark krdo\\n                    ch[x][y]=true;\\n\\n                    // check kro agar humare next node destination yane row-1,col-1 node to nahi\\n                    // agar hn to ans, ya dis+1 m se chote distance ko return krdo\\n                    // yaha d+1 isliye kiya h qki d jo h wo current node ka distace h\\n                    // to next node ka distance d+1\\n                    if(x==row-1 && y==col-1 ) return min(ans,d+1);\\n\\n                    //aur agar ye destination ni h to queue m location or increse ki hui distance ka pair banake push krdo\\n                    q.push({{x,y},d+1});\\n                }\\n            }\\n        }\\n\\n        // hume path nahi milega tb hum yaha tk ayenge\\n        // isliye -1 return krdo\\n        return -1;\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n      row = grid.size();\\n      col = grid[0].size();\\n         \\n        return solve(grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092363,
                "title": "easy-to-understand-c-solution-with-explanation-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Intution is very simple where we have to traverse all the cells and check for all the 0 cell to make the clear path ( as termed in the question). \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Get the boundary condition check first so that we can avoid the unnecessary calls.\\n2. since we have to traverse in all the 8 direction, create the array of points using simple geometry.\\n3. run the standard BFS algorithm.\\n\\n# Complexity\\n- Time complexity: O(N)*O(M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:)(N)*O(M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // getting the size of rows and cols\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        // creating the visited array to keep track of traversal\\n        vector<vector<int>> vis(rows,vector<int>(cols,0));\\n        // creating a queue to hold the row,col and distance \\n        queue<pair<pair<int,int>,int>> q;\\n        // checking the initial condition\\n        if(grid[0][0]!=0 || grid[rows-1][cols-1]!=0) return -1;\\n        // staring the BFS with setting the q with initial postion and distance\\n        q.push({{0,0},0});\\n        // marking the visited array position\\n        vis[0][0] =1;\\n        // untill q is not empty\\n        while(!q.empty()){\\n            //getting the row postion from the queue\\n            int sr = q.front().first.first;\\n            //getting the col postion from the queue\\n            int sc = q.front().first.second;\\n            // //getting the distance from the queue\\n            int distance = q.front().second;\\n            q.pop();\\n            //checking if final postion reached, if yes return distance+1\\n            if(sr==rows-1 and sc== cols-1) return distance+1;\\n            // created the delrow and delcol array with all the 8 direction values\\n            int delrow[] = {1,0,-1,-1,-1,0,1,1};\\n            int delcol[] = {-1,-1,-1,0,1,1,1,0};\\n            // checking all 8 direction from current postion\\n            for(int i=0;i<8;i++){\\n                int drow = sr + delrow[i];\\n                int dcol = sc + delcol[i];\\n                // Again checking the valid values before pushing the values on the queue\\n                if(drow>= 0 && drow<rows && dcol>=0 && dcol<cols && \\n                grid[drow][dcol]==0 && vis[drow][dcol]==0){\\n                    //pushing it into the queue and marking visited.\\n                    q.push({{drow,dcol},distance+1});\\n                    vis[drow][dcol]=1;\\n                }\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n# IF THIS IS HELPFUL, PLEASE UPVOTE!!!\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // getting the size of rows and cols\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        // creating the visited array to keep track of traversal\\n        vector<vector<int>> vis(rows,vector<int>(cols,0));\\n        // creating a queue to hold the row,col and distance \\n        queue<pair<pair<int,int>,int>> q;\\n        // checking the initial condition\\n        if(grid[0][0]!=0 || grid[rows-1][cols-1]!=0) return -1;\\n        // staring the BFS with setting the q with initial postion and distance\\n        q.push({{0,0},0});\\n        // marking the visited array position\\n        vis[0][0] =1;\\n        // untill q is not empty\\n        while(!q.empty()){\\n            //getting the row postion from the queue\\n            int sr = q.front().first.first;\\n            //getting the col postion from the queue\\n            int sc = q.front().first.second;\\n            // //getting the distance from the queue\\n            int distance = q.front().second;\\n            q.pop();\\n            //checking if final postion reached, if yes return distance+1\\n            if(sr==rows-1 and sc== cols-1) return distance+1;\\n            // created the delrow and delcol array with all the 8 direction values\\n            int delrow[] = {1,0,-1,-1,-1,0,1,1};\\n            int delcol[] = {-1,-1,-1,0,1,1,1,0};\\n            // checking all 8 direction from current postion\\n            for(int i=0;i<8;i++){\\n                int drow = sr + delrow[i];\\n                int dcol = sc + delcol[i];\\n                // Again checking the valid values before pushing the values on the queue\\n                if(drow>= 0 && drow<rows && dcol>=0 && dcol<cols && \\n                grid[drow][dcol]==0 && vis[drow][dcol]==0){\\n                    //pushing it into the queue and marking visited.\\n                    q.push({{drow,dcol},distance+1});\\n                    vis[drow][dcol]=1;\\n                }\\n            }\\n        }\\n        return -1;\\n\\n    }\\n};\\n# IF THIS IS HELPFUL, PLEASE UPVOTE!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958483,
                "title": "c-solution-dijkstra-s-algorithm",
                "content": "# Please Upvote If You Find It Helpful.\\n# Approach: Using Dijkstral\\'s Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0]==1)\\n            return -1;\\n        int n = grid.size();\\n        vector<vector<int>> dis(n, vector<int>(n, 1e9));\\n        dis[0][0] = 1;\\n        queue<pair<int, pair<int, int>>> q;\\n        // {dis, {r, c}}\\n        q.push({1, {0, 0}});\\n        int drow[] = {-1, 1, 0 ,0, -1, 1, 1, -1}, dcol[] = {0, 0, -1, 1, -1, -1, 1, 1};\\n        while(!q.empty()){\\n            auto it = q.front();\\n            auto ver = it.second;\\n            int dist = it.first, r = ver.first, c = ver.second;\\n            q.pop();\\n            for(int i=0;i<8;i++){\\n                int nrow = r + drow[i], ncol = c + dcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<n && grid[nrow][ncol]==0){\\n                    if(dis[nrow][ncol] > dist + 1){\\n                        dis[nrow][ncol] = dist+1;\\n                        q.push({dis[nrow][ncol], {nrow, ncol}});\\n                    }\\n                }\\n            }\\n        }\\n        if(dis[n-1][n-1]!=1e9)\\n            return dis[n-1][n-1];\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Breadth-First Search",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0]==1)\\n            return -1;\\n        int n = grid.size();\\n        vector<vector<int>> dis(n, vector<int>(n, 1e9));\\n        dis[0][0] = 1;\\n        queue<pair<int, pair<int, int>>> q;\\n        // {dis, {r, c}}\\n        q.push({1, {0, 0}});\\n        int drow[] = {-1, 1, 0 ,0, -1, 1, 1, -1}, dcol[] = {0, 0, -1, 1, -1, -1, 1, 1};\\n        while(!q.empty()){\\n            auto it = q.front();\\n            auto ver = it.second;\\n            int dist = it.first, r = ver.first, c = ver.second;\\n            q.pop();\\n            for(int i=0;i<8;i++){\\n                int nrow = r + drow[i], ncol = c + dcol[i];\\n                if(nrow>=0 && ncol>=0 && nrow<n && ncol<n && grid[nrow][ncol]==0){\\n                    if(dis[nrow][ncol] > dist + 1){\\n                        dis[nrow][ncol] = dist+1;\\n                        q.push({dis[nrow][ncol], {nrow, ncol}});\\n                    }\\n                }\\n            }\\n        }\\n        if(dis[n-1][n-1]!=1e9)\\n            return dis[n-1][n-1];\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939321,
                "title": "faster-than-98-bfs-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nVisit in all possible 8 directions and update their distacnes from (0,0) by following BFS approach. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(grid[0][0]==1||grid[n-1][n-1]==1)\\n        {\\n            return -1;\\n        }\\n        queue<pair<int,int>>q;\\n        int dis[n][n];\\n        bool vis[n][n];\\n        memset(vis,false,sizeof(vis));\\n        memset(dis,0,sizeof(dis));\\n        dis[0][0]=1;\\n        q.push({0,0});\\n        while(!q.empty())\\n        {\\n            pair<int,int>p=q.front();\\n            int i=p.first,j=p.second;\\n            q.pop();\\n            //vis[i][j]=true;\\n            //for(auto child:adj[{i,j}])\\n            {\\n                //if(!vis[i][j])\\n                {\\n                    if(i+1<n&&!vis[i+1][j]&&grid[i+1][j]==0)\\n                    {\\n                        vis[i+1][j]=true;\\n                        dis[i+1][j]=dis[i][j]+1;\\n                        q.push({i+1,j});\\n                    }\\n                    if(i-1>=0&&!vis[i-1][j]&&grid[i-1][j]==0)\\n                    {\\n                        vis[i-1][j]=true;\\n                        dis[i-1][j]=dis[i][j]+1;\\n                        q.push({i-1,j});\\n                    }\\n                    if(j+1<n&&!vis[i][j+1]&&grid[i][j+1]==0)\\n                    {\\n                        vis[i][j+1]=true;\\n                        dis[i][j+1]=dis[i][j]+1;\\n                        q.push({i,j+1});\\n                    }\\n                    if(j-1>=0&&!vis[i][j-1]&&grid[i][j-1]==0)\\n                    {\\n                        vis[i][j-1]=true;\\n                        dis[i][j-1]=dis[i][j]+1;\\n                        q.push({i,j-1});\\n                    }\\n                    if(i+1<n&&j+1<n&&!vis[i+1][j+1]&&grid[i+1][j+1]==0)\\n                    {\\n                        vis[i+1][j+1]=true;\\n                        dis[i+1][j+1]=dis[i][j]+1;\\n                        q.push({i+1,j+1});\\n                    }\\n                    if(i-1>=0&&j+1<n&&!vis[i-1][j+1]&&grid[i-1][j+1]==0)\\n                    {\\n                        vis[i-1][j+1]=true;\\n                        dis[i-1][j+1]=dis[i][j]+1;\\n                        q.push({i-1,j+1});\\n                    }\\n                    if(i-1>=0&&j-1>=0&&!vis[i-1][j-1]&&grid[i-1][j-1]==0)\\n                    {\\n                        vis[i-1][j-1]=true;\\n                        dis[i-1][j-1]=dis[i][j]+1;\\n                        q.push({i-1,j-1});\\n                    }\\n                    if(i+1<n&&j-1>=0&&!vis[i+1][j-1]&&grid[i+1][j-1]==0)\\n                    {\\n                        vis[i+1][j-1]=true;\\n                        dis[i+1][j-1]=dis[i][j]+1;\\n                        q.push({i+1,j-1});\\n                    }\\n                }\\n            }\\n        }\\n        if(dis[n-1][n-1]) return dis[n-1][n-1];\\n        else return -1;\\n    }\\n};\\n```\\nPls upvote if find useful:)",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        if(grid[0][0]==1||grid[n-1][n-1]==1)\\n        {\\n            return -1;\\n        }\\n        queue<pair<int,int>>q;\\n        int dis[n][n];\\n        bool vis[n][n];\\n        memset(vis,false,sizeof(vis));\\n        memset(dis,0,sizeof(dis));\\n        dis[0][0]=1;\\n        q.push({0,0});\\n        while(!q.empty())\\n        {\\n            pair<int,int>p=q.front();\\n            int i=p.first,j=p.second;\\n            q.pop();\\n            //vis[i][j]=true;\\n            //for(auto child:adj[{i,j}])\\n            {\\n                //if(!vis[i][j])\\n                {\\n                    if(i+1<n&&!vis[i+1][j]&&grid[i+1][j]==0)\\n                    {\\n                        vis[i+1][j]=true;\\n                        dis[i+1][j]=dis[i][j]+1;\\n                        q.push({i+1,j});\\n                    }\\n                    if(i-1>=0&&!vis[i-1][j]&&grid[i-1][j]==0)\\n                    {\\n                        vis[i-1][j]=true;\\n                        dis[i-1][j]=dis[i][j]+1;\\n                        q.push({i-1,j});\\n                    }\\n                    if(j+1<n&&!vis[i][j+1]&&grid[i][j+1]==0)\\n                    {\\n                        vis[i][j+1]=true;\\n                        dis[i][j+1]=dis[i][j]+1;\\n                        q.push({i,j+1});\\n                    }\\n                    if(j-1>=0&&!vis[i][j-1]&&grid[i][j-1]==0)\\n                    {\\n                        vis[i][j-1]=true;\\n                        dis[i][j-1]=dis[i][j]+1;\\n                        q.push({i,j-1});\\n                    }\\n                    if(i+1<n&&j+1<n&&!vis[i+1][j+1]&&grid[i+1][j+1]==0)\\n                    {\\n                        vis[i+1][j+1]=true;\\n                        dis[i+1][j+1]=dis[i][j]+1;\\n                        q.push({i+1,j+1});\\n                    }\\n                    if(i-1>=0&&j+1<n&&!vis[i-1][j+1]&&grid[i-1][j+1]==0)\\n                    {\\n                        vis[i-1][j+1]=true;\\n                        dis[i-1][j+1]=dis[i][j]+1;\\n                        q.push({i-1,j+1});\\n                    }\\n                    if(i-1>=0&&j-1>=0&&!vis[i-1][j-1]&&grid[i-1][j-1]==0)\\n                    {\\n                        vis[i-1][j-1]=true;\\n                        dis[i-1][j-1]=dis[i][j]+1;\\n                        q.push({i-1,j-1});\\n                    }\\n                    if(i+1<n&&j-1>=0&&!vis[i+1][j-1]&&grid[i+1][j-1]==0)\\n                    {\\n                        vis[i+1][j-1]=true;\\n                        dis[i+1][j-1]=dis[i][j]+1;\\n                        q.push({i+1,j-1});\\n                    }\\n                }\\n            }\\n        }\\n        if(dis[n-1][n-1]) return dis[n-1][n-1];\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927775,
                "title": "simple-and-detailed-djkistra-s-shortest-path-based-approach-beats-90",
                "content": "# Intuition\\n**Simple Djkistra Shortest Path Algorithm**\\n\\n# Approach\\n1.We need a distance vector with the same dimension as the grid matrix.\\n2.Queue to store [Distance][Row][Col]\\n3.Initial configuration: \\n    Matrix[0][0]=1 \\n    Queue having [1][0][0] as the first entry\\n4.Run the Djikstra,s algorithm in 8 directions \\n5.return the shortest path to the node[n-1][n-1]\\n\\n\\n# Complexity\\n- Time complexity:\\nSame complexity as Djiktra\\'s:\\nO((E+V)log(V)) where E->no of edges and V->no of vertices\\n\\n- Space complexity:\\nO(n^2)+O(n) for the distance matrix and the queue respectively\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        if(grid[0][0]==1)return -1;\\n        //defining starting and ending nodes\\n        int srow=0;\\n        int scol=0;\\n        int trow=grid.size()-1;\\n        int tcol=grid[0].size()-1;\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        //defining the initial configuration\\n        vector<vector<int>>dist(m,vector<int>(n,1e9));//distance matrix\\n        dist[srow][scol]=1;\\n        queue<pair<int,pair<int,int>>>q;//queue: dist,row,col\\n        q.push({1,{0,0}});\\n        \\n        //defining the movements\\n        int drow[]={-1,-1,0,1,1,1,0,-1};\\n        int dcol[]={0,1,1,1,0,-1,-1,-1};\\n\\n        //djkistra implementation\\n        while(!q.empty())\\n        {\\n            int d=q.front().first;\\n            int row=q.front().second.first;\\n            int col=q.front().second.second;\\n            q.pop();\\n            for(int i=0;i<8;i++)\\n            {\\n                int nrow=row+drow[i];\\n                int ncol=col+dcol[i];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && grid[nrow][ncol]==0 && dist[nrow][ncol]>d+1)\\n                {\\n                    dist[nrow][ncol]=d+1;\\n                    q.push({d+1,{nrow,ncol}});\\n                }\\n            }\\n            \\n        }\\n        if(dist[trow][tcol]==1e9)//path not possible\\n            return -1;\\n        return dist[trow][tcol];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) \\n    {\\n        if(grid[0][0]==1)return -1;\\n        //defining starting and ending nodes\\n        int srow=0;\\n        int scol=0;\\n        int trow=grid.size()-1;\\n        int tcol=grid[0].size()-1;\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        //defining the initial configuration\\n        vector<vector<int>>dist(m,vector<int>(n,1e9));//distance matrix\\n        dist[srow][scol]=1;\\n        queue<pair<int,pair<int,int>>>q;//queue: dist,row,col\\n        q.push({1,{0,0}});\\n        \\n        //defining the movements\\n        int drow[]={-1,-1,0,1,1,1,0,-1};\\n        int dcol[]={0,1,1,1,0,-1,-1,-1};\\n\\n        //djkistra implementation\\n        while(!q.empty())\\n        {\\n            int d=q.front().first;\\n            int row=q.front().second.first;\\n            int col=q.front().second.second;\\n            q.pop();\\n            for(int i=0;i<8;i++)\\n            {\\n                int nrow=row+drow[i];\\n                int ncol=col+dcol[i];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && grid[nrow][ncol]==0 && dist[nrow][ncol]>d+1)\\n                {\\n                    dist[nrow][ncol]=d+1;\\n                    q.push({d+1,{nrow,ncol}});\\n                }\\n            }\\n            \\n        }\\n        if(dist[trow][tcol]==1e9)//path not possible\\n            return -1;\\n        return dist[trow][tcol];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920574,
                "title": "a-simple-dijkstra-algorithm-striver-intuition-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA dijkstra Algorithm for finding shortest path.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDone a simple BFS with the help of Dijkstra algorithm. Storing every minimum dist of that index from source in the index;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(ElogV*8)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N*N) for taking matrix size of NXN;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //int n=grid.size();\\n\\n        const int n = grid.size();\\n    if (grid[0][0] == 0 && n == 1)\\n      return 1;\\n    if (grid[0][0] == 1 || grid.back().back() == 1)\\n      return -1;\\n        \\n        vector<vector<int>> dist(n,vector<int>(n,1e9));\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({1,{0,0}});\\n        dist[0][0]=0;\\n\\n        int dRow[8]={-1,-1,0,1,1,1,0,-1};\\n        int dCol[8]={0,1,1,1,0,-1,-1,-1};\\n\\n        while(!q.empty())\\n        {\\n            int dis=q.front().first;\\n            int r=q.front().second.first;\\n            int c=q.front().second.second;\\n\\n            q.pop();\\n\\n            for(int i=0;i<8;i++)\\n            {\\n                int nrow=r+dRow[i];\\n                int ncol=c+dCol[i];\\n\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<n && grid[nrow][ncol]==0\\n                && dis+1<dist[nrow][ncol])\\n                {\\n                    dist[nrow][ncol]=dis+1;\\n                   if(nrow==n-1 && ncol==n-1) return dist[nrow][ncol];\\n                    q.push({1+dis,{nrow,ncol}});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //int n=grid.size();\\n\\n        const int n = grid.size();\\n    if (grid[0][0] == 0 && n == 1)\\n      return 1;\\n    if (grid[0][0] == 1 || grid.back().back() == 1)\\n      return -1;\\n        \\n        vector<vector<int>> dist(n,vector<int>(n,1e9));\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({1,{0,0}});\\n        dist[0][0]=0;\\n\\n        int dRow[8]={-1,-1,0,1,1,1,0,-1};\\n        int dCol[8]={0,1,1,1,0,-1,-1,-1};\\n\\n        while(!q.empty())\\n        {\\n            int dis=q.front().first;\\n            int r=q.front().second.first;\\n            int c=q.front().second.second;\\n\\n            q.pop();\\n\\n            for(int i=0;i<8;i++)\\n            {\\n                int nrow=r+dRow[i];\\n                int ncol=c+dCol[i];\\n\\n                if(nrow>=0 && nrow<n && ncol>=0 && ncol<n && grid[nrow][ncol]==0\\n                && dis+1<dist[nrow][ncol])\\n                {\\n                    dist[nrow][ncol]=dis+1;\\n                   if(nrow==n-1 && ncol==n-1) return dist[nrow][ncol];\\n                    q.push({1+dis,{nrow,ncol}});\\n                }\\n            }\\n        }\\n\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877508,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    BFS 2D\\n\\n\\n# Code\\n```\\n#define maxn 105\\n#define pii pair<int, int>\\nint fx[] = {-1, 1, 0, 0, 1, -1, -1, 1};\\nint fy[] = {0, 0, -1, 1, 1, 1, -1, -1};\\n\\nclass Solution {\\npublic:\\n    int n, m, vis[maxn][maxn], dis[maxn][maxn];\\n    vector<vector<int>> grids;\\n\\n    bool valid(int x, int y)\\n    {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y] and !grids[x][y]) return true;\\n        else return false;\\n    }\\n\\n    void bfs(int sx, int sy) {\\n        vis[sx][sy] = 1;\\n        dis[sx][sy] = 1;\\n        queue<pii> q;\\n        q.push({sx, sy});\\n        while(!q.empty()) {\\n            pii top = q.front();\\n            int x = top.first;\\n            int y = top.second;\\n            q.pop();\\n            for(int k=0; k<8; k++) {\\n                int tx = x + fx[k];\\n                int ty = y + fy[k];\\n                if(valid(tx, ty)) {\\n                    vis[tx][ty] = 1;\\n                    dis[tx][ty] = dis[x][y] + 1;\\n                    q.push({tx, ty});\\n                }\\n            }\\n        }\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        grids = grid;\\n        memset(vis, 0, sizeof(vis));\\n        memset(dis, 0, sizeof(dis));\\n        n = grid.size(), m = grid[0].size();\\n\\n        if(valid(0, 0)) bfs(0, 0);\\n\\n        int ans = dis[n-1][m-1];\\n        if(ans) return ans;\\n        else return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define maxn 105\\n#define pii pair<int, int>\\nint fx[] = {-1, 1, 0, 0, 1, -1, -1, 1};\\nint fy[] = {0, 0, -1, 1, 1, 1, -1, -1};\\n\\nclass Solution {\\npublic:\\n    int n, m, vis[maxn][maxn], dis[maxn][maxn];\\n    vector<vector<int>> grids;\\n\\n    bool valid(int x, int y)\\n    {\\n        if(x >= 0 and x < n and y >= 0 and y < m and !vis[x][y] and !grids[x][y]) return true;\\n        else return false;\\n    }\\n\\n    void bfs(int sx, int sy) {\\n        vis[sx][sy] = 1;\\n        dis[sx][sy] = 1;\\n        queue<pii> q;\\n        q.push({sx, sy});\\n        while(!q.empty()) {\\n            pii top = q.front();\\n            int x = top.first;\\n            int y = top.second;\\n            q.pop();\\n            for(int k=0; k<8; k++) {\\n                int tx = x + fx[k];\\n                int ty = y + fy[k];\\n                if(valid(tx, ty)) {\\n                    vis[tx][ty] = 1;\\n                    dis[tx][ty] = dis[x][y] + 1;\\n                    q.push({tx, ty});\\n                }\\n            }\\n        }\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        grids = grid;\\n        memset(vis, 0, sizeof(vis));\\n        memset(dis, 0, sizeof(dis));\\n        n = grid.size(), m = grid[0].size();\\n\\n        if(valid(0, 0)) bfs(0, 0);\\n\\n        int ans = dis[n-1][m-1];\\n        if(ans) return ans;\\n        else return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742566,
                "title": "c-from-bfs-to-djikstras-solution",
                "content": "Simple Bfs Solution\\n```\\nclass Solution {\\npublic:\\n    int dx[8]={0,1,-1,0,1,-1,-1,1};\\n    int dy[8]={1,0,0,-1,1,-1,1,-1};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        if(grid[0][0]==1 or grid[n-1][n-1]==1)\\n            return -1;\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({1,{0,0}});\\n        while(!q.empty())\\n        {\\n            int cnt=q.front().first;\\n            int x=q.front().second.first;\\n            int y=q.front().second.second;\\n            q.pop();\\n            if(x==n-1 and y==n-1)\\n            {\\n                return cnt;\\n            }\\n           \\n            for(int k=0;k<8;k++)\\n            {\\n                int newx=x+dx[k];\\n                int newy=y+dy[k];\\n                if(newx<0 or newy<0 or newx>=n or newy>=n or vis[newx][newy]==1 or grid[newx][newy]==1)\\n                    continue;\\n                vis[newx][newy]=1;\\n                q.push({cnt+1,{newx,newy}});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\nDjikstras Shortest Path Solution\\n```\\ntypedef pair<int,pair<int,int>> pi;\\nclass Solution {\\npublic:\\n    int dx[8]={0,1,-1,0,1,-1,-1,1};\\n    int dy[8]={1,0,0,-1,1,-1,1,-1};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n         int n=grid.size();\\n        vector<vector<int>> dist(n,vector<int>(n,1e9));\\n        if(grid[0][0]==1 or grid[n-1][n-1]==1)\\n            return -1;\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        pq.push({1,{0,0}});\\n        dist[0][0]=1;\\n        while(!pq.empty())\\n        {\\n            int cnt=pq.top().first;\\n            int x=pq.top().second.first;\\n            int y=pq.top().second.second;\\n            pq.pop();\\n            for(int k=0;k<=7;k++)\\n            {\\n                int newx=x+dx[k];\\n                int newy=y+dy[k];\\n                if(newx<0 or newy<0 or newx>=n or newy>=n or grid[newx][newy]==1)\\n                    continue;\\n                if(dist[newx][newy]>1+cnt)\\n                {\\n                    dist[newx][newy]=1+cnt;\\n                    pq.push({dist[newx][newy],{newx,newy}});\\n                }\\n            }\\n        }\\n        if(dist[n-1][n-1]==1e9)\\n            return -1;\\n        return dist[n-1][n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[8]={0,1,-1,0,1,-1,-1,1};\\n    int dy[8]={1,0,0,-1,1,-1,1,-1};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        if(grid[0][0]==1 or grid[n-1][n-1]==1)\\n            return -1;\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({1,{0,0}});\\n        while(!q.empty())\\n        {\\n            int cnt=q.front().first;\\n            int x=q.front().second.first;\\n            int y=q.front().second.second;\\n            q.pop();\\n            if(x==n-1 and y==n-1)\\n            {\\n                return cnt;\\n            }\\n           \\n            for(int k=0;k<8;k++)\\n            {\\n                int newx=x+dx[k];\\n                int newy=y+dy[k];\\n                if(newx<0 or newy<0 or newx>=n or newy>=n or vis[newx][newy]==1 or grid[newx][newy]==1)\\n                    continue;\\n                vis[newx][newy]=1;\\n                q.push({cnt+1,{newx,newy}});\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\ntypedef pair<int,pair<int,int>> pi;\\nclass Solution {\\npublic:\\n    int dx[8]={0,1,-1,0,1,-1,-1,1};\\n    int dy[8]={1,0,0,-1,1,-1,1,-1};\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n         int n=grid.size();\\n        vector<vector<int>> dist(n,vector<int>(n,1e9));\\n        if(grid[0][0]==1 or grid[n-1][n-1]==1)\\n            return -1;\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        pq.push({1,{0,0}});\\n        dist[0][0]=1;\\n        while(!pq.empty())\\n        {\\n            int cnt=pq.top().first;\\n            int x=pq.top().second.first;\\n            int y=pq.top().second.second;\\n            pq.pop();\\n            for(int k=0;k<=7;k++)\\n            {\\n                int newx=x+dx[k];\\n                int newy=y+dy[k];\\n                if(newx<0 or newy<0 or newx>=n or newy>=n or grid[newx][newy]==1)\\n                    continue;\\n                if(dist[newx][newy]>1+cnt)\\n                {\\n                    dist[newx][newy]=1+cnt;\\n                    pq.push({dist[newx][newy],{newx,newy}});\\n                }\\n            }\\n        }\\n        if(dist[n-1][n-1]==1e9)\\n            return -1;\\n        return dist[n-1][n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700526,
                "title": "easy-to-understand-bfs-with-explanation",
                "content": "# Intuition\\nThe goal is to convert the 1st martix to the 2nd. So in this we will use BFS and add +1 to the next visited neighbor. So whatever the end sum is in cell (m-1, n-1) will be our answer.\\n\\n![matrix.png](https://assets.leetcode.com/users/images/bf073896-ded8-488c-911a-6c63231c4953_1665714677.1979873.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Code\\n```\\npublic class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        Queue<int[]> que = new Queue<int[]>();\\n\\n        // 8 directional\\n        List<int[]> directions = new List<int[]>(){new int[]{-1,0}, new int[]{1,0}, new int[]{0,1}, new int[]{0,-1}, new int[]{1,-1}, new int[]{-1,-1}, new int[]{-1,1}, new int[]{1,1}};\\n\\n        int m = grid.Count();\\n        int n = grid[0].Count();\\n\\n        // There is either no start or no end then return false\\n        if(grid[0][0] != 0 || grid[m-1][n-1] != 0) return -1;\\n\\n        que.Enqueue(new int[]{0,0});\\n        grid[0][0] = 1; // This is our starting point\\n\\n        while(que.Count != 0){\\n            int[] curr = que.Dequeue();\\n            int currI = curr[0];\\n            int currJ = curr[1];\\n\\n            // We have reached the destination so return this.\\n            if(currI == m-1 && currJ == n-1) return grid[currI][currJ]; \\n\\n            foreach(int[] dir in directions){\\n                int newI = currI+dir[0];\\n                int newJ = currJ+dir[1];\\n\\n                if(newI>=0 && newI<m && newJ>=0 && newJ<n && grid[newI][newJ] == 0){\\n                    que.Enqueue(new int[]{newI, newJ});\\n                    grid[newI][newJ] = grid[currI][currJ]+1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ShortestPathBinaryMatrix(int[][] grid) {\\n        Queue<int[]> que = new Queue<int[]>();\\n\\n        // 8 directional\\n        List<int[]> directions = new List<int[]>(){new int[]{-1,0}, new int[]{1,0}, new int[]{0,1}, new int[]{0,-1}, new int[]{1,-1}, new int[]{-1,-1}, new int[]{-1,1}, new int[]{1,1}};\\n\\n        int m = grid.Count();\\n        int n = grid[0].Count();\\n\\n        // There is either no start or no end then return false\\n        if(grid[0][0] != 0 || grid[m-1][n-1] != 0) return -1;\\n\\n        que.Enqueue(new int[]{0,0});\\n        grid[0][0] = 1; // This is our starting point\\n\\n        while(que.Count != 0){\\n            int[] curr = que.Dequeue();\\n            int currI = curr[0];\\n            int currJ = curr[1];\\n\\n            // We have reached the destination so return this.\\n            if(currI == m-1 && currJ == n-1) return grid[currI][currJ]; \\n\\n            foreach(int[] dir in directions){\\n                int newI = currI+dir[0];\\n                int newJ = currJ+dir[1];\\n\\n                if(newI>=0 && newI<m && newJ>=0 && newJ<n && grid[newI][newJ] == 0){\\n                    que.Enqueue(new int[]{newI, newJ});\\n                    grid[newI][newJ] = grid[currI][currJ]+1;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661020,
                "title": "c-djikstra-algorithm-bfs",
                "content": "**!!! Please Upvote !!!**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We have to find the shortest distnace from a source node (i.e. index $(0,0)$) to a destination node (i.e. index $(n-1, n-1)$).\\n    So, here we can use simple Dijkstra Algorithm, taking 8 direction from current index as child node and taking unit weight $(i.e.\\\\ Taking\\\\ Distance\\\\ to\\\\ travel\\\\ another\\\\ node\\\\ is\\\\ 1)$.\\n\\n- **Base Cases :-**\\n  1. node should be inside boundry of matrix.\\n  $(i.e,$ $i>=0$ $and$ $j>=0$ $and$ $i<n$ $and$ $j<n$ $)$\\n  2. We can only traverse when $grid[i][j] == 0$. \\n  3. if source $(0,0)$) or destination $(n-1, n-1)$ is 1 than as per point no. 2, we can not even move forward, so we will `return -1` at starting only.\\n  4. After completing Djikstra algorithm if $distTo[n-1][n-1]\\\\ ==\\\\ INT\\\\_MAX$, than it will conclude that reaching destination node $(n-1, n-1)$ is not possible,  so we will `return -1`.\\n  5. if point no. 4 is not true, than we will `return (distTo[n-1][n-1] + 1)`. $$(Here\\\\ \\\\ we\\\\ \\\\ add\\\\ \\\\ 1\\\\ \\\\ to\\\\ \\\\ final\\\\ \\\\ result,\\\\ \\\\ to\\\\ \\\\ count\\\\ \\\\ source\\\\ \\\\ node\\\\ \\\\ (0, 0)\\\\ \\\\ in\\\\ \\\\ the\\\\ \\\\ path)$$\\n\\n# Code\\n```\\nstruct myPair{\\n    int dist;\\n    int i;\\n    int j;\\n};\\n\\nstruct myComp {\\n    constexpr bool operator()(myPair const& a, myPair const& b)const noexcept\\n    {\\n        return a.dist > b.dist;\\n    }\\n};\\nclass Solution {\\n    bool check(int i, int j, int n, vector<vector<int>>& grid)\\n    {\\n        if(i>=0 and j>=0 and i<n and j<n and grid[i][j]==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n\\n        if(grid[0][0]!=0 or grid[n-1][n-1]!=0)\\n            return -1;\\n\\n        vector<vector<int>> distTo(n, vector<int>(n, INT_MAX));\\n\\n        priority_queue<myPair, vector<myPair>, myComp> pq;\\n\\n        vector<int> dirx{1, -1, 1, 1, 0, -1, 0, -1};\\n        vector<int> diry{1, 1, -1, 0, 1, 0, -1, -1};\\n\\n        distTo[0][0] = 0;\\n        pq.push({0, 0, 0});\\n\\n        while(!pq.empty())\\n        {\\n            myPair u = pq.top();\\n            pq.pop();\\n\\n            for(int k=0; k<8; k++)\\n            {\\n                if(check((u.i + dirx[k]), (u.j + diry[k]), n, grid))\\n                {\\n                    myPair v = {distTo[(u.i + dirx[k])][(u.j + diry[k])], (u.i + dirx[k]), (u.j + diry[k])};\\n\\n                    if(v.dist > (distTo[u.i][u.j] + 1))\\n                    {\\n                        v.dist = (distTo[u.i][u.j] + 1);\\n                        distTo[(u.i + dirx[k])][(u.j + diry[k])] = v.dist;\\n                        pq.push(v);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (distTo[n-1][n-1]==INT_MAX)?-1:(distTo[n-1][n-1]+1);\\n    }\\n};\\n```\\n\\n\\n**!!! Please Upvote !!!**",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct myPair{\\n    int dist;\\n    int i;\\n    int j;\\n};\\n\\nstruct myComp {\\n    constexpr bool operator()(myPair const& a, myPair const& b)const noexcept\\n    {\\n        return a.dist > b.dist;\\n    }\\n};\\nclass Solution {\\n    bool check(int i, int j, int n, vector<vector<int>>& grid)\\n    {\\n        if(i>=0 and j>=0 and i<n and j<n and grid[i][j]==0)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n\\n        if(grid[0][0]!=0 or grid[n-1][n-1]!=0)\\n            return -1;\\n\\n        vector<vector<int>> distTo(n, vector<int>(n, INT_MAX));\\n\\n        priority_queue<myPair, vector<myPair>, myComp> pq;\\n\\n        vector<int> dirx{1, -1, 1, 1, 0, -1, 0, -1};\\n        vector<int> diry{1, 1, -1, 0, 1, 0, -1, -1};\\n\\n        distTo[0][0] = 0;\\n        pq.push({0, 0, 0});\\n\\n        while(!pq.empty())\\n        {\\n            myPair u = pq.top();\\n            pq.pop();\\n\\n            for(int k=0; k<8; k++)\\n            {\\n                if(check((u.i + dirx[k]), (u.j + diry[k]), n, grid))\\n                {\\n                    myPair v = {distTo[(u.i + dirx[k])][(u.j + diry[k])], (u.i + dirx[k]), (u.j + diry[k])};\\n\\n                    if(v.dist > (distTo[u.i][u.j] + 1))\\n                    {\\n                        v.dist = (distTo[u.i][u.j] + 1);\\n                        distTo[(u.i + dirx[k])][(u.j + diry[k])] = v.dist;\\n                        pq.push(v);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (distTo[n-1][n-1]==INT_MAX)?-1:(distTo[n-1][n-1]+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543974,
                "title": "simple-java-solution-bfs",
                "content": "```\\n// BFS Time Complexity --> O(v) ~ O(n * m)\\n// Please Upvote if you find it helpful !!\\n\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length, m = grid[0].length, shortestPath = 1;\\n        int[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {1, 1}, {-1, -1}, {1, -1}, {-1, 1}};\\n        \\n        LinkedList<Integer> que = new LinkedList<>();\\n        \\n        // if the start (row, col) or the end (row, col) contains non zero values then it is impossible to reach (n - 1, m - 1) or start from (0, 0)\\n        if(grid[0][0] != 0 || grid[n - 1][m - 1] != 0){  \\n            return -1;\\n        }\\n        \\n        // instead of making a visited[] just doing changes in the original matrix i.e placing a value not present in matrix to mark it visited.\\n        grid[0][0] = 2; \\n        \\n        // instead of adding pair of (row, col) in the queue we are just treating the (row, col) as 1D\\n        que.addLast(0);\\n        \\n        // First While loop in BFS manages the Levels\\n        while(que.size() != 0){                \\n            int size = que.size();\\n            // Second While loop in BFS Processes the current Level and prepare the upcoming level Simultaneously\\n            while(size-- > 0){    \\n                int remove_vtx_idx = que.removeFirst();\\n                int row = remove_vtx_idx / m;                    // converting the 1D mapping back into the 2D\\n                int col = remove_vtx_idx % m;                    // converting the 1D mapping back into the 2D\\n                \\n                if(row == n - 1 && col == m - 1){\\n                    return shortestPath;                    // if the removed vertex is our dest then return from here.\\n                }\\n                \\n                for(int d = 0; d < dir.length; d++){\\n                    int r = row + dir[d][0];\\n                    int c = col + dir[d][1];\\n                    \\n                    if(r >= 0 && c >= 0 && r < n && c < m && grid[r][c] == 0){\\n                        grid[r][c] = 2;       // marking visited\\n                        que.addLast(r * m + c); // Adding the 1D mapping of indexes\\n                    }\\n                }\\n            }\\n            shortestPath += 1;                     // incrementing the level i.e shortestPath in this case\\n        }\\n        \\n// if the above BFS is Completed and it comes at this point then it means there is no clear path, Therefore return -1\\n        return -1; \\n    }   \\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length, m = grid[0].length, shortestPath = 1;\\n        int[][] dir = {{0, 1}",
                "codeTag": "Java"
            },
            {
                "id": 2452243,
                "title": "bfs-with-self-explainatory-variable-names-time-o-n-space-o-n",
                "content": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if 1 in (grid[0][0], grid[-1][-1]):\\n            return -1\\n\\n        ROWS, COLS = len(grid), len(grid[0])\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\\n        \\n        q = deque([(0, 0, 1)])\\n        visited = set()\\n        visited.add((0, 0))\\n        \\n        while q:\\n            x, y, distance = q.popleft()\\n            if (x, y) == (COLS - 1, ROWS - 1):\\n                return distance\\n            \\n            for dx, dy in directions:\\n                newX, newY = x + dx, y + dy\\n                \\n                if 0 <= newX < COLS and 0 <= newY < ROWS and (newX, newY) not in visited and grid[newX][newY] == 0:\\n                    q.append((newX, newY, distance + 1))\\n                    visited.add((newX, newY))\\n                    \\n        return -1\\n    # Time: O(n) where n is the number of cells in the grid\\n    # Space: O(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\\n        if 1 in (grid[0][0], grid[-1][-1]):\\n            return -1\\n\\n        ROWS, COLS = len(grid), len(grid[0])\\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\\n        \\n        q = deque([(0, 0, 1)])\\n        visited = set()\\n        visited.add((0, 0))\\n        \\n        while q:\\n            x, y, distance = q.popleft()\\n            if (x, y) == (COLS - 1, ROWS - 1):\\n                return distance\\n            \\n            for dx, dy in directions:\\n                newX, newY = x + dx, y + dy\\n                \\n                if 0 <= newX < COLS and 0 <= newY < ROWS and (newX, newY) not in visited and grid[newX][newY] == 0:\\n                    q.append((newX, newY, distance + 1))\\n                    visited.add((newX, newY))\\n                    \\n        return -1\\n    # Time: O(n) where n is the number of cells in the grid\\n    # Space: O(n)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575612,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1878646,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1570870,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1566117,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1912468,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1566221,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1566563,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1912518,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1796187,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1912561,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1575612,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1878646,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1570870,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1566117,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1912468,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1566221,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1566563,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1912518,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1796187,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1912561,
                "content": [
                    {
                        "username": "peterx123",
                        "content": "If your BFS with tracking visited node gets TLE, you could check if you add those new nodes to visited on time.\\nif you are adding the node to visited only when you poll it from queue, then your BFS might get TLE."
                    },
                    {
                        "username": "shyamala1307",
                        "content": "[@MonikaLisa2010](/MonikaLisa2010) All the adjacent cells can again be traversed repeatedly if not marked as visited while adding to the queue. "
                    },
                    {
                        "username": "Rahu88",
                        "content": "If you still get a TLE with [@peterx123](/peterx123) and [@Liam Merino](/fmomaha) optimisation, it may be a problem with the data structure you are using for visited.\\n\\nHint: We don\\'t care about the order of the elements in visited unlike queue.\\n\\nIt should be around 7000% faster if used properly."
                    },
                    {
                        "username": "fmomaha",
                        "content": "[@ujjwalpathaak](/ujjwalpathaak) Adding to visited right away before adding a node to the queue can help terminate other branches of the BFS early. For example, lets take a 2x2 grid similar to example one, but with all zeros. The first level of BFS will have the three other cells that aren\\'t the starting cell. Technically we are done here since we have found a path, but depending when you check for the end condition your BFS might not end immediately. I only check for the bottom right corner after popping. But for now, we have 3 more nodes in our queue such as `[(1,0),(0,1),(1,1)]`\\nIf we mark before queueing:(1,1) is visited already, when we pop (1,0) we don\\'t re add (1,1) to the stack since we have it marked. Thee same applies for (0,1). In an example of 3 elements of the queue, we have saved 2 deque operations."
                    },
                    {
                        "username": "MonikaLisa2010",
                        "content": "great tip worked for me!! can you please explain in detail how is this working?"
                    },
                    {
                        "username": "kartikkk1212",
                        "content": "Thanks man , now I will keep this in mind everytime I do something like this"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "good catch"
                    },
                    {
                        "username": "kevinmzy",
                        "content": "[@sdsf3454](/sdsf3454) Thanks!"
                    },
                    {
                        "username": "_SID_",
                        "content": "After seeing this made simple changes and got it right. Thanks : )"
                    },
                    {
                        "username": "sdsf3454",
                        "content": "This was helpful. Thanks"
                    },
                    {
                        "username": "anarthana",
                        "content": " <b>All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).</b>\\n\\nThe wording here was a bit confusing to me.  Now that I\\'ve solved the problem, I think all they were trying to say was:\\n\\n<b>The path is made up of horizontal, vertical, and/or diagonal steps</b>"
                    },
                    {
                        "username": "zapdos_thunder",
                        "content": "I came to discussion threads just to see this!. Thanks"
                    },
                    {
                        "username": "54mv39",
                        "content": "haha.. it is a pixel connection terminology "
                    },
                    {
                        "username": "JackChen890311",
                        "content": "They really need to change the wording here"
                    },
                    {
                        "username": "amaan7",
                        "content": "Thanks man !\\n"
                    },
                    {
                        "username": "icespeech",
                        "content": "In the problem description, it gives two constraints for the definition of a **clear path**.\\nAnd constraint two says:\\n\\n* **All the adjacent cells of the path** are 8-directionally connected (i.e., **they are different** and they share an edge or a corner).\\n\\nWhat does **they are different** mean? Firstly I thought it means they are all 1s, because that\\'s different from the 0s in the path. But in example 2, all the adjacent cells of the path are [[0,2],[1,0],[1,1],[2,1]], and they are not all 1s because cell [0,2] contains a zero. (As the pic shows.)\\n![image](https://assets.leetcode.com/users/images/c89b9e6a-8591-4210-8964-717d5d209d0c_1651877883.2621098.png)\\n\\nSo maybe by **they are different** it means the adjacent cells are not included in the path? But should not that be self-evident?\\n\\nCan anyone please give a clearer definition of it? Many thanks.\\n\\n"
                    },
                    {
                        "username": "Proosias",
                        "content": "It means cells in the path that are next to each other are **adjacent from an 8-directional standpoint**(is a neighbor cell including diagonals) and are **different cells** (cell a -> b, a and be will have different coordinates) "
                    },
                    {
                        "username": "SandeepKV",
                        "content": "Can anybody explain the meaning of the problem? I understand that the end goal is to find the shortest path from [0,0] to [n-1,m-1]. But not sure what the constraints exactly are.\\n\\nTIA"
                    },
                    {
                        "username": "mochiball",
                        "content": "Basically the question is asking \"if you start from the top left, can you reach the bottom right while only traversing 0\\'s in your path\"\\n\\nSo two edge cases come to mind immediately : if your top left and bottom right are not 0\\'s, there is no way to reach it. \\n\\nOtherwise, this is a standard traversal problem starting from the top left. In these problems, you should keep a distance array "
                    },
                    {
                        "username": "user2659kC",
                        "content": "Well I am also not sure how to get the solution for this problem but for now I know that the path should be found out from the top Left corner of the array to the bottom right hand side of the array and the path that needs to be followed should be all zeros 0s. Kinda complicated but looking out at the discussions to find out some ideas \\n"
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "1. It\\'s always square so from [0][0] to [n-1][n-1]\\n2. You can move to any direction from the current cell: North, North-East, East, South-East ... etc\\n3. Constraints are: \\n     I) you can not step on tiles with \\'1\\';\\n    II) you can not step out of bounds obviously."
                    },
                    {
                        "username": "c4tdog",
                        "content": "welcome to a new month"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shortest-path-in-binary-matrix/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-first Search (BFS), Overwriting Input\n\n  \n**Approach 2:** Breadth-first Search (Without Overwriting the Input)\n\n  \n**Approach 3:** A* (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "csazad2702",
                        "content": "[[0,1],[1,0]] my output is 1 because we can reach diagonally in one step\\nwhy it is 2"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question asks return \"cells traveled\" so the top left corner counts as 1 "
                    },
                    {
                        "username": "user2659kC",
                        "content": "the steps starting from 1. so if you start from top left corner of the array and to the bottom right side of the array, you will have moved 1+1 steps  = 2 steps. \\nJust make sure when you start calculating the steps it starts from 1 instead of 0 and you might get the output\\n "
                    },
                    {
                        "username": "himralgarg",
                        "content": "The length of a clear path is the number of visited cells of this path. So you are visiting two cells hence answer is 2"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "[@rohish](/rohish) because we are finding the smallest path"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "because it counts the number of 0\\'s visited to reach the destination"
                    },
                    {
                        "username": "ethanolx",
                        "content": "[@rohish](/rohish) cuz in this case, a diagonal shortcut was taken, resulting in a total of 4 visited cells only: (0, 0) -> (0, 1) -> (1, 2) -> (2, 2). Note that from (0, 1) to (1, 2) only 2 cells were visited as opposed to 3 since it was a diagonal shortcut. The cell (0, 2) was skipped."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "For `[[0,1],[1,0]]`, answer 2 is justified [@csazad2702](/csazad2702), because as per problem description   \\n> The length of a clear path is the number of visited cells of this path.\\n\\nOn traversing diagonally, although we take one step, but we covered two cells (0,0) \\u2192 (1,1)\\n\\n-------\\n\\nFor `[0,0,0],[1,1,0],[1,1,0]]`, answer 4 is justified, [@rohish](/rohish). We can reach from (0,0) to (2,2) by covering 4 cells as (0,0) \\u2192 (0,1) \\u2192 (1,2) \\u2192 (2,2)."
                    },
                    {
                        "username": "rohish",
                        "content": "[@Gourav-Chouhan](/Gourav-Chouhan) Then why in this [[0,0,0],[1,1,0],[1,1,0]] answer is not 5?"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "how many cells did you visit on your way to the bottom right corner, 2 right? Thats the ans to the question, just add one to the your answer and it will work fine"
                    },
                    {
                        "username": "anwendeng",
                        "content": "**I think that is a game to move the king in the chess!**\nTest case:[[0,1,0,1,0],[1,0,0,0,1],[0,0,1,1,1],[0,0,0,0,0],[1,0,1,0,0]]\n```\n  -1   1  -3   1  -5\n   1  -2  -3  -4   1\n  -3  -3   1   1   1\n  -4  -4  -4  -5  -6\n   1  -5   1  -5  -6\n```\nIn this case, the  answer is  6, using the negative integers to denote the possible path.\nThe DFS approach is not suggested. It may leads to TLE.\n```\n[[0,0,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,0,1,0,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0],[1,0,0,0,1,1,1,0,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,0,1,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,1,0,0,1,1,0,1,0,0,0,1,0,0,1,1,1],[0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0],[1,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0],[0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,1,0],[1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0],[0,0,1,1,1,0,1,1,1,1,0,1,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,0,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,0,1,0],[1,0,0,1,1,0,0,1,0,0,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0],[0,0,1,0,0,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,0,1,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,0,0,0,0,0,0],[0,0,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,1,1],[1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0],[1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,0,1,0,0,1,0,1,1,1],[0,1,0,1,0,1,1,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,1,1,0],[1,0,0,0,1,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0],[1,0,0,1,1,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,1,0,1],[1,1,0,1,1,1,0,1,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,1,1,1],[0,0,1,0,1,1,0,1,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,0,0,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,0,0,1],[0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,0,1,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1],[0,1,0,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1],[1,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,0,0,1,1,1,1],[0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0],[0,0,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,1,1,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,1,1,0,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1],[0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,0,1,1,0,1],[0,1,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0],[0,1,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,1,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,1],[1,1,0,0,0,1,0,0,1,1,0,0,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,1,0,1,1,0,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1],[0,1,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,0,1,1,1,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,0,1],[0,0,1,1,1,1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,0,1],[1,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,1,1,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1],[1,1,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,0,0],[0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,0,1,1,0,0,1,0,0,1,0,1],[0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1],[1,0,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,0,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,1,1,0,0,1,1,0,1,1,0,0,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,1,0,0,1,1,1,1,0,1],[0,0,1,0,1,0,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0],[0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,1,0,1,1,0,0,1],[0,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,0,0,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1],[1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,0,1,1,0,1,1,1,1],[0,0,0,0,1,0,0,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,1],[1,0,1,0,0,0,1,1,0,1,1,1,0,0,1,1,1,0,1,1,1,0,0,1,1,0,1,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,1,1,1,1,1],[0,1,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,0,0,1,0,0,1,1,1,1,1,0,1,0,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0],[1,1,1,1,1,0,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,0,1,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,0,1,1,1,0,0,0,1,1,1],[1,0,0,0,0,0,0,1,1,1,1,0,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,0,0],[0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,1,0,0,0,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,0,1,0,1,0,1],[1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,1,1,1],[0,0,1,1,0,0,0,0,0,0,1,1,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,1,1,1,0,0,1],[1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,0,1,1],[1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,1,0,0,1,0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0],[1,1,1,1,0,0,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,0,1,0,1,0,1,0,1,1,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,0,0,1,1,0,1,0,0,1,0,0,1,1,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,1,0,0],[0,0,0,0,0,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,0,1,0,0,1,1,0,0,1,1,1,0],[0,0,1,1,1,1,0,1,1,1,0,1,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,1,1,1,1,0,0,1,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,0,1,1,0,1,1,1],[0,0,1,0,0,1,0,0,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,0,0,0,1,1,1,0,0],[1,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1],[0,1,0,1,1,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,1,0,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0],[0,1,0,0,0,0,1,0,0,1,0,1,0,1,0,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,1],[0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,0,0,1,0,0,0,1,1,1,0,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,1,1,1,1],[0,0,1,1,0,1,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,0,1,0,0,1,1,0,1,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,1,0,1,1],[0,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,0,0,0,0,1],[1,0,0,1,0,1,1,0,0,0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,1,1,0,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1,0,1,1,0,1,0,0,1,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0],[0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,1,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,1,0,0],[1,1,0,0,1,1,0,0,1,0,0,1,0,0,1,0,1,1,1,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[1,0,1,1,1,1,1,0,1,0,0,1,1,1,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1],[0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,1,0,1],[0,1,0,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,1,0,0,0,1,0,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,0,1,1,0,0,0,0,1],[1,1,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,1,1,0,0,1,1,0,0,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,1,0,0,1,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,1,0,0,0],[1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,0,1,1,1,0,1,1],[1,0,1,1,1,1,0,0,0,1,1,1,0,1,0,0,0,0,1,0,1,0,0,0,1,1,0,1,0,1,0,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,0,1],[1,1,1,1,1,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,1,1,1,1,0,0,1,1,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,1,1,0,0,1,0,1,1,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,1],[0,0,0,0,1,0,1,0,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1,1,0,1,0,0,1,0,0,0,0,0,0,1,0,1,1],[1,1,0,1,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0],[1,0,1,0,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,0,1,0,1,1,0,0,1,0,1,0,1],[0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,0],[0,0,1,1,1,0,0,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0],[0,1,1,1,0,1,0,0,0,1,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,0,0,1,1,0,1,1,1,0,1,0,1,0,1,1,0,0],[0,0,1,0,0,0,0,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,1,1,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,1,1,1,0,0,0,1,0,0,1,0,0,1,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1],[0,1,0,1,0,1,0,0,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,1,1,1,0,1,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,1,1,1,0,0,1],[0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,1,1,1,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,0,0,1,1,0,1,1,0,1,0,1,0,0,0,0,1,0,1,1,1,1,1],[0,0,0,0,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,0,0,1,0,0,1,0,1,1,0,1,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,1,0,0],[1,1,0,0,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,1,1,0,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,0,0,0],[1,0,0,1,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,1,1,0,0,1,1,1,0,1,1,0,1,0,0,0,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,0,0,0,0,1,0,0,0,0],[0,1,0,0,0,1,0,1,1,1,1,1,0,0,1,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,1,1,0,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0],[0,1,1,1,1,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,0,1,0,1,0,0],[0,1,0,1,1,1,0,0,0,1,1,0,0,0,1,1,1,1,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,1,0,1],[0,0,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,0,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,1,1,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,1,1,1,0,0,1,0,1,0,0,0,0,0],[1,1,1,1,1,0,1,0,0,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1],[1,0,1,0,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,0,0,1,1,1,1,0,0,0,0,1,1,0,0,1,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,0,0,0,0,0,1,1,1,1],[1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,1,1,1,1,0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,0,1,0,1,1,0,1,1,1,1,0,1,1,0,0,0,0,1,0,0,1,1,0,1],[0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,1,1,1,1,1,0,1,1,1,1],[1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,1,1,0,0,1,0,1,0,0,0,0,1],[0,1,1,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,0,1,0,0,1,0,0,1,0,0,1,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,1,0,0,0,0,0,0],[0,0,1,0,1,1,1,1,1,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,0,0,1,1,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1],[1,1,0,1,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,1,1,1,0,1,0,0,0,1,1,1,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,1,0,0,0,1,1],[1,0,1,1,0,1,1,0,0,1,1,1,0,1,1,0,0,1,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1,1,0,0,1,1,1,0,0,1,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,0,1,1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,0,1],[0,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,0,0,1,1,0,1,0,0,1,1,0,0,0,0,1,0,1,1,1,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1],[1,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,1,0,1,1,0,0,1,0,0,1,0,1,0,1,1,0,0,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,0,1,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1],[0,0,0,1,0,1,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,0,0,0,1,0,0,0,1,1,1,0,0,1,0,0,0,1,1,1,1,0,0,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0],[0,0,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,1,1,1,1,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,1,1,0,1],[1,1,1,0,0,1,1,1,0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,1,1,0,1,0,1,0,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,1,1,1,1,1],[1,1,1,0,1,0,0,1,1,1,0,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,0,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0]]\n```"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@EricRaw](/EricRaw) THX, I found a bug in my program and have fixed it!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "because the start of the move [0,0] is count as 1 move too"
                    },
                    {
                        "username": "noormd",
                        "content": "Make sure to traverse the array in all 8 directions.  `direction = [[1,0], [0,1], [-1,0], [0,-1], [1,1], [-1,-1], [1,-1], [-1,1]]` ,using this as template could be useful"
                    },
                    {
                        "username": "user5400vw",
                        "content": "Not a hard problem.  Just tedious and lots of potential for repetitive messy code."
                    },
                    {
                        "username": "WangXiaoShawn",
                        "content": "cant agree anymore\\n"
                    }
                ]
            },
            {
                "id": 1912488,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1912756,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1913466,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1912722,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1912533,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1912532,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1842244,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 2049155,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 2048374,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1967456,
                "content": [
                    {
                        "username": "slsktnkv",
                        "content": "Yet another bfs.\\nToo boring."
                    },
                    {
                        "username": "uday06",
                        "content": "could anyone please tell me why dfs is not working here?"
                    },
                    {
                        "username": "mochiball",
                        "content": "DFS is more work for shortest path problems. It will work but the code is more complicated and you\\'re potentially exploring paths that are not needed"
                    },
                    {
                        "username": "uday06",
                        "content": "[@amaan7](/amaan7) thanks"
                    },
                    {
                        "username": "amaan7",
                        "content": "dfs will work, but it will take more time than bfs to find the minimum path, and why so, because, dfs will find all the paths and while doing that it will make an answer for the minimum path, but in BFS as soon as we get the first path it will be our answer, no need to find the remaining paths! hope so I was able to clear the doubt "
                    },
                    {
                        "username": "uday06",
                        "content": "[@EricRaw](/EricRaw) thanks eric"
                    },
                    {
                        "username": "EricRaw",
                        "content": "it will take a long time because you are repeating the same grid over and over again and you are taking all the possible path before you can end the DFS\n\neg\n[0,0,1]\n[0,0,1]\n[1,1,0]\n\nwith DFS if you check all direction you will call\n- the grid [1,0] 4 time from [0,0], [0,1], [1,1], and ([0,1] -> [1,1])\n- the middle of the grid 5 times from [0,0], [0,1], [1,0], ([0,1] -> [1,0]), and ([1,0] -> [0,1])\n- ect\n\nmaybe if you make a condition if it longer than the shortest traversal you found you break from it,  it will make it faster. but it will still take long time to find the shortest"
                    },
                    {
                        "username": "archijham1",
                        "content": "This problem cannot be solved using backtracking as it may give TLE. We can think of using memoization to reduce time complexity but this will also not work and give wrong solution, because what we will do is store value of case giving shortest path at that particular stage, let's say there are two possible case which will give same shortest value at that stage and our code will select one, but on moving at another stage this case may not be yield shortest path. Thus we may not get shortest path using memoization.\n\nThis is what I observed while trying to solve using Memoization.\n\nCorrect me if I am wrong."
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Yes bro same. I agree with you. I spent hrs debugging memoization with backtracking"
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Q. Why did normal 8-Directional BFS gave the 1st Path as the Shortest path. Even though I didn\\'t used any priority_queue or any min/max distance updation. It May be possible that any other path in BFS that matched row == n - 1 && col == m - 1 would yield shorter dist. "
                    },
                    {
                        "username": "EricRaw",
                        "content": "BFS guarantees that the first path it discovers will be the shortest because BFS explores the grid layer by layer, and each layer represents cells that are one step farther from the starting point"
                    },
                    {
                        "username": "daring-calf",
                        "content": "A good start for June and happy international Children\\'s Day everyone!"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Happy Children\\u2019s Day, leetcoders."
                    },
                    {
                        "username": "nikhila01",
                        "content": "This problem is quite heavy on edge cases. Consider these cases:\\n* The starting cell is blocked\\n* The target cell is blocked\\n* The start or target cells are not blocked but are surrounded by blocked cells\\n\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Every edge case can be handled by one line of conditional statement.\\nclass Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int res = 0, n = grid.size();\\n\\n        if(grid[0][0] == 1) return -1;\\n\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        map<pair<int,int>,bool> visi;\\n        map<pair<int,int>, int> rememb;\\n\\n        visi[{0,0}] = true;\\n        rememb[{0, 0}] = 1;\\n        \\n        int dx[] = {-1, -1, 0, 1, 1, 1, 0, -1};\\n        int dy[] = {0, 1, 1, 1, 0, -1, -1, -1};\\n\\n        while(!q.empty()){\\n            int x = q.front().first, y = q.front().second;\\n            q.pop();\\n\\n            cout << \"x = \" << x << \" y = \" << y << endl;\\n\\n            if(x == n-1 && y == n-1 && grid[x][y] == 0) return rememb[{x, y}]; \\n\\n            for(int i=0;i<8;i++){\\n                int newx = x + dx[i], newy = y + dy[i];\\n\\n                if(newx >= 0 && newx < n && newy >= 0 && newy < n && grid[newx][newy] == 0 && visi[{newx, newy}] == false){\\n                    q.push({newx, newy});\\n                    rememb[{newx, newy}] = rememb[{x, y}] + 1;\\n                    visi[{newx, newy}] = true;\\n                }\\n            }\\n        }\\n\\n        return -1;\\n    }\\n};"
                    },
                    {
                        "username": "layyy",
                        "content": "make the nodes visited as soon as you push them in the queue or you might get TLE"
                    },
                    {
                        "username": "mochiball",
                        "content": "Don\\'t think we need a visited array here. \\n\\nThis is just standard BFS with a distance array. We only add to queue if the distance to the cell is smaller than our current distance. This ensures that we will always have the shortest distance to a cell "
                    },
                    {
                        "username": "b20137",
                        "content": "```class Solution {\\nprivate:\\n    int mCost=INT_MAX;\\n\\n    void util(vector<vector<int>>& grid, vector<vector<bool>>& vis, int i=0, int j=0, int curCost=1) {\\n        int n=grid.size();\\n\\n        if(i==n-1 && j==n-1) {\\n            mCost=min(mCost, curCost);\\n            return;\\n        }\\n\\n        // down\\n        if(i<n-1 && grid[i+1][j]!=1 && !vis[i+1][j]) {\\n            vis[i+1][j]=true;\\n            util(grid, vis, i+1, j, curCost+1);\\n            vis[i+1][j]=false;\\n        }\\n        // up\\n        if(i>0 && grid[i-1][j]!=1 && !vis[i-1][j]) {\\n            vis[i-1][j]=true;\\n            util(grid, vis, i-1, j, curCost+1);\\n            vis[i-1][j]=false;\\n        }\\n        // right\\n        if(j<n-1 && grid[i][j+1]!=1 && !vis[i][j+1]) {\\n            vis[i][j+1]=true;\\n            util(grid, vis, i, j+1, curCost+1);\\n            vis[i][j+1]=false;\\n        }\\n        // left\\n        if(j>0 && grid[i][j-1]!=1 && !vis[i][j-1]) {\\n            vis[i][j-1]=true;\\n            util(grid, vis, i, j-1, curCost-1);\\n            vis[i][j-1]=false;\\n        }\\n        // down-right\\n        if(i<n-1 && j<n-1 && grid[i+1][j+1]!=1 && !vis[i+1][j+1]) {\\n            vis[i+1][j+1]=true;\\n            util(grid, vis, i+1, j+1, curCost+1);\\n            vis[i+1][j+1]=false;\\n        }\\n        // up-left\\n        if(i>0 && j>0 && grid[i-1][j-1]!=1 && !vis[i-1][j-1]) {\\n            vis[i-1][j-1]=true;\\n            util(grid, vis, i-1, j-1, curCost+1);\\n            vis[i-1][j-1]=false;\\n        }\\n        // up-right\\n        if(i>0 && j<n-1 && grid[i-1][j+1]!=1 && !vis[i-1][j+1]) {\\n            vis[i-1][j+1]=true;\\n            util(grid, vis, i-1, j+1, curCost+1);\\n            vis[i-1][j+1]=false;\\n        }\\n        // down-left\\n        if(i<n-1 && j>0 && grid[i+1][j-1]!=1 && !vis[i+1][j-1]) {\\n            vis[i+1][j-1]=true;\\n            util(grid, vis, i+1, j-1, curCost+1);\\n            vis[i+1][j-1]=false;\\n        }\\n    }\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n\\n        if(grid[0][0]==1) return -1;\\n\\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\\n        vis[0][0]=true;\\n\\n        util(grid, vis);\\n\\n        return mCost==INT_MAX ? -1 : mCost;\\n    }\\n};\\n```\\nWhat is wrong with this code?\\n"
                    }
                ]
            },
            {
                "id": 1928310,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1924380,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1921952,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1914453,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1914281,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1913744,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1913470,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1913454,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1913300,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1913287,
                "content": [
                    {
                        "username": "m00nbean",
                        "content": "It seems to me I've encountered strange behavior. I've solved this problem using my visual studio, but in that case:\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nI've got correct answer on my visual studio, which is 14,\nbut when I copied that code to leetcode editor i've got answer 15, which is incorrect, what is wrong with my code or editor?\n<iframe src=\"https://leetcode.com/playground/kgNKh3ML/shared\" frameBorder=\"0\" width=\"400\" height=\"300\"></iframe>"
                    },
                    {
                        "username": "m00nbean",
                        "content": "[@VladimirTheLeet](/VladimirTheLeet) so, it seems, my visual studio gives answer 14, leetcode output line says that output is 15 and the expected line answer 14 is required. It turns out I\\'m recieving different answers on different platforms with the same piece of code"
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "the path length, including both ends, is 15 for that case"
                    },
                    {
                        "username": "kaushambi2612",
                        "content": "For those thrown off by \"8-directionally connected\", it means you can go up, down, left, right, and all 4 diagonals. Here\\'s a useful link: https://www.imageprocessingplace.com/downloads_V3/root_downloads/tutorials/contour_tracing_Abeer_George_Ghuneim/connect.html"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "I am still learning DSA and i don\\'t know BFS, so i tried to solved this problem using recursion, but it is giving me TLE error at test case 49, can someone tell me how should i solve this problem using recursion?"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "so its actually DFS which you are doing here , but the fact is that DFS is not always optimal (i.e it wont always give you the shortest path ) hence it is advisable to use BFS here as it traverses breadth wise and always gives the most optimal answer from source to destination .\\n\\nIt is important to understand though why DFS wont work , the simple reason that DFS moves in a single direction till its greatest depth , and it marks the nodes as visited , once marked visited that particular node might not be available for the actual shorter path , hence it would reach the source eventually but would take a longer route . To rectify this everytime you finish the dfs calls you have to remove the visited cell from the visited set , this will give you the correct answer but the time complexity will be huge which would eventually lead to TLE.\\n\\nBut as said BFS traverses level-wise , hence the first time it reaches the target that path is actually the shortest path present ."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "By default, recursion will get you a DFS alg.  It\\'s possible to turn recursion into a BFS, but it\\'s a massive PITA, and impractical.\\n\\nAs for DFS... I still can\\'t come up with a way to use DFS to solve this thing."
                    },
                    {
                        "username": "SahilNikam",
                        "content": "testcase number 62 just blows my mind.\n[[0,1,1,0,0,0],\n[0,1,0,1,1,0],\n[0,1,1,0,1,0],\n[0,0,0,1,1,0],\n[1,1,1,1,1,0],\n[1,1,1,1,1,0]]\nwe can also travel up for  that we can maintain boolean array to mark visited and unvisited paths to avoid circular loop.\nbut it's getting TLE."
                    },
                    {
                        "username": "rayrogar",
                        "content": "Easy one , but we need to take carefull with so many thins  Uff!!, thats make our code ougly. Take good care with test cases, we don\\'t need to check the same case over and over again. That is the real goal in this problem I think.\\n[Here my solution, Beats 100% of Memory submisions ](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3589754/beats-100-in-memory/)"
                    },
                    {
                        "username": "prateekmohanty63",
                        "content": "Can someone explain me what is wrong with my code here \\n\\nclass Solution {\\npublic:\\n   \\n   long long solve(vector<vector<int>>&grid,int i,int j,vector<vector<int>>&vis)\\n   {\\n       // base case\\n       int n=grid.size();\\n       int m=grid[0].size();\\n\\n       // base case\\n\\n       if(i<0 || i>=n)return INT_MAX;\\n\\n       if(j<0 || j>=m)return INT_MAX;\\n\\n\\n        if(grid[i][j]==1)return INT_MAX;\\n\\n         if(i==n-1 && j==m-1)return 0; \\n\\n\\n       long long moveUp=INT_MAX;\\n       long long moveDown=INT_MAX;\\n       long long moveLeft=INT_MAX;\\n       long long moveRight=INT_MAX;\\n       long long moveDiag1=INT_MAX;\\n       long long moveDiag2=INT_MAX;\\n       long long moveDiag3=INT_MAX;\\n       long long moveDiag4=INT_MAX;\\n\\n      // move up\\n       if(i-1>=0 && vis[i-1][j]==0)\\n       {\\n           vis[i-1][j]=1;\\n           moveUp=1+solve(grid,i-1,j,vis);\\n       }\\n       // move down\\n       if(i+1<n && vis[i+1][j]==0)\\n       {\\n           vis[i+1][j]=1;\\n           moveDown=1+solve(grid,i+1,j,vis);\\n       }\\n       // move left\\n       if(j-1>=0 && vis[i][j-1]==0)\\n       {\\n           vis[i][j-1]=1;\\n           moveLeft=1+solve(grid,i,j-1,vis);\\n       }\\n       // move right\\n       if(j+1<m && vis[i][j+1]==0)\\n       {\\n           vis[i][j+1]=1;\\n           moveRight=1+solve(grid,i,j+1,vis);\\n       }\\n       // move diag-1\\n       if(i-1>=0 && j-1>=0 && vis[i-1][j-1]==0)\\n       {\\n           vis[i-1][j-1]=1;\\n           moveDiag1=1+solve(grid,i-1,j-1,vis);\\n       }\\n       // move diag-2\\n       if(i-1>=0 && j+1<m && vis[i-1][j+1]==0)\\n       {\\n           vis[i-1][j+1]=1;\\n           moveDiag2=1+solve(grid,i-1,j+1,vis);\\n       }\\n       // move diag-3\\n       if(i+1<n && j-1>=0 && vis[i+1][j-1]==0)\\n       {\\n           vis[i+1][j-1]=1;\\n           moveDiag3=1+solve(grid,i+1,j-1,vis);\\n       }\\n       // move diag-4\\n       if(i+1<n && j+1<m && vis[i+1][j+1]==0)\\n       {\\n           vis[i+1][j+1]=1;\\n           moveDiag4=1+solve(grid,i+1,j+1,vis);\\n       }\\n\\n       return min({moveUp,moveDown,moveLeft,moveRight,moveDiag1,moveDiag2,moveDiag3,moveDiag4});\\n   }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n\\n        int res=solve(grid,0,0,vis);\\n\\n        if(res==INT_MAX)return -1;\\n        return res+1;\\n\\n\\n    }\\n};\\n\\nWhy is this giving a wrong answer "
                    },
                    {
                        "username": "Bantydeni",
                        "content": "class Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1|| grid[n-1][n-1] == 1){\\n            return -1;\\n        }\\n        int[][] dirs = {{-1, -1}, {-1, 0},{-1,1}, {0,-1}, {0,1}, {1,-1}, {1,0}, {1,1} };\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] {0, 0});\\n        grid[0][0] = 1;\\n        while (!queue.isEmpty()) {\\n            int[] curr = queue.poll();\\n            int row = curr[0], col = curr[1];\\n            if (row == n-1 && col == n-1) {\\n                return grid[row][col];\\n            }\\n            for (int[] dir : dirs) {\\n                int newRow = row + dir[0], newCol = col + dir[1];\\n                if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n && grid[newRow][newCol] == 0) {\\n                    queue.offer(new int[]{newRow, newCol});\\n                    grid[newRow][newCol] = grid[row][col] + 1;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "no this is correct answer bro "
                    },
                    {
                        "username": "ariafrz",
                        "content": "I love BFS problems! So fun to implement. "
                    },
                    {
                        "username": "Hussain_14",
                        "content": "This code of mine does not work. Can someone find the bug in it please.\\nclass Solution {\\npublic: \\n    \\n    int ans=INT_MAX;\\n    int count=0;\\n    map<pair<int, int>, int> vis;\\n    // vector<vector<int>> vis;\\n    bool issafe(int i, int j, vector<vector<int>> grid)\\n    {\\n        if(i<grid.size() and j<grid.size() and i>=0 and j>=0 and !grid[i][j])\\n        return true;\\n        return false;\\n    }\\n\\n    void dfs(vector<vector<int>> grid, int indices[], int x, int y)\\n    {\\n        if(x==grid.size()-1 and y==grid[0].size()-1 and issafe(x,y,grid))\\n        {\\n            cout<<ans<<endl;\\n            ans=min(count, ans);\\n            \\n            return;\\n        }\\n        \\n        cout<<x<<\" \"<<y<<\" \"<<count<<endl;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                 \\n                 int currrow=x+indices[i];\\n                 int currcol=y+indices[j];\\n                 if(issafe(currrow,currcol,grid) and !vis[{currrow, currcol}])\\n                   {\\n                    \\n                    // cout<<count<<endl;\\n                    count=count+1;\\n                    vis[{currrow, currcol}]=1;\\n                    dfs(grid, indices, currrow, currcol);\\n                    count=count-1;  // we are backtracking to the start location\\n                   }\\n                 }\\n\\n        }  \\n    \\n        \\n    }\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        // so at every dfs call I need to go to every adjacent after checking if it is zero\\n        // to check if it is 0 we can do a issafe function on this\\n        // vis.resize(grid.size(), vector<int> (grid.size(), 0));\\n          int indices[3]={-1,0,1};\\n          dfs(grid,indices,0,0);\\n          if(ans==INT_MAX)\\n          return -1;\\n          return ans;\\n\\n    }\\n}; "
                    },
                    {
                        "username": "dragAnsh",
                        "content": "why can\\'t it be done using dp? i use a simple recursive approach and then use dp. but it gives wrong answer\\n\\nclass Solution {\\npublic:\\n\\n    int helper(vector<vector<int>>& grid, vector<vector<int>>& dp, int i, int j, int m, int n)\\n    {\\n        // base case\\n        if(i == m and j == n and grid[i][j] == 0)return dp[i][j] = 1;\\n\\n        // check\\n        if(i >= grid.size() or i < 0 or j >= grid[0].size() or j < 0 or grid[i][j] == 1)return -1;\\n\\n        // look-up\\n        if(dp[i][j] != -2)\\n        {\\n            return dp[i][j];\\n        }\\n\\n        // rec case\\n        int ans = INT_MAX;\\n        vector< pair<int, int> > dirn{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1,1}, {-1, -1}, {-1, 1}, {1, -1}};\\n\\n        for(auto dir : dirn)\\n        {\\n            int new_i = i + dir.first;\\n            int new_j = j + dir.second;\\n            // mark this cell as visited\\n            grid[i][j] = 1;\\n            int temp = helper(grid, dp, new_i, new_j, m, n);\\n            grid[i][j] = 0;\\n            // cout << \"i : \" << new_i << \", j : \" << new_j << \", tmp: \" << temp <<endl;\\n            if(temp != -1)ans = min(ans, temp + 1);\\n        }\\n        return dp[i][j] = (ans == INT_MAX ? -1 : ans);\\n    }\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        vector< vector<int> >dp(grid.size() + 1, vector<int>(grid[0].size() + 1, -2));\\n        return helper(grid, dp, 0, 0, grid.size() - 1, grid[0].size() - 1);\\n    }\\n};"
                    },
                    {
                        "username": "priyanshuagrawal419",
                        "content": "Dynamic programming can also be used to solve this problem by breaking it down into smaller subproblems and building up the solution based on the results of these subproblems. However, in this particular case, using dynamic programming may not be the most efficient approach because of the specific constraints and requirements of the problem.\\n\\nDynamic programming is typically beneficial when there are overlapping subproblems, and the solution to the larger problem can be efficiently constructed from the solutions to the smaller subproblems. In this problem, the length of the shortest clear path from the top-left cell to any other cell is not solely dependent on the lengths of the paths from neighboring cells. The requirement of 8-directional connectivity and the need to find the shortest path make it challenging to efficiently apply dynamic programming.\\n\\nWhile you could potentially use dynamic programming to solve this problem by memoizing the results of subproblems and building up the solution, the time and space complexity would likely be higher compared to using other approaches like BFS or DFS. Breadth-first search (BFS) is a more intuitive and efficient choice in this case because it explores the cells in a layer-by-layer manner, guaranteeing that the first path found to the target cell is the shortest one.\\n\\nIn summary, while dynamic programming is a powerful technique, it may not be the most suitable approach for this specific problem due to the requirements of 8-directional connectivity and finding the shortest path. BFS or DFS are more commonly used to solve such path-finding problems efficiently."
                    }
                ]
            },
            {
                "id": 1913273,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1913244,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1913214,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1913210,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1913189,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1913087,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1913078,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1913016,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1912985,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1912966,
                "content": [
                    {
                        "username": "shivamchaurasia2912",
                        "content": "\"they are different\" Ruined my day :)"
                    },
                    {
                        "username": "mustafiz7",
                        "content": "using extra space for storing visited node (in set or array) will give TLE.\\nHint is:(if u didnt get it)...\\n..\\n..\\n..\\n..\\n..\\nchange or manipulate grid array itself. That is, change visited array value to 1.\\nEx. grid[i][j] is visited change =1."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "# Here is an Approach :-)\n **Check if the top-left cell or the bottom-right cell is blocked (1). If either of them is blocked, return -1 as there is no clear path.**\n\n     Use Breadth-First Search (BFS) to explore the grid. Start from the top-left cell (0, 0) and traverse the grid level by level until reaching the \n      bottom-right cell (n-1, n-1) or until no more cells can be visited.\n\n            a. Initialize a queue, a visited matrix, and a variable to keep track of the path length.\n\n            b. Enqueue the starting cell into the queue and mark it as visited.\n\n            c. While the queue is not empty, dequeue a cell and examine its neighbors:\n                Check if each neighbor is valid (within grid boundaries, not blocked, and not visited).\n                If valid, enqueue the neighbor, mark it as visited, and increment the path length by 1.\n            \n            d. If the bottom-right cell is reached, return the path length as the shortest clear path.\n\n        If the bottom-right cell is not reached and there are no more cells to explore, return -1 as there is no clear path."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code for reference:-)***\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3586586/standard-bfs-easiest-solution/"
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "There is only one path or are multiple paths ?"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "There can be multiple shortest paths, but you need to find only the length. For example:\\n[[0,0,0],\\n[0,1,0],\\n[0,0,0]]\\n"
                    },
                    {
                        "username": "abhishekravi848",
                        "content": "I know BFS can work here. But I have a doubt that Whether  the backtracking Algorithm can be implemented on this question????? Although it may generate a lower TC solution but it may generate a solution???"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "yes you can implement backtracking solution using dfs. and it will give you tle.\\n"
                    },
                    {
                        "username": "robbiemu",
                        "content": "are we guaranteed that there is only one path?\nit seems like a trivial solution would be to always return 1, because any single cell is a shortest path from that cell to itself, and there is no designation of start and end cells."
                    },
                    {
                        "username": "manifold1985",
                        "content": "It does specify that a clear path in a binary matrix is a path from the **top-left cell (i.e., (0, 0))** to the **bottom-right cell (i.e., (n - 1, n - 1))**."
                    },
                    {
                        "username": "yinboshi13",
                        "content": "start = [0,0]; end = [n-1,n-1]\nThat's well defined...\n\nThere's no guarantee of single shortest path.  It's not asking for a path - it just wants the length.  Find any such path and return the length."
                    },
                    {
                        "username": "chettriyuvraj",
                        "content": "Unrelated to the solution, but why does Leetcode\\'s markdown editor get SO SLOW with a few thousand lines of solution text?"
                    },
                    {
                        "username": "SAKSHAM11_",
                        "content": "i was able to solve it easily but the description is not phrased appropriately \n\nIf someone is getting runtime error in bfs implementation, be sure to mark the node visited at the time of adding the node to queue ,This will solve your runtime problem ,!!!!!!!!"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "The reason why dfs is not working.\\ndfs are using the backtracking solution which as a result repeating the same cell multiple times but bfs are visiting each cell only once."
                    },
                    {
                        "username": "amaan7",
                        "content": "Good start to a month I guess !"
                    }
                ]
            },
            {
                "id": 1912938,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912878,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912851,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912810,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912800,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912724,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912707,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912692,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912667,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912665,
                "content": [
                    {
                        "username": "GD18",
                        "content": "Quite easy and straightforward question, just perform bfs to calculate shortest path from \\n [0][0] to [n-1][n-1] , instead of usual four directions, this time include diagonal directions as well, in total , ie 8 directions from every node !=1. DIRECTIONS -> [top,bot,left,right,top-left,top-right,bot-left,bot-right]."
                    },
                    {
                        "username": "Nexes_OO7",
                        "content": "This should be tagged easy as simple bfs algo!!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "QUESTIONS WITH SHORTEST PATH OR MINIMUM GO FOR BFS"
                    },
                    {
                        "username": "psionl0",
                        "content": "I spent way more time in this than necessary due to the poor wording of the question. The first two test cases made it appear that a diagonal counted as 2 moves but the reason why the path is 1 longer than otherwise apparent is that the TL corner is also counted in the path."
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "class Solution {\\npublic:\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        //these are the indexes for the last element\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n      vector<vector<int>> dis(n,vector<int>(m,1e9));\\n\\n       dis[0][0]=0;\\n        queue<pair<int,pair<int,int>>>q;\\n        q.push({0,{0,0}});\\n        int dr[]={-1,-1,-1,0,0,1,1,1};\\n        int dc[]={-1,0,1,-1,1,-1,0,1};\\n        while(!q.empty())\\n        {\\n             auto anmol=q.front();\\n             q.pop();\\n             int d=anmol.first;\\n             int r=anmol.second.first;\\n             int c=anmol.second.second;\\n          for(int i=0;i<8;i++){\\n              int nr=r+dr[i];\\n              int nc=r+dc[i];\\n              if(nr>=0 && nr<n && nc<m && nc>=0 && grid[nr][nc]==0 && d+1<dis[nr][nc])\\n              {\\n                  dis[nr][nc]=d+1;\\n                 \\n                  if(nr==n && nc==m)\\n                  {\\n                      return dis[nr][nc];\\n                  }\\n               q.push({d+1,{nr,nc}});\\n              }\\n          }\\n        }\\n        return -1;\\n    }\\n};\\ni have used queue to traverse in it .I am getting the error in it can anyone tell whats the problem in it "
                    },
                    {
                        "username": "mycodingprofileanmolparmar",
                        "content": "[@EricRaw](/EricRaw) corrected it but still not getting to the correct answer is anything more wrong thing that can you tell which is helpful to me thanks btw\\n"
                    },
                    {
                        "username": "EricRaw",
                        "content": " ```int nc=r+dc[i];```\nyou are adding the wrong thing\nthe r should be c if i am not wrong"
                    },
                    {
                        "username": "yurek16II",
                        "content": "In this case:\\n[[0,0,0,0,1],\\n [1,0,0,0,0],\\n [0,1,0,1,0],\\n [0,0,0,1,1],\\n [0,0,0,1,0]]\\n expected answer is 7.\\n\\nBut right, lower corner is surrounded by 1s.\\nShouldn\\'t the answer be -1?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "expected answer is -1"
                    },
                    {
                        "username": "EricRaw",
                        "content": "i test it in my place the expected answer is -1"
                    },
                    {
                        "username": "curtainyf",
                        "content": "Why this code cannot work when grid = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]:\\n `class Solution {\\npublic:\\n\\n    int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1}, dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\\n    int n;\\n\\n    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {\\n        if(grid[0][0] == 1) return -1;\\n        n = grid.size();\\n\\n        int res = 1000010;\\n\\n        queue<pair<pair<int, int>, int>> q;\\n        q.push(make_pair(make_pair(0, 0), 1));\\n        grid[0][0] = 1;\\n\\n        while(!q.empty()){\\n            auto cur = q.front(); q.pop();\\n            int x = cur.first.first, y = cur.first.second, dis = cur.second;\\n            if(x == n - 1 && y == n - 1) {res= min(res, dis); break;}\\n            for(int i = 0; i < 8; i ++){\\n                int xx = x + dx[i], yy = y + dy[i];\\n                if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0){\\n                    grid[xx][yy] = 1;\\n                    q.push(make_pair(make_pair(xx, yy), dis + 1)); \\n                }\\n            }\\n        }\\n\\n        if(res != 100010) return res;\\n        else return -1;\\n    }\\n};`"
                    },
                    {
                        "username": "curtainyf",
                        "content": "[@EricRaw](/EricRaw) U are right. I have checked many times before, I\\'m so stupid!!! Thank you!"
                    },
                    {
                        "username": "EricRaw",
                        "content": "`` if(xx >= 0 && x < n && yy >= 0 && yy < n && grid[xx][yy] == 0)``\\nthere is a typo in there where x is being used instead of xx"
                    },
                    {
                        "username": "zB0y",
                        "content": "Would a DFS solution not work?"
                    },
                    {
                        "username": "user5400vw",
                        "content": "whatever can be done in bfs can be done with dfs, right?  they will both traverse all nodes."
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "A good extension of this problem would be to show the path, not just find its length. And/or define the path length in a geometric sense, i.e., with a more costly diagonal step."
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "DFS here would be costlier in terms of operations performed right? "
                    }
                ]
            },
            {
                "id": 1912614,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1912613,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1912609,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1912595,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1912593,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1912511,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1912484,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1883520,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1803865,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            },
            {
                "id": 1799493,
                "content": [
                    {
                        "username": "girish13",
                        "content": "When I use a boolean[][] visited array to check if the cell is already visited or not, I get a TLE on testcase 68 (this has n = 100).\\n\\nBut when I use grid[][] itself to check if the cell is visited or not by modifying grid[x][y] = 1 when visiting and checking if grid[x][y] != 1 when adding new cell to the queue.\\n\\nI don\\'t get why my code is failing when the Time complexity is O(n^2) in both the cases ?\\n\\nSubmission Link :\\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961351642/\\n\\nCan someone pls explain what am I missing ?\\n\\n ```\\nclass Solution {\\n    public int shortestPathBinaryMatrix(int[][] grid) {\\n        int n = grid.length;\\n        if(grid[0][0] == 1 || grid[n - 1][n - 1] == 1) return -1;\\n        boolean[][] visited = new boolean[n][n];\\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\\n\\n        Queue<int[]> queue = new LinkedList<int[]>();\\n        queue.add(new int[]{0, 0, 1});\\n        \\n        while(!queue.isEmpty()){\\n            int[] curr = queue.poll();\\n            int r = curr[0], c = curr[1], d = curr[2];\\n            if(r == n - 1 && c == n - 1) return d;\\n            visited[r][c] = true;\\n            for(int[] dir : dirs){\\n                int x = r + dir[0], y = c + dir[1];\\n                if(x < 0 || y < 0 || x >= n || y >= n) continue;\\n                if(visited[x][y] == false && grid[x][y] == 0)\\n                    queue.add(new int[]{x, y, d + 1});\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "girish13",
                        "content": "Thanks a lot guys [@San_J](/ccx6mse9) [@Maang-io](/Maang-io) [@Eric](/EricRaw). Stupid & silly mistake. "
                    },
                    {
                        "username": "heissanjay",
                        "content": "You have to mark the current cell visited to true before adding it to the queue to make sure that we avoid revisiting the same cell multiple times.\\n\\n\\nTo fix your problem, \\nIn this block,\\n`\\nif(visited[x][y] == false && grid[x][y] == 0)\\n                   queue.add(new int[]{x, y, d + 1});\\n      }\\n`\\nyou are checking that the current cell is not visited and the value in the cell is \\'0\\', if yes, you are adding that to the queue, but you forgot to set the visited property of the current cell to *True*. Since it remains false, the above condition evaluated to true always, that prevent queue from become empty and stuck in endless loop. Thats produces the TLE."
                    },
                    {
                        "username": "Maang-io",
                        "content": "Set visited[r][c] = true, the moment you add them in queue. here is my submission, and I do use separate visited matrix. \\nhttps://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/961394666/"
                    },
                    {
                        "username": "EricRaw",
                        "content": "The problem arises from the order in which you mark a grid as visited. Currently, you set the visited status to true only when a grid is polled from the queue. However, this leads to multiple grids with the same x and y coordinates being added to the queue because the visited status remains false even though you already add it into your queue.\n\nto fix this you should set visited true when you add it into your queue\n\neg\n[0,0,0]\n[1,0,1]\n[1,1,1]\n\n- first step from [0, 0]\nadd [1,0] and [1,1]\nqueue = [1,0] and [1,1]\n\n- second step [1, 0]\nadd [2,0] and [1,1] again\nqueue = [1,1] , [2,1] , [1,1]"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "So they are over those DESIGNING questions finally"
                    },
                    {
                        "username": "Bantydeni",
                        "content": "The brute force approach for the Shortest Path in Binary Matrix problem would be to use DFS to explore all possible paths from the top-left cell to the bottom-right cell. The time complexity of this approach is O(2^(n^2)), where n is the size of the binary matrix.\\nDFS would explore every possible path from the top-left cell to the bottom-right cell, and keep track of the length of each path. It would then return the length of the shortest path found. However, this approach is not practical for large binary matrices, as the time complexity grows exponentially with the size of the matrix.\\nA more efficient approach is to use BFS, which can explore every possible direction at the same time and with the same speed, meaning that if any branch reaches the end, it must be the fastest one."
                    },
                    {
                        "username": "ebarykin",
                        "content": "Could you please explain why DFS time complexity  in your explanation is O(2^(n^2)) instead of O(n^2)??"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Why the hell backtracking + memoization is failing?"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "[@anxiousLeetcoder](/anxiousLeetcoder) Makes sense!"
                    },
                    {
                        "username": "anxiousLeetcoder",
                        "content": "backtracking + memoization will just traverse once from src to all nodes and save that path, it may or may not be the shortest one."
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "Got a similar question in a FAANG interview. The solution is a bit of a cliche. Please ask more this kind of questions more!!!"
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "All the adjacent cells of the path are 8-directionally connected (i.e., they are different and they share an edge or a corner).\\nCould someone tell what this actually means?"
                    },
                    {
                        "username": "cherkezovr",
                        "content": "This means you can move in 8 directions: not only vertically and horizontally, but diagonally too"
                    },
                    {
                        "username": "romegenix",
                        "content": "Can I use Dijkstra\\'s algorithm in this question ? If yes upvote it and explain me how please "
                    },
                    {
                        "username": "VladimirTheLeet",
                        "content": "Since all moves between cells have the same cost of 1, Dijkstra\\'s algorithm would be just a plain BFS."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "Dijkstra is too much. BFS is enough"
                    },
                    {
                        "username": "slsktnkv",
                        "content": "Of course, you can. Moreover, this is a solution."
                    },
                    {
                        "username": "im-naime",
                        "content": "Do you also love to walk on maze, grid, and matrix in bfs, dfs way! Let\\'s cheers, buddy."
                    },
                    {
                        "username": "easy_problems_hunter",
                        "content": "SHOULD BE AN EASY LEVEL"
                    },
                    {
                        "username": "nikhila01",
                        "content": "NO IT SHOULD NOT"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why doesn\\'t this work? Can someone explain me?\\n\\n\\n`class Solution {`\\n`public:`\\n `   int n;`\\n `   int f(int i,int j,vector<vector<int>>& grid){`\\n `       if(i==n-1 and j==n-1)return 0;`\\n`        if(i>=n or j>=n)return 1e7;`\\n  `      if(grid[i][j]==1)return 1e7;`\\n`        int r=f(i+1,j,grid);`\\n`        int d=f(i,j+1,grid);`\\n`        int di=f(i+1,j+1,grid);`\\n`        return 1+min({r,d,di});`\\n`    }`\\n`    int shortestPathBinaryMatrix(vector<vector<int>>& grid) {`\\n  `      n=grid.size();`\\n  `      int r;`\\n `       r=f(0,0,grid);`\\n `       if(r>=1e7)return -1;`\\n`        return r+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "siebenschlaefer",
                        "content": "Two issues: \\n- This solution does not check the value of that cell.\\n    But if the bottom-right cell (`grid[n - 1][n - 1]`) is `1` the function should return `-1`.\\n- This solution only consider three neighboring cells: `(i+1,j)`, `(i,j+1)`, and `(i+1,j+1)`.\\n    But what if the path needs is \"windy\" like in this example:\\n    ```\\n    {0,1,1,0,0,0},\\n    {0,1,0,1,1,0},\\n    {0,1,1,0,1,0},\\n    {0,0,0,1,1,0},\\n    {1,1,1,1,1,0},\\n    {1,1,1,1,1,0}\\n    ```\\n    You have to consider all neighboring cells."
                    }
                ]
            }
        ]
    }
]