[
    {
        "title": "Find the Celebrity",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1567240,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1570868,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1570222,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1566960,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1575568,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1568563,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1774364,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1576518,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1573806,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1573599,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1567240,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1570868,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1570222,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1566960,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1575568,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1568563,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1774364,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1576518,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1573806,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            },
            {
                "id": 1573599,
                "content": [
                    {
                        "username": "princessmaja",
                        "content": "What does the input [[1,1],[1,1]] mean? Problem says \"n people (labeled from 0 to n - 1) \".\\nDoes this input mean there are two people labelled 1?"
                    },
                    {
                        "username": "espertusnu",
                        "content": "The input is meant to be an adjacency matrix. The input [[1,1],[1,1]] means that both nodes point to each other."
                    },
                    {
                        "username": "user9260GC",
                        "content": "There is no \\'graph\\' in the input but it\\'s specified in the input section. Very misleading. Only actual input is \\'n\\'."
                    },
                    {
                        "username": "JinZhenlin",
                        "content": "So in the example 1, the input is:\\n\\n\"graph = [[1,1,0],[0,1,0],[1,1,1]]\"\\n\\nHow does that exactly translate to the explanation? :\\n\\n\"There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\" \\n\\n\\nIs anyone else just as confused as I am? Clarification is much appreciated! Thanks! \\n"
                    },
                    {
                        "username": "snowAnna",
                        "content": "I was stuck for a while since the system could not find \\'knows\\' ,We need to replace \\'knows\\' with Knows for c#"
                    },
                    {
                        "username": "manik_x_mahajan",
                        "content": "[[1,1,1],[1,1,0],[0,0,1]]\\n\\nThe expected  answer of this testcase is -1.\\nWe can clearly see that \\na. 2 knows no one.\\nb. 1 knows 0.\\nc. 0 knows 1,2.\\n\\nAs 2 don\\'t know anyone. The answer should be 2.\\nCan someone please clear it?\\n"
                    },
                    {
                        "username": "hashrin",
                        "content": "For 2 to be the celebrity, everyone else in the room should know 2. Here, 1 does not know 2."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "* A superb video solution from LC for bruteforce, optimal approaches and code. \\n* I mistook the question thinking the edges are already given and mentally tried solving using DFS and BFS. But later understood the catch of this problem is there are no edges for the nodes.\\n* I then mentally solved by brute force. Also observed that A knows B means B could be celebrity and A will never be celebrity. And tried to optimise ruling out A from celebrity possibility HashSet (which initially included all nodes). But failed in continuing. What I missed in observing is that if A doesn\\'t know B, then the opposite assumption is also possible, ie, A could be celebrity and B will never be the celebrity. \\n* Lesson learned: think in the opposite way too. Here I thought of the true case, but missed about the false case."
                    },
                    {
                        "username": "RohitSgh",
                        "content": "From every API call, we can **rule out one person**. This person **cannot** be celebrity.\\n\\n- if `knows(a, b)` returns `true`, this means `a` cannot be celebrity since the person knows someone.\\n- else if `knows(a, b)` returns `false`, this means `b` cannot be celebrity since there is one person which does not know about `b`\\n\\nThus, with $N-1$ API calls, we can rule out $N-1$ possibilities of celebrity, leaving us with only $1$ candidate for celebrity. "
                    },
                    {
                        "username": "Lily_X",
                        "content": "I thought the result will be 1 because 0 is a celebrity, but the correct answer is 0. Can someone help me on this?"
                    },
                    {
                        "username": "SanketSingh",
                        "content": "This question can be solved using graphs (indegree and outdegree concept) in O(N^2) Time complexity.\\nWe can also solve this question in O(N) time and O(1) space using simple two pointer concept.\\nWe are going to compare two persons at a time one from begining and other from end and we will remove that person from consideration which cannot be a celebrity. For example if there are two persons X and Y and X can identify person Y then surely X cannot be a celebrity as it knows a person inside this party. Other case would be when X does not know Y and in this case Y cannot be a celebrity as there is at least one person who does not know him/her inside party. Using this intuition two pointer concept can be applied to find the celebrity inside this party.\\nI found a good explanatory video on Youtube by algods.\\nYou can refer to this video for a better explanation.\\nVideo Link:\\n[https://youtu.be/aENYremq77I](http://)"
                    },
                    {
                        "username": "tyhal",
                        "content": "This test case will catch solutions that don\\'t check backwards.\\n\\n[ [0,0,1], [0,0,0], [0,0,0] ]\\n\\nSome solutions will pick p2 as the celebrity:\\n* They pick p2 because p0 knows p2 \\n* They don\\'t then check that p1 knows p2\\n\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Accounts Merge",
        "question_content": "<p>Given a list of <code>accounts</code> where each element <code>accounts[i]</code> is a list of strings, where the first element <code>accounts[i][0]</code> is a name, and the rest of the elements are <strong>emails</strong> representing emails of the account.</p>\n\n<p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p>\n\n<p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails <strong>in sorted order</strong>. The accounts themselves can be returned in <strong>any order</strong>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> accounts = [[&quot;John&quot;,&quot;johnsmith@mail.com&quot;,&quot;john_newyork@mail.com&quot;],[&quot;John&quot;,&quot;johnsmith@mail.com&quot;,&quot;john00@mail.com&quot;],[&quot;Mary&quot;,&quot;mary@mail.com&quot;],[&quot;John&quot;,&quot;johnnybravo@mail.com&quot;]]\n<strong>Output:</strong> [[&quot;John&quot;,&quot;john00@mail.com&quot;,&quot;john_newyork@mail.com&quot;,&quot;johnsmith@mail.com&quot;],[&quot;Mary&quot;,&quot;mary@mail.com&quot;],[&quot;John&quot;,&quot;johnnybravo@mail.com&quot;]]\n<strong>Explanation:</strong>\nThe first and second John&#39;s are the same person as they have the common email &quot;johnsmith@mail.com&quot;.\nThe third John and Mary are different people as none of their email addresses are used by other accounts.\nWe could return these lists in any order, for example the answer [[&#39;Mary&#39;, &#39;mary@mail.com&#39;], [&#39;John&#39;, &#39;johnnybravo@mail.com&#39;], \n[&#39;John&#39;, &#39;john00@mail.com&#39;, &#39;john_newyork@mail.com&#39;, &#39;johnsmith@mail.com&#39;]] would still be accepted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> accounts = [[&quot;Gabe&quot;,&quot;Gabe0@m.co&quot;,&quot;Gabe3@m.co&quot;,&quot;Gabe1@m.co&quot;],[&quot;Kevin&quot;,&quot;Kevin3@m.co&quot;,&quot;Kevin5@m.co&quot;,&quot;Kevin0@m.co&quot;],[&quot;Ethan&quot;,&quot;Ethan5@m.co&quot;,&quot;Ethan4@m.co&quot;,&quot;Ethan0@m.co&quot;],[&quot;Hanzo&quot;,&quot;Hanzo3@m.co&quot;,&quot;Hanzo1@m.co&quot;,&quot;Hanzo0@m.co&quot;],[&quot;Fern&quot;,&quot;Fern5@m.co&quot;,&quot;Fern1@m.co&quot;,&quot;Fern0@m.co&quot;]]\n<strong>Output:</strong> [[&quot;Ethan&quot;,&quot;Ethan0@m.co&quot;,&quot;Ethan4@m.co&quot;,&quot;Ethan5@m.co&quot;],[&quot;Gabe&quot;,&quot;Gabe0@m.co&quot;,&quot;Gabe1@m.co&quot;,&quot;Gabe3@m.co&quot;],[&quot;Hanzo&quot;,&quot;Hanzo0@m.co&quot;,&quot;Hanzo1@m.co&quot;,&quot;Hanzo3@m.co&quot;],[&quot;Kevin&quot;,&quot;Kevin0@m.co&quot;,&quot;Kevin3@m.co&quot;,&quot;Kevin5@m.co&quot;],[&quot;Fern&quot;,&quot;Fern0@m.co&quot;,&quot;Fern1@m.co&quot;,&quot;Fern5@m.co&quot;]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= accounts.length &lt;= 1000</code></li>\n\t<li><code>2 &lt;= accounts[i].length &lt;= 10</code></li>\n\t<li><code>1 &lt;= accounts[i][j].length &lt;= 30</code></li>\n\t<li><code>accounts[i][0]</code> consists of English letters.</li>\n\t<li><code>accounts[i][j] (for j &gt; 0)</code> is a valid email.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 109161,
                "title": "python-simple-dfs-with-explanation",
                "content": "We give each account an ID, based on the index of it within the list of accounts.\\n\\n```\\n[\\n  [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], # Account 0\\n  [\"John\", \"johnnybravo@mail.com\"], # Account 1\\n  [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],  # Account 2\\n  [\"Mary\", \"mary@mail.com\"] # Account 3\\n]\\n```\\n\\nNext, build an `emails_accounts_map` that maps an email to a list of accounts, which can be used to track which email is linked to which account. This is essentially our graph.\\n\\n```\\n# emails_accounts_map of email to account ID\\n{\\n  \"johnsmith@mail.com\": [0, 2],\\n  \"john00@mail.com\": [0],\\n  \"johnnybravo@mail.com\": [1],\\n  \"john_newyork@mail.com\": [2],\\n  \"mary@mail.com\": [3]\\n}\\n```\\n\\nNext we do a DFS on each account in accounts list and look up `emails_accounts_map` to tell us which accounts are linked to that particular account via common emails. This will make sure we visit each account only once. This is a recursive process and we should collect all the emails that we encounter along the way.\\n\\nLastly, sort the collected emails and add it to final results, `res` along with the name.\\n\\n**\\uD83D\\uDCAF Check out https://www.techinterviewhandbook.org for more tips and tricks by me to ace your coding interview \\uD83D\\uDCAF**\\n\\n```\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        from collections import defaultdict\\n        visited_accounts = [False] * len(accounts)\\n        emails_accounts_map = defaultdict(list)\\n        res = []\\n        # Build up the graph.\\n        for i, account in enumerate(accounts):\\n            for j in range(1, len(account)):\\n                email = account[j]\\n                emails_accounts_map[email].append(i)\\n        # DFS code for traversing accounts.\\n        def dfs(i, emails):\\n            if visited_accounts[i]:\\n                return\\n            visited_accounts[i] = True\\n            for j in range(1, len(accounts[i])):\\n                email = accounts[i][j]\\n                emails.add(email)\\n                for neighbor in emails_accounts_map[email]:\\n                    dfs(neighbor, emails)\\n        # Perform DFS for accounts and add to results.\\n        for i, account in enumerate(accounts):\\n            if visited_accounts[i]:\\n                continue\\n            name, emails = account[0], set()\\n            dfs(i, emails)\\n            res.append([name] + sorted(emails))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n[\\n  [\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], # Account 0\\n  [\"John\", \"johnnybravo@mail.com\"], # Account 1\\n  [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"],  # Account 2\\n  [\"Mary\", \"mary@mail.com\"] # Account 3\\n]\\n```\n```\\n# emails_accounts_map of email to account ID\\n{\\n  \"johnsmith@mail.com\": [0, 2],\\n  \"john00@mail.com\": [0],\\n  \"johnnybravo@mail.com\": [1],\\n  \"john_newyork@mail.com\": [2],\\n  \"mary@mail.com\": [3]\\n}\\n```\n```\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        from collections import defaultdict\\n        visited_accounts = [False] * len(accounts)\\n        emails_accounts_map = defaultdict(list)\\n        res = []\\n        # Build up the graph.\\n        for i, account in enumerate(accounts):\\n            for j in range(1, len(account)):\\n                email = account[j]\\n                emails_accounts_map[email].append(i)\\n        # DFS code for traversing accounts.\\n        def dfs(i, emails):\\n            if visited_accounts[i]:\\n                return\\n            visited_accounts[i] = True\\n            for j in range(1, len(accounts[i])):\\n                email = accounts[i][j]\\n                emails.add(email)\\n                for neighbor in emails_accounts_map[email]:\\n                    dfs(neighbor, emails)\\n        # Perform DFS for accounts and add to results.\\n        for i, account in enumerate(accounts):\\n            if visited_accounts[i]:\\n                continue\\n            name, emails = account[0], set()\\n            dfs(i, emails)\\n            res.append([name] + sorted(emails))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109157,
                "title": "java-c-union-find",
                "content": "1. The key task here is to `connect` those `emails`, and this is a perfect use case for union find.\\n2. to group these emails, each group need to have a `representative`, or `parent`.\\n3. At the beginning, set each email as its own representative.\\n4. Emails in each account naturally belong to a same group, and should be joined by assigning to the same parent (let's use the parent of first email in that list);\\n\\nSimple Example:\\n```\\na b c // now b, c have parent a\\nd e f // now e, f have parent d\\ng a d // now abc, def all merged to group g\\n\\nparents populated after parsing 1st account: a b c\\na->a\\nb->a\\nc->a\\n\\nparents populated after parsing 2nd account: d e f\\nd->d\\ne->d\\nf->d\\n\\nparents populated after parsing 3rd account: g a d\\ng->g\\na->g\\nd->g\\n\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> acts) {\\n        Map<String, String> owner = new HashMap<>();\\n        Map<String, String> parents = new HashMap<>();\\n        Map<String, TreeSet<String>> unions = new HashMap<>();\\n        for (List<String> a : acts) {\\n            for (int i = 1; i < a.size(); i++) {\\n                parents.put(a.get(i), a.get(i));\\n                owner.put(a.get(i), a.get(0));\\n            }\\n        }\\n        for (List<String> a : acts) {\\n            String p = find(a.get(1), parents);\\n            for (int i = 2; i < a.size(); i++)\\n                parents.put(find(a.get(i), parents), p);\\n        }\\n        for(List<String> a : acts) {\\n            String p = find(a.get(1), parents);\\n            if (!unions.containsKey(p)) unions.put(p, new TreeSet<>());\\n            for (int i = 1; i < a.size(); i++)\\n                unions.get(p).add(a.get(i));\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        for (String p : unions.keySet()) {\\n            List<String> emails = new ArrayList(unions.get(p));\\n            emails.add(0, owner.get(p));\\n            res.add(emails);\\n        }\\n        return res;\\n    }\\n    private String find(String s, Map<String, String> p) {\\n        return p.get(s) == s ? s : find(p.get(s), p);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& acts) {\\n        map<string, string> owner;\\n        map<string, string> parents;\\n        map<string, set<string>> unions;\\n        for (int i = 0; i < acts.size(); i++) {\\n            for (int j = 1; j < acts[i].size(); j++) {\\n                parents[acts[i][j]] = acts[i][j];\\n                owner[acts[i][j]] = acts[i][0];\\n            }\\n        }\\n        for (int i = 0; i < acts.size(); i++) {\\n            string p = find(acts[i][1], parents);\\n            for (int j = 2; j < acts[i].size(); j++)\\n                parents[find(acts[i][j], parents)] = p;\\n        }\\n        for (int i = 0; i < acts.size(); i++)\\n            for (int j = 1; j < acts[i].size(); j++)\\n                unions[find(acts[i][j], parents)].insert(acts[i][j]);\\n\\n        vector<vector<string>> res;\\n        for (pair<string, set<string>> p : unions) {\\n            vector<string> emails(p.second.begin(), p.second.end());\\n            emails.insert(emails.begin(), owner[p.first]);\\n            res.push_back(emails);\\n        }\\n        return res;\\n    }\\nprivate:\\n    string find(string s, map<string, string>& p) {\\n        return p[s] == s ? s : find(p[s], p);\\n    }\\n};\\n```\\n**C++ Lambda**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& acts) {\\n        map<string, string> owner;\\n        map<string, string> parents;\\n        function<string(string)> find = [&](string s) {return parents[s] == s ? s : find(parents[s]); };\\n        for (int i = 0; i < acts.size(); i++) {\\n            for (int j = 1; j < acts[i].size(); j++) {\\n                parents[acts[i][j]] = acts[i][j];\\n                owner[acts[i][j]] = acts[i][0];\\n            }\\n        }\\n        for (int i = 0; i < acts.size(); i++) {\\n            string p = find(acts[i][1]);\\n            for (int j = 2; j < acts[i].size(); j++) {\\n                parents[find(acts[i][j])] = p;\\n            }\\n        }\\n        map<string, set<string>> unions;\\n        for (int i = 0; i < acts.size(); i++) {\\n            for (int j = 1; j < acts[i].size(); j++) {\\n                unions[find(acts[i][j])].insert(acts[i][j]);\\n            }\\n        }\\n        vector<vector<string>> merged;\\n        for (pair<string, set<string>> p : unions) {\\n            vector<string> emails(p.second.begin(), p.second.end());\\n            emails.insert(emails.begin(), owner[p.first]);\\n            merged.push_back(emails);\\n        }\\n        return merged;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\na b c // now b, c have parent a\\nd e f // now e, f have parent d\\ng a d // now abc, def all merged to group g\\n\\nparents populated after parsing 1st account: a b c\\na->a\\nb->a\\nc->a\\n\\nparents populated after parsing 2nd account: d e f\\nd->d\\ne->d\\nf->d\\n\\nparents populated after parsing 3rd account: g a d\\ng->g\\na->g\\nd->g\\n\\n```\n```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> acts) {\\n        Map<String, String> owner = new HashMap<>();\\n        Map<String, String> parents = new HashMap<>();\\n        Map<String, TreeSet<String>> unions = new HashMap<>();\\n        for (List<String> a : acts) {\\n            for (int i = 1; i < a.size(); i++) {\\n                parents.put(a.get(i), a.get(i));\\n                owner.put(a.get(i), a.get(0));\\n            }\\n        }\\n        for (List<String> a : acts) {\\n            String p = find(a.get(1), parents);\\n            for (int i = 2; i < a.size(); i++)\\n                parents.put(find(a.get(i), parents), p);\\n        }\\n        for(List<String> a : acts) {\\n            String p = find(a.get(1), parents);\\n            if (!unions.containsKey(p)) unions.put(p, new TreeSet<>());\\n            for (int i = 1; i < a.size(); i++)\\n                unions.get(p).add(a.get(i));\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        for (String p : unions.keySet()) {\\n            List<String> emails = new ArrayList(unions.get(p));\\n            emails.add(0, owner.get(p));\\n            res.add(emails);\\n        }\\n        return res;\\n    }\\n    private String find(String s, Map<String, String> p) {\\n        return p.get(s) == s ? s : find(p.get(s), p);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& acts) {\\n        map<string, string> owner;\\n        map<string, string> parents;\\n        map<string, set<string>> unions;\\n        for (int i = 0; i < acts.size(); i++) {\\n            for (int j = 1; j < acts[i].size(); j++) {\\n                parents[acts[i][j]] = acts[i][j];\\n                owner[acts[i][j]] = acts[i][0];\\n            }\\n        }\\n        for (int i = 0; i < acts.size(); i++) {\\n            string p = find(acts[i][1], parents);\\n            for (int j = 2; j < acts[i].size(); j++)\\n                parents[find(acts[i][j], parents)] = p;\\n        }\\n        for (int i = 0; i < acts.size(); i++)\\n            for (int j = 1; j < acts[i].size(); j++)\\n                unions[find(acts[i][j], parents)].insert(acts[i][j]);\\n\\n        vector<vector<string>> res;\\n        for (pair<string, set<string>> p : unions) {\\n            vector<string> emails(p.second.begin(), p.second.end());\\n            emails.insert(emails.begin(), owner[p.first]);\\n            res.push_back(emails);\\n        }\\n        return res;\\n    }\\nprivate:\\n    string find(string s, map<string, string>& p) {\\n        return p[s] == s ? s : find(p[s], p);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& acts) {\\n        map<string, string> owner;\\n        map<string, string> parents;\\n        function<string(string)> find = [&](string s) {return parents[s] == s ? s : find(parents[s]); };\\n        for (int i = 0; i < acts.size(); i++) {\\n            for (int j = 1; j < acts[i].size(); j++) {\\n                parents[acts[i][j]] = acts[i][j];\\n                owner[acts[i][j]] = acts[i][0];\\n            }\\n        }\\n        for (int i = 0; i < acts.size(); i++) {\\n            string p = find(acts[i][1]);\\n            for (int j = 2; j < acts[i].size(); j++) {\\n                parents[find(acts[i][j])] = p;\\n            }\\n        }\\n        map<string, set<string>> unions;\\n        for (int i = 0; i < acts.size(); i++) {\\n            for (int j = 1; j < acts[i].size(); j++) {\\n                unions[find(acts[i][j])].insert(acts[i][j]);\\n            }\\n        }\\n        vector<vector<string>> merged;\\n        for (pair<string, set<string>> p : unions) {\\n            vector<string> emails(p.second.begin(), p.second.end());\\n            emails.insert(emails.begin(), owner[p.first]);\\n            merged.push_back(emails);\\n        }\\n        return merged;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109158,
                "title": "java-solution-build-graph-dfs-search",
                "content": "I have tried my best to make my code clean. Hope the basic idea below may help you. Happy coding!\n\nBasicly, this is a graph problem. Notice that each account[ i ] tells us some edges. What we have to do is as follows:\n1. Use these edges to build some components. Common email addresses are like the intersections that connect each single component for each account.\n2. Because each component represents a merged account, do DFS search for each components and add into a list. Before add the name into this list, sort the emails. Then add name string into it.\n\nExamples: Assume we have three accounts, we connect them like this in order to use DFS. \n{Name, 1, 2, 3} => Name -- 1 -- 2 -- 3\n{Name, 2, 4, 5} => Name -- 2 -- 4 -- 5 (The same graph node 2 appears)\n{Name, 6, 7, 8} => Name -- 6 -- 7 -- 8\n(Where numbers represent email addresses).\n\n```\nclass Solution {\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\n        Map<String, Set<String>> graph = new HashMap<>();  //<email node, neighbor nodes>\n        Map<String, String> name = new HashMap<>();        //<email, username>\n        // Build the graph;\n        for (List<String> account : accounts) {\n            String userName = account.get(0);\n            for (int i = 1; i < account.size(); i++) {\n                if (!graph.containsKey(account.get(i))) {\n                    graph.put(account.get(i), new HashSet<>());\n                }\n                name.put(account.get(i), userName);\n                \n                if (i == 1) continue;\n                graph.get(account.get(i)).add(account.get(i - 1));\n                graph.get(account.get(i - 1)).add(account.get(i));\n            }\n        }\n        \n        Set<String> visited = new HashSet<>();\n        List<List<String>> res = new LinkedList<>();\n        // DFS search the graph;\n        for (String email : name.keySet()) {\n            List<String> list = new LinkedList<>();\n            if (visited.add(email)) {\n                dfs(graph, email, visited, list);\n                Collections.sort(list);\n                list.add(0, name.get(email));\n                res.add(list);\n            }\n        }\n        \n        return res;\n    }\n    \n    public void dfs(Map<String, Set<String>> graph, String email, Set<String> visited, List<String> list) {\n        list.add(email);\n        for (String next : graph.get(email)) {\n            if (visited.add(next)) {\n                dfs(graph, next, visited, list);\n            }\n        }\n    }\n}\n````\nPlease check the clean version posted by @zhangchunli below. Thanks for updating.",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\n        Map<String, Set<String>> graph = new HashMap<>();  //<email node, neighbor nodes>\n        Map<String, String> name = new HashMap<>();        //<email, username>\n        // Build the graph;\n        for (List<String> account : accounts) {\n            String userName = account.get(0);\n            for (int i = 1; i < account.size(); i++) {\n                if (!graph.containsKey(account.get(i))) {\n                    graph.put(account.get(i), new HashSet<>());\n                }\n                name.put(account.get(i), userName);\n                \n                if (i == 1) continue;\n                graph.get(account.get(i)).add(account.get(i - 1));\n                graph.get(account.get(i - 1)).add(account.get(i));\n            }\n        }\n        \n        Set<String> visited = new HashSet<>();\n        List<List<String>> res = new LinkedList<>();\n        // DFS search the graph;\n        for (String email : name.keySet()) {\n            List<String> list = new LinkedList<>();\n            if (visited.add(email)) {\n                dfs(graph, email, visited, list);\n                Collections.sort(list);\n                list.add(0, name.get(email));\n                res.add(list);\n            }\n        }\n        \n        return res;\n    }\n    \n    public void dfs(Map<String, Set<String>> graph, String email, Set<String> visited, List<String> list) {\n        list.add(email);\n        for (String next : graph.get(email)) {\n            if (visited.add(next)) {\n                dfs(graph, next, visited, list);\n            }\n        }\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 1084738,
                "title": "python-the-clean-union-find-solution-you-are-looking-for",
                "content": "```python\\nclass UF:\\n    def __init__(self, N):\\n        self.parents = list(range(N))\\n    def union(self, child, parent):\\n        self.parents[self.find(child)] = self.find(parent)\\n    def find(self, x):\\n        if x != self.parents[x]:\\n            self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\nclass Solution:\\n    # 196 ms, 82.09%. \\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        uf = UF(len(accounts))\\n        \\n        # Creat unions between indexes\\n        ownership = {}\\n        for i, (_, *emails) in enumerate(accounts):\\n            for email in emails:\\n                if email in ownership:\\n                    uf.union(i, ownership[email])\\n                ownership[email] = i\\n        \\n        # Append emails to correct index\\n        ans = collections.defaultdict(list)\\n        for email, owner in ownership.items():\\n            ans[uf.find(owner)].append(email)\\n        \\n        return [[accounts[i][0]] + sorted(emails) for i, emails in ans.items()]\\n```\\nI hope you learn something new. \\nIf you think your solution is cleaner, I would love to learn how you do it. Please post it below.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```python\\nclass UF:\\n    def __init__(self, N):\\n        self.parents = list(range(N))\\n    def union(self, child, parent):\\n        self.parents[self.find(child)] = self.find(parent)\\n    def find(self, x):\\n        if x != self.parents[x]:\\n            self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\nclass Solution:\\n    # 196 ms, 82.09%. \\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        uf = UF(len(accounts))\\n        \\n        # Creat unions between indexes\\n        ownership = {}\\n        for i, (_, *emails) in enumerate(accounts):\\n            for email in emails:\\n                if email in ownership:\\n                    uf.union(i, ownership[email])\\n                ownership[email] = i\\n        \\n        # Append emails to correct index\\n        ans = collections.defaultdict(list)\\n        for email, owner in ownership.items():\\n            ans[uf.find(owner)].append(email)\\n        \\n        return [[accounts[i][0]] + sorted(emails) for i, emails in ans.items()]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601960,
                "title": "c-python-simple-solution-w-images-and-explanation-building-graph-dfs",
                "content": "We are given list of accounts `A` where  `A[i][0]` denotes a person having email accounts: `A[i][j]` (`1 <= j <= size(A[i])`). Two person `A[i1][0]` & `A[i2][0]` having a common email denote that they are same person and we need to merge such accounts into one.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Connect Emails & DFS)***\\n\\nThe question asks us to merge two accounts if they have a common email. How do we identify if two accounts have a common email? We could iterate over two accounts of same name and for every email of one account, if it is found in other account, we merge those account. However, this is costly as for every account, we may need to traverse every email of every other account which gives time complexity of <code>O((NML)<sup>2</sup>)</code>, where `N` is the number of accounts, `M` is the number of emails per account, `L` is the length of each email.\\n\\nBut is there a more efficient way?\\nWe can see that the set of emails of each account form a single group belonging to a person. If we visualize these as a graph, we can think of them as various connected components of a graph. More specifically, the emails belonging to a person form the node of a connected component and all these connected components make up our whole graph. \\n\\nNow, each email from one account will have an edge with one another email of the same account. But if an email is found in multiple accounts, they will have edge with other emails from all these multiple accounts as well. The following diagram will help better visualize the scenario (In image, `A` is input list, <code>P<sub>i</sub></code> denotes person name of an account and <code>E<sub>i</sub></code> denotes emails) -\\n\\n<p align = middle>\\n<img src = \"https://assets.leetcode.com/users/images/a168aaeb-2a72-4685-8c22-3035b403df40_1638157349.171727.png\" width=700 />\\n</p>\\n\\n\\nAn email belonging to multiple accounts will have edge with atleast one other email from each of those multiple accounts. This effectively merges the group of emails from these accounts into one. Thus, when we model this problem using graph, we can see that the emails belonging to the same person (even if they are from different accounts) form a single connected component. So we can just iterate over each component to find all the emails that belong to that person.\\n\\nWe can state the above approach in following steps -\\n1. Form an undirected acyclic graph with emails as node. This can be represented as adjacency list graph. Each email node from same account will be connected & have an edge with one other email from same account. For eg. If E1, E2, E3 are emails of an account, E1 forms edge with E2 and E2 forms edge with E3.\\n\\n2. Start with each account, take an email from that account(let\\'s say 1st email) & traverse over the component of that email. Each email traversed will belong to the person of this account (since they form a connected component). We can use DFS/BFS for traversing the component of graph. We will sort the list emails found in this traversal and it in final list of merged accounts along with the person name at beginning.\\n   We also mark each of these email as seen so we dont iterate over them again and form a duplicate.\\n3. We repeat the process for all accounts. Finally, we would have traversed over every email and if an email was present in multiple accounts, it will be merged into list of emails belonging to same person.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    void dfs(string& email) {\\n        seen.insert(email);\\n        ans.back().push_back(email);\\n        for(auto& adjEmail : G[email]) \\n            if(!seen.count(adjEmail)) \\n                dfs(adjEmail);        \\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& A) {        \\n        for(auto& acc : A)                            \\n            for(int i = 2; i < size(acc); i++)              // create graph with email as nodes and,\\n                G[acc[i]].push_back(acc[i-1]),              // add edges between adjacent nodes of same account\\n                G[acc[i-1]].push_back(acc[i]);\\n        \\n        for(auto& acc : A) \\n            if(!seen.count(acc[1])) {                       // If an email from a account is not previously seen,\\n                ans.push_back({acc[0]});                    // create new account & insert person\\'s name\\n                dfs(acc[1]);                                // perform dfs to find all his emails & add it to the list\\n                sort(begin(ans.back())+1, end(ans.back())); // sort the emails\\n            }            \\n        \\n        return ans;\\n    }\\nprivate:\\n    unordered_map<string, vector<string>> G;  // adjacency list graph with email as nodes and edges between adjacent email of same account\\n    unordered_set<string> seen;               // to mark an email as visited in DFS\\n    vector<vector<string>> ans;               // final answer after merging accounts\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def accountsMerge(self, A):\\n        G, seen, ans = defaultdict(list), set(), []\\n\\n        for acc in A:\\n            for i in range(2,len(acc)):\\n                G[acc[i]].append(acc[i-1])\\n                G[acc[i-1]].append(acc[i])\\n\\n        def dfs(email):\\n            seen.add(email)\\n            emailList = [email]\\n            for E in G[email]:\\n                if E not in seen:\\n                    emailList.extend(dfs(E))\\n            return emailList\\n        for acc in A:\\n            if acc[1] not in seen:\\n                ans.append([acc[0]] + sorted(dfs(acc[1])))\\n        return ans\\n```\\n\\n\\n***Time Complexity :*** <code>O(NML\\\\*log(NM))</code>, where `N` is the number of accounts, `M` is the number of emails per account, `L` is the length of each email. We firstly iterate over each email from each account and form the graph which requires `O(NML)`. Then for every account, we consider the 1st email in it and perform a DFS if that email was not seen previously. Finally the set of emails found in DFS are sorted and inserted into the final list. In worst case, every email may belongs to same person and in this case sorting takes <code>O(NML*log(NM))</code>\\n***Space Complexity :*** <code>O(NML)</code>, required to store the graph. \\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void dfs(string& email) {\\n        seen.insert(email);\\n        ans.back().push_back(email);\\n        for(auto& adjEmail : G[email]) \\n            if(!seen.count(adjEmail)) \\n                dfs(adjEmail);        \\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& A) {        \\n        for(auto& acc : A)                            \\n            for(int i = 2; i < size(acc); i++)              // create graph with email as nodes and,\\n                G[acc[i]].push_back(acc[i-1]),              // add edges between adjacent nodes of same account\\n                G[acc[i-1]].push_back(acc[i]);\\n        \\n        for(auto& acc : A) \\n            if(!seen.count(acc[1])) {                       // If an email from a account is not previously seen,\\n                ans.push_back({acc[0]});                    // create new account & insert person\\'s name\\n                dfs(acc[1]);                                // perform dfs to find all his emails & add it to the list\\n                sort(begin(ans.back())+1, end(ans.back())); // sort the emails\\n            }            \\n        \\n        return ans;\\n    }\\nprivate:\\n    unordered_map<string, vector<string>> G;  // adjacency list graph with email as nodes and edges between adjacent email of same account\\n    unordered_set<string> seen;               // to mark an email as visited in DFS\\n    vector<vector<string>> ans;               // final answer after merging accounts\\n};\\n```\n```python\\nclass Solution:\\n    def accountsMerge(self, A):\\n        G, seen, ans = defaultdict(list), set(), []\\n\\n        for acc in A:\\n            for i in range(2,len(acc)):\\n                G[acc[i]].append(acc[i-1])\\n                G[acc[i-1]].append(acc[i])\\n\\n        def dfs(email):\\n            seen.add(email)\\n            emailList = [email]\\n            for E in G[email]:\\n                if E not in seen:\\n                    emailList.extend(dfs(E))\\n            return emailList\\n        for acc in A:\\n            if acc[1] not in seen:\\n                ans.append([acc[0]] + sorted(dfs(acc[1])))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 172568,
                "title": "beats-99-18-solution-c",
                "content": "```\\nclass Solution {\\n    int find(vector<int> &union_find, int ind) {\\n        while(union_find[ind] != ind)\\n            ind = union_find[ind];\\n        return ind;\\n    }\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string, int> m;\\n        vector<int> union_find(accounts.size(), 0);\\n        unordered_map<int, vector<string>> res_map;\\n        for (int i = 0; i < accounts.size(); i++) {\\n            union_find[i] = i;\\n            for (int j = 1; j < accounts[i].size(); j++) {\\n                if (m.find(accounts[i][j]) != m.end()) {\\n                    int root1 = find(union_find, i);\\n                    int root2 = find(union_find, m[accounts[i][j]]);\\n                    union_find[root1] = root2;\\n                }\\n                else\\n                    m[accounts[i][j]] = union_find[i];\\n            }\\n        }\\n        for (auto it : m) {\\n            int ind = find(union_find, it.second);\\n            res_map[ind].push_back(it.first);\\n        }\\n        vector<vector<string>> res;\\n        for (auto it : res_map) {\\n            vector<string> email = it.second;\\n            sort(email.begin(), email.end());\\n            email.insert(email.begin(), accounts[it.first][0]);\\n            res.push_back(email);\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int find(vector<int> &union_find, int ind) {\\n        while(union_find[ind] != ind)\\n            ind = union_find[ind];\\n        return ind;\\n    }\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string, int> m;\\n        vector<int> union_find(accounts.size(), 0);\\n        unordered_map<int, vector<string>> res_map;\\n        for (int i = 0; i < accounts.size(); i++) {\\n            union_find[i] = i;\\n            for (int j = 1; j < accounts[i].size(); j++) {\\n                if (m.find(accounts[i][j]) != m.end()) {\\n                    int root1 = find(union_find, i);\\n                    int root2 = find(union_find, m[accounts[i][j]]);\\n                    union_find[root1] = root2;\\n                }\\n                else\\n                    m[accounts[i][j]] = union_find[i];\\n            }\\n        }\\n        for (auto it : m) {\\n            int ind = find(union_find, it.second);\\n            res_map[ind].push_back(it.first);\\n        }\\n        vector<vector<string>> res;\\n        for (auto it : res_map) {\\n            vector<string> email = it.second;\\n            sort(email.begin(), email.end());\\n            email.insert(email.begin(), accounts[it.first][0]);\\n            res.push_back(email);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 140978,
                "title": "easy-to-understand-union-find-in-java-95",
                "content": "```\\nclass Solution {\\n  public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n    int[] parents = new int[accounts.size()];\\n    for (int i = 0; i < accounts.size(); i++) {\\n      parents[i] = i;  \\n    }\\n    Map<String, Integer> owners = new HashMap<>();\\n    for (int i = 0; i < accounts.size(); i++) {\\n      for (int j = 1; j < accounts.get(i).size(); j++) {\\n        String email = accounts.get(i).get(j);\\n        if (owners.containsKey(email)) {\\n          int person = owners.get(email);\\n          int p1 = findParent(parents, i);\\n          int p2 = findParent(parents, person);\\n          if (p1 != p2) {\\n            parents[p2] = p1;  \\n          }\\n        } else {\\n          owners.put(email, i);  \\n        }\\n      }\\n    }\\n    \\n    Map<Integer, TreeSet<String>> users = new HashMap<>();\\n    for (int i = 0; i < accounts.size(); i++) {\\n      int parent = findParent(parents, i);\\n      List<String> emails = accounts.get(i);\\n      users.putIfAbsent(parent, new TreeSet<String>());\\n      users.get(parent).addAll(emails.subList(1, emails.size()));\\n    }\\n    \\n    List<List<String>> res = new ArrayList<List<String>>();\\n    for (Integer idx : users.keySet()) {\\n      String name = accounts.get(idx).get(0);\\n      ArrayList<String> emails = new ArrayList<>(users.get(idx));\\n      emails.add(0, name);\\n      res.add(emails);\\n    } \\n    return res;\\n  }\\n  \\n  private int findParent(int[] parents, int idx) {\\n    while (idx != parents[idx]) {\\n      parents[idx] = parents[parents[idx]];  \\n      idx = parents[idx];\\n    }\\n    return idx;\\n  } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n    int[] parents = new int[accounts.size()];\\n    for (int i = 0; i < accounts.size(); i++) {\\n      parents[i] = i;  \\n    }\\n    Map<String, Integer> owners = new HashMap<>();\\n    for (int i = 0; i < accounts.size(); i++) {\\n      for (int j = 1; j < accounts.get(i).size(); j++) {\\n        String email = accounts.get(i).get(j);\\n        if (owners.containsKey(email)) {\\n          int person = owners.get(email);\\n          int p1 = findParent(parents, i);\\n          int p2 = findParent(parents, person);\\n          if (p1 != p2) {\\n            parents[p2] = p1;  \\n          }\\n        } else {\\n          owners.put(email, i);  \\n        }\\n      }\\n    }\\n    \\n    Map<Integer, TreeSet<String>> users = new HashMap<>();\\n    for (int i = 0; i < accounts.size(); i++) {\\n      int parent = findParent(parents, i);\\n      List<String> emails = accounts.get(i);\\n      users.putIfAbsent(parent, new TreeSet<String>());\\n      users.get(parent).addAll(emails.subList(1, emails.size()));\\n    }\\n    \\n    List<List<String>> res = new ArrayList<List<String>>();\\n    for (Integer idx : users.keySet()) {\\n      String name = accounts.get(idx).get(0);\\n      ArrayList<String> emails = new ArrayList<>(users.get(idx));\\n      emails.add(0, name);\\n      res.add(emails);\\n    } \\n    return res;\\n  }\\n  \\n  private int findParent(int[] parents, int idx) {\\n    while (idx != parents[idx]) {\\n      parents[idx] = parents[parents[idx]];  \\n      idx = parents[idx];\\n    }\\n    return idx;\\n  } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602173,
                "title": "python-simple-dfs-explained",
                "content": "Actually, what we need to find is this problem are connected components of graph. So, let us do it in two steps:\\n\\n1. Construct our graph, iterating over `accounts`: for each name: look at emails `E1, ..., Ek`, then it is enough to connect `E1` with each of the others.\\n2. Perform dfs to find connected components, which we keep as `comps` with correspondences between number of component and list of emails in this component. We also keep set `seen` of visited nodes. In the end we just return sort all components and return then.\\n\\n#### Complexity\\nTime complexity is  `O(a1 log a1 + ... ak * log ak)` where `ai` is the length of `accounts[i]`. Space complexity is `O(a1 + ... + ak)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def accountsMerge(self, accounts):\\n        names = {}\\n        graph = defaultdict(set)\\n        for acc in accounts:\\n            name = acc[0]\\n            for email in acc[1:]:\\n                graph[acc[1]].add(email)\\n                graph[email].add(acc[1])\\n                names[email] = name\\n                \\n        comps, seen, ans, i = defaultdict(list), set(), [], 0\\n        def dfs(node, i):\\n            comps[i].append(node)\\n            seen.add(node)\\n            for neib in graph[node]:\\n                if neib not in seen: dfs(neib, i)\\n        \\n        for email in graph:\\n            if email not in seen:\\n                dfs(email, i)\\n                i += 1\\n        \\n        return [[names[val[0]]] + sorted(val) for _,val in comps.items()]\\n```\\n\\n#### Remark\\nThere is also union find solution, but because we need to sort our emails, time complexity, even for union find with ranks will be the same as for simple dfs.\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def accountsMerge(self, accounts):\\n        names = {}\\n        graph = defaultdict(set)\\n        for acc in accounts:\\n            name = acc[0]\\n            for email in acc[1:]:\\n                graph[acc[1]].add(email)\\n                graph[email].add(acc[1])\\n                names[email] = name\\n                \\n        comps, seen, ans, i = defaultdict(list), set(), [], 0\\n        def dfs(node, i):\\n            comps[i].append(node)\\n            seen.add(node)\\n            for neib in graph[node]:\\n                if neib not in seen: dfs(neib, i)\\n        \\n        for email in graph:\\n            if email not in seen:\\n                dfs(email, i)\\n                i += 1\\n        \\n        return [[names[val[0]]] + sorted(val) for _,val in comps.items()]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224506,
                "title": "c-60-ms-beats-98-75-union-find-solution-with-detailed-explanation",
                "content": "```\\n\\tvector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        std::vector<int> parent(accounts.size(), 0);\\n        std::unordered_map<std::string, int> email_id;\\n        \\n        // We gather all the e-mails and the group in whick thet belong\\n        // We make groups for the case that one e-mail has multiple accounts\\n        for (int i = 0; i < accounts.size(); i++) {\\n            // Initialize the parent vector\\n            parent[i] = i;\\n            for (int j = 1; j < accounts[i].size(); j++) {\\n                // If this e-mail has been found again then union-find in order to \\n                // add under the same group the current e-mail and the already stored\\n                // e-mail\\n                if (email_id.find(accounts[i][j]) != email_id.end()) {\\n                    int f1 = find(parent, i);\\n                    int f2 = find(parent, email_id[accounts[i][j]]);\\n                    // Union\\n                    parent[f1] = f2;\\n                } else {\\n                    // If this e-mail is found for the first time then add it to the map\\n                    email_id[accounts[i][j]] = i;\\n                }\\n            }\\n        }\\n        // We make a new map in order to store for every group the e-mails it contains\\n        std::unordered_map<int, std::vector<std::string>> mres;\\n        for (auto it : email_id) {\\n            int f = find(parent, it.second);\\n            mres[f].push_back(it.first);\\n        }\\n        \\n        // In the previous (mres) map we have our answer but we must give the proper structure\\n        // We add the name of the account (we retieve it from the initial vector since we have\\n        // the number of the group) and we sort the e-mails.\\n        std::vector<std::vector<std::string>> res;\\n        for (auto it : mres) {\\n            std::sort(it.second.begin(), it.second.end());\\n            std::vector<std::string> tmp = {accounts[it.first][0]};\\n            for (auto i : it.second) tmp.push_back(i);\\n            res.push_back(tmp);\\n        }\\n        return res;\\n    }\\n    int find(std::vector<int>& parent, int i) {\\n        if (parent[i] == i) return i;\\n        return parent[i] = find(parent, parent[i]);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\tvector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        std::vector<int> parent(accounts.size(), 0);\\n        std::unordered_map<std::string, int> email_id;\\n        \\n        // We gather all the e-mails and the group in whick thet belong\\n        // We make groups for the case that one e-mail has multiple accounts\\n        for (int i = 0; i < accounts.size(); i++) {\\n            // Initialize the parent vector\\n            parent[i] = i;\\n            for (int j = 1; j < accounts[i].size(); j++) {\\n                // If this e-mail has been found again then union-find in order to \\n                // add under the same group the current e-mail and the already stored\\n                // e-mail\\n                if (email_id.find(accounts[i][j]) != email_id.end()) {\\n                    int f1 = find(parent, i);\\n                    int f2 = find(parent, email_id[accounts[i][j]]);\\n                    // Union\\n                    parent[f1] = f2;\\n                } else {\\n                    // If this e-mail is found for the first time then add it to the map\\n                    email_id[accounts[i][j]] = i;\\n                }\\n            }\\n        }\\n        // We make a new map in order to store for every group the e-mails it contains\\n        std::unordered_map<int, std::vector<std::string>> mres;\\n        for (auto it : email_id) {\\n            int f = find(parent, it.second);\\n            mres[f].push_back(it.first);\\n        }\\n        \\n        // In the previous (mres) map we have our answer but we must give the proper structure\\n        // We add the name of the account (we retieve it from the initial vector since we have\\n        // the number of the group) and we sort the e-mails.\\n        std::vector<std::vector<std::string>> res;\\n        for (auto it : mres) {\\n            std::sort(it.second.begin(), it.second.end());\\n            std::vector<std::string> tmp = {accounts[it.first][0]};\\n            for (auto i : it.second) tmp.push_back(i);\\n            res.push_back(tmp);\\n        }\\n        return res;\\n    }\\n    int find(std::vector<int>& parent, int i) {\\n        if (parent[i] == i) return i;\\n        return parent[i] = find(parent, parent[i]);\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1602535,
                "title": "full-explanation-dry-run-on-first-example-code-with-comments-simple-variables-name-c",
                "content": "#### Full explantion on the first test case, see below,\\n\\nRuntime: 80 ms, faster than 89.44% of C++ online submissions for Accounts Merge.\\nMemory Usage: 34.5 MB, less than 81.24% of C++ online submissions for Accounts Merge.\\n\\n```\\n// if you like this, please give me a upvote\\nclass Solution {\\npublic:\\n    int parents[1001]; // why 1001? becoz it is max length of accounts, see constraints (1 <= accounts.length <= 1000)\\n    \\n    // function to find original parent\\n    int findpar(int parents[], int to_find)\\n    {\\n        while(parents[to_find] != to_find)\\n            to_find = parents[to_find];\\n        \\n        return to_find; \\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        // Link each email to their respective orginal parent, \\n        // we will do it by linking each email to its unique id\\n        unordered_map<string, int> email_to_id;\\n        \\n        for(int i = 0; i < accounts.size(); i++) // traversing from each row\\n        {\\n            parents[i] = i; // intially we don\\'t know anything, so every parent is unique id of itself\\n            \\n            // why we start from 1? becoz emails starting from this place\\n            for(int j = 1; j < accounts[i].size(); j++)\\n            {\\n                // we check if this particular email already got their unique id, if yes then we link it to its original parent unique id\\n                if(email_to_id.find(accounts[i][j]) != email_to_id.end())\\n                {\\n                    int parent1 = findpar(parents, i);\\n                    int parent2 = findpar(parents, email_to_id[accounts[i][j]]);\\n                    \\n                    parents[parent1] = parent2;\\n                }\\n                else // if not find, then just give it to exsiting parent\\n                {\\n                    email_to_id[accounts[i][j]] = parents[i];\\n                }\\n            }\\n        }\\n            \\n            // Now, we create a map that store all email id with their unique ids\\n            //            id,  vector of all emails\\n            unordered_map<int, vector<string>> resultant_map;\\n            \\n            for(auto it: email_to_id)\\n            {\\n                int uniq_id = findpar(parents, it.second); \\n                resultant_map[uniq_id].push_back(it.first);\\n            }\\n            \\n            // uff tired, so now towards final ans\\n            vector<vector<string>> ans;\\n            for(auto it: resultant_map)\\n            {\\n                vector<string> email = it.second;\\n                \\n                // question demand in sorted order\\n                sort(email.begin(), email.end());\\n                \\n                // inserting name in starting with the help of unique id\\n                email.insert(email.begin(), accounts[it.first][0]);\\n                \\n                ans.push_back(email);\\n            }\\n        return ans;\\n    }\\n};\\n```\\n\\nDRY RUN ON FIRST TEST CASE:-\\n![image](https://assets.leetcode.com/users/images/bf2dd8df-ba65-4818-a24f-9bafa1ab9132_1638186268.1506336.jpeg)\\n![image](https://assets.leetcode.com/users/images/ccf921c5-b3e9-4822-908c-a81274847a50_1638186274.019536.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\n// if you like this, please give me a upvote\\nclass Solution {\\npublic:\\n    int parents[1001]; // why 1001? becoz it is max length of accounts, see constraints (1 <= accounts.length <= 1000)\\n    \\n    // function to find original parent\\n    int findpar(int parents[], int to_find)\\n    {\\n        while(parents[to_find] != to_find)\\n            to_find = parents[to_find];\\n        \\n        return to_find; \\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        // Link each email to their respective orginal parent, \\n        // we will do it by linking each email to its unique id\\n        unordered_map<string, int> email_to_id;\\n        \\n        for(int i = 0; i < accounts.size(); i++) // traversing from each row\\n        {\\n            parents[i] = i; // intially we don\\'t know anything, so every parent is unique id of itself\\n            \\n            // why we start from 1? becoz emails starting from this place\\n            for(int j = 1; j < accounts[i].size(); j++)\\n            {\\n                // we check if this particular email already got their unique id, if yes then we link it to its original parent unique id\\n                if(email_to_id.find(accounts[i][j]) != email_to_id.end())\\n                {\\n                    int parent1 = findpar(parents, i);\\n                    int parent2 = findpar(parents, email_to_id[accounts[i][j]]);\\n                    \\n                    parents[parent1] = parent2;\\n                }\\n                else // if not find, then just give it to exsiting parent\\n                {\\n                    email_to_id[accounts[i][j]] = parents[i];\\n                }\\n            }\\n        }\\n            \\n            // Now, we create a map that store all email id with their unique ids\\n            //            id,  vector of all emails\\n            unordered_map<int, vector<string>> resultant_map;\\n            \\n            for(auto it: email_to_id)\\n            {\\n                int uniq_id = findpar(parents, it.second); \\n                resultant_map[uniq_id].push_back(it.first);\\n            }\\n            \\n            // uff tired, so now towards final ans\\n            vector<vector<string>> ans;\\n            for(auto it: resultant_map)\\n            {\\n                vector<string> email = it.second;\\n                \\n                // question demand in sorted order\\n                sort(email.begin(), email.end());\\n                \\n                // inserting name in starting with the help of unique id\\n                email.insert(email.begin(), accounts[it.first][0]);\\n                \\n                ans.push_back(email);\\n            }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109162,
                "title": "summary-for-dfs-templates",
                "content": "The run time of my AC solution is 95 ms which beats 90% cpp solutions. I have met this kind of problem several times, such as [547. Friend Circles](https://leetcode.com/problems/friend-circles/description/) and [737. Sentence Similarity II](https://leetcode.com/problems/sentence-similarity-ii/description/), and you can see my [solution](https://discuss.leetcode.com/topic/112575/real-interview-follow-up-preprocessing-for-multiple-queries) for [737. Sentence Similarity II](https://leetcode.com/problems/sentence-similarity-ii/description/). For this kind of problem, we can use both union-find and DFS algorithms. To make a brief summary, I would like to write a general DFS template, hope it helps.\\n\\nLet us look at this problem, treat each email accounts group (an entity in the given input accounts) as a component, we want to find all connected components among these email accounts. Two components are connected if they have any emails in common. \\n\\nSo the first step is to build a map that can help us to find connected components. For this problem, we should find all components that each email belongs to.\\n```\\n//  build a map that can help us to find connected components. \\n//  treat each entity in accounts as a unique component\\n//  find all component index for each email\\nunordered_map<string, vector<int>> acct;\\nfor (int i = 0; i < n; ++i) {\\n      for (int j = 1; j < accounts[i].size(); ++j) {\\n            acct[accounts[i][j]].push_back(i);\\n      }\\n}\\n```\\n\\nThe second step is to find all emails that in a connected component and generate the output. The idea is simple, we iterate for all component in the input accounts, add all emails into a hash set in case of duplicated emails. At the same time, we need to keep the index of connected components so that we can process the connected components in a DFS manner. To make sure that we just visit each component once, we can use a bool vector to mask the visited component. \\n\\n\\n```\\n//  DFS find all emails in a connected component\\n{       \\n        vector<vector<string>> res;\\n        vector<bool> visited(n, false);\\n        for (int i = 0; i < n; ++i) {\\n            if (visited[i]) continue;    // skip visited component\\n            visited[i] = true;\\n\\n            set<string> emails;\\n            // keep the components index need to visit\\n            vector<int> to_visit{i};    \\n            // find all accounts in a DFS manner\\n            for (int j = 0; j < to_visit.size(); ++j) {\\n                int cur = to_visit[j];\\n                \\n                //  push all email in the current component into emails\\n                emails.insert(accounts[cur].begin() + 1, accounts[cur].end());\\n                \\n                // DFS find all connected components\\n                for (int k = 1; k < accounts[cur].size(); ++k) {\\n                    for (int idx: acct[accounts[cur][k]]) {\\n                        if (visited[idx]) continue;\\n                        visited[idx] = true;\\n                        to_visit.push_back(idx);\\n                    }    \\n                }\\n            }\\n            \\n            //  first save the user name, then save all emails\\n            res.push_back(vector<string> {accounts[i][0]});\\n            auto& r = res.back();\\n            r.insert(r.end(), emails.begin(), emails.end());\\n        }\\n}\\n```\\n\\n\\nSo we can summarize the abstract template as a two-step solution to crack such kind of problem:\\n\\n```\\n//  The first step is to find the connection between connected components.\\n//  In this way, we can visit next component when finishing current component.\\n//  Usually, we can use a map or unordered_map to represent such kind of connection.\\nunordered_map<string, vector<int>> map_connection;\\nfor (int i = 0; i < components.size(); ++i) {\\n      for (int j = 0; j < components[i].size(); ++j) {\\n            //  build connection\\n      }\\n}\\n\\n//  The second step is to merge connected components in a DFS manner.\\n//  To avoid visit any components more than once, we need to remember visited components.\\n//  Usually, this step is a three-layer nested for loop.\\nvector<vector<string>> res;\\nvector<bool> visited(n, false);   // make sure visit each component only once\\n//  first for loop, iterate for each component in the given input\\nfor (int i = 0; i < components.size(); ++i) {\\n    if (visited[i]) continue;   // skip visited component\\n    visited[i] = true;\\n\\n    //  keep the components index need to visit\\n    vector<int> to_visit{i};\\n    \\n    //  save the merged result\\n    set<string> merged_components;\\n\\n    //  second loop, find all connected components in a DFS manner\\n    for (int j = 0; j < to_visit.size(); ++j) {\\n         int cur = to_visit[j];\\n\\n         //   deal with current component\\n         merged_components.insert(components[cur].begin(), components[cur].end());\\n\\n         // thid loop, DFS find all connected components\\n         for (int k = 1; k < accounts[cur].size(); ++k) {\\n              for (int idx: acct[accounts[cur][k]]) {\\n                   if (visited[idx]) continue;   // skip visited component\\n                   visited[idx] = true;\\n                   to_visit.push_back(idx);    //  push into to_visit\\n              }    \\n         }\\n    }\\n}\\n```\\n\\n\\nSolution for [547. Friend Circles](https://leetcode.com/problems/friend-circles/description/):\\n```\\nint findCircleNum(vector<vector<int>>& M) {\\n        int n = M.size();\\n        vector<bool> visited(n, false);\\n        \\n        int cnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            \\n            ++cnt;\\n            vector<int> to_visit{i};\\n            \\n            for (int j = 0; j < to_visit.size(); ++j) {               \\n                int cur = to_visit[j];\\n                for (int k = 0; k < n; ++k) {\\n                    if (visited[k] || M[cur][k] == 0) continue;\\n                    visited[k] = true;\\n                    \\n                    to_visit.push_back(k);\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n//  build a map that can help us to find connected components. \\n//  treat each entity in accounts as a unique component\\n//  find all component index for each email\\nunordered_map<string, vector<int>> acct;\\nfor (int i = 0; i < n; ++i) {\\n      for (int j = 1; j < accounts[i].size(); ++j) {\\n            acct[accounts[i][j]].push_back(i);\\n      }\\n}\\n```\n```\\n//  DFS find all emails in a connected component\\n{       \\n        vector<vector<string>> res;\\n        vector<bool> visited(n, false);\\n        for (int i = 0; i < n; ++i) {\\n            if (visited[i]) continue;    // skip visited component\\n            visited[i] = true;\\n\\n            set<string> emails;\\n            // keep the components index need to visit\\n            vector<int> to_visit{i};    \\n            // find all accounts in a DFS manner\\n            for (int j = 0; j < to_visit.size(); ++j) {\\n                int cur = to_visit[j];\\n                \\n                //  push all email in the current component into emails\\n                emails.insert(accounts[cur].begin() + 1, accounts[cur].end());\\n                \\n                // DFS find all connected components\\n                for (int k = 1; k < accounts[cur].size(); ++k) {\\n                    for (int idx: acct[accounts[cur][k]]) {\\n                        if (visited[idx]) continue;\\n                        visited[idx] = true;\\n                        to_visit.push_back(idx);\\n                    }    \\n                }\\n            }\\n            \\n            //  first save the user name, then save all emails\\n            res.push_back(vector<string> {accounts[i][0]});\\n            auto& r = res.back();\\n            r.insert(r.end(), emails.begin(), emails.end());\\n        }\\n}\\n```\n```\\n//  The first step is to find the connection between connected components.\\n//  In this way, we can visit next component when finishing current component.\\n//  Usually, we can use a map or unordered_map to represent such kind of connection.\\nunordered_map<string, vector<int>> map_connection;\\nfor (int i = 0; i < components.size(); ++i) {\\n      for (int j = 0; j < components[i].size(); ++j) {\\n            //  build connection\\n      }\\n}\\n\\n//  The second step is to merge connected components in a DFS manner.\\n//  To avoid visit any components more than once, we need to remember visited components.\\n//  Usually, this step is a three-layer nested for loop.\\nvector<vector<string>> res;\\nvector<bool> visited(n, false);   // make sure visit each component only once\\n//  first for loop, iterate for each component in the given input\\nfor (int i = 0; i < components.size(); ++i) {\\n    if (visited[i]) continue;   // skip visited component\\n    visited[i] = true;\\n\\n    //  keep the components index need to visit\\n    vector<int> to_visit{i};\\n    \\n    //  save the merged result\\n    set<string> merged_components;\\n\\n    //  second loop, find all connected components in a DFS manner\\n    for (int j = 0; j < to_visit.size(); ++j) {\\n         int cur = to_visit[j];\\n\\n         //   deal with current component\\n         merged_components.insert(components[cur].begin(), components[cur].end());\\n\\n         // thid loop, DFS find all connected components\\n         for (int k = 1; k < accounts[cur].size(); ++k) {\\n              for (int idx: acct[accounts[cur][k]]) {\\n                   if (visited[idx]) continue;   // skip visited component\\n                   visited[idx] = true;\\n                   to_visit.push_back(idx);    //  push into to_visit\\n              }    \\n         }\\n    }\\n}\\n```\n```\\nint findCircleNum(vector<vector<int>>& M) {\\n        int n = M.size();\\n        vector<bool> visited(n, false);\\n        \\n        int cnt = 0;\\n        for (int i = 0; i < n; ++i) {\\n            if (visited[i]) continue;\\n            visited[i] = true;\\n            \\n            ++cnt;\\n            vector<int> to_visit{i};\\n            \\n            for (int j = 0; j < to_visit.size(); ++j) {               \\n                int cur = to_visit[j];\\n                for (int k = 0; k < n; ++k) {\\n                    if (visited[k] || M[cur][k] == 0) continue;\\n                    visited[k] = true;\\n                    \\n                    to_visit.push_back(k);\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109186,
                "title": "python-union-find-with-path-compression-and-building-disjoint-set-on-the-fly",
                "content": "Create two maps for fast query\\n1. ```email_to_id``` - email to the id unique for each email which is also used as the index for our disjoint set\\n2. ```id_to_name - the unique id to name (also means email to name)```\\n\\nFor the disjoint set part, we use the negative values represent the size of the set, when we union two sets we link smaller set to bigger set, this potentially give us a relatively shorter path. However if we call find more frequently this shouldn't matter too much.\\nAlso we are build the data structure on the fly by append id to ds every time we see a new email.  \\n```\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        \\n        def find(a):\\n            if ds[a] < 0:\\n                return a\\n            ds[a] = find(ds[a])\\n            return ds[a]\\n        \\n        def union(a, b):\\n            a, b = find(a), find(b)\\n            if a != b:\\n                if ds[a] < ds[b]:\\n                    ds[a] += ds[b]\\n                    ds[b] = a\\n                else:\\n                    ds[b] += ds[a]\\n                    ds[a] = b\\n\\n        c, ds, email_to_id, id_to_name = 0, [], {}, {}\\n        for account in accounts:\\n            for email in account[1:]:\\n                if email not in email_to_id:\\n                    email_to_id[email] = c\\n                    id_to_name[c] = account[0]\\n                    ds.append(-1)\\n                    c += 1\\n                union(email_to_id[account[1]], email_to_id[email])        \\n                \\n        res = {}\\n        for email, id in email_to_id.items():\\n            master = find(id)\\n            res[master] = res.get(master, []) + [email]\\n        return [[id_to_name[id]] + sorted(emails) for id, emails in res.items()]",
                "solutionTags": [],
                "code": "```email_to_id```\n```id_to_name - the unique id to name (also means email to name)```",
                "codeTag": "Unknown"
            },
            {
                "id": 1601980,
                "title": "java-solution-using-unionfind-beats-99-87-of-submissions",
                "content": "```\\nclass Solution {\\n    class UnionFind {\\n        int[] parent;\\n        int[] weight;\\n        \\n        public UnionFind(int num) {\\n            parent = new int[num];\\n            weight = new int[num];\\n            \\n            for(int i =  0; i < num; i++) {\\n                parent[i] = i;\\n                weight[i] = 1;\\n            }\\n        }\\n        \\n        public void union(int a, int  b) {\\n            int rootA = root(a);\\n            int rootB = root(b);\\n            \\n            if (rootA == rootB) {\\n                return;\\n            }\\n            \\n            if (weight[rootA] > weight[rootB]) {\\n                parent[rootB] = rootA;\\n                weight[rootA] += weight[rootB];\\n            } else {\\n                parent[rootA] = rootB;\\n                weight[rootB] += weight[rootA];\\n            }\\n        }\\n        \\n        public int root(int a) {\\n            if (parent[a] == a) {\\n                return a;\\n            }\\n            \\n            parent[a] = root(parent[a]);\\n            return parent[a];\\n        }\\n    }\\n\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        int size = accounts.size();\\n\\n        UnionFind uf = new UnionFind(size);\\n\\n        // prepare a hash with unique email address as key and index in accouts as value\\n        HashMap<String, Integer> emailToId = new  HashMap<>();\\n        for(int i = 0; i < size; i++) {\\n            List<String> details = accounts.get(i);\\n            for(int j = 1; j < details.size(); j++) {\\n                String email = details.get(j);\\n                \\n\\t\\t\\t\\t// if we have already seen this email before, merge the account  \"i\" with previous account\\n\\t\\t\\t\\t// else add it to hash\\n                if (emailToId.containsKey(email)) {\\n                    uf.union(i, emailToId.get(email));\\n                } else  {\\n                    emailToId.put(email, i);\\n                }\\n            }\\n        }\\n        \\n        // prepare a hash with index in accounts as key and list of unique email address for that account as value\\n        HashMap<Integer, List<String>> idToEmails = new HashMap<>();\\n        for(String key : emailToId.keySet()) {\\n            int root = uf.root(emailToId.get(key));\\n            \\n            if (!idToEmails.containsKey(root)) {\\n                idToEmails.put(root, new ArrayList<String>());\\n            }\\n            \\n            idToEmails.get(root).add(key);\\n        }\\n        \\n        // collect the emails from idToEmails, sort it and add account name at index 0 to get the final list to add to final return List\\n        List<List<String>> mergedDetails =  new ArrayList<>();\\n        for(Integer id : idToEmails.keySet()) {\\n            List<String> emails =  idToEmails.get(id);\\n            Collections.sort(emails);\\n            emails.add(0, accounts.get(id).get(0));\\n            \\n            mergedDetails.add(emails);\\n        }\\n        \\n        return  mergedDetails;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    class UnionFind {\\n        int[] parent;\\n        int[] weight;\\n        \\n        public UnionFind(int num) {\\n            parent = new int[num];\\n            weight = new int[num];\\n            \\n            for(int i =  0; i < num; i++) {\\n                parent[i] = i;\\n                weight[i] = 1;\\n            }\\n        }\\n        \\n        public void union(int a, int  b) {\\n            int rootA = root(a);\\n            int rootB = root(b);\\n            \\n            if (rootA == rootB) {\\n                return;\\n            }\\n            \\n            if (weight[rootA] > weight[rootB]) {\\n                parent[rootB] = rootA;\\n                weight[rootA] += weight[rootB];\\n            } else {\\n                parent[rootA] = rootB;\\n                weight[rootB] += weight[rootA];\\n            }\\n        }\\n        \\n        public int root(int a) {\\n            if (parent[a] == a) {\\n                return a;\\n            }\\n            \\n            parent[a] = root(parent[a]);\\n            return parent[a];\\n        }\\n    }\\n\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        int size = accounts.size();\\n\\n        UnionFind uf = new UnionFind(size);\\n\\n        // prepare a hash with unique email address as key and index in accouts as value\\n        HashMap<String, Integer> emailToId = new  HashMap<>();\\n        for(int i = 0; i < size; i++) {\\n            List<String> details = accounts.get(i);\\n            for(int j = 1; j < details.size(); j++) {\\n                String email = details.get(j);\\n                \\n\\t\\t\\t\\t// if we have already seen this email before, merge the account  \"i\" with previous account\\n\\t\\t\\t\\t// else add it to hash\\n                if (emailToId.containsKey(email)) {\\n                    uf.union(i, emailToId.get(email));\\n                } else  {\\n                    emailToId.put(email, i);\\n                }\\n            }\\n        }\\n        \\n        // prepare a hash with index in accounts as key and list of unique email address for that account as value\\n        HashMap<Integer, List<String>> idToEmails = new HashMap<>();\\n        for(String key : emailToId.keySet()) {\\n            int root = uf.root(emailToId.get(key));\\n            \\n            if (!idToEmails.containsKey(root)) {\\n                idToEmails.put(root, new ArrayList<String>());\\n            }\\n            \\n            idToEmails.get(root).add(key);\\n        }\\n        \\n        // collect the emails from idToEmails, sort it and add account name at index 0 to get the final list to add to final return List\\n        List<List<String>> mergedDetails =  new ArrayList<>();\\n        for(Integer id : idToEmails.keySet()) {\\n            List<String> emails =  idToEmails.get(id);\\n            Collections.sort(emails);\\n            emails.add(0, accounts.get(id).get(0));\\n            \\n            mergedDetails.add(emails);\\n        }\\n        \\n        return  mergedDetails;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1195613,
                "title": "91-dfs-and-bfs-with-explanation-both-iterative-and-recursive-in-python-fast-and-easy",
                "content": "\\n# Method 1.1: using DFS Iterative\\n\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \\n        em_to_name = {}\\n        em_graph = defaultdict(set)\\n        \\n        for acc in accounts:\\n            name = acc[0]\\n            \\n            # making a graph of common connected gmail\\n            # all acc the gamil start with 1 index\\n            for email in acc[1:]:\\n                \\n                # connect 1st to 2nd email\\n                em_graph[acc[1]].add(email)\\n                \\n                #connect 2nd to 1st email\\n                em_graph[email].add(acc[1])\\n                \\n                # create a hashmap\\n                # it help us to find the email owners\\n                em_to_name[email] = name\\n                \\n        # print(em_graph)\\n        # print(em_to_name)\\n    \\n        seen = set()\\n        ans = []\\n        \\n        # here we use loop to traverse all unconnected\\n        # components of the graph\\n        for email in em_graph:\\n            if email not in seen:\\n                seen.add(email)\\n                st = [email]\\n                component = []\\n                \\n                # this loop give us the all conneted path as here\\n                # all common gmail as a list in comonent\\n                while st:\\n                    edge = st.pop()\\n                    component.append(edge)\\n                    for nei in em_graph[edge]:\\n                        if nei not in seen:\\n                            seen.add(nei)\\n                            st.append(nei)\\n                            \\n                # after geting all connect comonent\\n                # we sorted the as question\\n                # and search the owner of the starting email\\n                # append in the ans\\n                ans.append([em_to_name[email]] + sorted(component))\\n        return ans\\n```\\n                    \\n# Method 1.2: using DFS Recursion\\n\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:        \\n        \\n        em_to_name = {}\\n        em_graph = defaultdict(set)\\n        \\n        for acc in accounts:\\n            name = acc[0]\\n            \\n            # making a graph of common connected gmail\\n            # all acc the gamil start with 1 index\\n            for email in acc[1:]:\\n                \\n                # connect 1st to 2nd email\\n                em_graph[acc[1]].add(email)\\n                \\n                #connect 2nd to 1st email\\n                em_graph[email].add(acc[1])\\n                \\n                # create a hashmap\\n                # it help us to find the email owners\\n                em_to_name[email] = name\\n                \\n        # print(em_graph)\\n        # print(em_to_name)\\n    \\n        seen = set()\\n        ans = []\\n        \\n        # dfs function\\n        def dfs(s,comp):\\n            if s in seen:\\n                return\\n            seen.add(s)\\n            comp.append(s)\\n            for nei in em_graph[s]:\\n                if nei not in seen:\\n                    dfs(nei,comp)    \\n            return comp  \\n        \\n        # here we use loop to traverse all unconnected\\n        # components of the graph\\n        for email in em_graph:\\n            if email not in seen:\\n                component = []\\n                dfs(email, component)\\n                ans.append([em_to_name[email]] + sorted(component))\\n                \\n        return ans      \\n```     \\n# Method 2: using BFS\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \\n        em_to_name = {}\\n        em_graph = defaultdict(set)\\n        \\n        for acc in accounts:\\n            name = acc[0]\\n            \\n            # making a graph of common connected gmail\\n            # all acc the gamil start with 1 index\\n            for email in acc[1:]:\\n                \\n                # connect 1st to 2nd email\\n                em_graph[acc[1]].add(email)\\n                \\n                #connect 2nd to 1st email\\n                em_graph[email].add(acc[1])\\n                \\n                # create a hashmap\\n                # it help us to find the email owners\\n                em_to_name[email] = name\\n                \\n        # print(em_graph)\\n        # print(em_to_name)\\n    \\n        seen = set()\\n        ans = []\\n        \\n        # here we use loop to traverse all unconnected\\n        # components of the graph\\n        for email in em_graph:\\n            if email not in seen:\\n                seen.add(email)\\n                 q = [email]\\n                component = []\\n                \\n                # this loop give us the all conneted path as here\\n                # all common gmail as a list in comonent\\n                while q:\\n                    edge = q.pop(0)\\n                    component.append(edge)\\n                    for nei in em_graph[edge]:\\n                        if nei not in seen:\\n                            seen.add(nei)\\n                           q.append(nei)\\n                            \\n                # after geting all connect comonent\\n                # we sorted the as question\\n                # and search the owner of the starting email\\n                # append in the ans\\n                ans.append([em_to_name[email]] + sorted(component))\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \\n        em_to_name = {}\\n        em_graph = defaultdict(set)\\n        \\n        for acc in accounts:\\n            name = acc[0]\\n            \\n            # making a graph of common connected gmail\\n            # all acc the gamil start with 1 index\\n            for email in acc[1:]:\\n                \\n                # connect 1st to 2nd email\\n                em_graph[acc[1]].add(email)\\n                \\n                #connect 2nd to 1st email\\n                em_graph[email].add(acc[1])\\n                \\n                # create a hashmap\\n                # it help us to find the email owners\\n                em_to_name[email] = name\\n                \\n        # print(em_graph)\\n        # print(em_to_name)\\n    \\n        seen = set()\\n        ans = []\\n        \\n        # here we use loop to traverse all unconnected\\n        # components of the graph\\n        for email in em_graph:\\n            if email not in seen:\\n                seen.add(email)\\n                st = [email]\\n                component = []\\n                \\n                # this loop give us the all conneted path as here\\n                # all common gmail as a list in comonent\\n                while st:\\n                    edge = st.pop()\\n                    component.append(edge)\\n                    for nei in em_graph[edge]:\\n                        if nei not in seen:\\n                            seen.add(nei)\\n                            st.append(nei)\\n                            \\n                # after geting all connect comonent\\n                # we sorted the as question\\n                # and search the owner of the starting email\\n                # append in the ans\\n                ans.append([em_to_name[email]] + sorted(component))\\n        return ans\\n```\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:        \\n        \\n        em_to_name = {}\\n        em_graph = defaultdict(set)\\n        \\n        for acc in accounts:\\n            name = acc[0]\\n            \\n            # making a graph of common connected gmail\\n            # all acc the gamil start with 1 index\\n            for email in acc[1:]:\\n                \\n                # connect 1st to 2nd email\\n                em_graph[acc[1]].add(email)\\n                \\n                #connect 2nd to 1st email\\n                em_graph[email].add(acc[1])\\n                \\n                # create a hashmap\\n                # it help us to find the email owners\\n                em_to_name[email] = name\\n                \\n        # print(em_graph)\\n        # print(em_to_name)\\n    \\n        seen = set()\\n        ans = []\\n        \\n        # dfs function\\n        def dfs(s,comp):\\n            if s in seen:\\n                return\\n            seen.add(s)\\n            comp.append(s)\\n            for nei in em_graph[s]:\\n                if nei not in seen:\\n                    dfs(nei,comp)    \\n            return comp  \\n        \\n        # here we use loop to traverse all unconnected\\n        # components of the graph\\n        for email in em_graph:\\n            if email not in seen:\\n                component = []\\n                dfs(email, component)\\n                ans.append([em_to_name[email]] + sorted(component))\\n                \\n        return ans      \\n```\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \\n        em_to_name = {}\\n        em_graph = defaultdict(set)\\n        \\n        for acc in accounts:\\n            name = acc[0]\\n            \\n            # making a graph of common connected gmail\\n            # all acc the gamil start with 1 index\\n            for email in acc[1:]:\\n                \\n                # connect 1st to 2nd email\\n                em_graph[acc[1]].add(email)\\n                \\n                #connect 2nd to 1st email\\n                em_graph[email].add(acc[1])\\n                \\n                # create a hashmap\\n                # it help us to find the email owners\\n                em_to_name[email] = name\\n                \\n        # print(em_graph)\\n        # print(em_to_name)\\n    \\n        seen = set()\\n        ans = []\\n        \\n        # here we use loop to traverse all unconnected\\n        # components of the graph\\n        for email in em_graph:\\n            if email not in seen:\\n                seen.add(email)\\n                 q = [email]\\n                component = []\\n                \\n                # this loop give us the all conneted path as here\\n                # all common gmail as a list in comonent\\n                while q:\\n                    edge = q.pop(0)\\n                    component.append(edge)\\n                    for nei in em_graph[edge]:\\n                        if nei not in seen:\\n                            seen.add(nei)\\n                           q.append(nei)\\n                            \\n                # after geting all connect comonent\\n                # we sorted the as question\\n                # and search the owner of the starting email\\n                # append in the ans\\n                ans.append([em_to_name[email]] + sorted(component))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881977,
                "title": "python-union-find-clean-code",
                "content": "**Basic Union-Find Implementation:** https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/discuss/516491/Java-Union-Find-DFS-BFS-Solutions-Complexity-Explain-Clean-code\\n\\n**Python**\\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, x):\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x]) # Path compression\\n        return self.parent[x]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False  # Return False if u and v are already union\\n        if self.size[pu] > self.size[pv]: # Union by larger size\\n            self.size[pu] += self.size[pv]\\n            self.parent[pv] = pu\\n        else:\\n            self.size[pv] += self.size[pu]\\n            self.parent[pu] = pv\\n        return True\\n\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        uf = UnionFind(10000)\\n        \\n        map_email_id = {}\\n        map_id_email = {}\\n        map_email_name = {}\\n        id = 0\\n        for acc in accounts:\\n            name = acc[0]\\n            for email in acc[1:]:\\n                map_email_name[email] = name\\n                if email not in map_email_id:\\n                    map_email_id[email] = id\\n                    map_id_email[id] = email\\n                    id += 1\\n                uf.union(map_email_id[acc[1]], map_email_id[email]) # union 1st email and ith emails -> union emails in same account together\\n        \\n        merged_emails = defaultdict(set)\\n        for _id in range(id):\\n            merged_emails[uf.find(_id)].add(map_id_email[_id])\\n            \\n        ans = []\\n        for (_id, emails) in merged_emails.items():\\n            name = map_email_name[map_id_email[_id]]\\n            ans.append([name] + list(sorted(emails)))\\n        return ans\\n```\\n\\n**Complexity**\\n- Time: `O(S * \\u03B1(S)) ~ O(S)`, where `S` is sum of all emails of accounts\\n- Space: `O(S)`",
                "solutionTags": [],
                "code": "```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, x):\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x]) # Path compression\\n        return self.parent[x]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False  # Return False if u and v are already union\\n        if self.size[pu] > self.size[pv]: # Union by larger size\\n            self.size[pu] += self.size[pv]\\n            self.parent[pv] = pu\\n        else:\\n            self.size[pv] += self.size[pu]\\n            self.parent[pu] = pv\\n        return True\\n\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        uf = UnionFind(10000)\\n        \\n        map_email_id = {}\\n        map_id_email = {}\\n        map_email_name = {}\\n        id = 0\\n        for acc in accounts:\\n            name = acc[0]\\n            for email in acc[1:]:\\n                map_email_name[email] = name\\n                if email not in map_email_id:\\n                    map_email_id[email] = id\\n                    map_id_email[id] = email\\n                    id += 1\\n                uf.union(map_email_id[acc[1]], map_email_id[email]) # union 1st email and ith emails -> union emails in same account together\\n        \\n        merged_emails = defaultdict(set)\\n        for _id in range(id):\\n            merged_emails[uf.find(_id)].add(map_id_email[_id])\\n            \\n        ans = []\\n        for (_id, emails) in merged_emails.items():\\n            name = map_email_name[map_id_email[_id]]\\n            ans.append([name] + list(sorted(emails)))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109191,
                "title": "why-c-internal-string-sort-is-different-from-java-s",
                "content": " For c# program,        \\n List<string> test = new List<string>();\\n test.Add(\"john00@mail.com\");\\n test.Add(\"john_newyork@mail.com\");\\n Console.WriteLine(test[0]);\\n Console.WriteLine(test[1]);\\n\\n /*here generate\\n john00@mail.com\\n john_newyork@mail.com\\n*/\\n\\n\\n test.Sort();     \\n Console.WriteLine(test[0]);\\n Console.WriteLine(test[1]);\\n\\n/*here generate\\njohn_newyork@mail.com\\njohn00@mail.com\\n*/\\n\\nSo what is the standard \"sorted order\" for emails?",
                "solutionTags": [],
                "code": " For c# program,        \\n List<string> test = new List<string>();\\n test.Add(\"john00@mail.com\");\\n test.Add(\"john_newyork@mail.com\");\\n Console.WriteLine(test[0]);\\n Console.WriteLine(test[1]);\\n\\n /*here generate\\n john00@mail.com\\n john_newyork@mail.com\\n*/\\n\\n\\n test.Sort();     \\n Console.WriteLine(test[0]);\\n Console.WriteLine(test[1]);\\n\\n/*here generate\\njohn_newyork@mail.com\\njohn00@mail.com\\n*/\\n\\nSo what is the standard \"sorted order\" for emails?",
                "codeTag": "Unknown"
            },
            {
                "id": 1492945,
                "title": "java-tc-o-nlogn-sc-o-n-unionfind-union-by-rank-path-compression",
                "content": "```\\n/**\\n * Using union-find (Union by rank and path compression) to group all emails\\n * belonging to same owner. And using TreeSet to sort each group of emails.\\n *\\n * Time Complexity: O(N + N * log(N) + N) = O(N * log(N))\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Total number of email addresses in the input. Here assuming the length of\\n * each email and owner string is a fixed constant.\\n */\\n\\nclass Solution {\\n    private class Node {\\n        String parent;\\n        String owner;\\n        int rank;\\n\\n        public Node(String owner, String parent, int rank) {\\n            this.owner = owner;\\n            this.parent = parent;\\n            this.rank = rank;\\n        }\\n    }\\n\\n    // Union by Rank and Path Compression\\n    private class AccountMergeUnionFind {\\n        private Map<String, Node> emailToNode;\\n\\n        public AccountMergeUnionFind() {\\n            this.emailToNode = new HashMap<>();\\n        }\\n\\n        public void addEmail(String owner, String email) {\\n            if (!emailToNode.containsKey(email)) {\\n                emailToNode.put(email, new Node(owner, email, 0));\\n            }\\n        }\\n\\n        public String findParent(String email) {\\n            Node curNode = emailToNode.get(email);\\n            if (!email.equals(curNode.parent)) {\\n                curNode.parent = findParent(curNode.parent);\\n            }\\n            return curNode.parent;\\n        }\\n\\n        public void union(String email1, String email2) {\\n            String parent1 = findParent(email1);\\n            String parent2 = findParent(email2);\\n\\n            if (parent1.equals(parent2)) {\\n                return;\\n            }\\n\\n            Node node1 = emailToNode.get(parent1);\\n            Node node2 = emailToNode.get(parent2);\\n\\n            if (node1.rank >= node2.rank) {\\n                node2.parent = parent1;\\n                if (node1.rank == node2.rank) {\\n                    node1.rank++;\\n                }\\n            } else {\\n                node1.parent = parent2;\\n            }\\n        }\\n\\n        public String getOwner(String email) {\\n            return emailToNode.get(email).owner;\\n        }\\n    }\\n\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        if (accounts == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n        if (accounts.size() == 0) {\\n            return new ArrayList<>();\\n        }\\n\\n        AccountMergeUnionFind uf = new AccountMergeUnionFind();\\n\\n        // Populating UnionFind with all emails.\\n        for (List<String> account : accounts) {\\n            if (account.size() <= 1) {\\n                continue;\\n            }\\n            String owner = account.get(0);\\n            uf.addEmail(owner, account.get(1));\\n\\n            for (int i = 2; i < account.size(); i++) {\\n                uf.addEmail(owner, account.get(i));\\n                uf.union(account.get(1), account.get(i));\\n            }\\n        }\\n\\n        // Creating merged Groups with sorted emails\\n        Map<String, TreeSet<String>> groups = new HashMap<>();\\n        for (List<String> account : accounts) {\\n            if (account.size() <= 1) {\\n                continue;\\n            }\\n            String parent = uf.findParent(account.get(1));\\n            if (!groups.containsKey(parent)) {\\n                groups.put(parent, new TreeSet<>());\\n            }\\n            TreeSet<String> curGroup = groups.get(parent);\\n            for (int i = 1; i < account.size(); i++) {\\n                curGroup.add(account.get(i));\\n            }\\n        }\\n\\n        // Creating final result list\\n        List<List<String>> result = new ArrayList<>();\\n        for (Map.Entry<String, TreeSet<String>> group : groups.entrySet()) {\\n            List<String> account = new ArrayList<>();\\n            account.add(uf.getOwner(group.getKey()));\\n            account.addAll(group.getValue());\\n            result.add(account);\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Tree",
                    "Union Find",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * Using union-find (Union by rank and path compression) to group all emails\\n * belonging to same owner. And using TreeSet to sort each group of emails.\\n *\\n * Time Complexity: O(N + N * log(N) + N) = O(N * log(N))\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Total number of email addresses in the input. Here assuming the length of\\n * each email and owner string is a fixed constant.\\n */\\n\\nclass Solution {\\n    private class Node {\\n        String parent;\\n        String owner;\\n        int rank;\\n\\n        public Node(String owner, String parent, int rank) {\\n            this.owner = owner;\\n            this.parent = parent;\\n            this.rank = rank;\\n        }\\n    }\\n\\n    // Union by Rank and Path Compression\\n    private class AccountMergeUnionFind {\\n        private Map<String, Node> emailToNode;\\n\\n        public AccountMergeUnionFind() {\\n            this.emailToNode = new HashMap<>();\\n        }\\n\\n        public void addEmail(String owner, String email) {\\n            if (!emailToNode.containsKey(email)) {\\n                emailToNode.put(email, new Node(owner, email, 0));\\n            }\\n        }\\n\\n        public String findParent(String email) {\\n            Node curNode = emailToNode.get(email);\\n            if (!email.equals(curNode.parent)) {\\n                curNode.parent = findParent(curNode.parent);\\n            }\\n            return curNode.parent;\\n        }\\n\\n        public void union(String email1, String email2) {\\n            String parent1 = findParent(email1);\\n            String parent2 = findParent(email2);\\n\\n            if (parent1.equals(parent2)) {\\n                return;\\n            }\\n\\n            Node node1 = emailToNode.get(parent1);\\n            Node node2 = emailToNode.get(parent2);\\n\\n            if (node1.rank >= node2.rank) {\\n                node2.parent = parent1;\\n                if (node1.rank == node2.rank) {\\n                    node1.rank++;\\n                }\\n            } else {\\n                node1.parent = parent2;\\n            }\\n        }\\n\\n        public String getOwner(String email) {\\n            return emailToNode.get(email).owner;\\n        }\\n    }\\n\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        if (accounts == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n        if (accounts.size() == 0) {\\n            return new ArrayList<>();\\n        }\\n\\n        AccountMergeUnionFind uf = new AccountMergeUnionFind();\\n\\n        // Populating UnionFind with all emails.\\n        for (List<String> account : accounts) {\\n            if (account.size() <= 1) {\\n                continue;\\n            }\\n            String owner = account.get(0);\\n            uf.addEmail(owner, account.get(1));\\n\\n            for (int i = 2; i < account.size(); i++) {\\n                uf.addEmail(owner, account.get(i));\\n                uf.union(account.get(1), account.get(i));\\n            }\\n        }\\n\\n        // Creating merged Groups with sorted emails\\n        Map<String, TreeSet<String>> groups = new HashMap<>();\\n        for (List<String> account : accounts) {\\n            if (account.size() <= 1) {\\n                continue;\\n            }\\n            String parent = uf.findParent(account.get(1));\\n            if (!groups.containsKey(parent)) {\\n                groups.put(parent, new TreeSet<>());\\n            }\\n            TreeSet<String> curGroup = groups.get(parent);\\n            for (int i = 1; i < account.size(); i++) {\\n                curGroup.add(account.get(i));\\n            }\\n        }\\n\\n        // Creating final result list\\n        List<List<String>> result = new ArrayList<>();\\n        for (Map.Entry<String, TreeSet<String>> group : groups.entrySet()) {\\n            List<String> account = new ArrayList<>();\\n            account.add(uf.getOwner(group.getKey()));\\n            account.addAll(group.getValue());\\n            result.add(account);\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892756,
                "title": "javascript-union-find-solution",
                "content": "```javascript\\nvar accountsMerge = function (accounts) {\\n    const parents = {};\\n    const email2name = {};\\n\\n    const find = (x) => {\\n        if (parents[x] !== x) {\\n            parents[x] = find(parents[x]);\\n        }\\n\\n        return parents[x];\\n    };\\n\\n    const union = (x, y) => {\\n        parents[find(x)] = find(y);\\n    };\\n\\n    for (const [name, ...emails] of accounts) {\\n        for (const email of emails) {\\n            if (!parents[email]) {\\n                parents[email] = email;\\n            }\\n\\n            email2name[email] = name;\\n            union(email, emails[0]);\\n        }\\n    }\\n\\n    const emails = {};\\n    for (const email of Object.keys(parents)) {\\n        const parent = find(email);\\n        if (parent in emails) {\\n            emails[parent].push(email);\\n        } else {\\n            emails[parent] = [email];\\n        }\\n    }\\n\\n    return Object.entries(emails).map(([email, x]) => [email2name[email], ...x.sort()]);\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```javascript\\nvar accountsMerge = function (accounts) {\\n    const parents = {};\\n    const email2name = {};\\n\\n    const find = (x) => {\\n        if (parents[x] !== x) {\\n            parents[x] = find(parents[x]);\\n        }\\n\\n        return parents[x];\\n    };\\n\\n    const union = (x, y) => {\\n        parents[find(x)] = find(y);\\n    };\\n\\n    for (const [name, ...emails] of accounts) {\\n        for (const email of emails) {\\n            if (!parents[email]) {\\n                parents[email] = email;\\n            }\\n\\n            email2name[email] = name;\\n            union(email, emails[0]);\\n        }\\n    }\\n\\n    const emails = {};\\n    for (const email of Object.keys(parents)) {\\n        const parent = find(email);\\n        if (parent in emails) {\\n            emails[parent].push(email);\\n        } else {\\n            emails[parent] = [email];\\n        }\\n    }\\n\\n    return Object.entries(emails).map(([email, x]) => [email2name[email], ...x.sort()]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 175269,
                "title": "my-python-dfs-and-union-find-solutions-beats-98-7-and-100",
                "content": "DFS:\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        d = {}  # key:val = email:index\\n        from collections import defaultdict\\n        graph = defaultdict(list)   # graph connecting the indices of the same account\\n        for i, a in enumerate(accounts):\\n            for email in a[1:]:\\n                if email in d:\\n                    graph[i].append(d[email])\\n                    graph[d[email]].append(i)\\n                else:\\n                    d[email] = i\\n        \\n        # dfs, return indices belong to the same account\\n        def dfs(i):\\n            tmp = {i}\\n            for j in graph[i]:\\n                if j not in seen:\\n                    seen.add(j)\\n                    tmp |= dfs(j)\\n            return tmp\\n                    \\n        seen = set()\\n        res = [] \\n        for i in range(len(accounts)):\\n            if i in seen:\\n                continue\\n            res.append([accounts[i][0]] + sorted(set(email for j in dfs(i) for email in accounts[j][1:])))\\n        \\n        return res\\n```\\nUnion Find:\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        # find root\\n        def findroot(i):\\n            while root[i] != i:\\n                root[i] = root[root[i]]     # path compression\\n                i = root[i]\\n            return i\\n        \\n        # union find\\n        d = {}  # key:val = email:index\\n        root = list(range(len(accounts)))   \\n        for i, a in enumerate(accounts):\\n            for email in a[1:]:\\n                if email in d:\\n                    r1, r2 = findroot(i), findroot(d[email])\\n                    root[r2] = r1\\n                else:\\n                    d[email] = i\\n                    \\n        # merge accounts      \\n        from collections import defaultdict\\n        res0 = defaultdict(set)     # key:val = index: {set of emails}\\n        for i in range(len(accounts)):\\n            res0[findroot(i)] |= set(accounts[i][1:])\\n        \\n        # convert into required format\\n        res = []\\n        for k, v in res0.items():    \\n            res.append([accounts[k][0]] + sorted(v))\\n        \\n        return res\\n```\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        d = {}  # key:val = email:index\\n        from collections import defaultdict\\n        graph = defaultdict(list)   # graph connecting the indices of the same account\\n        for i, a in enumerate(accounts):\\n            for email in a[1:]:\\n                if email in d:\\n                    graph[i].append(d[email])\\n                    graph[d[email]].append(i)\\n                else:\\n                    d[email] = i\\n        \\n        # dfs, return indices belong to the same account\\n        def dfs(i):\\n            tmp = {i}\\n            for j in graph[i]:\\n                if j not in seen:\\n                    seen.add(j)\\n                    tmp |= dfs(j)\\n            return tmp\\n                    \\n        seen = set()\\n        res = [] \\n        for i in range(len(accounts)):\\n            if i in seen:\\n                continue\\n            res.append([accounts[i][0]] + sorted(set(email for j in dfs(i) for email in accounts[j][1:])))\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        # find root\\n        def findroot(i):\\n            while root[i] != i:\\n                root[i] = root[root[i]]     # path compression\\n                i = root[i]\\n            return i\\n        \\n        # union find\\n        d = {}  # key:val = email:index\\n        root = list(range(len(accounts)))   \\n        for i, a in enumerate(accounts):\\n            for email in a[1:]:\\n                if email in d:\\n                    r1, r2 = findroot(i), findroot(d[email])\\n                    root[r2] = r1\\n                else:\\n                    d[email] = i\\n                    \\n        # merge accounts      \\n        from collections import defaultdict\\n        res0 = defaultdict(set)     # key:val = index: {set of emails}\\n        for i in range(len(accounts)):\\n            res0[findroot(i)] |= set(accounts[i][1:])\\n        \\n        # convert into required format\\n        res = []\\n        for k, v in res0.items():    \\n            res.append([accounts[k][0]] + sorted(v))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602097,
                "title": "c-simple-dfs-solution-with-comments",
                "content": "## Approach\\n\\nThe task here is pretty much straight forward. We\\'ll be representing our accounts vector as a graph. For any two elements which can be merged , we draw an edge between them. Finally, we just iterate over the graph and for each connected component, we\\'ll merge them\\n\\n## Code\\n\\n```\\n//function to check if two vectors share a common e-mail\\nbool haveCommon(vector<string> &a,vector<string> &b)\\n    {\\n\\t//if their names are not same, they cann\\'t be merged\\n        if(a[0] != b[0]) return false;\\n        for(auto &ele : b)\\n        {\\n\\t\\t\\t//excluding the check for name\\n            if(ele == b[0]) continue;\\n            for(auto &cand : a) \\n            {\\n\\t\\t\\t// if we found a common mail, return true\\n                if(cand == ele) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n\\t// just normal DFS\\n    void dfs(vector<int> adj[],int node,vector<int> &con,bool *vis)\\n    {\\n        vis[node] = 1;\\n        con.push_back(node);\\n        for(auto &child : adj[node])\\n        {\\n            if(!vis[child]) dfs(adj,child,con,vis);\\n        }\\n    }\\n    \\n\\t//function to merge all the elements of connected components\\n\\t//and append the merged vector to our result\\n    void merge(vector<int> &con,vector<vector<string>> &res,vector<vector<string>> &acc)\\n    {\\n        vector<string> arr(1);\\n\\t\\t//pushing the name\\n        arr[0] = acc[con[0]][0];\\n\\t\\t\\n\\t\\t//here we use a set as we want all the merged mails to be unique and in sorted order\\n        set<string> st;\\n\\t\\t\\n\\t\\t//put all the elements of the connected component\\'s indices in the set\\n        for(auto &idx : con)\\n        {\\n\\t\\t\\t//we skipped 0 as we have already added the name in out arr vector before \\n            for(int i=1;i<acc[idx].size();i++)\\n                st.insert(acc[idx][i]);\\n        }\\n        \\n\\t\\t//put all the elements of set in arr\\n        for(auto &ele : st) arr.push_back(ele);\\n\\t\\t\\n\\t\\t//push arr in res \\n        res.push_back(arr);\\n    }\\n\\t\\n\\tvector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n\\t//initialize an adjacency list with indices as vertices\\n        vector<int> adj[accounts.size()];\\n        \\n        for(int i=0;i<accounts.size();i++)\\n        {\\n            for(int j=i+1;j<accounts.size();j++)\\n            {\\n\\t\\t\\t//here we check if accounts[i] can be merged with accounts[j]\\n                bool check = haveCommon(accounts[i],accounts[j]);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if it is we\\'ll add a bi-directional edge\\n                if(check) \\n                {\\n                    adj[i].push_back(j);\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n\\t\\t//vector to store our ans and visited array\\n        vector<vector<string>> res;\\n        bool vis[accounts.size()];\\n        memset(vis,false,sizeof(vis));\\n\\t\\t\\n        // int cnt = 0;\\n\\t\\t\\n\\t\\t//we\\'ll traverse using dfs and find connected components\\n\\t\\t//in order to merge them\\n        for(int i=0;i<accounts.size();i++)\\n        {\\n\\t\\t//vector to store all the indices of connected components\\n\\t\\t// i.e., components which can be merged\\n            vector<int> con;\\n            if(!vis[i])\\n            {\\n\\t\\t\\t//do dfs to find all the connected components\\n                dfs(adj,i,con,vis);\\n                merge(con,res,accounts);\\n            }\\n        }\\n        \\n        \\n        //returning the ans\\n        return res;\\n    }\\n```\\n\\nI will add the Union Find solution soon.",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\n//function to check if two vectors share a common e-mail\\nbool haveCommon(vector<string> &a,vector<string> &b)\\n    {\\n\\t//if their names are not same, they cann\\'t be merged\\n        if(a[0] != b[0]) return false;\\n        for(auto &ele : b)\\n        {\\n\\t\\t\\t//excluding the check for name\\n            if(ele == b[0]) continue;\\n            for(auto &cand : a) \\n            {\\n\\t\\t\\t// if we found a common mail, return true\\n                if(cand == ele) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n\\t// just normal DFS\\n    void dfs(vector<int> adj[],int node,vector<int> &con,bool *vis)\\n    {\\n        vis[node] = 1;\\n        con.push_back(node);\\n        for(auto &child : adj[node])\\n        {\\n            if(!vis[child]) dfs(adj,child,con,vis);\\n        }\\n    }\\n    \\n\\t//function to merge all the elements of connected components\\n\\t//and append the merged vector to our result\\n    void merge(vector<int> &con,vector<vector<string>> &res,vector<vector<string>> &acc)\\n    {\\n        vector<string> arr(1);\\n\\t\\t//pushing the name\\n        arr[0] = acc[con[0]][0];\\n\\t\\t\\n\\t\\t//here we use a set as we want all the merged mails to be unique and in sorted order\\n        set<string> st;\\n\\t\\t\\n\\t\\t//put all the elements of the connected component\\'s indices in the set\\n        for(auto &idx : con)\\n        {\\n\\t\\t\\t//we skipped 0 as we have already added the name in out arr vector before \\n            for(int i=1;i<acc[idx].size();i++)\\n                st.insert(acc[idx][i]);\\n        }\\n        \\n\\t\\t//put all the elements of set in arr\\n        for(auto &ele : st) arr.push_back(ele);\\n\\t\\t\\n\\t\\t//push arr in res \\n        res.push_back(arr);\\n    }\\n\\t\\n\\tvector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n\\t//initialize an adjacency list with indices as vertices\\n        vector<int> adj[accounts.size()];\\n        \\n        for(int i=0;i<accounts.size();i++)\\n        {\\n            for(int j=i+1;j<accounts.size();j++)\\n            {\\n\\t\\t\\t//here we check if accounts[i] can be merged with accounts[j]\\n                bool check = haveCommon(accounts[i],accounts[j]);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if it is we\\'ll add a bi-directional edge\\n                if(check) \\n                {\\n                    adj[i].push_back(j);\\n                    adj[j].push_back(i);\\n                }\\n            }\\n        }\\n        \\n\\t\\t//vector to store our ans and visited array\\n        vector<vector<string>> res;\\n        bool vis[accounts.size()];\\n        memset(vis,false,sizeof(vis));\\n\\t\\t\\n        // int cnt = 0;\\n\\t\\t\\n\\t\\t//we\\'ll traverse using dfs and find connected components\\n\\t\\t//in order to merge them\\n        for(int i=0;i<accounts.size();i++)\\n        {\\n\\t\\t//vector to store all the indices of connected components\\n\\t\\t// i.e., components which can be merged\\n            vector<int> con;\\n            if(!vis[i])\\n            {\\n\\t\\t\\t//do dfs to find all the connected components\\n                dfs(adj,i,con,vis);\\n                merge(con,res,accounts);\\n            }\\n        }\\n        \\n        \\n        //returning the ans\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 609431,
                "title": "c-union-find-with-explanation",
                "content": "1. We first create n (size of accounts) groups, one for each account.\\n\\tIn the beginning each group points to itself.\\n2. Create a email to groups mapping \\'emailToGroup\\' as described below:\\n\\tFor each emails in account[i] ( group => i ):\\n\\t2.1 If email is not present in emailToGroup then add  ( email, i ) to  emailToGroup.\\n\\t2.2 If email is present then merge group \\'i\\' and group \\'emailToGroup[email]\\'.\\n```              \\n                   // Union\\n                    int root1 = find( parent, i );\\n                    int root2 = find( parent, emailToGroup[email] );\\n                    parent[ root1 ] = root2;\\n```\\n3. Create a reverse map of group to email.\\n\\t\\n```\\nclass Solution {\\n    int find( vector<int>& parent, int i ) {\\n        while( parent[i] != i )\\n            i = parent[i];\\n        return i;\\n    }\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        vector<int> parent(n); // groups 0 ... n-1\\n        unordered_map< string, int > emailToGroup; // email -> group\\n    \\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i; // init parent\\n            for( int j=1; j < accounts[i].size(); j++ ) {\\n                string email = accounts[i][j];\\n                if( emailToGroup.find( email ) != emailToGroup.end() ) {\\n                    // Union\\n                    int root1 = find( parent, i );\\n                    int root2 = find( parent, emailToGroup[email] );\\n                    parent[ root1 ] = root2;\\n                } else {\\n                    emailToGroup[ email ] = i;\\n                }\\n            }\\n        }\\n    \\n        unordered_map<int, vector<string>> groupToEmail;\\n        for( auto it : emailToGroup ) {\\n            int root = find( parent, it.second );\\n            groupToEmail[root].push_back( it.first );\\n        }\\n        \\n        // create result\\n        vector<vector<std::string>> res;\\n        for( auto it : groupToEmail ) {\\n            sort( it.second.begin(), it.second.end() );\\n            vector<string> tmp = { accounts[it.first][0] };\\n            tmp.insert( tmp.end(), it.second.begin(), it.second.end() );\\n            res.push_back( tmp );\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```              \\n                   // Union\\n                    int root1 = find( parent, i );\\n                    int root2 = find( parent, emailToGroup[email] );\\n                    parent[ root1 ] = root2;\\n```\n```\\nclass Solution {\\n    int find( vector<int>& parent, int i ) {\\n        while( parent[i] != i )\\n            i = parent[i];\\n        return i;\\n    }\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        vector<int> parent(n); // groups 0 ... n-1\\n        unordered_map< string, int > emailToGroup; // email -> group\\n    \\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i; // init parent\\n            for( int j=1; j < accounts[i].size(); j++ ) {\\n                string email = accounts[i][j];\\n                if( emailToGroup.find( email ) != emailToGroup.end() ) {\\n                    // Union\\n                    int root1 = find( parent, i );\\n                    int root2 = find( parent, emailToGroup[email] );\\n                    parent[ root1 ] = root2;\\n                } else {\\n                    emailToGroup[ email ] = i;\\n                }\\n            }\\n        }\\n    \\n        unordered_map<int, vector<string>> groupToEmail;\\n        for( auto it : emailToGroup ) {\\n            int root = find( parent, it.second );\\n            groupToEmail[root].push_back( it.first );\\n        }\\n        \\n        // create result\\n        vector<vector<std::string>> res;\\n        for( auto it : groupToEmail ) {\\n            sort( it.second.begin(), it.second.end() );\\n            vector<string> tmp = { accounts[it.first][0] };\\n            tmp.insert( tmp.end(), it.second.begin(), it.second.end() );\\n            res.push_back( tmp );\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599721,
                "title": "c-solution-graph-dfs",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_map<string, vector<string>> graph;\\n    unordered_set<string> visited;\\n    unordered_map<string,string> email_to_name;\\n\\n    void buildGraph(vector<vector<string>>& accounts) {\\n        for(int i = 0; i < accounts.size(); ++i) {\\n            string name = accounts[i][0];\\n            string first_email = accounts[i][1];\\n            \\n            for(int j = 1; j < accounts[i].size(); ++j) {\\n                string email = accounts[i][j];\\n                graph[first_email].push_back(email);\\n                graph[email].push_back(first_email);\\n                if(!email_to_name.count(email) ) {\\n                    email_to_name[email] = name;\\n                }\\n            }\\n        }\\n        \\n    }\\n    void dfs(string email, set<string> &email_set) {\\n        if(visited.count(email)) {\\n            return;\\n        }\\n        visited.insert(email);\\n        email_set.insert(email);\\n        for(auto email : graph[email]) {\\n            dfs(email, email_set);\\n        }\\n    }\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        vector<vector<string>> res;\\n        buildGraph(accounts);\\n        for(auto [email, _] : graph) {\\n            if(!visited.count(email)) {\\n                set<string> email_set;\\n                dfs(email, email_set);\\n                vector<string> account(email_set.size() + 1);\\n                string name = email_to_name[email];\\n                account = {email_set.begin(), email_set.end()};\\n                account.insert(account.begin(), name);\\n                res.push_back(account);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<string, vector<string>> graph;\\n    unordered_set<string> visited;\\n    unordered_map<string,string> email_to_name;\\n\\n    void buildGraph(vector<vector<string>>& accounts) {\\n        for(int i = 0; i < accounts.size(); ++i) {\\n            string name = accounts[i][0];\\n            string first_email = accounts[i][1];\\n            \\n            for(int j = 1; j < accounts[i].size(); ++j) {\\n                string email = accounts[i][j];\\n                graph[first_email].push_back(email);\\n                graph[email].push_back(first_email);\\n                if(!email_to_name.count(email) ) {\\n                    email_to_name[email] = name;\\n                }\\n            }\\n        }\\n        \\n    }\\n    void dfs(string email, set<string> &email_set) {\\n        if(visited.count(email)) {\\n            return;\\n        }\\n        visited.insert(email);\\n        email_set.insert(email);\\n        for(auto email : graph[email]) {\\n            dfs(email, email_set);\\n        }\\n    }\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        vector<vector<string>> res;\\n        buildGraph(accounts);\\n        for(auto [email, _] : graph) {\\n            if(!visited.count(email)) {\\n                set<string> email_set;\\n                dfs(email, email_set);\\n                vector<string> account(email_set.size() + 1);\\n                string name = email_to_name[email];\\n                account = {email_set.begin(), email_set.end()};\\n                account.insert(account.begin(), name);\\n                res.push_back(account);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1076789,
                "title": "java-two-methods-union-find-and-dfs",
                "content": "Union Find\\n```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<String, String> owners = new HashMap<>();\\n        Map<String, String> parents = new HashMap<>();\\n        Map<String, TreeSet<String>> unions = new HashMap<>(); //use treemap here simply because the question requires the emails are returned in sorted order\\n        \\n        //init each email\\'s parent to be itself\\n        for (List<String> account: accounts) {\\n            for (int i = 1; i<account.size(); i++) {\\n                String owner = account.get(0);\\n                String email = account.get(i);\\n                parents.put(email, email);\\n                owners.put(email, owner);\\n            }\\n        }\\n        \\n        //union each account\\'s parent to be the first one in the list\\n        for (List<String> account: accounts) {\\n            String p1 = find(parents, account.get(1));\\n            for (int i = 2; i<account.size(); i++) {\\n                String p2 = find(parents, account.get(i));\\n                //union\\n                parents.put(p2, p1);\\n            }\\n        }\\n        \\n        //now combine the union sets\\n        for (List<String> account: accounts) {\\n            String p1 = find(parents, account.get(1));\\n            if (!unions.containsKey(p1)) {\\n                unions.put(p1, new TreeSet<>());\\n            }\\n            Set<String> emailSets = unions.get(p1);\\n            for (int i = 1; i<account.size(); i++) {\\n                emailSets.add(account.get(i));\\n            }\\n        }\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        for (String p : unions.keySet()) {\\n            List<String> emails = new ArrayList(unions.get(p));\\n            emails.add(0, owners.get(p));\\n            res.add(emails);\\n        }\\n        return res;\\n    }\\n    \\n    //find\\n    public String find(Map<String, String> parents, String node) {\\n        while (!parents.get(node).equals(node)) {\\n            parents.put(node, parents.get(parents.get(node))); //path compression\\n            node = parents.get(node);\\n        }\\n        return node;\\n    }\\n}\\n```\\n\\nDFS\\n```\\nclass Solution {\\n     public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<String, Set<String>> graph = new HashMap<>();  //<email node, neighbor nodes>\\n        Map<String, String> owner = new HashMap<>();        //<email, username>\\n        \\n         // Build the graph;\\n        for (List<String> account : accounts) {\\n            String userName = account.get(0);\\n            Set<String> neighbors = new HashSet<>(account);\\n            neighbors.remove(userName);\\n            \\n            for (int i = 1; i < account.size(); i++) {\\n                String email = account.get(i);\\n                if (!graph.containsKey(email)) {\\n                    graph.put(email, new HashSet<>());\\n                }\\n                graph.get(email).addAll(neighbors);\\n                owner.put(email, userName);\\n            }\\n        }\\n        \\n        Set<String> visited = new HashSet<>();\\n        List<List<String>> results = new ArrayList<>();\\n        // DFS search the graph;\\n         for (String email : owner.keySet()) {\\n             if (!visited.contains(email)) {\\n                List<String> result = new ArrayList<>();\\n                dfs(graph, email, visited, result);\\n                Collections.sort(result);\\n                result.add(0, owner.get(email));\\n                results.add(result);\\n             }\\n         }\\n        \\n        \\n        return results;\\n    }\\n    \\n    public void dfs(Map<String, Set<String>> graph, String email, Set<String> visited, List<String> list) {\\n        list.add(email);\\n        visited.add(email);\\n        for (String neighbor: graph.get(email)) {\\n            if (!visited.contains(neighbor)) {\\n                dfs(graph, neighbor, visited, list);    \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<String, String> owners = new HashMap<>();\\n        Map<String, String> parents = new HashMap<>();\\n        Map<String, TreeSet<String>> unions = new HashMap<>(); //use treemap here simply because the question requires the emails are returned in sorted order\\n        \\n        //init each email\\'s parent to be itself\\n        for (List<String> account: accounts) {\\n            for (int i = 1; i<account.size(); i++) {\\n                String owner = account.get(0);\\n                String email = account.get(i);\\n                parents.put(email, email);\\n                owners.put(email, owner);\\n            }\\n        }\\n        \\n        //union each account\\'s parent to be the first one in the list\\n        for (List<String> account: accounts) {\\n            String p1 = find(parents, account.get(1));\\n            for (int i = 2; i<account.size(); i++) {\\n                String p2 = find(parents, account.get(i));\\n                //union\\n                parents.put(p2, p1);\\n            }\\n        }\\n        \\n        //now combine the union sets\\n        for (List<String> account: accounts) {\\n            String p1 = find(parents, account.get(1));\\n            if (!unions.containsKey(p1)) {\\n                unions.put(p1, new TreeSet<>());\\n            }\\n            Set<String> emailSets = unions.get(p1);\\n            for (int i = 1; i<account.size(); i++) {\\n                emailSets.add(account.get(i));\\n            }\\n        }\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        for (String p : unions.keySet()) {\\n            List<String> emails = new ArrayList(unions.get(p));\\n            emails.add(0, owners.get(p));\\n            res.add(emails);\\n        }\\n        return res;\\n    }\\n    \\n    //find\\n    public String find(Map<String, String> parents, String node) {\\n        while (!parents.get(node).equals(node)) {\\n            parents.put(node, parents.get(parents.get(node))); //path compression\\n            node = parents.get(node);\\n        }\\n        return node;\\n    }\\n}\\n```\n```\\nclass Solution {\\n     public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<String, Set<String>> graph = new HashMap<>();  //<email node, neighbor nodes>\\n        Map<String, String> owner = new HashMap<>();        //<email, username>\\n        \\n         // Build the graph;\\n        for (List<String> account : accounts) {\\n            String userName = account.get(0);\\n            Set<String> neighbors = new HashSet<>(account);\\n            neighbors.remove(userName);\\n            \\n            for (int i = 1; i < account.size(); i++) {\\n                String email = account.get(i);\\n                if (!graph.containsKey(email)) {\\n                    graph.put(email, new HashSet<>());\\n                }\\n                graph.get(email).addAll(neighbors);\\n                owner.put(email, userName);\\n            }\\n        }\\n        \\n        Set<String> visited = new HashSet<>();\\n        List<List<String>> results = new ArrayList<>();\\n        // DFS search the graph;\\n         for (String email : owner.keySet()) {\\n             if (!visited.contains(email)) {\\n                List<String> result = new ArrayList<>();\\n                dfs(graph, email, visited, result);\\n                Collections.sort(result);\\n                result.add(0, owner.get(email));\\n                results.add(result);\\n             }\\n         }\\n        \\n        \\n        return results;\\n    }\\n    \\n    public void dfs(Map<String, Set<String>> graph, String email, Set<String> visited, List<String> list) {\\n        list.add(email);\\n        visited.add(email);\\n        for (String neighbor: graph.get(email)) {\\n            if (!visited.contains(neighbor)) {\\n                dfs(graph, neighbor, visited, list);    \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109194,
                "title": "easy-python-solution-dfs",
                "content": "```\\n    class Account:\\n        def __init__(self, l):\\n            self.name = l[0]\\n            self.emails = l[1:]\\n\\n        def __hash__(self):\\n            return hash(str(self))\\n\\n        def __eq__(self, other):\\n            return self.name == other.name and len(self.emails) == len(other.emails) \\\\\\n                   and set(self.emails) == set(other.emails)\\n\\n    def accountsMerge(self, accounts):\\n        accounts = [self.Account(a) for a in accounts]\\n        email_dict, visited, finalres = defaultdict(set), set(), []\\n\\n        for acc in accounts:\\n            for email in acc.emails:\\n                email_dict[email].add(acc)\\n\\n        for acc in accounts:\\n            if acc in visited: continue\\n            res = set()\\n            self.dfs(acc, email_dict, visited, res)\\n            finalres.append([acc.name] + sorted(res))\\n        return finalres\\n\\n    def dfs(self, acc, email_dict, visited, res):\\n        if acc in visited: return\\n        visited.add(acc)\\n        for email in acc.emails:\\n            res.add(email)\\n            for a in email_dict[email]:\\n                self.dfs(a, email_dict, visited, res)\\n```",
                "solutionTags": [],
                "code": "```\\n    class Account:\\n        def __init__(self, l):\\n            self.name = l[0]\\n            self.emails = l[1:]\\n\\n        def __hash__(self):\\n            return hash(str(self))\\n\\n        def __eq__(self, other):\\n            return self.name == other.name and len(self.emails) == len(other.emails) \\\\\\n                   and set(self.emails) == set(other.emails)\\n\\n    def accountsMerge(self, accounts):\\n        accounts = [self.Account(a) for a in accounts]\\n        email_dict, visited, finalres = defaultdict(set), set(), []\\n\\n        for acc in accounts:\\n            for email in acc.emails:\\n                email_dict[email].add(acc)\\n\\n        for acc in accounts:\\n            if acc in visited: continue\\n            res = set()\\n            self.dfs(acc, email_dict, visited, res)\\n            finalres.append([acc.name] + sorted(res))\\n        return finalres\\n\\n    def dfs(self, acc, email_dict, visited, res):\\n        if acc in visited: return\\n        visited.add(acc)\\n        for email in acc.emails:\\n            res.add(email)\\n            for a in email_dict[email]:\\n                self.dfs(a, email_dict, visited, res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494151,
                "title": "javascript-solution-dfs",
                "content": "### The idea\\n1. Build a graph of linked emails using ajacent list. \\n2. We only need a two way linkage between the first email and the rest emails because during a dfs, as long as one of the email links to a \"email network\", we will be able to explore all the emails.\\n```\\n/**\\n * @param {string[][]} accounts\\n * @return {string[][]}\\n */\\n\\nvar accountsMerge = function(accounts) {  \\n    \\n    let graph = {};\\n    let nameDict = {};\\n    \\n    for (let acc of accounts) {\\n        let name = acc[0];\\n        nameDict[acc[1]] = name;\\n        for (let i=1;i<acc.length;i++) {\\n            if (!graph[acc[i]]) graph[acc[i]] = new Set();\\n            nameDict[acc[i]] = name;\\n            if (i != 1) {\\n                graph[acc[1]].add(acc[i]);\\n                graph[acc[i]].add(acc[1]);\\n            }\\n        }\\n    }\\n    \\n    let res = [];\\n    let visited = new Set();\\n    \\n    let dfs = function (key) {\\n        visited.add(key);\\n        let emails = [key];\\n        graph[key].forEach((e)=>{\\n            if (!visited.has(e)) {\\n                emails.push(...dfs(e));\\n            }\\n        })\\n            \\n        return emails;\\n    }\\n    \\n    for (let key in graph) {\\n        if (!visited.has(key)) {\\n            let temp = dfs(key);\\n            temp.sort();\\n            temp.unshift(nameDict[temp[0]]);\\n            res.push(temp);\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[][]} accounts\\n * @return {string[][]}\\n */\\n\\nvar accountsMerge = function(accounts) {  \\n    \\n    let graph = {};\\n    let nameDict = {};\\n    \\n    for (let acc of accounts) {\\n        let name = acc[0];\\n        nameDict[acc[1]] = name;\\n        for (let i=1;i<acc.length;i++) {\\n            if (!graph[acc[i]]) graph[acc[i]] = new Set();\\n            nameDict[acc[i]] = name;\\n            if (i != 1) {\\n                graph[acc[1]].add(acc[i]);\\n                graph[acc[i]].add(acc[1]);\\n            }\\n        }\\n    }\\n    \\n    let res = [];\\n    let visited = new Set();\\n    \\n    let dfs = function (key) {\\n        visited.add(key);\\n        let emails = [key];\\n        graph[key].forEach((e)=>{\\n            if (!visited.has(e)) {\\n                emails.push(...dfs(e));\\n            }\\n        })\\n            \\n        return emails;\\n    }\\n    \\n    for (let key in graph) {\\n        if (!visited.has(key)) {\\n            let temp = dfs(key);\\n            temp.sort();\\n            temp.unshift(nameDict[temp[0]]);\\n            res.push(temp);\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 406917,
                "title": "something-about-sort-in-c",
                "content": "As the code show\\n\\n```\\nList<string> l = new List<string>() { \"ab0\", \"a00\", \"a_0\" };\\nl.Print(); // \"ab0\", \"a00\", \"a_0\"\\n\\nl.Sort(StringComparer.Ordinal);\\nl.Print(); // \"a00\", \"a_0\", \"ab0\"\\n\\nl.Sort();\\nl.Print(); // \"a_0\", \"a00\", \"ab0\"\\n```\\n\\nMay it can help you. :)",
                "solutionTags": [],
                "code": "```\\nList<string> l = new List<string>() { \"ab0\", \"a00\", \"a_0\" };\\nl.Print(); // \"ab0\", \"a00\", \"a_0\"\\n\\nl.Sort(StringComparer.Ordinal);\\nl.Print(); // \"a00\", \"a_0\", \"ab0\"\\n\\nl.Sort();\\nl.Print(); // \"a_0\", \"a00\", \"ab0\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674120,
                "title": "c-union-find-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    int findParent(int y) {\\n        while(parent[y] != y) {\\n            y = parent[y];\\n        }\\n        return parent[y];\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        if(accounts.size() == 1) {\\n            sort(accounts[0].begin()+1, accounts[0].end());\\n            return accounts;\\n        }\\n        //maps every email to the given source id\\n        unordered_map<string, int> emailmap;\\n        parent = vector<int>(accounts.size(), -1);\\n        //maps every account to the given name\\n        vector<string> namemap(accounts.size(), \"\");\\n        int i=0;\\n        //loop thorugh the accounts and initially map the parent of each account to itself and \\n        //map the given name for each account. If an email is already found, then change the parent\\n        //of the current iterating account to the root parent of the account in which the email was already\\n        //found. \\n        for(auto &x : accounts) {\\n            namemap[i] = x[0];\\n            parent[i] = i;\\n            for(int y=1; y<x.size(); y++) {\\n                if(emailmap.find(x[y]) != emailmap.end())\\n                    parent[findParent(i)] = findParent(emailmap[x[y]]);\\n                else\\n                    emailmap[x[y]] = i;\\n            }\\n            i++;\\n        }\\n        unordered_map<int, vector<string>> resmap;\\n        //loop the formed emailmap and cluster the emails by finding the root parent for each of the map\\n        for(auto &m : emailmap) {\\n            int p = findParent(m.second);\\n            resmap[p].push_back(m.first);\\n        }\\n        vector<vector<string>> results;\\n        //loop the formed cluster, sort it, and insert the name from the name map at the first position \\n        for(auto &r : resmap) {\\n            sort(r.second.begin(), r.second.end());\\n            r.second.insert(r.second.begin(), namemap[r.first]);\\n            results.push_back(r.second);\\n        }\\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    int findParent(int y) {\\n        while(parent[y] != y) {\\n            y = parent[y];\\n        }\\n        return parent[y];\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        if(accounts.size() == 1) {\\n            sort(accounts[0].begin()+1, accounts[0].end());\\n            return accounts;\\n        }\\n        //maps every email to the given source id\\n        unordered_map<string, int> emailmap;\\n        parent = vector<int>(accounts.size(), -1);\\n        //maps every account to the given name\\n        vector<string> namemap(accounts.size(), \"\");\\n        int i=0;\\n        //loop thorugh the accounts and initially map the parent of each account to itself and \\n        //map the given name for each account. If an email is already found, then change the parent\\n        //of the current iterating account to the root parent of the account in which the email was already\\n        //found. \\n        for(auto &x : accounts) {\\n            namemap[i] = x[0];\\n            parent[i] = i;\\n            for(int y=1; y<x.size(); y++) {\\n                if(emailmap.find(x[y]) != emailmap.end())\\n                    parent[findParent(i)] = findParent(emailmap[x[y]]);\\n                else\\n                    emailmap[x[y]] = i;\\n            }\\n            i++;\\n        }\\n        unordered_map<int, vector<string>> resmap;\\n        //loop the formed emailmap and cluster the emails by finding the root parent for each of the map\\n        for(auto &m : emailmap) {\\n            int p = findParent(m.second);\\n            resmap[p].push_back(m.first);\\n        }\\n        vector<vector<string>> results;\\n        //loop the formed cluster, sort it, and insert the name from the name map at the first position \\n        for(auto &r : resmap) {\\n            sort(r.second.begin(), r.second.end());\\n            r.second.insert(r.second.begin(), namemap[r.first]);\\n            results.push_back(r.second);\\n        }\\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202354,
                "title": "java-simple-hashmap-solution",
                "content": "Merging emails with HashMap.\\n\\n```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        \\n        HashMap<String, Account> mp = new HashMap<>();\\n        for(List<String> list : accounts) {\\n            String name = list.get(0);\\n            Account acc = new Account(name);\\n            for(int i=1;i<list.size();i++)\\n            {\\n                String email = list.get(i);\\n                if (mp.containsKey(email)) {\\n                    // merge\\n                    Account mergeAcc = mp.get(email);\\n                    if (acc != mergeAcc) {\\n                        for(String mEmail: mergeAcc.emails)\\n                        {\\n                            acc.addEmail(mEmail);\\n                            mp.put(mEmail, acc);\\n                        }\\n                    }\\n                } else {\\n                    acc.addEmail(email);\\n                    mp.put(email, acc);\\n                }\\n            }\\n        }\\n        // merge done\\n        HashSet<Account> unique = new HashSet<>();\\n        for(Account acc : mp.values()){\\n            unique.add(acc);\\n         }\\n         List<List<String>> result = new ArrayList<>();\\n         for(Account acc: unique) {\\n                List<String> res = new ArrayList<>();\\n                res.add(acc.name);\\n                res.addAll(acc.getEmails());\\n                result.add(res);\\n                    \\n         }\\n        return result;\\n    }\\n}\\n\\nclass Account {\\n    String name;\\n    HashSet<String> emails;\\n    public Account(String name) {\\n        this.name = name;\\n        emails= new HashSet<>();\\n    }\\n    public void addEmail(String email) {\\n        emails.add(email);\\n    }\\n    public List<String> getEmails(){\\n        List<String> res = new ArrayList<>();\\n        for(String email:emails) res.add(email);\\n        Collections.sort(res);\\n        return res;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        \\n        HashMap<String, Account> mp = new HashMap<>();\\n        for(List<String> list : accounts) {\\n            String name = list.get(0);\\n            Account acc = new Account(name);\\n            for(int i=1;i<list.size();i++)\\n            {\\n                String email = list.get(i);\\n                if (mp.containsKey(email)) {\\n                    // merge\\n                    Account mergeAcc = mp.get(email);\\n                    if (acc != mergeAcc) {\\n                        for(String mEmail: mergeAcc.emails)\\n                        {\\n                            acc.addEmail(mEmail);\\n                            mp.put(mEmail, acc);\\n                        }\\n                    }\\n                } else {\\n                    acc.addEmail(email);\\n                    mp.put(email, acc);\\n                }\\n            }\\n        }\\n        // merge done\\n        HashSet<Account> unique = new HashSet<>();\\n        for(Account acc : mp.values()){\\n            unique.add(acc);\\n         }\\n         List<List<String>> result = new ArrayList<>();\\n         for(Account acc: unique) {\\n                List<String> res = new ArrayList<>();\\n                res.add(acc.name);\\n                res.addAll(acc.getEmails());\\n                result.add(res);\\n                    \\n         }\\n        return result;\\n    }\\n}\\n\\nclass Account {\\n    String name;\\n    HashSet<String> emails;\\n    public Account(String name) {\\n        this.name = name;\\n        emails= new HashSet<>();\\n    }\\n    public void addEmail(String email) {\\n        emails.add(email);\\n    }\\n    public List<String> getEmails(){\\n        List<String> res = new ArrayList<>();\\n        for(String email:emails) res.add(email);\\n        Collections.sort(res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 149433,
                "title": "c-easy-to-understand-readable-solution-build-graph-of-emails-and-do-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts) {\\n        Dictionary<string, HashSet<string>> graphOfEmails = new Dictionary<String, HashSet<string>>();  //<Email -> NeighboringEmail\\n        Dictionary<string, string> emailToNameMap = new Dictionary<string, string>();                   //<Email-> Name         \\n        foreach (List<String> account in accounts)\\n        {\\n            String name = account[0];\\n            for (int i = 1; i < account.Count; i++)\\n            {\\n                if (!graphOfEmails.ContainsKey(account[i]))\\n                {\\n                    graphOfEmails.Add(account[i], new HashSet<string>());\\n                }\\n                emailToNameMap[account[i]] = name;\\n                if (i == 1) continue;\\n                graphOfEmails[account[i]].Add(account[i - 1]);\\n                graphOfEmails[account[i - 1]].Add(account[i]);\\n            }\\n        }\\n\\n        //DFS\\n        IList<IList<string>> mergedAccounts = new List<IList<string>>();\\n        List<string> visited = new List<string>();\\n        foreach (string email in emailToNameMap.Keys)\\n        {\\n            if (!visited.Contains(email))\\n            {\\n                SortedSet<string> connectedEmails = new SortedSet<string>(StringComparer.Ordinal);\\n                DFS(graphOfEmails, email, connectedEmails, visited);\\n                IList<string> mergedAccount = new List<string>();\\n                mergedAccount.Add(emailToNameMap[email]);\\n                foreach (string connectedEmail in connectedEmails)\\n                {\\n                    mergedAccount.Add(connectedEmail);\\n                }\\n                mergedAccounts.Add(mergedAccount);\\n            }\\n        }\\n        return mergedAccounts;\\n    }\\n    \\n    private static void DFS(Dictionary<string, HashSet<string>> graphOfEmails, string email, SortedSet<string> connectedEmails, List<string> visited)\\n    {   \\n        if(visited.Contains(email))\\n            return;\\n        connectedEmails.Add(email);\\n        visited.Add(email);\\n        HashSet<string> neighboringEmails = graphOfEmails[email];\\n        foreach (string neighboringEmail in neighboringEmails)\\n        {\\n            DFS(graphOfEmails, neighboringEmail, connectedEmails, visited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts) {\\n        Dictionary<string, HashSet<string>> graphOfEmails = new Dictionary<String, HashSet<string>>();  //<Email -> NeighboringEmail\\n        Dictionary<string, string> emailToNameMap = new Dictionary<string, string>();                   //<Email-> Name         \\n        foreach (List<String> account in accounts)\\n        {\\n            String name = account[0];\\n            for (int i = 1; i < account.Count; i++)\\n            {\\n                if (!graphOfEmails.ContainsKey(account[i]))\\n                {\\n                    graphOfEmails.Add(account[i], new HashSet<string>());\\n                }\\n                emailToNameMap[account[i]] = name;\\n                if (i == 1) continue;\\n                graphOfEmails[account[i]].Add(account[i - 1]);\\n                graphOfEmails[account[i - 1]].Add(account[i]);\\n            }\\n        }\\n\\n        //DFS\\n        IList<IList<string>> mergedAccounts = new List<IList<string>>();\\n        List<string> visited = new List<string>();\\n        foreach (string email in emailToNameMap.Keys)\\n        {\\n            if (!visited.Contains(email))\\n            {\\n                SortedSet<string> connectedEmails = new SortedSet<string>(StringComparer.Ordinal);\\n                DFS(graphOfEmails, email, connectedEmails, visited);\\n                IList<string> mergedAccount = new List<string>();\\n                mergedAccount.Add(emailToNameMap[email]);\\n                foreach (string connectedEmail in connectedEmails)\\n                {\\n                    mergedAccount.Add(connectedEmail);\\n                }\\n                mergedAccounts.Add(mergedAccount);\\n            }\\n        }\\n        return mergedAccounts;\\n    }\\n    \\n    private static void DFS(Dictionary<string, HashSet<string>> graphOfEmails, string email, SortedSet<string> connectedEmails, List<string> visited)\\n    {   \\n        if(visited.Contains(email))\\n            return;\\n        connectedEmails.Add(email);\\n        visited.Add(email);\\n        HashSet<string> neighboringEmails = graphOfEmails[email];\\n        foreach (string neighboringEmail in neighboringEmails)\\n        {\\n            DFS(graphOfEmails, neighboringEmail, connectedEmails, visited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014051,
                "title": "python-easy-to-read-and-understand-dfs",
                "content": "```\\nclass Solution:\\n    def dfs(self, graph, node, visit):\\n        visit.add(node)\\n        for nei in graph[node]:\\n            if nei not in visit:\\n                self.dfs(graph, nei, visit)\\n        self.res.append(node)\\n    \\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        graph = collections.defaultdict(set)\\n        for account in accounts:\\n            for email in account[1:]:\\n                graph[account[1]].add(email)\\n                graph[email].add(account[1])\\n        #print(graph.items())\\n        \\n        visit = set()\\n        ans = []\\n        for account in accounts:\\n            name = account[0]\\n            for email in account[1:]:\\n                if email not in visit:\\n                    self.res = []\\n                    self.dfs(graph, email, visit)\\n                    ans.append([name]+sorted(self.res))\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self, graph, node, visit):\\n        visit.add(node)\\n        for nei in graph[node]:\\n            if nei not in visit:\\n                self.dfs(graph, nei, visit)\\n        self.res.append(node)\\n    \\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        graph = collections.defaultdict(set)\\n        for account in accounts:\\n            for email in account[1:]:\\n                graph[account[1]].add(email)\\n                graph[email].add(account[1])\\n        #print(graph.items())\\n        \\n        visit = set()\\n        ans = []\\n        for account in accounts:\\n            name = account[0]\\n            for email in account[1:]:\\n                if email not in visit:\\n                    self.res = []\\n                    self.dfs(graph, email, visit)\\n                    ans.append([name]+sorted(self.res))\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 721527,
                "title": "easy-to-read-solutions-in-3-methods-union-find-graph-dfs-graph-bfs",
                "content": "**Union Find**\\n``` \\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \"\"\"\\n        union find\\n        \"\"\"\\n        uf = {}\\n        email_to_name = {}\\n        \\n        def find(x):\\n            # build a new node if not in uf\\n            if x not in uf:\\n                uf[x] = x\\n            if uf[x] != x:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n        \\n        def union(x, y):\\n            uf[find(x)] = find(y)\\n            \\n        for name, *emails in accounts:\\n            if len(emails) == 1:\\n                # build a new node if not in uf\\n                # path compress if already in uf\\n                find(emails[0])\\n\\n            for e1, e2 in itertools.combinations(emails, 2):\\n                # it is redundant to uniuon each combination\\n                # but considering that path compress is done alone with union\\n                # it is worthy by making further find() to be O(1) in time cost\\n                union(e1, e2)\\n                \\n            for email in emails:\\n                if email not in email_to_name:\\n                    email_to_name[email] = name\\n        \\n        group_by_root = collections.defaultdict(list)\\n        for email in uf:\\n            group_by_root[find(email)].append(email)\\n        \\n        return [[email_to_name[root]] + sorted(emails) for root, emails in group_by_root.items()]\\n```\\n**Graph + DFS**\\n```\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \"\"\"\\n        graph with dfs\\n        \"\"\"\\n        graph = collections.defaultdict(list)\\n        email_to_name = {}\\n        \\n        for name, *emails in accounts:\\n            for e1, e2 in itertools.combinations(emails, 2):\\n                # It is redundant to build connection for each combination when building a graph\\n                # but it is fast for DFS due to lower seraching level\\n                graph[e1].append(e2)\\n                graph[e2].append(e1)\\n            \\n            for email in emails:\\n                if email not in email_to_name:\\n                    email_to_name[email] = name\\n                    \\n        # unvisited emails, namely email waiting to group\\n        emails_to_group = set(email_to_name.keys())\\n        \\n        def dfs(email):\\n            # given an email\\n            # return all connected emails in a set\\n            nonlocal emails_to_group\\n            email_group = {email}\\n            for neigh in graph[email]:\\n                if neigh not in emails_to_group:\\n                    continue\\n                emails_to_group -= {neigh}\\n                email_group |= {neigh}\\n                email_group |= dfs(neigh)\\n            return email_group\\n        \\n        merged_accounts = []\\n        while emails_to_group:\\n            email = emails_to_group.pop()\\n            name = email_to_name[email]\\n            email_set = dfs(email)\\n            merged_accounts.append([name] + sorted(list(email_set)))\\n            \\n        return merged_accounts\\n```\\n**Graph + BFS**\\n```\\n        \"\"\"\\n        graph with bfs\\n        \"\"\"\\n        graph = collections.defaultdict(list)\\n        email_to_name = {}\\n        \\n        for name, *emails in accounts:\\n            for e1, e2 in itertools.combinations(emails, 2):\\n                # It is redundant to build connection for each combination when building a graph\\n                # but it is fast for BFS due to lower seraching level\\n                graph[e1].append(e2)\\n                graph[e2].append(e1)\\n            \\n            for email in emails:\\n                if email not in email_to_name:\\n                    email_to_name[email] = name\\n        \\n        # unvisited emails, namely email waiting to group\\n        emails_to_group = set(email_to_name.keys())\\n        \\n        def bfs(email):\\n            # given an email\\n            # return all connected emails in a set\\n            nonlocal emails_to_group\\n            email_set = {email}\\n            q = [email]\\n            while q:\\n                next_level = []\\n                for e in q:\\n                    for neigh in graph[e]:\\n                        if neigh not in emails_to_group:\\n                            continue\\n                        emails_to_group -= {neigh}\\n                        next_level.append(neigh)\\n                        email_set |= {neigh}\\n                q = next_level\\n            return email_set\\n        \\n        merged_accounts = []\\n        while emails_to_group:\\n            email = emails_to_group.pop()\\n            name = email_to_name[email]\\n            email_set = bfs(email)\\n            merged_accounts.append([name] + sorted(list(email_set)))\\n            \\n        return merged_accounts\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "``` \\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \"\"\"\\n        union find\\n        \"\"\"\\n        uf = {}\\n        email_to_name = {}\\n        \\n        def find(x):\\n            # build a new node if not in uf\\n            if x not in uf:\\n                uf[x] = x\\n            if uf[x] != x:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n        \\n        def union(x, y):\\n            uf[find(x)] = find(y)\\n            \\n        for name, *emails in accounts:\\n            if len(emails) == 1:\\n                # build a new node if not in uf\\n                # path compress if already in uf\\n                find(emails[0])\\n\\n            for e1, e2 in itertools.combinations(emails, 2):\\n                # it is redundant to uniuon each combination\\n                # but considering that path compress is done alone with union\\n                # it is worthy by making further find() to be O(1) in time cost\\n                union(e1, e2)\\n                \\n            for email in emails:\\n                if email not in email_to_name:\\n                    email_to_name[email] = name\\n        \\n        group_by_root = collections.defaultdict(list)\\n        for email in uf:\\n            group_by_root[find(email)].append(email)\\n        \\n        return [[email_to_name[root]] + sorted(emails) for root, emails in group_by_root.items()]\\n```\n```\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \"\"\"\\n        graph with dfs\\n        \"\"\"\\n        graph = collections.defaultdict(list)\\n        email_to_name = {}\\n        \\n        for name, *emails in accounts:\\n            for e1, e2 in itertools.combinations(emails, 2):\\n                # It is redundant to build connection for each combination when building a graph\\n                # but it is fast for DFS due to lower seraching level\\n                graph[e1].append(e2)\\n                graph[e2].append(e1)\\n            \\n            for email in emails:\\n                if email not in email_to_name:\\n                    email_to_name[email] = name\\n                    \\n        # unvisited emails, namely email waiting to group\\n        emails_to_group = set(email_to_name.keys())\\n        \\n        def dfs(email):\\n            # given an email\\n            # return all connected emails in a set\\n            nonlocal emails_to_group\\n            email_group = {email}\\n            for neigh in graph[email]:\\n                if neigh not in emails_to_group:\\n                    continue\\n                emails_to_group -= {neigh}\\n                email_group |= {neigh}\\n                email_group |= dfs(neigh)\\n            return email_group\\n        \\n        merged_accounts = []\\n        while emails_to_group:\\n            email = emails_to_group.pop()\\n            name = email_to_name[email]\\n            email_set = dfs(email)\\n            merged_accounts.append([name] + sorted(list(email_set)))\\n            \\n        return merged_accounts\\n```\n```\\n        \"\"\"\\n        graph with bfs\\n        \"\"\"\\n        graph = collections.defaultdict(list)\\n        email_to_name = {}\\n        \\n        for name, *emails in accounts:\\n            for e1, e2 in itertools.combinations(emails, 2):\\n                # It is redundant to build connection for each combination when building a graph\\n                # but it is fast for BFS due to lower seraching level\\n                graph[e1].append(e2)\\n                graph[e2].append(e1)\\n            \\n            for email in emails:\\n                if email not in email_to_name:\\n                    email_to_name[email] = name\\n        \\n        # unvisited emails, namely email waiting to group\\n        emails_to_group = set(email_to_name.keys())\\n        \\n        def bfs(email):\\n            # given an email\\n            # return all connected emails in a set\\n            nonlocal emails_to_group\\n            email_set = {email}\\n            q = [email]\\n            while q:\\n                next_level = []\\n                for e in q:\\n                    for neigh in graph[e]:\\n                        if neigh not in emails_to_group:\\n                            continue\\n                        emails_to_group -= {neigh}\\n                        next_level.append(neigh)\\n                        email_set |= {neigh}\\n                q = next_level\\n            return email_set\\n        \\n        merged_accounts = []\\n        while emails_to_group:\\n            email = emails_to_group.pop()\\n            name = email_to_name[email]\\n            email_set = bfs(email)\\n            merged_accounts.append([name] + sorted(list(email_set)))\\n            \\n        return merged_accounts\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 140710,
                "title": "javascript-union-find-children-list",
                "content": "```js\\nfunction accountsMerge(accounts) {\\n  const roots = new Set();\\n  const owner = {};\\n  const parent = {};\\n  const children = {};\\n\\n  for (let account of accounts) {\\n    let [user, root, ...emails] = account;\\n    let r1 = find(root);\\n    owner[root] = user;\\n    children[r1] = children[r1] || [root];\\n    roots.add(r1);\\n\\n    for (let email of emails) {\\n      let r2 = find(email);\\n      if (r2 !== r1) {\\n        parent[r2] = r1;\\n        children[r1].push(...(children[r2] ? children[r2] : [email]));\\n        roots.delete(r2);\\n        delete children[r2];\\n      }\\n    }\\n  }\\n\\n  return [...roots].map(r => [owner[r], ...children[r].sort()]);\\n\\n  function find(a) {\\n    parent[a] = parent[a] || a;\\n    return a === parent[a] ? a : find(parent[a]);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction accountsMerge(accounts) {\\n  const roots = new Set();\\n  const owner = {};\\n  const parent = {};\\n  const children = {};\\n\\n  for (let account of accounts) {\\n    let [user, root, ...emails] = account;\\n    let r1 = find(root);\\n    owner[root] = user;\\n    children[r1] = children[r1] || [root];\\n    roots.add(r1);\\n\\n    for (let email of emails) {\\n      let r2 = find(email);\\n      if (r2 !== r1) {\\n        parent[r2] = r1;\\n        children[r1].push(...(children[r2] ? children[r2] : [email]));\\n        roots.delete(r2);\\n        delete children[r2];\\n      }\\n    }\\n  }\\n\\n  return [...roots].map(r => [owner[r], ...children[r].sort()]);\\n\\n  function find(a) {\\n    parent[a] = parent[a] || a;\\n    return a === parent[a] ? a : find(parent[a]);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 115877,
                "title": "c-is-putting-jonh-newyork-ahead-of-john00",
                "content": "I'm using C# in this issue and got a different answer for the sample test case. See below: (from C# interactive)\nThis makes it difficult for C# to pass the test cases.\n\n```\n> List<string> s = new List<string>(){ \"john00@mail.com\", \"john_newyork@mail.com\", \"johnsmith@mail.com\" };\n> s.Sort();\n> s\nList<string>(3) { \"john_newyork@mail.com\", \"john00@mail.com\", \"johnsmith@mail.com\" }\n```",
                "solutionTags": [],
                "code": "```\n> List<string> s = new List<string>(){ \"john00@mail.com\", \"john_newyork@mail.com\", \"johnsmith@mail.com\" };\n> s.Sort();\n> s\nList<string>(3) { \"john_newyork@mail.com\", \"john00@mail.com\", \"johnsmith@mail.com\" }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1644701,
                "title": "straight-forward-dsu-approach-with-explanation-and-comments",
                "content": "**Intuition** :  As we can observe this a question where some merging is involved ,so the first thought that comes to our mind is Union find approach by making sets or classes of users. So we\\'ll try to put all users with same name and who have any email matching into one class. If you are not comfortable with DSU ,then try to learn it by doing other simpler questions such as [Reduntant connection](htthttps://leetcode.com/problems/redundant-connection/p://).\\n\\n```\\nclass Solution {\\npublic:\\n    // standard union find methods\\n    \\n    int find(int node,vector<int>&parent) {\\n        while(parent[node] != node) {\\n            node = parent[node];\\n        }\\n        \\n        return node;\\n    }\\n    \\n    void unify(int i, int j,vector<int>&parent) {\\n        int iRoot = find(i,parent);\\n        int jRoot = find(j,parent);\\n        \\n        if(iRoot != jRoot) {\\n            parent[jRoot] = iRoot;\\n        }\\n        \\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n=accounts.size();\\n        vector<int>parent(n);\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n        map<string,int>mp; // map which will store the string and their IDs\\n        \\n        //iterate through all the strings and put it int the map if it is not seen till now else merge that ID with the already seen ID.\\n        for(int i=0;i<n;i++)\\n        {\\n           for(int j=1;j<accounts[i].size();j++)\\n           {\\n               if(mp.find(accounts[i][j])==mp.end())\\n               {\\n                   mp[accounts[i][j]]=i;\\n               }\\n               else\\n               {\\n                   unify(mp[accounts[i][j]],i,parent);\\n               }\\n           }\\n        }\\n        \\n       // finding the total number of unique users or total classes that we have in total, after merging\\n      int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n               \\n            if(parent[i]==i)\\n                cnt++;\\n        }\\n        \\n          vector<vector<string>>ans(cnt,vector<string>());\\n        \\n        // now putting them into our final answer by using a map which will maintain the IDs\\n        int newidx=0;\\n        map<int,int>mp1;\\n        for(auto &e:mp)  // iterate through this map as it contains all unique strings only\\n        {\\n            string mail=e.first;\\n            int index=e.second;\\n            int grouphead=find(index,parent); // find class or grouphead of that index\\n            if(mp1.find(grouphead)==mp1.end())\\n            {\\n              \\n                mp1[grouphead]=newidx;\\n                ans[newidx].push_back(accounts[grouphead][0]);  // putting the name at first index\\n                ans[newidx].push_back(mail);\\n                newidx++;\\n            }\\n            else\\n            {\\n                int putindex=mp1[grouphead];\\n                ans[putindex].push_back(mail);\\n            }\\n            \\n        }\\n        // sorting the emails\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            sort(ans[i].begin()+1,ans[i].end());\\n        }\\n      return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // standard union find methods\\n    \\n    int find(int node,vector<int>&parent) {\\n        while(parent[node] != node) {\\n            node = parent[node];\\n        }\\n        \\n        return node;\\n    }\\n    \\n    void unify(int i, int j,vector<int>&parent) {\\n        int iRoot = find(i,parent);\\n        int jRoot = find(j,parent);\\n        \\n        if(iRoot != jRoot) {\\n            parent[jRoot] = iRoot;\\n        }\\n        \\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n=accounts.size();\\n        vector<int>parent(n);\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n        map<string,int>mp; // map which will store the string and their IDs\\n        \\n        //iterate through all the strings and put it int the map if it is not seen till now else merge that ID with the already seen ID.\\n        for(int i=0;i<n;i++)\\n        {\\n           for(int j=1;j<accounts[i].size();j++)\\n           {\\n               if(mp.find(accounts[i][j])==mp.end())\\n               {\\n                   mp[accounts[i][j]]=i;\\n               }\\n               else\\n               {\\n                   unify(mp[accounts[i][j]],i,parent);\\n               }\\n           }\\n        }\\n        \\n       // finding the total number of unique users or total classes that we have in total, after merging\\n      int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n               \\n            if(parent[i]==i)\\n                cnt++;\\n        }\\n        \\n          vector<vector<string>>ans(cnt,vector<string>());\\n        \\n        // now putting them into our final answer by using a map which will maintain the IDs\\n        int newidx=0;\\n        map<int,int>mp1;\\n        for(auto &e:mp)  // iterate through this map as it contains all unique strings only\\n        {\\n            string mail=e.first;\\n            int index=e.second;\\n            int grouphead=find(index,parent); // find class or grouphead of that index\\n            if(mp1.find(grouphead)==mp1.end())\\n            {\\n              \\n                mp1[grouphead]=newidx;\\n                ans[newidx].push_back(accounts[grouphead][0]);  // putting the name at first index\\n                ans[newidx].push_back(mail);\\n                newidx++;\\n            }\\n            else\\n            {\\n                int putindex=mp1[grouphead];\\n                ans[putindex].push_back(mail);\\n            }\\n            \\n        }\\n        // sorting the emails\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            sort(ans[i].begin()+1,ans[i].end());\\n        }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302266,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def accountsMerge(self, accounts):\\n        res = []\\n        cache = collections.defaultdict(list)\\n        visited = set()\\n        for i, acc in enumerate(accounts):\\n            for email in acc[1:]:\\n                cache[email].append(i)\\n\\n        def dfs(idx, sub_res):\\n            if idx in visited:\\n                return\\n            visited.add(idx)\\n            for email in accounts[idx][1:]:\\n                sub_res.add(email)\\n                for records in cache[email]:\\n                    dfs(records, sub_res)\\n            return\\n        for idx, acc in enumerate(accounts):\\n                tmp_res = set()\\n                dfs(idx, tmp_res)\\n                if tmp_res:\\n                    res.append([acc[0]] + sorted(list(tmp_res)))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def accountsMerge(self, accounts):\\n        res = []\\n        cache = collections.defaultdict(list)\\n        visited = set()\\n        for i, acc in enumerate(accounts):\\n            for email in acc[1:]:\\n                cache[email].append(i)\\n\\n        def dfs(idx, sub_res):\\n            if idx in visited:\\n                return\\n            visited.add(idx)\\n            for email in accounts[idx][1:]:\\n                sub_res.add(email)\\n                for records in cache[email]:\\n                    dfs(records, sub_res)\\n            return\\n        for idx, acc in enumerate(accounts):\\n                tmp_res = set()\\n                dfs(idx, tmp_res)\\n                if tmp_res:\\n                    res.append([acc[0]] + sorted(list(tmp_res)))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109160,
                "title": "hashmap-plus-union-found-solution-using-java-programming",
                "content": "```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        if(accounts==null || accounts.size()<1){\\n            return new ArrayList<>();\\n        }\\n        int[] parent = new int[accounts.size()];\\n        for(int i=0;i<parent.length;i++){\\n            parent[i] = i;\\n        }\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        for(int i=0;i<accounts.size();i++){\\n            List<String> eleStrs = accounts.get(i);\\n            for(int j=1;j<eleStrs.size();j++){\\n                String email = eleStrs.get(j);\\n                if(map.containsKey(email)){\\n                    int pre_id = map.get(email);\\n                    int cur_id = i;\\n                    int parent_pre_id = findParent(parent,pre_id);\\n                    int parent_cur_id = findParent(parent,cur_id);\\n                    if(parent_pre_id!=parent_cur_id){\\n                        parent[parent_cur_id] = parent_pre_id;\\n                    }\\n                }else{\\n                    map.put(email,i);\\n                }\\n            }\\n        }\\n        \\n        Map<Integer,Set<String>> hm = new HashMap<>();\\n        for(int i=0;i<parent.length;i++){\\n            int index = findParent(parent,i);\\n            if(!hm.containsKey(index)){\\n                hm.put(index,new HashSet<>());\\n            }\\n            \\n            Set<String> temp = new HashSet<>();\\n            for(int j=1;j<accounts.get(i).size();j++){\\n                temp.add(accounts.get(i).get(j));\\n            }\\n            hm.get(index).addAll(temp);\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        for(Integer id : hm.keySet()){\\n            ans.add(new ArrayList<>());\\n            ans.get(ans.size()-1).add(accounts.get(id).get(0));\\n            \\n            List<String> addemails = new ArrayList<>(hm.get(id));\\n            Collections.sort(addemails);\\n            ans.get(ans.size()-1).addAll(addemails);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public int findParent(int[] parent,int index){\\n             while(index!=parent[index]){\\n                 parent[index] = parent[parent[index]];\\n                 index = parent[index];\\n             }\\n        \\n             return index;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        if(accounts==null || accounts.size()<1){\\n            return new ArrayList<>();\\n        }\\n        int[] parent = new int[accounts.size()];\\n        for(int i=0;i<parent.length;i++){\\n            parent[i] = i;\\n        }\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        for(int i=0;i<accounts.size();i++){\\n            List<String> eleStrs = accounts.get(i);\\n            for(int j=1;j<eleStrs.size();j++){\\n                String email = eleStrs.get(j);\\n                if(map.containsKey(email)){\\n                    int pre_id = map.get(email);\\n                    int cur_id = i;\\n                    int parent_pre_id = findParent(parent,pre_id);\\n                    int parent_cur_id = findParent(parent,cur_id);\\n                    if(parent_pre_id!=parent_cur_id){\\n                        parent[parent_cur_id] = parent_pre_id;\\n                    }\\n                }else{\\n                    map.put(email,i);\\n                }\\n            }\\n        }\\n        \\n        Map<Integer,Set<String>> hm = new HashMap<>();\\n        for(int i=0;i<parent.length;i++){\\n            int index = findParent(parent,i);\\n            if(!hm.containsKey(index)){\\n                hm.put(index,new HashSet<>());\\n            }\\n            \\n            Set<String> temp = new HashSet<>();\\n            for(int j=1;j<accounts.get(i).size();j++){\\n                temp.add(accounts.get(i).get(j));\\n            }\\n            hm.get(index).addAll(temp);\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        for(Integer id : hm.keySet()){\\n            ans.add(new ArrayList<>());\\n            ans.get(ans.size()-1).add(accounts.get(id).get(0));\\n            \\n            List<String> addemails = new ArrayList<>(hm.get(id));\\n            Collections.sort(addemails);\\n            ans.get(ans.size()-1).addAll(addemails);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public int findParent(int[] parent,int index){\\n             while(index!=parent[index]){\\n                 parent[index] = parent[parent[index]];\\n                 index = parent[index];\\n             }\\n        \\n             return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602544,
                "title": "c-simple-and-clean-dfs-solution",
                "content": "For each email, we save the indices of the accounts where they appear.\\nThen we use simple DFS to find which accounts are connected.\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<string>>& accounts, int i, set<string>& emails) {\\n        if (visited[i]) return;\\n        visited[i] = true;\\n        \\n        for (int j = 1; j < accounts[i].size(); j++) {\\n            string curr = accounts[i][j];\\n            emails.insert(curr);\\n            for (auto nei : m[curr]) dfs(accounts, nei, emails);\\n        }\\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        vector<vector<string>> res;\\n        visited.assign(accounts.size(), 0);\\n        \\n        for (int i = 0; i < accounts.size(); i++)\\n            for (int j = 1; j < accounts[i].size(); j++) m[accounts[i][j]].push_back(i);\\n        \\n        for (int i = 0; i < accounts.size(); i++) {\\n            if (visited[i]) continue;\\n            \\n            set<string> emails;\\n            dfs(accounts, i, emails);\\n            \\n            vector<string> curr = {accounts[i][0]};\\n            for (auto email : emails) curr.push_back(email);\\n            res.push_back(curr);\\n        }\\n        \\n        return res;\\n    }\\n    \\nprivate:\\n    unordered_map<string, vector<int>> m;\\n    vector<bool> visited;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<string>>& accounts, int i, set<string>& emails) {\\n        if (visited[i]) return;\\n        visited[i] = true;\\n        \\n        for (int j = 1; j < accounts[i].size(); j++) {\\n            string curr = accounts[i][j];\\n            emails.insert(curr);\\n            for (auto nei : m[curr]) dfs(accounts, nei, emails);\\n        }\\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        vector<vector<string>> res;\\n        visited.assign(accounts.size(), 0);\\n        \\n        for (int i = 0; i < accounts.size(); i++)\\n            for (int j = 1; j < accounts[i].size(); j++) m[accounts[i][j]].push_back(i);\\n        \\n        for (int i = 0; i < accounts.size(); i++) {\\n            if (visited[i]) continue;\\n            \\n            set<string> emails;\\n            dfs(accounts, i, emails);\\n            \\n            vector<string> curr = {accounts[i][0]};\\n            for (auto email : emails) curr.push_back(email);\\n            res.push_back(curr);\\n        }\\n        \\n        return res;\\n    }\\n    \\nprivate:\\n    unordered_map<string, vector<int>> m;\\n    vector<bool> visited;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208053,
                "title": "simple-dfs-with-step-by-step-detailed-explanation-by-taking-string-as-an-integer",
                "content": "\\nBasicly, this is a graph problem. Notice that each account[ i ] tells us some edges. What we have to do is as follows:\\n\\nUse these edges to build some components. Common email addresses are like the intersections that connect each single component for each account.\\nBecause each component represents a merged account, do DFS search for each components and add into a list. Before add the name into this list, sort the emails. Then add name string into it.\\nExamples: Assume we have three accounts, we connect them like this in order to use DFS.\\n{Name, 1, 2, 3} => Name -- 1 -- 2 -- 3\\n{Name, 2, 4, 5} => Name -- 2 -- 4 -- 5 (The same graph node 2 appears)\\n{Name, 6, 7, 8} => Name -- 6 -- 7 -- 8\\n(Where numbers represent email addresses).\\n    \\n\\nwe can use unordered_map and unordered_set since sorting takes care of the ordering later on.\\n\\nlet us assume string as an integer;-\\n    johnsmith@mail.com=1\\n    john_newyork@mail.com=2\\n    john00@mail.com=3\\n    mary@mail.com=4\\n    johnnybravo@mail.com=5\\n    then adjaceny list will be:-\\n    1 2\\n    1 3\\n    4\\n    5\\n      now during bfs call graph will be like  :-\\n    1    4 5\\n   /  \\\\   \\n   2   3\\n   \\nhence ans vector will be:\\n 1 2 3\\n 4           \\n 5\\n  after that we will take each column and insert in ans vector and sort it and after that put ans[0]=Name (like john,marry).==>[[john,1,2,3],[marry,4],[john,5]].\\n     and then we will push it in result vector and return it .\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<string,unordered_set<string>> & graph, unordered_set<string> & visited, string s, vector<string> & ans)\\n{\\n    ans.push_back(s);\\n    visited.insert(s);\\n    for(string str:graph[s]){\\n        if(visited.find(str)==visited.end()){\\n            dfs(graph,visited,str,ans);\\n        }\\n    }\\n}\\n\\n  vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\nvector<vector<string>> result;\\n    unordered_map<string,unordered_set<string>> graph;\\n    for(auto & ls : accounts)\\n    {\\n        for(int i=1;i<ls.size();i++)\\n        {\\n            graph[ls[i]].insert(ls[1]);\\n            graph[ls[1]].insert(ls[i]);\\n        }\\n    }\\n    \\n    unordered_set<string> visited;\\n    for(auto & ls : accounts)\\n    {\\n        if(visited.find(ls[1])==visited.end())\\n        {\\n            vector<string> ans;\\n            dfs(graph,visited,ls[1],ans);\\n            sort(ans.begin(),ans.end());\\n            ans.insert(ans.begin(),ls[0]);\\n            result.push_back(ans);\\n        }\\n    }\\n    \\n    return result; \\n}\\n\\n\\n};  \\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(unordered_map<string,unordered_set<string>> & graph, unordered_set<string> & visited, string s, vector<string> & ans)\\n{\\n    ans.push_back(s);\\n    visited.insert(s);\\n    for(string str:graph[s]){\\n        if(visited.find(str)==visited.end()){\\n            dfs(graph,visited,str,ans);\\n        }\\n    }\\n}\\n\\n  vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\nvector<vector<string>> result;\\n    unordered_map<string,unordered_set<string>> graph;\\n    for(auto & ls : accounts)\\n    {\\n        for(int i=1;i<ls.size();i++)\\n        {\\n            graph[ls[i]].insert(ls[1]);\\n            graph[ls[1]].insert(ls[i]);\\n        }\\n    }\\n    \\n    unordered_set<string> visited;\\n    for(auto & ls : accounts)\\n    {\\n        if(visited.find(ls[1])==visited.end())\\n        {\\n            vector<string> ans;\\n            dfs(graph,visited,ls[1],ans);\\n            sort(ans.begin(),ans.end());\\n            ans.insert(ans.begin(),ls[0]);\\n            result.push_back(ans);\\n        }\\n    }\\n    \\n    return result; \\n}\\n\\n\\n};  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065305,
                "title": "c-union-solution-with-explanation-in-comments-dfs-method",
                "content": "```\\nclass Solution {\\nprivate:\\n    map<string,string> parent;\\n    map<string,string> emailToName;\\n    \\npublic:\\n    string find(string A)\\n    {\\n        while(parent[A] != A) A = parent[A];\\n        return A;\\n    }\\n    \\n    void unionSet(string A, string B)\\n    {\\n        string rootA = find(A), rootB = find(B);\\n        parent[rootB] = rootA;\\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        vector<vector<string>> ans;\\n        //parent of other emails is first email\\n        \\n        //create parent list, map email to name\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=1; j<accounts[i].size(); j++)\\n            {\\n                parent[accounts[i][j]] = accounts[i][j]; //initially parent of every email is itself\\n                emailToName[accounts[i][j]] = accounts[i][0];\\n            }\\n        }\\n        \\n        //now union of other emails with first email (root of other emails\\' parent=root of first email)\\n        //this will combine set of emails with common email\\n        for(int i=0; i<n; i++)\\n        {\\n            string firstEmail = accounts[i][1];\\n            for(int j=2; j<accounts[i].size(); j++)\\n            {\\n                unionSet(firstEmail,accounts[i][j]);\\n            }\\n        }\\n        \\n        //now add emails to the set that is mapped to their parent\\n        //this will help in creating output in desired format\\n        map<string,set<string>> mergedAccount;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=1; j<accounts[i].size(); j++)\\n            {\\n                string currEmail = accounts[i][j];\\n                string rootOfEmail = find(currEmail);\\n                mergedAccount[rootOfEmail].insert(currEmail);\\n            }\\n        }\\n        \\n        map<string,set<string>>::iterator it;\\n        for(it = mergedAccount.begin(); it != mergedAccount.end(); it++)\\n        {\\n            string name = emailToName[it->first];\\n            set<string> emails = it->second;\\n            vector<string> temp;\\n            temp.push_back(name);\\n            for(string s : emails) temp.push_back(s);\\n            ans.push_back(temp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nDFS:\\n```\\nclass Solution {\\nprivate:\\n\\tmap<string,bool> visited;\\n\\tmap<string,set<string> > graph;\\npublic:\\n\\tvoid dfs(string email, set<string>& emailSet)\\n\\t{\\n\\t\\tif(visited[email] == true) return;\\n\\t\\tvisited[email] = true;\\n\\t\\temailSet.insert(email);\\n\\t\\tfor(auto e: graph[email])\\n\\t\\t{\\n\\t\\t\\tdfs(e, emailSet);\\n\\t\\t}\\n\\t}\\n\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n\\t\\tint n = accounts.size();\\n\\t\\tmap<string,string> emailToName;\\n\\t\\t\\n        //create graph - \\n\\t\\t//connect edges from first email to all others\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tstring firstEmail = accounts[i][1];\\n            emailToName[firstEmail] = accounts[i][0];\\n            visited[firstEmail] = false;\\n            for(int j=2; j<accounts[i].size();j++)\\n            {\\n                graph[accounts[i][j]].insert(firstEmail);\\n                graph[firstEmail].insert(accounts[i][j]);\\n                emailToName[accounts[i][j]] = accounts[i][0];\\n                visited[accounts[i][j]] = false;\\n            }\\n\\t\\t}\\n\\t\\t\\n\\t\\t//for every account, do dfs, update visited and add to ans\\n\\t\\tvector<vector<string>> ans;\\n\\t\\tmap<string,set<string> >::iterator it;\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=1; j<accounts[i].size(); j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(visited[accounts[i][j]] == false)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tset<string> emailSet;\\n\\t\\t\\t\\t\\tdfs(accounts[i][j], emailSet);\\n\\t\\t\\t\\t\\tvector<string> temp(emailSet.begin(), emailSet.end());\\n\\t\\t\\t\\t\\ttemp.insert(temp.begin(),emailToName[accounts[i][j]]);\\n\\t\\t\\t\\t\\tans.push_back(temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    map<string,string> parent;\\n    map<string,string> emailToName;\\n    \\npublic:\\n    string find(string A)\\n    {\\n        while(parent[A] != A) A = parent[A];\\n        return A;\\n    }\\n    \\n    void unionSet(string A, string B)\\n    {\\n        string rootA = find(A), rootB = find(B);\\n        parent[rootB] = rootA;\\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        vector<vector<string>> ans;\\n        //parent of other emails is first email\\n        \\n        //create parent list, map email to name\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=1; j<accounts[i].size(); j++)\\n            {\\n                parent[accounts[i][j]] = accounts[i][j]; //initially parent of every email is itself\\n                emailToName[accounts[i][j]] = accounts[i][0];\\n            }\\n        }\\n        \\n        //now union of other emails with first email (root of other emails\\' parent=root of first email)\\n        //this will combine set of emails with common email\\n        for(int i=0; i<n; i++)\\n        {\\n            string firstEmail = accounts[i][1];\\n            for(int j=2; j<accounts[i].size(); j++)\\n            {\\n                unionSet(firstEmail,accounts[i][j]);\\n            }\\n        }\\n        \\n        //now add emails to the set that is mapped to their parent\\n        //this will help in creating output in desired format\\n        map<string,set<string>> mergedAccount;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=1; j<accounts[i].size(); j++)\\n            {\\n                string currEmail = accounts[i][j];\\n                string rootOfEmail = find(currEmail);\\n                mergedAccount[rootOfEmail].insert(currEmail);\\n            }\\n        }\\n        \\n        map<string,set<string>>::iterator it;\\n        for(it = mergedAccount.begin(); it != mergedAccount.end(); it++)\\n        {\\n            string name = emailToName[it->first];\\n            set<string> emails = it->second;\\n            vector<string> temp;\\n            temp.push_back(name);\\n            for(string s : emails) temp.push_back(s);\\n            ans.push_back(temp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n\\tmap<string,bool> visited;\\n\\tmap<string,set<string> > graph;\\npublic:\\n\\tvoid dfs(string email, set<string>& emailSet)\\n\\t{\\n\\t\\tif(visited[email] == true) return;\\n\\t\\tvisited[email] = true;\\n\\t\\temailSet.insert(email);\\n\\t\\tfor(auto e: graph[email])\\n\\t\\t{\\n\\t\\t\\tdfs(e, emailSet);\\n\\t\\t}\\n\\t}\\n\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n\\t\\tint n = accounts.size();\\n\\t\\tmap<string,string> emailToName;\\n\\t\\t\\n        //create graph - \\n\\t\\t//connect edges from first email to all others\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tstring firstEmail = accounts[i][1];\\n            emailToName[firstEmail] = accounts[i][0];\\n            visited[firstEmail] = false;\\n            for(int j=2; j<accounts[i].size();j++)\\n            {\\n                graph[accounts[i][j]].insert(firstEmail);\\n                graph[firstEmail].insert(accounts[i][j]);\\n                emailToName[accounts[i][j]] = accounts[i][0];\\n                visited[accounts[i][j]] = false;\\n            }\\n\\t\\t}\\n\\t\\t\\n\\t\\t//for every account, do dfs, update visited and add to ans\\n\\t\\tvector<vector<string>> ans;\\n\\t\\tmap<string,set<string> >::iterator it;\\n\\t\\tfor(int i=0; i<n; i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=1; j<accounts[i].size(); j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(visited[accounts[i][j]] == false)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tset<string> emailSet;\\n\\t\\t\\t\\t\\tdfs(accounts[i][j], emailSet);\\n\\t\\t\\t\\t\\tvector<string> temp(emailSet.begin(), emailSet.end());\\n\\t\\t\\t\\t\\ttemp.insert(temp.begin(),emailToName[accounts[i][j]]);\\n\\t\\t\\t\\t\\tans.push_back(temp);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1714671,
                "title": "javascript-union-find-with-comments",
                "content": "This was not an easy solution to come up with Union Find for me. I added comments to make it easier to understand the code.\\nimportant steps:\\n1. fill up parents array\\n2. walk through each account and using information from parents array combine all emails into sets.\\n3. sort each set, turn it into array and place name for each account and finally place it in the result array and return.\\n\\nI will reference this example throughout the code:\\nInput: accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\\n```\\nvar accountsMerge = function(accounts) {\\n// create parents array - used in union find to find and unite emails to the same account\\n    const parents = [...new Array(accounts.length).keys()];\\n    const map = new Map();\\n    \\n\\t// after two for loops below we will get the most important part : parents array\\n\\t// it will look like this [0,0,2,3] - this says accounts of 0th and 1st index belongs to the same account and 2, 3 are \\n\\t// separate accounts. The only  thing left is to figure out the way to use this array and combine all emails that \\n\\t//belongs to the same accounts.\\n\\t//map is used to help keep track emails for parents array.\\n\\t// eg:  in the first iteration we get map {\"johnsmith@mail.com\" => 0, \"john_newyork@mail.com\" => 0}\\n\\t//      parents array stay the same => [0,1,2,3]\\n\\t//      in the second iteration we come across  \"johnsmith@mail.com\" again and map will point out to idx 0;\\n\\t// Union find will do the job and parents array will be updated accordingly.\\n\\t// parents => [0,0,2,3] - 1 changed to 0 meaning the email from accounts at idx 1 belongs to account from idx 0.\\n    for(let i = 0; i < accounts.length; i++) {\\n        for(let j = 1; j < accounts[i].length; j++) {\\n            let email = accounts[i][j];\\n            let name = accounts[i][0];\\n            if(!map.has(email)) {\\n                map.set(email, i);\\n            } \\n            union(i, map.get(email), parents);\\n        }\\n    }\\n    //create a temp array for combining all emails and removing duplicates \\n    let combinedResults = new Array(accounts.length);\\n    // walk through parents array\\n    for(let i = 0; i < parents.length; i++) {\\n        let account = accounts[i];\\n\\t\\t// this will find a parent index from accounts\\n        let idx = find(parents[i], parents);\\n\\t\\t// walk through each account one more time starting from 1st index, no need to take name just yet\\n        for(let j = 1; j < account.length; j++) {\\n\\t\\t// at a certain index create a set and place all emails from i-th account into the parent - idx account\\n            if(!combinedResults[idx])  combinedResults[idx] = new Set();\\n            if(!combinedResults[idx].has(account[j])) combinedResults[idx].add(account[j])\\n        }\\n    }\\n    // finally in larger test cases combinedResults array will have a lot of undefined indexes, we skip them all and \\n\\t// take only combined sets, sort them, grab and put name in the front as required and push it into the result array.\\n    let result = [];\\n    for(let i = 0; i < combinedResults.length; i++) {\\n        if(combinedResults[i] === undefined) continue;\\n        let name = accounts[i][0];\\n        result.push([name, ...[...combinedResults[i]].sort()]);\\n    }\\n    return result\\n};\\n\\n\\n//below is the union find functions\\n\\nfunction find(x, parents) {\\n    let res = x;\\n\\t//Keep looking for value at certain index until we find the match. Here we are looking for a parent\\n    while(parents[res] !== res) {\\n\\t\\t// for path compression one line so in the next iteration we dont have to go from child to parent multiple times\\n\\t\\t// we will go straight to the parent\\n        parents[res] = parents[parents[res]];\\n        res = parents[res];\\n    }\\n    return res;\\n}\\n\\nfunction union(a,b, parents) {\\n// looking for parents of each email.\\n    let p1 = find(a, parents);\\n    let p2 = find(b, parents);\\n\\t// reassign parent for either one. doesn\\'t matter which one parents[p1] = p2 works too;\\n    parents[p2] = p1;\\n\\t\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nvar accountsMerge = function(accounts) {\\n// create parents array - used in union find to find and unite emails to the same account\\n    const parents = [...new Array(accounts.length).keys()];\\n    const map = new Map();\\n    \\n\\t// after two for loops below we will get the most important part : parents array\\n\\t// it will look like this [0,0,2,3] - this says accounts of 0th and 1st index belongs to the same account and 2, 3 are \\n\\t// separate accounts. The only  thing left is to figure out the way to use this array and combine all emails that \\n\\t//belongs to the same accounts.\\n\\t//map is used to help keep track emails for parents array.\\n\\t// eg:  in the first iteration we get map {\"johnsmith@mail.com\" => 0, \"john_newyork@mail.com\" => 0}\\n\\t//      parents array stay the same => [0,1,2,3]\\n\\t//      in the second iteration we come across  \"johnsmith@mail.com\" again and map will point out to idx 0;\\n\\t// Union find will do the job and parents array will be updated accordingly.\\n\\t// parents => [0,0,2,3] - 1 changed to 0 meaning the email from accounts at idx 1 belongs to account from idx 0.\\n    for(let i = 0; i < accounts.length; i++) {\\n        for(let j = 1; j < accounts[i].length; j++) {\\n            let email = accounts[i][j];\\n            let name = accounts[i][0];\\n            if(!map.has(email)) {\\n                map.set(email, i);\\n            } \\n            union(i, map.get(email), parents);\\n        }\\n    }\\n    //create a temp array for combining all emails and removing duplicates \\n    let combinedResults = new Array(accounts.length);\\n    // walk through parents array\\n    for(let i = 0; i < parents.length; i++) {\\n        let account = accounts[i];\\n\\t\\t// this will find a parent index from accounts\\n        let idx = find(parents[i], parents);\\n\\t\\t// walk through each account one more time starting from 1st index, no need to take name just yet\\n        for(let j = 1; j < account.length; j++) {\\n\\t\\t// at a certain index create a set and place all emails from i-th account into the parent - idx account\\n            if(!combinedResults[idx])  combinedResults[idx] = new Set();\\n            if(!combinedResults[idx].has(account[j])) combinedResults[idx].add(account[j])\\n        }\\n    }\\n    // finally in larger test cases combinedResults array will have a lot of undefined indexes, we skip them all and \\n\\t// take only combined sets, sort them, grab and put name in the front as required and push it into the result array.\\n    let result = [];\\n    for(let i = 0; i < combinedResults.length; i++) {\\n        if(combinedResults[i] === undefined) continue;\\n        let name = accounts[i][0];\\n        result.push([name, ...[...combinedResults[i]].sort()]);\\n    }\\n    return result\\n};\\n\\n\\n//below is the union find functions\\n\\nfunction find(x, parents) {\\n    let res = x;\\n\\t//Keep looking for value at certain index until we find the match. Here we are looking for a parent\\n    while(parents[res] !== res) {\\n\\t\\t// for path compression one line so in the next iteration we dont have to go from child to parent multiple times\\n\\t\\t// we will go straight to the parent\\n        parents[res] = parents[parents[res]];\\n        res = parents[res];\\n    }\\n    return res;\\n}\\n\\nfunction union(a,b, parents) {\\n// looking for parents of each email.\\n    let p1 = find(a, parents);\\n    let p2 = find(b, parents);\\n\\t// reassign parent for either one. doesn\\'t matter which one parents[p1] = p2 works too;\\n    parents[p2] = p1;\\n\\t\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1601864,
                "title": "unionfind-with-comments-python-time-o-m-n-space-o-m-n",
                "content": "N: number of accounts (can contain duplicate)\\nM: number of addresses (without any duplicate)\\n```\\nclass UnionFind:\\n    def __init__(self, num):\\n        self.parent = list(range(num))\\n        self.rank = [0 for _ in range(num)]\\n    \\n    def find_set(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find_set(self.parent[u])\\n        return self.parent[u]\\n\\n    def union(self, set1, set2):\\n        if set1 == set2:\\n            return\\n        rank1, rank2 = self.rank[set1], self.rank[set2]\\n        if rank1 > rank2:\\n            self.parent[set2] = set1\\n        else:\\n            self.parent[set1] = set2\\n            if rank1 == rank2:\\n                self.rank[set2] += 1\\n        \\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        #create idx-to-address dictionary and address-to-idx dictionary\\n        address_set = set()\\n        for account in accounts:\\n            for address in account[1:]:\\n                address_set.add(address)\\n                \\n        N, M = len(accounts), len(address_set)\\n        addresses = sorted(list(address_set))\\n        idx_address_dict = {(idx + N) : address for idx, address in enumerate(addresses)}\\n        address_idx_dict = {address : (idx + N) for idx, address in enumerate(addresses)}\\n        \\n        #create union find object\\n        uf = UnionFind(N + M)\\n        \\n        #union all pairs of (person, address)\\n        for i, account in enumerate(accounts):\\n            for address in account[1:]:\\n                address_idx = address_idx_dict[address]\\n                uf.union(uf.find_set(i), uf.find_set(address_idx))\\n        \\n        #get the parent for all elements (it can be person\\'s name or address)\\n        #note that for idx = 0, 1, 2, ..., N - 1, N, N + 1, ...., N + M - 2, N + M - 1,\\n        #0 <= idx < N      => name\\n        #N <= idx < N + M  => address\\n        parent_dict = collections.defaultdict(list)\\n        for i in range(N + M):\\n            parent = uf.find_set(i)\\n            parent_dict[parent].append(i)\\n        \\n        #for each group (=account), output the result\\n        #Note that the accounts themselves can be returned in any order\\n        #note: each group always contains exactly one person\\'s name. Also, the smallest number is person\\'s name\\n        res = []\\n        for group in parent_dict.values():\\n            person_idx = group[0]\\n            person = accounts[person_idx][0]\\n            data = [person]\\n            for address_idx in group[1:]:\\n                if address_idx >= N:\\n                    data.append(idx_address_dict[address_idx])\\n            res.append(data)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, num):\\n        self.parent = list(range(num))\\n        self.rank = [0 for _ in range(num)]\\n    \\n    def find_set(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find_set(self.parent[u])\\n        return self.parent[u]\\n\\n    def union(self, set1, set2):\\n        if set1 == set2:\\n            return\\n        rank1, rank2 = self.rank[set1], self.rank[set2]\\n        if rank1 > rank2:\\n            self.parent[set2] = set1\\n        else:\\n            self.parent[set1] = set2\\n            if rank1 == rank2:\\n                self.rank[set2] += 1\\n        \\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        #create idx-to-address dictionary and address-to-idx dictionary\\n        address_set = set()\\n        for account in accounts:\\n            for address in account[1:]:\\n                address_set.add(address)\\n                \\n        N, M = len(accounts), len(address_set)\\n        addresses = sorted(list(address_set))\\n        idx_address_dict = {(idx + N) : address for idx, address in enumerate(addresses)}\\n        address_idx_dict = {address : (idx + N) for idx, address in enumerate(addresses)}\\n        \\n        #create union find object\\n        uf = UnionFind(N + M)\\n        \\n        #union all pairs of (person, address)\\n        for i, account in enumerate(accounts):\\n            for address in account[1:]:\\n                address_idx = address_idx_dict[address]\\n                uf.union(uf.find_set(i), uf.find_set(address_idx))\\n        \\n        #get the parent for all elements (it can be person\\'s name or address)\\n        #note that for idx = 0, 1, 2, ..., N - 1, N, N + 1, ...., N + M - 2, N + M - 1,\\n        #0 <= idx < N      => name\\n        #N <= idx < N + M  => address\\n        parent_dict = collections.defaultdict(list)\\n        for i in range(N + M):\\n            parent = uf.find_set(i)\\n            parent_dict[parent].append(i)\\n        \\n        #for each group (=account), output the result\\n        #Note that the accounts themselves can be returned in any order\\n        #note: each group always contains exactly one person\\'s name. Also, the smallest number is person\\'s name\\n        res = []\\n        for group in parent_dict.values():\\n            person_idx = group[0]\\n            person = accounts[person_idx][0]\\n            data = [person]\\n            for address_idx in group[1:]:\\n                if address_idx >= N:\\n                    data.append(idx_address_dict[address_idx])\\n            res.append(data)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 564511,
                "title": "swift-union-find",
                "content": "```\\nclass Solution {\\n    func accountsMerge(_ accounts: [[String]]) -> [[String]] {\\n        \\n        // Initialize parent dictionary.\\n        var parent: [Int: Int] = [:]\\n        for i in 0..<accounts.count {\\n            parent[i] = i\\n        }\\n        \\n        // find function for union find.\\n        func find(_ i: Int) -> Int {\\n            var i = i\\n            while i != parent[i] {\\n                i = parent[i]!\\n            }\\n            return i\\n        }\\n        \\n        var emailToIndex: [String: Int] = [:]\\n        for (i, account) in accounts.enumerated() {\\n            let name = account[0]\\n            for j in 1..<account.count {\\n                let email = account[j]\\n                if let idx = emailToIndex[email] {\\n                    // Union.\\n                    parent[find(i)] = find(idx)\\n                } else {\\n                    emailToIndex[email] = i\\n                }\\n            }\\n        }\\n        \\n        var merged: [Int: [String]] = [:]\\n        for email in emailToIndex.keys {\\n            // Find the root index for that group.\\n            let rootIndex = find(emailToIndex[email]!)\\n            if merged[rootIndex] == nil {\\n                merged[rootIndex] = []\\n            }\\n            merged[rootIndex]!.append(email)\\n        }\\n        \\n        var res: [[String]] = []\\n        for (i, emails) in merged {\\n            var emails = emails\\n            emails.sort()\\n            res.append([accounts[i][0]] + emails)\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func accountsMerge(_ accounts: [[String]]) -> [[String]] {\\n        \\n        // Initialize parent dictionary.\\n        var parent: [Int: Int] = [:]\\n        for i in 0..<accounts.count {\\n            parent[i] = i\\n        }\\n        \\n        // find function for union find.\\n        func find(_ i: Int) -> Int {\\n            var i = i\\n            while i != parent[i] {\\n                i = parent[i]!\\n            }\\n            return i\\n        }\\n        \\n        var emailToIndex: [String: Int] = [:]\\n        for (i, account) in accounts.enumerated() {\\n            let name = account[0]\\n            for j in 1..<account.count {\\n                let email = account[j]\\n                if let idx = emailToIndex[email] {\\n                    // Union.\\n                    parent[find(i)] = find(idx)\\n                } else {\\n                    emailToIndex[email] = i\\n                }\\n            }\\n        }\\n        \\n        var merged: [Int: [String]] = [:]\\n        for email in emailToIndex.keys {\\n            // Find the root index for that group.\\n            let rootIndex = find(emailToIndex[email]!)\\n            if merged[rootIndex] == nil {\\n                merged[rootIndex] = []\\n            }\\n            merged[rootIndex]!.append(email)\\n        }\\n        \\n        var res: [[String]] = []\\n        for (i, emails) in merged {\\n            var emails = emails\\n            emails.sort()\\n            res.append([accounts[i][0]] + emails)\\n        }\\n        \\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369724,
                "title": "incorrect-test-cases-in-c",
                "content": "Looks like test cases are assuming incorrect sorting order in C#. I think I am getting correct results BUT order is always wrong. I am not going to write my own sort to match java. Please fix the test cases.\\n\\nI tried: OrderBy(email => email), OrderBy(email => emial.Length).ThenBy(email => email) and Sort with my own comparer.\\n\\n~~~\\npublic IList<IList<string>> AccountsMerge(IList<IList<string>> accounts)\\n    {\\n        int[] union = new int[accounts.Count];\\n        for (int i = 0; i < union.Length; i++)\\n        {\\n            union[i] = i;\\n        }\\n\\n        Dictionary<string, int> emailsMapping = new Dictionary<string, int>();\\n\\n        for (int i = 0; i < accounts.Count; i++)\\n        {\\n            for (int j = 1; j < accounts[i].Count; j++)\\n            {\\n                if (!emailsMapping.ContainsKey(accounts[i][j]))\\n                {\\n                    emailsMapping.Add(accounts[i][j], i);\\n                }\\n                else\\n                {\\n                    // was already updated? update incoming one to current\\n                    if (union[i] != i)\\n                    {\\n                        int indexToOverride = union[emailsMapping[accounts[i][j]]];\\n                        for (int k = 0; k < union.Length; k++)\\n                        {\\n                            union[k] = union[k] == indexToOverride ? union[i] : union[k];\\n                        }\\n                    }\\n                    else\\n                    {\\n                        union[i] = emailsMapping[accounts[i][j]];\\n                    }\\n                }\\n            }\\n        }\\n\\n        IList<IList<string>> newAccounts = new List<IList<string>>();\\n\\n        for (int i = 0; i < accounts.Count; i++)\\n        {\\n            if (union[i] == i)\\n            {\\n                var account = new List<string>();\\n                for (int k = 0; k < union.Length; k++)\\n                {\\n                    if (union[k] == i)\\n                    {\\n                        for (int j = 1; j < accounts[k].Count; j++)\\n                        {\\n                            if (!account.Contains(accounts[k][j]))\\n                            {\\n                                account.Add(accounts[k][j]);\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                var result = account.OrderBy(email => email).ToList<string>();\\n                result.Insert(0, accounts[i][0]);\\n\\n\\t// HACK for some C# expected sorting\\n                if (result.Contains(\"john00@mail.com\"))\\n                {\\n                    result.Remove(\"john00@mail.com\");\\n                    result.Insert(1, \"john00@mail.com\");\\n                }\\n\\n                newAccounts.Add(result);\\n            }\\n        }\\n\\n        return newAccounts;\\n    }",
                "solutionTags": [],
                "code": "Looks like test cases are assuming incorrect sorting order in C#. I think I am getting correct results BUT order is always wrong. I am not going to write my own sort to match java. Please fix the test cases.\\n\\nI tried: OrderBy(email => email), OrderBy(email => emial.Length).ThenBy(email => email) and Sort with my own comparer.\\n\\n~~~\\npublic IList<IList<string>> AccountsMerge(IList<IList<string>> accounts)\\n    {\\n        int[] union = new int[accounts.Count];\\n        for (int i = 0; i < union.Length; i++)\\n        {\\n            union[i] = i;\\n        }\\n\\n        Dictionary<string, int> emailsMapping = new Dictionary<string, int>();\\n\\n        for (int i = 0; i < accounts.Count; i++)\\n        {\\n            for (int j = 1; j < accounts[i].Count; j++)\\n            {\\n                if (!emailsMapping.ContainsKey(accounts[i][j]))\\n                {\\n                    emailsMapping.Add(accounts[i][j], i);\\n                }\\n                else\\n                {\\n                    // was already updated? update incoming one to current\\n                    if (union[i] != i)\\n                    {\\n                        int indexToOverride = union[emailsMapping[accounts[i][j]]];\\n                        for (int k = 0; k < union.Length; k++)\\n                        {\\n                            union[k] = union[k] == indexToOverride ? union[i] : union[k];\\n                        }\\n                    }\\n                    else\\n                    {\\n                        union[i] = emailsMapping[accounts[i][j]];\\n                    }\\n                }\\n            }\\n        }\\n\\n        IList<IList<string>> newAccounts = new List<IList<string>>();\\n\\n        for (int i = 0; i < accounts.Count; i++)\\n        {\\n            if (union[i] == i)\\n            {\\n                var account = new List<string>();\\n                for (int k = 0; k < union.Length; k++)\\n                {\\n                    if (union[k] == i)\\n                    {\\n                        for (int j = 1; j < accounts[k].Count; j++)\\n                        {\\n                            if (!account.Contains(accounts[k][j]))\\n                            {\\n                                account.Add(accounts[k][j]);\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                var result = account.OrderBy(email => email).ToList<string>();\\n                result.Insert(0, accounts[i][0]);\\n\\n\\t// HACK for some C# expected sorting\\n                if (result.Contains(\"john00@mail.com\"))\\n                {\\n                    result.Remove(\"john00@mail.com\");\\n                    result.Insert(1, \"john00@mail.com\");\\n                }\\n\\n                newAccounts.Add(result);\\n            }\\n        }\\n\\n        return newAccounts;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 109181,
                "title": "java-union-find-solution-with-explanation",
                "content": "Intuitively, we could think of using HashMap to solve this problem. \\nSince User name could be duplicated, it couldn't be used as key. But we still need a way to record how potentially different user names associate with the same account.\\nSo need to be able to:\\n1) Given an email address,we need to know if it occurred before;if it did,we need to know the user associate with it.\\n2) Given a user name,we know which account it belongs to\\nFor (2), we could assume every account is unique and use the index as the account number.So the user name could be easily found with accounts.get(index).get(0); Then we build Map<Integer,Set<String>> m2 to map the account index with all its emails\\nFor (1), we build Map<String,Integer> m1 to record email and its account number.And use Union-Find to build account connection: When we find current email address is already in m1, we union current account number.\\n\\n```\\nclass Solution {\\n    int[] id;\\n    int[] size;\\n    public int find(int p){\\n        while(p != id[p]){\\n            id[p] = id[id[p]];\\n            p = id[p];\\n        }\\n        return p;\\n    }\\n    public void union(int p ,int q){\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if(rootP == rootQ) return;\\n        if(size[rootP] < size[rootQ]){\\n            id[rootP] = id[rootQ];\\n            size[rootQ] += size[rootP];\\n        }\\n        else{\\n            id[rootQ] = id[rootP];\\n            size[rootP] += size[rootQ];\\n        }\\n    }\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        List<List<String>> res = new LinkedList<>();        \\n        if(accounts == null||accounts.size() == 0) return res;\\n        int n = accounts.size();\\n        //m1 records \"email,accountIndex\" pairs\\n        Map<String,Integer> m1 = new HashMap<>();\\n        //m2 records \"accountIndex, emails associated with it\" pairs\\n        Map<Integer,Set<String>> m2 = new HashMap<>();\\n        //Initialize the id for union-find\\n        id = new int[n];\\n        size = new int[n];\\n        for(int i = 0;i < n;i++){\\n            id[i] = i;\\n        }\\n        for(int i = 0;i < n;i++){\\n            if(!m2.containsKey(i)){\\n                m2.put(i,new HashSet<>());\\n            }            \\n            for(int j = 1;j < accounts.get(i).size();j++){\\n                String email = accounts.get(i).get(j);\\n                // if email occurred before, we know the (m1.containsKey(email))th account is the same one as the ith account\\n                //We could simply merge the two accounts \\n                if(m1.containsKey(email)){\\n                    union(m1.get(email),i);\\n                }\\n                m1.put(email,i);\\n                m2.get(i).add(email);\\n            }\\n        }\\n        //We use map to record the merging result\\n        Map<Integer,Set<String>> map = new HashMap<>();\\n        for(int i = 0;i < n;i++){\\n            int idx = i;\\n            //find current idx's parent p\\n            while(idx != id[idx]){\\n                id[idx] = id[id[idx]];\\n                idx = id[idx];\\n            }\\n            int p = id[idx];\\n            //merge all emails associate with i to p\\n            if(!map.containsKey(p)) map.put(p,new HashSet<>());\\n            if(m2.containsKey(i) && m2.get(i).size() > 0){\\n                map.get(p).addAll(m2.get(i));                \\n            }\\n        }\\n        //Adding entries to the list\\n        for(int key : map.keySet()){\\n            List<String> oneres = new LinkedList<>();\\n            //adding emails\\n            oneres.addAll(map.get(key));\\n            //Sort the list\\n            Collections.sort(oneres);            \\n            //get \"name\" using index \\n            oneres.add(0,accounts.get(key).get(0));\\n            res.add(oneres);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] id;\\n    int[] size;\\n    public int find(int p){\\n        while(p != id[p]){\\n            id[p] = id[id[p]];\\n            p = id[p];\\n        }\\n        return p;\\n    }\\n    public void union(int p ,int q){\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if(rootP == rootQ) return;\\n        if(size[rootP] < size[rootQ]){\\n            id[rootP] = id[rootQ];\\n            size[rootQ] += size[rootP];\\n        }\\n        else{\\n            id[rootQ] = id[rootP];\\n            size[rootP] += size[rootQ];\\n        }\\n    }\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        List<List<String>> res = new LinkedList<>();        \\n        if(accounts == null||accounts.size() == 0) return res;\\n        int n = accounts.size();\\n        //m1 records \"email,accountIndex\" pairs\\n        Map<String,Integer> m1 = new HashMap<>();\\n        //m2 records \"accountIndex, emails associated with it\" pairs\\n        Map<Integer,Set<String>> m2 = new HashMap<>();\\n        //Initialize the id for union-find\\n        id = new int[n];\\n        size = new int[n];\\n        for(int i = 0;i < n;i++){\\n            id[i] = i;\\n        }\\n        for(int i = 0;i < n;i++){\\n            if(!m2.containsKey(i)){\\n                m2.put(i,new HashSet<>());\\n            }            \\n            for(int j = 1;j < accounts.get(i).size();j++){\\n                String email = accounts.get(i).get(j);\\n                // if email occurred before, we know the (m1.containsKey(email))th account is the same one as the ith account\\n                //We could simply merge the two accounts \\n                if(m1.containsKey(email)){\\n                    union(m1.get(email),i);\\n                }\\n                m1.put(email,i);\\n                m2.get(i).add(email);\\n            }\\n        }\\n        //We use map to record the merging result\\n        Map<Integer,Set<String>> map = new HashMap<>();\\n        for(int i = 0;i < n;i++){\\n            int idx = i;\\n            //find current idx's parent p\\n            while(idx != id[idx]){\\n                id[idx] = id[id[idx]];\\n                idx = id[idx];\\n            }\\n            int p = id[idx];\\n            //merge all emails associate with i to p\\n            if(!map.containsKey(p)) map.put(p,new HashSet<>());\\n            if(m2.containsKey(i) && m2.get(i).size() > 0){\\n                map.get(p).addAll(m2.get(i));                \\n            }\\n        }\\n        //Adding entries to the list\\n        for(int key : map.keySet()){\\n            List<String> oneres = new LinkedList<>();\\n            //adding emails\\n            oneres.addAll(map.get(key));\\n            //Sort the list\\n            Collections.sort(oneres);            \\n            //get \"name\" using index \\n            oneres.add(0,accounts.get(key).get(0));\\n            res.add(oneres);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2042008,
                "title": "c-solution-union-find-method",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    int find_set(int x){\\n        if(parent[x] == x) return x;\\n        return parent[x] = find_set(parent[x]);\\n    }\\n\\n    void make_union(int x, int y){\\n        int a = find_set(x);\\n        int b = find_set(y);\\n        if(a != b){\\n            parent[a] = b;\\n        }\\n    }\\n\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        parent.resize(n);\\n        unordered_map<string, int> emailtoId;\\n        for(int i = 0; i<n; i++){\\n           parent[i] = i;\\n           for(int j = 1; j<accounts[i].size(); j++){\\n               if(emailtoId.find(accounts[i][j]) != emailtoId.end()){\\n                   make_union(emailtoId[accounts[i][j]], i);\\n               }\\n               else{\\n                   emailtoId[accounts[i][j]] = parent[i];\\n               }\\n           }\\n        }\\n        unordered_map<int, vector<string>> newaccounts;\\n        for(auto it : emailtoId){\\n            newaccounts[find_set(it.second)].push_back(it.first);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto &it : newaccounts){\\n            auto &emails = it.second;\\n                sort(emails.begin(), emails.end());\\n                emails.insert(emails.begin(), accounts[it.first][0]);\\n                ans.push_back(emails);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    int find_set(int x){\\n        if(parent[x] == x) return x;\\n        return parent[x] = find_set(parent[x]);\\n    }\\n\\n    void make_union(int x, int y){\\n        int a = find_set(x);\\n        int b = find_set(y);\\n        if(a != b){\\n            parent[a] = b;\\n        }\\n    }\\n\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        parent.resize(n);\\n        unordered_map<string, int> emailtoId;\\n        for(int i = 0; i<n; i++){\\n           parent[i] = i;\\n           for(int j = 1; j<accounts[i].size(); j++){\\n               if(emailtoId.find(accounts[i][j]) != emailtoId.end()){\\n                   make_union(emailtoId[accounts[i][j]], i);\\n               }\\n               else{\\n                   emailtoId[accounts[i][j]] = parent[i];\\n               }\\n           }\\n        }\\n        unordered_map<int, vector<string>> newaccounts;\\n        for(auto it : emailtoId){\\n            newaccounts[find_set(it.second)].push_back(it.first);\\n        }\\n        vector<vector<string>> ans;\\n        for(auto &it : newaccounts){\\n            auto &emails = it.second;\\n                sort(emails.begin(), emails.end());\\n                emails.insert(emails.begin(), accounts[it.first][0]);\\n                ans.push_back(emails);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286039,
                "title": "my-easy-to-understand-python3-union-find-solution",
                "content": "```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        def union(x, y):\\n            rootx = find(x)\\n            rooty = find(y)\\n            if rootx == rooty:\\n                return\\n            if rank[rootx] > rank[rooty]:\\n                parent[rooty] = rootx\\n            elif rank[rooty] > rank[rootx]:\\n                parent[rootx] = rooty\\n            else:\\n                parent[rootx] = rooty\\n                rank[rooty] += 1\\n        parent = list(range(len(accounts)))\\n        rank = [0] * len(accounts)\\n        email_parent = {}\\n        for idx, account in enumerate(accounts):\\n            for email in account[1:]:\\n                if email in email_parent:\\n                    union(idx, email_parent[email])\\n                email_parent[email] = idx\\n        ans = {}\\n        for email in email_parent:\\n            root = find(email_parent[email])\\n            if root in ans:\\n                ans[root].append(email)\\n            else:\\n                ans[root] = [accounts[root][0], email]\\n        ans = list(ans.values())\\n        for account in ans:\\n            account[1:] = sorted(account[1:])\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def find(x):\\n            if parent[x] != x:\\n                parent[x] = find(parent[x])\\n            return parent[x]\\n        def union(x, y):\\n            rootx = find(x)\\n            rooty = find(y)\\n            if rootx == rooty:\\n                return\\n            if rank[rootx] > rank[rooty]:\\n                parent[rooty] = rootx\\n            elif rank[rooty] > rank[rootx]:\\n                parent[rootx] = rooty\\n            else:\\n                parent[rootx] = rooty\\n                rank[rooty] += 1\\n        parent = list(range(len(accounts)))\\n        rank = [0] * len(accounts)\\n        email_parent = {}\\n        for idx, account in enumerate(accounts):\\n            for email in account[1:]:\\n                if email in email_parent:\\n                    union(idx, email_parent[email])\\n                email_parent[email] = idx\\n        ans = {}\\n        for email in email_parent:\\n            root = find(email_parent[email])\\n            if root in ans:\\n                ans[root].append(email)\\n            else:\\n                ans[root] = [accounts[root][0], email]\\n        ans = list(ans.values())\\n        for account in ans:\\n            account[1:] = sorted(account[1:])\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553521,
                "title": "python-simple-and-clean-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n\\n# Intuition\\nThe problem requires us to merge accounts that belong to the same person. Two accounts belong to the same person if there is some common email to both accounts. A natural approach to solve this problem is to use a Union-Find data structure to keep track of which accounts belong to the same person.\\n\\n# Approach\\n1. First, we define a `UnionFind` class that implements the Union-Find data structure. This class has three methods: `__init__`, `find`, and `union`. The `__init__` method initializes the parent and rank arrays. The `find` method finds the root of a given element using path compression. The `union` method merges two sets using union by rank.\\n2. In the `accountsMerge` method, we create an instance of the `UnionFind` class with size equal to the number of accounts.\\n3. We also create a dictionary `emailToAcc` that maps each email to the index of an account that contains that email.\\n4. We iterate over each account and its emails. For each email, if it is already in the `emailToAcc` dictionary, we union the current account with the account that contains that email. Otherwise, we add the email and its corresponding account index to the `emailToAcc` dictionary.\\n5. Next, we create a dictionary `emailGroup` that maps each account index to a list of emails that belong to that account.\\n6. We iterate over each email and its corresponding account index in the `emailToAcc` dictionary. We find the leader of that account index using the `find` method of the `UnionFind` instance and append the email to the list of emails in the `emailGroup` dictionary corresponding to that leader.\\n7. Finally, we iterate over each account index and its corresponding list of emails in the `emailGroup` dictionary. We get the name of that account from the input accounts list and append a new list containing the name and sorted emails to the result.\\n\\n# Complexity\\n- Time complexity: $$O(A \\\\log A)$$ where $$A = \\\\sum_{i=1}^n |accounts[i]|$$ is the total number of emails.\\n- Space complexity: $$O(A)$$ where $$A = \\\\sum_{i=1}^n |accounts[i]|$$ is the total number of emails.\\n\\n# Code\\n```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.par = [i for i in range(n)] # initialize parent array\\n        self.rank = [1] * n # initialize rank array\\n    \\n    def find(self, x):\\n        # find the root of x using path compression\\n        while x != self.par[x]:\\n            self.par[x] = self.par[self.par[x]]\\n            x = self.par[x]\\n        return x\\n    \\n    def union(self, x1, x2):\\n        # merge two sets using union by rank\\n        p1, p2 = self.find(x1), self.find(x2)\\n        if p1 == p2:\\n            return False\\n        if self.rank[p1] > self.rank[p2]:\\n            self.par[p2] = p1\\n            self.rank[p1] += self.rank[p2]\\n        else:\\n            self.par[p1] = p2\\n            self.rank[p2] += self.rank[p1]\\n        return True\\n\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        uf = UnionFind(len(accounts)) # create UnionFind instance\\n        emailToAcc = {} # email -> index of acc\\n\\n        for i, a in enumerate(accounts):\\n            for e in a[1:]:\\n                if e in emailToAcc:\\n                    uf.union(i, emailToAcc[e]) # union accounts with common email\\n                else:\\n                    emailToAcc[e] = i\\n\\n        emailGroup = defaultdict(list) # index of acc -> list of emails\\n        for e, i in emailToAcc.items():\\n            leader = uf.find(i) # find leader of account index\\n            emailGroup[leader].append(e) # append email to leader\\'s list of emails\\n\\n        res = []\\n        for i, emails in emailGroup.items():\\n            name = accounts[i][0] # get account name\\n            res.append([name] + sorted(emailGroup[i])) # append name and sorted emails to result\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.par = [i for i in range(n)] # initialize parent array\\n        self.rank = [1] * n # initialize rank array\\n    \\n    def find(self, x):\\n        # find the root of x using path compression\\n        while x != self.par[x]:\\n            self.par[x] = self.par[self.par[x]]\\n            x = self.par[x]\\n        return x\\n    \\n    def union(self, x1, x2):\\n        # merge two sets using union by rank\\n        p1, p2 = self.find(x1), self.find(x2)\\n        if p1 == p2:\\n            return False\\n        if self.rank[p1] > self.rank[p2]:\\n            self.par[p2] = p1\\n            self.rank[p1] += self.rank[p2]\\n        else:\\n            self.par[p1] = p2\\n            self.rank[p2] += self.rank[p1]\\n        return True\\n\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        uf = UnionFind(len(accounts)) # create UnionFind instance\\n        emailToAcc = {} # email -> index of acc\\n\\n        for i, a in enumerate(accounts):\\n            for e in a[1:]:\\n                if e in emailToAcc:\\n                    uf.union(i, emailToAcc[e]) # union accounts with common email\\n                else:\\n                    emailToAcc[e] = i\\n\\n        emailGroup = defaultdict(list) # index of acc -> list of emails\\n        for e, i in emailToAcc.items():\\n            leader = uf.find(i) # find leader of account index\\n            emailGroup[leader].append(e) # append email to leader\\'s list of emails\\n\\n        res = []\\n        for i, emails in emailGroup.items():\\n            name = accounts[i][0] # get account name\\n            res.append([name] + sorted(emailGroup[i])) # append name and sorted emails to result\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744992,
                "title": "c-dsu-union-by-size-unordered-map-easy-solution-concise-solution",
                "content": "```\\nclass DisjointSet{\\n    vector<int> rank,parent,size;\\npublic:\\n    DisjointSet(int n){\\n        rank.resize(n+1,0);\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for(int i=0;i<=n;i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node){\\n        if(node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u,int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v) return;\\n        if(rank[ulp_u] < rank[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]){\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u,int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v) return;\\n        if(rank[ulp_u] < rank[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        DisjointSet ds(n);\\n    \\n        unordered_map<string,int> mapMailNode;\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<accounts[i].size();j++){\\n                string mail = accounts[i][j];\\n                if(mapMailNode.find(mail) == mapMailNode.end()){\\n                    mapMailNode[mail] = i;\\n                }\\n                else{\\n                    ds.unionBySize(i, mapMailNode[mail]);\\n                }\\n            }\\n        }\\n        vector<string> mergedMail[n];\\n        for(auto it: mapMailNode){\\n            string mail = it.first;\\n            int node  = ds.findUPar(it.second);\\n            mergedMail[node].push_back(mail);\\n        }\\n        vector<vector<string>> ans;\\n        for(int i=0;i<n;i++){\\n            if(mergedMail[i].size() == 0) continue;\\n            sort(mergedMail[i].begin(),mergedMail[i].end());\\n            vector<string> temp;\\n            temp.push_back(accounts[i][0]);\\n            for(auto it: mergedMail[i]){\\n                temp.push_back(it);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet{\\n    vector<int> rank,parent,size;\\npublic:\\n    DisjointSet(int n){\\n        rank.resize(n+1,0);\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for(int i=0;i<=n;i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node){\\n        if(node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u,int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v) return;\\n        if(rank[ulp_u] < rank[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]){\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u,int v){\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if(ulp_u == ulp_v) return;\\n        if(rank[ulp_u] < rank[ulp_v]){\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n\\n};\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        DisjointSet ds(n);\\n    \\n        unordered_map<string,int> mapMailNode;\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<accounts[i].size();j++){\\n                string mail = accounts[i][j];\\n                if(mapMailNode.find(mail) == mapMailNode.end()){\\n                    mapMailNode[mail] = i;\\n                }\\n                else{\\n                    ds.unionBySize(i, mapMailNode[mail]);\\n                }\\n            }\\n        }\\n        vector<string> mergedMail[n];\\n        for(auto it: mapMailNode){\\n            string mail = it.first;\\n            int node  = ds.findUPar(it.second);\\n            mergedMail[node].push_back(mail);\\n        }\\n        vector<vector<string>> ans;\\n        for(int i=0;i<n;i++){\\n            if(mergedMail[i].size() == 0) continue;\\n            sort(mergedMail[i].begin(),mergedMail[i].end());\\n            vector<string> temp;\\n            temp.push_back(accounts[i][0]);\\n            for(auto it: mergedMail[i]){\\n                temp.push_back(it);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2002881,
                "title": "java-union-find-with-thorough-explanation-beats-82-but-easy-to-follow",
                "content": "```\\nclass Solution {\\n    class UnionFind {\\n        int[] parents;\\n\\n        UnionFind(int size) {\\n            parents = new int[size];\\n            for (int i = 0; i < parents.length; i++) {\\n                parents[i] = i;\\n            }\\n        }\\n\\n        int find(int node) {\\n            while (parents[node] != node)\\n                node = parents[node];\\n\\n            return node;\\n        }\\n\\n        void union(int firstNode, int secondNode) {\\n            int firstParent = find(firstNode);\\n            int secondParent = find(secondNode);\\n\\n            if (firstParent == secondParent)\\n                return;\\n\\n            parents[firstParent] = secondParent;\\n        }\\n    }\\n\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n\\n        /**\\n         * Union Find\\n         * since the problem describes a connection between an account and emails\\n         * and we want to merge the accounts, this seems like a good candidate for union\\n         * find.\\n         * \\n         * The issue becomes how to transfer the email to an integer to be used in union\\n         * find. Actually, we need to use the accounts instead of emails since the merge will happen on the\\n         * account level not the email level.\\n         * \\n         * To do so, each account will get an account id equal to its index in accounts array\\n         * \\n         * Now, we need to loop through all emails, mapping them to account id,\\n         * if we find an email that we have seen before, we union the two account ids\\n         * \\n         * No since we have unioned the account, we need to loop through the account again\\n         * and merge the emails into the final parent account of all merged accounts\\n         * here we can add the emails to TreeSet to be sorted on the fly\\n         * \\n         * Finally we need to create the final result list, adding the account owner name to\\n         * the beginning of the list\\n         */\\n        Map<String, Integer> emailToAccount = new HashMap<>();\\n        UnionFind unionFind = new UnionFind(accounts.size());\\n\\n        // mapping emails to account, if an email has been seen before, union the two\\n        // accounts together\\n        for (int i = 0; i < accounts.size(); i++) {\\n            List<String> account = accounts.get(i);\\n            int accountId = i;\\n            for (int j = 1; j < account.size(); j++) {\\n                String email = account.get(j);\\n                if (emailToAccount.containsKey(email)) {\\n                    // if we have seen an email before in a different account, we union these two\\n                    // accounts\\n                    int previousAccount = emailToAccount.get(email);\\n                    unionFind.union(accountId, previousAccount);\\n                    continue;\\n                } else {\\n                    emailToAccount.put(email, accountId);\\n                }\\n            }\\n        }\\n\\n        // map each account to its emails after merging, sort the emails while doing so\\n        Map<Integer, TreeSet<String>> accountEmails = new HashMap<>();\\n        for (int i = 0; i < accounts.size(); i++) {\\n            int accountId = i;\\n            int accountParent = unionFind.find(accountId);\\n            List<String> emails = accounts.get(accountId).subList(1, accounts.get(accountId).size());\\n            if (accountEmails.containsKey(accountParent)) {\\n                accountEmails.get(accountParent).addAll(emails);\\n            } else {\\n                TreeSet<String> sortedEmails = new TreeSet<>();\\n                sortedEmails.addAll(emails);\\n                accountEmails.put(accountParent, sortedEmails);\\n            }\\n        }\\n\\n        // create the final result list\\n        List<List<String>> result = new ArrayList<>();\\n        for (int accountId : accountEmails.keySet()) {\\n            List<String> sortedAccountEmails = new ArrayList<>();\\n            sortedAccountEmails.add(accounts.get(accountId).get(0));\\n            sortedAccountEmails.addAll(accountEmails.get(accountId));\\n            result.add(sortedAccountEmails);\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class UnionFind {\\n        int[] parents;\\n\\n        UnionFind(int size) {\\n            parents = new int[size];\\n            for (int i = 0; i < parents.length; i++) {\\n                parents[i] = i;\\n            }\\n        }\\n\\n        int find(int node) {\\n            while (parents[node] != node)\\n                node = parents[node];\\n\\n            return node;\\n        }\\n\\n        void union(int firstNode, int secondNode) {\\n            int firstParent = find(firstNode);\\n            int secondParent = find(secondNode);\\n\\n            if (firstParent == secondParent)\\n                return;\\n\\n            parents[firstParent] = secondParent;\\n        }\\n    }\\n\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n\\n        /**\\n         * Union Find\\n         * since the problem describes a connection between an account and emails\\n         * and we want to merge the accounts, this seems like a good candidate for union\\n         * find.\\n         * \\n         * The issue becomes how to transfer the email to an integer to be used in union\\n         * find. Actually, we need to use the accounts instead of emails since the merge will happen on the\\n         * account level not the email level.\\n         * \\n         * To do so, each account will get an account id equal to its index in accounts array\\n         * \\n         * Now, we need to loop through all emails, mapping them to account id,\\n         * if we find an email that we have seen before, we union the two account ids\\n         * \\n         * No since we have unioned the account, we need to loop through the account again\\n         * and merge the emails into the final parent account of all merged accounts\\n         * here we can add the emails to TreeSet to be sorted on the fly\\n         * \\n         * Finally we need to create the final result list, adding the account owner name to\\n         * the beginning of the list\\n         */\\n        Map<String, Integer> emailToAccount = new HashMap<>();\\n        UnionFind unionFind = new UnionFind(accounts.size());\\n\\n        // mapping emails to account, if an email has been seen before, union the two\\n        // accounts together\\n        for (int i = 0; i < accounts.size(); i++) {\\n            List<String> account = accounts.get(i);\\n            int accountId = i;\\n            for (int j = 1; j < account.size(); j++) {\\n                String email = account.get(j);\\n                if (emailToAccount.containsKey(email)) {\\n                    // if we have seen an email before in a different account, we union these two\\n                    // accounts\\n                    int previousAccount = emailToAccount.get(email);\\n                    unionFind.union(accountId, previousAccount);\\n                    continue;\\n                } else {\\n                    emailToAccount.put(email, accountId);\\n                }\\n            }\\n        }\\n\\n        // map each account to its emails after merging, sort the emails while doing so\\n        Map<Integer, TreeSet<String>> accountEmails = new HashMap<>();\\n        for (int i = 0; i < accounts.size(); i++) {\\n            int accountId = i;\\n            int accountParent = unionFind.find(accountId);\\n            List<String> emails = accounts.get(accountId).subList(1, accounts.get(accountId).size());\\n            if (accountEmails.containsKey(accountParent)) {\\n                accountEmails.get(accountParent).addAll(emails);\\n            } else {\\n                TreeSet<String> sortedEmails = new TreeSet<>();\\n                sortedEmails.addAll(emails);\\n                accountEmails.put(accountParent, sortedEmails);\\n            }\\n        }\\n\\n        // create the final result list\\n        List<List<String>> result = new ArrayList<>();\\n        for (int accountId : accountEmails.keySet()) {\\n            List<String> sortedAccountEmails = new ArrayList<>();\\n            sortedAccountEmails.add(accounts.get(accountId).get(0));\\n            sortedAccountEmails.addAll(accountEmails.get(accountId));\\n            result.add(sortedAccountEmails);\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524767,
                "title": "python-dfs-recursive",
                "content": "```\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        adjacent = defaultdict(set)\\n        to_name = {}\\n        \\n        for acc in accounts: # (1)\\n            name = acc[0]\\n            for email in acc[1:]:\\n                adjacent[acc[1]].add(email)\\n                adjacent[email].add(acc[1])\\n                to_name[email] = name\\n            \\n        visited = set()\\n        \\n        def dfs(node):\\n            if node in visited:\\n                return []\\n            \\n            visited.add(node)\\n            components = [node]\\n            \\n            for v in adjacent[node]:\\n                components.extend(dfs(v))\\n            \\n            return components\\n        \\n        result = []\\n        \\n        for email in adjacent:\\n            if email not in visited:\\n                name = to_name[email]\\n                result.append([name] + sorted(dfs(email))) # (2)\\n        \\n        return result\\n    \\n    # (KEY IDEA) This problem sounds like we should be finding connections, so think of connected components. We can\\'t use an account name to determine overlaps, because several accounts can have the same name. Instead, we focus on the emails. For each account, we can draw an undirected line between the first email to the rest of the emails. Then, we can see if any of the accounts overlap in emails by finding all the connected components.\\n    # (1) Draw an undirected line between first email to the rest of the emails.\\n    # (2) Find all connected components associated with this account name.\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        adjacent = defaultdict(set)\\n        to_name = {}\\n        \\n        for acc in accounts: # (1)\\n            name = acc[0]\\n            for email in acc[1:]:\\n                adjacent[acc[1]].add(email)\\n                adjacent[email].add(acc[1])\\n                to_name[email] = name\\n            \\n        visited = set()\\n        \\n        def dfs(node):\\n            if node in visited:\\n                return []\\n            \\n            visited.add(node)\\n            components = [node]\\n            \\n            for v in adjacent[node]:\\n                components.extend(dfs(v))\\n            \\n            return components\\n        \\n        result = []\\n        \\n        for email in adjacent:\\n            if email not in visited:\\n                name = to_name[email]\\n                result.append([name] + sorted(dfs(email))) # (2)\\n        \\n        return result\\n    \\n    # (KEY IDEA) This problem sounds like we should be finding connections, so think of connected components. We can\\'t use an account name to determine overlaps, because several accounts can have the same name. Instead, we focus on the emails. For each account, we can draw an undirected line between the first email to the rest of the emails. Then, we can see if any of the accounts overlap in emails by finding all the connected components.\\n    # (1) Draw an undirected line between first email to the rest of the emails.\\n    # (2) Find all connected components associated with this account name.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137156,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<Integer, Set<String>> emailToAccounts = new HashMap<>();\\n        Map<String, Integer> emailGroup = new HashMap<>();\\n        \\n        for (int i = 0; i < accounts.size(); i++) {\\n            int accountId = i;\\n            List<String> accountDetails = accounts.get(accountId);\\n            emailToAccounts.computeIfAbsent(accountId, k -> new HashSet<>());\\n            \\n            for (int j = 1; j < accountDetails.size(); j++) {\\n                String email = accountDetails.get(j);\\n                \\n                if (emailGroup.containsKey(email) && emailGroup.get(email) != accountId) {\\n                    int prevAccountId = emailGroup.get(email);\\n                    \\n                    emailToAccounts.get(accountId).addAll(emailToAccounts.get(prevAccountId));\\n                    \\n                    for (String e : emailToAccounts.get(prevAccountId)) {\\n                        emailGroup.put(e, accountId);\\n                    }\\n                }\\n                \\n                emailGroup.put(email, accountId);\\n                emailToAccounts.get(accountId).add(email);\\n            }\\n        }\\n        \\n        emailToAccounts.clear();\\n        for (Map.Entry<String, Integer> entry : emailGroup.entrySet()) {\\n            int accountId = entry.getValue();\\n            String email = entry.getKey();\\n            emailToAccounts.computeIfAbsent(accountId, \\n                                            k -> new TreeSet<>(\\n                                                (a, b) -> a.compareTo(b)\\n                                            ));\\n            \\n            emailToAccounts.get(accountId).add(email);\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        for (Map.Entry<Integer, Set<String>> entry : emailToAccounts.entrySet()) {\\n            int accountId = entry.getKey();\\n            Set<String> emails = entry.getValue();\\n            String name = accounts.get(accountId).get(0);\\n           \\n            List<String> list = new ArrayList<>();\\n            list.add(name);\\n            list.addAll(emails);\\n            \\n            ans.add(list);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<Integer, Set<String>> emailToAccounts = new HashMap<>();\\n        Map<String, Integer> emailGroup = new HashMap<>();\\n        \\n        for (int i = 0; i < accounts.size(); i++) {\\n            int accountId = i;\\n            List<String> accountDetails = accounts.get(accountId);\\n            emailToAccounts.computeIfAbsent(accountId, k -> new HashSet<>());\\n            \\n            for (int j = 1; j < accountDetails.size(); j++) {\\n                String email = accountDetails.get(j);\\n                \\n                if (emailGroup.containsKey(email) && emailGroup.get(email) != accountId) {\\n                    int prevAccountId = emailGroup.get(email);\\n                    \\n                    emailToAccounts.get(accountId).addAll(emailToAccounts.get(prevAccountId));\\n                    \\n                    for (String e : emailToAccounts.get(prevAccountId)) {\\n                        emailGroup.put(e, accountId);\\n                    }\\n                }\\n                \\n                emailGroup.put(email, accountId);\\n                emailToAccounts.get(accountId).add(email);\\n            }\\n        }\\n        \\n        emailToAccounts.clear();\\n        for (Map.Entry<String, Integer> entry : emailGroup.entrySet()) {\\n            int accountId = entry.getValue();\\n            String email = entry.getKey();\\n            emailToAccounts.computeIfAbsent(accountId, \\n                                            k -> new TreeSet<>(\\n                                                (a, b) -> a.compareTo(b)\\n                                            ));\\n            \\n            emailToAccounts.get(accountId).add(email);\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        for (Map.Entry<Integer, Set<String>> entry : emailToAccounts.entrySet()) {\\n            int accountId = entry.getKey();\\n            Set<String> emails = entry.getValue();\\n            String name = accounts.get(accountId).get(0);\\n           \\n            List<String> list = new ArrayList<>();\\n            list.add(name);\\n            list.addAll(emails);\\n            \\n            ans.add(list);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041575,
                "title": "union-find-ruby",
                "content": "```\\ndef accounts_merge(accounts)\\n  @parents = {}\\n  @email_to_name = {}\\n  \\n  accounts.each do |name, *emails|\\n    emails.each do |email|\\n      @email_to_name[email] = name\\n      @parents[email] = email unless @parents[email]\\n      union(emails[0], email)\\n    end\\n  end\\n  # p @parents\\n  # p @email_to_name\\n  @emails = {}\\n  \\n  @parents.keys.each do |email|\\n    parent = find(email)\\n    @emails[parent] = @emails[parent] ? @emails[parent].push(email) : [email]\\n  end\\n  \\n  # p @emails\\n  @emails.map do |p_email, emails|\\n    [@email_to_name[p_email], *emails.sort]\\n  end\\nend\\n\\ndef union(u, v)\\n  p1 = find(u)\\n  p2 = find(v)\\n  @parents[p2] = p1\\nend\\n\\ndef find(x)\\n  return x if @parents[x] == x\\n  @parents[x] = find(@parents[x])\\n  @parents[x]\\nend",
                "solutionTags": [
                    "Ruby",
                    "Union Find"
                ],
                "code": "```\\ndef accounts_merge(accounts)\\n  @parents = {}\\n  @email_to_name = {}\\n  \\n  accounts.each do |name, *emails|\\n    emails.each do |email|\\n      @email_to_name[email] = name\\n      @parents[email] = email unless @parents[email]\\n      union(emails[0], email)\\n    end\\n  end\\n  # p @parents\\n  # p @email_to_name\\n  @emails = {}\\n  \\n  @parents.keys.each do |email|\\n    parent = find(email)\\n    @emails[parent] = @emails[parent] ? @emails[parent].push(email) : [email]\\n  end\\n  \\n  # p @emails\\n  @emails.map do |p_email, emails|\\n    [@email_to_name[p_email], *emails.sort]\\n  end\\nend\\n\\ndef union(u, v)\\n  p1 = find(u)\\n  p2 = find(v)\\n  @parents[p2] = p1\\nend\\n\\ndef find(x)\\n  return x if @parents[x] == x\\n  @parents[x] = find(@parents[x])\\n  @parents[x]\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 1039509,
                "title": "c-clean-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, vector<string>> adj;\\n    \\n    void dfs(unordered_set<string> &vis, string s, vector<string> &abc){\\n        if(vis.find(s)!=vis.end())\\n            return;\\n        vis.insert(s);\\n        abc.push_back(s);\\n        \\n        for(int i=0;i<adj[s].size();i++){\\n            dfs(vis, adj[s][i], abc);\\n        } \\n    }\\n\\t\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string, string> m;\\n        vector<vector<string>> ans;\\n        for(int i=0;i<accounts.size();i++){\\n            for(int j=1;j<accounts[i].size();j++){\\n               adj[accounts[i][1]].push_back(accounts[i][j]);\\n               adj[accounts[i][j]].push_back(accounts[i][1]);\\n               m[accounts[i][j]]=accounts[i][0];\\n           }\\n        }\\n        unordered_set<string> vis;\\n        for(int i=0;i<accounts.size();i++){\\n            for(int j=1;j<accounts[i].size();j++){\\n                if(vis.find(accounts[i][j])==vis.end()){\\n                    vector<string> abc;\\n                    dfs(vis, accounts[i][j], abc);\\n                    sort(abc.begin(), abc.end());\\n                    abc.insert(abc.begin(), m[accounts[i][j]]);\\n                    ans.push_back(abc);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, vector<string>> adj;\\n    \\n    void dfs(unordered_set<string> &vis, string s, vector<string> &abc){\\n        if(vis.find(s)!=vis.end())\\n            return;\\n        vis.insert(s);\\n        abc.push_back(s);\\n        \\n        for(int i=0;i<adj[s].size();i++){\\n            dfs(vis, adj[s][i], abc);\\n        } \\n    }\\n\\t\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string, string> m;\\n        vector<vector<string>> ans;\\n        for(int i=0;i<accounts.size();i++){\\n            for(int j=1;j<accounts[i].size();j++){\\n               adj[accounts[i][1]].push_back(accounts[i][j]);\\n               adj[accounts[i][j]].push_back(accounts[i][1]);\\n               m[accounts[i][j]]=accounts[i][0];\\n           }\\n        }\\n        unordered_set<string> vis;\\n        for(int i=0;i<accounts.size();i++){\\n            for(int j=1;j<accounts[i].size();j++){\\n                if(vis.find(accounts[i][j])==vis.end()){\\n                    vector<string> abc;\\n                    dfs(vis, accounts[i][j], abc);\\n                    sort(abc.begin(), abc.end());\\n                    abc.insert(abc.begin(), m[accounts[i][j]]);\\n                    ans.push_back(abc);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 732743,
                "title": "javascript-solution-graph-iterative-dfs-with-comments",
                "content": "```/**\\n * @param {string[][]} accounts\\n * @return {string[][]}\\n */\\nvar accountsMerge = function(accounts) {\\n    if(!accounts.length) {\\n        return [];\\n    }\\n\\n    // Create a Map of <Email --> Username>\\n    const emailToNameMap = new Map();   \\n    accounts.forEach((account) => {\\n       const name = account[0];\\n        for(let i = 1; i < account.length; i++) {\\n            emailToNameMap.set(account[i], name);\\n        }\\n    });\\n    \\n    // construct the graph using accounts (items 1..n are emails)\\n    // add an edge between 1st email (account[1]) with rest of the emails & vice versa\\n    const graph = new Map();\\n    accounts.forEach(account => {\\n        const firstNode = account[1];\\n        let firstNodeNeighbors = [];\\n        if(graph.has(firstNode)) {\\n            firstNodeNeighbors = graph.get(firstNode);\\n        }\\n        for(let i = 2; i < account.length; i++) {\\n            firstNodeNeighbors.push(account[i]);\\n            let currrentNodeNeighbours = graph.get(account[i]) || [];\\n            currrentNodeNeighbours.push(firstNode);\\n            graph.set(account[i], currrentNodeNeighbours);\\n        }\\n        graph.set(firstNode, firstNodeNeighbors);\\n    });\\n    \\n    const result = [];\\n    const visited = new Set(); // to keep track of visited nodes\\n    const stack = [];\\n    \\n    graph.forEach((neighbours, email, map) => {\\n        \\n        /* Steps: \\n         if we are visiting a node for first time, \\n          1. then this would form the first entry of this <email>.\\n          2. assign newEntry with this user\\'s name and save this email ID in array.\\n          3. Perform a DFS on this node and find all its connected nodes (emails)\\n          4. Sort the list of emails (nodes) of this connected component\\n          5. Add the [name, <sorted emails>] to final result array\\n        */\\n        if(!visited.has(email)) {\\n            \\n            visited.add(email);\\n            stack.push(email);\\n            \\n            let newEntry = [emailToNameMap.get(email)];\\n            let newEntryEmails = [];\\n\\n            while(stack.length) {\\n                const currentNode = stack.pop();\\n                newEntryEmails.push(currentNode);\\n                \\n                const currentNeighbours = graph.get(currentNode);\\n\\n                for(let neighbour of currentNeighbours) {\\n                    \\n                    if(!visited.has(neighbour)) {\\n                        visited.add(neighbour);\\n                        stack.push(neighbour);\\n                    }\\n                }\\n            }\\n            \\n            newEntryEmails.sort();\\n            newEntry = newEntry.concat(newEntryEmails);\\n            result.push(newEntry); \\n        }\\n    });\\n    \\n    return result;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```/**\\n * @param {string[][]} accounts\\n * @return {string[][]}\\n */\\nvar accountsMerge = function(accounts) {\\n    if(!accounts.length) {\\n        return [];\\n    }\\n\\n    // Create a Map of <Email --> Username>\\n    const emailToNameMap = new Map();   \\n    accounts.forEach((account) => {\\n       const name = account[0];\\n        for(let i = 1; i < account.length; i++) {\\n            emailToNameMap.set(account[i], name);\\n        }\\n    });\\n    \\n    // construct the graph using accounts (items 1..n are emails)\\n    // add an edge between 1st email (account[1]) with rest of the emails & vice versa\\n    const graph = new Map();\\n    accounts.forEach(account => {\\n        const firstNode = account[1];\\n        let firstNodeNeighbors = [];\\n        if(graph.has(firstNode)) {\\n            firstNodeNeighbors = graph.get(firstNode);\\n        }\\n        for(let i = 2; i < account.length; i++) {\\n            firstNodeNeighbors.push(account[i]);\\n            let currrentNodeNeighbours = graph.get(account[i]) || [];\\n            currrentNodeNeighbours.push(firstNode);\\n            graph.set(account[i], currrentNodeNeighbours);\\n        }\\n        graph.set(firstNode, firstNodeNeighbors);\\n    });\\n    \\n    const result = [];\\n    const visited = new Set(); // to keep track of visited nodes\\n    const stack = [];\\n    \\n    graph.forEach((neighbours, email, map) => {\\n        \\n        /* Steps: \\n         if we are visiting a node for first time, \\n          1. then this would form the first entry of this <email>.\\n          2. assign newEntry with this user\\'s name and save this email ID in array.\\n          3. Perform a DFS on this node and find all its connected nodes (emails)\\n          4. Sort the list of emails (nodes) of this connected component\\n          5. Add the [name, <sorted emails>] to final result array\\n        */\\n        if(!visited.has(email)) {\\n            \\n            visited.add(email);\\n            stack.push(email);\\n            \\n            let newEntry = [emailToNameMap.get(email)];\\n            let newEntryEmails = [];\\n\\n            while(stack.length) {\\n                const currentNode = stack.pop();\\n                newEntryEmails.push(currentNode);\\n                \\n                const currentNeighbours = graph.get(currentNode);\\n\\n                for(let neighbour of currentNeighbours) {\\n                    \\n                    if(!visited.has(neighbour)) {\\n                        visited.add(neighbour);\\n                        stack.push(neighbour);\\n                    }\\n                }\\n            }\\n            \\n            newEntryEmails.sort();\\n            newEntry = newEntry.concat(newEntryEmails);\\n            result.push(newEntry); \\n        }\\n    });\\n    \\n    return result;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 694279,
                "title": "java-graph-solution-1-with-comments-added",
                "content": "```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<String, String> emailToName = new HashMap<>();\\n        Map<String, List<String>> graph = new HashMap<>();\\n        \\n        // idea is to create a graph where email are vertices. For a given account,\\n        // create an edge between all the emails in it. Also update emailToName Map\\n        for(List<String> account: accounts){\\n            // for current account, get the name\\n            String name = account.get(0);\\n             \\n            // remaining elements in the account list are emails. Create edges among them\\n            for(int i = 1; i < account.size(); i++){\\n                String firstEmail = account.get(1);\\n                String currentEmail = account.get(i);\\n                \\n                // populate graph\\n                graph.computeIfAbsent(currentEmail, x -> new ArrayList<>()).add(firstEmail);\\n                graph.computeIfAbsent(firstEmail, x -> new ArrayList<>()).add(currentEmail);\\n                \\n                // update emailToName map\\n                emailToName.put(currentEmail, name);\\n            }\\n        }\\n        \\n        // Once we have graph created, problem is reduced to find connected components in this \\n        // graph. We will use DFS to find connected components in graph and add that to answer.\\n        Set<String> seenEmails = new HashSet<>();\\n        \\n        // create result list\\n        List<List<String>> ans = new ArrayList();\\n        \\n        // start DFS\\n        for(String email: graph.keySet()){\\n            if(!seenEmails.contains(email)){\\n                // mark it visited\\n                seenEmails.add(email);\\n                \\n                // For DFS, we will use a Stack\\n                Stack<String> stack = new Stack<>();\\n                stack.push(email);\\n                \\n                // All emails in same component\\n                List<String> connectedComponent = new ArrayList<>();\\n                \\n                while(!stack.isEmpty()){\\n                    String node = stack.pop();\\n                    connectedComponent.add(node);\\n                    \\n                    for(String neigh : graph.get(node)){\\n                        if(!seenEmails.contains(neigh)){\\n                            seenEmails.add(neigh);\\n                            stack.push(neigh);\\n                        }\\n                    }\\n                }\\n                \\n                // add connectedComponent to result\\n                Collections.sort(connectedComponent);\\n                connectedComponent.add(0, emailToName.get(email));\\n                ans.add(connectedComponent);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<String, String> emailToName = new HashMap<>();\\n        Map<String, List<String>> graph = new HashMap<>();\\n        \\n        // idea is to create a graph where email are vertices. For a given account,\\n        // create an edge between all the emails in it. Also update emailToName Map\\n        for(List<String> account: accounts){\\n            // for current account, get the name\\n            String name = account.get(0);\\n             \\n            // remaining elements in the account list are emails. Create edges among them\\n            for(int i = 1; i < account.size(); i++){\\n                String firstEmail = account.get(1);\\n                String currentEmail = account.get(i);\\n                \\n                // populate graph\\n                graph.computeIfAbsent(currentEmail, x -> new ArrayList<>()).add(firstEmail);\\n                graph.computeIfAbsent(firstEmail, x -> new ArrayList<>()).add(currentEmail);\\n                \\n                // update emailToName map\\n                emailToName.put(currentEmail, name);\\n            }\\n        }\\n        \\n        // Once we have graph created, problem is reduced to find connected components in this \\n        // graph. We will use DFS to find connected components in graph and add that to answer.\\n        Set<String> seenEmails = new HashSet<>();\\n        \\n        // create result list\\n        List<List<String>> ans = new ArrayList();\\n        \\n        // start DFS\\n        for(String email: graph.keySet()){\\n            if(!seenEmails.contains(email)){\\n                // mark it visited\\n                seenEmails.add(email);\\n                \\n                // For DFS, we will use a Stack\\n                Stack<String> stack = new Stack<>();\\n                stack.push(email);\\n                \\n                // All emails in same component\\n                List<String> connectedComponent = new ArrayList<>();\\n                \\n                while(!stack.isEmpty()){\\n                    String node = stack.pop();\\n                    connectedComponent.add(node);\\n                    \\n                    for(String neigh : graph.get(node)){\\n                        if(!seenEmails.contains(neigh)){\\n                            seenEmails.add(neigh);\\n                            stack.push(neigh);\\n                        }\\n                    }\\n                }\\n                \\n                // add connectedComponent to result\\n                Collections.sort(connectedComponent);\\n                connectedComponent.add(0, emailToName.get(email));\\n                ans.add(connectedComponent);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434481,
                "title": "javascript-readable-code-for-humans-graph-dfs",
                "content": "```js\\nvar accountsMerge = function(accounts) {\\n    let graph = {}, emailToName = {}\\n    // build graph between first email in account and the rest.\\n    for(let account of accounts) {\\n        let [name, ...emails] = account\\n        emailToName[emails[0]] = name\\n        for(let email of emails) {\\n            graph[emails[0]] = (graph[emails[0]] || new Set()).add(email)\\n            graph[email] = (graph[email] || new Set()).add(emails[0])\\n        }\\n    }\\n    \\n    // DFS\\n    let seen = {}, answer = []\\n    for(let email of Object.keys(graph)) {\\n        if(!seen[email]) {\\n            let stack = [email]\\n            seen[email] = true\\n            let account = [email]\\n            while(stack.length !==0) {\\n                let start = stack.pop()\\n                for(let item of graph[start]) {\\n                    if(!seen[item]) {\\n                        account.push(item)\\n                        stack.push(item)\\n                        seen[item] = true\\n                    }\\n                }\\n            }\\n            account.sort()\\n            account.unshift(emailToName[email])\\n            answer.push(account)\\n        }\\n    }\\n    return answer\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar accountsMerge = function(accounts) {\\n    let graph = {}, emailToName = {}\\n    // build graph between first email in account and the rest.\\n    for(let account of accounts) {\\n        let [name, ...emails] = account\\n        emailToName[emails[0]] = name\\n        for(let email of emails) {\\n            graph[emails[0]] = (graph[emails[0]] || new Set()).add(email)\\n            graph[email] = (graph[email] || new Set()).add(emails[0])\\n        }\\n    }\\n    \\n    // DFS\\n    let seen = {}, answer = []\\n    for(let email of Object.keys(graph)) {\\n        if(!seen[email]) {\\n            let stack = [email]\\n            seen[email] = true\\n            let account = [email]\\n            while(stack.length !==0) {\\n                let start = stack.pop()\\n                for(let item of graph[start]) {\\n                    if(!seen[item]) {\\n                        account.push(item)\\n                        stack.push(item)\\n                        seen[item] = true\\n                    }\\n                }\\n            }\\n            account.sort()\\n            account.unshift(emailToName[email])\\n            answer.push(account)\\n        }\\n    }\\n    return answer\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 366144,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\n   void merge(vector<vector<string>> &accounts, int index, unordered_map<string,vector<int>> &email2accounts, vector<bool> &visited, unordered_set<string> &email_set) {\\n       visited[index] = true;\\n       email_set.insert(accounts[index].begin()+1, accounts[index].end());\\n       for(int i = 1; i< accounts[index].size(); i++) {\\n           auto indexes = email2accounts[accounts[index][i]];\\n           for (int j: indexes) \\n               if(!visited[j])\\n                   merge(accounts,j,email2accounts,visited, email_set);     \\n       }\\n       return;\\n   } \\n    \\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n      vector<vector<string>> merged_accounts;\\n      unordered_map<string, vector<int>> email2accounts;\\n      vector<bool> visited(accounts.size(),false);\\n        \\n      for(int i = 0; i < accounts.size(); i++) \\n         for(int j = 1; j< accounts[i].size(); j++) \\n             email2accounts[accounts[i][j]].push_back(i); \\n  \\n      for(int i =0; i< accounts.size(); i++) \\n          if(!visited[i]) {\\n              unordered_set<string> email_set;\\n              vector<string> account{accounts[i][0]};\\n              merge(accounts, i,email2accounts, visited, email_set);\\n              account.insert(account.end(), email_set.begin(), email_set.end());\\n              sort(account.begin()+1, account.end());\\n              merged_accounts.push_back(account);\\n          }   \\n        \\n      return merged_accounts;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   void merge(vector<vector<string>> &accounts, int index, unordered_map<string,vector<int>> &email2accounts, vector<bool> &visited, unordered_set<string> &email_set) {\\n       visited[index] = true;\\n       email_set.insert(accounts[index].begin()+1, accounts[index].end());\\n       for(int i = 1; i< accounts[index].size(); i++) {\\n           auto indexes = email2accounts[accounts[index][i]];\\n           for (int j: indexes) \\n               if(!visited[j])\\n                   merge(accounts,j,email2accounts,visited, email_set);     \\n       }\\n       return;\\n   } \\n    \\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n      vector<vector<string>> merged_accounts;\\n      unordered_map<string, vector<int>> email2accounts;\\n      vector<bool> visited(accounts.size(),false);\\n        \\n      for(int i = 0; i < accounts.size(); i++) \\n         for(int j = 1; j< accounts[i].size(); j++) \\n             email2accounts[accounts[i][j]].push_back(i); \\n  \\n      for(int i =0; i< accounts.size(); i++) \\n          if(!visited[i]) {\\n              unordered_set<string> email_set;\\n              vector<string> account{accounts[i][0]};\\n              merge(accounts, i,email2accounts, visited, email_set);\\n              account.insert(account.end(), email_set.begin(), email_set.end());\\n              sort(account.begin()+1, account.end());\\n              merged_accounts.push_back(account);\\n          }   \\n        \\n      return merged_accounts;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 344724,
                "title": "python-simple-intuitive-solution",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        self.root = [i for i in xrange(len(accounts))]\\n        email_to_id = {}\\n        id_to_name = {}\\n        for i,account in enumerate(accounts):\\n            id_to_name[i] = account[0]\\n            for email in account[1:]:\\n                if not email in email_to_id:\\n                    email_to_id[email] = i\\n                else:\\n                    self.union(i,email_to_id[email])\\n                    \\n        id_to_emailSet = defaultdict(set)\\n        for account in accounts:\\n            for email in account[1:]:\\n                root_id = self.find(email_to_id[email])\\n                id_to_emailSet[root_id].add(email)\\n        \\n        res = []\\n        for i,email_set in id_to_emailSet.items():\\n            res.append([id_to_name[i]] + sorted(list(email_set)))\\n        \\n        return res\\n    \\n    def union(self,i,idx):\\n        self.root[self.find(idx)] = self.find(i)\\n    \\n    def find(self,i):\\n        path = []\\n        while i != self.root[i]:\\n            path.append(i)\\n            i = self.root[i]\\n        ans = i\\n        while path:\\n            idx = path.pop()\\n            self.root[idx] = ans\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        self.root = [i for i in xrange(len(accounts))]\\n        email_to_id = {}\\n        id_to_name = {}\\n        for i,account in enumerate(accounts):\\n            id_to_name[i] = account[0]\\n            for email in account[1:]:\\n                if not email in email_to_id:\\n                    email_to_id[email] = i\\n                else:\\n                    self.union(i,email_to_id[email])\\n                    \\n        id_to_emailSet = defaultdict(set)\\n        for account in accounts:\\n            for email in account[1:]:\\n                root_id = self.find(email_to_id[email])\\n                id_to_emailSet[root_id].add(email)\\n        \\n        res = []\\n        for i,email_set in id_to_emailSet.items():\\n            res.append([id_to_name[i]] + sorted(list(email_set)))\\n        \\n        return res\\n    \\n    def union(self,i,idx):\\n        self.root[self.find(idx)] = self.find(i)\\n    \\n    def find(self,i):\\n        path = []\\n        while i != self.root[i]:\\n            path.append(i)\\n            i = self.root[i]\\n        ans = i\\n        while path:\\n            idx = path.pop()\\n            self.root[idx] = ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109176,
                "title": "how-did-the-sorting-work",
                "content": "How did the sorting work?\\n\\nFor the example, it has the following:\\n\\nInput: \\n```accounts = [[\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], [\"John\", \"johnnybravo@mail.com\"], [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"], [\"Mary\", \"mary@mail.com\"]]```\\nOutput: ```[[\"John\", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  [\"John\", \"johnnybravo@mail.com\"], [\"Mary\", \"mary@mail.com\"]]```\\n\\nIn the input, the \"johnsmith\" email address is listed first, but in the output, that address is listed last. Am I missing something here?",
                "solutionTags": [],
                "code": "```accounts = [[\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], [\"John\", \"johnnybravo@mail.com\"], [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"], [\"Mary\", \"mary@mail.com\"]]```\n```[[\"John\", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  [\"John\", \"johnnybravo@mail.com\"], [\"Mary\", \"mary@mail.com\"]]```",
                "codeTag": "Unknown"
            },
            {
                "id": 3548047,
                "title": "using-graphs-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &g,int s,vector<int> &st,vector<bool> &vis)\\n    {\\n        vis[s]=true;\\n        st.push_back(s);\\n        for(auto i:g[s])\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(g,i,st,vis);\\n            }\\n        }\\n\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& a) {\\n        sort(a.begin(),a.end());\\n        vector<vector<string>> ans;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i;\\n            while(j<n&&a[j][0]==a[i][0])\\n            {\\n                j++;\\n            }\\n            if(j==n)\\n            {\\n                j--;\\n            }\\n            if(j<n&&a[j][0]!=a[i][0])\\n            {\\n                j--;\\n            }\\n            int m=1;\\n            unordered_map<string,int> mp;\\n            unordered_map<int ,string> mp1;\\n            for(int k=i;k<=j;k++)\\n            {\\n                int z=a[k].size();\\n                \\n                for(int l=1;l<z;l++){\\n                    if(mp.find(a[k][l])==mp.end())\\n                    {\\n                        mp[a[k][l]]=m;\\n                        mp1[m]=a[k][l];\\n                        m++;\\n                    }\\n                }\\n            }\\n            vector<vector<int>> g(m);\\n            for(int k=i;k<=j;k++)\\n            {\\n                int z=a[k].size();\\n                \\n                for(int l=1;l<z-1;l++){\\n                    int u=mp[a[k][l]];\\n                    int v=mp[a[k][l+1]];\\n                    g[v].push_back(u);\\n                    g[u].push_back(v);\\n                }\\n            }\\n            vector<bool> vis(m,false);\\n            for(int k=1;k<m;k++)\\n            {\\n                if(!vis[k])\\n                {\\n                    vector<int> st;\\n                    dfs(g,k,st,vis);\\n                    vector<string> mt(st.size()+1);\\n                    mt[0]=a[i][0];\\n                    for(int l=0;l<st.size();l++)\\n                    {\\n                        mt[l+1]=mp1[st[l]];\\n                    }\\n                    cout<<st.size()<<endl;\\n                    sort(mt.begin()+1,mt.end());\\n                    ans.push_back(mt);\\n                }\\n            }\\n            i=j;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &g,int s,vector<int> &st,vector<bool> &vis)\\n    {\\n        vis[s]=true;\\n        st.push_back(s);\\n        for(auto i:g[s])\\n        {\\n            if(!vis[i])\\n            {\\n                dfs(g,i,st,vis);\\n            }\\n        }\\n\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& a) {\\n        sort(a.begin(),a.end());\\n        vector<vector<string>> ans;\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i;\\n            while(j<n&&a[j][0]==a[i][0])\\n            {\\n                j++;\\n            }\\n            if(j==n)\\n            {\\n                j--;\\n            }\\n            if(j<n&&a[j][0]!=a[i][0])\\n            {\\n                j--;\\n            }\\n            int m=1;\\n            unordered_map<string,int> mp;\\n            unordered_map<int ,string> mp1;\\n            for(int k=i;k<=j;k++)\\n            {\\n                int z=a[k].size();\\n                \\n                for(int l=1;l<z;l++){\\n                    if(mp.find(a[k][l])==mp.end())\\n                    {\\n                        mp[a[k][l]]=m;\\n                        mp1[m]=a[k][l];\\n                        m++;\\n                    }\\n                }\\n            }\\n            vector<vector<int>> g(m);\\n            for(int k=i;k<=j;k++)\\n            {\\n                int z=a[k].size();\\n                \\n                for(int l=1;l<z-1;l++){\\n                    int u=mp[a[k][l]];\\n                    int v=mp[a[k][l+1]];\\n                    g[v].push_back(u);\\n                    g[u].push_back(v);\\n                }\\n            }\\n            vector<bool> vis(m,false);\\n            for(int k=1;k<m;k++)\\n            {\\n                if(!vis[k])\\n                {\\n                    vector<int> st;\\n                    dfs(g,k,st,vis);\\n                    vector<string> mt(st.size()+1);\\n                    mt[0]=a[i][0];\\n                    for(int l=0;l<st.size();l++)\\n                    {\\n                        mt[l+1]=mp1[st[l]];\\n                    }\\n                    cout<<st.size()<<endl;\\n                    sort(mt.begin()+1,mt.end());\\n                    ans.push_back(mt);\\n                }\\n            }\\n            i=j;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2821905,
                "title": "concise-union-find-c",
                "content": "```\\nclass Solution {\\n    int findPar(int node, vector<int> &prnt) {\\n        if(prnt[node] == node) return node;\\n        return prnt[node] = findPar(prnt[node], prnt);\\n    }\\n\\n    void unionn(int u, int v, vector<int> &rank, vector<int> &prnt) {\\n        u = findPar(u, prnt), v = findPar(v, prnt);\\n\\n        if(rank[u] < rank[v]) prnt[u] = v;\\n        else if(rank[u] > rank[v]) prnt[v] = u;\\n        else prnt[v] = u, rank[u]++;\\n    }\\n\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n\\n        vector<int> rank(n, 0), prnt(n);\\n        for(int i=0; i<n; i++) prnt[i] = i;\\n\\n        unordered_map<string, int> em;\\n        for(int i=0; i<n; i++) {\\n            for(int j=1; j<accounts[i].size(); j++) {\\n                if(em.find(accounts[i][j]) == em.end())  em[accounts[i][j]] = i;\\n                else unionn(em[accounts[i][j]], i, rank, prnt);\\n            }\\n        }\\n        vector<set<string>> merge(n);\\n        for(auto i : em) merge[findPar(i.second, prnt)].insert(i.first);\\n        \\n        vector<vector<string>> ans;\\n        for(int i=0; i<n; i++){\\n            if(!merge[i].size()) continue;\\n            \\n            vector<string> t;\\n            t.push_back(accounts[i][0]);\\n            for(string s : merge[i]) t.push_back(s);\\n            ans.push_back(t);\\n        }\\n\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int findPar(int node, vector<int> &prnt) {\\n        if(prnt[node] == node) return node;\\n        return prnt[node] = findPar(prnt[node], prnt);\\n    }\\n\\n    void unionn(int u, int v, vector<int> &rank, vector<int> &prnt) {\\n        u = findPar(u, prnt), v = findPar(v, prnt);\\n\\n        if(rank[u] < rank[v]) prnt[u] = v;\\n        else if(rank[u] > rank[v]) prnt[v] = u;\\n        else prnt[v] = u, rank[u]++;\\n    }\\n\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n\\n        vector<int> rank(n, 0), prnt(n);\\n        for(int i=0; i<n; i++) prnt[i] = i;\\n\\n        unordered_map<string, int> em;\\n        for(int i=0; i<n; i++) {\\n            for(int j=1; j<accounts[i].size(); j++) {\\n                if(em.find(accounts[i][j]) == em.end())  em[accounts[i][j]] = i;\\n                else unionn(em[accounts[i][j]], i, rank, prnt);\\n            }\\n        }\\n        vector<set<string>> merge(n);\\n        for(auto i : em) merge[findPar(i.second, prnt)].insert(i.first);\\n        \\n        vector<vector<string>> ans;\\n        for(int i=0; i<n; i++){\\n            if(!merge[i].size()) continue;\\n            \\n            vector<string> t;\\n            t.push_back(accounts[i][0]);\\n            for(string s : merge[i]) t.push_back(s);\\n            ans.push_back(t);\\n        }\\n\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2550030,
                "title": "python-construct-graph-and-dfs-easy-implementation",
                "content": "```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        adj = defaultdict(list)\\n        # Build an adjacency list - graph\\n        for emails in accounts:\\n            for i in range(2,len(emails)):\\n                adj[emails[i]].append(emails[i-1])\\n                adj[emails[i-1]].append(emails[i])\\n        \\n        def dfs(email):\\n            seen.add(email)\\n            res = [email]\\n            small = []\\n            for u in adj[email]:\\n                if u not in seen:\\n                    small += dfs(u)\\n            return res + small\\n        \\n        seen = set()\\n        ans = []\\n        # Traverse through the components of graph and combine result\\n        for emails in accounts:\\n            if emails[1] not in seen:\\n                ans.append([emails[0]] + sorted(dfs(emails[1])))\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        adj = defaultdict(list)\\n        # Build an adjacency list - graph\\n        for emails in accounts:\\n            for i in range(2,len(emails)):\\n                adj[emails[i]].append(emails[i-1])\\n                adj[emails[i-1]].append(emails[i])\\n        \\n        def dfs(email):\\n            seen.add(email)\\n            res = [email]\\n            small = []\\n            for u in adj[email]:\\n                if u not in seen:\\n                    small += dfs(u)\\n            return res + small\\n        \\n        seen = set()\\n        ans = []\\n        # Traverse through the components of graph and combine result\\n        for emails in accounts:\\n            if emails[1] not in seen:\\n                ans.append([emails[0]] + sorted(dfs(emails[1])))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450935,
                "title": "js-union-find-and-dfs-comments",
                "content": "**Union Find Solution:**\\n```\\nconst accountsMergeUnionFind = function (accounts) {\\n  const emailOwner = {};\\n  const parents = {};\\n\\n  // Travel up the list of parents for an email until we find the root parent\\n  const findRootParent = (email) => {\\n    if (parents[email] !== email) parents[email] = findRootParent(parents[email]);\\n\\n    return parents[email];\\n  };\\n\\n  // Union the groups by assigning the root parent of email 2\\n  // to be a child of the root parent of email 1\\n  const unionGroup = (email1, email2) => {\\n    parents[findRootParent(email1)] = findRootParent(email2);\\n  };\\n\\n  accounts.forEach(([name, ...emails]) => {\\n    emails.forEach((email) => {\\n      // Set a parent for the email if none exists\\n      if (!parents[email]) parents[email] = email;\\n\\n      emailOwner[email] = name;\\n      // Group emails from the same account together by assigning the same root parent\\n      unionGroup(email, emails[0]);\\n    });\\n  });\\n\\n  const emailGroups = {};\\n  Object.keys(parents).forEach((parent) => {\\n    const rootParent = findRootParent(parent);\\n    if (emailGroups[rootParent]) {\\n      emailGroups[rootParent].push(parent);\\n    } else {\\n      emailGroups[rootParent] = [parent];\\n    }\\n  });\\n\\n  return Object.entries(emailGroups)\\n    .map(([parent, children]) => [emailOwner[parent], ...children.sort()]);\\n};\\n```\\n**Depth First Search Solution:**\\n```\\nconst accountsMergeDfs = function (accounts) {\\n  const visitedAccounts = new Array(accounts.length - 1).fill(false);\\n  const emailAccountsMap = {};\\n  const result = [];\\n\\n  // For each email, create a list of account indexes that have that email\\n  accounts.forEach(([_, ...emails], i) => {\\n    emails.forEach((email) => {\\n      if (emailAccountsMap[email]) {\\n        emailAccountsMap[email].push(i);\\n      } else {\\n        emailAccountsMap[email] = [i];\\n      }\\n    });\\n  });\\n\\n  // Add every email in the account to the merged list,\\n  // and add every email from every account associated with those emails to the merged list\\n  const dfs = (i, mergedEmails) => {\\n    if (visitedAccounts[i] === true) return;\\n    visitedAccounts[i] = true;\\n\\n    const account = accounts[i];\\n    for (let j = 1; j < account.length; j++) {\\n      const email = account[j];\\n\\n      mergedEmails.add(email);\\n\\n      emailAccountsMap[email].forEach((neighbor) => {\\n        dfs(neighbor, mergedEmails);\\n      });\\n    }\\n  };\\n\\n  // For each account, merge the account\\'s emails with any account that share an email\\n  accounts.forEach(([owner, ..._], i) => {\\n    if (visitedAccounts[i]) return;\\n\\n    const mergedEmails = new Set();\\n    dfs(i, mergedEmails);\\n\\n    result.push([owner, ...Array.from(mergedEmails).sort()]);\\n  });\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nconst accountsMergeUnionFind = function (accounts) {\\n  const emailOwner = {};\\n  const parents = {};\\n\\n  // Travel up the list of parents for an email until we find the root parent\\n  const findRootParent = (email) => {\\n    if (parents[email] !== email) parents[email] = findRootParent(parents[email]);\\n\\n    return parents[email];\\n  };\\n\\n  // Union the groups by assigning the root parent of email 2\\n  // to be a child of the root parent of email 1\\n  const unionGroup = (email1, email2) => {\\n    parents[findRootParent(email1)] = findRootParent(email2);\\n  };\\n\\n  accounts.forEach(([name, ...emails]) => {\\n    emails.forEach((email) => {\\n      // Set a parent for the email if none exists\\n      if (!parents[email]) parents[email] = email;\\n\\n      emailOwner[email] = name;\\n      // Group emails from the same account together by assigning the same root parent\\n      unionGroup(email, emails[0]);\\n    });\\n  });\\n\\n  const emailGroups = {};\\n  Object.keys(parents).forEach((parent) => {\\n    const rootParent = findRootParent(parent);\\n    if (emailGroups[rootParent]) {\\n      emailGroups[rootParent].push(parent);\\n    } else {\\n      emailGroups[rootParent] = [parent];\\n    }\\n  });\\n\\n  return Object.entries(emailGroups)\\n    .map(([parent, children]) => [emailOwner[parent], ...children.sort()]);\\n};\\n```\n```\\nconst accountsMergeDfs = function (accounts) {\\n  const visitedAccounts = new Array(accounts.length - 1).fill(false);\\n  const emailAccountsMap = {};\\n  const result = [];\\n\\n  // For each email, create a list of account indexes that have that email\\n  accounts.forEach(([_, ...emails], i) => {\\n    emails.forEach((email) => {\\n      if (emailAccountsMap[email]) {\\n        emailAccountsMap[email].push(i);\\n      } else {\\n        emailAccountsMap[email] = [i];\\n      }\\n    });\\n  });\\n\\n  // Add every email in the account to the merged list,\\n  // and add every email from every account associated with those emails to the merged list\\n  const dfs = (i, mergedEmails) => {\\n    if (visitedAccounts[i] === true) return;\\n    visitedAccounts[i] = true;\\n\\n    const account = accounts[i];\\n    for (let j = 1; j < account.length; j++) {\\n      const email = account[j];\\n\\n      mergedEmails.add(email);\\n\\n      emailAccountsMap[email].forEach((neighbor) => {\\n        dfs(neighbor, mergedEmails);\\n      });\\n    }\\n  };\\n\\n  // For each account, merge the account\\'s emails with any account that share an email\\n  accounts.forEach(([owner, ..._], i) => {\\n    if (visitedAccounts[i]) return;\\n\\n    const mergedEmails = new Set();\\n    dfs(i, mergedEmails);\\n\\n    result.push([owner, ...Array.from(mergedEmails).sort()]);\\n  });\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015147,
                "title": "simple-js-solution-w-comments-optimized-union-find-dfs",
                "content": "```\\n/**\\n * *Time: O(N x K log N x K), N = number of accounts, K = max length of accounts\\n * *Space: O(N x K)\\n */\\n// Runtime: 207 ms, faster than 51.74% of JavaScript online submissions for Accounts Merge.\\n// Memory Usage: 56.2 MB, less than 49.54% of JavaScript online submissions for Accounts Merge.\\nconst accountsMerge = (accounts) => {\\n  const parent = {};\\n  const rank = {};\\n\\n  const find = (x) => {\\n\\t // initialize parent and rank\\n    if (!parent[x]) {\\n      parent[x] = x;\\n      rank[x] = 0;\\n    }\\n\\n    if (parent[x] === x) return parent[x];\\n\\n    return (parent[x] = find(parent[x])); // path compression\\n  };\\n\\n  const union = (x, y) => {\\n    const [X, Y] = [find(x), find(y)];\\n\\n    if (X === Y) return; // same parent\\n\\n\\t// union by rank\\n    if (rank[X] < rank[Y]) parent[X] = Y;\\n    else if (rank[Y] < rank[X]) parent[Y] = X;\\n    else {\\n      parent[Y] = X;\\n      rank[X]++;\\n    }\\n  };\\n\\n  const map = {}; // email: name\\n  // lookup: map email to first name\\n  // Union-Find: on each email\\n  for (const [name, ...emails] of accounts) {\\n    for (const email of emails) {\\n      if (!map[email]) map[email] = name;\\n\\t  \\n      union(email, emails[0]);\\n    }\\n  }\\n\\n  const components = {}; // parent email: [emails]\\n  // from list of unique emails, map parent email to [emails]\\n  for (const email of Object.keys(parent)) {\\n    const root = find(email); // get parent of email\\n\\n    if (!components[root]) components[root] = [email];\\n    else components[root].push(email);\\n  }\\n\\n  const output = [];\\n  const componentList = Object.entries(components); // parent email: [emails]\\n  for (const [parent, emails] of componentList) {\\n    emails.sort();\\n    const name = map[parent];\\n    const account = [name, ...emails];\\n\\n    output.push(account);\\n  }\\n\\n  return output;\\n};\\n\\n/**\\n * *Time: O(N x K log N x K), N = number of accounts, K = max length of accounts\\n * *Space: O(N x K)\\n */\\n// Runtime: 183 ms, faster than 66.79% of JavaScript online submissions for Accounts Merge.\\n// Memory Usage: 54.2 MB, less than 66.97% of JavaScript online submissions for Accounts Merge.\\nconst accountsMerge = (accounts) => {\\n  const visited = new Set();\\n  const adjacency = {};\\n\\n  const traverse = (email, account) => {\\n    if (visited.has(email)) return; // skip visited\\n\\n    // mark visited and add email to current component\\n    visited.add(email);\\n    account.push(email);\\n\\n    // traverse all neightbors and add to same account\\n    for (const adjacent of adjacency[email]) {\\n      traverse(adjacent, account);\\n    }\\n\\n    return account;\\n  };\\n\\n  // create adjacency list\\n  for (const [, ...emails] of accounts) {\\n    for (const email of emails) {\\n      const parent = emails[0]; // set 1st email as parent\\n\\n      // parent: [emails]\\n      if (!adjacency[parent]) adjacency[parent] = [email];\\n      else adjacency[parent].push(email);\\n\\n      // email: [parent]\\n      if (!adjacency[email]) adjacency[email] = [parent];\\n      else adjacency[email].push(parent);\\n    }\\n  }\\n\\n  const output = [];\\n  for (const [name, ...emails] of accounts) {\\n    const parent = emails[0];\\n\\n    if (visited.has(parent)) continue;\\n\\n    // find all components connected to parent\\n    const account = traverse(parent, []);\\n\\n    account.sort();\\n    output.push([name, ...account]);\\n  }\\n\\n  return output;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Union Find",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * *Time: O(N x K log N x K), N = number of accounts, K = max length of accounts\\n * *Space: O(N x K)\\n */\\n// Runtime: 207 ms, faster than 51.74% of JavaScript online submissions for Accounts Merge.\\n// Memory Usage: 56.2 MB, less than 49.54% of JavaScript online submissions for Accounts Merge.\\nconst accountsMerge = (accounts) => {\\n  const parent = {};\\n  const rank = {};\\n\\n  const find = (x) => {\\n\\t // initialize parent and rank\\n    if (!parent[x]) {\\n      parent[x] = x;\\n      rank[x] = 0;\\n    }\\n\\n    if (parent[x] === x) return parent[x];\\n\\n    return (parent[x] = find(parent[x])); // path compression\\n  };\\n\\n  const union = (x, y) => {\\n    const [X, Y] = [find(x), find(y)];\\n\\n    if (X === Y) return; // same parent\\n\\n\\t// union by rank\\n    if (rank[X] < rank[Y]) parent[X] = Y;\\n    else if (rank[Y] < rank[X]) parent[Y] = X;\\n    else {\\n      parent[Y] = X;\\n      rank[X]++;\\n    }\\n  };\\n\\n  const map = {}; // email: name\\n  // lookup: map email to first name\\n  // Union-Find: on each email\\n  for (const [name, ...emails] of accounts) {\\n    for (const email of emails) {\\n      if (!map[email]) map[email] = name;\\n\\t  \\n      union(email, emails[0]);\\n    }\\n  }\\n\\n  const components = {}; // parent email: [emails]\\n  // from list of unique emails, map parent email to [emails]\\n  for (const email of Object.keys(parent)) {\\n    const root = find(email); // get parent of email\\n\\n    if (!components[root]) components[root] = [email];\\n    else components[root].push(email);\\n  }\\n\\n  const output = [];\\n  const componentList = Object.entries(components); // parent email: [emails]\\n  for (const [parent, emails] of componentList) {\\n    emails.sort();\\n    const name = map[parent];\\n    const account = [name, ...emails];\\n\\n    output.push(account);\\n  }\\n\\n  return output;\\n};\\n\\n/**\\n * *Time: O(N x K log N x K), N = number of accounts, K = max length of accounts\\n * *Space: O(N x K)\\n */\\n// Runtime: 183 ms, faster than 66.79% of JavaScript online submissions for Accounts Merge.\\n// Memory Usage: 54.2 MB, less than 66.97% of JavaScript online submissions for Accounts Merge.\\nconst accountsMerge = (accounts) => {\\n  const visited = new Set();\\n  const adjacency = {};\\n\\n  const traverse = (email, account) => {\\n    if (visited.has(email)) return; // skip visited\\n\\n    // mark visited and add email to current component\\n    visited.add(email);\\n    account.push(email);\\n\\n    // traverse all neightbors and add to same account\\n    for (const adjacent of adjacency[email]) {\\n      traverse(adjacent, account);\\n    }\\n\\n    return account;\\n  };\\n\\n  // create adjacency list\\n  for (const [, ...emails] of accounts) {\\n    for (const email of emails) {\\n      const parent = emails[0]; // set 1st email as parent\\n\\n      // parent: [emails]\\n      if (!adjacency[parent]) adjacency[parent] = [email];\\n      else adjacency[parent].push(email);\\n\\n      // email: [parent]\\n      if (!adjacency[email]) adjacency[email] = [parent];\\n      else adjacency[email].push(parent);\\n    }\\n  }\\n\\n  const output = [];\\n  for (const [name, ...emails] of accounts) {\\n    const parent = emails[0];\\n\\n    if (visited.has(parent)) continue;\\n\\n    // find all components connected to parent\\n    const account = traverse(parent, []);\\n\\n    account.sort();\\n    output.push([name, ...account]);\\n  }\\n\\n  return output;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1602208,
                "title": "python3-union-find-explained",
                "content": "We can use Union Find data structure here since we need merge some entities. First, we create a dictionary that maps an account index to itself (initially each account belongs to itself). Then we iterate over emails in all accounts and create a dictionary that maps email to the account index. Along with that, we verify if the same email appears multiple times and in this case call union operation to unite a subset of emails under the same account index. After, we need to build a dictionary that maps a merged account to emails. We call the find operation to find the final account index and append all emails that belong to it. Lastly, we just form the resulting list.\\n\\nTime: **O(N * \\u03B1(N))** for 3 iterations + `find` with Path Compression\\nSpace: **O(N)** for 3 hahsmaps\\n\\nRuntime: 196 ms, faster than **86.15%** of Python3 online submissions for Accounts Merge.\\nMemory Usage: 17.6 MB, less than **98.69%** of Python3 online submissions for Accounts Merge.\\n\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        self.p = {i:i for i in range(len(accounts))} # parents\\n               \\n        eta = dict() # maps email to account\\n        for i, acc in enumerate(accounts):\\n            for email in acc[1:]:\\n                if email in eta:\\n                    self.union(eta[email], i)\\n                    continue\\n                \\n                eta[email] = i\\n    \\n        ate = dict() # maps account to emails\\n        for email in eta:\\n            acc = self.find(eta[email])\\n            \\n            if acc in ate:\\n                ate[acc].append(email)\\n            else:\\n                ate[acc] = [email]\\n             \\n        res = []   \\n        for p in ate: # build the result list\\n            res.append([accounts[p][0]] + sorted(ate[p]))\\n            \\n        return res\\n    \\n    def union(self, a, b):\\n        self.p[self.find(b)] = self.find(a)\\n\\n    def find(self, res):\\n        while self.p[res] != res:\\n            self.p[res] = self.p[self.p[res]]\\n            res = self.p[res]\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        self.p = {i:i for i in range(len(accounts))} # parents\\n               \\n        eta = dict() # maps email to account\\n        for i, acc in enumerate(accounts):\\n            for email in acc[1:]:\\n                if email in eta:\\n                    self.union(eta[email], i)\\n                    continue\\n                \\n                eta[email] = i\\n    \\n        ate = dict() # maps account to emails\\n        for email in eta:\\n            acc = self.find(eta[email])\\n            \\n            if acc in ate:\\n                ate[acc].append(email)\\n            else:\\n                ate[acc] = [email]\\n             \\n        res = []   \\n        for p in ate: # build the result list\\n            res.append([accounts[p][0]] + sorted(ate[p]))\\n            \\n        return res\\n    \\n    def union(self, a, b):\\n        self.p[self.find(b)] = self.find(a)\\n\\n    def find(self, res):\\n        while self.p[res] != res:\\n            self.p[res] = self.p[self.p[res]]\\n            res = self.p[res]\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601823,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        res = {}\\n        for acc in accounts:\\n            if acc[0] in res:\\n                temp = [set(acc[1:])]\\n                for mail in res[acc[0]]:\\n                    if temp[0].intersection(mail):\\n                        temp[0] = temp[0].union( mail )\\n                    else:\\n                        temp.append(mail)\\n                res[acc[0]] = temp\\n            else:\\n                res.update({acc[0]: [set(acc[1:])]})\\n        return [ [name] + sorted(list(mail)) for name, mails in res.iteritems() for mail in mails ]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        res = {}\\n        for acc in accounts:\\n            if acc[0] in res:\\n                temp = [set(acc[1:])]\\n                for mail in res[acc[0]]:\\n                    if temp[0].intersection(mail):\\n                        temp[0] = temp[0].union( mail )\\n                    else:\\n                        temp.append(mail)\\n                res[acc[0]] = temp\\n            else:\\n                res.update({acc[0]: [set(acc[1:])]})\\n        return [ [name] + sorted(list(mail)) for name, mails in res.iteritems() for mail in mails ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336771,
                "title": "simple-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string,int>vis;\\n    \\n    unordered_map<string, vector<string>> vg;\\n    \\n    void dfs(string S,vector<string>&v)\\n    {\\n        vis[S]=1;\\n        \\n        if(count(S.begin(),S.end(),\\'@\\'))\\n        {\\n            v.push_back(S);\\n        }\\n        \\n        for(string x:vg[S])\\n        {\\n            if(!vis[x])\\n                dfs(x,v);\\n        }\\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& acc) {\\n        int i,j,n=acc.size();\\n        \\n        \\n        for(i=0;i<n;i++)\\n        {\\n            string S=to_string(i);\\n            \\n            for(j=1;j<acc[i].size();j++)\\n            {\\n                vg[S].push_back(acc[i][j]);\\n                vg[acc[i][j]].push_back(S);\\n            }\\n        }\\n        \\n        vector<vector<string>>ans;\\n        \\n        j=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            string S1=to_string(i);\\n            \\n            if(!vis[S1])\\n            {\\n                vector<string>v;\\n                v.push_back(acc[i][0]);\\n                \\n                dfs(S1,v);\\n                \\n                sort(v.begin()+1,v.end());\\n                \\n                ans.push_back(v);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string,int>vis;\\n    \\n    unordered_map<string, vector<string>> vg;\\n    \\n    void dfs(string S,vector<string>&v)\\n    {\\n        vis[S]=1;\\n        \\n        if(count(S.begin(),S.end(),\\'@\\'))\\n        {\\n            v.push_back(S);\\n        }\\n        \\n        for(string x:vg[S])\\n        {\\n            if(!vis[x])\\n                dfs(x,v);\\n        }\\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& acc) {\\n        int i,j,n=acc.size();\\n        \\n        \\n        for(i=0;i<n;i++)\\n        {\\n            string S=to_string(i);\\n            \\n            for(j=1;j<acc[i].size();j++)\\n            {\\n                vg[S].push_back(acc[i][j]);\\n                vg[acc[i][j]].push_back(S);\\n            }\\n        }\\n        \\n        vector<vector<string>>ans;\\n        \\n        j=0;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            string S1=to_string(i);\\n            \\n            if(!vis[S1])\\n            {\\n                vector<string>v;\\n                v.push_back(acc[i][0]);\\n                \\n                dfs(S1,v);\\n                \\n                sort(v.begin()+1,v.end());\\n                \\n                ans.push_back(v);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1260584,
                "title": "union-find-using-2-maps-explained-with-comments-c",
                "content": "In order to implement the solution, I devised the following approach:\\n1. While traversing the accounts, each email is mapped to the index number of the vector. So, we use a <string, int> map called id.\\n2. In case we have already seen that email, perform union on the two index numbers of the vector. So, we use a vector<int> called parent.\\n3. After having performed unions, we will find the parent of each index.\\n4. Then, to generate the resultant vector, we make use of a map <int, set<string>> called uni which contains the mapping of parent index to the set of all emails(belonging to parent as well as its children).\\n5. Insert the parent index name to the beginning and convert set to vector and push it to the resultant vector.\\n\\t\\n\\tThough the code seems a bit complex, I have divided it into chunks and adding comments to make it simpler:\\n\\t```\\n\\tclass Solution {\\n\\tpublic:\\n    map<string, int> id; //contains the index corresponding to an email\\n    vector<int> parent; //contains the parent index of every index in accounts\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        int x = 0;\\n        for(int i = 0; i < accounts.size(); i++){\\n            parent.push_back(i);\\n        }\\n        \\n        for(auto c : accounts){\\n            int s = c.size();\\n            for(int i = 1; i < s; i++){\\n               if(id.count(c[i]))//checking if that email has occurred previously\\n                   uni(x , id[c[i]]);//union is performed\\n                else\\n                id[c[i]] = x;\\n            }\\n            x++;\\n        }\\n               \\n\\t\\tmap<int , set<string>> uni;//contains the map for parent index and corresponding set of emails\\n        vector<vector<string>> res;//contains name and sorted emails to be returned\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            int x = find(i);//finding the parent index for all indices after unions have been performed\\n            for(int j = 1; j < accounts[i].size();j++){\\n                uni[x].insert(accounts[i][j]);//inserting emails to the set belonging to parent index\\n            }\\n        } \\n        \\n        for(auto i = uni.begin(); i != uni.end(); i++){\\n            string name = accounts[i->first][0];//getting name from the index\\n            vector<string> emails(i->second.begin() , i->second.end());//converting set to vector\\n            emails.insert(emails.begin(), name);//inserting the name to start of vector\\n            res.push_back(emails);\\n        }\\n            \\n        return res;\\n        \\n    }    \\n    int find(int x){//for union find by path compression\\n        if(parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    void uni(int x ,int y){//for uniting two different parents\\n        x = find(x), y = find(y);\\n        if(x != y)\\n            parent[x] = y;\\n    }\\n\\t};\\n\\t```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n\\tclass Solution {\\n\\tpublic:\\n    map<string, int> id; //contains the index corresponding to an email\\n    vector<int> parent; //contains the parent index of every index in accounts\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        int x = 0;\\n        for(int i = 0; i < accounts.size(); i++){\\n            parent.push_back(i);\\n        }\\n        \\n        for(auto c : accounts){\\n            int s = c.size();\\n            for(int i = 1; i < s; i++){\\n               if(id.count(c[i]))//checking if that email has occurred previously\\n                   uni(x , id[c[i]]);//union is performed\\n                else\\n                id[c[i]] = x;\\n            }\\n            x++;\\n        }\\n               \\n\\t\\tmap<int , set<string>> uni;//contains the map for parent index and corresponding set of emails\\n        vector<vector<string>> res;//contains name and sorted emails to be returned\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            int x = find(i);//finding the parent index for all indices after unions have been performed\\n            for(int j = 1; j < accounts[i].size();j++){\\n                uni[x].insert(accounts[i][j]);//inserting emails to the set belonging to parent index\\n            }\\n        } \\n        \\n        for(auto i = uni.begin(); i != uni.end(); i++){\\n            string name = accounts[i->first][0];//getting name from the index\\n            vector<string> emails(i->second.begin() , i->second.end());//converting set to vector\\n            emails.insert(emails.begin(), name);//inserting the name to start of vector\\n            res.push_back(emails);\\n        }\\n            \\n        return res;\\n        \\n    }    \\n    int find(int x){//for union find by path compression\\n        if(parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    void uni(int x ,int y){//for uniting two different parents\\n        x = find(x), y = find(y);\\n        if(x != y)\\n            parent[x] = y;\\n    }\\n\\t};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 953702,
                "title": "python-solution-with-hash-based-union-find",
                "content": "The union-find datastructure required by this question is slightly different than the one in the books, but the exact same concepts still apply.\\nThe inner \\'id\\' array representing the connected component is replaced with a dictionary, mapping an email address to a \"leader\". Union & find work the same, with minor change in find. Same concepts of tree compression.\\n\\n```\\nclass UF:\\n    def __init__(self):\\n        self.id = {}\\n    \\n    def union(self, p, q):\\n        i = self.find(p)\\n        j = self.find(q)\\n        self.id[i] = j\\n    \\n    def find(self, p):\\n        if p not in self.id:\\n            self.id[p] = p\\n        while p != self.id[p]:\\n            self.id[p] = self.id[self.id[p]]\\n            p = self.id[p] \\n        return p\\n    \\n```\\n\\nThen we union all emails with the 1st one in the group, essentially making them a connected component.\\n```\\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        uf = UF()\\n        email_to_person = {}\\n        \\n        # Mapping an email to person and grouping them in group of connected components\\n        for account in accounts:\\n            person = account[0]\\n            for email in account[1:]:\\n                email_to_person[email] = person\\n                uf.union(account[1], email)\\n        \\n        # Creating lists of clusters        \\n        clusters = collections.defaultdict(list)\\n        for email in email_to_person.keys():\\n            clusters[uf.find(email)].append(email)\\n\\n        # Building the output\\n        result = []\\n        for cluster in clusters.values():\\n            group = [email_to_person[cluster[0]]] + sorted(cluster)\\n            result.append(group)\\n        return result\\n        ```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UF:\\n    def __init__(self):\\n        self.id = {}\\n    \\n    def union(self, p, q):\\n        i = self.find(p)\\n        j = self.find(q)\\n        self.id[i] = j\\n    \\n    def find(self, p):\\n        if p not in self.id:\\n            self.id[p] = p\\n        while p != self.id[p]:\\n            self.id[p] = self.id[self.id[p]]\\n            p = self.id[p] \\n        return p\\n    \\n```\n```\\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        uf = UF()\\n        email_to_person = {}\\n        \\n        # Mapping an email to person and grouping them in group of connected components\\n        for account in accounts:\\n            person = account[0]\\n            for email in account[1:]:\\n                email_to_person[email] = person\\n                uf.union(account[1], email)\\n        \\n        # Creating lists of clusters        \\n        clusters = collections.defaultdict(list)\\n        for email in email_to_person.keys():\\n            clusters[uf.find(email)].append(email)\\n\\n        # Building the output\\n        result = []\\n        for cluster in clusters.values():\\n            group = [email_to_person[cluster[0]]] + sorted(cluster)\\n            result.append(group)\\n        return result\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 411598,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts) \\n    {\\n        var emailToNameMap = new Dictionary<string, string>();\\n        var parentMap  = new Dictionary<string, string>();\\n        foreach(var account in accounts)\\n        {\\n            for(int i = 1; i < account.Count; i++)\\n            {\\n                if(!emailToNameMap.ContainsKey(account[i]))\\n                    emailToNameMap[account[i]] = account[0];\\n                \\n                string par1 = GetParent(parentMap, account[1]), par2 = GetParent(parentMap, account[i]);\\n                if(par1 != par2)\\n                    parentMap[par1] = par2;\\n            }\\n        }\\n        \\n        var resultMap = new Dictionary<string, HashSet<string>>();\\n        foreach(var email in parentMap.Keys.ToList())\\n        {\\n            var par = GetParent(parentMap, email);\\n            if(!resultMap.ContainsKey(par))\\n                resultMap[par] = new HashSet<string>();\\n            resultMap[par].Add(email);\\n        }\\n        \\n        var result = new List<IList<string>>();\\n        \\n        foreach(var kvp in resultMap)\\n        {\\n            var list = new List<string>();\\n            foreach(var elem in kvp.Value)\\n                list.Add(elem);\\n            list.Sort(string.CompareOrdinal);\\n            list.Insert(0, emailToNameMap[kvp.Key]);\\n            result.Add(list);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private string GetParent(Dictionary<string, string> parentMap, string str)\\n    {\\n        if(!parentMap.ContainsKey(str)) parentMap[str] = str;\\n        if(parentMap[str] != str)\\n            parentMap[str] = GetParent(parentMap, parentMap[str]);\\n        return parentMap[str];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts) \\n    {\\n        var emailToNameMap = new Dictionary<string, string>();\\n        var parentMap  = new Dictionary<string, string>();\\n        foreach(var account in accounts)\\n        {\\n            for(int i = 1; i < account.Count; i++)\\n            {\\n                if(!emailToNameMap.ContainsKey(account[i]))\\n                    emailToNameMap[account[i]] = account[0];\\n                \\n                string par1 = GetParent(parentMap, account[1]), par2 = GetParent(parentMap, account[i]);\\n                if(par1 != par2)\\n                    parentMap[par1] = par2;\\n            }\\n        }\\n        \\n        var resultMap = new Dictionary<string, HashSet<string>>();\\n        foreach(var email in parentMap.Keys.ToList())\\n        {\\n            var par = GetParent(parentMap, email);\\n            if(!resultMap.ContainsKey(par))\\n                resultMap[par] = new HashSet<string>();\\n            resultMap[par].Add(email);\\n        }\\n        \\n        var result = new List<IList<string>>();\\n        \\n        foreach(var kvp in resultMap)\\n        {\\n            var list = new List<string>();\\n            foreach(var elem in kvp.Value)\\n                list.Add(elem);\\n            list.Sort(string.CompareOrdinal);\\n            list.Insert(0, emailToNameMap[kvp.Key]);\\n            result.Add(list);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private string GetParent(Dictionary<string, string> parentMap, string str)\\n    {\\n        if(!parentMap.ContainsKey(str)) parentMap[str] = str;\\n        if(parentMap[str] != str)\\n            parentMap[str] = GetParent(parentMap, parentMap[str]);\\n        return parentMap[str];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279085,
                "title": "java-33ms-union-find-solution-with-detailed-explanation",
                "content": "This problem can be solved in three steps:\\n1. **bipartite graph matching**: we can take name as the left part and email as the right part of a bipartite graph. Apparently, the left part contains ```accounts.size()``` nodes and the given list ```accounts``` has denoted the map from name to email. So what we need to do is building the map from email to name;\\n2. put those names sharing at least one email into a set. In order to merge emails, we first need to put names which share the same emails together. Since the number of names is known, it is simple to do so under the help of union find set. \\n3. merge emails. \\n\\n```\\npublic List<List<String>> accountsMerge(List<List<String>> accounts) { // accounts denotes the map from name to email\\n    List<List<String>> resultList = new ArrayList<List<String>>();\\n\\t\\n\\t// 1.build the map from email to name\\n    Map<String, List<Integer>> emailToAccount = new HashMap<String, List<Integer>>();\\n    for(int i = 0; i < accounts.size(); i++) { \\n        List<String> currentAccount = accounts.get(i);\\n        for(int j = 1; j < currentAccount.size(); j++) {\\n            if( emailToAccount.get(currentAccount.get(j)) == null )\\n                emailToAccount.put(currentAccount.get(j), new ArrayList<Integer>());\\n            emailToAccount.get(currentAccount.get(j)).add(i);\\n        }\\n    }\\n\\t\\n\\t// 2. put those names sharing at least one email into a set: \\n\\tUnionFind uf = new UnionFind(accounts.size());\\n    for( Map.Entry<String, List<Integer>> entry: emailToAccount.entrySet() ) {\\n        List<Integer> accountIndexList = entry.getValue();\\n        int baseIndex = accountIndexList.get(0);\\n        for(int i = 1; i < accountIndexList.size(); i++)\\n            uf.union(baseIndex, accountIndexList.get(i));\\n    }\\n    List<Integer> mergeList[] = new List[accounts.size()];\\n    for(int i = 0; i < accounts.size(); i++) {\\n        int root = uf.find(i);\\n        if( mergeList[root] == null)\\n            mergeList[root] = new ArrayList<Integer>();\\n        mergeList[root].add(i);\\n    }\\n\\t\\n\\t// 3.merge emails\\n    for(int i = 0; i < accounts.size(); i++) {\\n        if( mergeList[i] != null ) {\\n            String name = accounts.get(i).get(0);\\n            Set<String> currentSet = new HashSet<String>();\\n\\n            for(int j = 0; j < mergeList[i].size(); j++) {\\n                List<String> account = accounts.get(mergeList[i].get(j));\\n                currentSet.addAll(account.subList(1, account.size()));\\n            }\\n\\n            List<String> currentAccount = new ArrayList<String>(currentSet);\\n            Collections.sort(currentAccount);\\n            currentAccount.add(0, name);\\n            resultList.add(currentAccount);    \\n        }\\n    }\\n    return resultList;\\n}\\n\\nclass UnionFind{\\n    int parent[];\\n    int height[];\\n\\n    public int find(int i) {\\n        return parent[i] != i ? find(parent[i]) : parent[i];\\n    }\\n\\n    public void union(int i, int j) {\\n        int pi = find(i);\\n        int pj = find(j);\\n        if( height[pi] < height[pj] )\\n            parent[pi] = pj;\\n        else if( height[pi] > height[pj] )\\n            parent[pj] = pi;\\n        else{\\n            parent[pi] = pj;\\n            height[pj]++;\\n        }\\n    }\\n\\n    public UnionFind(int size) {\\n        parent = new int[size];\\n        height = new int[size];\\n        for(int i = 0; i < size; i++) {\\n            parent[i] = i;\\n            height[i] = 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```accounts.size()```\n```accounts```\n```\\npublic List<List<String>> accountsMerge(List<List<String>> accounts) { // accounts denotes the map from name to email\\n    List<List<String>> resultList = new ArrayList<List<String>>();\\n\\t\\n\\t// 1.build the map from email to name\\n    Map<String, List<Integer>> emailToAccount = new HashMap<String, List<Integer>>();\\n    for(int i = 0; i < accounts.size(); i++) { \\n        List<String> currentAccount = accounts.get(i);\\n        for(int j = 1; j < currentAccount.size(); j++) {\\n            if( emailToAccount.get(currentAccount.get(j)) == null )\\n                emailToAccount.put(currentAccount.get(j), new ArrayList<Integer>());\\n            emailToAccount.get(currentAccount.get(j)).add(i);\\n        }\\n    }\\n\\t\\n\\t// 2. put those names sharing at least one email into a set: \\n\\tUnionFind uf = new UnionFind(accounts.size());\\n    for( Map.Entry<String, List<Integer>> entry: emailToAccount.entrySet() ) {\\n        List<Integer> accountIndexList = entry.getValue();\\n        int baseIndex = accountIndexList.get(0);\\n        for(int i = 1; i < accountIndexList.size(); i++)\\n            uf.union(baseIndex, accountIndexList.get(i));\\n    }\\n    List<Integer> mergeList[] = new List[accounts.size()];\\n    for(int i = 0; i < accounts.size(); i++) {\\n        int root = uf.find(i);\\n        if( mergeList[root] == null)\\n            mergeList[root] = new ArrayList<Integer>();\\n        mergeList[root].add(i);\\n    }\\n\\t\\n\\t// 3.merge emails\\n    for(int i = 0; i < accounts.size(); i++) {\\n        if( mergeList[i] != null ) {\\n            String name = accounts.get(i).get(0);\\n            Set<String> currentSet = new HashSet<String>();\\n\\n            for(int j = 0; j < mergeList[i].size(); j++) {\\n                List<String> account = accounts.get(mergeList[i].get(j));\\n                currentSet.addAll(account.subList(1, account.size()));\\n            }\\n\\n            List<String> currentAccount = new ArrayList<String>(currentSet);\\n            Collections.sort(currentAccount);\\n            currentAccount.add(0, name);\\n            resultList.add(currentAccount);    \\n        }\\n    }\\n    return resultList;\\n}\\n\\nclass UnionFind{\\n    int parent[];\\n    int height[];\\n\\n    public int find(int i) {\\n        return parent[i] != i ? find(parent[i]) : parent[i];\\n    }\\n\\n    public void union(int i, int j) {\\n        int pi = find(i);\\n        int pj = find(j);\\n        if( height[pi] < height[pj] )\\n            parent[pi] = pj;\\n        else if( height[pi] > height[pj] )\\n            parent[pj] = pi;\\n        else{\\n            parent[pi] = pj;\\n            height[pj]++;\\n        }\\n    }\\n\\n    public UnionFind(int size) {\\n        parent = new int[size];\\n        height = new int[size];\\n        for(int i = 0; i < size; i++) {\\n            parent[i] = i;\\n            height[i] = 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211817,
                "title": "find-connected-components-of-the-undirected-graph-using-dfs-and-bfs-in-python",
                "content": "Usually, we can converted the problem into the classical graph problem \"find connected components in an undirected graph\" .\\n1. The DFS method :\\n```\\ndef accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        graph, email_to_name = collections.defaultdict(set), {}\\n        for acc in accounts:\\n            for email in acc[1:]:\\n                graph[acc[1]].add(email)\\n                graph[email].add(acc[1])\\n                email_to_name[email] = acc[0]\\n\\n        def dfs(v):\\n            seen.add(v)\\n            temp.append(v)\\n            for nei in graph[v]:\\n                if nei not in seen:\\n                    dfs(nei)\\n\\n        res, seen = [], set()\\n        for node in graph:\\n            if node not in seen:\\n                temp = list()\\n                dfs(node)\\n                res.append([email_to_name[node]] + sorted(temp))\\n        return res\\n```\\n2. The BFS method :\\n```\\ndef accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        graph, email_to_name = collections.defaultdict(set), {}\\n        for acc in accounts:\\n            for email in acc[1:]:\\n                graph[acc[1]].add(email)\\n                graph[email].add(acc[1])\\n                email_to_name[email] = acc[0]\\n\\n        res, seen = [], set()\\n        for node in graph:\\n            if node not in seen:\\n                seen.add(node)\\n                queue = [node]\\n                temp = list()\\n                while queue:\\n                    cur = queue.pop(0)\\n                    temp.append(cur)\\n                    for nei in graph[cur]:\\n                        if nei not in seen:\\n                            seen.add(nei)\\n                            queue.append(nei)\\n                res.append([email_to_name[node]] + sorted(temp))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        graph, email_to_name = collections.defaultdict(set), {}\\n        for acc in accounts:\\n            for email in acc[1:]:\\n                graph[acc[1]].add(email)\\n                graph[email].add(acc[1])\\n                email_to_name[email] = acc[0]\\n\\n        def dfs(v):\\n            seen.add(v)\\n            temp.append(v)\\n            for nei in graph[v]:\\n                if nei not in seen:\\n                    dfs(nei)\\n\\n        res, seen = [], set()\\n        for node in graph:\\n            if node not in seen:\\n                temp = list()\\n                dfs(node)\\n                res.append([email_to_name[node]] + sorted(temp))\\n        return res\\n```\n```\\ndef accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        graph, email_to_name = collections.defaultdict(set), {}\\n        for acc in accounts:\\n            for email in acc[1:]:\\n                graph[acc[1]].add(email)\\n                graph[email].add(acc[1])\\n                email_to_name[email] = acc[0]\\n\\n        res, seen = [], set()\\n        for node in graph:\\n            if node not in seen:\\n                seen.add(node)\\n                queue = [node]\\n                temp = list()\\n                while queue:\\n                    cur = queue.pop(0)\\n                    temp.append(cur)\\n                    for nei in graph[cur]:\\n                        if nei not in seen:\\n                            seen.add(nei)\\n                            queue.append(nei)\\n                res.append([email_to_name[node]] + sorted(temp))\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2914774,
                "title": "easy-to-understand-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question asks us to return the final merged array of all the accounts. We know that two accounts with the same emails definitely are the same person. The first thing I though when I saw this problem is to do a DFS. At the root of this problem, it is the same as finding the number of components in an undirected graph. Each node will be an email, and each edge will be undirected and based on if an email is in the same account as another email. The name of the account is basically not used in the logic of the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo implement DFS on an undirected graph, we first need to build the graph. So we will just iterate through all the accounts and create and adjacency list that will connect an email to the first email in that account. We also keep an emailToNameDict to get the name of the account owner in the end. We also keep a visited set to make sure we do not traverse on any nodes that have already been merged into components. THe dfs is simply recursively traversing through all neighbors of an array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(N(K* log(K)). N being the total number of emails all accounts and K being the maximum num of emails of an account. We must iterate through every email in the list in all cases, and in each iteration, we sort basically the entire component which takes O(K*log(K)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this algorithm is O(N) as we must store every email in all accounts. \\n\\nIf you have any questions or issues with the solution or explanation, please let me know in the comments.\\n\\n# Code\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        #AccountDict stores doubly directed email linked to head of the email list\\n        accountDict = defaultdict(set)\\n        emailToNameDict = {}\\n        result = []\\n\\n        #Build both the dictionaries\\n        for account in accounts:\\n            accName = account[0]\\n            emailHead = account[1]\\n\\n            for i in range(1,len(account)):\\n                currEmail = account[i]\\n                \\n                accountDict[emailHead].add(currEmail)\\n                accountDict[currEmail].add(emailHead)\\n                emailToNameDict[currEmail] =  accName\\n\\n        #Traverse dfs of the graph to find emails that are connected to this email\\n        def dfs(currEmail,mergedAcc):\\n            if currEmail in visited:\\n                return\\n            \\n            visited.add(currEmail)\\n            mergedAcc.append(currEmail)\\n            for neighbor in accountDict[currEmail]:\\n                dfs(neighbor,mergedAcc)\\n\\n            return mergedAcc\\n\\n        #visited set to ensure we do not visit and already visited node\\n        visited = set()\\n        for email in emailToNameDict:\\n            if email not in visited:\\n                result.append([emailToNameDict[email]] + sorted(dfs(email,[])))\\n\\n        return result\\n                      \\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        #AccountDict stores doubly directed email linked to head of the email list\\n        accountDict = defaultdict(set)\\n        emailToNameDict = {}\\n        result = []\\n\\n        #Build both the dictionaries\\n        for account in accounts:\\n            accName = account[0]\\n            emailHead = account[1]\\n\\n            for i in range(1,len(account)):\\n                currEmail = account[i]\\n                \\n                accountDict[emailHead].add(currEmail)\\n                accountDict[currEmail].add(emailHead)\\n                emailToNameDict[currEmail] =  accName\\n\\n        #Traverse dfs of the graph to find emails that are connected to this email\\n        def dfs(currEmail,mergedAcc):\\n            if currEmail in visited:\\n                return\\n            \\n            visited.add(currEmail)\\n            mergedAcc.append(currEmail)\\n            for neighbor in accountDict[currEmail]:\\n                dfs(neighbor,mergedAcc)\\n\\n            return mergedAcc\\n\\n        #visited set to ensure we do not visit and already visited node\\n        visited = set()\\n        for email in emailToNameDict:\\n            if email not in visited:\\n                result.append([emailToNameDict[email]] + sorted(dfs(email,[])))\\n\\n        return result\\n                      \\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444032,
                "title": "c-simple-c-code-95-time",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    vector<int> parent, size;\\n    int find_set(int v)\\n    {\\n        if(v == parent[v])\\n            return v;\\n        return parent[v] = find_set(parent[v]);\\n    }\\n    void union_set(int a, int b)\\n    {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a == b) return;\\n        if(size[a] < size[b])\\n        {\\n            parent[a] = b;\\n            size[b] += size[a];\\n        }\\n        else\\n        {\\n            parent[b] = a;\\n            size[a] += size[b];\\n        }\\n        return;\\n    }\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        unordered_map<string, int> um;\\n        int i = 0;\\n        for(vector<string> &vec : accounts)\\n        {\\n            parent.push_back(i);\\n            size.push_back(1);\\n            for(int j = 1; j < vec.size(); j++)\\n            {\\n                if(um.count(vec[j]))\\n                    union_set(i, um[vec[j]]);\\n                else\\n                    um[vec[j]] = i;\\n            }\\n            i++;\\n        }\\n        unordered_map<int, set<string>> us;  \\n        for(int i = 0; i < n; i++)\\n        {\\n            int val = find_set(i);\\n            for(int j = 1; j < accounts[i].size(); j++)\\n            {\\n                us[val].insert(accounts[i][j]);\\n            }\\n        }\\n        vector<vector<string>> ans;\\n        for(auto &[fst, snd] : us)\\n        {\\n            vector<string> tmp;\\n            tmp.push_back(accounts[fst][0]);\\n            for(string s : snd)\\n                tmp.push_back(s);\\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> parent, size;\\n    int find_set(int v)\\n    {\\n        if(v == parent[v])\\n            return v;\\n        return parent[v] = find_set(parent[v]);\\n    }\\n    void union_set(int a, int b)\\n    {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a == b) return;\\n        if(size[a] < size[b])\\n        {\\n            parent[a] = b;\\n            size[b] += size[a];\\n        }\\n        else\\n        {\\n            parent[b] = a;\\n            size[a] += size[b];\\n        }\\n        return;\\n    }\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        unordered_map<string, int> um;\\n        int i = 0;\\n        for(vector<string> &vec : accounts)\\n        {\\n            parent.push_back(i);\\n            size.push_back(1);\\n            for(int j = 1; j < vec.size(); j++)\\n            {\\n                if(um.count(vec[j]))\\n                    union_set(i, um[vec[j]]);\\n                else\\n                    um[vec[j]] = i;\\n            }\\n            i++;\\n        }\\n        unordered_map<int, set<string>> us;  \\n        for(int i = 0; i < n; i++)\\n        {\\n            int val = find_set(i);\\n            for(int j = 1; j < accounts[i].size(); j++)\\n            {\\n                us[val].insert(accounts[i][j]);\\n            }\\n        }\\n        vector<vector<string>> ans;\\n        for(auto &[fst, snd] : us)\\n        {\\n            vector<string> tmp;\\n            tmp.push_back(accounts[fst][0]);\\n            for(string s : snd)\\n                tmp.push_back(s);\\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399320,
                "title": "python-a-17-line-solution-using-directed-graph-with-some-tricks",
                "content": "```python\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        # Create a graph using python dict\\n        graph = defaultdict(list)\\n        \\n        # Trick #1: emails of each account together form a cycle in the graph, hence:\\n        # - uses less space than storing both u->v and v->u\\n        # - #nodes <= N*K, #edges = N*K\\n \\xA0 \\xA0 \\xA0 \\xA0# - starts at any email (node), any other email of the same is visitable\\n \\xA0 \\xA0 \\xA0 \\xA0# As the result, emails belong to a person create multiple cycles connected \\n\\t\\t# together making a connected component,\\n        # and the graph is consisted of many connected components like that.\\n        for acc in accounts:\\n            for i in range(1, len(acc) - 1):\\n                graph[acc[i]].append(acc[i+1])\\n            graph[acc[-1]].append(acc[1])\\n        \\n        # dfs to traverse all node in a connected component\\n        def __visit(node):\\n            # a node not in the graph means it has been visited\\n            if node not in graph:\\n                return []\\n            out = [node]\\n            # Trick #2: remove the node after visited, this saves some space \\n\\t\\t\\t# because there\\'s no need for storing the visited status of each node\\n            for child in graph.pop(node):\\n                out.extend(__visit(child))\\n            return out\\n        \\n        for acc in accounts:\\n            # an email is not in the graph means it has been visited and is belongs to a processed component\\n            if acc[1] in graph:\\n                # if an email is not visited, a new component is found\\n                yield [acc[0], *sorted(__visit(acc[1]))]\\n        \\n        # Time complexity is O(NKlogNK): O(NK) for building and traversing the graph, O(NKlogNK) for sorting.\\n        # Space complexity is O(NK): O(NK) for storing the graph and O(NK) for storing the output.\\n```\\n\\nComments and suggestions are highly appreciated.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        # Create a graph using python dict\\n        graph = defaultdict(list)\\n        \\n        # Trick #1: emails of each account together form a cycle in the graph, hence:\\n        # - uses less space than storing both u->v and v->u\\n        # - #nodes <= N*K, #edges = N*K\\n \\xA0 \\xA0 \\xA0 \\xA0# - starts at any email (node), any other email of the same is visitable\\n \\xA0 \\xA0 \\xA0 \\xA0# As the result, emails belong to a person create multiple cycles connected \\n\\t\\t# together making a connected component,\\n        # and the graph is consisted of many connected components like that.\\n        for acc in accounts:\\n            for i in range(1, len(acc) - 1):\\n                graph[acc[i]].append(acc[i+1])\\n            graph[acc[-1]].append(acc[1])\\n        \\n        # dfs to traverse all node in a connected component\\n        def __visit(node):\\n            # a node not in the graph means it has been visited\\n            if node not in graph:\\n                return []\\n            out = [node]\\n            # Trick #2: remove the node after visited, this saves some space \\n\\t\\t\\t# because there\\'s no need for storing the visited status of each node\\n            for child in graph.pop(node):\\n                out.extend(__visit(child))\\n            return out\\n        \\n        for acc in accounts:\\n            # an email is not in the graph means it has been visited and is belongs to a processed component\\n            if acc[1] in graph:\\n                # if an email is not visited, a new component is found\\n                yield [acc[0], *sorted(__visit(acc[1]))]\\n        \\n        # Time complexity is O(NKlogNK): O(NK) for building and traversing the graph, O(NKlogNK) for sorting.\\n        # Space complexity is O(NK): O(NK) for storing the graph and O(NK) for storing the output.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329677,
                "title": "3-methods-dfs-union-find-and-hashset",
                "content": "**DFS**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {       \\n        //first make it such that for each given account all of it\\'s\\n        //email nodes are connected to each other\\n        //and then use DFS to gather all the emails for each connected comp (account)\\n               \\n        n = accounts.size();\\n        //so first we build the list in like star formation or some\\n        buildAdjList(accounts);        \\n        \\n        //now do DFS for each account in the list\\n            //if unvisited store name too before traversing\\n            //push_back each encountered and unvisted node to output vector\\n        vector<vector<string>> output;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (visited.find(accounts[i][1]) == visited.end()) {\\n                vector<string> emailList = {accounts[i][0]};\\n                DFS(emailList, accounts, accounts[i][1]);\\n                sort(emailList.begin()+1, emailList.end());\\n                output.push_back(emailList); \\n            }\\n        }\\n        //output should be sorted and ready to go\\n        return output;\\n    }\\n    \\nprivate:\\n    unordered_map<string, vector<string>> aList;\\n    unordered_set<string> visited;\\n    int n;\\n    \\n    void buildAdjList(vector<vector<string>>& accounts)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 2; j < accounts[i].size(); j++)\\n            {\\n                aList[accounts[i][1]].push_back(accounts[i][j]);\\n                aList[accounts[i][j]].push_back(accounts[i][1]);\\n            }\\n        }\\n    }\\n    \\n    void DFS(vector<string>& emailList, vector<vector<string>>& accounts, \\n                string curr)\\n    {\\n        //start at curr (if seen before)\\n        if (visited.find(curr) != visited.end()) {\\n            return;\\n        }\\n        visited.insert(curr); //mark visited\\n        emailList.push_back(curr); \\n        \\n        //now loop through all neighbors\\n        for (int i = 0; i < aList[curr].size(); i++)\\n        {\\n            DFS(emailList, accounts, aList[curr][i]);\\n        }\\n    }\\n};\\n```\\n\\n**Union Find:**\\n\\n```\\nclass UnionFind {\\npublic:\\n    //Constructor    \\n    UnionFind(int size) : leader(size), rank(size)\\n    {\\n        for (int i = 0; i < size; i++)\\n        {\\n            leader[i] = i; //all start off as their own leader\\n            rank[i] = 1; //all start off as 1\\n        }\\n    }\\n    \\n    //Find function\\n    int find(int node)\\n    {\\n        if (node == leader[node]) {\\n            return node; //if it\\'s its own leader\\n        }\\n        return leader[node] = find(leader[node]);\\n    }\\n    \\n    //union function\\n    void unionMerge(int node1, int node2)\\n    {\\n        int leader1 = find(node1);\\n        int leader2 = find(node2);\\n        if (leader1 == leader2) {\\n            return;\\n        }\\n        else if (rank[leader1] > rank[leader2]) {\\n            leader[leader2] = leader1; //append smaller one to larger\\n        }\\n        else if (rank[leader1] < rank[leader2]) {\\n            leader[leader1] = leader2;\\n        }\\n        else {\\n            //must be same size; this is the only scenario where the size\\n            //of a chain gets updated too\\n            leader[leader2] = leader1;\\n            rank[leader1]++;\\n        }\\n    }\\n    \\n    //isSame component function\\n    bool isConnected(int node1, int node2)\\n    {\\n        return find(node1) == find(node2);\\n    }\\n    \\nprivate:\\n    vector<int> leader;\\n    vector<int> rank;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        UnionFind UF(n); //every accnt starts off as it\\'s own node\\n        \\n        //traverse over all the emails for each account\\n        //need some way to keep track of whether we\\'ve seen the email before\\n        //as well as what leader/index it corresponds to\\n        unordered_map<string, int> hTable;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 1; j < accounts[i].size(); j++)\\n            {\\n                if (hTable.find(accounts[i][j]) == hTable.end()) {\\n                    hTable[accounts[i][j]] = i; //not seen\\n                }\\n                else {\\n                    //must be seen, union i and whatever group this one is from\\n                    UF.unionMerge(i, hTable[accounts[i][j]]);\\n                }\\n            }\\n        }\\n        \\n        //now traverse each email again and see which node group it belongs to\\n        vector<vector<string>> output;\\n        vector<vector<string>> acc(n);\\n        unordered_set<string> emailSet;\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 1; j < accounts[i].size();j++)\\n            {\\n                if (emailSet.find(accounts[i][j]) == emailSet.end()) {\\n                    int index = UF.find(hTable[accounts[i][j]]);\\n                    if(acc[index].empty()) {\\n                        acc[index].push_back(accounts[i][0]);\\n                    }\\n                    acc[index].push_back(accounts[i][j]);\\n                    emailSet.insert(accounts[i][j]);\\n                }\\n            }\\n        }\\n        \\n        //now traverse through the map\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (!acc[i].empty()) {\\n                sort(acc[i].begin()+1, acc[i].end());\\n                output.push_back(acc[i]);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\\n\\n**Hash Set Type Thing**\\n\\n* It turns out this soln goes 98% in time and 97% in space so it is very fast and efficient\\n* However, it is also completely a mess\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {        \\n        //does sorting the accounts by name help at all?\\n        int n = accounts.size();\\n        sort(accounts.begin(), accounts.end());   \\n        \\n        vector<vector<string>> output;\\n        \\n        //OK trying an NlogN method where we sort build up a set of emails\\n        //and then push back the name and ordered set -> list after\\n        for (int i = 0; i < n; i++)\\n        {\\n            string name = accounts[i][0];\\n            if (name == \"-1\") {\\n                continue; //already processed\\n            }\\n            vector<string> person; //otherwise create a vector for it\\n            accounts[i][0] = \"-1\"; //marking done\\n            person.push_back(name); //first entry of their account has to be their name\\n            unordered_set<string> emailList;\\n            //now add all of their emails to a set\\n            for (int j = 1; j < accounts[i].size(); j++)\\n            {\\n                emailList.insert(accounts[i][j]);\\n            }\\n            \\n            bool going = true;\\n            while (going)\\n            {\\n                going = false;\\n                //now time to compare it with all other of same name\\n\\t\\t\\t\\t//only have to look at the next consecutive accounts since they are sorted\\n                int tempI = i + 1;\\n                while (tempI < n && (name == accounts[tempI][0]\\n                        || accounts[tempI][0] == \"-1\"))\\n                {\\n                    if (accounts[tempI][0] == \"-1\") {\\n                        tempI++;\\n                        continue; //since we could still have ppl of same name after\\n                    }\\n                    //check for any similarities \\n\\t\\t\\t\\t\\t//(only merge if you find an account in common)\\n                    for (int j = 1; j < accounts[tempI].size(); j++)\\n                    {\\n                        if (emailList.find(accounts[tempI][j]) \\n                            != emailList.end()) {\\n                            merge(emailList, accounts[tempI]);\\n                            accounts[tempI][0] = \"-1\";\\n                            //have to restart the search ig this is so f****d\\n                            going = true;\\n                            break;\\n                        }\\n                    }\\n                    tempI++;\\n                }\\n            }\\n            \\n            for (const auto& elem: emailList) {\\n                person.push_back(elem);\\n            }\\n            //person should now have all the emails for that name\\n            sort(person.begin() + 1, person.end()); //sort pushback\\n            output.push_back(person);\\n        }\\n        \\n        return output;\\n    }\\n    \\n    void merge(unordered_set<string>& emailList, vector<string>& emails)\\n    {\\n        for (int i = 1; i < emails.size(); i++)\\n        {\\n            if (emailList.find(emails[i]) == emailList.end()) {\\n                emailList.insert(emails[i]); //add to set\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Union Find",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {       \\n        //first make it such that for each given account all of it\\'s\\n        //email nodes are connected to each other\\n        //and then use DFS to gather all the emails for each connected comp (account)\\n               \\n        n = accounts.size();\\n        //so first we build the list in like star formation or some\\n        buildAdjList(accounts);        \\n        \\n        //now do DFS for each account in the list\\n            //if unvisited store name too before traversing\\n            //push_back each encountered and unvisted node to output vector\\n        vector<vector<string>> output;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (visited.find(accounts[i][1]) == visited.end()) {\\n                vector<string> emailList = {accounts[i][0]};\\n                DFS(emailList, accounts, accounts[i][1]);\\n                sort(emailList.begin()+1, emailList.end());\\n                output.push_back(emailList); \\n            }\\n        }\\n        //output should be sorted and ready to go\\n        return output;\\n    }\\n    \\nprivate:\\n    unordered_map<string, vector<string>> aList;\\n    unordered_set<string> visited;\\n    int n;\\n    \\n    void buildAdjList(vector<vector<string>>& accounts)\\n    {\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 2; j < accounts[i].size(); j++)\\n            {\\n                aList[accounts[i][1]].push_back(accounts[i][j]);\\n                aList[accounts[i][j]].push_back(accounts[i][1]);\\n            }\\n        }\\n    }\\n    \\n    void DFS(vector<string>& emailList, vector<vector<string>>& accounts, \\n                string curr)\\n    {\\n        //start at curr (if seen before)\\n        if (visited.find(curr) != visited.end()) {\\n            return;\\n        }\\n        visited.insert(curr); //mark visited\\n        emailList.push_back(curr); \\n        \\n        //now loop through all neighbors\\n        for (int i = 0; i < aList[curr].size(); i++)\\n        {\\n            DFS(emailList, accounts, aList[curr][i]);\\n        }\\n    }\\n};\\n```\n```\\nclass UnionFind {\\npublic:\\n    //Constructor    \\n    UnionFind(int size) : leader(size), rank(size)\\n    {\\n        for (int i = 0; i < size; i++)\\n        {\\n            leader[i] = i; //all start off as their own leader\\n            rank[i] = 1; //all start off as 1\\n        }\\n    }\\n    \\n    //Find function\\n    int find(int node)\\n    {\\n        if (node == leader[node]) {\\n            return node; //if it\\'s its own leader\\n        }\\n        return leader[node] = find(leader[node]);\\n    }\\n    \\n    //union function\\n    void unionMerge(int node1, int node2)\\n    {\\n        int leader1 = find(node1);\\n        int leader2 = find(node2);\\n        if (leader1 == leader2) {\\n            return;\\n        }\\n        else if (rank[leader1] > rank[leader2]) {\\n            leader[leader2] = leader1; //append smaller one to larger\\n        }\\n        else if (rank[leader1] < rank[leader2]) {\\n            leader[leader1] = leader2;\\n        }\\n        else {\\n            //must be same size; this is the only scenario where the size\\n            //of a chain gets updated too\\n            leader[leader2] = leader1;\\n            rank[leader1]++;\\n        }\\n    }\\n    \\n    //isSame component function\\n    bool isConnected(int node1, int node2)\\n    {\\n        return find(node1) == find(node2);\\n    }\\n    \\nprivate:\\n    vector<int> leader;\\n    vector<int> rank;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        UnionFind UF(n); //every accnt starts off as it\\'s own node\\n        \\n        //traverse over all the emails for each account\\n        //need some way to keep track of whether we\\'ve seen the email before\\n        //as well as what leader/index it corresponds to\\n        unordered_map<string, int> hTable;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 1; j < accounts[i].size(); j++)\\n            {\\n                if (hTable.find(accounts[i][j]) == hTable.end()) {\\n                    hTable[accounts[i][j]] = i; //not seen\\n                }\\n                else {\\n                    //must be seen, union i and whatever group this one is from\\n                    UF.unionMerge(i, hTable[accounts[i][j]]);\\n                }\\n            }\\n        }\\n        \\n        //now traverse each email again and see which node group it belongs to\\n        vector<vector<string>> output;\\n        vector<vector<string>> acc(n);\\n        unordered_set<string> emailSet;\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 1; j < accounts[i].size();j++)\\n            {\\n                if (emailSet.find(accounts[i][j]) == emailSet.end()) {\\n                    int index = UF.find(hTable[accounts[i][j]]);\\n                    if(acc[index].empty()) {\\n                        acc[index].push_back(accounts[i][0]);\\n                    }\\n                    acc[index].push_back(accounts[i][j]);\\n                    emailSet.insert(accounts[i][j]);\\n                }\\n            }\\n        }\\n        \\n        //now traverse through the map\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (!acc[i].empty()) {\\n                sort(acc[i].begin()+1, acc[i].end());\\n                output.push_back(acc[i]);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {        \\n        //does sorting the accounts by name help at all?\\n        int n = accounts.size();\\n        sort(accounts.begin(), accounts.end());   \\n        \\n        vector<vector<string>> output;\\n        \\n        //OK trying an NlogN method where we sort build up a set of emails\\n        //and then push back the name and ordered set -> list after\\n        for (int i = 0; i < n; i++)\\n        {\\n            string name = accounts[i][0];\\n            if (name == \"-1\") {\\n                continue; //already processed\\n            }\\n            vector<string> person; //otherwise create a vector for it\\n            accounts[i][0] = \"-1\"; //marking done\\n            person.push_back(name); //first entry of their account has to be their name\\n            unordered_set<string> emailList;\\n            //now add all of their emails to a set\\n            for (int j = 1; j < accounts[i].size(); j++)\\n            {\\n                emailList.insert(accounts[i][j]);\\n            }\\n            \\n            bool going = true;\\n            while (going)\\n            {\\n                going = false;\\n                //now time to compare it with all other of same name\\n\\t\\t\\t\\t//only have to look at the next consecutive accounts since they are sorted\\n                int tempI = i + 1;\\n                while (tempI < n && (name == accounts[tempI][0]\\n                        || accounts[tempI][0] == \"-1\"))\\n                {\\n                    if (accounts[tempI][0] == \"-1\") {\\n                        tempI++;\\n                        continue; //since we could still have ppl of same name after\\n                    }\\n                    //check for any similarities \\n\\t\\t\\t\\t\\t//(only merge if you find an account in common)\\n                    for (int j = 1; j < accounts[tempI].size(); j++)\\n                    {\\n                        if (emailList.find(accounts[tempI][j]) \\n                            != emailList.end()) {\\n                            merge(emailList, accounts[tempI]);\\n                            accounts[tempI][0] = \"-1\";\\n                            //have to restart the search ig this is so f****d\\n                            going = true;\\n                            break;\\n                        }\\n                    }\\n                    tempI++;\\n                }\\n            }\\n            \\n            for (const auto& elem: emailList) {\\n                person.push_back(elem);\\n            }\\n            //person should now have all the emails for that name\\n            sort(person.begin() + 1, person.end()); //sort pushback\\n            output.push_back(person);\\n        }\\n        \\n        return output;\\n    }\\n    \\n    void merge(unordered_set<string>& emailList, vector<string>& emails)\\n    {\\n        for (int i = 1; i < emails.size(); i++)\\n        {\\n            if (emailList.find(emails[i]) == emailList.end()) {\\n                emailList.insert(emails[i]); //add to set\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602262,
                "title": "c-easy-to-understand-dsu",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int find( int x, vector<int>& parent )\\n    {\\n        while( x != parent[x] )\\n        {\\n            parent[x] = parent[parent[x]];\\n            x = parent[x];\\n        }\\n        \\n        return x;\\n    }\\n    \\n    void merge( int x, int y, vector<int>& parent )\\n    {\\n        int parX = find(x,parent);\\n        int parY = find(y,parent);\\n        \\n        parent[parY] = parX;\\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        \\n        int sz= accounts.size();\\n        \\n        unordered_map<string,int>isEmailPresent;\\n        vector<int>parent(sz,0);\\n        \\n        for( int i = 0; i < sz; i++ )\\n        {\\n            parent[i] = i;\\n        }\\n        \\n        for( int id = 0; id < sz; id++ )\\n        {\\n            int listSize = accounts[id].size();\\n            \\n            for( int j = 1; j < listSize; j++ )\\n            {\\n                string email = accounts[id][j];\\n                \\n                if( isEmailPresent.find(email) != isEmailPresent.end() )\\n                {\\n                    int accountID = isEmailPresent[email];\\n                    merge(accountID,id,parent);   \\n                }\\n                else\\n                {\\n                    isEmailPresent[email] = id;\\n                }\\n            }\\n   \\n        }\\n        \\n        unordered_map<int,vector<int>>mergedAccounts;\\n        unordered_map<int,vector<int>>::iterator itr;\\n        vector<vector<string>>answer;\\n        \\n        for( int i = 0; i < sz; i++ )\\n        {\\n            mergedAccounts[find(i,parent)].push_back(i); \\n        }\\n        \\n        for( itr = mergedAccounts.begin(); itr != mergedAccounts.end(); itr++ )\\n        {\\n            vector<int>allAccounts = itr->second;\\n            set<string>tmpSet;\\n            \\n            for( int j = 0; j < allAccounts.size(); j++ )\\n            {\\n                int id = allAccounts[j];\\n                for( int i = 1; i < accounts[id].size(); i++ )\\n                {\\n                    tmpSet.insert(accounts[id][i]);\\n                }\\n            }\\n            \\n            vector<string>tmpAns;\\n            string accountName = accounts[allAccounts[0]][0];\\n            tmpAns.push_back(accountName);\\n            \\n            set<string>::iterator itr = tmpSet.begin();\\n            \\n            while( itr != tmpSet.end() )\\n            {\\n                tmpAns.push_back(*itr);\\n                itr++;\\n            }\\n            \\n            sort(tmpAns.begin()+1,tmpAns.end());\\n            answer.push_back(tmpAns);\\n            \\n        }\\n        \\n        return answer;\\n        \\n        \\n    \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find( int x, vector<int>& parent )\\n    {\\n        while( x != parent[x] )\\n        {\\n            parent[x] = parent[parent[x]];\\n            x = parent[x];\\n        }\\n        \\n        return x;\\n    }\\n    \\n    void merge( int x, int y, vector<int>& parent )\\n    {\\n        int parX = find(x,parent);\\n        int parY = find(y,parent);\\n        \\n        parent[parY] = parX;\\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        \\n        int sz= accounts.size();\\n        \\n        unordered_map<string,int>isEmailPresent;\\n        vector<int>parent(sz,0);\\n        \\n        for( int i = 0; i < sz; i++ )\\n        {\\n            parent[i] = i;\\n        }\\n        \\n        for( int id = 0; id < sz; id++ )\\n        {\\n            int listSize = accounts[id].size();\\n            \\n            for( int j = 1; j < listSize; j++ )\\n            {\\n                string email = accounts[id][j];\\n                \\n                if( isEmailPresent.find(email) != isEmailPresent.end() )\\n                {\\n                    int accountID = isEmailPresent[email];\\n                    merge(accountID,id,parent);   \\n                }\\n                else\\n                {\\n                    isEmailPresent[email] = id;\\n                }\\n            }\\n   \\n        }\\n        \\n        unordered_map<int,vector<int>>mergedAccounts;\\n        unordered_map<int,vector<int>>::iterator itr;\\n        vector<vector<string>>answer;\\n        \\n        for( int i = 0; i < sz; i++ )\\n        {\\n            mergedAccounts[find(i,parent)].push_back(i); \\n        }\\n        \\n        for( itr = mergedAccounts.begin(); itr != mergedAccounts.end(); itr++ )\\n        {\\n            vector<int>allAccounts = itr->second;\\n            set<string>tmpSet;\\n            \\n            for( int j = 0; j < allAccounts.size(); j++ )\\n            {\\n                int id = allAccounts[j];\\n                for( int i = 1; i < accounts[id].size(); i++ )\\n                {\\n                    tmpSet.insert(accounts[id][i]);\\n                }\\n            }\\n            \\n            vector<string>tmpAns;\\n            string accountName = accounts[allAccounts[0]][0];\\n            tmpAns.push_back(accountName);\\n            \\n            set<string>::iterator itr = tmpSet.begin();\\n            \\n            while( itr != tmpSet.end() )\\n            {\\n                tmpAns.push_back(*itr);\\n                itr++;\\n            }\\n            \\n            sort(tmpAns.begin()+1,tmpAns.end());\\n            answer.push_back(tmpAns);\\n            \\n        }\\n        \\n        return answer;\\n        \\n        \\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1565758,
                "title": "python-dfs-solution",
                "content": "```\\n      def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def dfs(i, s):\\n            visited[i] = True\\n            for email in accounts[i][1:]:\\n                s.add(email)\\n            for j in adj_lst[i]:\\n                if not visited[j]:\\n                    dfs(j, s)\\n            \\n        n = len(accounts)\\n        # find the accounts needed to merge\\n        email_to_name = collections.defaultdict(list)\\n        for i in range(n):\\n            for email in accounts[i][1:]:\\n                email_to_name[email].append(i)\\n        # create the graph represented by adj_list\\n        adj_lst = [set() for _ in range(n)]\\n        for overlaps in email_to_name.values():\\n            m = len(overlaps)\\n            for i in range(m):\\n                for j in range(i + 1, m):\\n                    a, b = overlaps[i], overlaps[j]\\n                    adj_lst[a].add(b)\\n                    adj_lst[b].add(a)\\n        # use DFS to visit all accounts and merge accounts\\n        visited = n * [False]\\n        res = []\\n        for i in range(n):\\n            if not visited[i]:\\n                name, emails = accounts[i][0], set()\\n                dfs(i, emails)\\n                res.append([name] + sorted(list(emails)))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n      def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def dfs(i, s):\\n            visited[i] = True\\n            for email in accounts[i][1:]:\\n                s.add(email)\\n            for j in adj_lst[i]:\\n                if not visited[j]:\\n                    dfs(j, s)\\n            \\n        n = len(accounts)\\n        # find the accounts needed to merge\\n        email_to_name = collections.defaultdict(list)\\n        for i in range(n):\\n            for email in accounts[i][1:]:\\n                email_to_name[email].append(i)\\n        # create the graph represented by adj_list\\n        adj_lst = [set() for _ in range(n)]\\n        for overlaps in email_to_name.values():\\n            m = len(overlaps)\\n            for i in range(m):\\n                for j in range(i + 1, m):\\n                    a, b = overlaps[i], overlaps[j]\\n                    adj_lst[a].add(b)\\n                    adj_lst[b].add(a)\\n        # use DFS to visit all accounts and merge accounts\\n        visited = n * [False]\\n        res = []\\n        for i in range(n):\\n            if not visited[i]:\\n                name, emails = accounts[i][0], set()\\n                dfs(i, emails)\\n                res.append([name] + sorted(list(emails)))\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1412764,
                "title": "c-dfs-solution",
                "content": "**Note**\\n```List<string>.Sort(StringComparer.Ordinal)``` performs a lexical sort based on ASCII values.\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts) {\\n        \\n        List<IList<string>> res = new List<IList<string>>();\\n        if(accounts == null || accounts.Count == 0)\\n            return res;\\n        \\n        // graph: <email, neighour emails>\\n        Dictionary<string,HashSet<string>> graph = new Dictionary<string,HashSet<string>>(); \\n        Dictionary<string,string> emailNameDic = new Dictionary<string,string>();\\n        \\n        foreach(var accountList in accounts)\\n        {\\n            int size = accountList.Count;\\n            string accountName = accountList[0];\\n            \\n            for(int i = 1; i < size; i++)\\n            {\\n                if(!graph.ContainsKey(accountList[i]))\\n                    graph[accountList[i]] = new HashSet<string>();\\n                \\n                if(!emailNameDic.ContainsKey(accountList[i]))\\n                    emailNameDic.Add(accountList[i], accountName);\\n                \\n                if(i == 1)\\n                    continue;\\n                \\n                graph[accountList[i]].Add(accountList[i-1]);\\n                graph[accountList[i-1]].Add(accountList[i]);\\n            }\\n        }\\n        \\n        HashSet<string> visited = new HashSet<string>();\\n        foreach(var email in emailNameDic.Keys)\\n        {\\n            List<string> list = new List<string>();\\n            if(!visited.Contains(email))\\n            {\\n                dfs(graph, email, list, visited);\\n\\t\\t\\t\\t// peform a lexical sort based on ASCII\\n                list.Sort(StringComparer.Ordinal);\\n                list.Insert(0, emailNameDic[email]);\\n                res.Add(list);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void dfs(Dictionary<string,HashSet<string>> graph, string email, List<string> list, HashSet<string> visited)\\n    {\\n        list.Add(email);\\n        visited.Add(email);\\n        foreach(var nextEmail in graph[email])\\n        {\\n            if(!visited.Contains(nextEmail))\\n                dfs(graph, nextEmail, list, visited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```List<string>.Sort(StringComparer.Ordinal)```\n```\\npublic class Solution {\\n    public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts) {\\n        \\n        List<IList<string>> res = new List<IList<string>>();\\n        if(accounts == null || accounts.Count == 0)\\n            return res;\\n        \\n        // graph: <email, neighour emails>\\n        Dictionary<string,HashSet<string>> graph = new Dictionary<string,HashSet<string>>(); \\n        Dictionary<string,string> emailNameDic = new Dictionary<string,string>();\\n        \\n        foreach(var accountList in accounts)\\n        {\\n            int size = accountList.Count;\\n            string accountName = accountList[0];\\n            \\n            for(int i = 1; i < size; i++)\\n            {\\n                if(!graph.ContainsKey(accountList[i]))\\n                    graph[accountList[i]] = new HashSet<string>();\\n                \\n                if(!emailNameDic.ContainsKey(accountList[i]))\\n                    emailNameDic.Add(accountList[i], accountName);\\n                \\n                if(i == 1)\\n                    continue;\\n                \\n                graph[accountList[i]].Add(accountList[i-1]);\\n                graph[accountList[i-1]].Add(accountList[i]);\\n            }\\n        }\\n        \\n        HashSet<string> visited = new HashSet<string>();\\n        foreach(var email in emailNameDic.Keys)\\n        {\\n            List<string> list = new List<string>();\\n            if(!visited.Contains(email))\\n            {\\n                dfs(graph, email, list, visited);\\n\\t\\t\\t\\t// peform a lexical sort based on ASCII\\n                list.Sort(StringComparer.Ordinal);\\n                list.Insert(0, emailNameDic[email]);\\n                res.Add(list);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void dfs(Dictionary<string,HashSet<string>> graph, string email, List<string> list, HashSet<string> visited)\\n    {\\n        list.Add(email);\\n        visited.Add(email);\\n        foreach(var nextEmail in graph[email])\\n        {\\n            if(!visited.Contains(nextEmail))\\n                dfs(graph, nextEmail, list, visited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281507,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> visited;\\n    unordered_map<string, vector<string>> graph;\\n    unordered_map<string,string> emailNameRelation;\\n    \\n    void dfs(string email, vector<string> &emailList){\\n        visited[email]=true;\\n        emailList.push_back(email);\\n        \\n        for(string emails: graph[email]){\\n            if(!visited[emails])\\n                dfs(emails, emailList);\\n        }\\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n    \\n        // constructing the graph\\n        for(vector<string> account: accounts){\\n            int n = account.size();\\n            string name = account[0];\\n            emailNameRelation[account[1]]=name; // associating the first email with the name\\n            visited[account[1]]=false;\\n            for(int i=2;i<n;i++){\\n                visited[account[i]]=false;\\n                emailNameRelation[account[i]]=name; // associating all other emails with the name\\n                graph[account[i]].push_back(account[1]); // creating an edge between first email and ith email\\n                graph[account[1]].push_back(account[i]);\\n            }\\n        }\\n        \\n        vector<vector<string>> res;\\n        \\n        for(int i=0;i<accounts.size();i++){\\n            for(int j=1; j < accounts[i].size(); j++){\\n                \\n                // performing a dfs about the email acounts[i][j]\\n                if(!visited[accounts[i][j]]){\\n                    vector<string> emailList;\\n                    dfs(accounts[i][j], emailList);\\n                    emailList.push_back(emailNameRelation[accounts[i][j]]);\\n                    \\n                    reverse(emailList.begin(), emailList.end());\\n                    sort(emailList.begin()+1, emailList.end());\\n                    res.push_back(emailList);\\n                }\\n            }\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, bool> visited;\\n    unordered_map<string, vector<string>> graph;\\n    unordered_map<string,string> emailNameRelation;\\n    \\n    void dfs(string email, vector<string> &emailList){\\n        visited[email]=true;\\n        emailList.push_back(email);\\n        \\n        for(string emails: graph[email]){\\n            if(!visited[emails])\\n                dfs(emails, emailList);\\n        }\\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n    \\n        // constructing the graph\\n        for(vector<string> account: accounts){\\n            int n = account.size();\\n            string name = account[0];\\n            emailNameRelation[account[1]]=name; // associating the first email with the name\\n            visited[account[1]]=false;\\n            for(int i=2;i<n;i++){\\n                visited[account[i]]=false;\\n                emailNameRelation[account[i]]=name; // associating all other emails with the name\\n                graph[account[i]].push_back(account[1]); // creating an edge between first email and ith email\\n                graph[account[1]].push_back(account[i]);\\n            }\\n        }\\n        \\n        vector<vector<string>> res;\\n        \\n        for(int i=0;i<accounts.size();i++){\\n            for(int j=1; j < accounts[i].size(); j++){\\n                \\n                // performing a dfs about the email acounts[i][j]\\n                if(!visited[accounts[i][j]]){\\n                    vector<string> emailList;\\n                    dfs(accounts[i][j], emailList);\\n                    emailList.push_back(emailNameRelation[accounts[i][j]]);\\n                    \\n                    reverse(emailList.begin(), emailList.end());\\n                    sort(emailList.begin()+1, emailList.end());\\n                    res.push_back(emailList);\\n                }\\n            }\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203868,
                "title": "python-union-find-w-path-compression-and-union-by-rank",
                "content": "```\\ndef accounts_merge(accounts: list[list[str]]) -> list[list[str]]:\\n    \"\"\"\\n    Accounts Merge\\n\\n    time: O(\\u03B1(n)), where n is the total number of email accounts for all users and \\u03B1(n) is the inverse Ackermann function. \\n    space: O(n)\\n\\n    :param accounts:\\n    :return:\\n    \"\"\"\\n    groups = defaultdict(list)\\n    email_to_user = {}\\n\\n    # parent is a dictionary of disjoint sets.\\n    # The default value (i.e. \"\") means the parent of the node is itself.\\n    parent = defaultdict(str)\\n\\n    # rank is a dictionary of disjoint set ranks.\\n    # The default value (i.e. 0) is the lowest rank.\\n    rank = defaultdict(int)\\n\\n    # find (w/ path compression)\\n    def find(a: str) -> str:\\n        # The node `a` is its own parent (i.e. parent[node] is empty).\\n        if parent[a] == \"\":\\n            return a\\n\\n        # Otherwise, recursively find (and set) the parent of the node `a`.\\n        parent[a] = find(parent[a])\\n\\n        # Return the parent of the node.\\n        return parent[a]\\n\\n    # union (by rank)\\n    def union(a: str, b: str):\\n        # Find the parent for the node `a`.\\n        a = find(a)\\n\\n        # Find the parent for the node `b`.\\n        b = find(b)\\n\\n        # If the parents of `a` and `b` are different, union them together.\\n        if a != b:\\n\\n            # If `b` has a higher rank than `a`, set `b` as parent.\\n            if rank[a] < rank[b]:\\n                parent[a] = b\\n\\n            # If `a` has a higher rank than `b`, set `a` as parent.\\n            elif rank[a] > rank[b]:\\n                parent[b] = a\\n\\n            # If the ranks are the same, set `a` as parent and increment the rank for `a`.\\n            else:\\n                parent[b] = a\\n                rank[a] += 1\\n\\n    # Loop though the user accounts.\\n    for i, account in enumerate(accounts):\\n        user, *emails = account\\n\\n        # Loop through the emails.\\n        for email in emails:\\n            # Associate the email with the user for lookup.\\n            email_to_user[email] = user\\n\\n            # Union the first email with all other emails (including itself).\\n            union(emails[0], email)\\n\\n    # Loop though the emails.\\n    for email in email_to_user:\\n        # Find the root/leader email for the disjoint set.\\n        email_0 = find(email)\\n\\n        # Group the emails by root/leader email.\\n        groups[email_0].append(email)\\n\\n    # Return a list of lists where the value is a user and sorted emails for that user.\\n    return [\\n        [email_to_user[email_0], *sorted(emails)]\\n        for email_0, emails in groups.items()\\n    ]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\ndef accounts_merge(accounts: list[list[str]]) -> list[list[str]]:\\n    \"\"\"\\n    Accounts Merge\\n\\n    time: O(\\u03B1(n)), where n is the total number of email accounts for all users and \\u03B1(n) is the inverse Ackermann function. \\n    space: O(n)\\n\\n    :param accounts:\\n    :return:\\n    \"\"\"\\n    groups = defaultdict(list)\\n    email_to_user = {}\\n\\n    # parent is a dictionary of disjoint sets.\\n    # The default value (i.e. \"\") means the parent of the node is itself.\\n    parent = defaultdict(str)\\n\\n    # rank is a dictionary of disjoint set ranks.\\n    # The default value (i.e. 0) is the lowest rank.\\n    rank = defaultdict(int)\\n\\n    # find (w/ path compression)\\n    def find(a: str) -> str:\\n        # The node `a` is its own parent (i.e. parent[node] is empty).\\n        if parent[a] == \"\":\\n            return a\\n\\n        # Otherwise, recursively find (and set) the parent of the node `a`.\\n        parent[a] = find(parent[a])\\n\\n        # Return the parent of the node.\\n        return parent[a]\\n\\n    # union (by rank)\\n    def union(a: str, b: str):\\n        # Find the parent for the node `a`.\\n        a = find(a)\\n\\n        # Find the parent for the node `b`.\\n        b = find(b)\\n\\n        # If the parents of `a` and `b` are different, union them together.\\n        if a != b:\\n\\n            # If `b` has a higher rank than `a`, set `b` as parent.\\n            if rank[a] < rank[b]:\\n                parent[a] = b\\n\\n            # If `a` has a higher rank than `b`, set `a` as parent.\\n            elif rank[a] > rank[b]:\\n                parent[b] = a\\n\\n            # If the ranks are the same, set `a` as parent and increment the rank for `a`.\\n            else:\\n                parent[b] = a\\n                rank[a] += 1\\n\\n    # Loop though the user accounts.\\n    for i, account in enumerate(accounts):\\n        user, *emails = account\\n\\n        # Loop through the emails.\\n        for email in emails:\\n            # Associate the email with the user for lookup.\\n            email_to_user[email] = user\\n\\n            # Union the first email with all other emails (including itself).\\n            union(emails[0], email)\\n\\n    # Loop though the emails.\\n    for email in email_to_user:\\n        # Find the root/leader email for the disjoint set.\\n        email_0 = find(email)\\n\\n        # Group the emails by root/leader email.\\n        groups[email_0].append(email)\\n\\n    # Return a list of lists where the value is a user and sorted emails for that user.\\n    return [\\n        [email_to_user[email_0], *sorted(emails)]\\n        for email_0, emails in groups.items()\\n    ]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1068003,
                "title": "java-dfs",
                "content": "\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n\\n\\t\\tHashMap<String, String> owners = new HashMap<String, String>();\\n\\t\\tHashMap<String, List<String>> graph = new HashMap<String, List<String>>();\\n\\n\\t\\tfor (List<String> account : accounts) {\\n\\t\\t\\tString name = account.get(0);\\n\\t\\t\\tint length = account.size();\\n\\t\\t\\tfor (int i = 1; i < length; i++) {\\n\\t\\t\\t\\tString curr = account.get(i);\\n\\t\\t\\t\\tString prev = account.get(i - 1);\\n\\t\\t\\t\\tif (!graph.containsKey(curr))\\n\\t\\t\\t\\t\\tgraph.put(curr, new ArrayList<String>());\\n\\t\\t\\t\\towners.put(curr, name);\\n\\t\\t\\t\\tif (i == 1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tgraph.get(curr).add(prev);\\n\\t\\t\\t\\tgraph.get(prev).add(curr);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tHashSet<String> visited = new HashSet<String>();\\n\\t\\tList<List<String>> ans = new ArrayList<List<String>>();\\n\\t\\tfor (String email : owners.keySet()) {\\n\\t\\t\\tif (!visited.contains(email)) {\\n\\t\\t\\t\\tList<String> res = new ArrayList<String>();\\n\\t\\t\\t\\tdfs(graph, visited, email, res);\\n\\t\\t\\t\\tCollections.sort(res);\\n\\t\\t\\t\\tres.add(0, owners.get(email));\\n\\t\\t\\t\\tans.add(res);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic void dfs(HashMap<String, List<String>> graph, HashSet<String> visited, String curr, List<String> res) {\\n\\t\\tres.add(curr);\\n\\t\\tvisited.add(curr);\\n\\t\\tList<String> nbrs = graph.get(curr);\\n\\t\\tfor (String nbr : nbrs) {\\n\\t\\t\\tif (!visited.contains(nbr))\\n\\t\\t\\t\\tdfs(graph, visited, nbr, res);\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n\\n\\t\\tHashMap<String, String> owners = new HashMap<String, String>();\\n\\t\\tHashMap<String, List<String>> graph = new HashMap<String, List<String>>();\\n\\n\\t\\tfor (List<String> account : accounts) {\\n\\t\\t\\tString name = account.get(0);\\n\\t\\t\\tint length = account.size();\\n\\t\\t\\tfor (int i = 1; i < length; i++) {\\n\\t\\t\\t\\tString curr = account.get(i);\\n\\t\\t\\t\\tString prev = account.get(i - 1);\\n\\t\\t\\t\\tif (!graph.containsKey(curr))\\n\\t\\t\\t\\t\\tgraph.put(curr, new ArrayList<String>());\\n\\t\\t\\t\\towners.put(curr, name);\\n\\t\\t\\t\\tif (i == 1)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tgraph.get(curr).add(prev);\\n\\t\\t\\t\\tgraph.get(prev).add(curr);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tHashSet<String> visited = new HashSet<String>();\\n\\t\\tList<List<String>> ans = new ArrayList<List<String>>();\\n\\t\\tfor (String email : owners.keySet()) {\\n\\t\\t\\tif (!visited.contains(email)) {\\n\\t\\t\\t\\tList<String> res = new ArrayList<String>();\\n\\t\\t\\t\\tdfs(graph, visited, email, res);\\n\\t\\t\\t\\tCollections.sort(res);\\n\\t\\t\\t\\tres.add(0, owners.get(email));\\n\\t\\t\\t\\tans.add(res);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic void dfs(HashMap<String, List<String>> graph, HashSet<String> visited, String curr, List<String> res) {\\n\\t\\tres.add(curr);\\n\\t\\tvisited.add(curr);\\n\\t\\tList<String> nbrs = graph.get(curr);\\n\\t\\tfor (String nbr : nbrs) {\\n\\t\\t\\tif (!visited.contains(nbr))\\n\\t\\t\\t\\tdfs(graph, visited, nbr, res);\\n\\t\\t}\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 955840,
                "title": "javascript-union-find",
                "content": "```\\nvar accountsMerge = function(accounts) {\\n    let n = accounts.length;\\n    let map = new Map()\\n    let indexMap = new Map()\\n    let parent = Array(n).fill(0).map((i, index) => index)\\n    let res = []\\n    \\n    function find(x){\\n        while(parent[x] != x) x = parent[x]\\n        return x\\n    }\\n    \\n    function union(i, j){\\n        let x = find(i)\\n        let y = find(j)\\n        parent[x] = y\\n    }\\n    \\n    for(let i=0; i<n; i++){\\n        let arr = accounts[i]\\n        for(let j=1; j<arr.length; j++){\\n            if(!map.has(arr[j])){\\n                map.set(arr[j], i)\\n                let a = indexMap.get(i) || []\\n                indexMap.set(i, a.concat(arr[j]))\\n            } union(i, map.get(arr[j]))\\n        }\\n    }\\n    \\n    for(let [i, emails] of indexMap){\\n        if(parent[i]!=i){\\n            let arr = indexMap.get(find(i))\\n            arr.push(...emails)\\n            indexMap.delete(i)\\n        }\\n    }\\n    \\n    for(let [i, emails] of indexMap){\\n        emails.sort()\\n        res.push([accounts[i][0], ...emails])\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nvar accountsMerge = function(accounts) {\\n    let n = accounts.length;\\n    let map = new Map()\\n    let indexMap = new Map()\\n    let parent = Array(n).fill(0).map((i, index) => index)\\n    let res = []\\n    \\n    function find(x){\\n        while(parent[x] != x) x = parent[x]\\n        return x\\n    }\\n    \\n    function union(i, j){\\n        let x = find(i)\\n        let y = find(j)\\n        parent[x] = y\\n    }\\n    \\n    for(let i=0; i<n; i++){\\n        let arr = accounts[i]\\n        for(let j=1; j<arr.length; j++){\\n            if(!map.has(arr[j])){\\n                map.set(arr[j], i)\\n                let a = indexMap.get(i) || []\\n                indexMap.set(i, a.concat(arr[j]))\\n            } union(i, map.get(arr[j]))\\n        }\\n    }\\n    \\n    for(let [i, emails] of indexMap){\\n        if(parent[i]!=i){\\n            let arr = indexMap.get(find(i))\\n            arr.push(...emails)\\n            indexMap.delete(i)\\n        }\\n    }\\n    \\n    for(let [i, emails] of indexMap){\\n        emails.sort()\\n        res.push([accounts[i][0], ...emails])\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 904816,
                "title": "c-simplest-possible-code-easy-to-understand",
                "content": "```\\npublic class Solution {\\n    Dictionary<int, HashSet<string>> accountToEmail = new Dictionary<int, HashSet<string>>();\\n    Dictionary<string, HashSet<int>> emailToAccount = new Dictionary<string, HashSet<int>>();\\n    \\n    public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts) {\\n        var result = new List<IList<string>>();\\n        if (accounts == null || accounts.Count == 0)\\n            return result;\\n\\n        for (int i = 0; i < accounts.Count; i++){\\n            if (!accountToEmail.ContainsKey(i))\\n                accountToEmail.Add(i, new HashSet<string>());\\n            \\n            for (int j = 1; j < accounts[i].Count; j++){\\n                string email = accounts[i][j];\\n                accountToEmail[i].Add(email);\\n                if (!emailToAccount.ContainsKey(email))\\n                    emailToAccount.Add(email, new HashSet<int>());\\n                \\n                emailToAccount[email].Add(i);\\n            }\\n        }\\n        \\n        HashSet<int> visitedAccounts = new HashSet<int>();\\n        for(int i = 0; i < accounts.Count; i++){\\n            if (visitedAccounts.Contains(i))\\n                continue;\\n            \\n            string name = accounts[i][0];\\n            HashSet<string> singleAccountEmails = new HashSet<string>();\\n            dfs(i, singleAccountEmails, visitedAccounts);\\n            List<string> emailIds = singleAccountEmails.ToList();\\n            emailIds.Sort(StringComparer.Ordinal);\\n            emailIds.Insert(0, name);\\n            result.Add(emailIds);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void dfs(int account, HashSet<string> singleAccountEmails, HashSet<int> visitedAccounts){\\n        if (visitedAccounts.Contains(account))\\n            return;\\n        \\n        visitedAccounts.Add(account);\\n        HashSet<string> emails = accountToEmail[account];\\n        foreach(string email in emails){\\n            singleAccountEmails.Add(email);\\n            HashSet<int> accounts = emailToAccount[email];\\n            foreach(int acc in accounts){\\n                if (visitedAccounts.Contains(acc))\\n                    continue;\\n                \\n                dfs(acc, singleAccountEmails, visitedAccounts);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    Dictionary<int, HashSet<string>> accountToEmail = new Dictionary<int, HashSet<string>>();\\n    Dictionary<string, HashSet<int>> emailToAccount = new Dictionary<string, HashSet<int>>();\\n    \\n    public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts) {\\n        var result = new List<IList<string>>();\\n        if (accounts == null || accounts.Count == 0)\\n            return result;\\n\\n        for (int i = 0; i < accounts.Count; i++){\\n            if (!accountToEmail.ContainsKey(i))\\n                accountToEmail.Add(i, new HashSet<string>());\\n            \\n            for (int j = 1; j < accounts[i].Count; j++){\\n                string email = accounts[i][j];\\n                accountToEmail[i].Add(email);\\n                if (!emailToAccount.ContainsKey(email))\\n                    emailToAccount.Add(email, new HashSet<int>());\\n                \\n                emailToAccount[email].Add(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 806505,
                "title": "swift-graph",
                "content": "```\\nclass Solution {\\n    func accountsMerge(_ accounts: [[String]]) -> [[String]] {\\n        var emailRelation = [String: Set<String>]()\\n        var emailToName = [String: String]()\\n        \\n        buildGraph(accounts, &emailRelation, &emailToName)\\n        \\n        return dfs(emailRelation, emailToName)\\n    }\\n    \\n    private func buildGraph(_ accounts: [[String]],_ emailRelation: inout [String: Set<String>],_ emailToName: inout [String: String]) {\\n        for account in accounts {\\n            let name = account[0]\\n            let emails = Array(account[1...])\\n            let first = emails[0]\\n            \\n            for email in emails {\\n                emailRelation[first, default: []].insert(email)\\n                emailRelation[email, default: []].insert(first)\\n                emailToName[email] = name\\n            }\\n        }\\n    }\\n    \\n    private func dfs(_ emailRelation: [String: Set<String>],_ emailToName: [String: String]) -> [[String]] {\\n        var result: [[String]] = []\\n        var visited = Set<String>()\\n        \\n        for email in emailRelation.keys {\\n            if !visited.contains(email) {\\n                visited.insert(email)\\n                \\n                var stack: [String] = []\\n                var emailList: [String] = []\\n                \\n                stack.append(email)\\n                \\n                while !stack.isEmpty {\\n                    let em = stack.removeLast()\\n                    emailList.append(em)\\n                    \\n                    for neigbor in emailRelation[em]! where !visited.contains(neigbor) {\\n                        visited.insert(neigbor)\\n                        stack.append(neigbor)\\n                    }\\n                }\\n                \\n                result.append([emailToName[email]!] + emailList.sorted() )\\n                \\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search",
                    "Graph",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    func accountsMerge(_ accounts: [[String]]) -> [[String]] {\\n        var emailRelation = [String: Set<String>]()\\n        var emailToName = [String: String]()\\n        \\n        buildGraph(accounts, &emailRelation, &emailToName)\\n        \\n        return dfs(emailRelation, emailToName)\\n    }\\n    \\n    private func buildGraph(_ accounts: [[String]],_ emailRelation: inout [String: Set<String>],_ emailToName: inout [String: String]) {\\n        for account in accounts {\\n            let name = account[0]\\n            let emails = Array(account[1...])\\n            let first = emails[0]\\n            \\n            for email in emails {\\n                emailRelation[first, default: []].insert(email)\\n                emailRelation[email, default: []].insert(first)\\n                emailToName[email] = name\\n            }\\n        }\\n    }\\n    \\n    private func dfs(_ emailRelation: [String: Set<String>],_ emailToName: [String: String]) -> [[String]] {\\n        var result: [[String]] = []\\n        var visited = Set<String>()\\n        \\n        for email in emailRelation.keys {\\n            if !visited.contains(email) {\\n                visited.insert(email)\\n                \\n                var stack: [String] = []\\n                var emailList: [String] = []\\n                \\n                stack.append(email)\\n                \\n                while !stack.isEmpty {\\n                    let em = stack.removeLast()\\n                    emailList.append(em)\\n                    \\n                    for neigbor in emailRelation[em]! where !visited.contains(neigbor) {\\n                        visited.insert(neigbor)\\n                        stack.append(neigbor)\\n                    }\\n                }\\n                \\n                result.append([emailToName[email]!] + emailList.sorted() )\\n                \\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778528,
                "title": "python-alternative-to-union-find-beats-99-annotated",
                "content": "Group by ID, is my workaround to the union-find method. Here are a few other problems where this approach can be used:\\n\\nProblem <b><a href=\"https://leetcode.com/problems/lexicographically-smallest-equivalent-string\">lexicographically-smallest-equivalent-string</a></b> with a similar <b><a href = \"https://leetcode.com/problems/lexicographically-smallest-equivalent-string/discuss/776792/python-group-by-id-beats-100-runtime-and-memory\">Solution</a></b> (100% runtime and memory)\\nProblem <b><a href=\"https://leetcode.com/problems/friend-circles\">friend-circles</a></b> with a similar <b><a href = \"https://leetcode.com/problems/friend-circles/discuss/778619/python-alternative-to-union-find-beats-100\">Solution</a></b> (100% runtime)\\nProblem <b><a href=\"https://leetcode.com/problems/synonymous-sentences\">synonymous-sentences</a></b> with a similar <b><a href=\"https://leetcode.com/problems/synonymous-sentences/discuss/776936/Python-Group-and-DFS-Annotated-Beats-97.5\">Solution</a></b> (97.5% runtime 75% memory)\\nProblem <b><a href=\"https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends\">the-earliest-moment-when-everyone-become-friends</a></b> with a similar <b><a href=\"https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends/discuss/776624/python-pretend-islands-4-steps\">Solution</a></b>\\n\\n\\n```python\\ndef accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n\\n\\t# Assign name_id : id to name\\n\\t# Assign email_id : email to id\\n\\t# Assign group : id to group (set) of emails that share the same id\\n\\t#\\n\\t# for id in group: return name_id[id] + group[id]\\n\\n\\tgroup_id = 0\\n\\tgroup = {}\\n\\tname_id = {}\\n\\temail_id = {}\\n\\n\\tfor name, *emails in accounts:\\n\\n\\t\\tids = set([email_id[e] for e in emails if e in email_id])\\n\\n\\t\\tif len(ids) > 1:\\n\\t\\t\\t#different emails belong to different groups already\\n\\t\\t\\ttarget_id = min(ids)\\n\\n\\t\\t\\t#obsolete ids: \\n\\t\\t\\tids.remove(target_id)\\n\\n\\t\\t\\t#collect all emails in obsolete groups into target_id group\\n\\t\\t\\tfor id in ids:\\n\\t\\t\\t\\tfor email in group[id]:\\n\\t\\t\\t\\t\\temail_id[email] = target_id\\n\\t\\t\\t\\tgroup[target_id] |= group[id]\\n\\t\\t\\t\\tdel name_id[id]\\n\\t\\t\\t\\tdel group[id]\\n\\n\\t\\t\\t#collect all emails that did not already contain a group\\n\\t\\t\\tfor e in emails:\\n\\t\\t\\t\\tif e not in email_id:\\n\\t\\t\\t\\t\\temail_id[e] = target_id\\n\\t\\t\\t\\t\\tgroup[target_id] |= set([e])\\n\\n\\t\\telif (len(ids) == 1) and (len(emails) > 1):\\n\\t\\t\\t#only one email has a group, add all other emails to that group\\n\\t\\t\\ttarget_id = ids.pop()\\n\\t\\t\\tfor e in emails:\\n\\t\\t\\t\\temail_id[e] = target_id\\n\\t\\t\\tgroup[target_id] |= set(emails)\\n\\n\\t\\telif not ids:\\n\\t\\t\\t#all emails are new (do not belong to a group yet)\\n\\t\\t\\tgroup[group_id] = set(emails)\\n\\t\\t\\tfor e in emails:\\n\\t\\t\\t\\temail_id[e] = group_id\\n\\t\\t\\tname_id[group_id] = name\\n\\t\\t\\tgroup_id += 1\\n\\n\\treturn sorted([[name_id[i]] + sorted(group[i]) for i in group])\\n```\\n<img src=\"https://assets.leetcode.com/users/images/7adcdf7d-9969-40f1-aa57-392029d02e93_1596832123.1441505.png\" width=\"55%\">\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n\\n\\t# Assign name_id : id to name\\n\\t# Assign email_id : email to id\\n\\t# Assign group : id to group (set) of emails that share the same id\\n\\t#\\n\\t# for id in group: return name_id[id] + group[id]\\n\\n\\tgroup_id = 0\\n\\tgroup = {}\\n\\tname_id = {}\\n\\temail_id = {}\\n\\n\\tfor name, *emails in accounts:\\n\\n\\t\\tids = set([email_id[e] for e in emails if e in email_id])\\n\\n\\t\\tif len(ids) > 1:\\n\\t\\t\\t#different emails belong to different groups already\\n\\t\\t\\ttarget_id = min(ids)\\n\\n\\t\\t\\t#obsolete ids: \\n\\t\\t\\tids.remove(target_id)\\n\\n\\t\\t\\t#collect all emails in obsolete groups into target_id group\\n\\t\\t\\tfor id in ids:\\n\\t\\t\\t\\tfor email in group[id]:\\n\\t\\t\\t\\t\\temail_id[email] = target_id\\n\\t\\t\\t\\tgroup[target_id] |= group[id]\\n\\t\\t\\t\\tdel name_id[id]\\n\\t\\t\\t\\tdel group[id]\\n\\n\\t\\t\\t#collect all emails that did not already contain a group\\n\\t\\t\\tfor e in emails:\\n\\t\\t\\t\\tif e not in email_id:\\n\\t\\t\\t\\t\\temail_id[e] = target_id\\n\\t\\t\\t\\t\\tgroup[target_id] |= set([e])\\n\\n\\t\\telif (len(ids) == 1) and (len(emails) > 1):\\n\\t\\t\\t#only one email has a group, add all other emails to that group\\n\\t\\t\\ttarget_id = ids.pop()\\n\\t\\t\\tfor e in emails:\\n\\t\\t\\t\\temail_id[e] = target_id\\n\\t\\t\\tgroup[target_id] |= set(emails)\\n\\n\\t\\telif not ids:\\n\\t\\t\\t#all emails are new (do not belong to a group yet)\\n\\t\\t\\tgroup[group_id] = set(emails)\\n\\t\\t\\tfor e in emails:\\n\\t\\t\\t\\temail_id[e] = group_id\\n\\t\\t\\tname_id[group_id] = name\\n\\t\\t\\tgroup_id += 1\\n\\n\\treturn sorted([[name_id[i]] + sorted(group[i]) for i in group])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 650129,
                "title": "javascript-dfs-graph-solution-with-explanation-95-runtime-100-memory",
                "content": "This problem can be solved with either a graph or set unions\\nPersonally I find the graph logic easier to follow.\\n\\nThe way to tackle this problem is to think about each email as a node on a graph, with the email itself being the key/vertex.\\nAs we loop through each account, we have a list of emails.\\nWe can go through these emails and connect each email (vertex) to the previousEmail of the account. This will create a straight line of edges for the account. Once we find repeat emails later on, the vertex already exists, so when we add an edge to a repeat email, it connects it to the previous edges!\\nHeres an example:\\n`\"greg\": a@gmail --> b@gmail ---> c@gmail`\\n`\"greg\": d@gmail --> ^b@gmail^ --> f@gmail`\\n\\nOnce we loop into the second account, b@gmail already exists as a key, so when we connect `d@gmail` to `b@gmail` and `b@gmail` to `f@gmail`, we are really connecting the new account\\'s graph to the old account\\'s graph with these edges\\n\\nAfter we construct it, we simply traverse the graph and create output based on visted edges. Each of these accounts will be a separate group of edges, so once we fully visit one account, we will move on to the next.\\n\\n```\\n/**\\n * @param {string[][]} accounts\\n * @return {string[][]}\\n */\\nvar accountsMerge = function(accounts) {\\n    let graph = {};\\n    // Create graph\\n    for (const account of accounts) {\\n        let name = \\'\\';\\n        let prevEmail = null;\\n        for (let i = 0; i < account.length;i++) {\\n            if (i === 0) {\\n                // handle name\\n                name = account[i];\\n            } else {\\n                const email = account[i];\\n                if (!graph[email]) {\\n                  // add vertice to graph\\n                    graph[email] = {\\n                        edges: [],\\n                        name: name\\n                    }\\n                } \\n                if (prevEmail !== null) {\\n                    // add edges to graph if they dont already exist\\n                    if (!graph[prevEmail].edges.includes(email)) {\\n                        graph[prevEmail].edges.push(email);\\n                        graph[email].edges.push(prevEmail);\\n                    }\\n                }\\n                prevEmail = email;\\n            }\\n        }\\n    }\\n    // Create a DFS function\\n    var dfs = function(graph, node, visited, output) {\\n        visited[node] = true;\\n        output.push(node);\\n        for (const email of graph[node].edges) {\\n            if (!visited[email]) {\\n                dfs(graph, email, visited, output)\\n            }\\n        }\\n        return output;\\n    }\\n    \\n    let visited = {};\\n    const emails = Object.keys(graph);\\n    let merged = [];\\n    // DFS each unvisited email to create output\\n    for (const email of emails) {\\n        if (!visited[email]) {\\n            // Output will be created at each unvisted node\\n            //  which means after the dfs, we will have visited all connected emails on the account\\n            let output = []\\n            dfs(graph, email, visited, output)\\n            output.sort();\\n            // Add name to front after sorting\\n            output.unshift(graph[email].name)\\n            merged.push(output);\\n        }\\n    }\\n    return merged;\\n};```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string[][]} accounts\\n * @return {string[][]}\\n */\\nvar accountsMerge = function(accounts) {\\n    let graph = {};\\n    // Create graph\\n    for (const account of accounts) {\\n        let name = \\'\\';\\n        let prevEmail = null;\\n        for (let i = 0; i < account.length;i++) {\\n            if (i === 0) {\\n                // handle name\\n                name = account[i];\\n            } else {\\n                const email = account[i];\\n                if (!graph[email]) {\\n                  // add vertice to graph\\n                    graph[email] = {\\n                        edges: [],\\n                        name: name\\n                    }\\n                } \\n                if (prevEmail !== null) {\\n                    // add edges to graph if they dont already exist\\n                    if (!graph[prevEmail].edges.includes(email)) {\\n                        graph[prevEmail].edges.push(email);\\n                        graph[email].edges.push(prevEmail);\\n                    }\\n                }\\n                prevEmail = email;\\n            }\\n        }\\n    }\\n    // Create a DFS function\\n    var dfs = function(graph, node, visited, output) {\\n        visited[node] = true;\\n        output.push(node);\\n        for (const email of graph[node].edges) {\\n            if (!visited[email]) {\\n                dfs(graph, email, visited, output)\\n            }\\n        }\\n        return output;\\n    }\\n    \\n    let visited = {};\\n    const emails = Object.keys(graph);\\n    let merged = [];\\n    // DFS each unvisited email to create output\\n    for (const email of emails) {\\n        if (!visited[email]) {\\n            // Output will be created at each unvisted node\\n            //  which means after the dfs, we will have visited all connected emails on the account\\n            let output = []\\n            dfs(graph, email, visited, output)\\n            output.sort();\\n            // Add name to front after sorting\\n            output.unshift(graph[email].name)\\n            merged.push(output);\\n        }\\n    }\\n    return merged;\\n};```",
                "codeTag": "Unknown"
            },
            {
                "id": 631820,
                "title": "c-union-find-hashmap-easy-to-read-and-understand",
                "content": "```\\nclass Solution {\\n    vector<int>parent;\\n    int find(int x) {\\n        return (parent[x] == x) ? x : find(parent[x]);\\n    }\\n    \\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        \\n        unordered_map<string, int>email;\\n        parent.resize(n, 0);\\n        \\n        /* Perform union find to mark emails under same parent */\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            for (int j = 1; j < accounts[i].size(); j++) {\\n                if (email.find(accounts[i][j]) != email.end()) {\\n                    int x = find(i);\\n                    int y = find(email[accounts[i][j]]);\\n                    if (x != y)\\n                        parent[y] = x;\\n                } else {\\n                    email[accounts[i][j]] = i;\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, vector<string>>emailgroups;\\n        /* Group all emails under same parent index */\\n        for (auto it = email.begin(); it != email.end(); it++) {\\n            int x = find(it->second);\\n            emailgroups[x].push_back(it->first);\\n        }\\n     \\n        vector<vector<string>>res;\\n        for (auto it = emailgroups.begin(); it != emailgroups.end(); it++) {\\n            sort(it->second.begin(), it->second.end());\\n            vector<string>temp;\\n            /* Add name */\\n            temp.push_back(accounts[it->first][0]);\\n            /* Add emails */\\n            for (int i = 0; i < it->second.size(); i++) \\n                temp.push_back(it->second[i]);\\n            res.push_back(temp);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int>parent;\\n    int find(int x) {\\n        return (parent[x] == x) ? x : find(parent[x]);\\n    }\\n    \\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        \\n        unordered_map<string, int>email;\\n        parent.resize(n, 0);\\n        \\n        /* Perform union find to mark emails under same parent */\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            for (int j = 1; j < accounts[i].size(); j++) {\\n                if (email.find(accounts[i][j]) != email.end()) {\\n                    int x = find(i);\\n                    int y = find(email[accounts[i][j]]);\\n                    if (x != y)\\n                        parent[y] = x;\\n                } else {\\n                    email[accounts[i][j]] = i;\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int, vector<string>>emailgroups;\\n        /* Group all emails under same parent index */\\n        for (auto it = email.begin(); it != email.end(); it++) {\\n            int x = find(it->second);\\n            emailgroups[x].push_back(it->first);\\n        }\\n     \\n        vector<vector<string>>res;\\n        for (auto it = emailgroups.begin(); it != emailgroups.end(); it++) {\\n            sort(it->second.begin(), it->second.end());\\n            vector<string>temp;\\n            /* Add name */\\n            temp.push_back(accounts[it->first][0]);\\n            /* Add emails */\\n            for (int i = 0; i < it->second.size(); i++) \\n                temp.push_back(it->second[i]);\\n            res.push_back(temp);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479029,
                "title": "python-bfs-solution",
                "content": "Simple python BFS solution, build graph of email to account and email to name first, then BFS email to explore all the emails linked to the same account.\\n```\\nclass Solution:\\n    \\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        # build Graph\\n        email_to_name = {}\\n        email_to_acc = collections.defaultdict(set)\\n        for i, account in enumerate(accounts):\\n            for email in account[1:]:\\n                email_to_acc[email].add(i)\\n                email_to_name[email] = account[0]\\n        \\n        # BFS email\\n        ans = []\\n        visited = set()\\n        q = collections.deque()\\n        for email in email_to_acc:\\n            if email not in visited:\\n                name = email_to_name[email]\\n                q.append(email)\\n                visited.add(email)\\n                temp_emails = []\\n                while q:\\n                    node = q.popleft()\\n                    temp_emails.append(node)\\n                    for acc in email_to_acc[node]:\\n                        for acc_email in accounts[acc][1:]:\\n                            if acc_email not in visited:\\n                                q.append(acc_email)\\n                                visited.add(acc_email)\\n                ans.append([name]+sorted(temp_emails))\\n        return ans\\n\\t```\\n\\n    \\n",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        # build Graph\\n        email_to_name = {}\\n        email_to_acc = collections.defaultdict(set)\\n        for i, account in enumerate(accounts):\\n            for email in account[1:]:\\n                email_to_acc[email].add(i)\\n                email_to_name[email] = account[0]\\n        \\n        # BFS email\\n        ans = []\\n        visited = set()\\n        q = collections.deque()\\n        for email in email_to_acc:\\n            if email not in visited:\\n                name = email_to_name[email]\\n                q.append(email)\\n                visited.add(email)\\n                temp_emails = []\\n                while q:\\n                    node = q.popleft()\\n                    temp_emails.append(node)\\n                    for acc in email_to_acc[node]:\\n                        for acc_email in accounts[acc][1:]:\\n                            if acc_email not in visited:\\n                                q.append(acc_email)\\n                                visited.add(acc_email)\\n                ans.append([name]+sorted(temp_emails))\\n        return ans\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 438817,
                "title": "go-270ms-solution-beat-96-with-comments",
                "content": "```go\\nfunc accountsMerge(accounts [][]string) [][]string {\\n\\t// key: email, value: index of accounts\\n\\temailMap := make(map[string]int)\\n\\t// indexConnections, initial state: indexConnections[i]=i\\n\\t// if indexConnections[i]=j, i and j are connected\\n\\tindexConnections := make([]int, len(accounts))\\n\\tfor i := range indexConnections {\\n\\t\\tindexConnections[i] = i\\n\\t}\\n\\n\\tfor accountIndex, emails := range accounts {\\n\\t\\tfor i := 1; i < len(emails); i++ {\\n\\t\\t\\tif existIndex, exist := emailMap[emails[i]]; exist {\\n\\t\\t\\t\\tfor {\\n\\t\\t\\t\\t\\t// connect existIndex and accountIndex by set indexArray[existIndex] as accountIndex\\n\\t\\t\\t\\t\\t// if existIndex has connect to another index, we need connect them together\\n\\t\\t\\t\\t\\tif indexConnections[existIndex] == existIndex {\\n\\t\\t\\t\\t\\t\\tindexConnections[existIndex] = accountIndex\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\texistIndex, indexConnections[existIndex] = indexConnections[existIndex], accountIndex\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\temailMap[emails[i]] = accountIndex\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// after this, we will connect all emails belong to same person\\n\\tfor i := len(indexConnections)-1; i >= 0; i-- {\\n\\t\\tindexConnections[i] = indexConnections[indexConnections[i]]\\n\\t}\\n\\n\\t// key: accounts index, value: [name, emails...]\\n\\tmagic := make(map[int][]string)\\n\\tfor email, index := range emailMap {\\n\\t\\tif _, exist := magic[indexConnections[index]]; !exist {\\n\\t\\t\\tmagic[indexConnections[index]] = []string{accounts[index][0]}\\n\\t\\t}\\n\\t\\tmagic[indexConnections[index]] = append(magic[indexConnections[index]], email)\\n\\t}\\n\\n\\t// trans map to slice, sort emails\\n\\tretSlice := make([][]string, 0, len(magic))\\n\\tfor _, v := range magic {\\n\\t\\tsort.Strings(v[1:])\\n\\t\\tretSlice = append(retSlice, v)\\n\\t}\\n\\treturn retSlice\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc accountsMerge(accounts [][]string) [][]string {\\n\\t// key: email, value: index of accounts\\n\\temailMap := make(map[string]int)\\n\\t// indexConnections, initial state: indexConnections[i]=i\\n\\t// if indexConnections[i]=j, i and j are connected\\n\\tindexConnections := make([]int, len(accounts))\\n\\tfor i := range indexConnections {\\n\\t\\tindexConnections[i] = i\\n\\t}\\n\\n\\tfor accountIndex, emails := range accounts {\\n\\t\\tfor i := 1; i < len(emails); i++ {\\n\\t\\t\\tif existIndex, exist := emailMap[emails[i]]; exist {\\n\\t\\t\\t\\tfor {\\n\\t\\t\\t\\t\\t// connect existIndex and accountIndex by set indexArray[existIndex] as accountIndex\\n\\t\\t\\t\\t\\t// if existIndex has connect to another index, we need connect them together\\n\\t\\t\\t\\t\\tif indexConnections[existIndex] == existIndex {\\n\\t\\t\\t\\t\\t\\tindexConnections[existIndex] = accountIndex\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\texistIndex, indexConnections[existIndex] = indexConnections[existIndex], accountIndex\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\temailMap[emails[i]] = accountIndex\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t// after this, we will connect all emails belong to same person\\n\\tfor i := len(indexConnections)-1; i >= 0; i-- {\\n\\t\\tindexConnections[i] = indexConnections[indexConnections[i]]\\n\\t}\\n\\n\\t// key: accounts index, value: [name, emails...]\\n\\tmagic := make(map[int][]string)\\n\\tfor email, index := range emailMap {\\n\\t\\tif _, exist := magic[indexConnections[index]]; !exist {\\n\\t\\t\\tmagic[indexConnections[index]] = []string{accounts[index][0]}\\n\\t\\t}\\n\\t\\tmagic[indexConnections[index]] = append(magic[indexConnections[index]], email)\\n\\t}\\n\\n\\t// trans map to slice, sort emails\\n\\tretSlice := make([][]string, 0, len(magic))\\n\\tfor _, v := range magic {\\n\\t\\tsort.Strings(v[1:])\\n\\t\\tretSlice = append(retSlice, v)\\n\\t}\\n\\treturn retSlice\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123752,
                "title": "java-dfs-template-for-connected-component",
                "content": "```\\n    public static List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<String, String> emailToName = new HashMap<>(); // to construct answer\\n        Map<String, List<String>> graph = new HashMap<>();\\n        for (List<String> account : accounts) {\\n            String name = \"\";\\n            \\n            for (int i = 0; i < account.size(); i++) {\\n                String email = account.get(i);\\n                if (i == 0) {\\n                    name = email;\\n                    continue;\\n                }\\n                if (i == 1) {\\n                    graph.computeIfAbsent(email, x -> new ArrayList<>());\\n                    emailToName.put(email, name);\\n                    continue;\\n                }\\n                graph.computeIfAbsent(email, x -> new ArrayList<>()).add(account.get(1));\\n                graph.get(account.get(1)).add(email);\\n                emailToName.put(email, name);\\n            }\\n        }\\n        Set<String> visited = new HashSet<>();\\n        List<List<String>> res = new ArrayList<>();\\n        for (String email : graph.keySet()) {\\n            if (!visited.contains(email)) {\\n                \\n                visited.add(email);\\n                Stack<String> stack = new Stack<>();\\n                stack.push(email);\\n                List<String> component = new ArrayList<>();\\n                while (!stack.isEmpty()) {\\n                    String cur = stack.pop();\\n                    component.add(cur);\\n                    for (String nei : graph.get(cur)) {\\n                        \\n                        if (!visited.contains(nei)) {\\n                            stack.push(nei);\\n                            visited.add(nei);\\n                        }\\n                    }\\n                }\\n                \\n                Collections.sort(component);\\n                component.add(0, emailToName.get(email));\\n                res.add(component);\\n            }\\n        }\\n        return res;\\n    }\\n   \\n```",
                "solutionTags": [],
                "code": "```\\n    public static List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<String, String> emailToName = new HashMap<>(); // to construct answer\\n        Map<String, List<String>> graph = new HashMap<>();\\n        for (List<String> account : accounts) {\\n            String name = \"\";\\n            \\n            for (int i = 0; i < account.size(); i++) {\\n                String email = account.get(i);\\n                if (i == 0) {\\n                    name = email;\\n                    continue;\\n                }\\n                if (i == 1) {\\n                    graph.computeIfAbsent(email, x -> new ArrayList<>());\\n                    emailToName.put(email, name);\\n                    continue;\\n                }\\n                graph.computeIfAbsent(email, x -> new ArrayList<>()).add(account.get(1));\\n                graph.get(account.get(1)).add(email);\\n                emailToName.put(email, name);\\n            }\\n        }\\n        Set<String> visited = new HashSet<>();\\n        List<List<String>> res = new ArrayList<>();\\n        for (String email : graph.keySet()) {\\n            if (!visited.contains(email)) {\\n                \\n                visited.add(email);\\n                Stack<String> stack = new Stack<>();\\n                stack.push(email);\\n                List<String> component = new ArrayList<>();\\n                while (!stack.isEmpty()) {\\n                    String cur = stack.pop();\\n                    component.add(cur);\\n                    for (String nei : graph.get(cur)) {\\n                        \\n                        if (!visited.contains(nei)) {\\n                            stack.push(nei);\\n                            visited.add(nei);\\n                        }\\n                    }\\n                }\\n                \\n                Collections.sort(component);\\n                component.add(0, emailToName.get(email));\\n                res.add(component);\\n            }\\n        }\\n        return res;\\n    }\\n   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109169,
                "title": "c-union-find-hashtable",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    struct Account{\\n      string name;\\n      set<string> emails;\\n      Account *parent;\\n    \\n      Account():parent(nullptr){\\n      }\\n        \\n      Account(string n)\\n          :\\n          name(n),parent(nullptr){\\n          }\\n        \\n     void addEmail(const string &email){\\n         emails.insert(email);\\n      }\\n    \\n      void addEmails(Account *other){\\n          for(auto &e : other->emails){\\n              addEmail(e);\\n          }\\n      }\\n    \\n    };\\n    \\n    Account *find(Account *acc){\\n        if(acc->parent == nullptr){\\n            return acc;\\n        }\\n        \\n        acc->parent->addEmails(acc);\\n        acc->parent = find(acc->parent);\\n        return acc->parent;\\n    }\\n    \\n    void Union(Account *a1, Account *a2){\\n\\n        Account *r1 = find(a1);\\n        Account *r2 = find(a2);\\n            \\n        if(r1 == r2){\\n            return;\\n        }\\n        \\n        if(r1->emails.size() > r2->emails.size()){\\n            r2->parent = r1;\\n            r1->addEmails(r2);\\n        }\\n        else{\\n           r1->parent = r2;\\n           r2->addEmails(r1);\\n        }\\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string,Account*> mailToAccount;\\n        \\n        for(auto &a : accounts){\\n            Account *acc = new Account(a[0]);\\n            for(int i = 1; i < a.size(); ++i){\\n                acc->addEmail(a[i]);\\n            }\\n            \\n            for(auto &email : acc->emails){\\n                if(mailToAccount.find(email) == mailToAccount.end()){\\n                    mailToAccount[email] = acc;\\n                }\\n                else{\\n                    Union(mailToAccount[email],acc);\\n                    mailToAccount[email] = find(acc);\\n                }\\n            }\\n        }\\n        \\n        unordered_set<Account *> visited;\\n        for(auto &p : mailToAccount){\\n            visited.insert(find(p.second));\\n        }\\n            \\n        vector<vector<string> > result;\\n        for(auto &a : visited){\\n            vector<string> temp;\\n            temp.push_back(a->name);\\n            for(auto &s : a->emails){\\n                temp.push_back(s);\\n            }\\n            \\n            result.push_back(temp);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct Account{\\n      string name;\\n      set<string> emails;\\n      Account *parent;\\n    \\n      Account():parent(nullptr){\\n      }\\n        \\n      Account(string n)\\n          :\\n          name(n),parent(nullptr){\\n          }\\n        \\n     void addEmail(const string &email){\\n         emails.insert(email);\\n      }\\n    \\n      void addEmails(Account *other){\\n          for(auto &e : other->emails){\\n              addEmail(e);\\n          }\\n      }\\n    \\n    };\\n    \\n    Account *find(Account *acc){\\n        if(acc->parent == nullptr){\\n            return acc;\\n        }\\n        \\n        acc->parent->addEmails(acc);\\n        acc->parent = find(acc->parent);\\n        return acc->parent;\\n    }\\n    \\n    void Union(Account *a1, Account *a2){\\n\\n        Account *r1 = find(a1);\\n        Account *r2 = find(a2);\\n            \\n        if(r1 == r2){\\n            return;\\n        }\\n        \\n        if(r1->emails.size() > r2->emails.size()){\\n            r2->parent = r1;\\n            r1->addEmails(r2);\\n        }\\n        else{\\n           r1->parent = r2;\\n           r2->addEmails(r1);\\n        }\\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string,Account*> mailToAccount;\\n        \\n        for(auto &a : accounts){\\n            Account *acc = new Account(a[0]);\\n            for(int i = 1; i < a.size(); ++i){\\n                acc->addEmail(a[i]);\\n            }\\n            \\n            for(auto &email : acc->emails){\\n                if(mailToAccount.find(email) == mailToAccount.end()){\\n                    mailToAccount[email] = acc;\\n                }\\n                else{\\n                    Union(mailToAccount[email],acc);\\n                    mailToAccount[email] = find(acc);\\n                }\\n            }\\n        }\\n        \\n        unordered_set<Account *> visited;\\n        for(auto &p : mailToAccount){\\n            visited.insert(find(p.second));\\n        }\\n            \\n        vector<vector<string> > result;\\n        for(auto &a : visited){\\n            vector<string> temp;\\n            temp.push_back(a->name);\\n            for(auto &s : a->emails){\\n                temp.push_back(s);\\n            }\\n            \\n            result.push_back(temp);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879589,
                "title": "optimized-approach-using-disjoint-set",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First, we will create a map data structure. Then we will store each email with the respective index of the account(the email belongs to) in that map data structure.\\n2. While doing so, if we encounter an email again(i.e. If any index is previously assigned for the email), we will perform union(either unionBySize() or unionByRank()) of the current index and the previously assigned index.\\n3. After completing step 2, now it\\u2019s time to merge the accounts. For merging, we will iterate over all the emails individually and find the ultimate parent(using the findUPar() method) of the assigned index of every email. Then we will add the email of the current account to the index(account index) that is the ultimate parent. Thus the accounts will be merged.\\n4. Finally, we will sort the emails for every account separately and store the final results in the answer array accordingly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N+E) + O(E*4\\u0251) + O(N*(ElogE + E))\\nwhere N = no. of indices or nodes and E = no. of emails. The first term is for visiting all the emails. The second term is for merging the accounts. And the third term is for sorting the emails and storing them in the answer array.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)+ O(N) +O(2N) ~ O(N)\\n\\n# Code\\n```\\nclass DisjointSet {\\n    public:\\n        vector<int> parent,size;\\n\\n        DisjointSet(int n) {\\n\\n            parent.resize(n+1);\\n            size.resize(n+1);\\n\\n            for(int i=0;i<n;i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        int findUPar(int node) {\\n            if(parent[node] == node)\\n                return node;\\n\\n            return parent[node] = findUPar(parent[node]);\\n        }\\n\\n        void UnionBySize(int u,int v) {\\n            int ultimateU = findUPar(u);\\n            int ultimateV = findUPar(v);\\n\\n            if(ultimateU == ultimateV)\\n                return;\\n\\n            if(size[ultimateU] < size[ultimateV]) {\\n                parent[ultimateU] = ultimateV;\\n                size[ultimateV] += size[ultimateU];\\n            }\\n            else {\\n                parent[ultimateV] = ultimateU;\\n                size[ultimateU] += size[ultimateV];\\n            } \\n        }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n\\n        DisjointSet ds(n);\\n\\n        unordered_map<string,int> mapMailNode;\\n\\n        for(int i=0;i<n;i++) {\\n            for(int j=1;j<accounts[i].size();j++) {\\n                string mail = accounts[i][j];\\n\\n                if(mapMailNode.find(mail) == mapMailNode.end()) {\\n                    mapMailNode[mail] = i;\\n                }\\n                else {\\n                    ds.UnionBySize(i,mapMailNode[mail]);\\n                }\\n            }\\n        }\\n\\n\\n        vector<string> temp[n];\\n\\n        for(auto it:mapMailNode) {\\n            string mail = it.first;\\n\\n            int node = ds.findUPar(it.second);\\n\\n            temp[node].push_back(mail);\\n        }\\n\\n\\n        vector<vector<string>> ans;\\n\\n        for(int i=0;i<n;i++) {\\n            if(temp[i].size() == 0)\\n                continue;\\n\\n            sort(temp[i].begin(),temp[i].end());\\n\\n            vector<string> temp2;\\n            temp2.push_back(accounts[i][0]);\\n\\n            for(auto it:temp[i]) {\\n                temp2.push_back(it);\\n            }\\n\\n            ans.push_back(temp2);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n![upvote_CAT.webp](https://assets.leetcode.com/users/images/9a9f5921-782f-407a-999c-bf06c2b40309_1691464181.6623218.webp)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet {\\n    public:\\n        vector<int> parent,size;\\n\\n        DisjointSet(int n) {\\n\\n            parent.resize(n+1);\\n            size.resize(n+1);\\n\\n            for(int i=0;i<n;i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        int findUPar(int node) {\\n            if(parent[node] == node)\\n                return node;\\n\\n            return parent[node] = findUPar(parent[node]);\\n        }\\n\\n        void UnionBySize(int u,int v) {\\n            int ultimateU = findUPar(u);\\n            int ultimateV = findUPar(v);\\n\\n            if(ultimateU == ultimateV)\\n                return;\\n\\n            if(size[ultimateU] < size[ultimateV]) {\\n                parent[ultimateU] = ultimateV;\\n                size[ultimateV] += size[ultimateU];\\n            }\\n            else {\\n                parent[ultimateV] = ultimateU;\\n                size[ultimateU] += size[ultimateV];\\n            } \\n        }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n\\n        DisjointSet ds(n);\\n\\n        unordered_map<string,int> mapMailNode;\\n\\n        for(int i=0;i<n;i++) {\\n            for(int j=1;j<accounts[i].size();j++) {\\n                string mail = accounts[i][j];\\n\\n                if(mapMailNode.find(mail) == mapMailNode.end()) {\\n                    mapMailNode[mail] = i;\\n                }\\n                else {\\n                    ds.UnionBySize(i,mapMailNode[mail]);\\n                }\\n            }\\n        }\\n\\n\\n        vector<string> temp[n];\\n\\n        for(auto it:mapMailNode) {\\n            string mail = it.first;\\n\\n            int node = ds.findUPar(it.second);\\n\\n            temp[node].push_back(mail);\\n        }\\n\\n\\n        vector<vector<string>> ans;\\n\\n        for(int i=0;i<n;i++) {\\n            if(temp[i].size() == 0)\\n                continue;\\n\\n            sort(temp[i].begin(),temp[i].end());\\n\\n            vector<string> temp2;\\n            temp2.push_back(accounts[i][0]);\\n\\n            for(auto it:temp[i]) {\\n                temp2.push_back(it);\\n            }\\n\\n            ans.push_back(temp2);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781710,
                "title": "python-straightforward-union-find-approach-with-explanation-and-comments",
                "content": "# Approach\\n1. Define a UnionFind class that has Union by Rank and Find with path compression. \\n\\n2. Create a dictionary email_to_name to map each email to the name associated with it.\\n\\n3. Create an instance of the UnionFind class.\\n\\n4. For each account in the accounts list, iterate over its emails and add them to the email_to_name dictionary. Then, call the union method of the UnionFind instance to merge the first email with the current email.\\n\\n5. Create a dictionary components to store the components (sets of emails belonging to the same account).\\n\\n6. For each email in the email_to_name dictionary, find its root using the find method of the UnionFind instance and add it to the corresponding component in the components dictionary.\\n\\n7. Create an empty list result to store the final result.\\n\\n8. For each root in the components dictionary, get the name associated with it from the email_to_name dictionary, sort the list of emails associated with it in ascending order, and append a new list containing the name and sorted emails to the result list.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(NKlog(NK))$$ \\n\\n- Space complexity:\\n$$O(NK)$$\\n\\nHere $N$ is the number of accounts and $K$ is the maximum length of an account.\\n\\nUnion by Rank and Find with path compression have a constant ammortized time complexity.\\n\\n# Code\\n```\\nclass UnionFind:\\n    def __init__(self):\\n        self.root = {}\\n        self.rank = {}\\n\\n    def insert(self, element):\\n        # If the element is not already in the root dictionary, add it and set its rank to 1\\n        if element not in self.root:\\n            self.root[element] = element\\n            self.rank[element] = 1\\n\\n    def find(self, element):\\n        # Insert the element if it\\'s not already in the root dictionary\\n        self.insert(element)\\n        # If the element is its own root, return it\\n        if self.root[element] == element:\\n            return element\\n        # Otherwise, recursively find the root of the element and update its root in the dictionary\\n        self.root[element] = self.find(self.root[element])\\n        return self.root[element]\\n\\n    def union(self, x, y):\\n        # Find the roots of x and y\\n        x_root = self.find(x)\\n        y_root = self.find(y)\\n        # If the roots are different, merge them\\n        if x_root != y_root:\\n            # Merge the root with smaller rank into the root with larger rank\\n            if self.rank[x_root] > self.rank[y_root]:\\n                self.root[y_root] = x_root\\n            elif self.rank[y_root] > self.rank[x_root]:\\n                self.root[x_root] = y_root\\n            else:\\n                # If the ranks are equal, merge y_root into x_root and increment the rank of x_root\\n                self.root[y_root] = x_root\\n                self.rank[x_root] += 1\\n\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        email_to_name = {}\\n        uf = UnionFind()\\n        for account in accounts:\\n            name, *emails = account\\n            for email in emails:\\n                email_to_name[email] = name\\n                uf.union(emails[0], email)\\n        \\n        # Create a dictionary to store the components (sets of emails belonging to the same account)\\n        components = {}\\n        for email in email_to_name:\\n            root = uf.find(email)\\n            components[root] = components.get(root, []) + [email]\\n        \\n        result = []\\n        for root in components:\\n            name = email_to_name[root]\\n            emails = sorted(components[root])\\n            result.append([name] + emails)\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self):\\n        self.root = {}\\n        self.rank = {}\\n\\n    def insert(self, element):\\n        # If the element is not already in the root dictionary, add it and set its rank to 1\\n        if element not in self.root:\\n            self.root[element] = element\\n            self.rank[element] = 1\\n\\n    def find(self, element):\\n        # Insert the element if it\\'s not already in the root dictionary\\n        self.insert(element)\\n        # If the element is its own root, return it\\n        if self.root[element] == element:\\n            return element\\n        # Otherwise, recursively find the root of the element and update its root in the dictionary\\n        self.root[element] = self.find(self.root[element])\\n        return self.root[element]\\n\\n    def union(self, x, y):\\n        # Find the roots of x and y\\n        x_root = self.find(x)\\n        y_root = self.find(y)\\n        # If the roots are different, merge them\\n        if x_root != y_root:\\n            # Merge the root with smaller rank into the root with larger rank\\n            if self.rank[x_root] > self.rank[y_root]:\\n                self.root[y_root] = x_root\\n            elif self.rank[y_root] > self.rank[x_root]:\\n                self.root[x_root] = y_root\\n            else:\\n                # If the ranks are equal, merge y_root into x_root and increment the rank of x_root\\n                self.root[y_root] = x_root\\n                self.rank[x_root] += 1\\n\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        email_to_name = {}\\n        uf = UnionFind()\\n        for account in accounts:\\n            name, *emails = account\\n            for email in emails:\\n                email_to_name[email] = name\\n                uf.union(emails[0], email)\\n        \\n        # Create a dictionary to store the components (sets of emails belonging to the same account)\\n        components = {}\\n        for email in email_to_name:\\n            root = uf.find(email)\\n            components[root] = components.get(root, []) + [email]\\n        \\n        result = []\\n        for root in components:\\n            name = email_to_name[root]\\n            emails = sorted(components[root])\\n            result.append([name] + emails)\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469849,
                "title": "python-easy-disjoint-sets-union",
                "content": "```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def findParent(u):\\n            if u==parent[u]:\\n                return u\\n            else:\\n                parent[u]=findParent(parent[u])\\n                return parent[u]\\n                \\n        def unionBySize(u,v):\\n            pu,pv=findParent(u),findParent(v)\\n            if pu==pv:\\n                return \\n            elif size[pu]<size[pv]:\\n                parent[pu]=pv\\n                size[pv]+=size[pu]\\n            else:\\n                parent[pv]=pu\\n                size[pu]+=size[pv]\\n            \\n        n=len(accounts)\\n        parent=[i for i in range(n)]\\n        size=[1]*n\\n        d={}\\n        for i in range(n):\\n            for j in range(1,len(accounts[i])):\\n                s=accounts[i][j]\\n                if s not in d:\\n                    d[s]=i\\n                else:\\n                    unionBySize(i,d[s])\\n        temp=defaultdict(list)\\n        for k,v in d.items():\\n            pv=findParent(v)\\n            temp[pv].append(k)\\n        res=[]\\n        for i in temp:\\n            temp2=sorted(temp[i])\\n            ans=[accounts[i][0]]\\n            ans.extend(temp2)\\n            res.append(ans)\\n        return res\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def findParent(u):\\n            if u==parent[u]:\\n                return u\\n            else:\\n                parent[u]=findParent(parent[u])\\n                return parent[u]\\n                \\n        def unionBySize(u,v):\\n            pu,pv=findParent(u),findParent(v)\\n            if pu==pv:\\n                return \\n            elif size[pu]<size[pv]:\\n                parent[pu]=pv\\n                size[pv]+=size[pu]\\n            else:\\n                parent[pv]=pu\\n                size[pu]+=size[pv]\\n            \\n        n=len(accounts)\\n        parent=[i for i in range(n)]\\n        size=[1]*n\\n        d={}\\n        for i in range(n):\\n            for j in range(1,len(accounts[i])):\\n                s=accounts[i][j]\\n                if s not in d:\\n                    d[s]=i\\n                else:\\n                    unionBySize(i,d[s])\\n        temp=defaultdict(list)\\n        for k,v in d.items():\\n            pv=findParent(v)\\n            temp[pv].append(k)\\n        res=[]\\n        for i in temp:\\n            temp2=sorted(temp[i])\\n            ans=[accounts[i][0]]\\n            ans.extend(temp2)\\n            res.append(ans)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440606,
                "title": "solution",
                "content": "```C++ []\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>> &details) {\\n        int n = details.size();\\n        DisjointSet ds(n);\\n        unordered_map<string, int> mapMailNode;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < details[i].size(); j++) {\\n                string mail = details[i][j];\\n                if (mapMailNode.find(mail) == mapMailNode.end()) {\\n                    mapMailNode[mail] = i;\\n                }else {\\n                    ds.unionBySize(i, mapMailNode[mail]);\\n                }\\n            }\\n        }\\n        vector<string> mergedMail[n];\\n        for (auto it : mapMailNode) {\\n            string mail = it.first;\\n            int node = ds.findUPar(it.second);\\n            mergedMail[node].push_back(mail);\\n        }\\n        vector<vector<string>> ans;\\n        for (int i = 0; i < n; i++) {\\n            if (mergedMail[i].size() == 0) continue;\\n            sort(mergedMail[i].begin(), mergedMail[i].end());\\n            \\n            vector<string> temp;\\n            temp.push_back(details[i][0]);\\n            for (auto it : mergedMail[i]) temp.push_back(it);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        n = len(accounts)\\n\\n        par = [i for i in range(n)]\\n        rank = [1] * (n)\\n\\n        def find(n):\\n            p = par[n]\\n\\n            while p != par[p]:\\n                par[p] = par[par[p]]\\n                p = par[p]\\n            return p\\n\\n        def union(n1,n2):\\n            p1, p2 = find(n1),find(n2)\\n\\n            if p1 == p2:\\n                return False\\n\\n            if rank[p1] > rank[p2]:\\n                par[p2] = p1\\n                rank[p1] += rank[p2]\\n            else:\\n                par[p1] = p2\\n                rank[p2] += rank[p1]\\n            return True\\n\\n        emailtoAcc = {} #email -> index of acc\\n        for i,a in enumerate(accounts):\\n            for e in a[1:]:\\n                if e in emailtoAcc:\\n                    union(i, emailtoAcc[e])\\n                else:\\n                    emailtoAcc[e] = i\\n\\n        emailGroup = defaultdict(list) #index of acc -> list of emails\\n        for e,i in emailtoAcc.items():\\n            leader = find(i)\\n            emailGroup[leader].append(e)\\n\\n        res = []\\n        for i, email in emailGroup.items():\\n            name = accounts[i][0]\\n            res.append([name] + sorted(emailGroup[i]))\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n    static class P {\\n        Map<String, Integer> emails = new HashMap<>();\\n        List<List<String>> groups = new ArrayList<>();\\n\\n        void process(List<String> list) {\\n            Integer key = null;\\n            for (int i = 1; i < list.size(); i++) {\\n                String email = list.get(i);\\n                Integer existing = emails.get(email);\\n                if (existing != null) {\\n                    if (key == null) {\\n                        key = existing;\\n                    } else if (!key.equals(existing)){\\n                        key = merge(existing, key);\\n                    }\\n                }\\n            }\\n            List<String> group;\\n            if (key == null) {\\n                key = groups.size();\\n                groups.add(group = new ArrayList<>());\\n            } else {\\n                group = groups.get(key);\\n            }\\n            for (int i = 1; i < list.size(); i++) {\\n                String email = list.get(i);\\n                if (emails.put(email, key) == null) {\\n                    group.add(email);\\n                }\\n            }\\n        }\\n        Integer merge(Integer key1, Integer key2) {\\n            var gr1 = groups.get(key1);\\n            var gr2 = groups.get(key2);\\n            if (gr1.size() > gr2.size()) {\\n                return merge(key2, key1);\\n            }\\n            for (String email : gr1) {\\n                emails.put(email, key2);\\n            }\\n            gr2.addAll(gr1);\\n            groups.set(key1, null);\\n            return key2;\\n        }\\n    }\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<String, P> map = new HashMap<>();\\n        for (List<String> list : accounts) {\\n            String name = list.get(0);\\n            map.computeIfAbsent(name, k -> new P()).process(list);\\n        }\\n        List<List<String>> result = new ArrayList<>();\\n        for (Map.Entry<String, P> entry : map.entrySet()) {\\n            for (var group : entry.getValue().groups) {\\n                if (group != null) {\\n                    Collections.sort(group);\\n                    var r = new ArrayList<String>(group.size() + 1);\\n                    r.add(entry.getKey());\\n                    r.addAll(group);\\n                    result.add(r);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass DisjointSet {\\n    vector<int> rank, parent, size;\\npublic:\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>> &details) {\\n        int n = details.size();\\n        DisjointSet ds(n);\\n        unordered_map<string, int> mapMailNode;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < details[i].size(); j++) {\\n                string mail = details[i][j];\\n                if (mapMailNode.find(mail) == mapMailNode.end()) {\\n                    mapMailNode[mail] = i;\\n                }else {\\n                    ds.unionBySize(i, mapMailNode[mail]);\\n                }\\n            }\\n        }\\n        vector<string> mergedMail[n];\\n        for (auto it : mapMailNode) {\\n            string mail = it.first;\\n            int node = ds.findUPar(it.second);\\n            mergedMail[node].push_back(mail);\\n        }\\n        vector<vector<string>> ans;\\n        for (int i = 0; i < n; i++) {\\n            if (mergedMail[i].size() == 0) continue;\\n            sort(mergedMail[i].begin(), mergedMail[i].end());\\n            \\n            vector<string> temp;\\n            temp.push_back(details[i][0]);\\n            for (auto it : mergedMail[i]) temp.push_back(it);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        n = len(accounts)\\n\\n        par = [i for i in range(n)]\\n        rank = [1] * (n)\\n\\n        def find(n):\\n            p = par[n]\\n\\n            while p != par[p]:\\n                par[p] = par[par[p]]\\n                p = par[p]\\n            return p\\n\\n        def union(n1,n2):\\n            p1, p2 = find(n1),find(n2)\\n\\n            if p1 == p2:\\n                return False\\n\\n            if rank[p1] > rank[p2]:\\n                par[p2] = p1\\n                rank[p1] += rank[p2]\\n            else:\\n                par[p1] = p2\\n                rank[p2] += rank[p1]\\n            return True\\n\\n        emailtoAcc = {} #email -> index of acc\\n        for i,a in enumerate(accounts):\\n            for e in a[1:]:\\n                if e in emailtoAcc:\\n                    union(i, emailtoAcc[e])\\n                else:\\n                    emailtoAcc[e] = i\\n\\n        emailGroup = defaultdict(list) #index of acc -> list of emails\\n        for e,i in emailtoAcc.items():\\n            leader = find(i)\\n            emailGroup[leader].append(e)\\n\\n        res = []\\n        for i, email in emailGroup.items():\\n            name = accounts[i][0]\\n            res.append([name] + sorted(emailGroup[i]))\\n        return res\\n```\n```Java []\\nclass Solution {\\n    static class P {\\n        Map<String, Integer> emails = new HashMap<>();\\n        List<List<String>> groups = new ArrayList<>();\\n\\n        void process(List<String> list) {\\n            Integer key = null;\\n            for (int i = 1; i < list.size(); i++) {\\n                String email = list.get(i);\\n                Integer existing = emails.get(email);\\n                if (existing != null) {\\n                    if (key == null) {\\n                        key = existing;\\n                    } else if (!key.equals(existing)){\\n                        key = merge(existing, key);\\n                    }\\n                }\\n            }\\n            List<String> group;\\n            if (key == null) {\\n                key = groups.size();\\n                groups.add(group = new ArrayList<>());\\n            } else {\\n                group = groups.get(key);\\n            }\\n            for (int i = 1; i < list.size(); i++) {\\n                String email = list.get(i);\\n                if (emails.put(email, key) == null) {\\n                    group.add(email);\\n                }\\n            }\\n        }\\n        Integer merge(Integer key1, Integer key2) {\\n            var gr1 = groups.get(key1);\\n            var gr2 = groups.get(key2);\\n            if (gr1.size() > gr2.size()) {\\n                return merge(key2, key1);\\n            }\\n            for (String email : gr1) {\\n                emails.put(email, key2);\\n            }\\n            gr2.addAll(gr1);\\n            groups.set(key1, null);\\n            return key2;\\n        }\\n    }\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<String, P> map = new HashMap<>();\\n        for (List<String> list : accounts) {\\n            String name = list.get(0);\\n            map.computeIfAbsent(name, k -> new P()).process(list);\\n        }\\n        List<List<String>> result = new ArrayList<>();\\n        for (Map.Entry<String, P> entry : map.entrySet()) {\\n            for (var group : entry.getValue().groups) {\\n                if (group != null) {\\n                    Collections.sort(group);\\n                    var r = new ArrayList<String>(group.size() + 1);\\n                    r.add(entry.getKey());\\n                    r.addAll(group);\\n                    result.add(r);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406352,
                "title": "dsu-disjoint-set",
                "content": "# Code\\n```\\nclass DSU{\\n    private:\\n        const int N = 1e6+10;\\n        vector<int> parent, size, rank;\\n    public:\\n        DSU(){\\n            parent.resize(N);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(N,1);\\n            rank.resize(N,0);\\n        }\\n        DSU(int n){\\n            parent.resize(n+1);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(n+1,1);\\n            rank.resize(n+1,0);\\n        }\\n        int find(int v){\\n            if(parent[v] == v) return v;\\n            //path compression\\n            return parent[v] = find(parent[v]);\\n        }\\n        void unionS(int a,int b){\\n            a = find(a);\\n            b = find(b);\\n            if(a!=b){\\n                //union by size\\n                if(size[a] < size[b]) swap(a,b);\\n                parent[b] = a;\\n                size[a] += size[b];\\n            }\\n        }\\n        void unionR(int x, int y) {\\n            x = find(x), y = find(y);\\n            if(x == y) return;\\n            //union by rank\\n            else if(rank[x] < rank[y]) parent[x] = y;\\n            else if (rank[x] > rank[y]) parent[y] = x;\\n            else parent[y] = x,rank[x]++;\\n      }\\n};\\nclass Solution {\\nprivate:\\n    unordered_map<string,int> mergeEmails(vector<vector<string>>& A,DSU& ds){\\n        int n = size(A);\\n        unordered_map<string,int> mp;\\n        for(int i=0; i<n; ++i){\\n            int m = size(A[i]);\\n            for(int j=1; j<m; ++j){\\n                if(mp.count(A[i][j])) ds.unionS(i,mp[A[i][j]]);\\n                mp[A[i][j]] = i;\\n            }\\n        }\\n        return mp;\\n    }\\n    unordered_map<int,vector<string>> emailsMapping(unordered_map<string,int>& mp,DSU& ds){\\n        unordered_map<int,vector<string>> merge;\\n        for(auto&&[email,index]: mp){\\n            index = ds.find(index);\\n            merge[index].push_back(email);\\n        }\\n        return merge;\\n    }\\n    vector<vector<string>> buildAnswer(vector<vector<string>>& A,unordered_map<int,vector<string>>& merge){\\n        vector<vector<string>> ans;\\n        for(auto&&[index,emails]: merge){\\n            vector<string> person {A[index][0]};\\n            person.insert(end(person),begin(emails),end(emails));\\n            sort(begin(person)+1,end(person));\\n            ans.push_back(person);\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& A) {\\n        int n = size(A);\\n        DSU ds(n-1);\\n        auto merge_emails = mergeEmails(A,ds);\\n        auto emails_mapping = emailsMapping(merge_emails,ds);\\n        auto ans = buildAnswer(A,emails_mapping);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Union Find"
                ],
                "code": "```\\nclass DSU{\\n    private:\\n        const int N = 1e6+10;\\n        vector<int> parent, size, rank;\\n    public:\\n        DSU(){\\n            parent.resize(N);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(N,1);\\n            rank.resize(N,0);\\n        }\\n        DSU(int n){\\n            parent.resize(n+1);\\n            iota(begin(parent),end(parent),0);\\n            size.resize(n+1,1);\\n            rank.resize(n+1,0);\\n        }\\n        int find(int v){\\n            if(parent[v] == v) return v;\\n            //path compression\\n            return parent[v] = find(parent[v]);\\n        }\\n        void unionS(int a,int b){\\n            a = find(a);\\n            b = find(b);\\n            if(a!=b){\\n                //union by size\\n                if(size[a] < size[b]) swap(a,b);\\n                parent[b] = a;\\n                size[a] += size[b];\\n            }\\n        }\\n        void unionR(int x, int y) {\\n            x = find(x), y = find(y);\\n            if(x == y) return;\\n            //union by rank\\n            else if(rank[x] < rank[y]) parent[x] = y;\\n            else if (rank[x] > rank[y]) parent[y] = x;\\n            else parent[y] = x,rank[x]++;\\n      }\\n};\\nclass Solution {\\nprivate:\\n    unordered_map<string,int> mergeEmails(vector<vector<string>>& A,DSU& ds){\\n        int n = size(A);\\n        unordered_map<string,int> mp;\\n        for(int i=0; i<n; ++i){\\n            int m = size(A[i]);\\n            for(int j=1; j<m; ++j){\\n                if(mp.count(A[i][j])) ds.unionS(i,mp[A[i][j]]);\\n                mp[A[i][j]] = i;\\n            }\\n        }\\n        return mp;\\n    }\\n    unordered_map<int,vector<string>> emailsMapping(unordered_map<string,int>& mp,DSU& ds){\\n        unordered_map<int,vector<string>> merge;\\n        for(auto&&[email,index]: mp){\\n            index = ds.find(index);\\n            merge[index].push_back(email);\\n        }\\n        return merge;\\n    }\\n    vector<vector<string>> buildAnswer(vector<vector<string>>& A,unordered_map<int,vector<string>>& merge){\\n        vector<vector<string>> ans;\\n        for(auto&&[index,emails]: merge){\\n            vector<string> person {A[index][0]};\\n            person.insert(end(person),begin(emails),end(emails));\\n            sort(begin(person)+1,end(person));\\n            ans.push_back(person);\\n        }\\n        return ans;\\n    }\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& A) {\\n        int n = size(A);\\n        DSU ds(n-1);\\n        auto merge_emails = mergeEmails(A,ds);\\n        auto emails_mapping = emailsMapping(merge_emails,ds);\\n        auto ans = buildAnswer(A,emails_mapping);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218976,
                "title": "accounts-merge-c-99-31-faster",
                "content": "```\\nclass DisjointSet{\\npublic:\\n    vector<int> parent,size;\\n    DisjointSet(int n){\\n        parent.resize(n);\\n        size.resize(n,1);\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n    }\\n    \\n    int findUpar(int node){\\n        if(node==parent[node]) return node;\\n        \\n        return parent[node]=findUpar(parent[node]);\\n    }\\n    \\n    void unionByRank(int u,int v){\\n        int ulp_u=findUpar(u);\\n        int ulp_v=findUpar(v);\\n        if(ulp_u==ulp_v) return;\\n        else if(size[ulp_u]<size[ulp_v]){\\n            parent[ulp_u]=ulp_v;\\n            size[ulp_v]+=size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v]=ulp_u;\\n            size[ulp_u]+=size[ulp_v];\\n        }\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n=accounts.size();\\n        DisjointSet ds(n);\\n        unordered_map<string,int> mp;\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<accounts[i].size();j++){\\n                if(mp.find(accounts[i][j])==mp.end()){\\n                    mp[accounts[i][j]]=i;\\n                }\\n                else{\\n                     ds.unionByRank(mp[accounts[i][j]],i);\\n                }\\n            }\\n        }\\n        vector<string> mergeMail[n];\\n        \\n        for(auto it:mp){\\n            string mail=it.first;\\n            int node=it.second;\\n            mergeMail[ds.findUpar(node)].push_back(mail);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        \\n        for(int i=0;i<n;i++){\\n            if(mergeMail[i].size()==0) continue;\\n            string name=accounts[i][0];\\n            vector<string> mails;\\n            mails.push_back(name);\\n            sort(mergeMail[i].begin(),mergeMail[i].end());\\n            for(int j=0;j<mergeMail[i].size();j++){\\n                mails.push_back(mergeMail[i][j]);\\n            }\\n            ans.push_back(mails);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass DisjointSet{\\npublic:\\n    vector<int> parent,size;\\n    DisjointSet(int n){\\n        parent.resize(n);\\n        size.resize(n,1);\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n    }\\n    \\n    int findUpar(int node){\\n        if(node==parent[node]) return node;\\n        \\n        return parent[node]=findUpar(parent[node]);\\n    }\\n    \\n    void unionByRank(int u,int v){\\n        int ulp_u=findUpar(u);\\n        int ulp_v=findUpar(v);\\n        if(ulp_u==ulp_v) return;\\n        else if(size[ulp_u]<size[ulp_v]){\\n            parent[ulp_u]=ulp_v;\\n            size[ulp_v]+=size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v]=ulp_u;\\n            size[ulp_u]+=size[ulp_v];\\n        }\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n=accounts.size();\\n        DisjointSet ds(n);\\n        unordered_map<string,int> mp;\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<accounts[i].size();j++){\\n                if(mp.find(accounts[i][j])==mp.end()){\\n                    mp[accounts[i][j]]=i;\\n                }\\n                else{\\n                     ds.unionByRank(mp[accounts[i][j]],i);\\n                }\\n            }\\n        }\\n        vector<string> mergeMail[n];\\n        \\n        for(auto it:mp){\\n            string mail=it.first;\\n            int node=it.second;\\n            mergeMail[ds.findUpar(node)].push_back(mail);\\n        }\\n        \\n        vector<vector<string>> ans;\\n        \\n        for(int i=0;i<n;i++){\\n            if(mergeMail[i].size()==0) continue;\\n            string name=accounts[i][0];\\n            vector<string> mails;\\n            mails.push_back(name);\\n            sort(mergeMail[i].begin(),mergeMail[i].end());\\n            for(int j=0;j<mergeMail[i].size();j++){\\n                mails.push_back(mergeMail[i][j]);\\n            }\\n            ans.push_back(mails);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184187,
                "title": "union-find-faster-code-logical-reasoning-behind-every-data-structures-used",
                "content": "```\\nclass Solution {\\npublic:\\n    // union find in emails\\n    int find(int i,vector<int>&parent,int &deep,vector<int>&rank){\\n        if(i==parent[i]) return i;\\n        parent[i]=find(parent[i],parent,++deep,rank);\\n        rank[i]+=deep;\\n        return parent[i];\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n              //  email name\\n        vector<pair<string,string>>v;\\n        for(auto &vec:accounts)\\n          for(int i=1;i<vec.size();i++)\\n\\t\\t     v.push_back({vec[i],vec[0]});\\n             \\n        vector<int>parent(v.size());\\n        vector<int>rank(v.size(),1);\\n\\t\\t\\n        for(int i=0;i<parent.size();i++) parent[i]=i;\\n        \\n        unordered_map<string,int>mp;\\n        vector<bool>vis(parent.size());\\n        \\n        int cnt=0,tp;\\n         // cnt  uniquely differentiate each email (for ex= first email key is 1 ,second has 2 and so on)\\n        for(auto &vec:accounts){\\n             int p;\\n             if(mp.count(v[cnt].first)==0) p=find(cnt,parent,tp=0,rank),mp[v[cnt].first]=cnt;\\n             else p=find(mp[v[cnt].first],parent,tp=0,rank),vis[cnt]=1;  // if already email comes we skip it by making it visited\\n             cnt++;\\n            \\n             for(int i=2;i<vec.size();i++,cnt++){\\n                 int t;\\n                 if(mp.count(v[cnt].first)==0) t=find(cnt,parent,tp=0,rank),mp[v[cnt].first]=cnt;\\n                 else t=find(mp[v[cnt].first],parent,tp=0,rank),vis[cnt]=1;\\n                 if(t==p) continue;\\n                 else if(rank[p]<rank[t]) parent[p]=t;\\n                 else parent[t]=p;\\n             }\\n        }\\n        vector<vector<string>>ans;\\n        // print name of corresponding parent email\\n        for(int i=0;i<parent.size();i++){\\n            if(vis[i]) continue;\\n            int p=find(i,parent,tp=0,rank);\\n            string ofp=v[p].second;\\n            vector<string>ss; ss.push_back(ofp);\\n            vector<string>temp;\\n             for(int j=0;j<parent.size();j++)\\n                 if(!vis[j] and find(j,parent,tp=0,rank)==p)\\n                     temp.push_back(v[j].first), vis[j]=1;\\n            sort(temp.begin(),temp.end());\\n            for(auto &str:temp) ss.push_back(str);\\n            ans.push_back(ss);\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "class Solution {\\npublic:\\n    // union find in emails\\n    int find(int i,vector<int>&parent,int &deep,vector<int>&rank){\\n        if(i==parent[i]) return i;\\n        parent[i]=find(parent[i],parent,++deep,rank);\\n        rank[i]+=deep;\\n        return parent[i];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2914842,
                "title": "c-dsu-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(V*V)\\n\\n- Space complexity:O(V)\\n\\n# Code\\n```\\nclass disjointset{\\n    public:\\n    vector<int>par;\\n    disjointset(int n){\\n        par.resize(n+1);\\n        for(int i=0; i<=n; i++){par[i]=i;}\\n    }\\n    int findp(int u){\\n        if(par[u]==u){return u;}\\n        return par[u]=findp(par[u]);\\n    }\\n    void un(int u, int v){\\n        par[findp(u)]=par[findp(v)];\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        disjointset d(accounts.size());\\n        unordered_map<string, int>m;\\n        for(int i=0; i<accounts.size(); i++){\\n            for(int j=1; j<accounts[i].size(); j++){\\n                if(m.find(accounts[i][j])==m.end()){\\n                    m[accounts[i][j]]=i;\\n                }\\n                else{\\n                    d.un(i, m[accounts[i][j]]);\\n                }\\n            }\\n        }\\n        vector<string>v[accounts.size()];\\n        vector<vector<string>>ans;\\n        for(auto it: m){\\n            v[d.findp(it.second)].push_back(it.first);\\n        }\\n        for(int i=0; i<accounts.size(); i++){\\n            if(v[i].size()==0){continue;}\\n            sort(v[i].begin(), v[i].end());\\n            vector<string>temp;\\n            temp.push_back(accounts[i][0]);\\n            for(auto it: v[i]){\\n                temp.push_back(it);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass disjointset{\\n    public:\\n    vector<int>par;\\n    disjointset(int n){\\n        par.resize(n+1);\\n        for(int i=0; i<=n; i++){par[i]=i;}\\n    }\\n    int findp(int u){\\n        if(par[u]==u){return u;}\\n        return par[u]=findp(par[u]);\\n    }\\n    void un(int u, int v){\\n        par[findp(u)]=par[findp(v)];\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        disjointset d(accounts.size());\\n        unordered_map<string, int>m;\\n        for(int i=0; i<accounts.size(); i++){\\n            for(int j=1; j<accounts[i].size(); j++){\\n                if(m.find(accounts[i][j])==m.end()){\\n                    m[accounts[i][j]]=i;\\n                }\\n                else{\\n                    d.un(i, m[accounts[i][j]]);\\n                }\\n            }\\n        }\\n        vector<string>v[accounts.size()];\\n        vector<vector<string>>ans;\\n        for(auto it: m){\\n            v[d.findp(it.second)].push_back(it.first);\\n        }\\n        for(int i=0; i<accounts.size(); i++){\\n            if(v[i].size()==0){continue;}\\n            sort(v[i].begin(), v[i].end());\\n            vector<string>temp;\\n            temp.push_back(accounts[i][0]);\\n            for(auto it: v[i]){\\n                temp.push_back(it);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845317,
                "title": "python-solution-union-find-map-counter-insort-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolve the problem via majorly 2 Data Structure in combination i.e\\nUnion-Find + HashMap\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUnion and Find to reduce the accounts to unique groups\\n\\nConcepts :\\n- Union-Find (custom class)\\n- dict & defaultdict (collections)\\n- counter (itertools)\\n- insort (bisect)\\n\\n\\n# Code\\n```\\n# from bisect import insort\\n# from collections import defaultdict\\n# from itertools import count\\n\\nclass UnionFind:\\n    def __init__(self, n) -> None:\\n        self.parent = [i for i in range(n)] # parent of each group\\n        self.grpCnt = n  # total groups \\n    \\n    def find(self, x):\\n        while x != self.parent[x]:\\n            x = self.parent[x]\\n        return x\\n\\n    def union(self, x, y):\\n        pre_x = self.find(x)\\n        pre_y = self.find(y)\\n        if pre_x != pre_y: # if not merged already \\n            # Surely the first [x] would be the lead of group based on first come first serve\\n            self.parent[pre_y] = pre_x \\n            self.grpCnt -= 1\\n\\nclass Solution:\\n    def accountsMerge(self, accounts:  List[List[str]]) -> List[List[str]]:\\n        emailToAcc = {}  # email -> account_idx\\n        uf = UnionFind(len(accounts))\\n\\n        for idx, account in enumerate(accounts):\\n            for email in account[1:]:\\n                if email in emailToAcc:\\n                    # Already account registered in some group\\n                    rootGrpId = emailToAcc[email]\\n                    uf.union(rootGrpId, idx)   # club current account to registered group\\n                else:\\n                    # Account not registered yet\\n                    emailToAcc[email] = idx\\n        \\n        # Now the Accounts info is clubbed\\n\\n        # counter mechanism to find the pos of unique grp in result list\\n        cntr = count()\\n        grpToPos = defaultdict(cntr.__next__)\\n        merged = [[] for _ in range(uf.grpCnt)]\\n\\n        # Combine all emails to specific group\\n        for email, accId in emailToAcc.items():\\n            grpId = uf.find(accId)  # this [accId] belongs to which grp ?\\n            pos = grpToPos[grpId]\\n            insort(merged[pos], email)  # Insertion Sort to maintain order\\n\\n        # Add name at the start of each merged result\\n        for accId, mergePos in grpToPos.items():\\n            name = accounts[accId][0]\\n            merged[mergePos].insert(0, name)\\n\\n        return merged\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\n# from bisect import insort\\n# from collections import defaultdict\\n# from itertools import count\\n\\nclass UnionFind:\\n    def __init__(self, n) -> None:\\n        self.parent = [i for i in range(n)] # parent of each group\\n        self.grpCnt = n  # total groups \\n    \\n    def find(self, x):\\n        while x != self.parent[x]:\\n            x = self.parent[x]\\n        return x\\n\\n    def union(self, x, y):\\n        pre_x = self.find(x)\\n        pre_y = self.find(y)\\n        if pre_x != pre_y: # if not merged already \\n            # Surely the first [x] would be the lead of group based on first come first serve\\n            self.parent[pre_y] = pre_x \\n            self.grpCnt -= 1\\n\\nclass Solution:\\n    def accountsMerge(self, accounts:  List[List[str]]) -> List[List[str]]:\\n        emailToAcc = {}  # email -> account_idx\\n        uf = UnionFind(len(accounts))\\n\\n        for idx, account in enumerate(accounts):\\n            for email in account[1:]:\\n                if email in emailToAcc:\\n                    # Already account registered in some group\\n                    rootGrpId = emailToAcc[email]\\n                    uf.union(rootGrpId, idx)   # club current account to registered group\\n                else:\\n                    # Account not registered yet\\n                    emailToAcc[email] = idx\\n        \\n        # Now the Accounts info is clubbed\\n\\n        # counter mechanism to find the pos of unique grp in result list\\n        cntr = count()\\n        grpToPos = defaultdict(cntr.__next__)\\n        merged = [[] for _ in range(uf.grpCnt)]\\n\\n        # Combine all emails to specific group\\n        for email, accId in emailToAcc.items():\\n            grpId = uf.find(accId)  # this [accId] belongs to which grp ?\\n            pos = grpToPos[grpId]\\n            insort(merged[pos], email)  # Insertion Sort to maintain order\\n\\n        # Add name at the start of each merged result\\n        for accId, mergePos in grpToPos.items():\\n            name = accounts[accId][0]\\n            merged[mergePos].insert(0, name)\\n\\n        return merged\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774679,
                "title": "accounts-merge-java-dfs-bfs",
                "content": "# Merge Accounts\\n\\n1. In this approach, we need to make a graph (adjaceny list), where each email is a node and every node is connected to its first email.\\n![step1.PNG](https://assets.leetcode.com/users/images/77043d7b-3d90-4dfe-8d12-239a689d49dd_1672654436.677998.png)\\n\\n2. The adjacency list is a hashmap of email as key and list of emails as its adjacent node/ neighbour. It will be a bidirected graph.\\n3. We will do a DFS/BFS from its first node and merge all the emails of the same person.\\n![step2.PNG](https://assets.leetcode.com/users/images/6733be22-bd16-4cd3-bef5-af69e9041b57_1672654476.7702694.png)\\n\\n4. add the name of the person at the beginning of the list and add the list to the result and return the result\\n![step3 and 4.PNG](https://assets.leetcode.com/users/images/57754d3b-7154-4c09-9994-bff9945cad0b_1672654507.271698.png)\\n\\n```java\\nclass Solution {\\n    Set<String> visited = new HashSet<>();\\n \\n    HashMap<String,List<String>> adjList = new HashMap<>();\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n    // create the graph the from accounts\\n        for(List<String> account : accounts){\\n            // get(1) bcz 0 index is name\\n            String firstEmail = account.get(1);\\n            int accountSize = account.size();\\n            for(int index = 2;index < accountSize;index++){\\n                String email = account.get(index);\\n                if(!adjList.containsKey(firstEmail)){\\n                    adjList.put(firstEmail,new ArrayList<String>());\\n                }\\n                adjList.get(firstEmail).add(email);\\n                if(!adjList.containsKey(email)){\\n                    adjList.put(email, new ArrayList<String>());\\n                }\\n                adjList.get(email).add(firstEmail);\\n            }\\n        }\\n        // DFS from all the nodes\\n         List<List<String>> res = new ArrayList<>();\\n        for(List<String> account: accounts){\\n            String name = account.get(0);\\n            // firstEmail\\n            String firstEmail = account.get(1);\\n            \\n            if (!visited.contains(firstEmail)){\\n            ArrayList<String> mergeAccount = new ArrayList<>();\\n            mergeAccount.add(name);\\n            DFS(mergeAccount,firstEmail);\\n            Collections.sort(mergeAccount.subList(1,mergeAccount.size()));\\n            res.add(mergeAccount);\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n\\n        public void DFS(List<String>mergeAccount, String email){\\n            visited.add(email);\\n            mergeAccount.add(email);\\n            \\n             if (!adjList.containsKey(email)) {\\n                    return;\\n                }\\n            \\n            for (String neighbour: adjList.get(email)){\\n                \\n                if(!visited.contains(neighbour)){\\n                    DFS(mergeAccount,neighbour);\\n                }\\n            }\\n        }\\n    \\n    \\n}\\n\\n```\\nThe Same problem can be solved using **BFS.**\\n```java\\nclass Solution {\\n        //  adjacency list\\n        Map<String, List<String> > adjList = new HashMap<>();\\n        // set of visited email\\n        Set<String> visited = new HashSet<>();\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n// step 1: make a adj list\\n        for(List<String> account: accounts){\\n            String firstEmail = account.get(1);\\n            int numberOfEmail = account.size();\\n            List<String> neigh;\\n            for(int index=2; index<numberOfEmail ; index++){\\n                String email = account.get(index);\\n                // to create bidirectional graph\\n                neigh = adjList.containsKey(firstEmail) ? adjList.get(firstEmail): new ArrayList<String>();\\n                neigh.add(email);\\n                adjList.put(firstEmail, neigh);\\n                neigh = adjList.containsKey(email) ? adjList.get(email): new ArrayList<String>();\\n                neigh.add(firstEmail);\\n                adjList.put(email, neigh);\\n            }\\n        }\\n        List<List<String>> result = new ArrayList<>();\\n        // step 3: Start the BFS\\n        for(List<String> account: accounts){\\n            String name = account.get(0);\\n            String firstEmail = account.get(1);\\n            List<String> mergeAccount = new ArrayList<>();\\n            if(!visited.contains(firstEmail)){\\n                mergeAccount.add(name);\\n                BFS(mergeAccount, firstEmail);\\n// Step 4: sort the Arraylist from 1 to size and add it to the result\\n                Collections.sort(mergeAccount.subList(1,mergeAccount.size()));\\n                result.add(mergeAccount);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public void BFS(List<String> mergeAccount, String email){\\n        \\n        Queue<String> accounts = new ArrayDeque<>();\\n        accounts.offer(email);\\n        while (!accounts.isEmpty()){\\n            String account = accounts.poll();\\n            if(visited.contains(account)) continue;\\n\\n            visited.add(account);\\n            mergeAccount.add(account);\\n            List<String> neighbour = adjList.get(account);\\n            if(neighbour == null) return ;\\n            \\n            int noOfNeighbour = neighbour.size();\\n            for(int i=0; i< noOfNeighbour; i++){\\n                String neigh = neighbour.get(i);\\n                if(!visited.contains(neigh)){\\n                    accounts.offer(neigh);\\n            }\\n            }\\n        }\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```java\\nclass Solution {\\n    Set<String> visited = new HashSet<>();\\n \\n    HashMap<String,List<String>> adjList = new HashMap<>();\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n    // create the graph the from accounts\\n        for(List<String> account : accounts){\\n            // get(1) bcz 0 index is name\\n            String firstEmail = account.get(1);\\n            int accountSize = account.size();\\n            for(int index = 2;index < accountSize;index++){\\n                String email = account.get(index);\\n                if(!adjList.containsKey(firstEmail)){\\n                    adjList.put(firstEmail,new ArrayList<String>());\\n                }\\n                adjList.get(firstEmail).add(email);\\n                if(!adjList.containsKey(email)){\\n                    adjList.put(email, new ArrayList<String>());\\n                }\\n                adjList.get(email).add(firstEmail);\\n            }\\n        }\\n        // DFS from all the nodes\\n         List<List<String>> res = new ArrayList<>();\\n        for(List<String> account: accounts){\\n            String name = account.get(0);\\n            // firstEmail\\n            String firstEmail = account.get(1);\\n            \\n            if (!visited.contains(firstEmail)){\\n            ArrayList<String> mergeAccount = new ArrayList<>();\\n            mergeAccount.add(name);\\n            DFS(mergeAccount,firstEmail);\\n            Collections.sort(mergeAccount.subList(1,mergeAccount.size()));\\n            res.add(mergeAccount);\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n\\n        public void DFS(List<String>mergeAccount, String email){\\n            visited.add(email);\\n            mergeAccount.add(email);\\n            \\n             if (!adjList.containsKey(email)) {\\n                    return;\\n                }\\n            \\n            for (String neighbour: adjList.get(email)){\\n                \\n                if(!visited.contains(neighbour)){\\n                    DFS(mergeAccount,neighbour);\\n                }\\n            }\\n        }\\n    \\n    \\n}\\n\\n```\n```java\\nclass Solution {\\n        //  adjacency list\\n        Map<String, List<String> > adjList = new HashMap<>();\\n        // set of visited email\\n        Set<String> visited = new HashSet<>();\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n// step 1: make a adj list\\n        for(List<String> account: accounts){\\n            String firstEmail = account.get(1);\\n            int numberOfEmail = account.size();\\n            List<String> neigh;\\n            for(int index=2; index<numberOfEmail ; index++){\\n                String email = account.get(index);\\n                // to create bidirectional graph\\n                neigh = adjList.containsKey(firstEmail) ? adjList.get(firstEmail): new ArrayList<String>();\\n                neigh.add(email);\\n                adjList.put(firstEmail, neigh);\\n                neigh = adjList.containsKey(email) ? adjList.get(email): new ArrayList<String>();\\n                neigh.add(firstEmail);\\n                adjList.put(email, neigh);\\n            }\\n        }\\n        List<List<String>> result = new ArrayList<>();\\n        // step 3: Start the BFS\\n        for(List<String> account: accounts){\\n            String name = account.get(0);\\n            String firstEmail = account.get(1);\\n            List<String> mergeAccount = new ArrayList<>();\\n            if(!visited.contains(firstEmail)){\\n                mergeAccount.add(name);\\n                BFS(mergeAccount, firstEmail);\\n// Step 4: sort the Arraylist from 1 to size and add it to the result\\n                Collections.sort(mergeAccount.subList(1,mergeAccount.size()));\\n                result.add(mergeAccount);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public void BFS(List<String> mergeAccount, String email){\\n        \\n        Queue<String> accounts = new ArrayDeque<>();\\n        accounts.offer(email);\\n        while (!accounts.isEmpty()){\\n            String account = accounts.poll();\\n            if(visited.contains(account)) continue;\\n\\n            visited.add(account);\\n            mergeAccount.add(account);\\n            List<String> neighbour = adjList.get(account);\\n            if(neighbour == null) return ;\\n            \\n            int noOfNeighbour = neighbour.size();\\n            for(int i=0; i< noOfNeighbour; i++){\\n                String neigh = neighbour.get(i);\\n                if(!visited.contains(neigh)){\\n                    accounts.offer(neigh);\\n            }\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495269,
                "title": "python-simple-explanation-of-confusing-solution",
                "content": "What is difficult about this problem is to identify what to take as `Nodes` and what to take as `Edges`. \\n\\nTaking `Accounts` as `Nodes` seems natural. But then, the confusion comes if you blindly treat `Emails` as `Edges`. \\n\\nSince one `Email` can link _multiple_ `Accounts`, thinking of it as an `Edge` quickly becomes confusing: in a regular graph, one `Edge` can link only **2** `Nodes`. But here, **M** `Nodes` can be linked by 1 `Email`.\\n\\nSo, I propose to think about `Email` as purely ***Abstract Indication*** that some **K** `Accounts` are linked, `K` can be anything from `{0,1,..}`.\\n\\nWe track this information by building the map between Email and the Accounts it links, e.g.:\\n`Email -> [Account1, Account4, ..., AccountJ]`\\n\\nThen, the solution boils down to launching dfs from each and every Account and exploring what other Accounts can be reached (out of those that have not been reached yet). And while doing dfs, to identify the connections between Nodes (Accounts), we use this map we created earlier:\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n```\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \\n        emails_to_accounts = defaultdict(set)\\n        \\n        for i, account in enumerate(accounts):\\n            for email in account[1:]:\\n                emails_to_accounts[email].add(i)\\n                \\n        output = []\\n        \\n        visited_accounts = set()\\n        \\n        for i, account in enumerate(accounts):\\n            \\n            if i in visited_accounts:\\n                continue\\n            \\n            name = account[0]\\n            emails = account[1:]\\n            \\n            current_merged_emails = set()\\n            stack = [i]\\n            \\n            # dfs\\n            while stack:\\n                current_account = stack.pop()\\n                if current_account in visited_accounts:\\n                    continue\\n                    \\n                visited_accounts.add(current_account)\\n                \\n                # get all accounts\\n                current_emails = accounts[current_account][1:]\\n                current_merged_emails.update(current_emails)\\n                for current_email in current_emails:\\n                    stack += emails_to_accounts[current_email]\\n                    \\n            output.append([name]+sorted(list(current_merged_emails)))\\n    \\n        return output",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226610,
                "title": "simple-dfs-solution-find-connected-components-and-we-will-get-our-answer",
                "content": "we first make our adjacency list\\n1. we first traverse the given accounts vector\\n2. we only connect the emails to the account holder name , no need to connect every email to other.\\n3. now here comes the smart or creative way , since two persons can have same names , but we have to make sure they are not connected or they form two different components , \\n4. we will take a variable \"backchar\" and initialize it to 1, and every time we connect the emails to the account name, we will insert back the back char to the name and increment the backchar , so the next time even if the name is same the name we will be adding in our adj will be name+to_string(backchar) **(see the code for better understanding)** (if you can implement this then your problem is half sloved)\\n\\nafter we have made our adj list we will traverse the adj list like this\\n1. we take the key value of our list or map and check if it is not a email (implemented a finutil function , if we found a \\'@\\' in string return false) and if its not yet visited\\n2. we will initialize a set<string> emails and call the dfs function , which traverses the whole connected component and only insert emails in our set , again by checking with findutil function that we have made\\n3.  after dfs we will store the emails in the name on which we have called the dfs\\n4.  but before inserting the name , we have to pop back the integers , that we added through our backchar variable ,\\n5.  and after the for loop we will return our result vector\\n\\nsee the code , i have given comments whereever needed\\n\\n```\\nunordered_map<string, vector<string>> adj;\\nunordered_map<string, bool> vis;\\nclass Solution {\\npublic:\\n    bool findutil(string s) // this function will return true if its not a email , and a name\\n    {\\n        for(auto x:s)\\n            if(x==\\'@\\')\\n                return false;\\n        return true;\\n    }\\n    void dfs(string x, set<string>& emails)\\n    {\\n\\t\\t// simple dfs\\n        vis[x]=true;\\n        if(!findutil(x)) // inserting if its an email\\n            emails.insert(x);\\n        for(auto y:adj[x])\\n            if(!vis[y])\\n                dfs(y, emails);\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int backchar=1;\\n        adj.clear(); vis.clear();\\n        for(auto x:accounts)\\n        {\\n            string name= x[0];\\n            if(adj.find(name)!=adj.end())\\n            {\\n                name+=to_string(backchar); // to differntiate two persons with the same name\\n                backchar++;\\n                \\n            }\\n            for(int i=1; i<x.size(); i++)\\n            {\\n                adj[name].push_back(x[i]); // connecting the emails to the perosn \\n                adj[x[i]].push_back(name); // it is an undirected graph \\n            }\\n        }\\n        vector<vector<string>> res;\\n        for(auto x:adj)\\n        {\\n            string xx= x.first;\\n            if(findutil(xx) && !vis[xx]) // chacking if its a name of account holder and not yet visited \\n            {\\n                string name= xx;\\n                set<string> emails; // to store all emails in current connected component\\n                dfs(xx, emails);\\n                int n= name.length();\\n                n--;\\n                while(name[n]>=\\'0\\' && name[n]<=\\'9\\') // we have added backchar in names to differntiate but in the final answer we have to pop back the integers\\n                {\\n                    name.pop_back();\\n                    n--;\\n                }\\n                vector<string> tmp;\\n                tmp.push_back(name);\\n                for(auto y:emails)\\n                    tmp.push_back(y); \\n                res.push_back(tmp);\\n            }\\n                \\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n**if you found this useful , please upvote thisss, it takes a lot of time and effort to make such long posts, and also it is  a hard problem :-))**",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph",
                    "Ordered Set"
                ],
                "code": "```\\nunordered_map<string, vector<string>> adj;\\nunordered_map<string, bool> vis;\\nclass Solution {\\npublic:\\n    bool findutil(string s) // this function will return true if its not a email , and a name\\n    {\\n        for(auto x:s)\\n            if(x==\\'@\\')\\n                return false;\\n        return true;\\n    }\\n    void dfs(string x, set<string>& emails)\\n    {\\n\\t\\t// simple dfs\\n        vis[x]=true;\\n        if(!findutil(x)) // inserting if its an email\\n            emails.insert(x);\\n        for(auto y:adj[x])\\n            if(!vis[y])\\n                dfs(y, emails);\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int backchar=1;\\n        adj.clear(); vis.clear();\\n        for(auto x:accounts)\\n        {\\n            string name= x[0];\\n            if(adj.find(name)!=adj.end())\\n            {\\n                name+=to_string(backchar); // to differntiate two persons with the same name\\n                backchar++;\\n                \\n            }\\n            for(int i=1; i<x.size(); i++)\\n            {\\n                adj[name].push_back(x[i]); // connecting the emails to the perosn \\n                adj[x[i]].push_back(name); // it is an undirected graph \\n            }\\n        }\\n        vector<vector<string>> res;\\n        for(auto x:adj)\\n        {\\n            string xx= x.first;\\n            if(findutil(xx) && !vis[xx]) // chacking if its a name of account holder and not yet visited \\n            {\\n                string name= xx;\\n                set<string> emails; // to store all emails in current connected component\\n                dfs(xx, emails);\\n                int n= name.length();\\n                n--;\\n                while(name[n]>=\\'0\\' && name[n]<=\\'9\\') // we have added backchar in names to differntiate but in the final answer we have to pop back the integers\\n                {\\n                    name.pop_back();\\n                    n--;\\n                }\\n                vector<string> tmp;\\n                tmp.push_back(name);\\n                for(auto y:emails)\\n                    tmp.push_back(y); \\n                res.push_back(tmp);\\n            }\\n                \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213322,
                "title": "c-dsu-clean-code",
                "content": "```\\nmap<string,string> father;\\nmap<string,string> owner;\\nmap<string,set<string>> mp;//root->string->>set of strings it contains\\nvector<vector<string>> res;\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& v) {\\n       father.clear();\\n        owner.clear();\\n        mp.clear();\\n        for(int i=0;i<res.size();i++){\\n            res.clear();\\n        }\\n        int n=v.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<v[i].size();j++){\\n                father[v[i][j]]=v[i][j];\\n                owner[v[i][j]]=v[i][0];//name of the person\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=2;j<v[i].size();j++){\\n                if(find(v[i][j-1])!=find(v[i][j])){\\n                    join(v[i][j-1],v[i][j]);\\n                }\\n            }\\n        }\\n        //now cluster have been formed\\n        //for every acc find out the root,and then insert the string into the map container of that acc\\'s particular root\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<v[i].size();j++){\\n                string root=find(v[i][j]);\\n                mp[root].insert(v[i][j]);\\n            }\\n        }\\n        for(auto it:mp){\\n            string godfather=owner[it.first];\\n            vector<string> tmp;\\n            tmp.push_back(godfather);\\n            for(auto s:it.second){\\n                tmp.push_back(s);\\n            }\\n            res.push_back(tmp);\\n        }\\n        return res;\\n    }\\n    string find(string v) {\\n         return (v == father[v]) ? v : father[v] = find(father[v]);\\n    }\\n    void join(string u,string v) {\\n        u = find(u);\\n        v = find(v);\\n        if(u==v) return;\\n        if(u<v){\\n            father[v]=u;\\n        }\\n        else{\\n            father[u]=v;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nmap<string,string> father;\\nmap<string,string> owner;\\nmap<string,set<string>> mp;//root->string->>set of strings it contains\\nvector<vector<string>> res;\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& v) {\\n       father.clear();\\n        owner.clear();\\n        mp.clear();\\n        for(int i=0;i<res.size();i++){\\n            res.clear();\\n        }\\n        int n=v.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<v[i].size();j++){\\n                father[v[i][j]]=v[i][j];\\n                owner[v[i][j]]=v[i][0];//name of the person\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=2;j<v[i].size();j++){\\n                if(find(v[i][j-1])!=find(v[i][j])){\\n                    join(v[i][j-1],v[i][j]);\\n                }\\n            }\\n        }\\n        //now cluster have been formed\\n        //for every acc find out the root,and then insert the string into the map container of that acc\\'s particular root\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<v[i].size();j++){\\n                string root=find(v[i][j]);\\n                mp[root].insert(v[i][j]);\\n            }\\n        }\\n        for(auto it:mp){\\n            string godfather=owner[it.first];\\n            vector<string> tmp;\\n            tmp.push_back(godfather);\\n            for(auto s:it.second){\\n                tmp.push_back(s);\\n            }\\n            res.push_back(tmp);\\n        }\\n        return res;\\n    }\\n    string find(string v) {\\n         return (v == father[v]) ? v : father[v] = find(father[v]);\\n    }\\n    void join(string u,string v) {\\n        u = find(u);\\n        v = find(v);\\n        if(u==v) return;\\n        if(u<v){\\n            father[v]=u;\\n        }\\n        else{\\n            father[u]=v;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127546,
                "title": "c-union-find-with-path-compression-and-quick-union-beats-95",
                "content": "```\\npublic class Solution {\\n    public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts) {\\n        \\n        DisjointSet accountGroups = new (accounts.Count);        \\n        Dictionary<string, int> emailToAccountId = new();\\n        \\n        for (int accountId = 0; accountId < accounts.Count; accountId++)\\n        {            \\n            IList<string> account = accounts[accountId];\\n            string accountName = account[0];\\n            \\n            for (int j = 1; j < account.Count; j++)\\n            {\\n                string email = account[j];\\n                \\n                // If this is the first time we see this email, assign accountId to the email\\n                if (emailToAccountId.TryGetValue(email, out int emailAccountId) is false)\\n                    emailToAccountId.Add(email, accountId);\\n                else\\n                    // If we have seen this email before then union this account with the previous account of the email\\n                    accountGroups.Union(accountId, emailAccountId);\\n            }\\n        }\\n        \\n        Dictionary<int, List<string>> accountGroupToEmails = new();\\n        \\n        foreach((string email, int accountId) in emailToAccountId)\\n        {\\n            int accountGroupId = accountGroups.Find(accountId);\\n            \\n            if (accountGroupToEmails.TryGetValue(accountGroupId, out List<string> emails) is false)\\n            {\\n                emails = new();\\n                accountGroupToEmails.Add(accountGroupId, emails);\\n            }\\n            \\n            emails.Add(email);\\n        }\\n        \\n        List<IList<string>> mergedAccounts = new();\\n        \\n        foreach ((int accountGroupId, List<string> emails) in accountGroupToEmails)\\n        {\\n            List<string> account = new() { accounts[accountGroupId][0] };\\n            emails.Sort(StringComparer.Ordinal);\\n            account.AddRange(emails);\\n            mergedAccounts.Add(account);\\n        }\\n        \\n        return mergedAccounts;\\n    }\\n    \\n    class DisjointSet\\n    {\\n        private readonly int[] parents;\\n        private readonly int[] ranks;\\n        \\n        public DisjointSet(int size)\\n        {\\n            parents = new int[size];\\n            ranks = new int[size];\\n            \\n            for (int i = 0; i < size; i++)\\n            {\\n                parents[i] = i;\\n                ranks[i] = 1;\\n            }\\n        }\\n        \\n        public int Find(int node) => node == parents[node] ? node : (parents[node] = Find(parents[node]));\\n        \\n        public void Union(int left, int right)\\n        {\\n            int rootLeft = Find(left);\\n            int rootRight = Find(right);\\n            \\n            if (rootLeft == rootRight) return;\\n            \\n            if (ranks[rootLeft] >= ranks[rootRight])\\n            {\\n                parents[rootRight] = rootLeft;\\n                \\n                if (ranks[rootLeft] == ranks[rootRight]) ranks[rootLeft]++;\\n            }\\n            else parents[rootLeft] = rootRight;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts) {\\n        \\n        DisjointSet accountGroups = new (accounts.Count);        \\n        Dictionary<string, int> emailToAccountId = new();\\n        \\n        for (int accountId = 0; accountId < accounts.Count; accountId++)\\n        {            \\n            IList<string> account = accounts[accountId];\\n            string accountName = account[0];\\n            \\n            for (int j = 1; j < account.Count; j++)\\n            {\\n                string email = account[j];\\n                \\n                // If this is the first time we see this email, assign accountId to the email\\n                if (emailToAccountId.TryGetValue(email, out int emailAccountId) is false)\\n                    emailToAccountId.Add(email, accountId);\\n                else\\n                    // If we have seen this email before then union this account with the previous account of the email\\n                    accountGroups.Union(accountId, emailAccountId);\\n            }\\n        }\\n        \\n        Dictionary<int, List<string>> accountGroupToEmails = new();\\n        \\n        foreach((string email, int accountId) in emailToAccountId)\\n        {\\n            int accountGroupId = accountGroups.Find(accountId);\\n            \\n            if (accountGroupToEmails.TryGetValue(accountGroupId, out List<string> emails) is false)\\n            {\\n                emails = new();\\n                accountGroupToEmails.Add(accountGroupId, emails);\\n            }\\n            \\n            emails.Add(email);\\n        }\\n        \\n        List<IList<string>> mergedAccounts = new();\\n        \\n        foreach ((int accountGroupId, List<string> emails) in accountGroupToEmails)\\n        {\\n            List<string> account = new() { accounts[accountGroupId][0] };\\n            emails.Sort(StringComparer.Ordinal);\\n            account.AddRange(emails);\\n            mergedAccounts.Add(account);\\n        }\\n        \\n        return mergedAccounts;\\n    }\\n    \\n    class DisjointSet\\n    {\\n        private readonly int[] parents;\\n        private readonly int[] ranks;\\n        \\n        public DisjointSet(int size)\\n        {\\n            parents = new int[size];\\n            ranks = new int[size];\\n            \\n            for (int i = 0; i < size; i++)\\n            {\\n                parents[i] = i;\\n                ranks[i] = 1;\\n            }\\n        }\\n        \\n        public int Find(int node) => node == parents[node] ? node : (parents[node] = Find(parents[node]));\\n        \\n        public void Union(int left, int right)\\n        {\\n            int rootLeft = Find(left);\\n            int rootRight = Find(right);\\n            \\n            if (rootLeft == rootRight) return;\\n            \\n            if (ranks[rootLeft] >= ranks[rootRight])\\n            {\\n                parents[rootRight] = rootLeft;\\n                \\n                if (ranks[rootLeft] == ranks[rootRight]) ranks[rootLeft]++;\\n            }\\n            else parents[rootLeft] = rootRight;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855935,
                "title": "c-easy-to-understand-union-find-solution",
                "content": "```\\nclass makeDSU{\\nprivate:\\n\\tvector <int> parent;\\n\\tvector <int> rank;\\n\\npublic:\\n\\n\\tmakeDSU(int n){\\n        parent.resize(n + 1);\\n        rank.resize(n + 1);\\n\\t\\tfor(int i = 0; i<= n ; i++){\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\trank[i] = 0;\\n\\t\\t}\\n\\t}\\n\\n\\tint findPar(int node){\\n\\t\\tif(node == parent[node]) return node;\\n\\n\\t\\treturn parent[node] = findPar(parent[node]);\\n\\t}\\n\\n\\tvoid unionDSU(int u, int v){\\n\\t\\tu = findPar(u);\\n\\t\\tv = findPar(v);\\n\\n\\t\\tif(rank[u] < rank[v]){\\n\\t\\t\\tparent[u] = v;\\n\\t\\t}\\n\\t\\telse if(rank[v] < rank[u]){\\n\\t\\t\\tparent[v] = u;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[v] = u;\\n\\t\\t\\trank[u]++;\\n\\t\\t}\\n\\t}\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int noOfAccounts = accounts.size();\\n\\n        makeDSU d(noOfAccounts);\\n\\n        map<string, int> emailToIdx;\\n\\n        for(int i = 0; i < noOfAccounts; i++){\\n        \\tauto account = accounts[i];\\n\\n        \\tfor(int j = 1; j < account.size(); j++){\\n        \\t\\tif(emailToIdx.find(account[j]) == emailToIdx.end()){\\n        \\t\\t\\temailToIdx[account[j]] = i;\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\td.unionDSU(i, emailToIdx[account[j]]);\\n        \\t\\t}\\n        \\t}\\n        }\\n\\n        map<int, set<string>> ansHash;\\n\\n        for(auto [email , index] : emailToIdx){\\n        \\tansHash[d.findPar(index)].insert(email);\\n        }\\n\\n        vector <vector <string>> res;\\n\\n        for(auto[index, emails] : ansHash){\\n        \\tvector <string> ans;\\n        \\tans.push_back(accounts[index][0]);\\n        \\tfor(auto email : emails){\\n        \\t\\tans.push_back(email);\\n        \\t}\\n        \\tres.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass makeDSU{\\nprivate:\\n\\tvector <int> parent;\\n\\tvector <int> rank;\\n\\npublic:\\n\\n\\tmakeDSU(int n){\\n        parent.resize(n + 1);\\n        rank.resize(n + 1);\\n\\t\\tfor(int i = 0; i<= n ; i++){\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\trank[i] = 0;\\n\\t\\t}\\n\\t}\\n\\n\\tint findPar(int node){\\n\\t\\tif(node == parent[node]) return node;\\n\\n\\t\\treturn parent[node] = findPar(parent[node]);\\n\\t}\\n\\n\\tvoid unionDSU(int u, int v){\\n\\t\\tu = findPar(u);\\n\\t\\tv = findPar(v);\\n\\n\\t\\tif(rank[u] < rank[v]){\\n\\t\\t\\tparent[u] = v;\\n\\t\\t}\\n\\t\\telse if(rank[v] < rank[u]){\\n\\t\\t\\tparent[v] = u;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tparent[v] = u;\\n\\t\\t\\trank[u]++;\\n\\t\\t}\\n\\t}\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int noOfAccounts = accounts.size();\\n\\n        makeDSU d(noOfAccounts);\\n\\n        map<string, int> emailToIdx;\\n\\n        for(int i = 0; i < noOfAccounts; i++){\\n        \\tauto account = accounts[i];\\n\\n        \\tfor(int j = 1; j < account.size(); j++){\\n        \\t\\tif(emailToIdx.find(account[j]) == emailToIdx.end()){\\n        \\t\\t\\temailToIdx[account[j]] = i;\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\td.unionDSU(i, emailToIdx[account[j]]);\\n        \\t\\t}\\n        \\t}\\n        }\\n\\n        map<int, set<string>> ansHash;\\n\\n        for(auto [email , index] : emailToIdx){\\n        \\tansHash[d.findPar(index)].insert(email);\\n        }\\n\\n        vector <vector <string>> res;\\n\\n        for(auto[index, emails] : ansHash){\\n        \\tvector <string> ans;\\n        \\tans.push_back(accounts[index][0]);\\n        \\tfor(auto email : emails){\\n        \\t\\tans.push_back(email);\\n        \\t}\\n        \\tres.push_back(ans);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843778,
                "title": "python-solution",
                "content": "\\n\\n\\nclass Solution:\\n    \\n\\tdef default_node():\\n        return {\\n            \"neighbors\": set(),\\n            \"name\": \"\"\\n        }\\n    \\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \\n        graph = collections.defaultdict(Solution.default_node)\\n        for account in accounts:\\n            name, emails = account[0], account[1:]\\n            for email in emails:\\n                graph[email][\"neighbors\"] = graph[email][\"neighbors\"].union(set(emails))\\n                graph[email][\"name\"] = name\\n        visited = set()\\n        ans = []\\n        \\n        \\n        def dfs(email, userEmails):\\n            if email in visited:\\n                return\\n            visited.add(email)\\n            userEmails.append(email)\\n            for neighbor in graph[email][\"neighbors\"]:\\n                dfs(neighbor, userEmails)\\n                \\n                \\n        for email in graph.keys():\\n            if email not in visited:\\n                userEmails = []\\n                dfs(email, userEmails)\\n                userEmails.sort()\\n                account = [graph[email][\"name\"]] + userEmails\\n                ans.append(account)\\n                \\n        return ans",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution:\\n    \\n\\tdef default_node():\\n        return {\\n            \"neighbors\": set(),\\n            \"name\": \"\"\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1771661,
                "title": "python-dfs",
                "content": "```\\n\"\"\"\\nDFS solution:\\nBuild a hash map from emails to the name of the person with the email\\nBuild a graph, where the nodes are the emails and the neighbors of a an email are the emails with the same account.\\nDo a DFS on the graph to find the connected components of the graph.\\nFor each connected component, query any element in the component for the name.\\n    add [name]+sorted(component) to an output array\\n\"\"\"\\n\\nclass Solution:\\n    def build_names(self, accounts): #returns a hasp map from emails to the name of the account holder\\n        \\n        output = dict()\\n        \\n        for arr in accounts:\\n            name = arr[0]\\n            for i in range(1,len(arr)):\\n                email = arr[i]\\n                output[email] = name\\n        \\n        return output\\n    \\n    def build_graph(self, accounts): #reutrns the hash map from emails to neighboring emails\\n        \\n        output = collections.defaultdict(set)\\n        \\n        for account in accounts:\\n            emails = set(account[1:])\\n            for email in emails:\\n                output[email].update(emails)\\n        \\n        return output\\n        \\n        \\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \\n        name = self.build_names(accounts)\\n        neighbors = self.build_graph(accounts)\\n        \\n        output = []\\n        \\n        visited = set()\\n        cur_component = set()\\n        \\n        def dfs(email): # visits the email, and then all of its neighbors that are not previously visited. Add them to the cur_component.\\n            cur_component.add(email)\\n            visited.add(email)\\n            \\n            for neighbor in neighbors[email]:\\n                if neighbor not in visited:\\n                    dfs(neighbor)\\n        \\n        #loop over emails. For each unvisited email, find the current component and process it to output. Then clear the current component.\\n        for email in neighbors:\\n            if email not in visited:\\n                dfs(email)\\n                output.append([name[email]]+sorted(cur_component))\\n                cur_component.clear()\\n        \\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nDFS solution:\\nBuild a hash map from emails to the name of the person with the email\\nBuild a graph, where the nodes are the emails and the neighbors of a an email are the emails with the same account.\\nDo a DFS on the graph to find the connected components of the graph.\\nFor each connected component, query any element in the component for the name.\\n    add [name]+sorted(component) to an output array\\n\"\"\"\\n\\nclass Solution:\\n    def build_names(self, accounts): #returns a hasp map from emails to the name of the account holder\\n        \\n        output = dict()\\n        \\n        for arr in accounts:\\n            name = arr[0]\\n            for i in range(1,len(arr)):\\n                email = arr[i]\\n                output[email] = name\\n        \\n        return output\\n    \\n    def build_graph(self, accounts): #reutrns the hash map from emails to neighboring emails\\n        \\n        output = collections.defaultdict(set)\\n        \\n        for account in accounts:\\n            emails = set(account[1:])\\n            for email in emails:\\n                output[email].update(emails)\\n        \\n        return output\\n        \\n        \\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \\n        name = self.build_names(accounts)\\n        neighbors = self.build_graph(accounts)\\n        \\n        output = []\\n        \\n        visited = set()\\n        cur_component = set()\\n        \\n        def dfs(email): # visits the email, and then all of its neighbors that are not previously visited. Add them to the cur_component.\\n            cur_component.add(email)\\n            visited.add(email)\\n            \\n            for neighbor in neighbors[email]:\\n                if neighbor not in visited:\\n                    dfs(neighbor)\\n        \\n        #loop over emails. For each unvisited email, find the current component and process it to output. Then clear the current component.\\n        for email in neighbors:\\n            if email not in visited:\\n                dfs(email)\\n                output.append([name[email]]+sorted(cur_component))\\n                cur_component.clear()\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692864,
                "title": "python3-unionfind",
                "content": "\\n```\\nfrom collections import defaultdict\\n\\n# UnionFind class\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        # Use a rank array to record the height of each vertex, i.e., the \"rank\" of each vertex.\\n        # The initial \"rank\" of each vertex is 1, because each of them is\\n        # a standalone vertex with no connection to other vertices.\\n        self.rank = [1] * size\\n\\n    # The find function here is the same as that in the disjoint set with path compression.\\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    # The union function with union by rank\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[rootX] > self.rank[rootY]:\\n                self.root[rootY] = rootX\\n            elif self.rank[rootX] < self.rank[rootY]:\\n                self.root[rootX] = rootY\\n            else:\\n                self.root[rootY] = rootX\\n                self.rank[rootX] += 1\\n\\n    def connected(self, x, y):\\n        return self.find(x) == self.find(y)\\n        \\n    \\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        account_list_size = len(accounts)\\n        uf = UnionFind(account_list_size)\\n        \\n        email_group = {}\\n        for i in range(account_list_size):\\n            account_size = len(accounts[i])\\n            \\n            for j in range(1, account_size):\\n                email = accounts[i][j]\\n                \\n                # if we have not seen this email, create a new group for it\\n                if email not in email_group:\\n                    email_group[email] = i\\n                else:\\n                    # we have seen this email, union this group with the previous email\\n                    uf.union(i, email_group[email])\\n            \\n        emailarray_dict = defaultdict(list)\\n        for email, group in email_group.items():\\n            emailarray_dict[uf.find(group)].append(email)\\n        \\n        return [[accounts[group][0]] + sorted(emails) for group, emails in emailarray_dict.items()]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8c3b9f05-014e-4815-ad16-93692eca3794_1642304208.5109653.png)\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\n# UnionFind class\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        # Use a rank array to record the height of each vertex, i.e., the \"rank\" of each vertex.\\n        # The initial \"rank\" of each vertex is 1, because each of them is\\n        # a standalone vertex with no connection to other vertices.\\n        self.rank = [1] * size\\n\\n    # The find function here is the same as that in the disjoint set with path compression.\\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    # The union function with union by rank\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[rootX] > self.rank[rootY]:\\n                self.root[rootY] = rootX\\n            elif self.rank[rootX] < self.rank[rootY]:\\n                self.root[rootX] = rootY\\n            else:\\n                self.root[rootY] = rootX\\n                self.rank[rootX] += 1\\n\\n    def connected(self, x, y):\\n        return self.find(x) == self.find(y)\\n        \\n    \\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        account_list_size = len(accounts)\\n        uf = UnionFind(account_list_size)\\n        \\n        email_group = {}\\n        for i in range(account_list_size):\\n            account_size = len(accounts[i])\\n            \\n            for j in range(1, account_size):\\n                email = accounts[i][j]\\n                \\n                # if we have not seen this email, create a new group for it\\n                if email not in email_group:\\n                    email_group[email] = i\\n                else:\\n                    # we have seen this email, union this group with the previous email\\n                    uf.union(i, email_group[email])\\n            \\n        emailarray_dict = defaultdict(list)\\n        for email, group in email_group.items():\\n            emailarray_dict[uf.find(group)].append(email)\\n        \\n        return [[accounts[group][0]] + sorted(emails) for group, emails in emailarray_dict.items()]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660595,
                "title": "python-union-find",
                "content": "```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \\n        class UnionFind:\\n            \\n            def __init__(self, n):\\n                self.n = n\\n                self.ids = list(range(n))\\n                \\n            def find(self, x):\\n                if x != self.ids[x]:\\n                    return self.find(self.ids[x])\\n                \\n                return x\\n            \\n            def unify(self, x, y):\\n                xi, yi = self.find(x), self.find(y)\\n                \\n                self.ids[xi] = yi\\n            \\n        uf = UnionFind(len(accounts))\\n        email2Group = {}\\n        for i,acc in enumerate(accounts):\\n            for email in acc[1:]:\\n                if email in email2Group:\\n                    uf.unify(i, email2Group[email])\\n                else:\\n                    email2Group[email] = uf.find(i)\\n                    \\n        group2Emails = defaultdict(set)\\n        for e,g in email2Group.items():\\n            group2Emails[uf.find(g)].add(e)\\n                \\n        result = []\\n        for g,emails in group2Emails.items():\\n            result.append([accounts[g][0]] + sorted(emails))\\n    \\n            \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        \\n        class UnionFind:\\n            \\n            def __init__(self, n):\\n                self.n = n\\n                self.ids = list(range(n))\\n                \\n            def find(self, x):\\n                if x != self.ids[x]:\\n                    return self.find(self.ids[x])\\n                \\n                return x\\n            \\n            def unify(self, x, y):\\n                xi, yi = self.find(x), self.find(y)\\n                \\n                self.ids[xi] = yi\\n            \\n        uf = UnionFind(len(accounts))\\n        email2Group = {}\\n        for i,acc in enumerate(accounts):\\n            for email in acc[1:]:\\n                if email in email2Group:\\n                    uf.unify(i, email2Group[email])\\n                else:\\n                    email2Group[email] = uf.find(i)\\n                    \\n        group2Emails = defaultdict(set)\\n        for e,g in email2Group.items():\\n            group2Emails[uf.find(g)].add(e)\\n                \\n        result = []\\n        for g,emails in group2Emails.items():\\n            result.append([accounts[g][0]] + sorted(emails))\\n    \\n            \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603152,
                "title": "clean-code-on-bfs-in-c-with-explanation",
                "content": "See in this question notice that suppose the elements that can be merged are\\n\\n> 1 and 2\\n> 1 and 3\\n> 3 and 4\\n> 0 and 4 ; 0 and 2\\n\\nSo all the accounts connected can be merged so bfs/dfs gives the result\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        \\n        int n = accounts.size();\\n        \\n        vector< vector< int >>adj( n );\\n        \\n        map< string , int >M;\\n        \\n        for( int i= 0 ; i<n ; i++ ){\\n            \\n            for( int j=1 ; j<accounts[i].size() ; j++ ){\\n                 \\n                 if( M.find( accounts[i][j] ) == M.end() )\\n                     M[ accounts[i][j] ] = i;\\n                \\n                 else{\\n                     \\n                     int t_b_m_w = M[ accounts[i][j] ] ;\\n                     \\n                     adj[ i ].push_back( t_b_m_w );  \\n                     adj[ t_b_m_w ].push_back( i );\\n                 }\\n            }\\n        }\\n        \\n        vector< bool >visited( n );\\n        \\n        vector< vector< string > >ans;\\n        \\n        for( int i=0 ; i<n ; i++ ){\\n            \\n            if( visited[i] ) continue;\\n            \\n            set< string >S;\\n            \\n            queue< int >Q;\\n            Q.push( i );\\n            \\n            visited[ i ] = true;\\n            \\n            while( !Q.empty() ){\\n                \\n                int curr = Q.front(); Q.pop();\\n                \\n                for( int j = 1; j< accounts[curr].size() ; j++ )\\n                    S.insert( accounts[curr][j] );\\n                \\n                for( auto x: adj[curr] ){\\n                     \\n                    if( visited[x] )continue;\\n                    \\n                    Q.push( x );\\n                    visited[x] = true;\\n                }\\n            }\\n            \\n            vector< string >X;\\n            \\n            X.push_back( accounts[i][0] );\\n            \\n            for( auto x:S )  X.push_back(x);\\n            \\n            ans.push_back( X );\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        \\n        int n = accounts.size();\\n        \\n        vector< vector< int >>adj( n );\\n        \\n        map< string , int >M;\\n        \\n        for( int i= 0 ; i<n ; i++ ){\\n            \\n            for( int j=1 ; j<accounts[i].size() ; j++ ){\\n                 \\n                 if( M.find( accounts[i][j] ) == M.end() )\\n                     M[ accounts[i][j] ] = i;\\n                \\n                 else{\\n                     \\n                     int t_b_m_w = M[ accounts[i][j] ] ;\\n                     \\n                     adj[ i ].push_back( t_b_m_w );  \\n                     adj[ t_b_m_w ].push_back( i );\\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 1602228,
                "title": "python3-dsu-sortedlist",
                "content": "1. Merge the account emails using DSU\\n2. Group the emails using the root from DSU and use SortedList from sortedcontainers to maintain order\\n3. return in the format asked in question\\n```\\nfrom sortedcontainers import SortedList\\nclass DSU:\\n    def __init__(self, n):\\n        self.arr = list(range(n))\\n    \\n    def find(self, x):\\n        if self.arr[x] != x:\\n            self.arr[x] = self.find(self.arr[x])\\n        return self.arr[x]\\n    \\n    def merge(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        self.arr[xr] = yr\\n        \\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        dsu = DSU(len(accounts))\\n        email_group = {}\\n        \\n        #merge using dsu\\n        for idx, account_list in enumerate(accounts):\\n            for i in range(1, len(account_list)):\\n                account_email = account_list[i]\\n                if account_email in email_group:\\n                    dsu.merge(idx, email_group[account_email])\\n                else:\\n                    email_group[account_email] = idx\\n        \\n        # group with root and sort  \\n        dd = defaultdict(SortedList)\\n        for email, group in email_group.items():\\n            group_root = dsu.find(group)\\n            dd[group_root].add(email)\\n        \\n        # create final answer in required format\\n        ret = []\\n        for idx, l in dd.items():\\n            ret.append([accounts[idx][0]] + list(l))\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass DSU:\\n    def __init__(self, n):\\n        self.arr = list(range(n))\\n    \\n    def find(self, x):\\n        if self.arr[x] != x:\\n            self.arr[x] = self.find(self.arr[x])\\n        return self.arr[x]\\n    \\n    def merge(self, x, y):\\n        xr, yr = self.find(x), self.find(y)\\n        self.arr[xr] = yr\\n        \\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        dsu = DSU(len(accounts))\\n        email_group = {}\\n        \\n        #merge using dsu\\n        for idx, account_list in enumerate(accounts):\\n            for i in range(1, len(account_list)):\\n                account_email = account_list[i]\\n                if account_email in email_group:\\n                    dsu.merge(idx, email_group[account_email])\\n                else:\\n                    email_group[account_email] = idx\\n        \\n        # group with root and sort  \\n        dd = defaultdict(SortedList)\\n        for email, group in email_group.items():\\n            group_root = dsu.find(group)\\n            dd[group_root].add(email)\\n        \\n        # create final answer in required format\\n        ret = []\\n        for idx, l in dd.items():\\n            ret.append([accounts[idx][0]] + list(l))\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599590,
                "title": "golang-3-solutions-dfs-emails-vs-bfs-accounts-and-disjoint-union",
                "content": "Updated: seems the Disjoint Union is better.\\n# Solution 1: DFS email\\n1. Build the graph with the map adjacent , which is  two direction.\\n2. With the help of memo visted to go through all emails.\\n\\n```\\nvar visited  map[string]bool\\nfunc accountsMerge(accounts [][]string) (result [][]string ){    \\n    adjacent := map[string][]string{} // build the graph!\\n    for _, account := range accounts{        \\n        firstEmail := account[1]\\n        for i:=2;i<len(account);i++{\\n            email := account[i]\\n            // must be two way directions. \\n            adjacent[firstEmail]=append(adjacent[firstEmail], email)    \\n            adjacent[email]=append( adjacent[email],firstEmail )\\n        }        \\n    }     \\n    // use DFS to go through the graph with help of memo visited \\n    visited = map[string]bool{}// visted email. any email just be visted once    \\n    for _, account := range accounts{\\n        firstEmail := account[1]        \\n        if visited[firstEmail]{ continue }\\n        \\n        mergedAccount:= []string{account[0]}\\n        dfs(&mergedAccount, firstEmail,adjacent )                  \\n        sort.Strings(mergedAccount[1:])\\n        result = append(result, mergedAccount)\\n    }\\n     return\\n}\\n\\nfunc dfs( mergedAccount *[]string, email string, adj map[string][]string){\\n    visited[email]=true  \\n    *mergedAccount = append( *mergedAccount, email)\\n    if neighbors, ok := adj[email];ok {\\n        for _, neig := range neighbors {\\n           if !visited[neig] { dfs(mergedAccount, neig, adj) }            \\n        }  \\n    }    \\n}\\n\\n```\\n\\n# Solution 2: BFS the account.\\n1. Build the graph with map edges. This is about the AccountID relationship, instead of email\\n2. Use BFS to iterate each Account and get the result.\\n\\n```\\n\\n// this solution is to buildthe graph of accounts.\\nfunc accountsMerge2(accounts [][]string) (result [][]string ){    \\n    m := make(map[string]int) // email: index of account.Help to build the graph edges\\n    edges := make(map[int][]int) // build the map    \\n    for i, acc := range accounts {\\n        for _, email := range acc[1:] {\\n            if idx, ok := m[email]; ok { // need two direction, or the early one may miss some connections.\\n                edges[idx],edges[i]  = append(edges[idx], i), append(edges[i], idx)\\n            } else {\\n                m[email] = i\\n            }\\n        }\\n    }\\n    \\n    visited := make(map[int]bool) // memo\\n    for i, account := range accounts {\\n        if visited[i] {continue}\\n        cur := []int{i} // use BFS \\n        acEmails := make(map[string]struct{})  // use a map to dedup the emails.\\n        for len(cur) > 0 {\\n            var next []int\\n            for _, idx := range cur{ \\n                if visited[idx] { continue}\\n                visited[idx] = true\\n                for _, email := range accounts[idx][1:] {\\n                    acEmails[email] = struct{}{}\\n                }\\n                next = append(next, edges[idx]...)                \\n            }\\n            cur=next\\n        }\\n        acResp := []string{account[0]}    \\n        for email := range acEmails {acResp = append(acResp, email)  }       \\n        sort.Strings(acResp[1:])\\n        result = append(result, acResp)\\n    }\\n    return result\\n} \\n```\\n# Solution 3: Disjoint Union\\n\\n```\\nfunc accountsMerge(accounts [][]string) (res [][]string ){\\n    n:=len(accounts)\\n    root := make([]int, n)\\n    for i:=0;i<n;i++{ root[i]=i }\\n    \\n    emailAccounts := map[string]int{}\\n    for acID, account := range accounts{        \\n        for i:=1;i<len(account);i++{\\n            email := account[i]\\n            if rootAccount, ok := emailAccounts[email];ok{ union(acID,rootAccount, root ) }            \\n            emailAccounts[email]=acID            \\n        }\\n    }\\n    \\n    // merge following root. key: accountID, values: all related emails, including duplicated. \\n    accEmails := map[int][]string{}\\n    for acID, rootID:= range root{\\n        accEmails[rootID]=append(accEmails[rootID], accounts[acID][1:]... )\\n    }\\n    \\n    // build response: \\n    for acID, emails := range accEmails{\\n        var m []string\\n        dedup := map[string]bool{}\\n        for _, email := range emails{\\n            if dedup[email] { continue }\\n            dedup[email]=true\\n            m=append(m, email)\\n        }\\n        sort.Strings(m) \\n        cur := append( []string{accounts[acID][0]}, m...)\\n        res=append(res, cur )\\n    }     \\n    return \\n}\\n\\n\\nfunc findRoot(i int, root []int)int{\\n    if i==root[i]{\\n        return i\\n    }\\n    return findRoot(root[i],root)\\n}\\n\\nfunc union( i, j int, root[] int){\\n    if rootI, rootJ := findRoot(i, root), findRoot(j, root); rootI!=rootJ{        \\n        for idx, v := range root{\\n            if v== rootI{ root[idx]=rootJ   }\\n        }        \\n    }        \\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nvar visited  map[string]bool\\nfunc accountsMerge(accounts [][]string) (result [][]string ){    \\n    adjacent := map[string][]string{} // build the graph!\\n    for _, account := range accounts{        \\n        firstEmail := account[1]\\n        for i:=2;i<len(account);i++{\\n            email := account[i]\\n            // must be two way directions. \\n            adjacent[firstEmail]=append(adjacent[firstEmail], email)    \\n            adjacent[email]=append( adjacent[email],firstEmail )\\n        }        \\n    }     \\n    // use DFS to go through the graph with help of memo visited \\n    visited = map[string]bool{}// visted email. any email just be visted once    \\n    for _, account := range accounts{\\n        firstEmail := account[1]        \\n        if visited[firstEmail]{ continue }\\n        \\n        mergedAccount:= []string{account[0]}\\n        dfs(&mergedAccount, firstEmail,adjacent )                  \\n        sort.Strings(mergedAccount[1:])\\n        result = append(result, mergedAccount)\\n    }\\n     return\\n}\\n\\nfunc dfs( mergedAccount *[]string, email string, adj map[string][]string){\\n    visited[email]=true  \\n    *mergedAccount = append( *mergedAccount, email)\\n    if neighbors, ok := adj[email];ok {\\n        for _, neig := range neighbors {\\n           if !visited[neig] { dfs(mergedAccount, neig, adj) }            \\n        }  \\n    }    \\n}\\n\\n```\n```\\n\\n// this solution is to buildthe graph of accounts.\\nfunc accountsMerge2(accounts [][]string) (result [][]string ){    \\n    m := make(map[string]int) // email: index of account.Help to build the graph edges\\n    edges := make(map[int][]int) // build the map    \\n    for i, acc := range accounts {\\n        for _, email := range acc[1:] {\\n            if idx, ok := m[email]; ok { // need two direction, or the early one may miss some connections.\\n                edges[idx],edges[i]  = append(edges[idx], i), append(edges[i], idx)\\n            } else {\\n                m[email] = i\\n            }\\n        }\\n    }\\n    \\n    visited := make(map[int]bool) // memo\\n    for i, account := range accounts {\\n        if visited[i] {continue}\\n        cur := []int{i} // use BFS \\n        acEmails := make(map[string]struct{})  // use a map to dedup the emails.\\n        for len(cur) > 0 {\\n            var next []int\\n            for _, idx := range cur{ \\n                if visited[idx] { continue}\\n                visited[idx] = true\\n                for _, email := range accounts[idx][1:] {\\n                    acEmails[email] = struct{}{}\\n                }\\n                next = append(next, edges[idx]...)                \\n            }\\n            cur=next\\n        }\\n        acResp := []string{account[0]}    \\n        for email := range acEmails {acResp = append(acResp, email)  }       \\n        sort.Strings(acResp[1:])\\n        result = append(result, acResp)\\n    }\\n    return result\\n} \\n```\n```\\nfunc accountsMerge(accounts [][]string) (res [][]string ){\\n    n:=len(accounts)\\n    root := make([]int, n)\\n    for i:=0;i<n;i++{ root[i]=i }\\n    \\n    emailAccounts := map[string]int{}\\n    for acID, account := range accounts{        \\n        for i:=1;i<len(account);i++{\\n            email := account[i]\\n            if rootAccount, ok := emailAccounts[email];ok{ union(acID,rootAccount, root ) }            \\n            emailAccounts[email]=acID            \\n        }\\n    }\\n    \\n    // merge following root. key: accountID, values: all related emails, including duplicated. \\n    accEmails := map[int][]string{}\\n    for acID, rootID:= range root{\\n        accEmails[rootID]=append(accEmails[rootID], accounts[acID][1:]... )\\n    }\\n    \\n    // build response: \\n    for acID, emails := range accEmails{\\n        var m []string\\n        dedup := map[string]bool{}\\n        for _, email := range emails{\\n            if dedup[email] { continue }\\n            dedup[email]=true\\n            m=append(m, email)\\n        }\\n        sort.Strings(m) \\n        cur := append( []string{accounts[acID][0]}, m...)\\n        res=append(res, cur )\\n    }     \\n    return \\n}\\n\\n\\nfunc findRoot(i int, root []int)int{\\n    if i==root[i]{\\n        return i\\n    }\\n    return findRoot(root[i],root)\\n}\\n\\nfunc union( i, j int, root[] int){\\n    if rootI, rootJ := findRoot(i, root), findRoot(j, root); rootI!=rootJ{        \\n        for idx, v := range root{\\n            if v== rootI{ root[idx]=rootJ   }\\n        }        \\n    }        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1483698,
                "title": "java-union-find-explanation-with-template-that-helps-solving-many-graph-problems",
                "content": "```\\n//Template starts\\n\\nclass UnionFind{\\n    private int[] parent, rank;\\n    \\n    public UnionFind(int n){\\n        parent= new int[n];\\n        rank= new int[n];\\n         // array is initialized with the total size of accounts and each is given a unique id. When the index of an array is equal to the value inside it, it means it is its own parent.\\n// if it is different, it means that it has some other parent.  Basically we are mapping each account to its index. And at the start, every account is its own parent.\\n        for(int i=0; i<n; i++)\\n            parent[i]= i;\\n    \\n    }\\n    // This method find\\'s the parent of a particular index. \\n    public int findParent(int node){\\n        if(parent[node] == node)\\n            return node;\\n        \\n\\t\\tparent[node]= findParent(parent[node]);\\n        return parent[node];\\n    }\\n                      \\n // If they weren\\'t already connected, then connect them. For connecting them, we would reassign the index of the account of where we found our email to the current account we are processing.\\n    public void union(int p, int q){\\n        int rootP= findParent(p);\\n        int rootQ= findParent(q);\\n        \\n        if(rootP == rootQ) return;\\n        \\n\\t\\t//deciding the parent on basis of their rank\\n        if(rank[rootP] < rank[rootQ]) parent[rootP]= rootQ;\\n        else if(rank[rootP] > rank[rootQ]) parent[rootQ]= rootP;\\n        else{//the rank of both roots are same so we can make either of them as parent\\n            parent[rootP]= rootQ;\\n            rank[rootQ]++;\\n        }\\n    }\\n}\\n//Template ends..\\n\\n\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        int n= accounts.size();\\n        UnionFind uf= new UnionFind(n);\\n        // This hashmap contains the email to index mapping. We will use this map to find the particular account when an email has already been found.\\n        Map<String, Integer> emailMap= new HashMap<>();\\n        // Traverse each List<String> from the first index i.e. skip first index which is the name and just traverse on the emails\\n        for(int i=0; i<n;i++){\\n            for(int j=1; j< accounts.get(i).size(); j++){\\n                String email= accounts.get(i).get(j);\\n                // The email in this account has already been registered before.\\n                if(emailMap.containsKey(email)){\\n                    // Find that account\\'s index\\n                    int person= emailMap.get(email);\\n                    // Find the parent of that current account\\n                    int p1= uf.findParent(i);\\n                    // Find the parent of the account where our email in the map had been found\\n                    int p2= uf.findParent(person);\\n                    // If they weren\\'t already connected, then connect them. For connecting them, we would reassign the index of the account of where we found our email to the current account we are processing.\\n                    uf.union(p1,p2);\\n                }\\n                \\n                else emailMap.put(email, i);// Otherwise just track it\\n            }\\n        }\\n        \\n        \\n        /* Now that we have our parents array ready where each index is either it\\'s own parent of has some other account\\'s index, \\nwe need to merge all accounts who\\'s parents are the same into one account. \\nThe users map will contain index to TreeSet of email mapping. \\nNote that treeset sorts the elements inside it in natural order, therefore no need to worry about sorting when using this data structure. \\nFor adding an element, it takes O(logn) operation. For n emails, it would take O(nlogn) and O(n) space.\\n*/\\n        Map<Integer, TreeSet<String>> users= new HashMap<>();\\n        for(int i=0; i< accounts.size(); i++){\\n            // find the parent. If an element in the parent\\'s array doesn\\'t equal it\\'s index, It\\'s parent is different. Retrieve that id.\\n            int parent= uf.findParent(i);\\n            // get all email\\'s particular to the index right now. Note that this is not collecting the parent\\'s email at al..\\n            List<String> userEmails= accounts.get(i);\\n            // create the treeset if not already there for that parent\\n            users.putIfAbsent(parent, new TreeSet<String> ());\\n            // get the treeset from the parent, and add all the email excluding the emails in them.\\n            users.get(parent).addAll(userEmails.subList(1, userEmails.size()));\\n            \\n        }\\n        // We not have a map with index and a treemap containing all the emails. Now we are Building final result. \\n        List<List<String>> res= new ArrayList<>();\\n        for(Integer userID: users.keySet()){\\n            // idx is the account id, get that particular account\\'s name. We need to append it to our arraylist before returning it.\\n            String userName= accounts.get(userID).get(0);\\n            \\n            ArrayList<String> list= new ArrayList<>(users.get(userID));\\n            list.add(0, userName);\\n            res.add(list);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nTopic wise Graph problems :)\\nhttps://leetcode.com/discuss/general-discussion/655708/Graph-For-Beginners-Problems-or-Pattern-or-Sample-Solutions",
                "solutionTags": [
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\n//Template starts\\n\\nclass UnionFind{\\n    private int[] parent, rank;\\n    \\n    public UnionFind(int n){\\n        parent= new int[n];\\n        rank= new int[n];\\n         // array is initialized with the total size of accounts and each is given a unique id. When the index of an array is equal to the value inside it, it means it is its own parent.\\n// if it is different, it means that it has some other parent.  Basically we are mapping each account to its index. And at the start, every account is its own parent.\\n        for(int i=0; i<n; i++)\\n            parent[i]= i;\\n    \\n    }\\n    // This method find\\'s the parent of a particular index. \\n    public int findParent(int node){\\n        if(parent[node] == node)\\n            return node;\\n        \\n\\t\\tparent[node]= findParent(parent[node]);\\n        return parent[node];\\n    }\\n                      \\n // If they weren\\'t already connected, then connect them. For connecting them, we would reassign the index of the account of where we found our email to the current account we are processing.\\n    public void union(int p, int q){\\n        int rootP= findParent(p);\\n        int rootQ= findParent(q);\\n        \\n        if(rootP == rootQ) return;\\n        \\n\\t\\t//deciding the parent on basis of their rank\\n        if(rank[rootP] < rank[rootQ]) parent[rootP]= rootQ;\\n        else if(rank[rootP] > rank[rootQ]) parent[rootQ]= rootP;\\n        else{//the rank of both roots are same so we can make either of them as parent\\n            parent[rootP]= rootQ;\\n            rank[rootQ]++;\\n        }\\n    }\\n}\\n//Template ends..\\n\\n\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        int n= accounts.size();\\n        UnionFind uf= new UnionFind(n);\\n        // This hashmap contains the email to index mapping. We will use this map to find the particular account when an email has already been found.\\n        Map<String, Integer> emailMap= new HashMap<>();\\n        // Traverse each List<String> from the first index i.e. skip first index which is the name and just traverse on the emails\\n        for(int i=0; i<n;i++){\\n            for(int j=1; j< accounts.get(i).size(); j++){\\n                String email= accounts.get(i).get(j);\\n                // The email in this account has already been registered before.\\n                if(emailMap.containsKey(email)){\\n                    // Find that account\\'s index\\n                    int person= emailMap.get(email);\\n                    // Find the parent of that current account\\n                    int p1= uf.findParent(i);\\n                    // Find the parent of the account where our email in the map had been found\\n                    int p2= uf.findParent(person);\\n                    // If they weren\\'t already connected, then connect them. For connecting them, we would reassign the index of the account of where we found our email to the current account we are processing.\\n                    uf.union(p1,p2);\\n                }\\n                \\n                else emailMap.put(email, i);// Otherwise just track it\\n            }\\n        }\\n        \\n        \\n        /* Now that we have our parents array ready where each index is either it\\'s own parent of has some other account\\'s index, \\nwe need to merge all accounts who\\'s parents are the same into one account. \\nThe users map will contain index to TreeSet of email mapping. \\nNote that treeset sorts the elements inside it in natural order, therefore no need to worry about sorting when using this data structure. \\nFor adding an element, it takes O(logn) operation. For n emails, it would take O(nlogn) and O(n) space.\\n*/\\n        Map<Integer, TreeSet<String>> users= new HashMap<>();\\n        for(int i=0; i< accounts.size(); i++){\\n            // find the parent. If an element in the parent\\'s array doesn\\'t equal it\\'s index, It\\'s parent is different. Retrieve that id.\\n            int parent= uf.findParent(i);\\n            // get all email\\'s particular to the index right now. Note that this is not collecting the parent\\'s email at al..\\n            List<String> userEmails= accounts.get(i);\\n            // create the treeset if not already there for that parent\\n            users.putIfAbsent(parent, new TreeSet<String> ());\\n            // get the treeset from the parent, and add all the email excluding the emails in them.\\n            users.get(parent).addAll(userEmails.subList(1, userEmails.size()));\\n            \\n        }\\n        // We not have a map with index and a treemap containing all the emails. Now we are Building final result. \\n        List<List<String>> res= new ArrayList<>();\\n        for(Integer userID: users.keySet()){\\n            // idx is the account id, get that particular account\\'s name. We need to append it to our arraylist before returning it.\\n            String userName= accounts.get(userID).get(0);\\n            \\n            ArrayList<String> list= new ArrayList<>(users.get(userID));\\n            list.add(0, userName);\\n            res.add(list);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480627,
                "title": "explanation-step-by-step-c-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    string find(string s, map<string, string>& p) {\\n        return p[s] == s ? s : find(p[s], p);\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& acnt) {\\n        map<string,string> parent;\\n        map<string,string> owner;\\n        map<string,set<string>> unions;\\n        int n = acnt.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<acnt[i].size();j++)\\n            {\\n                parent[acnt[i][j]] = acnt[i][j]; //intilizing parent to itself\\n                owner[acnt[i][j]] = acnt[i][0]; //owwer of every email id in that acnt will be it\\'s first element\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            string p = find(acnt[i][1],parent); // taking first email-id as parent and others as childeren\\n            for(int j=2;j<acnt[i].size();j++)\\n            {\\n                parent[find(acnt[i][j],parent)] = p;\\n        //a->b->c\\n        //d->e->f\\n        //g->a->d\\n    //so here b and c report to a\\n    //e and f report to d\\n    //and a and d report to g\\n    //overall everyone report to g that\\'s why parent[find(acnt[i][j],parent)] and not parent[acnt[i][j]] = p\\n            }\\n            \\n        }\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=1;j<acnt[i].size();j++)\\n           {\\n               unions[find(acnt[i][j],parent)].insert(acnt[i][j]);\\n               // inserting every email-id to there respective parent\\n               /*\\n               johnsmith@mail.com->john_newyork@mai.com->john00@mail.com\\n               <--head-----------><----inside set----------------------->\\n               \\n               */\\n           }\\n       }\\n    \\n        vector<vector<string>> res;\\n        for(pair<string,set<string>> p : unions)\\n        {\\n            vector<string> emails(p.second.begin(),p.second.end()); //storing every email id from set to vector\\n            emails.insert(emails.begin(),owner[p.first]);\\n            //owner of p.first is name of that account holder which inserted in the begining of vector emails\\n            res.push_back(emails);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string find(string s, map<string, string>& p) {\\n        return p[s] == s ? s : find(p[s], p);\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& acnt) {\\n        map<string,string> parent;\\n        map<string,string> owner;\\n        map<string,set<string>> unions;\\n        int n = acnt.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=1;j<acnt[i].size();j++)\\n            {\\n                parent[acnt[i][j]] = acnt[i][j]; //intilizing parent to itself\\n                owner[acnt[i][j]] = acnt[i][0]; //owwer of every email id in that acnt will be it\\'s first element\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            string p = find(acnt[i][1],parent); // taking first email-id as parent and others as childeren\\n            for(int j=2;j<acnt[i].size();j++)\\n            {\\n                parent[find(acnt[i][j],parent)] = p;\\n        //a->b->c\\n        //d->e->f\\n        //g->a->d\\n    //so here b and c report to a\\n    //e and f report to d\\n    //and a and d report to g\\n    //overall everyone report to g that\\'s why parent[find(acnt[i][j],parent)] and not parent[acnt[i][j]] = p\\n            }\\n            \\n        }\\n       for(int i=0;i<n;i++)\\n       {\\n           for(int j=1;j<acnt[i].size();j++)\\n           {\\n               unions[find(acnt[i][j],parent)].insert(acnt[i][j]);\\n               // inserting every email-id to there respective parent\\n               /*\\n               johnsmith@mail.com->john_newyork@mai.com->john00@mail.com\\n               <--head-----------><----inside set----------------------->\\n               \\n               */\\n           }\\n       }\\n    \\n        vector<vector<string>> res;\\n        for(pair<string,set<string>> p : unions)\\n        {\\n            vector<string> emails(p.second.begin(),p.second.end()); //storing every email id from set to vector\\n            emails.insert(emails.begin(),owner[p.first]);\\n            //owner of p.first is name of that account holder which inserted in the begining of vector emails\\n            res.push_back(emails);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451452,
                "title": "union-find",
                "content": "```\\nclass UnionFind {\\n    vector<int> parent;\\npublic:\\n    UnionFind(int n) {\\n        parent.resize(n);\\n        for(int i=0; i<n; i++)\\n            parent[i] = i;\\n    }\\n    \\n    int find(int v) {\\n        if(v==parent[v])\\n            return v;\\n        return parent[v] = find(parent[v]);\\n    }\\n    \\n    void merge(int u, int v) {\\n        int pu = find(u), pv = find(v);\\n        if(pu!=pv)\\n            parent[pu] = pv;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        UnionFind *dsu = new UnionFind(n);\\n        unordered_map<string, int> mp;\\n        int index = 0;\\n        for(auto &user: accounts) {\\n            for(int i=1; i<(int)user.size(); i++) {\\n                if(mp.find(user[i])!=mp.end())\\n                    dsu->merge(mp[user[i]], index);\\n                mp[user[i]] = index;\\n            }\\n            index++;\\n        }\\n        vector<vector<string>> ans;\\n        unordered_map<int, int> mpi;\\n        for(int i=0; i<n; i++) {\\n            if(dsu->find(i)==i) {\\n                mpi[i] = ans.size();\\n                ans.push_back({accounts[i][0]});\\n            }\\n        }\\n        for(auto itr: mp)\\n            ans[mpi[dsu->find(itr.second)]].push_back(itr.first);\\n        for(auto &user: ans)\\n            sort(user.begin()+1, user.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind {\\n    vector<int> parent;\\npublic:\\n    UnionFind(int n) {\\n        parent.resize(n);\\n        for(int i=0; i<n; i++)\\n            parent[i] = i;\\n    }\\n    \\n    int find(int v) {\\n        if(v==parent[v])\\n            return v;\\n        return parent[v] = find(parent[v]);\\n    }\\n    \\n    void merge(int u, int v) {\\n        int pu = find(u), pv = find(v);\\n        if(pu!=pv)\\n            parent[pu] = pv;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n = accounts.size();\\n        UnionFind *dsu = new UnionFind(n);\\n        unordered_map<string, int> mp;\\n        int index = 0;\\n        for(auto &user: accounts) {\\n            for(int i=1; i<(int)user.size(); i++) {\\n                if(mp.find(user[i])!=mp.end())\\n                    dsu->merge(mp[user[i]], index);\\n                mp[user[i]] = index;\\n            }\\n            index++;\\n        }\\n        vector<vector<string>> ans;\\n        unordered_map<int, int> mpi;\\n        for(int i=0; i<n; i++) {\\n            if(dsu->find(i)==i) {\\n                mpi[i] = ans.size();\\n                ans.push_back({accounts[i][0]});\\n            }\\n        }\\n        for(auto itr: mp)\\n            ans[mpi[dsu->find(itr.second)]].push_back(itr.first);\\n        for(auto &user: ans)\\n            sort(user.begin()+1, user.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335073,
                "title": "js-using-dfs-with-approach-explained",
                "content": "Approach:\\n- Create a graph adjacency list, considering each email as a node. `em_to_em map` is used for this purpose. The list is a Set so that each email is linked to another email just once.\\n- Create an email to name Map, this is required to prepend to the result lists.\\n- Apply DFS, starting with the first email in the graph, add to the stack and visit all the connected nodes (depth), while creating a list of all the connected nodes (emails).\\n- If stack is empty, all the connected nodes to the email key are covered, then sort the connected email list and add to the result array.\\n\\n```\\nvar accountsMerge = function(accounts) {\\n    const em_to_em = new Map(),\\n          em_to_name = new Map();\\n    \\n    accounts.forEach(account => {\\n        const name = account[0];\\n        em_to_name.set(account[1], name);\\n\\n        if(!em_to_em.has(account[1])) {\\n            em_to_em.set(account[1], new Set());\\n        }\\n        em_to_em.set(account[1], em_to_em.get(account[1]).add(account[1]));\\n        \\n        \\n        for(let i = 2; i < account.length; ++i) {\\n            if(!em_to_em.has(account[i])) {\\n                em_to_em.set(account[i], new Set());    \\n            }\\n            em_to_em.set(account[i], em_to_em.get(account[i]).add(account[1]));\\n            em_to_name.set(account[i], name);\\n            em_to_em.set(account[1], em_to_em.get(account[1]).add(account[i]));\\n        }\\n    })\\n    \\n    const result = [];\\n    const stack = [];\\n    const visited = new Set();\\n    let email_list = [];\\n    \\n    em_to_em.forEach((neighbors, email) => {\\n        if(!visited.has(email)) {\\n            visited.add(email);\\n            stack.push(email);\\n            email_list = [];\\n            \\n            while(stack.length) {\\n                let em = stack.pop();\\n                email_list.push(em);\\n                em_to_em.get(em).forEach(nei => {\\n                    if(!visited.has(nei)) {\\n                        visited.add(nei);\\n                        stack.push(nei);   \\n                    }\\n                })\\n            }\\n            email_list = email_list.sort((a, b) => {\\n                a = a.split(\\'\\');\\n                b = b.split(\\'\\');\\n                let i = 0, j = 0;\\n                while(i < a.length && j < b.length) {\\n                    if(a[i].charCodeAt(0) !== b[j].charCodeAt(0)) {\\n                        return a[i].charCodeAt(0) - b[j].charCodeAt(0);\\n                    }\\n                    ++i;\\n                    ++j;\\n                }\\n                if(i < a.length) {\\n                    return 1;\\n                }\\n                if(j < b.length) {\\n                    return -1;\\n                }\\n                return 0;\\n            });\\n            const part = [em_to_name.get(email)].concat(email_list);\\n            result.push(part);\\n        }\\n    })\\n    return result;\\n}\\n```\\nTime Complexity = O(n * mlogm) \\nSpace Complexity = O(n * m)\\n[n - length of array, m - length of each account]",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar accountsMerge = function(accounts) {\\n    const em_to_em = new Map(),\\n          em_to_name = new Map();\\n    \\n    accounts.forEach(account => {\\n        const name = account[0];\\n        em_to_name.set(account[1], name);\\n\\n        if(!em_to_em.has(account[1])) {\\n            em_to_em.set(account[1], new Set());\\n        }\\n        em_to_em.set(account[1], em_to_em.get(account[1]).add(account[1]));\\n        \\n        \\n        for(let i = 2; i < account.length; ++i) {\\n            if(!em_to_em.has(account[i])) {\\n                em_to_em.set(account[i], new Set());    \\n            }\\n            em_to_em.set(account[i], em_to_em.get(account[i]).add(account[1]));\\n            em_to_name.set(account[i], name);\\n            em_to_em.set(account[1], em_to_em.get(account[1]).add(account[i]));\\n        }\\n    })\\n    \\n    const result = [];\\n    const stack = [];\\n    const visited = new Set();\\n    let email_list = [];\\n    \\n    em_to_em.forEach((neighbors, email) => {\\n        if(!visited.has(email)) {\\n            visited.add(email);\\n            stack.push(email);\\n            email_list = [];\\n            \\n            while(stack.length) {\\n                let em = stack.pop();\\n                email_list.push(em);\\n                em_to_em.get(em).forEach(nei => {\\n                    if(!visited.has(nei)) {\\n                        visited.add(nei);\\n                        stack.push(nei);   \\n                    }\\n                })\\n            }\\n            email_list = email_list.sort((a, b) => {\\n                a = a.split(\\'\\');\\n                b = b.split(\\'\\');\\n                let i = 0, j = 0;\\n                while(i < a.length && j < b.length) {\\n                    if(a[i].charCodeAt(0) !== b[j].charCodeAt(0)) {\\n                        return a[i].charCodeAt(0) - b[j].charCodeAt(0);\\n                    }\\n                    ++i;\\n                    ++j;\\n                }\\n                if(i < a.length) {\\n                    return 1;\\n                }\\n                if(j < b.length) {\\n                    return -1;\\n                }\\n                return 0;\\n            });\\n            const part = [em_to_name.get(email)].concat(email_list);\\n            result.push(part);\\n        }\\n    })\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1306197,
                "title": "short-and-sweet-java-solution-graph-dfs",
                "content": "```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        \\n        Map<String, Set<String>> graph = new HashMap<>();\\n        Map<String, String> emailName = new HashMap<>();\\n        \\n        for (List<String> emails : accounts) {\\n            String name = emails.get(0);\\n            for (int i = 1; i < emails.size(); i++) {\\n                graph.computeIfAbsent(emails.get(i), v -> new HashSet<>());\\n                emailName.put(emails.get(i), name);\\n                for (int j = i + 1; j < emails.size(); j++) {\\n                    graph.computeIfAbsent(emails.get(i), v -> new HashSet<>()).add(emails.get(j));\\n                    graph.computeIfAbsent(emails.get(j), v -> new HashSet<>()).add(emails.get(i));\\n                }\\n            }\\n        }\\n        List<List<String>> res = new LinkedList<>();\\n        \\n        Set<String> added = new HashSet<>();\\n        for (String origin : graph.keySet()) {\\n            List<String> emailGroup = new LinkedList<>();\\n            dfs(origin, graph, added, emailGroup);\\n            if (!emailGroup.isEmpty()) {\\n                Collections.sort(emailGroup);\\n                emailGroup.add(0, emailName.get(origin));\\n                res.add(emailGroup);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    void dfs(String origin, Map<String, Set<String>> graph, Set<String> added, List<String> emailGroup) {\\n        if (added.contains(origin)) {\\n            return;\\n        }\\n        added.add(origin);\\n        emailGroup.add(origin);\\n        for (String n : graph.get(origin)) {\\n            dfs(n, graph, added, emailGroup);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        \\n        Map<String, Set<String>> graph = new HashMap<>();\\n        Map<String, String> emailName = new HashMap<>();\\n        \\n        for (List<String> emails : accounts) {\\n            String name = emails.get(0);\\n            for (int i = 1; i < emails.size(); i++) {\\n                graph.computeIfAbsent(emails.get(i), v -> new HashSet<>());\\n                emailName.put(emails.get(i), name);\\n                for (int j = i + 1; j < emails.size(); j++) {\\n                    graph.computeIfAbsent(emails.get(i), v -> new HashSet<>()).add(emails.get(j));\\n                    graph.computeIfAbsent(emails.get(j), v -> new HashSet<>()).add(emails.get(i));\\n                }\\n            }\\n        }\\n        List<List<String>> res = new LinkedList<>();\\n        \\n        Set<String> added = new HashSet<>();\\n        for (String origin : graph.keySet()) {\\n            List<String> emailGroup = new LinkedList<>();\\n            dfs(origin, graph, added, emailGroup);\\n            if (!emailGroup.isEmpty()) {\\n                Collections.sort(emailGroup);\\n                emailGroup.add(0, emailName.get(origin));\\n                res.add(emailGroup);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    void dfs(String origin, Map<String, Set<String>> graph, Set<String> added, List<String> emailGroup) {\\n        if (added.contains(origin)) {\\n            return;\\n        }\\n        added.add(origin);\\n        emailGroup.add(origin);\\n        for (String n : graph.get(origin)) {\\n            dfs(n, graph, added, emailGroup);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252798,
                "title": "c-using-union-find-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void uni(int a,int b,vector<int>& par)\\n    {\\n        int para = getpar(a,par);\\n        int parb = getpar(b,par);\\n        \\n        par[para] = parb;\\n    }\\n    \\n    int getpar(int a,vector<int>& par)\\n    {\\n        if(par[a]!=a)\\n        {\\n            par[a] = getpar(par[a],par);\\n        }\\n        \\n        return par[a];\\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) \\n    {\\n        int n = accounts.size(),i,j;\\n        vector<int> par(n);\\n        for(i=0;i<n;i++)\\n        {\\n            par[i] = i;\\n        }\\n        \\n        map<string,int> emailMap;\\n        for(i=0;i<accounts.size();i++)\\n        {\\n            for(j=1;j<accounts[i].size();j++)\\n            {\\n                if(emailMap.find(accounts[i][j])!=emailMap.end())\\n                {\\n                    uni(i,emailMap[accounts[i][j]],par);\\n                }\\n                else\\n                {\\n                    emailMap[accounts[i][j]] = i;\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int,set<string>> mergedAns;\\n        unordered_map<int,string> name;\\n        for(i=0;i<n;i++)\\n        {\\n            int parent = getpar(i,par);\\n            name[parent] = (accounts[i][0]);\\n            \\n            for(j=1;j<accounts[i].size();j++)\\n            {\\n                mergedAns[parent].insert(accounts[i][j]);\\n            }\\n        }\\n        \\n        vector<vector<string>> ans;\\n        for(auto it = mergedAns.begin();it!=mergedAns.end();it++)\\n        {\\n            vector<string> temp;\\n            temp.push_back(name[it->first]);\\n            for(auto x:it->second)\\n            {\\n                temp.push_back(x);\\n            }\\n            ans.push_back(temp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void uni(int a,int b,vector<int>& par)\\n    {\\n        int para = getpar(a,par);\\n        int parb = getpar(b,par);\\n        \\n        par[para] = parb;\\n    }\\n    \\n    int getpar(int a,vector<int>& par)\\n    {\\n        if(par[a]!=a)\\n        {\\n            par[a] = getpar(par[a],par);\\n        }\\n        \\n        return par[a];\\n    }\\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) \\n    {\\n        int n = accounts.size(),i,j;\\n        vector<int> par(n);\\n        for(i=0;i<n;i++)\\n        {\\n            par[i] = i;\\n        }\\n        \\n        map<string,int> emailMap;\\n        for(i=0;i<accounts.size();i++)\\n        {\\n            for(j=1;j<accounts[i].size();j++)\\n            {\\n                if(emailMap.find(accounts[i][j])!=emailMap.end())\\n                {\\n                    uni(i,emailMap[accounts[i][j]],par);\\n                }\\n                else\\n                {\\n                    emailMap[accounts[i][j]] = i;\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int,set<string>> mergedAns;\\n        unordered_map<int,string> name;\\n        for(i=0;i<n;i++)\\n        {\\n            int parent = getpar(i,par);\\n            name[parent] = (accounts[i][0]);\\n            \\n            for(j=1;j<accounts[i].size();j++)\\n            {\\n                mergedAns[parent].insert(accounts[i][j]);\\n            }\\n        }\\n        \\n        vector<vector<string>> ans;\\n        for(auto it = mergedAns.begin();it!=mergedAns.end();it++)\\n        {\\n            vector<string> temp;\\n            temp.push_back(name[it->first]);\\n            for(auto x:it->second)\\n            {\\n                temp.push_back(x);\\n            }\\n            ans.push_back(temp);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203768,
                "title": "c-easy-to-understand-99-faster-and-space-efficient",
                "content": "```\\nclass unionfind\\n{\\n    public:\\n    vector<int> parent;\\n    vector<int> rank;\\n    int groupcount;\\n    unionfind(int gc)\\n    {\\n        groupcount = gc;\\n        parent.resize(gc,0);\\n        rank.resize(gc,0);\\n        for(int i=0;i<gc;i++)\\n            parent[i] = i;\\n    }\\n    \\n    int find(int x)\\n    {\\n        if(x==parent[x])\\n            return x;\\n        parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    void unionf(int x,int y)\\n    {\\n        int xroot = find(x);\\n        int yroot = find(y);\\n        if(xroot==yroot)\\n            return;\\n        groupcount--;\\n        if(rank[xroot]<rank[yroot])\\n            parent[xroot] = yroot;\\n        else if(rank[yroot]<rank[xroot])\\n            parent[yroot] = xroot;\\n        else\\n        {\\n           parent[yroot] = xroot;\\n            rank[xroot]++;\\n        }\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {        \\n        unordered_map<string,int> mp;\\n        int n = accounts.size();\\n        unionfind unionobj = unionfind(n);\\n\\n      //unite the accounts which have email common\\n        for(int i=0;i<n;i++)//iterate through each account\\n        {\\n            int len = accounts[i].size();\\n            for(int j=1;j<len;j++)//iterate through each email\\n            {\\n                if(mp.find(accounts[i][j])==mp.end())//if email is not observed before we create entry\\n                    mp[accounts[i][j]] = i;\\n                else                             // unite the two accounts which have this email in comon\\n                    unionobj.unionf(mp[accounts[i][j]],i);\\n                    \\n            }\\n        }\\n        \\n        int gc = unionobj.groupcount;//gives groups after uniting accounts\\n        vector<vector<string>> res(gc);\\n        unordered_map<int,int> gind;\\n        int index = 0;\\n        //iterating through each email and their index(in given accounts )\\n        for(auto emailindex:mp)\\n        {\\n            int group = unionobj.find(emailindex.second);//we find group no. to which it belongs\\n            if(gind.find(group)==gind.end())//if it doesn\\'t exist already\\n            {\\n                gind[group] = index;//store it\\n                res[index].push_back(accounts[emailindex.second][0]);//push name of account holder\\n                res[index].push_back(emailindex.first);//push this email\\n                index++;//index holds first free index in res\\n            }\\n            else\\n                res[gind[group]].push_back(emailindex.first);//push this email to already existing account\\n        }\\n         \\n        \\n        //sort the emails\\n        for(auto&v:res)\\n            sort(v.begin()+1,v.end());//begin()+1 because at 0 index we have name\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass unionfind\\n{\\n    public:\\n    vector<int> parent;\\n    vector<int> rank;\\n    int groupcount;\\n    unionfind(int gc)\\n    {\\n        groupcount = gc;\\n        parent.resize(gc,0);\\n        rank.resize(gc,0);\\n        for(int i=0;i<gc;i++)\\n            parent[i] = i;\\n    }\\n    \\n    int find(int x)\\n    {\\n        if(x==parent[x])\\n            return x;\\n        parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    void unionf(int x,int y)\\n    {\\n        int xroot = find(x);\\n        int yroot = find(y);\\n        if(xroot==yroot)\\n            return;\\n        groupcount--;\\n        if(rank[xroot]<rank[yroot])\\n            parent[xroot] = yroot;\\n        else if(rank[yroot]<rank[xroot])\\n            parent[yroot] = xroot;\\n        else\\n        {\\n           parent[yroot] = xroot;\\n            rank[xroot]++;\\n        }\\n    }\\n    \\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {        \\n        unordered_map<string,int> mp;\\n        int n = accounts.size();\\n        unionfind unionobj = unionfind(n);\\n\\n      //unite the accounts which have email common\\n        for(int i=0;i<n;i++)//iterate through each account\\n        {\\n            int len = accounts[i].size();\\n            for(int j=1;j<len;j++)//iterate through each email\\n            {\\n                if(mp.find(accounts[i][j])==mp.end())//if email is not observed before we create entry\\n                    mp[accounts[i][j]] = i;\\n                else                             // unite the two accounts which have this email in comon\\n                    unionobj.unionf(mp[accounts[i][j]],i);\\n                    \\n            }\\n        }\\n        \\n        int gc = unionobj.groupcount;//gives groups after uniting accounts\\n        vector<vector<string>> res(gc);\\n        unordered_map<int,int> gind;\\n        int index = 0;\\n        //iterating through each email and their index(in given accounts )\\n        for(auto emailindex:mp)\\n        {\\n            int group = unionobj.find(emailindex.second);//we find group no. to which it belongs\\n            if(gind.find(group)==gind.end())//if it doesn\\'t exist already\\n            {\\n                gind[group] = index;//store it\\n                res[index].push_back(accounts[emailindex.second][0]);//push name of account holder\\n                res[index].push_back(emailindex.first);//push this email\\n                index++;//index holds first free index in res\\n            }\\n            else\\n                res[gind[group]].push_back(emailindex.first);//push this email to already existing account\\n        }\\n         \\n        \\n        //sort the emails\\n        for(auto&v:res)\\n            sort(v.begin()+1,v.end());//begin()+1 because at 0 index we have name\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067951,
                "title": "java-union-find",
                "content": "\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n\\n\\t\\tList<List<String>> ans = new ArrayList<>();\\n\\t\\tHashMap<String, String> owners = new HashMap<String, String>();\\n\\t\\tHashMap<String, String> parent = new HashMap<String, String>();\\n\\t\\tHashMap<String, Integer> rank = new HashMap<String, Integer>();\\n\\t\\tHashMap<String, TreeSet<String>> groups = new HashMap<String, TreeSet<String>>();\\n\\n\\t\\tfor (List<String> account : accounts) {\\n\\t\\t\\tString name = account.get(0);\\n\\t\\t\\tint length = account.size();\\n\\t\\t\\tfor (int i = 1; i < length; i++) {\\n\\t\\t\\t\\tString email = account.get(i);\\n\\t\\t\\t\\tparent.put(email, email);\\n\\t\\t\\t\\trank.put(email, 1);\\n\\t\\t\\t\\towners.put(email, name);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (List<String> account : accounts) {\\n\\t\\t\\tString leader = find(account.get(1), parent);\\n\\t\\t\\tint length = account.size();\\n\\t\\t\\tfor (int i = 2; i < length; i++)\\n\\t\\t\\t\\tunion(leader, find(account.get(i), parent), parent, rank);\\n\\t\\t}\\n\\n\\t\\tfor (List<String> account : accounts) {\\n\\t\\t\\tint length = account.size();\\n\\t\\t\\tString leader = find(account.get(1), parent);\\n\\t\\t\\tif (!groups.containsKey(leader))\\n\\t\\t\\t\\tgroups.put(leader, new TreeSet<String>());\\n\\t\\t\\tfor (int i = 1; i < length; i++)\\n\\t\\t\\t\\tgroups.get(leader).add(account.get(i));\\n\\t\\t}\\n\\n\\t\\tfor (String leaders : groups.keySet()) {\\n\\t\\t\\tList<String> emails = new ArrayList<String>(groups.get(leaders));\\n\\t\\t\\temails.add(0, owners.get(leaders));\\n\\t\\t\\tans.add(emails);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic static String find(String x, HashMap<String, String> parent) {\\n\\n\\t\\tif (parent.get(x).equals(x))\\n\\t\\t\\treturn x;\\n\\n\\t\\tString temp = find(parent.get(x), parent);\\n\\t\\tparent.put(x, temp); // path by compression step\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tpublic static void union(String x, String y, HashMap<String, String> parent, HashMap<String, Integer> rank) {\\n\\n\\t\\tString parentx = find(x, parent);\\n\\t\\tString parenty = find(y, parent);\\n\\n\\t\\tif (parentx.equals(parenty))\\n\\t\\t\\treturn;\\n\\n\\t\\tint rankx = rank.get(parentx);\\n\\t\\tint ranky = rank.get(parenty);\\n\\n\\t\\t// union by rank step\\n\\t\\tif (rankx < ranky)\\n\\t\\t\\tparent.put(parentx, parenty);\\n\\t\\telse if (rankx > ranky)\\n\\t\\t\\tparent.put(parenty, parentx);\\n\\t\\telse {\\n\\t\\t\\tparent.put(parentx, parenty);\\n\\t\\t\\trank.put(parenty, rank.get(parenty) + 1);\\n\\t\\t}\\n\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n\\n\\t\\tList<List<String>> ans = new ArrayList<>();\\n\\t\\tHashMap<String, String> owners = new HashMap<String, String>();\\n\\t\\tHashMap<String, String> parent = new HashMap<String, String>();\\n\\t\\tHashMap<String, Integer> rank = new HashMap<String, Integer>();\\n\\t\\tHashMap<String, TreeSet<String>> groups = new HashMap<String, TreeSet<String>>();\\n\\n\\t\\tfor (List<String> account : accounts) {\\n\\t\\t\\tString name = account.get(0);\\n\\t\\t\\tint length = account.size();\\n\\t\\t\\tfor (int i = 1; i < length; i++) {\\n\\t\\t\\t\\tString email = account.get(i);\\n\\t\\t\\t\\tparent.put(email, email);\\n\\t\\t\\t\\trank.put(email, 1);\\n\\t\\t\\t\\towners.put(email, name);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (List<String> account : accounts) {\\n\\t\\t\\tString leader = find(account.get(1), parent);\\n\\t\\t\\tint length = account.size();\\n\\t\\t\\tfor (int i = 2; i < length; i++)\\n\\t\\t\\t\\tunion(leader, find(account.get(i), parent), parent, rank);\\n\\t\\t}\\n\\n\\t\\tfor (List<String> account : accounts) {\\n\\t\\t\\tint length = account.size();\\n\\t\\t\\tString leader = find(account.get(1), parent);\\n\\t\\t\\tif (!groups.containsKey(leader))\\n\\t\\t\\t\\tgroups.put(leader, new TreeSet<String>());\\n\\t\\t\\tfor (int i = 1; i < length; i++)\\n\\t\\t\\t\\tgroups.get(leader).add(account.get(i));\\n\\t\\t}\\n\\n\\t\\tfor (String leaders : groups.keySet()) {\\n\\t\\t\\tList<String> emails = new ArrayList<String>(groups.get(leaders));\\n\\t\\t\\temails.add(0, owners.get(leaders));\\n\\t\\t\\tans.add(emails);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tpublic static String find(String x, HashMap<String, String> parent) {\\n\\n\\t\\tif (parent.get(x).equals(x))\\n\\t\\t\\treturn x;\\n\\n\\t\\tString temp = find(parent.get(x), parent);\\n\\t\\tparent.put(x, temp); // path by compression step\\n\\t\\treturn temp;\\n\\t}\\n\\n\\tpublic static void union(String x, String y, HashMap<String, String> parent, HashMap<String, Integer> rank) {\\n\\n\\t\\tString parentx = find(x, parent);\\n\\t\\tString parenty = find(y, parent);\\n\\n\\t\\tif (parentx.equals(parenty))\\n\\t\\t\\treturn;\\n\\n\\t\\tint rankx = rank.get(parentx);\\n\\t\\tint ranky = rank.get(parenty);\\n\\n\\t\\t// union by rank step\\n\\t\\tif (rankx < ranky)\\n\\t\\t\\tparent.put(parentx, parenty);\\n\\t\\telse if (rankx > ranky)\\n\\t\\t\\tparent.put(parenty, parentx);\\n\\t\\telse {\\n\\t\\t\\tparent.put(parentx, parenty);\\n\\t\\t\\trank.put(parenty, rank.get(parenty) + 1);\\n\\t\\t}\\n\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1002150,
                "title": "java-union-find-25-ms-faster-than-95-64",
                "content": "```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        // build the email->account mapping\\n        HashMap<String, Account> emailAccount = new HashMap<>();\\n        for(List<String> list : accounts){\\n            String name = list.get(0);\\n            for(int i=1; i<list.size(); i++){\\n                String email = list.get(i);\\n                if(!emailAccount.containsKey(email)){\\n                    int id = emailAccount.size();\\n                    Account ac = new Account(name, list.get(i), id);\\n                    emailAccount.put(email, ac);\\n                }\\n            }\\n        }\\n        \\n        // union the related emails\\n        UnionFind uf = new UnionFind(emailAccount.size());\\n        for(List<String> list : accounts){\\n            String name = list.get(0);\\n            for(int i=2; i<list.size(); i++){\\n                Account preAc = emailAccount.get(list.get(i-1));\\n                Account curAc = emailAccount.get(list.get(i));\\n                uf.union(preAc.id, curAc.id);\\n            }\\n        }\\n        \\n        // build the id->email list mapping\\n        HashMap<Integer, List<String>> mergedEmails = new HashMap<>();\\n        for(String email: emailAccount.keySet()){\\n            Account ac = emailAccount.get(email);\\n            int id = uf.find(ac.id);   \\n            if(!mergedEmails.containsKey(id))\\n                mergedEmails.put(id, new ArrayList<String>());\\n            mergedEmails.get(id).add(email);\\n        }\\n        \\n        // assign name to the email list\\n        List<List<String>> rt = new ArrayList<>();\\n        for(Integer id: mergedEmails.keySet()){\\n            List<String> accountInfo = mergedEmails.get(id);\\n            Collections.sort(accountInfo);\\n            String anyEmail = accountInfo.get(0);\\n            accountInfo.add(0, emailAccount.get(anyEmail).name);\\n            rt.add(accountInfo);\\n        }\\n        \\n        return rt;\\n    }\\n}\\n\\nclass Account{\\n    public String name, email;\\n    public int id;\\n    public Account(String nm, String em, int i){\\n        this.name = nm;\\n        this.email = em;\\n        this.id = i;\\n    }\\n}\\n\\nclass UnionFind{\\n    private int[] ids;\\n    private int[] sz;\\n\\n    public UnionFind(int N){\\n        ids = new int[N];\\n        sz = new int[N];\\n        for(int i=0; i<N; i++){\\n            ids[i] = i;\\n            sz[i] = 1;\\n        }\\n    }\\n    public void union(int p, int q){\\n        int rootp = find(p);\\n        int rootq = find(q);\\n        if(rootq == rootp) return;\\n        if(sz[rootp] > sz[rootq]){ //balanced\\n            ids[rootq] = ids[rootp];\\n            sz[rootp] += sz[rootq];\\n        }else{\\n            ids[rootp] = ids[rootq];  \\n            sz[rootq] += sz[rootp];\\n        }\\n        \\n    }\\n    public int find(int p){\\n        while(p != ids[p]){\\n            p = ids[p];\\n            ids[p] = ids[ids[p]]; //path compression\\n        }\\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        // build the email->account mapping\\n        HashMap<String, Account> emailAccount = new HashMap<>();\\n        for(List<String> list : accounts){\\n            String name = list.get(0);\\n            for(int i=1; i<list.size(); i++){\\n                String email = list.get(i);\\n                if(!emailAccount.containsKey(email)){\\n                    int id = emailAccount.size();\\n                    Account ac = new Account(name, list.get(i), id);\\n                    emailAccount.put(email, ac);\\n                }\\n            }\\n        }\\n        \\n        // union the related emails\\n        UnionFind uf = new UnionFind(emailAccount.size());\\n        for(List<String> list : accounts){\\n            String name = list.get(0);\\n            for(int i=2; i<list.size(); i++){\\n                Account preAc = emailAccount.get(list.get(i-1));\\n                Account curAc = emailAccount.get(list.get(i));\\n                uf.union(preAc.id, curAc.id);\\n            }\\n        }\\n        \\n        // build the id->email list mapping\\n        HashMap<Integer, List<String>> mergedEmails = new HashMap<>();\\n        for(String email: emailAccount.keySet()){\\n            Account ac = emailAccount.get(email);\\n            int id = uf.find(ac.id);   \\n            if(!mergedEmails.containsKey(id))\\n                mergedEmails.put(id, new ArrayList<String>());\\n            mergedEmails.get(id).add(email);\\n        }\\n        \\n        // assign name to the email list\\n        List<List<String>> rt = new ArrayList<>();\\n        for(Integer id: mergedEmails.keySet()){\\n            List<String> accountInfo = mergedEmails.get(id);\\n            Collections.sort(accountInfo);\\n            String anyEmail = accountInfo.get(0);\\n            accountInfo.add(0, emailAccount.get(anyEmail).name);\\n            rt.add(accountInfo);\\n        }\\n        \\n        return rt;\\n    }\\n}\\n\\nclass Account{\\n    public String name, email;\\n    public int id;\\n    public Account(String nm, String em, int i){\\n        this.name = nm;\\n        this.email = em;\\n        this.id = i;\\n    }\\n}\\n\\nclass UnionFind{\\n    private int[] ids;\\n    private int[] sz;\\n\\n    public UnionFind(int N){\\n        ids = new int[N];\\n        sz = new int[N];\\n        for(int i=0; i<N; i++){\\n            ids[i] = i;\\n            sz[i] = 1;\\n        }\\n    }\\n    public void union(int p, int q){\\n        int rootp = find(p);\\n        int rootq = find(q);\\n        if(rootq == rootp) return;\\n        if(sz[rootp] > sz[rootq]){ //balanced\\n            ids[rootq] = ids[rootp];\\n            sz[rootp] += sz[rootq];\\n        }else{\\n            ids[rootp] = ids[rootq];  \\n            sz[rootq] += sz[rootp];\\n        }\\n        \\n    }\\n    public int find(int p){\\n        while(p != ids[p]){\\n            p = ids[p];\\n            ids[p] = ids[ids[p]]; //path compression\\n        }\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 981905,
                "title": "c-union-find-easy-understanding",
                "content": "```c++\\nclass UnionFind {\\n    private:\\n        unordered_map<string, string> connection;\\n    public:\\n        void unions(string x, string y) {\\n            if(connection.count(x) == 0) {  // Creating x email if it is not present in the pool\\n                connection[x] = x;\\n            }\\n            if(connection.count(y) == 0) {  // Creating x email if it is not present in the pool\\n                connection[y] = y;\\n            }\\n\\n            string par_x = find(x), par_y = find(y);\\n            connection[par_x] = par_y;  // Union operation\\n        }\\n    \\n        string find(string x) { // Finds the representative for email\\n            if(connection[x] != x)\\n                connection[x] = find(connection[x]);\\n            return connection[x];\\n        }\\n        \\n        bool isRepresentative(string s) {   // Returns true if it is the representative of the group\\n            return connection[s] == s;\\n        }\\n        \\n        vector<string> getGroupEmails(string remail) {  // Returns all the emails which has remail as representative\\n            vector<string> eList;\\n            for(auto email: connection)\\n                if(find(email.first) == remail) eList.push_back(email.first);\\n            return eList;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        UnionFind *unionFind = new UnionFind();\\n        unordered_map<string, string> owner;    // { email: name }\\n        \\n        for(auto &account: accounts) {\\n            for(int i = 1; i < account.size(); i++) {\\n                owner[account[i]] = account[0];\\n                unionFind->unions(account[i], account[1]);  // Union of all the emails in the account\\n            }\\n        }\\n        vector<vector<string>> res;\\n        for(auto itr: owner) {\\n            if(unionFind->isRepresentative(itr.first)) {    // If the email is rep\\n                vector<string> temp = unionFind->getGroupEmails(itr.first); // getting all the emails which map to rep\\n                sort(temp.begin(), temp.end()); // Sorting the emails\\n                temp.insert(temp.begin(), itr.second);  // Inserting the name at the beginning.\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```c++\\nclass UnionFind {\\n    private:\\n        unordered_map<string, string> connection;\\n    public:\\n        void unions(string x, string y) {\\n            if(connection.count(x) == 0) {  // Creating x email if it is not present in the pool\\n                connection[x] = x;\\n            }\\n            if(connection.count(y) == 0) {  // Creating x email if it is not present in the pool\\n                connection[y] = y;\\n            }\\n\\n            string par_x = find(x), par_y = find(y);\\n            connection[par_x] = par_y;  // Union operation\\n        }\\n    \\n        string find(string x) { // Finds the representative for email\\n            if(connection[x] != x)\\n                connection[x] = find(connection[x]);\\n            return connection[x];\\n        }\\n        \\n        bool isRepresentative(string s) {   // Returns true if it is the representative of the group\\n            return connection[s] == s;\\n        }\\n        \\n        vector<string> getGroupEmails(string remail) {  // Returns all the emails which has remail as representative\\n            vector<string> eList;\\n            for(auto email: connection)\\n                if(find(email.first) == remail) eList.push_back(email.first);\\n            return eList;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        UnionFind *unionFind = new UnionFind();\\n        unordered_map<string, string> owner;    // { email: name }\\n        \\n        for(auto &account: accounts) {\\n            for(int i = 1; i < account.size(); i++) {\\n                owner[account[i]] = account[0];\\n                unionFind->unions(account[i], account[1]);  // Union of all the emails in the account\\n            }\\n        }\\n        vector<vector<string>> res;\\n        for(auto itr: owner) {\\n            if(unionFind->isRepresentative(itr.first)) {    // If the email is rep\\n                vector<string> temp = unionFind->getGroupEmails(itr.first); // getting all the emails which map to rep\\n                sort(temp.begin(), temp.end()); // Sorting the emails\\n                temp.insert(temp.begin(), itr.second);  // Inserting the name at the beginning.\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825672,
                "title": "python-concise-union-find",
                "content": "<h4> Code: </h4>\\n\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        parents = {i:i for i in range(len(accounts))}\\n        emails_roots = {}\\n        \\n        def find(x):\\n            nonlocal parents\\n            if parents[x] != x: parents[x] = find(parents[x])\\n            return parents[x]\\n        \\n        for i in range(len(accounts)):\\n            for j in range(1, len(accounts[i])):\\n                if accounts[i][j] not in emails_roots: emails_roots[accounts[i][j]] = i\\n                else: parents[find(i)] = find(emails_roots[accounts[i][j]])\\n        \\n        for i in parents: parents[i] = find(parents[i])\\n        res = [[accounts[i][0], set()] for i in range(len(accounts))]\\n        for i in parents:  res[parents[i]][1] |= set(accounts[i][1:])\\n        \\n        return list(map(lambda x: [x[0]]+sorted(list(x[1])), filter(lambda x: len(x[1])>0, res)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        parents = {i:i for i in range(len(accounts))}\\n        emails_roots = {}\\n        \\n        def find(x):\\n            nonlocal parents\\n            if parents[x] != x: parents[x] = find(parents[x])\\n            return parents[x]\\n        \\n        for i in range(len(accounts)):\\n            for j in range(1, len(accounts[i])):\\n                if accounts[i][j] not in emails_roots: emails_roots[accounts[i][j]] = i\\n                else: parents[find(i)] = find(emails_roots[accounts[i][j]])\\n        \\n        for i in parents: parents[i] = find(parents[i])\\n        res = [[accounts[i][0], set()] for i in range(len(accounts))]\\n        for i in parents:  res[parents[i]][1] |= set(accounts[i][1:])\\n        \\n        return list(map(lambda x: [x[0]]+sorted(list(x[1])), filter(lambda x: len(x[1])>0, res)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820701,
                "title": "js-dfs",
                "content": "```\\n// 1. create an adjacency graph with nodes as email and edges to emails with same account\\n// 2. Do depth first search on all clusters in graph.\\n//   - find all unique accounts\\n// 3. map all unique accounts with account name\\n// 4. sort accounts\\n\\nvar accountsMerge = function(accounts) {\\n  const graph = {};\\n  const emailToName = {};\\n  \\n  for (let account of accounts) {\\n    const name = account[0];\\n    const firstEmail = account[1];\\n   \\n    for(let i = 1; i < account.length; i++) {\\n      const email = account[i] \\n\\n      emailToName[email] = name;\\n\\n      addEdge(graph, firstEmail, email)\\n      addEdge(graph, email, firstEmail)\\n    }\\n  }\\n  \\n  const result = [];\\n  const visited = new Set();\\n  \\n  for(let key of Object.keys(graph)) {\\n    const currentSet = new Set();\\n    \\n    if (!visited.has(key)) {\\n      dfs(graph, key, currentSet, visited)\\n    }\\n    \\n    if (currentSet.size > 0) {\\n      const mergedAccount = [...currentSet].sort()\\n      const anyEmail = mergedAccount[0]\\n      mergedAccount.unshift(emailToName[anyEmail])\\n      result.push(mergedAccount)\\n    }\\n  }\\n  \\n return result; \\n}\\n\\nfunction dfs(graph, source, currentSet, visited) {\\n  visited.add(source)\\n  currentSet.add(source)\\n  \\n  for(const neighbour of graph[source]) {\\n    if (!visited.has(neighbour)) {\\n      dfs(graph, neighbour, currentSet, visited)\\n    } \\n  }\\n}\\n\\n\\nfunction addEdge(graph, from, to) {\\n  if (from in graph === false) {\\n    graph[from] = [];\\n  } \\n  \\n  graph[from].push(to)\\n}\\n```\\n\\n\\nGreat explanation here: https://www.youtube.com/watch?v=uG9mgzWpLyg&t=1345s",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n// 1. create an adjacency graph with nodes as email and edges to emails with same account\\n// 2. Do depth first search on all clusters in graph.\\n//   - find all unique accounts\\n// 3. map all unique accounts with account name\\n// 4. sort accounts\\n\\nvar accountsMerge = function(accounts) {\\n  const graph = {};\\n  const emailToName = {};\\n  \\n  for (let account of accounts) {\\n    const name = account[0];\\n    const firstEmail = account[1];\\n   \\n    for(let i = 1; i < account.length; i++) {\\n      const email = account[i] \\n\\n      emailToName[email] = name;\\n\\n      addEdge(graph, firstEmail, email)\\n      addEdge(graph, email, firstEmail)\\n    }\\n  }\\n  \\n  const result = [];\\n  const visited = new Set();\\n  \\n  for(let key of Object.keys(graph)) {\\n    const currentSet = new Set();\\n    \\n    if (!visited.has(key)) {\\n      dfs(graph, key, currentSet, visited)\\n    }\\n    \\n    if (currentSet.size > 0) {\\n      const mergedAccount = [...currentSet].sort()\\n      const anyEmail = mergedAccount[0]\\n      mergedAccount.unshift(emailToName[anyEmail])\\n      result.push(mergedAccount)\\n    }\\n  }\\n  \\n return result; \\n}\\n\\nfunction dfs(graph, source, currentSet, visited) {\\n  visited.add(source)\\n  currentSet.add(source)\\n  \\n  for(const neighbour of graph[source]) {\\n    if (!visited.has(neighbour)) {\\n      dfs(graph, neighbour, currentSet, visited)\\n    } \\n  }\\n}\\n\\n\\nfunction addEdge(graph, from, to) {\\n  if (from in graph === false) {\\n    graph[from] = [];\\n  } \\n  \\n  graph[from].push(to)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 809218,
                "title": "clean-python-solution-explained-dfs",
                "content": "```python\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        graph = defaultdict(list)\\n        merged = set()\\n        ans = []\\n\\n        #[0]\\n        for data in accounts:\\n            emails = data[1:]\\n            for i, email in enumerate(emails):\\n                graph[email].extend(emails[:i])\\n                graph[email].extend(emails[i+1:])\\n        \\n        for data in accounts:\\n            name = data[0]\\n            visited = set()\\n            stack = [data[1]] #[2]\\n\\n            if data[1] in merged: continue #[1]\\n            \\n            while stack:\\n                e = stack.pop()\\n                if e in visited: continue\\n                visited.add(e)\\n                stack.extend(graph[e])\\n            \\n            merged.update(visited)\\n            ans.append([name]+sorted(list(visited))) #[3]\\n        \\n        return ans\\n\\n\"\"\"\\nTreat each email as a node.\\nBuild an adjacency graph. [0]\\n\\nFor every account\\'s data\\nFirst, lets check if the first email is already merged. [1]\\nIf the first email is already merged to other groups, then other emails will be in another group as well.\\nSo don\\'t need to check.\\n\\nSecond, do a DFS starting from the first email. Put all the connected nodes into visited. [2]\\nAnd append the sorted(visited) to the ans with name. [3]\\n\\nLet N be the total number of emails. M be the total number of final groups.\\nBuild the graph takes O(N).\\nFor each final groups, we make a DFS to all nodes, taking O(MN).\\nSort the group takes O((N/M)*Log(N/M)) -> O((N/M)*(logN-LogM))\\nTime: O(MN)\\nSpace: O(N)\\n\"\"\"\\n\\n\"\"\"\\nSimilar Problems: 399, 839, 952, 990, 721\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict\\n\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        graph = defaultdict(list)\\n        merged = set()\\n        ans = []\\n\\n        #[0]\\n        for data in accounts:\\n            emails = data[1:]\\n            for i, email in enumerate(emails):\\n                graph[email].extend(emails[:i])\\n                graph[email].extend(emails[i+1:])\\n        \\n        for data in accounts:\\n            name = data[0]\\n            visited = set()\\n            stack = [data[1]] #[2]\\n\\n            if data[1] in merged: continue #[1]\\n            \\n            while stack:\\n                e = stack.pop()\\n                if e in visited: continue\\n                visited.add(e)\\n                stack.extend(graph[e])\\n            \\n            merged.update(visited)\\n            ans.append([name]+sorted(list(visited))) #[3]\\n        \\n        return ans\\n\\n\"\"\"\\nTreat each email as a node.\\nBuild an adjacency graph. [0]\\n\\nFor every account\\'s data\\nFirst, lets check if the first email is already merged. [1]\\nIf the first email is already merged to other groups, then other emails will be in another group as well.\\nSo don\\'t need to check.\\n\\nSecond, do a DFS starting from the first email. Put all the connected nodes into visited. [2]\\nAnd append the sorted(visited) to the ans with name. [3]\\n\\nLet N be the total number of emails. M be the total number of final groups.\\nBuild the graph takes O(N).\\nFor each final groups, we make a DFS to all nodes, taking O(MN).\\nSort the group takes O((N/M)*Log(N/M)) -> O((N/M)*(logN-LogM))\\nTime: O(MN)\\nSpace: O(N)\\n\"\"\"\\n\\n\"\"\"\\nSimilar Problems: 399, 839, 952, 990, 721\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785429,
                "title": "python-disjoint-set-union-connected-components",
                "content": "According to wiki https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Representation, \\nWe define three kinds of operations.\\n```\\nclass DSU():\\n    def __init__(self):\\n        self.root = dict() # representative member (root) of each set\\n    \\n    def makeset(self, x):  \\n        if x not in self.root:\\n            self.root[x] = x\\n        \\n    def find(self, x):  # given x, get the root of each set\\n        if x == self.root[x]:  \\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n        \\n    def union(self, x, y):  # union x and y, let x be the root\\n        parent_x = self.find(x)\\n        parent_y = self.find(y)\\n        if parent_x != parent_y:\\n            self.root[parent_y] = parent_x\\n\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        dsu = DSU()\\n        email_to_name = {}  # 1. store every email for iteration use  2. (email, name) hashmap\\n        \\n        for acc in accounts:\\n            name = acc[0]\\n            root = acc[1]\\n            dsu.makeset(root)\\n            for email in acc[1:]:\\n                email_to_name[email] = name\\n                dsu.makeset(email)\\n                dsu.union(root, email)\\n                # we\\'ve completed the construction of a graph\\n                \\n        # Get the connected component, iterate through all of the emails \\n        connected_component = collections.defaultdict(list)\\n        for email, name in email_to_name.items():\\n            connected_component[dsu.find(email)].append(email)\\n        return [ [email_to_name[root]]+ sorted(lists) for root, lists in connected_component.items()]\\n     \\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU():\\n    def __init__(self):\\n        self.root = dict() # representative member (root) of each set\\n    \\n    def makeset(self, x):  \\n        if x not in self.root:\\n            self.root[x] = x\\n        \\n    def find(self, x):  # given x, get the root of each set\\n        if x == self.root[x]:  \\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n        \\n    def union(self, x, y):  # union x and y, let x be the root\\n        parent_x = self.find(x)\\n        parent_y = self.find(y)\\n        if parent_x != parent_y:\\n            self.root[parent_y] = parent_x\\n\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        dsu = DSU()\\n        email_to_name = {}  # 1. store every email for iteration use  2. (email, name) hashmap\\n        \\n        for acc in accounts:\\n            name = acc[0]\\n            root = acc[1]\\n            dsu.makeset(root)\\n            for email in acc[1:]:\\n                email_to_name[email] = name\\n                dsu.makeset(email)\\n                dsu.union(root, email)\\n                # we\\'ve completed the construction of a graph\\n                \\n        # Get the connected component, iterate through all of the emails \\n        connected_component = collections.defaultdict(list)\\n        for email, name in email_to_name.items():\\n            connected_component[dsu.find(email)].append(email)\\n        return [ [email_to_name[root]]+ sorted(lists) for root, lists in connected_component.items()]\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 776153,
                "title": "python-dfs",
                "content": "The overhead is to create a graph that has proper connections and mapping from name to emails.\\nAfterwards we just DFS.\\n\\nTime complexity: n*logn\\nWhere n is the number of strings in accounts\\n\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        graph = defaultdict(list)\\n        email_to_id = defaultdict(set)\\n        id_to_name = {}\\n        _id = -1\\n        visited = set()\\n        merged_accounts = []\\n        \\n        # Graph Creation\\n        for account in accounts:\\n            name = account[0]\\n            _id += 1\\n            id_to_name[_id] = name\\n            \\n            for email in account[1:]:\\n                graph[_id].append(email)\\n                graph[email].append(_id)\\n                if email in email_to_id:\\n                    for em in email_to_id[email]:\\n                        graph[_id].append(em)\\n                        graph[em].append(_id)\\n                email_to_id[email].add(_id)\\n        \\n        def walk(node):\\n            for neighbor in graph[node]:\\n                if neighbor not in visited:\\n                    visited.add(neighbor)\\n                    if type(neighbor) is str:\\n                        merged_accounts[-1].append(neighbor)\\n                    walk(neighbor)\\n        \\n        for _id in id_to_name:\\n            if _id not in visited:\\n                merged_accounts.append([id_to_name[_id]])\\n                walk(_id)\\n            \\n        return [[merged_acc[0], *sorted(merged_acc[1:])] for merged_acc in merged_accounts]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        graph = defaultdict(list)\\n        email_to_id = defaultdict(set)\\n        id_to_name = {}\\n        _id = -1\\n        visited = set()\\n        merged_accounts = []\\n        \\n        # Graph Creation\\n        for account in accounts:\\n            name = account[0]\\n            _id += 1\\n            id_to_name[_id] = name\\n            \\n            for email in account[1:]:\\n                graph[_id].append(email)\\n                graph[email].append(_id)\\n                if email in email_to_id:\\n                    for em in email_to_id[email]:\\n                        graph[_id].append(em)\\n                        graph[em].append(_id)\\n                email_to_id[email].add(_id)\\n        \\n        def walk(node):\\n            for neighbor in graph[node]:\\n                if neighbor not in visited:\\n                    visited.add(neighbor)\\n                    if type(neighbor) is str:\\n                        merged_accounts[-1].append(neighbor)\\n                    walk(neighbor)\\n        \\n        for _id in id_to_name:\\n            if _id not in visited:\\n                merged_accounts.append([id_to_name[_id]])\\n                walk(_id)\\n            \\n        return [[merged_acc[0], *sorted(merged_acc[1:])] for merged_acc in merged_accounts]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 652750,
                "title": "easy-c-bfs-with-comments",
                "content": "```\\n// Time: O(\\u2211AiLog(Ai))\\n// Space: O(\\u2211Ai)\\n// Algo: BFS\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        vector<vector<string>> out;\\n        unordered_map<string, vector<string>> groups;\\n        unordered_map<string, string> email_to_name;\\n        for (auto& act : accounts) {\\n            for (int i = 1; i < act.size(); i++) {\\n                // Create mappings for emails to name\\n                email_to_name[act[i]] = act[0];\\n                // Create mappings of 1st email to all other emails\\n                groups[act[1]].push_back(act[i]);\\n                groups[act[i]].push_back(act[1]);\\n            }\\n        }\\n        unordered_map<string, bool> visited;\\n        for (auto group : groups) {\\n            // Find unvisited group entry\\n            if (!visited[group.first]) {\\n                vector<string> tmp;\\n                // Push name as the first string\\n                tmp.push_back(email_to_name[group.first]);\\n                queue<string> q;\\n                q.push(group.first);\\n                visited[group.first] = true;\\n                // Do BFS loop\\n                while(!q.empty()) {\\n                    string s = q.front(); q.pop();\\n                    // Push email\\n                    tmp.push_back(s);\\n                    \\n                    for (auto& email : groups[s]) {\\n                        if (!visited[email]) {\\n                            q.push(email);\\n                            visited[email] = true;\\n                        }\\n                    }\\n                }\\n                // Sort the list of emails for this name\\n                // nlogn\\n                sort(tmp.begin() + 1, tmp.end());\\n                out.push_back(tmp);   \\n            }\\n        }\\n        return out;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// Time: O(\\u2211AiLog(Ai))\\n// Space: O(\\u2211Ai)\\n// Algo: BFS\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        vector<vector<string>> out;\\n        unordered_map<string, vector<string>> groups;\\n        unordered_map<string, string> email_to_name;\\n        for (auto& act : accounts) {\\n            for (int i = 1; i < act.size(); i++) {\\n                // Create mappings for emails to name\\n                email_to_name[act[i]] = act[0];\\n                // Create mappings of 1st email to all other emails\\n                groups[act[1]].push_back(act[i]);\\n                groups[act[i]].push_back(act[1]);\\n            }\\n        }\\n        unordered_map<string, bool> visited;\\n        for (auto group : groups) {\\n            // Find unvisited group entry\\n            if (!visited[group.first]) {\\n                vector<string> tmp;\\n                // Push name as the first string\\n                tmp.push_back(email_to_name[group.first]);\\n                queue<string> q;\\n                q.push(group.first);\\n                visited[group.first] = true;\\n                // Do BFS loop\\n                while(!q.empty()) {\\n                    string s = q.front(); q.pop();\\n                    // Push email\\n                    tmp.push_back(s);\\n                    \\n                    for (auto& email : groups[s]) {\\n                        if (!visited[email]) {\\n                            q.push(email);\\n                            visited[email] = true;\\n                        }\\n                    }\\n                }\\n                // Sort the list of emails for this name\\n                // nlogn\\n                sort(tmp.begin() + 1, tmp.end());\\n                out.push_back(tmp);   \\n            }\\n        }\\n        return out;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640507,
                "title": "c-graph-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string,vector<string>> groups;\\n        unordered_map<string,string> email_to_name;\\n        for(auto& account:accounts)\\n        {\\n            for(int i=1;i<account.size();++i)\\n            {\\n                email_to_name[account[i]]=account[0];\\n                groups[account[1]].push_back(account[i]);\\n                groups[account[i]].push_back(account[1]);\\n            }\\n        }\\n        \\n        vector<vector<string>> ans;\\n        unordered_map<string,bool> visited;\\n        for(auto& group:groups)\\n        {\\n            if(!visited[group.first])\\n            {\\n                vector<string> g{email_to_name[group.first]};\\n                stack<string> process;\\n                process.push(group.first);\\n                visited[group.first]=true;\\n                while(!process.empty())\\n                {\\n                    auto cur=process.top();\\n                    \\n                    g.push_back(cur);\\n                    process.pop();\\n                    for(auto& edge:groups[cur])\\n                    {\\n                        if(!visited[edge])\\n                        {\\n                            process.push(edge);                            \\n                            visited[edge]=true;\\n                        }\\n                    }\\n                }\\n                \\n                sort(g.begin()+1,g.end());\\n                ans.push_back(g);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string,vector<string>> groups;\\n        unordered_map<string,string> email_to_name;\\n        for(auto& account:accounts)\\n        {\\n            for(int i=1;i<account.size();++i)\\n            {\\n                email_to_name[account[i]]=account[0];\\n                groups[account[1]].push_back(account[i]);\\n                groups[account[i]].push_back(account[1]);\\n            }\\n        }\\n        \\n        vector<vector<string>> ans;\\n        unordered_map<string,bool> visited;\\n        for(auto& group:groups)\\n        {\\n            if(!visited[group.first])\\n            {\\n                vector<string> g{email_to_name[group.first]};\\n                stack<string> process;\\n                process.push(group.first);\\n                visited[group.first]=true;\\n                while(!process.empty())\\n                {\\n                    auto cur=process.top();\\n                    \\n                    g.push_back(cur);\\n                    process.pop();\\n                    for(auto& edge:groups[cur])\\n                    {\\n                        if(!visited[edge])\\n                        {\\n                            process.push(edge);                            \\n                            visited[edge]=true;\\n                        }\\n                    }\\n                }\\n                \\n                sort(g.begin()+1,g.end());\\n                ans.push_back(g);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609098,
                "title": "c-dfs",
                "content": "DFS solution. Comments inline\\n\\n    public class Solution\\n    {\\n        /// <summary>\\n        /// https://leetcode.com/problems/accounts-merge/\\n        /// </summary>\\n        /// <param name=\"accounts\"></param>\\n        /// <returns></returns>\\n        public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts)\\n        {\\n            // email node and neighbor nodes mapping\\n            Dictionary<string, HashSet<string>> graph = new Dictionary<string, HashSet<string>>();\\n            // email and user name mapping\\n            Dictionary<string, string> emailNameMap = new Dictionary<string, string>();\\n\\n            // construct graph\\n            foreach (var account in accounts)\\n            {\\n                // first value is user name\\n                string userName = account[0];\\n                for (int i = 1; i < account.Count; i++)\\n                {\\n                    // other following values on the list are email addresses\\n                    if (!graph.ContainsKey(account[i]))\\n                    {\\n                        graph[account[i]] = new HashSet<string>();\\n                    }\\n\\n                    // if the email id exists add it to the hashset corresponding to the email id\\n                    emailNameMap[account[i]] = userName; // assign username to the email\\n\\n                    if (i == 1)\\n                    {\\n                        continue;\\n                    }\\n\\n                    // add adjacent email ids as edges\\n                    graph[account[i]].Add(account[i - 1]);\\n                    graph[account[i - 1]].Add(account[i]);\\n                }\\n            }\\n\\n            HashSet<string> visited = new HashSet<string>();\\n            IList<IList<string>> res = new List<IList<string>>();\\n\\n            // DFS\\n            foreach (var email in emailNameMap.Keys)\\n            {\\n                List<string> listOfEmailAddresses = new List<string>();\\n                if (visited.Add(email))\\n                {\\n                    DFS(graph, email, visited, listOfEmailAddresses);\\n\\n                    listOfEmailAddresses.Add(emailNameMap[email]);\\n                    listOfEmailAddresses.Sort(StringComparer.Ordinal); // case insensitive compare\\n                    res.Add(listOfEmailAddresses);\\n                }\\n            }\\n            return res;\\n        }\\n\\n        private void DFS(Dictionary<string, HashSet<string>> graph, string email, HashSet<string> visited, List<string> listOfEmailAddresses)\\n        {\\n            listOfEmailAddresses.Add(email);\\n            foreach (var item in graph[email])\\n            {\\n                if (visited.Add(item))\\n                {\\n                    DFS(graph, item, visited, listOfEmailAddresses);\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution\\n    {\\n        /// <summary>\\n        /// https://leetcode.com/problems/accounts-merge/\\n        /// </summary>\\n        /// <param name=\"accounts\"></param>\\n        /// <returns></returns>\\n        public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts)\\n        {\\n            // email node and neighbor nodes mapping\\n            Dictionary<string, HashSet<string>> graph = new Dictionary<string, HashSet<string>>();\\n            // email and user name mapping\\n            Dictionary<string, string> emailNameMap = new Dictionary<string, string>();\\n\\n            // construct graph\\n            foreach (var account in accounts)\\n            {\\n                // first value is user name\\n                string userName = account[0];\\n                for (int i = 1; i < account.Count; i++)\\n                {\\n                    // other following values on the list are email addresses\\n                    if (!graph.ContainsKey(account[i]))\\n                    {\\n                        graph[account[i]] = new HashSet<string>();\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 600338,
                "title": "java-clean-code-with-unionfind",
                "content": "This is a good question for Union-Find. Flip the indices and work with it.\\n\\n```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<String, Integer> emailToIndex = new HashMap<>();\\n        int n = accounts.size();\\n        UnionFind uf = new UnionFind(n);\\n        \\n        for (int i = 0; i < n; i++) {\\n            List<String> emails = accounts.get(i);\\n            String personName = emails.get(0);\\n            for (int j = 1; j < emails.size(); j++) {\\n                String email = emails.get(j);\\n                if (emailToIndex.containsKey(email)) {\\n                    uf.union(i, emailToIndex.get(email));\\n                } else {\\n                    emailToIndex.put(email, i);\\n                }\\n            }\\n        }\\n        \\n        int resultIndex = 0;\\n        Map<Integer, Integer> rootToResult = new HashMap<>();\\n        List<TreeSet<String>> output = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (uf.isRoot(i)) {\\n                TreeSet results = new TreeSet<>();\\n                output.add(results);\\n                rootToResult.put(i, resultIndex);\\n                List<String> emails = accounts.get(i);\\n                for (int j = 1; j < emails.size(); j++) {\\n                    results.add(emails.get(j));\\n                }\\n                resultIndex++;\\n            }\\n        }\\n        \\n        int[] parents = uf.parent;\\n        \\n        // for all roots, add them, and add their parents...\\n        for (int i = 0; i < n; i++) {\\n            if (!uf.isRoot(i)) {\\n                TreeSet results = output.get(rootToResult.get(uf.findRoot(i)));\\n                List<String> emails = accounts.get(i);\\n                for (int j = 1; j < emails.size(); j++) {\\n                    results.add(emails.get(j));\\n                }\\n            }\\n        }\\n        \\n        List<List<String>> finalResult = new ArrayList<>();\\n        for (Map.Entry<Integer, Integer> entry: rootToResult.entrySet()) {\\n            List<String> row = new ArrayList<>();\\n            row.add(accounts.get(entry.getKey()).get(0));\\n            row.addAll(output.get(rootToResult.get(entry.getKey())));\\n            finalResult.add(row);\\n        }\\n        \\n        return finalResult;\\n        \\n    }\\n    \\n    private class UnionFind {\\n        \\n        public int[] parent;\\n        \\n        public UnionFind(int n) {\\n            parent = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public void union(int a, int b) {\\n            if (findRoot(a) == findRoot(b)) {\\n                return;\\n            }\\n            if (a > b) {\\n                union(b, a);\\n                return;\\n            }\\n            int rootB = findRoot(b);\\n            parent[rootB] = a;   \\n        }\\n        \\n        public int findRoot(int p) {\\n            while (p != parent[p]) {\\n                parent[p] = parent[parent[p]];    // path compression by halving\\n                p = parent[p];\\n            }\\n            return p;\\n        }\\n        \\n        public boolean isRoot(int a) {\\n            return parent[a] == a;\\n        }\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        Map<String, Integer> emailToIndex = new HashMap<>();\\n        int n = accounts.size();\\n        UnionFind uf = new UnionFind(n);\\n        \\n        for (int i = 0; i < n; i++) {\\n            List<String> emails = accounts.get(i);\\n            String personName = emails.get(0);\\n            for (int j = 1; j < emails.size(); j++) {\\n                String email = emails.get(j);\\n                if (emailToIndex.containsKey(email)) {\\n                    uf.union(i, emailToIndex.get(email));\\n                } else {\\n                    emailToIndex.put(email, i);\\n                }\\n            }\\n        }\\n        \\n        int resultIndex = 0;\\n        Map<Integer, Integer> rootToResult = new HashMap<>();\\n        List<TreeSet<String>> output = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            if (uf.isRoot(i)) {\\n                TreeSet results = new TreeSet<>();\\n                output.add(results);\\n                rootToResult.put(i, resultIndex);\\n                List<String> emails = accounts.get(i);\\n                for (int j = 1; j < emails.size(); j++) {\\n                    results.add(emails.get(j));\\n                }\\n                resultIndex++;\\n            }\\n        }\\n        \\n        int[] parents = uf.parent;\\n        \\n        // for all roots, add them, and add their parents...\\n        for (int i = 0; i < n; i++) {\\n            if (!uf.isRoot(i)) {\\n                TreeSet results = output.get(rootToResult.get(uf.findRoot(i)));\\n                List<String> emails = accounts.get(i);\\n                for (int j = 1; j < emails.size(); j++) {\\n                    results.add(emails.get(j));\\n                }\\n            }\\n        }\\n        \\n        List<List<String>> finalResult = new ArrayList<>();\\n        for (Map.Entry<Integer, Integer> entry: rootToResult.entrySet()) {\\n            List<String> row = new ArrayList<>();\\n            row.add(accounts.get(entry.getKey()).get(0));\\n            row.addAll(output.get(rootToResult.get(entry.getKey())));\\n            finalResult.add(row);\\n        }\\n        \\n        return finalResult;\\n        \\n    }\\n    \\n    private class UnionFind {\\n        \\n        public int[] parent;\\n        \\n        public UnionFind(int n) {\\n            parent = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        public void union(int a, int b) {\\n            if (findRoot(a) == findRoot(b)) {\\n                return;\\n            }\\n            if (a > b) {\\n                union(b, a);\\n                return;\\n            }\\n            int rootB = findRoot(b);\\n            parent[rootB] = a;   \\n        }\\n        \\n        public int findRoot(int p) {\\n            while (p != parent[p]) {\\n                parent[p] = parent[parent[p]];    // path compression by halving\\n                p = parent[p];\\n            }\\n            return p;\\n        }\\n        \\n        public boolean isRoot(int a) {\\n            return parent[a] == a;\\n        }\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536135,
                "title": "easy-to-understand-java-solution-union-find",
                "content": "Union Find Self Explanatory Solution\\n```\\npublic List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (accounts == null || accounts.size() == 0) {\\n            return result;\\n        }\\n        \\n        int[] parent = new int[accounts.size()];\\n        for (int i=0;i<accounts.size(); i++) {\\n            parent[i] = i; \\n        }\\n        \\n        // union find\\n        Map<String, Integer> emailToIdxMap = new HashMap<>();\\n        for (int i=0; i<accounts.size(); i++) {\\n            List<String> account = accounts.get(i);\\n            for (int j=1; j<account.size(); j++) {\\n                String email = account.get(j);\\n                if (emailToIdxMap.containsKey(email)) {\\n                    int givenIdx = emailToIdxMap.get(email);\\n                    int r1 = find(givenIdx, parent);\\n                    int r2 = find(i, parent);\\n                    parent[r2] = r1;\\n                } else {\\n                    emailToIdxMap.put(email, i);\\n                }\\n            }\\n        }\\n        \\n        // merge accounts   \\n        Map<Integer, Set<String>> idxToEmailMap = new HashMap<>();\\n        for (int i=0;i <accounts.size(); i++) {\\n            for (int j=1; j<accounts.get(i).size(); j++) {\\n                idxToEmailMap.putIfAbsent(find(i, parent), new TreeSet<>());\\n                idxToEmailMap.get(find(i, parent)).add(accounts.get(i).get(j));\\n            }\\n        }\\n        \\n        // convert into required output format\\n        for (Map.Entry<Integer, Set<String>> entry : idxToEmailMap.entrySet()) {\\n            List<String> currentAccount = new ArrayList<>();\\n            currentAccount.add(accounts.get(entry.getKey()).get(0));\\n            for (String email : entry.getValue()) {\\n                currentAccount.add(email);\\n            }\\n            result.add(currentAccount);\\n        }\\n        return result;\\n    }\\n    \\n    private int find(int i, int[] parent) {\\n        if (parent[i] != i) {\\n            return find(parent[i], parent);\\n        }\\n        return parent[i];\\n    }",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "Union Find Self Explanatory Solution\\n```\\npublic List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (accounts == null || accounts.size() == 0) {\\n            return result;\\n        }\\n        \\n        int[] parent = new int[accounts.size()];\\n        for (int i=0;i<accounts.size(); i++) {\\n            parent[i] = i; \\n        }\\n        \\n        // union find\\n        Map<String, Integer> emailToIdxMap = new HashMap<>();\\n        for (int i=0; i<accounts.size(); i++) {\\n            List<String> account = accounts.get(i);\\n            for (int j=1; j<account.size(); j++) {\\n                String email = account.get(j);\\n                if (emailToIdxMap.containsKey(email)) {\\n                    int givenIdx = emailToIdxMap.get(email);\\n                    int r1 = find(givenIdx, parent);\\n                    int r2 = find(i, parent);\\n                    parent[r2] = r1;\\n                } else {\\n                    emailToIdxMap.put(email, i);\\n                }\\n            }\\n        }\\n        \\n        // merge accounts   \\n        Map<Integer, Set<String>> idxToEmailMap = new HashMap<>();\\n        for (int i=0;i <accounts.size(); i++) {\\n            for (int j=1; j<accounts.get(i).size(); j++) {\\n                idxToEmailMap.putIfAbsent(find(i, parent), new TreeSet<>());\\n                idxToEmailMap.get(find(i, parent)).add(accounts.get(i).get(j));\\n            }\\n        }\\n        \\n        // convert into required output format\\n        for (Map.Entry<Integer, Set<String>> entry : idxToEmailMap.entrySet()) {\\n            List<String> currentAccount = new ArrayList<>();\\n            currentAccount.add(accounts.get(entry.getKey()).get(0));\\n            for (String email : entry.getValue()) {\\n                currentAccount.add(email);\\n            }\\n            result.add(currentAccount);\\n        }\\n        return result;\\n    }\\n    \\n    private int find(int i, int[] parent) {\\n        if (parent[i] != i) {\\n            return find(parent[i], parent);\\n        }\\n        return parent[i];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 518659,
                "title": "java-unionfind",
                "content": "```\\nclass Solution {\\n    Map<String, TreeSet<String>> unions = new HashMap<>();\\n    public List<List<String>> accountsMerge(List<List<String>> as) {\\n        Map<String, Integer> emap = new HashMap<>();\\n        Map<Integer, Set<String>> eset = new HashMap<>();\\n        int n = as.size();\\n        Uf uf = new Uf(n);\\n        for (int i = 0; i < n; i++){\\n            List<String> es = as.get(i);\\n            for (int j = 1; j < es.size(); j++) {\\n                String e = es.get(j);\\n                if (emap.containsKey(e)){\\n                    uf.union(emap.get(e), i);\\n                } \\n                emap.put(e, i);\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++){\\n            List<String> es = as.get(i);\\n            int p = uf.find(i);\\n            eset.computeIfAbsent(p, k -> new HashSet<>());\\n            Set<String> st = eset.get(p);\\n            for (int j = 1; j < es.size(); j++) {\\n                st.add(es.get(j));\\n            }\\n            eset.put(p, st); // if necessary?\\n        }\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        \\n        for (int i : eset.keySet()) {\\n            List<String> l = new ArrayList<>();\\n            l.addAll(eset.get(i));\\n            Collections.sort(l);\\n            l.add(0, as.get(i).get(0));\\n            res.add(l);\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n    \\n    class Uf {\\n        private int cnt;\\n        private int[] ps;\\n        \\n        \\n        public Uf(int n) {\\n            this.cnt = cnt;\\n            this.ps = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                ps[i] = i;\\n            }\\n        }\\n        \\n        public int find(int p) {\\n            if (ps[p] != p) p = find(ps[p]);\\n            return p;\\n        }\\n        \\n        public void union(int i, int j) {\\n            ps[find(i)] = ps[find(j)];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<String, TreeSet<String>> unions = new HashMap<>();\\n    public List<List<String>> accountsMerge(List<List<String>> as) {\\n        Map<String, Integer> emap = new HashMap<>();\\n        Map<Integer, Set<String>> eset = new HashMap<>();\\n        int n = as.size();\\n        Uf uf = new Uf(n);\\n        for (int i = 0; i < n; i++){\\n            List<String> es = as.get(i);\\n            for (int j = 1; j < es.size(); j++) {\\n                String e = es.get(j);\\n                if (emap.containsKey(e)){\\n                    uf.union(emap.get(e), i);\\n                } \\n                emap.put(e, i);\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++){\\n            List<String> es = as.get(i);\\n            int p = uf.find(i);\\n            eset.computeIfAbsent(p, k -> new HashSet<>());\\n            Set<String> st = eset.get(p);\\n            for (int j = 1; j < es.size(); j++) {\\n                st.add(es.get(j));\\n            }\\n            eset.put(p, st); // if necessary?\\n        }\\n        \\n        List<List<String>> res = new ArrayList<>();\\n        \\n        for (int i : eset.keySet()) {\\n            List<String> l = new ArrayList<>();\\n            l.addAll(eset.get(i));\\n            Collections.sort(l);\\n            l.add(0, as.get(i).get(0));\\n            res.add(l);\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n    \\n    class Uf {\\n        private int cnt;\\n        private int[] ps;\\n        \\n        \\n        public Uf(int n) {\\n            this.cnt = cnt;\\n            this.ps = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                ps[i] = i;\\n            }\\n        }\\n        \\n        public int find(int p) {\\n            if (ps[p] != p) p = find(ps[p]);\\n            return p;\\n        }\\n        \\n        public void union(int i, int j) {\\n            ps[find(i)] = ps[find(j)];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489526,
                "title": "python-unionfind-dfs-two-solutions",
                "content": "```\\n\\'\\'\\'\\nUnion Find\\nUnion all emails in each account\\nBy default use the first email as union root.\\nIterate all emails, and create a list of emails for each union.\\nsort the emails and append left the name of owner.\\n\\'\\'\\'\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        email_name = {}\\n        email_union = {}\\n        for acc in accounts:\\n            name = acc[0]\\n            for email in acc[1:]:\\n                email_name[email] = name\\n                self.union(acc[1], email, email_union) #By default use the first email as union root.\\n        email_list = collections.defaultdict(list)\\n        for email in email_name.keys():\\n            email_list[self.find(email, email_union)].append(email)\\n        res = []\\n        for k, v in email_list.items():\\n            res.append([email_name[k]] + sorted(v))\\n        return res\\n    \\n    def find(self, cur, my_union):\\n        if cur not in my_union:\\n            return None\\n        root = cur\\n        while my_union[root] != root:\\n            root = my_union[root]\\n        while cur != root:\\n            nxt = my_union[cur]\\n            my_union[cur] = root\\n            cur = nxt\\n        return root\\n    \\n    def union(self, left, right, my_union):\\n        left_root = self.find(left, my_union)\\n        right_root = self.find(right, my_union)\\n        if not left_root and not right_root:\\n            my_union[left] = my_union[right] = left\\n        elif left_root and not right_root:\\n            my_union[right] = left_root\\n        elif not left_root and right_root:\\n            my_union[left] = right_root\\n        else:\\n            my_union[right_root] = left_root\\n        return\\n\\t\\t\\n\\'\\'\\'\\nDFS\\nBuild a graph to link all emails belong to the same onwer\\nAdd edge between current email and the first email in each account.\\nUse DFS/BFS to get all the emails linked together and group, sort them with owner name to form the results\\nTime: O(nlogn), n is the total emails for all accounts\\nSpace: O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        email_name = {}\\n        graph = collections.defaultdict(list)\\n        for acc in accounts:\\n            name = acc[0]\\n            for email in acc[1:]:\\n                graph[email].append(acc[1])\\n                graph[acc[1]].append(email)\\n                email_name[email] = name\\n                \\n        seen = set()\\n        res = []\\n        for email in email_name.keys():\\n            if email not in seen:\\n                current_group = []\\n                self.DFS(email, current_group, seen, graph)\\n                res.append([email_name[email]]+sorted(current_group))\\n        return res\\n    \\n    def DFS(self, current, current_group, seen, graph):\\n        seen.add(current)\\n        current_group += [current]\\n        for nxt in graph[current]:\\n            if nxt not in seen:\\n                self.DFS(nxt, current_group, seen, graph)\\n        return\\t\\t\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\n\\'\\'\\'\\nUnion Find\\nUnion all emails in each account\\nBy default use the first email as union root.\\nIterate all emails, and create a list of emails for each union.\\nsort the emails and append left the name of owner.\\n\\'\\'\\'\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        email_name = {}\\n        email_union = {}\\n        for acc in accounts:\\n            name = acc[0]\\n            for email in acc[1:]:\\n                email_name[email] = name\\n                self.union(acc[1], email, email_union) #By default use the first email as union root.\\n        email_list = collections.defaultdict(list)\\n        for email in email_name.keys():\\n            email_list[self.find(email, email_union)].append(email)\\n        res = []\\n        for k, v in email_list.items():\\n            res.append([email_name[k]] + sorted(v))\\n        return res\\n    \\n    def find(self, cur, my_union):\\n        if cur not in my_union:\\n            return None\\n        root = cur\\n        while my_union[root] != root:\\n            root = my_union[root]\\n        while cur != root:\\n            nxt = my_union[cur]\\n            my_union[cur] = root\\n            cur = nxt\\n        return root\\n    \\n    def union(self, left, right, my_union):\\n        left_root = self.find(left, my_union)\\n        right_root = self.find(right, my_union)\\n        if not left_root and not right_root:\\n            my_union[left] = my_union[right] = left\\n        elif left_root and not right_root:\\n            my_union[right] = left_root\\n        elif not left_root and right_root:\\n            my_union[left] = right_root\\n        else:\\n            my_union[right_root] = left_root\\n        return\\n\\t\\t\\n\\'\\'\\'\\nDFS\\nBuild a graph to link all emails belong to the same onwer\\nAdd edge between current email and the first email in each account.\\nUse DFS/BFS to get all the emails linked together and group, sort them with owner name to form the results\\nTime: O(nlogn), n is the total emails for all accounts\\nSpace: O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        email_name = {}\\n        graph = collections.defaultdict(list)\\n        for acc in accounts:\\n            name = acc[0]\\n            for email in acc[1:]:\\n                graph[email].append(acc[1])\\n                graph[acc[1]].append(email)\\n                email_name[email] = name\\n                \\n        seen = set()\\n        res = []\\n        for email in email_name.keys():\\n            if email not in seen:\\n                current_group = []\\n                self.DFS(email, current_group, seen, graph)\\n                res.append([email_name[email]]+sorted(current_group))\\n        return res\\n    \\n    def DFS(self, current, current_group, seen, graph):\\n        seen.add(current)\\n        current_group += [current]\\n        for nxt in graph[current]:\\n            if nxt not in seen:\\n                self.DFS(nxt, current_group, seen, graph)\\n        return\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 435249,
                "title": "c-unitfind-easy-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int>parent;\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int len = accounts.size();\\n        parent.resize(len);\\n        vector<vector<string>> result;\\n        unordered_map<string, int> hashMap; //emial--index of row\\n        unordered_map<int, set<string>> graph; //index of row -- email list\\n\\n        for (int i = 0; i < len; ++i) parent[i] = i;\\n\\n        for (int i = 0; i < len; ++i) {\\n            for (int j = 1; j < accounts[i].size(); ++j) {\\n                if (hashMap.count(accounts[i][j]))\\n                    unit(i, hashMap[accounts[i][j]]);\\n                hashMap[accounts[i][j]] = find(i);\\n            }\\n        }\\n\\n        for (int i = 0; i < len; ++i) {\\n            graph[find(i)].insert(accounts[i].begin() + 1, accounts[i].end());\\n        }\\n        for (auto onePair : graph) {\\n            vector<string> oneResult;\\n            oneResult.push_back(accounts[onePair.first][0]);\\n            oneResult.insert(oneResult.end(), onePair.second.begin(), onePair.second.end());\\n            result.emplace_back(oneResult);\\n        }\\n        \\n        return result;\\n    }\\n\\nprivate:\\n    int find(int n) {\\n        return parent[n] == n ? n : find(parent[n]);\\n    }\\n\\n    void unit(int a, int b) {\\n        parent[find(a)] = find(b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int>parent;\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int len = accounts.size();\\n        parent.resize(len);\\n        vector<vector<string>> result;\\n        unordered_map<string, int> hashMap; //emial--index of row\\n        unordered_map<int, set<string>> graph; //index of row -- email list\\n\\n        for (int i = 0; i < len; ++i) parent[i] = i;\\n\\n        for (int i = 0; i < len; ++i) {\\n            for (int j = 1; j < accounts[i].size(); ++j) {\\n                if (hashMap.count(accounts[i][j]))\\n                    unit(i, hashMap[accounts[i][j]]);\\n                hashMap[accounts[i][j]] = find(i);\\n            }\\n        }\\n\\n        for (int i = 0; i < len; ++i) {\\n            graph[find(i)].insert(accounts[i].begin() + 1, accounts[i].end());\\n        }\\n        for (auto onePair : graph) {\\n            vector<string> oneResult;\\n            oneResult.push_back(accounts[onePair.first][0]);\\n            oneResult.insert(oneResult.end(), onePair.second.begin(), onePair.second.end());\\n            result.emplace_back(oneResult);\\n        }\\n        \\n        return result;\\n    }\\n\\nprivate:\\n    int find(int n) {\\n        return parent[n] == n ? n : find(parent[n]);\\n    }\\n\\n    void unit(int a, int b) {\\n        parent[find(a)] = find(b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385250,
                "title": "python-union-find",
                "content": "email -> name\\nemail -> index\\nindex union index\\ncombine all the email with the same index\\nadd name for every group\\n\\n\\n```\\nclass UnionFind():\\n    def __init__(self):\\n        self.parent = list(range(10001))\\n    def find(self,p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    def union(self,x,y):\\n        rx,ry = self.find(x),self.find(y)\\n        if rx != ry:\\n            self.parent[rx] = ry\\n\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        ans = []\\n        email2name = {}\\n        email2index = {}\\n        i = 0\\n        uf = UnionFind()\\n        for account in accounts:\\n            name = account[0]\\n            for email in account[1:]:\\n                if email not in email2index:\\n                    email2name[email] = name\\n                    email2index[email] = i\\n                    i += 1\\n                uf.union(email2index[account[1]],email2index[email])\\n        emailGroup = collections.defaultdict(list)\\n        for email in email2index:\\n            emailGroup[uf.find(email2index[email])].append(email)\\n        \\n        return [[email2name[emails[0]]] + sorted(emails) for emails in emailGroup.values()]\\n```",
                "solutionTags": [],
                "code": "```\\nclass UnionFind():\\n    def __init__(self):\\n        self.parent = list(range(10001))\\n    def find(self,p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    def union(self,x,y):\\n        rx,ry = self.find(x),self.find(y)\\n        if rx != ry:\\n            self.parent[rx] = ry\\n\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        ans = []\\n        email2name = {}\\n        email2index = {}\\n        i = 0\\n        uf = UnionFind()\\n        for account in accounts:\\n            name = account[0]\\n            for email in account[1:]:\\n                if email not in email2index:\\n                    email2name[email] = name\\n                    email2index[email] = i\\n                    i += 1\\n                uf.union(email2index[account[1]],email2index[email])\\n        emailGroup = collections.defaultdict(list)\\n        for email in email2index:\\n            emailGroup[uf.find(email2index[email])].append(email)\\n        \\n        return [[email2name[emails[0]]] + sorted(emails) for emails in emailGroup.values()]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213022,
                "title": "javascript-union-find-solution",
                "content": "```\\nvar accountsMerge = function(accounts) {\\n    \\n\\tconst root = {};\\n    const rank = {};\\n    const emailToName = {};\\n    \\n    function find(t) {\\n        if(root[t] !== t) {\\n            root[t] = find(root[t]);\\n        }\\n        return root[t];\\n    }\\n    \\n    function union(a,b) {\\n        const rootA = find(a);\\n        const rootB = find(b);\\n        if(rank[rootA] > rank[rootB]) {\\n            root[rootB] = rootA;\\n        } else if(rank[rootA] === rank[rootB]) {\\n            root[rootB] = rootA;\\n            rank[rootA] += 1;\\n        } else {\\n            root[rootA] = rootB;\\n        }\\n    }\\n    \\n    for(let acc of accounts) {\\n        const [name, ...emails] = acc;\\n        for(let email of emails) {\\n            root[email] = email;\\n            rank[email] = 0;\\n            emailToName[email] = name;\\n        }\\n    }\\n    \\n    for(let acc of accounts) {\\n        const [name, ...emails] = acc;\\n        for(let i = 1; i < emails.length; i++) {\\n            union(emails[0], emails[i]);\\n        }\\n    }\\n \\n    const placeholder = new Map();\\n    \\n    for(let r in root) {\\n        const parent = find(root[r]);\\n        if(placeholder.get(parent) === undefined) {\\n            placeholder.set(parent, []);\\n        } \\n        placeholder.get(parent).push(r);\\n    }\\n    \\n    const res = [];\\n    \\n    for(let r of placeholder.values()) {\\n        // use first email to map to the user name\\n        r.sort();\\n        res.push([emailToName[r[0]], ...r]);\\n    }\\n    \\n    return res;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar accountsMerge = function(accounts) {\\n    \\n\\tconst root = {};\\n    const rank = {};\\n    const emailToName = {};\\n    \\n    function find(t) {\\n        if(root[t] !== t) {\\n            root[t] = find(root[t]);\\n        }\\n        return root[t];\\n    }\\n    \\n    function union(a,b) {\\n        const rootA = find(a);\\n        const rootB = find(b);\\n        if(rank[rootA] > rank[rootB]) {\\n            root[rootB] = rootA;\\n        } else if(rank[rootA] === rank[rootB]) {\\n            root[rootB] = rootA;\\n            rank[rootA] += 1;\\n        } else {\\n            root[rootA] = rootB;\\n        }\\n    }\\n    \\n    for(let acc of accounts) {\\n        const [name, ...emails] = acc;\\n        for(let email of emails) {\\n            root[email] = email;\\n            rank[email] = 0;\\n            emailToName[email] = name;\\n        }\\n    }\\n    \\n    for(let acc of accounts) {\\n        const [name, ...emails] = acc;\\n        for(let i = 1; i < emails.length; i++) {\\n            union(emails[0], emails[i]);\\n        }\\n    }\\n \\n    const placeholder = new Map();\\n    \\n    for(let r in root) {\\n        const parent = find(root[r]);\\n        if(placeholder.get(parent) === undefined) {\\n            placeholder.set(parent, []);\\n        } \\n        placeholder.get(parent).push(r);\\n    }\\n    \\n    const res = [];\\n    \\n    for(let r of placeholder.values()) {\\n        // use first email to map to the user name\\n        r.sort();\\n        res.push([emailToName[r[0]], ...r]);\\n    }\\n    \\n    return res;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 176771,
                "title": "python-solution",
                "content": "DFS: \\n```\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        neighbor_dic = collections.defaultdict(set)\\n        name_dic = {}\\n        for lst in accounts:\\n            name = lst[0]\\n            for email in lst[1:]:\\n                neighbor_dic[email].add(lst[1])\\n                neighbor_dic[lst[1]].add(email)\\n                name_dic[email] = name\\n                   \\n        res = []\\n        seen = set()\\n        for key in neighbor_dic.keys():\\n            if key not in seen:\\n                seen.add(key)\\n                stack = [key]\\n                tmp = [key]\\n                while stack:\\n                    u = stack.pop()\\n                    for n in neighbor_dic[u]:\\n                        if n not in seen:\\n                            seen.add(n)\\n                            tmp.append(n)\\n                            stack.append(n)\\n                res.append([name_dic[key]]+sorted(tmp))\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        neighbor_dic = collections.defaultdict(set)\\n        name_dic = {}\\n        for lst in accounts:\\n            name = lst[0]\\n            for email in lst[1:]:\\n                neighbor_dic[email].add(lst[1])\\n                neighbor_dic[lst[1]].add(email)\\n                name_dic[email] = name\\n                   \\n        res = []\\n        seen = set()\\n        for key in neighbor_dic.keys():\\n            if key not in seen:\\n                seen.add(key)\\n                stack = [key]\\n                tmp = [key]\\n                while stack:\\n                    u = stack.pop()\\n                    for n in neighbor_dic[u]:\\n                        if n not in seen:\\n                            seen.add(n)\\n                            tmp.append(n)\\n                            stack.append(n)\\n                res.append([name_dic[key]]+sorted(tmp))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166167,
                "title": "python-union-find",
                "content": "```\\nclass Solution(object):  \\n    def init(self, accounts):\\n        self.parents = {}\\n        self.owner = {}\\n        for acc in accounts:\\n            self.owner[acc[1]] = acc[0]\\n            for email in acc[1:]:\\n                # not in parents, add it directly to parents\\n                if email not in self.parents:\\n                    self.parents[email] = acc[1]\\n                # union the old parent with the new parent\\n                else:\\n                    self.union(acc[1], self.parents[email])\\n    \\n    def find(self, x):\\n        if self.parents[x] == x:\\n            return x\\n        \\n        self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        px = self.find(x)\\n        py = self.find(y)\\n        self.parents[py] = px\\n        \\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        self.init(accounts)\\n        for acc in accounts:\\n            for email in acc[1:]:\\n                self.find(email)\\n                \\n        groups = list(set(self.parents.values()))\\n        ret = []\\n        for j in range(len(groups)):\\n            tmp = []\\n            for key in self.parents:\\n                if self.parents[key] == groups[j]:\\n                    tmp.append(key)\\n            tmp = sorted(tmp)\\n            tmp.insert(0, self.owner[groups[j]])\\n            ret.append(tmp)\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):  \\n    def init(self, accounts):\\n        self.parents = {}\\n        self.owner = {}\\n        for acc in accounts:\\n            self.owner[acc[1]] = acc[0]\\n            for email in acc[1:]:\\n                # not in parents, add it directly to parents\\n                if email not in self.parents:\\n                    self.parents[email] = acc[1]\\n                # union the old parent with the new parent\\n                else:\\n                    self.union(acc[1], self.parents[email])\\n    \\n    def find(self, x):\\n        if self.parents[x] == x:\\n            return x\\n        \\n        self.parents[x] = self.find(self.parents[x])\\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        px = self.find(x)\\n        py = self.find(y)\\n        self.parents[py] = px\\n        \\n    def accountsMerge(self, accounts):\\n        \"\"\"\\n        :type accounts: List[List[str]]\\n        :rtype: List[List[str]]\\n        \"\"\"\\n        self.init(accounts)\\n        for acc in accounts:\\n            for email in acc[1:]:\\n                self.find(email)\\n                \\n        groups = list(set(self.parents.values()))\\n        ret = []\\n        for j in range(len(groups)):\\n            tmp = []\\n            for key in self.parents:\\n                if self.parents[key] == groups[j]:\\n                    tmp.append(key)\\n            tmp = sorted(tmp)\\n            tmp.insert(0, self.owner[groups[j]])\\n            ret.append(tmp)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164699,
                "title": "c-solution-union-find-beats-91-49",
                "content": "n = length of all email addresses\\nTime: O(nlogn) because of Union Find & List<>.Sort()\\nSpace: O(n)\\n```\\npublic class Solution {\\n    private int findParent(int i, int[] accP){\\n        if(accP[i]!=i) accP[i] = findParent(accP[i], accP);\\n        return accP[i];\\n    }\\n    private void union(int i, int j, int[] accP, int[] accCnt){\\n        int iP = findParent(i, accP);\\n        int jP = findParent(j, accP);\\n        if(iP!=jP){\\n            if(accCnt[iP]>=accCnt[jP]){\\n                accP[jP] = iP;\\n                accCnt[iP] += accCnt[jP];\\n                accCnt[jP] = 0;\\n            }else{\\n                accP[iP] = jP;\\n                accCnt[jP] += accCnt[iP];\\n                accCnt[iP] = 0;\\n            }\\n        }\\n    }\\n    public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts) {\\n        Dictionary<string,int> dic = new Dictionary<string,int>();\\n        string[] acc = new string[accounts.Count];\\n        int[] accCnt = new int[accounts.Count];\\n        int[] accP = new int[accounts.Count];\\n        int mergeCnt = 0;\\n        for(int i=0; i<accounts.Count; i++){\\n            acc[i] = accounts[i][0];\\n            accCnt[i] = accounts[i].Count-1;\\n            accP[i] = i;\\n            int accI = i;\\n            for(int j=1; j<accounts[i].Count; j++){\\n                if(dic.ContainsKey(accounts[i][j])){\\n                    union(dic[accounts[i][j]], accI, accP, accCnt);\\n                }else dic.Add(accounts[i][j], accI);\\n            }\\n        }\\n        int[] accMap = new int[acc.Length];\\n        int mapCnt = 0;\\n        IList<IList<string>> ansList = new List<IList<string>>();\\n        for(int i=0; i<accCnt.Length; i++){\\n            if(accCnt[i]>0){\\n                accMap[i] = mapCnt;\\n                ansList.Add(new List<string>());\\n                ansList[mapCnt].Add(acc[i]);\\n                mapCnt++;\\n            }\\n        }\\n        foreach(var kv in dic) ansList[accMap[findParent(kv.Value,accP)]].Add(kv.Key);\\n        for(int i=0; i<ansList.Count; i++){\\n            List<string> list = (List<string>)ansList[i];\\n            list.Sort(1, ansList[i].Count-1, StringComparer.Ordinal);\\n            ansList[i] = list;\\n        }        \\n        return ansList;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private int findParent(int i, int[] accP){\\n        if(accP[i]!=i) accP[i] = findParent(accP[i], accP);\\n        return accP[i];\\n    }\\n    private void union(int i, int j, int[] accP, int[] accCnt){\\n        int iP = findParent(i, accP);\\n        int jP = findParent(j, accP);\\n        if(iP!=jP){\\n            if(accCnt[iP]>=accCnt[jP]){\\n                accP[jP] = iP;\\n                accCnt[iP] += accCnt[jP];\\n                accCnt[jP] = 0;\\n            }else{\\n                accP[iP] = jP;\\n                accCnt[jP] += accCnt[iP];\\n                accCnt[iP] = 0;\\n            }\\n        }\\n    }\\n    public IList<IList<string>> AccountsMerge(IList<IList<string>> accounts) {\\n        Dictionary<string,int> dic = new Dictionary<string,int>();\\n        string[] acc = new string[accounts.Count];\\n        int[] accCnt = new int[accounts.Count];\\n        int[] accP = new int[accounts.Count];\\n        int mergeCnt = 0;\\n        for(int i=0; i<accounts.Count; i++){\\n            acc[i] = accounts[i][0];\\n            accCnt[i] = accounts[i].Count-1;\\n            accP[i] = i;\\n            int accI = i;\\n            for(int j=1; j<accounts[i].Count; j++){\\n                if(dic.ContainsKey(accounts[i][j])){\\n                    union(dic[accounts[i][j]], accI, accP, accCnt);\\n                }else dic.Add(accounts[i][j], accI);\\n            }\\n        }\\n        int[] accMap = new int[acc.Length];\\n        int mapCnt = 0;\\n        IList<IList<string>> ansList = new List<IList<string>>();\\n        for(int i=0; i<accCnt.Length; i++){\\n            if(accCnt[i]>0){\\n                accMap[i] = mapCnt;\\n                ansList.Add(new List<string>());\\n                ansList[mapCnt].Add(acc[i]);\\n                mapCnt++;\\n            }\\n        }\\n        foreach(var kv in dic) ansList[accMap[findParent(kv.Value,accP)]].Add(kv.Key);\\n        for(int i=0; i<ansList.Count; i++){\\n            List<string> list = (List<string>)ansList[i];\\n            list.Sort(1, ansList[i].Count-1, StringComparer.Ordinal);\\n            ansList[i] = list;\\n        }        \\n        return ansList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 143255,
                "title": "another-c-union-find",
                "content": "We know it can be solved by union-find at first glance. But the actual implementation needs careful thought. Here, I insert a number as a string which represent the root {representative} to each group. In each iteration, If the root of this email has been set, then do the union operation, otherwise use the row number as the root.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        \\n        unordered_map<string, string> root;\\n        \\n        for (int i = 0; i < accounts.size(); i++) {\\n            root[to_string(i)] = to_string(i);\\n            for (int j = 1; j < accounts[i].size(); j++) {\\n                if (root.count(accounts[i][j]) == 0) {\\n                    root[accounts[i][j]] = to_string(i);\\n                } else {\\n                    string p = find(root, accounts[i][j]);\\n                    root[p] = to_string(i);\\n                }\\n            }\\n        }\\n        \\n        map<int, set<string>> r;\\n        for (int i = 0; i < accounts.size(); i++) {\\n            for (int j = 1; j < accounts[i].size(); j++) {\\n                string p = find(root, accounts[i][j]);\\n                r[stoi(p)].insert(accounts[i][j]);\\n            }\\n        }\\n        vector<vector<string>> res;\\n        for (auto e : r) {\\n            vector<string> v = {accounts[e.first][0]};\\n            v.insert(v.end(), e.second.begin(), e.second.end());\\n            res.push_back(v);\\n        }\\n        return res;\\n    }\\n    \\n    string find(unordered_map<string, string>& root, string i) {\\n        if (root[i] == i) return i;\\n        string p = find(root, root[i]);\\n        return root[i] = p;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        \\n        unordered_map<string, string> root;\\n        \\n        for (int i = 0; i < accounts.size(); i++) {\\n            root[to_string(i)] = to_string(i);\\n            for (int j = 1; j < accounts[i].size(); j++) {\\n                if (root.count(accounts[i][j]) == 0) {\\n                    root[accounts[i][j]] = to_string(i);\\n                } else {\\n                    string p = find(root, accounts[i][j]);\\n                    root[p] = to_string(i);\\n                }\\n            }\\n        }\\n        \\n        map<int, set<string>> r;\\n        for (int i = 0; i < accounts.size(); i++) {\\n            for (int j = 1; j < accounts[i].size(); j++) {\\n                string p = find(root, accounts[i][j]);\\n                r[stoi(p)].insert(accounts[i][j]);\\n            }\\n        }\\n        vector<vector<string>> res;\\n        for (auto e : r) {\\n            vector<string> v = {accounts[e.first][0]};\\n            v.insert(v.end(), e.second.begin(), e.second.end());\\n            res.push_back(v);\\n        }\\n        return res;\\n    }\\n    \\n    string find(unordered_map<string, string>& root, string i) {\\n        if (root[i] == i) return i;\\n        string p = find(root, root[i]);\\n        return root[i] = p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 112723,
                "title": "my-easy-java-solution-using-dfs-iterative",
                "content": "```\\nclass Solution {\\n    Map<String,List<Integer>> map;\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        List<List<String>> res = new ArrayList<>();\\n        \\n        int sz = accounts.size();\\n        map = new HashMap<>();\\n        boolean[] visited = new boolean[sz];\\n        for(int i=0;i<sz;i++){\\n            List<String> curr = accounts.get(i);\\n            for(int j=1;j<curr.size();j++){\\n                String email = curr.get(j);\\n                List<Integer> list;\\n                if(!map.containsKey(email)){\\n                    map.put(email,new ArrayList<>());\\n                }\\n                list = map.get(email);\\n                list.add(i);\\n            }\\n        }\\n        for(int i=0;i<sz;i++){\\n            if(visited[i])\\n                continue;\\n            String name = accounts.get(i).get(0);\\n            Set<String> mergedList = new HashSet<>();\\n            Stack<Integer> st = new Stack<>();\\n            st.push(i);\\n            while(!st.isEmpty()){\\n                int index = st.pop();\\n                if(visited[index])\\n                    continue;\\n                visited[index] = true;\\n                List<String> curr = accounts.get(index);\\n                for(int j=1;j<curr.size();j++){\\n                    String email = curr.get(j);\\n                    List<Integer> list = map.get(email);\\n                    mergedList.add(email);\\n                    for(int k:list){\\n                        if(!visited[k]){\\n                            st.push(k);\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n            List<String> newList = new ArrayList<>(mergedList);\\n            Collections.sort(newList);\\n            newList.add(0,name);\\n            res.add(newList);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<String,List<Integer>> map;\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        List<List<String>> res = new ArrayList<>();\\n        \\n        int sz = accounts.size();\\n        map = new HashMap<>();\\n        boolean[] visited = new boolean[sz];\\n        for(int i=0;i<sz;i++){\\n            List<String> curr = accounts.get(i);\\n            for(int j=1;j<curr.size();j++){\\n                String email = curr.get(j);\\n                List<Integer> list;\\n                if(!map.containsKey(email)){\\n                    map.put(email,new ArrayList<>());\\n                }\\n                list = map.get(email);\\n                list.add(i);\\n            }\\n        }\\n        for(int i=0;i<sz;i++){\\n            if(visited[i])\\n                continue;\\n            String name = accounts.get(i).get(0);\\n            Set<String> mergedList = new HashSet<>();\\n            Stack<Integer> st = new Stack<>();\\n            st.push(i);\\n            while(!st.isEmpty()){\\n                int index = st.pop();\\n                if(visited[index])\\n                    continue;\\n                visited[index] = true;\\n                List<String> curr = accounts.get(index);\\n                for(int j=1;j<curr.size();j++){\\n                    String email = curr.get(j);\\n                    List<Integer> list = map.get(email);\\n                    mergedList.add(email);\\n                    for(int k:list){\\n                        if(!visited[k]){\\n                            st.push(k);\\n                        }\\n                        \\n                    }\\n                }\\n            }\\n            List<String> newList = new ArrayList<>(mergedList);\\n            Collections.sort(newList);\\n            newList.add(0,name);\\n            res.add(newList);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039763,
                "title": "java-fastest-solution-disjoint-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n * k * log(k))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n * k)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/a8f2d4ae-02e9-4a2e-9ce7-12de6bdf29ee_1694608301.5841887.png)\\n\\n\\n# Code\\n```\\nclass DisjointSet {\\n    List<Integer> rank = new ArrayList<>();\\n    List<Integer> parent = new ArrayList<>();\\n    List<Integer> size = new ArrayList<>();\\n\\n    // Constructor to initialize the DisjointSet with \\'n\\' elements\\n    public DisjointSet(int n) {\\n        for (int i = 0; i <= n; i++) {\\n            rank.add(0); // Initialize the rank of each element to 0\\n            parent.add(i); // Initialize the parent of each element to itself\\n            size.add(1); // Initialize the size of each set to 1\\n        }\\n    }\\n\\n    // Find the ultimate parent of a node with path compression\\n    public int findUPar(int node) {\\n        if (node == parent.get(node)) {\\n            return node; // If the node is its own parent, it\\'s the ultimate parent\\n        }\\n        int ulp = findUPar(parent.get(node)); // Recursively find the ultimate parent\\n        parent.set(node, ulp); // Path compression: Update the parent to the ultimate parent\\n        return parent.get(node); // Return the ultimate parent\\n    }\\n\\n    // Union two sets by size\\n    public void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); // Find the ultimate parent of set containing \\'u\\'\\n        int ulp_v = findUPar(v); // Find the ultimate parent of set containing \\'v\\'\\n        if (ulp_u == ulp_v) return; // If both sets already have the same parent, do nothing\\n        if (size.get(ulp_u) < size.get(ulp_v)) {\\n            // Attach the smaller set (ulp_u) to the larger set (ulp_v)\\n            parent.set(ulp_u, ulp_v);\\n            size.set(ulp_v, size.get(ulp_v) + size.get(ulp_u)); // Update the size of ulp_v\\n        } else {\\n            // Attach the smaller set (ulp_v) to the larger set (ulp_u)\\n            parent.set(ulp_v, ulp_u);\\n            size.set(ulp_u, size.get(ulp_u) + size.get(ulp_v)); // Update the size of ulp_u\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    static List<List<String>> accountsMerge(List<List<String>> details) {\\n        int n = details.size();\\n        DisjointSet ds = new DisjointSet(n);\\n        HashMap<String, Integer> mapMailNode = new HashMap<String, Integer>();\\n\\n        // Traverse the input \\'details\\' list to build the DisjointSet and map mail to node\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < details.get(i).size(); j++) {\\n                String mail = details.get(i).get(j);\\n                if (!mapMailNode.containsKey(mail)) {\\n                    mapMailNode.put(mail, i);\\n                } else {\\n                    ds.unionBySize(i, mapMailNode.get(mail));\\n                }\\n            }\\n        }\\n\\n        ArrayList<String>[] mergedMail = new ArrayList[n];\\n        for (int i = 0; i < n; i++) mergedMail[i] = new ArrayList<String>();\\n\\n        // Build a list of merged mail for each node\\n        for (Map.Entry<String, Integer> it : mapMailNode.entrySet()) {\\n            String mail = it.getKey();\\n            int node = ds.findUPar(it.getValue());\\n            mergedMail[node].add(mail);\\n        }\\n\\n        List<List<String>> ans = new ArrayList<>();\\n\\n        // Construct the final merged accounts list\\n        for (int i = 0; i < n; i++) {\\n            if (mergedMail[i].size() == 0) continue;\\n            Collections.sort(mergedMail[i]); // Sort the merged mail list\\n            List<String> temp = new ArrayList<>();\\n            temp.add(details.get(i).get(0)); // Add the name of the account\\n            temp.addAll(mergedMail[i]); // Add the sorted mail addresses\\n            ans.add(temp); // Add the account to the final answer\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Depth-First Search",
                    "Union Find",
                    "Sorting"
                ],
                "code": "```\\nclass DisjointSet {\\n    List<Integer> rank = new ArrayList<>();\\n    List<Integer> parent = new ArrayList<>();\\n    List<Integer> size = new ArrayList<>();\\n\\n    // Constructor to initialize the DisjointSet with \\'n\\' elements\\n    public DisjointSet(int n) {\\n        for (int i = 0; i <= n; i++) {\\n            rank.add(0); // Initialize the rank of each element to 0\\n            parent.add(i); // Initialize the parent of each element to itself\\n            size.add(1); // Initialize the size of each set to 1\\n        }\\n    }\\n\\n    // Find the ultimate parent of a node with path compression\\n    public int findUPar(int node) {\\n        if (node == parent.get(node)) {\\n            return node; // If the node is its own parent, it\\'s the ultimate parent\\n        }\\n        int ulp = findUPar(parent.get(node)); // Recursively find the ultimate parent\\n        parent.set(node, ulp); // Path compression: Update the parent to the ultimate parent\\n        return parent.get(node); // Return the ultimate parent\\n    }\\n\\n    // Union two sets by size\\n    public void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u); // Find the ultimate parent of set containing \\'u\\'\\n        int ulp_v = findUPar(v); // Find the ultimate parent of set containing \\'v\\'\\n        if (ulp_u == ulp_v) return; // If both sets already have the same parent, do nothing\\n        if (size.get(ulp_u) < size.get(ulp_v)) {\\n            // Attach the smaller set (ulp_u) to the larger set (ulp_v)\\n            parent.set(ulp_u, ulp_v);\\n            size.set(ulp_v, size.get(ulp_v) + size.get(ulp_u)); // Update the size of ulp_v\\n        } else {\\n            // Attach the smaller set (ulp_v) to the larger set (ulp_u)\\n            parent.set(ulp_v, ulp_u);\\n            size.set(ulp_u, size.get(ulp_u) + size.get(ulp_v)); // Update the size of ulp_u\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    static List<List<String>> accountsMerge(List<List<String>> details) {\\n        int n = details.size();\\n        DisjointSet ds = new DisjointSet(n);\\n        HashMap<String, Integer> mapMailNode = new HashMap<String, Integer>();\\n\\n        // Traverse the input \\'details\\' list to build the DisjointSet and map mail to node\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 1; j < details.get(i).size(); j++) {\\n                String mail = details.get(i).get(j);\\n                if (!mapMailNode.containsKey(mail)) {\\n                    mapMailNode.put(mail, i);\\n                } else {\\n                    ds.unionBySize(i, mapMailNode.get(mail));\\n                }\\n            }\\n        }\\n\\n        ArrayList<String>[] mergedMail = new ArrayList[n];\\n        for (int i = 0; i < n; i++) mergedMail[i] = new ArrayList<String>();\\n\\n        // Build a list of merged mail for each node\\n        for (Map.Entry<String, Integer> it : mapMailNode.entrySet()) {\\n            String mail = it.getKey();\\n            int node = ds.findUPar(it.getValue());\\n            mergedMail[node].add(mail);\\n        }\\n\\n        List<List<String>> ans = new ArrayList<>();\\n\\n        // Construct the final merged accounts list\\n        for (int i = 0; i < n; i++) {\\n            if (mergedMail[i].size() == 0) continue;\\n            Collections.sort(mergedMail[i]); // Sort the merged mail list\\n            List<String> temp = new ArrayList<>();\\n            temp.add(details.get(i).get(0)); // Add the name of the account\\n            temp.addAll(mergedMail[i]); // Add the sorted mail addresses\\n            ans.add(temp); // Add the account to the final answer\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022342,
                "title": "c-union-find-with-explanation",
                "content": "It is evident by reading the question that disjoint set would be applied. But the work lies in applying it. \\n\\nAlgo :-\\n1. Create a map which holds relationship between the mail id and the Name. Here name is represented with an   integer value. The name for the first entry is conisdered as 0 and for second entry 1 and so on. \\n2.  If any mail exists in the map previously, we merge(union) these 2 numeric value which represents the set for the names and mails. \\nFor eg:\\n [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\\n\\nHere johnsmith@mail.com is already present in the map as entry {johnsmith@mail.com,0}, as it is already present we perform union operation on 0 and 1. This represents that the entry of mails in the 1st vector belongs to the same person as the first. \\n\\n3. Now we create another map which arranges all the maills with their respective person(here it will be represented with the numeric value).\\n\\n4. Now we create a 2d vector. We put in the name first and then all the mails belonging to that name from this map.\\n\\n```\\nclass Solution {\\n    \\n    vector<int>parents,rank;\\n    int findParent(int a)\\n    {\\n        if(parents[a]==a)return a;\\n        return  parents[a]=findParent(parents[a]);\\n    }\\n    \\n    void unionF(int a, int b)\\n    {\\n        int ulp_a=findParent(a);\\n        int ulp_b=findParent(b);\\n        if(ulp_a==ulp_b)return ;\\n        if(rank[ulp_a]<rank[ulp_b])\\n        {\\n            parents[a]=b;\\n        }\\n        else if(rank[ulp_a]>rank[ulp_b])\\n        {\\n            parents[ulp_b]=a;\\n        }\\n        else{\\n            parents[ulp_a]=b;\\n            rank[ulp_a]++;\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n=accounts.size();\\n        parents.resize(n,0);\\n        rank.resize(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            parents[i]=i;\\n        }\\n        \\n      \\n        map<string,int>mp;\\n        int i=0;\\n        for(auto it:accounts)\\n        {\\n            int m=it.size();\\n            for(int j=1;j<m;j++)\\n            {\\n                if(mp.find(it[j])==mp.end())\\n                {\\n                    mp[it[j]]=i;\\n                }\\n                else{\\n                    unionF(i,mp[it[j]]);\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        // for(auto it:mp)\\n        // {\\n        //     cout<<it.first<<\" \"<<it.second<<endl;\\n        // }\\n        \\n        \\n        // for(auto it:parents)\\n        // {\\n        //     cout<<it<<\" \";\\n        // }\\n        // cout<<endl;\\n        \\n        map<int,vector<string>>mp2;\\n        for(auto it:mp)\\n        {\\n            int p=findParent(it.second);\\n            \\n            mp2[p].push_back(it.first);\\n            \\n        }\\n        \\n        // for(auto it:mp2)\\n        // {\\n        //     cout<<it.first<<endl;\\n        //     for(auto i:it.second)\\n        //     {\\n        //         cout<<i<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        int k=mp2.size();\\n        vector<vector<string>>ans(k);\\n        int l=0;\\n        for(auto it:mp2)\\n        {\\n            //cout<<accounts[it.first][0];\\n            ans[l].push_back(accounts[it.first][0]);\\n            for(auto i:it.second)\\n            {\\n                //cout<<\"yes\"<<endl;\\n                ans[l].push_back(i);\\n            }\\n            l++;\\n        }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    \\n    vector<int>parents,rank;\\n    int findParent(int a)\\n    {\\n        if(parents[a]==a)return a;\\n        return  parents[a]=findParent(parents[a]);\\n    }\\n    \\n    void unionF(int a, int b)\\n    {\\n        int ulp_a=findParent(a);\\n        int ulp_b=findParent(b);\\n        if(ulp_a==ulp_b)return ;\\n        if(rank[ulp_a]<rank[ulp_b])\\n        {\\n            parents[a]=b;\\n        }\\n        else if(rank[ulp_a]>rank[ulp_b])\\n        {\\n            parents[ulp_b]=a;\\n        }\\n        else{\\n            parents[ulp_a]=b;\\n            rank[ulp_a]++;\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        int n=accounts.size();\\n        parents.resize(n,0);\\n        rank.resize(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            parents[i]=i;\\n        }\\n        \\n      \\n        map<string,int>mp;\\n        int i=0;\\n        for(auto it:accounts)\\n        {\\n            int m=it.size();\\n            for(int j=1;j<m;j++)\\n            {\\n                if(mp.find(it[j])==mp.end())\\n                {\\n                    mp[it[j]]=i;\\n                }\\n                else{\\n                    unionF(i,mp[it[j]]);\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        // for(auto it:mp)\\n        // {\\n        //     cout<<it.first<<\" \"<<it.second<<endl;\\n        // }\\n        \\n        \\n        // for(auto it:parents)\\n        // {\\n        //     cout<<it<<\" \";\\n        // }\\n        // cout<<endl;\\n        \\n        map<int,vector<string>>mp2;\\n        for(auto it:mp)\\n        {\\n            int p=findParent(it.second);\\n            \\n            mp2[p].push_back(it.first);\\n            \\n        }\\n        \\n        // for(auto it:mp2)\\n        // {\\n        //     cout<<it.first<<endl;\\n        //     for(auto i:it.second)\\n        //     {\\n        //         cout<<i<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        \\n        int k=mp2.size();\\n        vector<vector<string>>ans(k);\\n        int l=0;\\n        for(auto it:mp2)\\n        {\\n            //cout<<accounts[it.first][0];\\n            ans[l].push_back(accounts[it.first][0]);\\n            for(auto i:it.second)\\n            {\\n                //cout<<\"yes\"<<endl;\\n                ans[l].push_back(i);\\n            }\\n            l++;\\n        }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3909195,
                "title": "python3-solution-using-union-find-disjoint-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen there are many sets (accounts in this problem) but some of them are connected, you might use disjoint set(also called union find) to get the number of seperated sets.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe basic idea of disjoint set is simple and straightforward, using array p to reprent all the sets, to be specfic, i means the index of the set, p[i] means set i\\'s parent set.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def parent(i):\\n            root = i\\n            while root != p[root]:\\n                root = p[root]\\n            while root != p[i]:\\n                temp = p[i]\\n                p[i] = root\\n                i = temp\\n            return root\\n\\n        def connect(i, j):\\n            pi, pj = parent(i), parent(j)\\n            p[pi] = pj\\n\\n        p, email2Id, id2Email = [i for i in range(len(accounts))], {}, collections.defaultdict(set)\\n        for id, account in enumerate(accounts):\\n            for email in account[1:]:\\n                if email not in email2Id: email2Id[email] = id\\n                else: connect(email2Id[email], id)\\n        for id, account in enumerate(accounts):\\n            pi = parent(id)\\n            for email in account[1:]:\\n                id2Email[pi].add(email)\\n        return [[accounts[id][0]] + sorted(emails) for id, emails in id2Email.items()]\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def parent(i):\\n            root = i\\n            while root != p[root]:\\n                root = p[root]\\n            while root != p[i]:\\n                temp = p[i]\\n                p[i] = root\\n                i = temp\\n            return root\\n\\n        def connect(i, j):\\n            pi, pj = parent(i), parent(j)\\n            p[pi] = pj\\n\\n        p, email2Id, id2Email = [i for i in range(len(accounts))], {}, collections.defaultdict(set)\\n        for id, account in enumerate(accounts):\\n            for email in account[1:]:\\n                if email not in email2Id: email2Id[email] = id\\n                else: connect(email2Id[email], id)\\n        for id, account in enumerate(accounts):\\n            pi = parent(id)\\n            for email in account[1:]:\\n                id2Email[pi].add(email)\\n        return [[accounts[id][0]] + sorted(emails) for id, emails in id2Email.items()]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876909,
                "title": "c-union-find-map-super-intuitive-explained",
                "content": "1. ```par``` stores the parent string of a string. This will help us in forming a group of strings (emails) belonging to the same user.\\n2. ```sz``` is the size of a group of strings (emails which belong to a specific user).\\n3. ```accounts[x][0]``` is the username of a user whose duplicate emails belong to a string with ```name[parentString]=x```\\n4. First we initialize all the strings as we do in a union find program. Note that since we are storing the strings in a map, there won\\'t be duplicate strings and so each string maps to a single user.\\n5. Next, we join all the strings belonging to an account. This \\n\\ta. Forms a group of strings of the same account\\n\\tb. Merges another group if some string (email) is common between them.\\n6. Now we know the parent string of each string, we\\'ll group together these strings in another map, with parent string as the key.\\n7. Using ```name```, we\\'ll add all the strings of the group to the username.\\n```\\nclass Solution {\\npublic:\\n    map<string,string> par;\\n    map<string,int> name;\\n    map<string,long long> sz;\\n    string findPar(string s){\\n        if(par[s]==s){ return s; }\\n        return par[s]=findPar(par[s]);\\n    }\\n    void merge(string s1, string s2){\\n        s1=findPar(s1), s2=findPar(s2);\\n        if(s1==s2){ return; }\\n        if(sz[s1]<sz[s2]){ swap(s1,s2); }\\n        par[s2]=s1; \\n        sz[s1]+=sz[s2];\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        vector<vector<string>> ans;\\n        for(int j=0; j<accounts.size(); j++){\\n            vector<string> a=accounts[j];\\n            for(int i=1; i<a.size(); i++){\\n                par[a[i]]=a[i]; \\n                sz[a[i]]=1;\\n                name[a[i]]=j;\\n            }\\n        }\\n        for(auto &a:accounts){\\n            for(int i=2; i<a.size(); i++){\\n                merge(a[i],a[i-1]);\\n            }\\n        }\\n        map<string,vector<string>> accs;\\n        for(auto &[s,p]:par){ accs[findPar(p)].push_back(s); }\\n        for(auto &[parentString,it]:accs){\\n            vector<string> tmp={accounts[name[parentString]][0]};\\n            for(auto &i:it){ tmp.push_back(i); }\\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```par```\n```sz```\n```accounts[x][0]```\n```name[parentString]=x```\n```name```\n```\\nclass Solution {\\npublic:\\n    map<string,string> par;\\n    map<string,int> name;\\n    map<string,long long> sz;\\n    string findPar(string s){\\n        if(par[s]==s){ return s; }\\n        return par[s]=findPar(par[s]);\\n    }\\n    void merge(string s1, string s2){\\n        s1=findPar(s1), s2=findPar(s2);\\n        if(s1==s2){ return; }\\n        if(sz[s1]<sz[s2]){ swap(s1,s2); }\\n        par[s2]=s1; \\n        sz[s1]+=sz[s2];\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        vector<vector<string>> ans;\\n        for(int j=0; j<accounts.size(); j++){\\n            vector<string> a=accounts[j];\\n            for(int i=1; i<a.size(); i++){\\n                par[a[i]]=a[i]; \\n                sz[a[i]]=1;\\n                name[a[i]]=j;\\n            }\\n        }\\n        for(auto &a:accounts){\\n            for(int i=2; i<a.size(); i++){\\n                merge(a[i],a[i-1]);\\n            }\\n        }\\n        map<string,vector<string>> accs;\\n        for(auto &[s,p]:par){ accs[findPar(p)].push_back(s); }\\n        for(auto &[parentString,it]:accs){\\n            vector<string> tmp={accounts[name[parentString]][0]};\\n            for(auto &i:it){ tmp.push_back(i); }\\n            ans.push_back(tmp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819973,
                "title": "union-by-size-beats-99",
                "content": "```\\nclass DisjointSet {\\n    ArrayList<Integer> parent = new ArrayList<>();\\n    ArrayList<Integer> size = new ArrayList<>();\\n    \\n    DisjointSet(int n) {\\n        for (int i = 0; i <= n; i++) {\\n            parent.add(i);\\n            size.add(1);\\n        }\\n    }\\n    \\n    int findUParent(int node) {\\n        if (node == parent.get(node)) return node;\\n        int ulp = findUParent(parent.get(node));\\n        parent.set(node, ulp);\\n        return parent.get(node);\\n    }\\n    \\n    void unionBySize(int u, int v) {\\n        int ulpU = findUParent(u), ulpV = findUParent(v);\\n        if (ulpU == ulpV) return;\\n        if (size.get(ulpU) < size.get(ulpV)) {\\n            parent.set(ulpU, ulpV);\\n            size.set(ulpV, size.get(ulpU) + size.get(ulpV));\\n        } else {\\n            parent.set(ulpV, ulpU);\\n            size.set(ulpU, size.get(ulpU) + size.get(ulpV));\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        int len = accounts.size();\\n        DisjointSet ds = new DisjointSet(len);\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            int ilen = accounts.get(i).size();\\n            for (int j = 1; j < ilen; j++) {\\n                String tmp = accounts.get(i).get(j);\\n                if (!map.containsKey(tmp)) map.put(tmp, i);\\n                else ds.unionBySize(i, map.get(tmp));\\n            }\\n        }\\n        ArrayList<String>[] tmp = new ArrayList[len];\\n        for (int i = 0; i < len; i++) tmp[i] = new ArrayList<String>();\\n        for (Map.Entry<String, Integer> it : map.entrySet()) {\\n            String mail = it.getKey();\\n            int node = ds.findUParent(it.getValue());\\n            tmp[node].add(mail);\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        for (int i = 0; i < len; i++) {\\n            if (tmp[i].size() == 0) continue;\\n            ArrayList<String> txp = new ArrayList<>();\\n            txp.add(accounts.get(i).get(0));\\n            Collections.sort(tmp[i]);\\n            for (String s : tmp[i]) txp.add(s);\\n            res.add(txp);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DisjointSet {\\n    ArrayList<Integer> parent = new ArrayList<>();\\n    ArrayList<Integer> size = new ArrayList<>();\\n    \\n    DisjointSet(int n) {\\n        for (int i = 0; i <= n; i++) {\\n            parent.add(i);\\n            size.add(1);\\n        }\\n    }\\n    \\n    int findUParent(int node) {\\n        if (node == parent.get(node)) return node;\\n        int ulp = findUParent(parent.get(node));\\n        parent.set(node, ulp);\\n        return parent.get(node);\\n    }\\n    \\n    void unionBySize(int u, int v) {\\n        int ulpU = findUParent(u), ulpV = findUParent(v);\\n        if (ulpU == ulpV) return;\\n        if (size.get(ulpU) < size.get(ulpV)) {\\n            parent.set(ulpU, ulpV);\\n            size.set(ulpV, size.get(ulpU) + size.get(ulpV));\\n        } else {\\n            parent.set(ulpV, ulpU);\\n            size.set(ulpU, size.get(ulpU) + size.get(ulpV));\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public List<List<String>> accountsMerge(List<List<String>> accounts) {\\n        int len = accounts.size();\\n        DisjointSet ds = new DisjointSet(len);\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for (int i = 0; i < len; i++) {\\n            int ilen = accounts.get(i).size();\\n            for (int j = 1; j < ilen; j++) {\\n                String tmp = accounts.get(i).get(j);\\n                if (!map.containsKey(tmp)) map.put(tmp, i);\\n                else ds.unionBySize(i, map.get(tmp));\\n            }\\n        }\\n        ArrayList<String>[] tmp = new ArrayList[len];\\n        for (int i = 0; i < len; i++) tmp[i] = new ArrayList<String>();\\n        for (Map.Entry<String, Integer> it : map.entrySet()) {\\n            String mail = it.getKey();\\n            int node = ds.findUParent(it.getValue());\\n            tmp[node].add(mail);\\n        }\\n        List<List<String>> res = new ArrayList<>();\\n        for (int i = 0; i < len; i++) {\\n            if (tmp[i].size() == 0) continue;\\n            ArrayList<String> txp = new ArrayList<>();\\n            txp.add(accounts.get(i).get(0));\\n            Collections.sort(tmp[i]);\\n            for (String s : tmp[i]) txp.add(s);\\n            res.add(txp);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758042,
                "title": "dfs-simple-intuitive-approach",
                "content": "GO through the code it\\'s very simple and intutive approach, concept wise it\\' very simple but just a lengthy implimentation\\uD83E\\uDD72. \\n\\n```\\n  UPVOTE IF U FIND HELPFUL\\n```\\n\\n```\\n\\nclass Solution {\\npublic: \\n        map<int, string> m; // for name  | email\\'s int to name\\n        map<string, int> m1;// string to int for email\\n        map<int, string> m2;// int to email\\n    \\n    // go to all connected nodes and st\\n    void dfs(vector<vector<int>>&g, int i,vector<bool> &v, vector<string>&s)\\n    {\\n        if(v[i]) return;\\n        s.push_back(m2[i]);\\n        v[i]=1;\\n        \\n        for(auto it: g[i]) dfs(g,it,v,s);\\n    }\\n    \\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& a) \\n    {\\n        m.clear();\\n        m1.clear();\\n        m2.clear();\\n        vector<vector<int>> g(100001);\\n        int t=0;\\n        for(auto it: a)\\n        {\\n            string nm= it[0];// name of person\\n            for(int i=1; i<it.size(); i++)\\n            {\\n               \\n                if(m1.find(it[i])==m1.end())\\n                {\\n                    m1[it[i]]=t;// email to int\\n                    m2[t]=it[i];// int to email\\n                    t++;\\n                }\\n                 m[m1[it[i]]]=nm; // that email\\'s int to name\\n                \\n                if(i>=2) // store the graph \\n                {\\n                    g[m1[it[i-1]] ].push_back(m1[it[i]]);\\n                    g[m1[it[i]] ].push_back(m1[it[i-1]]);\\n                }\\n                \\n                \\n            }\\n        }\\n        \\n        \\n        \\n        vector<vector<string>> ans;\\n        int n=m1.size();\\n        vector<bool> v(n, false);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n           \\n            if(v[i]==false)// for each email which is not visited do dfs search for connected all emails\\n            {\\n                vector<string> s;\\n                dfs(g, i,v,s);\\n                \\n                vector<string> tem;\\n                tem.push_back(m[i]);\\n                sort(s.begin(),s.end());\\n                for(auto it: s) tem.push_back(it);\\n                ans.push_back(tem);\\n                tem.clear();\\n                s.clear();\\n\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\n  UPVOTE IF U FIND HELPFUL\\n```\n```\\n\\nclass Solution {\\npublic: \\n        map<int, string> m; // for name  | email\\'s int to name\\n        map<string, int> m1;// string to int for email\\n        map<int, string> m2;// int to email\\n    \\n    // go to all connected nodes and st\\n    void dfs(vector<vector<int>>&g, int i,vector<bool> &v, vector<string>&s)\\n    {\\n        if(v[i]) return;\\n        s.push_back(m2[i]);\\n        v[i]=1;\\n        \\n        for(auto it: g[i]) dfs(g,it,v,s);\\n    }\\n    \\n    \\n    vector<vector<string>> accountsMerge(vector<vector<string>>& a) \\n    {\\n        m.clear();\\n        m1.clear();\\n        m2.clear();\\n        vector<vector<int>> g(100001);\\n        int t=0;\\n        for(auto it: a)\\n        {\\n            string nm= it[0];// name of person\\n            for(int i=1; i<it.size(); i++)\\n            {\\n               \\n                if(m1.find(it[i])==m1.end())\\n                {\\n                    m1[it[i]]=t;// email to int\\n                    m2[t]=it[i];// int to email\\n                    t++;\\n                }\\n                 m[m1[it[i]]]=nm; // that email\\'s int to name\\n                \\n                if(i>=2) // store the graph \\n                {\\n                    g[m1[it[i-1]] ].push_back(m1[it[i]]);\\n                    g[m1[it[i]] ].push_back(m1[it[i-1]]);\\n                }\\n                \\n                \\n            }\\n        }\\n        \\n        \\n        \\n        vector<vector<string>> ans;\\n        int n=m1.size();\\n        vector<bool> v(n, false);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n           \\n            if(v[i]==false)// for each email which is not visited do dfs search for connected all emails\\n            {\\n                vector<string> s;\\n                dfs(g, i,v,s);\\n                \\n                vector<string> tem;\\n                tem.push_back(m[i]);\\n                sort(s.begin(),s.end());\\n                for(auto it: s) tem.push_back(it);\\n                ans.push_back(tem);\\n                tem.clear();\\n                s.clear();\\n\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564586,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1709979,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1566884,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1688738,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1565886,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1565414,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1785216,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1729060,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1695616,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1891652,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1564586,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1709979,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1566884,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1688738,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1565886,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1565414,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1785216,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1729060,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1695616,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 1891652,
                "content": [
                    {
                        "username": "xuxuxudaren",
                        "content": "My heart has broken."
                    },
                    {
                        "username": "crazysamurai",
                        "content": "I\\'m sorry, i\\'ll use only one email from now on."
                    },
                    {
                        "username": "gurupalsingh83",
                        "content": "++ \\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": ":(                                                                         ."
                    },
                    {
                        "username": "Ganes123",
                        "content": "ha ha ha  ha "
                    },
                    {
                        "username": "aman111298",
                        "content": "same here"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I disagree with this problem being termed as medium. Even if one know DSU, it\\'s hard to arrive to the solution."
                    },
                    {
                        "username": "zzjharry",
                        "content": "I agree. This one is more involving comparing to other union-find questions, since we need to be very clear about what the groups should be."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "While I agree that this is more difficult than standard DSU mediums, it\\'s still a pretty standard application of DSU. Let emails be nodes and let emails in the same array be connected by an undirected edge. \\n\\n"
                    },
                    {
                        "username": "cssource1156",
                        "content": "agree, it's a 100% \"Hard\" question"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "true. It should be marked as \"Hard\""
                    },
                    {
                        "username": "harkeshbirman",
                        "content": "NOT A MEDIUM. IT\\'S HARD"
                    },
                    {
                        "username": "marcello834",
                        "content": "Alright, this is truly out of context... It turns out that I have 2 leetcode accounts, how do I merge one into the other? :)"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/accounts-merge/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "coder42032",
                        "content": "Move this problem into hard section."
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This should be marked as hard..."
                    },
                    {
                        "username": "kamun",
                        "content": "This is definitely a hard problem. I saw many hards simpler than this one and not because it require knowledge of DSU or DFS, but because it is really hard to implement a clean version. "
                    },
                    {
                        "username": "user3366Sy",
                        "content": "Leetcode should add a new difficulty label called \"VERY HARD\" and this as one of the first problems to be labeled as that."
                    },
                    {
                        "username": "topoGraphKing",
                        "content": "So companies would start asking questions from \"VERY HARD\" level? Medium and Easy would be out the door!!"
                    }
                ]
            },
            {
                "id": 2035202,
                "content": [
                    {
                        "username": "Sourav04",
                        "content": "Please move this question to hard section"
                    },
                    {
                        "username": "Lesley999",
                        "content": "it is radicular! why need i make the emails in sorted order after using a long time to understand union find"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What the hell is the problem with multiple emails?!?"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "now onwards i will only send mails written on the paper no electronic way"
                    },
                    {
                        "username": "SeineAle",
                        "content": "More of a hashing question for me than DSU. Maybe I\\'m  Stupid, but I used a hell lots of maps. "
                    },
                    {
                        "username": "rahulshrma32",
                        "content": "class Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>rank;\\n    int find(int x)\\n    {\\n        if(x==parent[x]) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    void Union(int x,int y){\\n        int xp=find(x);\\n        int yp=find(y);\\n        if(xp==yp) return;\\n        if(rank[xp]>rank[yp]) parent[yp]=xp;\\n        else if(rank[yp]>rank[xp]) parent[xp]=yp;\\n        else{\\n            parent[yp]=xp;\\n            rank[xp]++;\\n        }\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string,int>mp;\\n        int n=accounts.size();\\n        rank.resize(n,0);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++) parent[i]=i;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                if(mp.find(accounts[i][j])==mp.end()){\\n                    mp[accounts[i][j]]=i;\\n                }\\n                else{\\n                    Union(i,mp[accounts[i][j]]);\\n                }\\n            }\\n        }\\n        vector<string>mergemail[n];\\n        vector<vector<string>>ans;\\n        for(auto it:mp){\\n            int x=find(it.second);\\n            mergemail[x].push_back(it.first);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mergemail[i].size()==0) continue;\\n            sort(mergemail[i].begin(),mergemail[i].end());\\n            vector<string>temp;\\n            temp.push_back(accounts[i][0]);\\n            for(auto it:mergemail[i]){\\n                temp.push_back(it);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n}; can anybody tell me why this code is not working\\n"
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "why is there no solution code about sorting the accounts based on accounts[i][0], followed by merging them if there is some common email in two adjacent rows work..?? I don\\'t see any edge case that it would fail to cover "
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am going through all my alt emails and deleting them right now"
                    },
                    {
                        "username": "Sourav04",
                        "content": "Hi I think this question should be in hard category not in the medium."
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Highly Non-Intuitive and wait......Medium ?   "
                    }
                ]
            },
            {
                "id": 1970894,
                "content": [
                    {
                        "username": "Sourav04",
                        "content": "Please move this question to hard section"
                    },
                    {
                        "username": "Lesley999",
                        "content": "it is radicular! why need i make the emails in sorted order after using a long time to understand union find"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What the hell is the problem with multiple emails?!?"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "now onwards i will only send mails written on the paper no electronic way"
                    },
                    {
                        "username": "SeineAle",
                        "content": "More of a hashing question for me than DSU. Maybe I\\'m  Stupid, but I used a hell lots of maps. "
                    },
                    {
                        "username": "rahulshrma32",
                        "content": "class Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>rank;\\n    int find(int x)\\n    {\\n        if(x==parent[x]) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    void Union(int x,int y){\\n        int xp=find(x);\\n        int yp=find(y);\\n        if(xp==yp) return;\\n        if(rank[xp]>rank[yp]) parent[yp]=xp;\\n        else if(rank[yp]>rank[xp]) parent[xp]=yp;\\n        else{\\n            parent[yp]=xp;\\n            rank[xp]++;\\n        }\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string,int>mp;\\n        int n=accounts.size();\\n        rank.resize(n,0);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++) parent[i]=i;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                if(mp.find(accounts[i][j])==mp.end()){\\n                    mp[accounts[i][j]]=i;\\n                }\\n                else{\\n                    Union(i,mp[accounts[i][j]]);\\n                }\\n            }\\n        }\\n        vector<string>mergemail[n];\\n        vector<vector<string>>ans;\\n        for(auto it:mp){\\n            int x=find(it.second);\\n            mergemail[x].push_back(it.first);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mergemail[i].size()==0) continue;\\n            sort(mergemail[i].begin(),mergemail[i].end());\\n            vector<string>temp;\\n            temp.push_back(accounts[i][0]);\\n            for(auto it:mergemail[i]){\\n                temp.push_back(it);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n}; can anybody tell me why this code is not working\\n"
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "why is there no solution code about sorting the accounts based on accounts[i][0], followed by merging them if there is some common email in two adjacent rows work..?? I don\\'t see any edge case that it would fail to cover "
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am going through all my alt emails and deleting them right now"
                    },
                    {
                        "username": "Sourav04",
                        "content": "Hi I think this question should be in hard category not in the medium."
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Highly Non-Intuitive and wait......Medium ?   "
                    }
                ]
            },
            {
                "id": 1730785,
                "content": [
                    {
                        "username": "Sourav04",
                        "content": "Please move this question to hard section"
                    },
                    {
                        "username": "Lesley999",
                        "content": "it is radicular! why need i make the emails in sorted order after using a long time to understand union find"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What the hell is the problem with multiple emails?!?"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "now onwards i will only send mails written on the paper no electronic way"
                    },
                    {
                        "username": "SeineAle",
                        "content": "More of a hashing question for me than DSU. Maybe I\\'m  Stupid, but I used a hell lots of maps. "
                    },
                    {
                        "username": "rahulshrma32",
                        "content": "class Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>rank;\\n    int find(int x)\\n    {\\n        if(x==parent[x]) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    void Union(int x,int y){\\n        int xp=find(x);\\n        int yp=find(y);\\n        if(xp==yp) return;\\n        if(rank[xp]>rank[yp]) parent[yp]=xp;\\n        else if(rank[yp]>rank[xp]) parent[xp]=yp;\\n        else{\\n            parent[yp]=xp;\\n            rank[xp]++;\\n        }\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string,int>mp;\\n        int n=accounts.size();\\n        rank.resize(n,0);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++) parent[i]=i;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                if(mp.find(accounts[i][j])==mp.end()){\\n                    mp[accounts[i][j]]=i;\\n                }\\n                else{\\n                    Union(i,mp[accounts[i][j]]);\\n                }\\n            }\\n        }\\n        vector<string>mergemail[n];\\n        vector<vector<string>>ans;\\n        for(auto it:mp){\\n            int x=find(it.second);\\n            mergemail[x].push_back(it.first);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mergemail[i].size()==0) continue;\\n            sort(mergemail[i].begin(),mergemail[i].end());\\n            vector<string>temp;\\n            temp.push_back(accounts[i][0]);\\n            for(auto it:mergemail[i]){\\n                temp.push_back(it);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n}; can anybody tell me why this code is not working\\n"
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "why is there no solution code about sorting the accounts based on accounts[i][0], followed by merging them if there is some common email in two adjacent rows work..?? I don\\'t see any edge case that it would fail to cover "
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am going through all my alt emails and deleting them right now"
                    },
                    {
                        "username": "Sourav04",
                        "content": "Hi I think this question should be in hard category not in the medium."
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Highly Non-Intuitive and wait......Medium ?   "
                    }
                ]
            },
            {
                "id": 2064212,
                "content": [
                    {
                        "username": "Sourav04",
                        "content": "Please move this question to hard section"
                    },
                    {
                        "username": "Lesley999",
                        "content": "it is radicular! why need i make the emails in sorted order after using a long time to understand union find"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What the hell is the problem with multiple emails?!?"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "now onwards i will only send mails written on the paper no electronic way"
                    },
                    {
                        "username": "SeineAle",
                        "content": "More of a hashing question for me than DSU. Maybe I\\'m  Stupid, but I used a hell lots of maps. "
                    },
                    {
                        "username": "rahulshrma32",
                        "content": "class Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>rank;\\n    int find(int x)\\n    {\\n        if(x==parent[x]) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    void Union(int x,int y){\\n        int xp=find(x);\\n        int yp=find(y);\\n        if(xp==yp) return;\\n        if(rank[xp]>rank[yp]) parent[yp]=xp;\\n        else if(rank[yp]>rank[xp]) parent[xp]=yp;\\n        else{\\n            parent[yp]=xp;\\n            rank[xp]++;\\n        }\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string,int>mp;\\n        int n=accounts.size();\\n        rank.resize(n,0);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++) parent[i]=i;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                if(mp.find(accounts[i][j])==mp.end()){\\n                    mp[accounts[i][j]]=i;\\n                }\\n                else{\\n                    Union(i,mp[accounts[i][j]]);\\n                }\\n            }\\n        }\\n        vector<string>mergemail[n];\\n        vector<vector<string>>ans;\\n        for(auto it:mp){\\n            int x=find(it.second);\\n            mergemail[x].push_back(it.first);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mergemail[i].size()==0) continue;\\n            sort(mergemail[i].begin(),mergemail[i].end());\\n            vector<string>temp;\\n            temp.push_back(accounts[i][0]);\\n            for(auto it:mergemail[i]){\\n                temp.push_back(it);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n}; can anybody tell me why this code is not working\\n"
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "why is there no solution code about sorting the accounts based on accounts[i][0], followed by merging them if there is some common email in two adjacent rows work..?? I don\\'t see any edge case that it would fail to cover "
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am going through all my alt emails and deleting them right now"
                    },
                    {
                        "username": "Sourav04",
                        "content": "Hi I think this question should be in hard category not in the medium."
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Highly Non-Intuitive and wait......Medium ?   "
                    }
                ]
            },
            {
                "id": 2059198,
                "content": [
                    {
                        "username": "Sourav04",
                        "content": "Please move this question to hard section"
                    },
                    {
                        "username": "Lesley999",
                        "content": "it is radicular! why need i make the emails in sorted order after using a long time to understand union find"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What the hell is the problem with multiple emails?!?"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "now onwards i will only send mails written on the paper no electronic way"
                    },
                    {
                        "username": "SeineAle",
                        "content": "More of a hashing question for me than DSU. Maybe I\\'m  Stupid, but I used a hell lots of maps. "
                    },
                    {
                        "username": "rahulshrma32",
                        "content": "class Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>rank;\\n    int find(int x)\\n    {\\n        if(x==parent[x]) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    void Union(int x,int y){\\n        int xp=find(x);\\n        int yp=find(y);\\n        if(xp==yp) return;\\n        if(rank[xp]>rank[yp]) parent[yp]=xp;\\n        else if(rank[yp]>rank[xp]) parent[xp]=yp;\\n        else{\\n            parent[yp]=xp;\\n            rank[xp]++;\\n        }\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string,int>mp;\\n        int n=accounts.size();\\n        rank.resize(n,0);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++) parent[i]=i;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                if(mp.find(accounts[i][j])==mp.end()){\\n                    mp[accounts[i][j]]=i;\\n                }\\n                else{\\n                    Union(i,mp[accounts[i][j]]);\\n                }\\n            }\\n        }\\n        vector<string>mergemail[n];\\n        vector<vector<string>>ans;\\n        for(auto it:mp){\\n            int x=find(it.second);\\n            mergemail[x].push_back(it.first);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mergemail[i].size()==0) continue;\\n            sort(mergemail[i].begin(),mergemail[i].end());\\n            vector<string>temp;\\n            temp.push_back(accounts[i][0]);\\n            for(auto it:mergemail[i]){\\n                temp.push_back(it);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n}; can anybody tell me why this code is not working\\n"
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "why is there no solution code about sorting the accounts based on accounts[i][0], followed by merging them if there is some common email in two adjacent rows work..?? I don\\'t see any edge case that it would fail to cover "
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am going through all my alt emails and deleting them right now"
                    },
                    {
                        "username": "Sourav04",
                        "content": "Hi I think this question should be in hard category not in the medium."
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Highly Non-Intuitive and wait......Medium ?   "
                    }
                ]
            },
            {
                "id": 2028395,
                "content": [
                    {
                        "username": "Sourav04",
                        "content": "Please move this question to hard section"
                    },
                    {
                        "username": "Lesley999",
                        "content": "it is radicular! why need i make the emails in sorted order after using a long time to understand union find"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What the hell is the problem with multiple emails?!?"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "now onwards i will only send mails written on the paper no electronic way"
                    },
                    {
                        "username": "SeineAle",
                        "content": "More of a hashing question for me than DSU. Maybe I\\'m  Stupid, but I used a hell lots of maps. "
                    },
                    {
                        "username": "rahulshrma32",
                        "content": "class Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>rank;\\n    int find(int x)\\n    {\\n        if(x==parent[x]) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    void Union(int x,int y){\\n        int xp=find(x);\\n        int yp=find(y);\\n        if(xp==yp) return;\\n        if(rank[xp]>rank[yp]) parent[yp]=xp;\\n        else if(rank[yp]>rank[xp]) parent[xp]=yp;\\n        else{\\n            parent[yp]=xp;\\n            rank[xp]++;\\n        }\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string,int>mp;\\n        int n=accounts.size();\\n        rank.resize(n,0);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++) parent[i]=i;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                if(mp.find(accounts[i][j])==mp.end()){\\n                    mp[accounts[i][j]]=i;\\n                }\\n                else{\\n                    Union(i,mp[accounts[i][j]]);\\n                }\\n            }\\n        }\\n        vector<string>mergemail[n];\\n        vector<vector<string>>ans;\\n        for(auto it:mp){\\n            int x=find(it.second);\\n            mergemail[x].push_back(it.first);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mergemail[i].size()==0) continue;\\n            sort(mergemail[i].begin(),mergemail[i].end());\\n            vector<string>temp;\\n            temp.push_back(accounts[i][0]);\\n            for(auto it:mergemail[i]){\\n                temp.push_back(it);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n}; can anybody tell me why this code is not working\\n"
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "why is there no solution code about sorting the accounts based on accounts[i][0], followed by merging them if there is some common email in two adjacent rows work..?? I don\\'t see any edge case that it would fail to cover "
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am going through all my alt emails and deleting them right now"
                    },
                    {
                        "username": "Sourav04",
                        "content": "Hi I think this question should be in hard category not in the medium."
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Highly Non-Intuitive and wait......Medium ?   "
                    }
                ]
            },
            {
                "id": 2025965,
                "content": [
                    {
                        "username": "Sourav04",
                        "content": "Please move this question to hard section"
                    },
                    {
                        "username": "Lesley999",
                        "content": "it is radicular! why need i make the emails in sorted order after using a long time to understand union find"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What the hell is the problem with multiple emails?!?"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "now onwards i will only send mails written on the paper no electronic way"
                    },
                    {
                        "username": "SeineAle",
                        "content": "More of a hashing question for me than DSU. Maybe I\\'m  Stupid, but I used a hell lots of maps. "
                    },
                    {
                        "username": "rahulshrma32",
                        "content": "class Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>rank;\\n    int find(int x)\\n    {\\n        if(x==parent[x]) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    void Union(int x,int y){\\n        int xp=find(x);\\n        int yp=find(y);\\n        if(xp==yp) return;\\n        if(rank[xp]>rank[yp]) parent[yp]=xp;\\n        else if(rank[yp]>rank[xp]) parent[xp]=yp;\\n        else{\\n            parent[yp]=xp;\\n            rank[xp]++;\\n        }\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string,int>mp;\\n        int n=accounts.size();\\n        rank.resize(n,0);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++) parent[i]=i;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                if(mp.find(accounts[i][j])==mp.end()){\\n                    mp[accounts[i][j]]=i;\\n                }\\n                else{\\n                    Union(i,mp[accounts[i][j]]);\\n                }\\n            }\\n        }\\n        vector<string>mergemail[n];\\n        vector<vector<string>>ans;\\n        for(auto it:mp){\\n            int x=find(it.second);\\n            mergemail[x].push_back(it.first);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mergemail[i].size()==0) continue;\\n            sort(mergemail[i].begin(),mergemail[i].end());\\n            vector<string>temp;\\n            temp.push_back(accounts[i][0]);\\n            for(auto it:mergemail[i]){\\n                temp.push_back(it);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n}; can anybody tell me why this code is not working\\n"
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "why is there no solution code about sorting the accounts based on accounts[i][0], followed by merging them if there is some common email in two adjacent rows work..?? I don\\'t see any edge case that it would fail to cover "
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am going through all my alt emails and deleting them right now"
                    },
                    {
                        "username": "Sourav04",
                        "content": "Hi I think this question should be in hard category not in the medium."
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Highly Non-Intuitive and wait......Medium ?   "
                    }
                ]
            },
            {
                "id": 2011447,
                "content": [
                    {
                        "username": "Sourav04",
                        "content": "Please move this question to hard section"
                    },
                    {
                        "username": "Lesley999",
                        "content": "it is radicular! why need i make the emails in sorted order after using a long time to understand union find"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What the hell is the problem with multiple emails?!?"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "now onwards i will only send mails written on the paper no electronic way"
                    },
                    {
                        "username": "SeineAle",
                        "content": "More of a hashing question for me than DSU. Maybe I\\'m  Stupid, but I used a hell lots of maps. "
                    },
                    {
                        "username": "rahulshrma32",
                        "content": "class Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>rank;\\n    int find(int x)\\n    {\\n        if(x==parent[x]) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    void Union(int x,int y){\\n        int xp=find(x);\\n        int yp=find(y);\\n        if(xp==yp) return;\\n        if(rank[xp]>rank[yp]) parent[yp]=xp;\\n        else if(rank[yp]>rank[xp]) parent[xp]=yp;\\n        else{\\n            parent[yp]=xp;\\n            rank[xp]++;\\n        }\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string,int>mp;\\n        int n=accounts.size();\\n        rank.resize(n,0);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++) parent[i]=i;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                if(mp.find(accounts[i][j])==mp.end()){\\n                    mp[accounts[i][j]]=i;\\n                }\\n                else{\\n                    Union(i,mp[accounts[i][j]]);\\n                }\\n            }\\n        }\\n        vector<string>mergemail[n];\\n        vector<vector<string>>ans;\\n        for(auto it:mp){\\n            int x=find(it.second);\\n            mergemail[x].push_back(it.first);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mergemail[i].size()==0) continue;\\n            sort(mergemail[i].begin(),mergemail[i].end());\\n            vector<string>temp;\\n            temp.push_back(accounts[i][0]);\\n            for(auto it:mergemail[i]){\\n                temp.push_back(it);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n}; can anybody tell me why this code is not working\\n"
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "why is there no solution code about sorting the accounts based on accounts[i][0], followed by merging them if there is some common email in two adjacent rows work..?? I don\\'t see any edge case that it would fail to cover "
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am going through all my alt emails and deleting them right now"
                    },
                    {
                        "username": "Sourav04",
                        "content": "Hi I think this question should be in hard category not in the medium."
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Highly Non-Intuitive and wait......Medium ?   "
                    }
                ]
            },
            {
                "id": 2010904,
                "content": [
                    {
                        "username": "Sourav04",
                        "content": "Please move this question to hard section"
                    },
                    {
                        "username": "Lesley999",
                        "content": "it is radicular! why need i make the emails in sorted order after using a long time to understand union find"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What the hell is the problem with multiple emails?!?"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "now onwards i will only send mails written on the paper no electronic way"
                    },
                    {
                        "username": "SeineAle",
                        "content": "More of a hashing question for me than DSU. Maybe I\\'m  Stupid, but I used a hell lots of maps. "
                    },
                    {
                        "username": "rahulshrma32",
                        "content": "class Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>rank;\\n    int find(int x)\\n    {\\n        if(x==parent[x]) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    void Union(int x,int y){\\n        int xp=find(x);\\n        int yp=find(y);\\n        if(xp==yp) return;\\n        if(rank[xp]>rank[yp]) parent[yp]=xp;\\n        else if(rank[yp]>rank[xp]) parent[xp]=yp;\\n        else{\\n            parent[yp]=xp;\\n            rank[xp]++;\\n        }\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string,int>mp;\\n        int n=accounts.size();\\n        rank.resize(n,0);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++) parent[i]=i;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                if(mp.find(accounts[i][j])==mp.end()){\\n                    mp[accounts[i][j]]=i;\\n                }\\n                else{\\n                    Union(i,mp[accounts[i][j]]);\\n                }\\n            }\\n        }\\n        vector<string>mergemail[n];\\n        vector<vector<string>>ans;\\n        for(auto it:mp){\\n            int x=find(it.second);\\n            mergemail[x].push_back(it.first);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mergemail[i].size()==0) continue;\\n            sort(mergemail[i].begin(),mergemail[i].end());\\n            vector<string>temp;\\n            temp.push_back(accounts[i][0]);\\n            for(auto it:mergemail[i]){\\n                temp.push_back(it);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n}; can anybody tell me why this code is not working\\n"
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "why is there no solution code about sorting the accounts based on accounts[i][0], followed by merging them if there is some common email in two adjacent rows work..?? I don\\'t see any edge case that it would fail to cover "
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am going through all my alt emails and deleting them right now"
                    },
                    {
                        "username": "Sourav04",
                        "content": "Hi I think this question should be in hard category not in the medium."
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Highly Non-Intuitive and wait......Medium ?   "
                    }
                ]
            },
            {
                "id": 1994657,
                "content": [
                    {
                        "username": "Sourav04",
                        "content": "Please move this question to hard section"
                    },
                    {
                        "username": "Lesley999",
                        "content": "it is radicular! why need i make the emails in sorted order after using a long time to understand union find"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "What the hell is the problem with multiple emails?!?"
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "now onwards i will only send mails written on the paper no electronic way"
                    },
                    {
                        "username": "SeineAle",
                        "content": "More of a hashing question for me than DSU. Maybe I\\'m  Stupid, but I used a hell lots of maps. "
                    },
                    {
                        "username": "rahulshrma32",
                        "content": "class Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>rank;\\n    int find(int x)\\n    {\\n        if(x==parent[x]) return x;\\n        return parent[x]=find(parent[x]);\\n    }\\n    void Union(int x,int y){\\n        int xp=find(x);\\n        int yp=find(y);\\n        if(xp==yp) return;\\n        if(rank[xp]>rank[yp]) parent[yp]=xp;\\n        else if(rank[yp]>rank[xp]) parent[xp]=yp;\\n        else{\\n            parent[yp]=xp;\\n            rank[xp]++;\\n        }\\n    }\\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {\\n        unordered_map<string,int>mp;\\n        int n=accounts.size();\\n        rank.resize(n,0);\\n        parent.resize(n);\\n        for(int i=0;i<n;i++) parent[i]=i;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<n;j++){\\n                if(mp.find(accounts[i][j])==mp.end()){\\n                    mp[accounts[i][j]]=i;\\n                }\\n                else{\\n                    Union(i,mp[accounts[i][j]]);\\n                }\\n            }\\n        }\\n        vector<string>mergemail[n];\\n        vector<vector<string>>ans;\\n        for(auto it:mp){\\n            int x=find(it.second);\\n            mergemail[x].push_back(it.first);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(mergemail[i].size()==0) continue;\\n            sort(mergemail[i].begin(),mergemail[i].end());\\n            vector<string>temp;\\n            temp.push_back(accounts[i][0]);\\n            for(auto it:mergemail[i]){\\n                temp.push_back(it);\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n}; can anybody tell me why this code is not working\\n"
                    },
                    {
                        "username": "KeshavJha2002",
                        "content": "why is there no solution code about sorting the accounts based on accounts[i][0], followed by merging them if there is some common email in two adjacent rows work..?? I don\\'t see any edge case that it would fail to cover "
                    },
                    {
                        "username": "AclassDev47",
                        "content": "I am going through all my alt emails and deleting them right now"
                    },
                    {
                        "username": "Sourav04",
                        "content": "Hi I think this question should be in hard category not in the medium."
                    },
                    {
                        "username": "Zeeshan251",
                        "content": "Highly Non-Intuitive and wait......Medium ?   "
                    }
                ]
            },
            {
                "id": 1992060,
                "content": [
                    {
                        "username": "LC_Binod",
                        "content": "Best problem I\\'ve ever encountered."
                    },
                    {
                        "username": "SG-C",
                        "content": "I suggest to block all accounts"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "18 minutes of coding + 4 minutes of debugging :)"
                    },
                    {
                        "username": "willus-mcgee",
                        "content": "Testcases allow for accounts to be in any order, but doesn\\'t seem to allow for emails within the accounts to be in any order. Does anyone else have this issue?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "This problem does not seem difficult at first glance. But I managed to notice that it requires DSU and really enjoyed applying it in a non standard way :)\nUsually it's about 0-n numbered nodes and edges, but here we have string sets."
                    },
                    {
                        "username": "kjers96",
                        "content": "Literally why one should always use only one email"
                    },
                    {
                        "username": "CaptainSam",
                        "content": "How is the output for the input\\n[[\"David\",\"David0@m.co\",\"David1@m.co\"],[\"David\",\"David3@m.co\",\"David4@m.co\"],[\"David\",\"David4@m.co\",\"David5@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\"],[\"David\",\"David1@m.co\",\"David2@m.co\"]]\\n\\nis this \\n[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]\\n\\nThere is David2@m.co in both the accounts, is this correct?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "How did you get this output? it prints everything in one entry for me: `[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]`"
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This is real Union and Find"
                    },
                    {
                        "username": "isamnagi",
                        "content": "Really hard, but break it into two( using the dfs solution).. building the graph... iterating it with dfs marking each email you visit while adding it to your mergedaccount.... All i can say is May Allah help you"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I believe the order of emails shouldnt  matter as long as they fall under the right name after merging\\nbut for some reason the testcases are sensitive to it.\\nSo instead of set, i used list to preserve the order so to speak \\nhowever when i run it here , it still messes up the order , despite working fine in my notebook\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def merge(considered,superset):\\n            for i in considered:\\n              if i in superset:return True \\n            return False\\n        def f(L):\\n            id = 0 \\n            hashmap = {}\\n            register = set()\\n            for i in L:\\n              name = i[0]\\n              if name not in register:\\n                register.add(name)\\n                hashmap[(name,id)]=set(i)\\n                hashmap[(name,id)].discard(name)\\n                id +=1\\n              else:\\n                merged = False\\n                for key in hashmap:\\n                  if key[0]==name and merge(i,hashmap[key]):\\n                    merged = True\\n                    hashmap[key].update(set(i))\\n                    hashmap[key].discard(name)\\n                if not merged:\\n                  hashmap[(name,id)]=set(i)\\n                  hashmap[(name,id)].discard(name)\\n                  id +=1\\n            Res =[]\\n            for i in hashmap:\\n              name =i[0]\\n              res =[name]\\n              res+=hashmap[i]\\n              Res.append(res)\\n            return Res   \\n        return f(accounts)\\n```"
                    }
                ]
            },
            {
                "id": 1975599,
                "content": [
                    {
                        "username": "LC_Binod",
                        "content": "Best problem I\\'ve ever encountered."
                    },
                    {
                        "username": "SG-C",
                        "content": "I suggest to block all accounts"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "18 minutes of coding + 4 minutes of debugging :)"
                    },
                    {
                        "username": "willus-mcgee",
                        "content": "Testcases allow for accounts to be in any order, but doesn\\'t seem to allow for emails within the accounts to be in any order. Does anyone else have this issue?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "This problem does not seem difficult at first glance. But I managed to notice that it requires DSU and really enjoyed applying it in a non standard way :)\nUsually it's about 0-n numbered nodes and edges, but here we have string sets."
                    },
                    {
                        "username": "kjers96",
                        "content": "Literally why one should always use only one email"
                    },
                    {
                        "username": "CaptainSam",
                        "content": "How is the output for the input\\n[[\"David\",\"David0@m.co\",\"David1@m.co\"],[\"David\",\"David3@m.co\",\"David4@m.co\"],[\"David\",\"David4@m.co\",\"David5@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\"],[\"David\",\"David1@m.co\",\"David2@m.co\"]]\\n\\nis this \\n[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]\\n\\nThere is David2@m.co in both the accounts, is this correct?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "How did you get this output? it prints everything in one entry for me: `[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]`"
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This is real Union and Find"
                    },
                    {
                        "username": "isamnagi",
                        "content": "Really hard, but break it into two( using the dfs solution).. building the graph... iterating it with dfs marking each email you visit while adding it to your mergedaccount.... All i can say is May Allah help you"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I believe the order of emails shouldnt  matter as long as they fall under the right name after merging\\nbut for some reason the testcases are sensitive to it.\\nSo instead of set, i used list to preserve the order so to speak \\nhowever when i run it here , it still messes up the order , despite working fine in my notebook\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def merge(considered,superset):\\n            for i in considered:\\n              if i in superset:return True \\n            return False\\n        def f(L):\\n            id = 0 \\n            hashmap = {}\\n            register = set()\\n            for i in L:\\n              name = i[0]\\n              if name not in register:\\n                register.add(name)\\n                hashmap[(name,id)]=set(i)\\n                hashmap[(name,id)].discard(name)\\n                id +=1\\n              else:\\n                merged = False\\n                for key in hashmap:\\n                  if key[0]==name and merge(i,hashmap[key]):\\n                    merged = True\\n                    hashmap[key].update(set(i))\\n                    hashmap[key].discard(name)\\n                if not merged:\\n                  hashmap[(name,id)]=set(i)\\n                  hashmap[(name,id)].discard(name)\\n                  id +=1\\n            Res =[]\\n            for i in hashmap:\\n              name =i[0]\\n              res =[name]\\n              res+=hashmap[i]\\n              Res.append(res)\\n            return Res   \\n        return f(accounts)\\n```"
                    }
                ]
            },
            {
                "id": 1928528,
                "content": [
                    {
                        "username": "LC_Binod",
                        "content": "Best problem I\\'ve ever encountered."
                    },
                    {
                        "username": "SG-C",
                        "content": "I suggest to block all accounts"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "18 minutes of coding + 4 minutes of debugging :)"
                    },
                    {
                        "username": "willus-mcgee",
                        "content": "Testcases allow for accounts to be in any order, but doesn\\'t seem to allow for emails within the accounts to be in any order. Does anyone else have this issue?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "This problem does not seem difficult at first glance. But I managed to notice that it requires DSU and really enjoyed applying it in a non standard way :)\nUsually it's about 0-n numbered nodes and edges, but here we have string sets."
                    },
                    {
                        "username": "kjers96",
                        "content": "Literally why one should always use only one email"
                    },
                    {
                        "username": "CaptainSam",
                        "content": "How is the output for the input\\n[[\"David\",\"David0@m.co\",\"David1@m.co\"],[\"David\",\"David3@m.co\",\"David4@m.co\"],[\"David\",\"David4@m.co\",\"David5@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\"],[\"David\",\"David1@m.co\",\"David2@m.co\"]]\\n\\nis this \\n[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]\\n\\nThere is David2@m.co in both the accounts, is this correct?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "How did you get this output? it prints everything in one entry for me: `[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]`"
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This is real Union and Find"
                    },
                    {
                        "username": "isamnagi",
                        "content": "Really hard, but break it into two( using the dfs solution).. building the graph... iterating it with dfs marking each email you visit while adding it to your mergedaccount.... All i can say is May Allah help you"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I believe the order of emails shouldnt  matter as long as they fall under the right name after merging\\nbut for some reason the testcases are sensitive to it.\\nSo instead of set, i used list to preserve the order so to speak \\nhowever when i run it here , it still messes up the order , despite working fine in my notebook\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def merge(considered,superset):\\n            for i in considered:\\n              if i in superset:return True \\n            return False\\n        def f(L):\\n            id = 0 \\n            hashmap = {}\\n            register = set()\\n            for i in L:\\n              name = i[0]\\n              if name not in register:\\n                register.add(name)\\n                hashmap[(name,id)]=set(i)\\n                hashmap[(name,id)].discard(name)\\n                id +=1\\n              else:\\n                merged = False\\n                for key in hashmap:\\n                  if key[0]==name and merge(i,hashmap[key]):\\n                    merged = True\\n                    hashmap[key].update(set(i))\\n                    hashmap[key].discard(name)\\n                if not merged:\\n                  hashmap[(name,id)]=set(i)\\n                  hashmap[(name,id)].discard(name)\\n                  id +=1\\n            Res =[]\\n            for i in hashmap:\\n              name =i[0]\\n              res =[name]\\n              res+=hashmap[i]\\n              Res.append(res)\\n            return Res   \\n        return f(accounts)\\n```"
                    }
                ]
            },
            {
                "id": 1917196,
                "content": [
                    {
                        "username": "LC_Binod",
                        "content": "Best problem I\\'ve ever encountered."
                    },
                    {
                        "username": "SG-C",
                        "content": "I suggest to block all accounts"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "18 minutes of coding + 4 minutes of debugging :)"
                    },
                    {
                        "username": "willus-mcgee",
                        "content": "Testcases allow for accounts to be in any order, but doesn\\'t seem to allow for emails within the accounts to be in any order. Does anyone else have this issue?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "This problem does not seem difficult at first glance. But I managed to notice that it requires DSU and really enjoyed applying it in a non standard way :)\nUsually it's about 0-n numbered nodes and edges, but here we have string sets."
                    },
                    {
                        "username": "kjers96",
                        "content": "Literally why one should always use only one email"
                    },
                    {
                        "username": "CaptainSam",
                        "content": "How is the output for the input\\n[[\"David\",\"David0@m.co\",\"David1@m.co\"],[\"David\",\"David3@m.co\",\"David4@m.co\"],[\"David\",\"David4@m.co\",\"David5@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\"],[\"David\",\"David1@m.co\",\"David2@m.co\"]]\\n\\nis this \\n[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]\\n\\nThere is David2@m.co in both the accounts, is this correct?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "How did you get this output? it prints everything in one entry for me: `[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]`"
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This is real Union and Find"
                    },
                    {
                        "username": "isamnagi",
                        "content": "Really hard, but break it into two( using the dfs solution).. building the graph... iterating it with dfs marking each email you visit while adding it to your mergedaccount.... All i can say is May Allah help you"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I believe the order of emails shouldnt  matter as long as they fall under the right name after merging\\nbut for some reason the testcases are sensitive to it.\\nSo instead of set, i used list to preserve the order so to speak \\nhowever when i run it here , it still messes up the order , despite working fine in my notebook\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def merge(considered,superset):\\n            for i in considered:\\n              if i in superset:return True \\n            return False\\n        def f(L):\\n            id = 0 \\n            hashmap = {}\\n            register = set()\\n            for i in L:\\n              name = i[0]\\n              if name not in register:\\n                register.add(name)\\n                hashmap[(name,id)]=set(i)\\n                hashmap[(name,id)].discard(name)\\n                id +=1\\n              else:\\n                merged = False\\n                for key in hashmap:\\n                  if key[0]==name and merge(i,hashmap[key]):\\n                    merged = True\\n                    hashmap[key].update(set(i))\\n                    hashmap[key].discard(name)\\n                if not merged:\\n                  hashmap[(name,id)]=set(i)\\n                  hashmap[(name,id)].discard(name)\\n                  id +=1\\n            Res =[]\\n            for i in hashmap:\\n              name =i[0]\\n              res =[name]\\n              res+=hashmap[i]\\n              Res.append(res)\\n            return Res   \\n        return f(accounts)\\n```"
                    }
                ]
            },
            {
                "id": 1902286,
                "content": [
                    {
                        "username": "LC_Binod",
                        "content": "Best problem I\\'ve ever encountered."
                    },
                    {
                        "username": "SG-C",
                        "content": "I suggest to block all accounts"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "18 minutes of coding + 4 minutes of debugging :)"
                    },
                    {
                        "username": "willus-mcgee",
                        "content": "Testcases allow for accounts to be in any order, but doesn\\'t seem to allow for emails within the accounts to be in any order. Does anyone else have this issue?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "This problem does not seem difficult at first glance. But I managed to notice that it requires DSU and really enjoyed applying it in a non standard way :)\nUsually it's about 0-n numbered nodes and edges, but here we have string sets."
                    },
                    {
                        "username": "kjers96",
                        "content": "Literally why one should always use only one email"
                    },
                    {
                        "username": "CaptainSam",
                        "content": "How is the output for the input\\n[[\"David\",\"David0@m.co\",\"David1@m.co\"],[\"David\",\"David3@m.co\",\"David4@m.co\"],[\"David\",\"David4@m.co\",\"David5@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\"],[\"David\",\"David1@m.co\",\"David2@m.co\"]]\\n\\nis this \\n[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]\\n\\nThere is David2@m.co in both the accounts, is this correct?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "How did you get this output? it prints everything in one entry for me: `[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]`"
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This is real Union and Find"
                    },
                    {
                        "username": "isamnagi",
                        "content": "Really hard, but break it into two( using the dfs solution).. building the graph... iterating it with dfs marking each email you visit while adding it to your mergedaccount.... All i can say is May Allah help you"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I believe the order of emails shouldnt  matter as long as they fall under the right name after merging\\nbut for some reason the testcases are sensitive to it.\\nSo instead of set, i used list to preserve the order so to speak \\nhowever when i run it here , it still messes up the order , despite working fine in my notebook\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def merge(considered,superset):\\n            for i in considered:\\n              if i in superset:return True \\n            return False\\n        def f(L):\\n            id = 0 \\n            hashmap = {}\\n            register = set()\\n            for i in L:\\n              name = i[0]\\n              if name not in register:\\n                register.add(name)\\n                hashmap[(name,id)]=set(i)\\n                hashmap[(name,id)].discard(name)\\n                id +=1\\n              else:\\n                merged = False\\n                for key in hashmap:\\n                  if key[0]==name and merge(i,hashmap[key]):\\n                    merged = True\\n                    hashmap[key].update(set(i))\\n                    hashmap[key].discard(name)\\n                if not merged:\\n                  hashmap[(name,id)]=set(i)\\n                  hashmap[(name,id)].discard(name)\\n                  id +=1\\n            Res =[]\\n            for i in hashmap:\\n              name =i[0]\\n              res =[name]\\n              res+=hashmap[i]\\n              Res.append(res)\\n            return Res   \\n        return f(accounts)\\n```"
                    }
                ]
            },
            {
                "id": 1828661,
                "content": [
                    {
                        "username": "LC_Binod",
                        "content": "Best problem I\\'ve ever encountered."
                    },
                    {
                        "username": "SG-C",
                        "content": "I suggest to block all accounts"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "18 minutes of coding + 4 minutes of debugging :)"
                    },
                    {
                        "username": "willus-mcgee",
                        "content": "Testcases allow for accounts to be in any order, but doesn\\'t seem to allow for emails within the accounts to be in any order. Does anyone else have this issue?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "This problem does not seem difficult at first glance. But I managed to notice that it requires DSU and really enjoyed applying it in a non standard way :)\nUsually it's about 0-n numbered nodes and edges, but here we have string sets."
                    },
                    {
                        "username": "kjers96",
                        "content": "Literally why one should always use only one email"
                    },
                    {
                        "username": "CaptainSam",
                        "content": "How is the output for the input\\n[[\"David\",\"David0@m.co\",\"David1@m.co\"],[\"David\",\"David3@m.co\",\"David4@m.co\"],[\"David\",\"David4@m.co\",\"David5@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\"],[\"David\",\"David1@m.co\",\"David2@m.co\"]]\\n\\nis this \\n[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]\\n\\nThere is David2@m.co in both the accounts, is this correct?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "How did you get this output? it prints everything in one entry for me: `[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]`"
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This is real Union and Find"
                    },
                    {
                        "username": "isamnagi",
                        "content": "Really hard, but break it into two( using the dfs solution).. building the graph... iterating it with dfs marking each email you visit while adding it to your mergedaccount.... All i can say is May Allah help you"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I believe the order of emails shouldnt  matter as long as they fall under the right name after merging\\nbut for some reason the testcases are sensitive to it.\\nSo instead of set, i used list to preserve the order so to speak \\nhowever when i run it here , it still messes up the order , despite working fine in my notebook\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def merge(considered,superset):\\n            for i in considered:\\n              if i in superset:return True \\n            return False\\n        def f(L):\\n            id = 0 \\n            hashmap = {}\\n            register = set()\\n            for i in L:\\n              name = i[0]\\n              if name not in register:\\n                register.add(name)\\n                hashmap[(name,id)]=set(i)\\n                hashmap[(name,id)].discard(name)\\n                id +=1\\n              else:\\n                merged = False\\n                for key in hashmap:\\n                  if key[0]==name and merge(i,hashmap[key]):\\n                    merged = True\\n                    hashmap[key].update(set(i))\\n                    hashmap[key].discard(name)\\n                if not merged:\\n                  hashmap[(name,id)]=set(i)\\n                  hashmap[(name,id)].discard(name)\\n                  id +=1\\n            Res =[]\\n            for i in hashmap:\\n              name =i[0]\\n              res =[name]\\n              res+=hashmap[i]\\n              Res.append(res)\\n            return Res   \\n        return f(accounts)\\n```"
                    }
                ]
            },
            {
                "id": 1820710,
                "content": [
                    {
                        "username": "LC_Binod",
                        "content": "Best problem I\\'ve ever encountered."
                    },
                    {
                        "username": "SG-C",
                        "content": "I suggest to block all accounts"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "18 minutes of coding + 4 minutes of debugging :)"
                    },
                    {
                        "username": "willus-mcgee",
                        "content": "Testcases allow for accounts to be in any order, but doesn\\'t seem to allow for emails within the accounts to be in any order. Does anyone else have this issue?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "This problem does not seem difficult at first glance. But I managed to notice that it requires DSU and really enjoyed applying it in a non standard way :)\nUsually it's about 0-n numbered nodes and edges, but here we have string sets."
                    },
                    {
                        "username": "kjers96",
                        "content": "Literally why one should always use only one email"
                    },
                    {
                        "username": "CaptainSam",
                        "content": "How is the output for the input\\n[[\"David\",\"David0@m.co\",\"David1@m.co\"],[\"David\",\"David3@m.co\",\"David4@m.co\"],[\"David\",\"David4@m.co\",\"David5@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\"],[\"David\",\"David1@m.co\",\"David2@m.co\"]]\\n\\nis this \\n[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]\\n\\nThere is David2@m.co in both the accounts, is this correct?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "How did you get this output? it prints everything in one entry for me: `[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]`"
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This is real Union and Find"
                    },
                    {
                        "username": "isamnagi",
                        "content": "Really hard, but break it into two( using the dfs solution).. building the graph... iterating it with dfs marking each email you visit while adding it to your mergedaccount.... All i can say is May Allah help you"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I believe the order of emails shouldnt  matter as long as they fall under the right name after merging\\nbut for some reason the testcases are sensitive to it.\\nSo instead of set, i used list to preserve the order so to speak \\nhowever when i run it here , it still messes up the order , despite working fine in my notebook\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def merge(considered,superset):\\n            for i in considered:\\n              if i in superset:return True \\n            return False\\n        def f(L):\\n            id = 0 \\n            hashmap = {}\\n            register = set()\\n            for i in L:\\n              name = i[0]\\n              if name not in register:\\n                register.add(name)\\n                hashmap[(name,id)]=set(i)\\n                hashmap[(name,id)].discard(name)\\n                id +=1\\n              else:\\n                merged = False\\n                for key in hashmap:\\n                  if key[0]==name and merge(i,hashmap[key]):\\n                    merged = True\\n                    hashmap[key].update(set(i))\\n                    hashmap[key].discard(name)\\n                if not merged:\\n                  hashmap[(name,id)]=set(i)\\n                  hashmap[(name,id)].discard(name)\\n                  id +=1\\n            Res =[]\\n            for i in hashmap:\\n              name =i[0]\\n              res =[name]\\n              res+=hashmap[i]\\n              Res.append(res)\\n            return Res   \\n        return f(accounts)\\n```"
                    }
                ]
            },
            {
                "id": 1807873,
                "content": [
                    {
                        "username": "LC_Binod",
                        "content": "Best problem I\\'ve ever encountered."
                    },
                    {
                        "username": "SG-C",
                        "content": "I suggest to block all accounts"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "18 minutes of coding + 4 minutes of debugging :)"
                    },
                    {
                        "username": "willus-mcgee",
                        "content": "Testcases allow for accounts to be in any order, but doesn\\'t seem to allow for emails within the accounts to be in any order. Does anyone else have this issue?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "This problem does not seem difficult at first glance. But I managed to notice that it requires DSU and really enjoyed applying it in a non standard way :)\nUsually it's about 0-n numbered nodes and edges, but here we have string sets."
                    },
                    {
                        "username": "kjers96",
                        "content": "Literally why one should always use only one email"
                    },
                    {
                        "username": "CaptainSam",
                        "content": "How is the output for the input\\n[[\"David\",\"David0@m.co\",\"David1@m.co\"],[\"David\",\"David3@m.co\",\"David4@m.co\"],[\"David\",\"David4@m.co\",\"David5@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\"],[\"David\",\"David1@m.co\",\"David2@m.co\"]]\\n\\nis this \\n[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]\\n\\nThere is David2@m.co in both the accounts, is this correct?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "How did you get this output? it prints everything in one entry for me: `[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]`"
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This is real Union and Find"
                    },
                    {
                        "username": "isamnagi",
                        "content": "Really hard, but break it into two( using the dfs solution).. building the graph... iterating it with dfs marking each email you visit while adding it to your mergedaccount.... All i can say is May Allah help you"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I believe the order of emails shouldnt  matter as long as they fall under the right name after merging\\nbut for some reason the testcases are sensitive to it.\\nSo instead of set, i used list to preserve the order so to speak \\nhowever when i run it here , it still messes up the order , despite working fine in my notebook\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def merge(considered,superset):\\n            for i in considered:\\n              if i in superset:return True \\n            return False\\n        def f(L):\\n            id = 0 \\n            hashmap = {}\\n            register = set()\\n            for i in L:\\n              name = i[0]\\n              if name not in register:\\n                register.add(name)\\n                hashmap[(name,id)]=set(i)\\n                hashmap[(name,id)].discard(name)\\n                id +=1\\n              else:\\n                merged = False\\n                for key in hashmap:\\n                  if key[0]==name and merge(i,hashmap[key]):\\n                    merged = True\\n                    hashmap[key].update(set(i))\\n                    hashmap[key].discard(name)\\n                if not merged:\\n                  hashmap[(name,id)]=set(i)\\n                  hashmap[(name,id)].discard(name)\\n                  id +=1\\n            Res =[]\\n            for i in hashmap:\\n              name =i[0]\\n              res =[name]\\n              res+=hashmap[i]\\n              Res.append(res)\\n            return Res   \\n        return f(accounts)\\n```"
                    }
                ]
            },
            {
                "id": 1769381,
                "content": [
                    {
                        "username": "LC_Binod",
                        "content": "Best problem I\\'ve ever encountered."
                    },
                    {
                        "username": "SG-C",
                        "content": "I suggest to block all accounts"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "18 minutes of coding + 4 minutes of debugging :)"
                    },
                    {
                        "username": "willus-mcgee",
                        "content": "Testcases allow for accounts to be in any order, but doesn\\'t seem to allow for emails within the accounts to be in any order. Does anyone else have this issue?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "This problem does not seem difficult at first glance. But I managed to notice that it requires DSU and really enjoyed applying it in a non standard way :)\nUsually it's about 0-n numbered nodes and edges, but here we have string sets."
                    },
                    {
                        "username": "kjers96",
                        "content": "Literally why one should always use only one email"
                    },
                    {
                        "username": "CaptainSam",
                        "content": "How is the output for the input\\n[[\"David\",\"David0@m.co\",\"David1@m.co\"],[\"David\",\"David3@m.co\",\"David4@m.co\"],[\"David\",\"David4@m.co\",\"David5@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\"],[\"David\",\"David1@m.co\",\"David2@m.co\"]]\\n\\nis this \\n[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]\\n\\nThere is David2@m.co in both the accounts, is this correct?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "How did you get this output? it prints everything in one entry for me: `[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]`"
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This is real Union and Find"
                    },
                    {
                        "username": "isamnagi",
                        "content": "Really hard, but break it into two( using the dfs solution).. building the graph... iterating it with dfs marking each email you visit while adding it to your mergedaccount.... All i can say is May Allah help you"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I believe the order of emails shouldnt  matter as long as they fall under the right name after merging\\nbut for some reason the testcases are sensitive to it.\\nSo instead of set, i used list to preserve the order so to speak \\nhowever when i run it here , it still messes up the order , despite working fine in my notebook\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def merge(considered,superset):\\n            for i in considered:\\n              if i in superset:return True \\n            return False\\n        def f(L):\\n            id = 0 \\n            hashmap = {}\\n            register = set()\\n            for i in L:\\n              name = i[0]\\n              if name not in register:\\n                register.add(name)\\n                hashmap[(name,id)]=set(i)\\n                hashmap[(name,id)].discard(name)\\n                id +=1\\n              else:\\n                merged = False\\n                for key in hashmap:\\n                  if key[0]==name and merge(i,hashmap[key]):\\n                    merged = True\\n                    hashmap[key].update(set(i))\\n                    hashmap[key].discard(name)\\n                if not merged:\\n                  hashmap[(name,id)]=set(i)\\n                  hashmap[(name,id)].discard(name)\\n                  id +=1\\n            Res =[]\\n            for i in hashmap:\\n              name =i[0]\\n              res =[name]\\n              res+=hashmap[i]\\n              Res.append(res)\\n            return Res   \\n        return f(accounts)\\n```"
                    }
                ]
            },
            {
                "id": 1718157,
                "content": [
                    {
                        "username": "LC_Binod",
                        "content": "Best problem I\\'ve ever encountered."
                    },
                    {
                        "username": "SG-C",
                        "content": "I suggest to block all accounts"
                    },
                    {
                        "username": "matthewjiao",
                        "content": "18 minutes of coding + 4 minutes of debugging :)"
                    },
                    {
                        "username": "willus-mcgee",
                        "content": "Testcases allow for accounts to be in any order, but doesn\\'t seem to allow for emails within the accounts to be in any order. Does anyone else have this issue?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "This problem does not seem difficult at first glance. But I managed to notice that it requires DSU and really enjoyed applying it in a non standard way :)\nUsually it's about 0-n numbered nodes and edges, but here we have string sets."
                    },
                    {
                        "username": "kjers96",
                        "content": "Literally why one should always use only one email"
                    },
                    {
                        "username": "CaptainSam",
                        "content": "How is the output for the input\\n[[\"David\",\"David0@m.co\",\"David1@m.co\"],[\"David\",\"David3@m.co\",\"David4@m.co\"],[\"David\",\"David4@m.co\",\"David5@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\"],[\"David\",\"David1@m.co\",\"David2@m.co\"]]\\n\\nis this \\n[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\"],[\"David\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]\\n\\nThere is David2@m.co in both the accounts, is this correct?"
                    },
                    {
                        "username": "dkochetov",
                        "content": "How did you get this output? it prints everything in one entry for me: `[[\"David\",\"David0@m.co\",\"David1@m.co\",\"David2@m.co\",\"David3@m.co\",\"David4@m.co\",\"David5@m.co\"]]`"
                    },
                    {
                        "username": "yyyc_0902",
                        "content": "This is real Union and Find"
                    },
                    {
                        "username": "isamnagi",
                        "content": "Really hard, but break it into two( using the dfs solution).. building the graph... iterating it with dfs marking each email you visit while adding it to your mergedaccount.... All i can say is May Allah help you"
                    },
                    {
                        "username": "Dr_Doofenshmirz",
                        "content": "I believe the order of emails shouldnt  matter as long as they fall under the right name after merging\\nbut for some reason the testcases are sensitive to it.\\nSo instead of set, i used list to preserve the order so to speak \\nhowever when i run it here , it still messes up the order , despite working fine in my notebook\\n```\\nclass Solution:\\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\\n        def merge(considered,superset):\\n            for i in considered:\\n              if i in superset:return True \\n            return False\\n        def f(L):\\n            id = 0 \\n            hashmap = {}\\n            register = set()\\n            for i in L:\\n              name = i[0]\\n              if name not in register:\\n                register.add(name)\\n                hashmap[(name,id)]=set(i)\\n                hashmap[(name,id)].discard(name)\\n                id +=1\\n              else:\\n                merged = False\\n                for key in hashmap:\\n                  if key[0]==name and merge(i,hashmap[key]):\\n                    merged = True\\n                    hashmap[key].update(set(i))\\n                    hashmap[key].discard(name)\\n                if not merged:\\n                  hashmap[(name,id)]=set(i)\\n                  hashmap[(name,id)].discard(name)\\n                  id +=1\\n            Res =[]\\n            for i in hashmap:\\n              name =i[0]\\n              res =[name]\\n              res+=hashmap[i]\\n              Res.append(res)\\n            return Res   \\n        return f(accounts)\\n```"
                    }
                ]
            }
        ]
    }
]