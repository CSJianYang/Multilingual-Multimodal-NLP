[
    {
        "title": "Count the Number of Beautiful Subarrays",
        "question_content": "You are given a 0-indexed integer array nums. In one operation, you can:\n\n\tChoose two different indices i and j such that 0 <= i, j < nums.length.\n\tChoose a non-negative integer k such that the kth bit (0-indexed) in the binary representation of nums[i] and nums[j] is 1.\n\tSubtract 2k from nums[i] and nums[j].\n\nA subarray is beautiful if it is possible to make all of its elements equal to 0 after applying the above operation any number of times.\nReturn the number of beautiful subarrays in the array nums.\nA subarray is a contiguous non-empty sequence of elements within an array.\n&nbsp;\nExample 1:\n\nInput: nums = [4,3,1,2,4]\nOutput: 2\nExplanation: There are 2 beautiful subarrays in nums: [4,3,1,2,4] and [4,3,1,2,4].\n- We can make all elements in the subarray [3,1,2] equal to 0 in the following way:\n  - Choose [3, 1, 2] and k = 1. Subtract 21 from both numbers. The subarray becomes [1, 1, 0].\n  - Choose [1, 1, 0] and k = 0. Subtract 20 from both numbers. The subarray becomes [0, 0, 0].\n- We can make all elements in the subarray [4,3,1,2,4] equal to 0 in the following way:\n  - Choose [4, 3, 1, 2, 4] and k = 2. Subtract 22 from both numbers. The subarray becomes [0, 3, 1, 2, 0].\n  - Choose [0, 3, 1, 2, 0] and k = 0. Subtract 20 from both numbers. The subarray becomes [0, 2, 0, 2, 0].\n  - Choose [0, 2, 0, 2, 0] and k = 1. Subtract 21 from both numbers. The subarray becomes [0, 0, 0, 0, 0].\n\nExample 2:\n\nInput: nums = [1,10,4]\nOutput: 0\nExplanation: There are no beautiful subarrays in nums.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t0 <= nums[i] <= 106",
        "solutions": [
            {
                "id": 3286372,
                "title": "java-c-python-prefix-xor",
                "content": "# **Intuition**\\nSimilar to the problem to count the subarrays with `sum = k`.\\nWe can record the prefix sum to solve it.\\n\\nHere we are counting the subarrays with `xor = 0`.\\nwe can record the prefix xor to solve it.\\n<br>\\n\\n# **Explanation**\\n`pre` records the prefix xor,\\nwhere `pre[i] = pre[i-1] ^ A[i]`.\\n\\n`dp` counts the frequency for prefix different value.\\nAt first `pre = 0`,\\nso we initilize `dp[0] = 1`.\\n\\nAs we iterate every `A[i]`,\\nwe update `pre ^= A[i]`,\\nthe number of current `dp[pre]`,\\nmeans the number prefix array with xor is `pre`,\\ncorresponding the number of subarray ending at `A[j]` with `xor = pre ^ pre = 0`.\\nso we update the result `res += dp[pre]` and `dp[pre] += 1`\\n\\nFinally we return `res`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public long beautifulSubarrays(int[] A) {\\n        HashMap<Integer, Integer> dp = new HashMap<>();\\n        dp.put(0, 1);\\n        int pre = 0;\\n        long res = 0;\\n        for (int a : A) {\\n            pre ^= a;\\n            int v = dp.getOrDefault(pre, 0);\\n            res += v;\\n            dp.put(pre, v + 1);\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    long long beautifulSubarrays(vector<int>& A) {\\n        unordered_map<int, int> dp{{0, 1}};\\n        long long res = 0, pre = 0;\\n        for (int a : A)\\n            res += dp[pre ^= a]++;\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def beautifulSubarrays(self, A):\\n        dp = Counter({0: 1})\\n        res = pre = 0\\n        for a in A:\\n            pre ^= a\\n            res += dp[pre]\\n            dp[pre] += 1\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long beautifulSubarrays(int[] A) {\\n        HashMap<Integer, Integer> dp = new HashMap<>();\\n        dp.put(0, 1);\\n        int pre = 0;\\n        long res = 0;\\n        for (int a : A) {\\n            pre ^= a;\\n            int v = dp.getOrDefault(pre, 0);\\n            res += v;\\n            dp.put(pre, v + 1);\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long beautifulSubarrays(vector<int>& A) {\\n        unordered_map<int, int> dp{{0, 1}};\\n        long long res = 0, pre = 0;\\n        for (int a : A)\\n            res += dp[pre ^= a]++;\\n        return res;\\n    }\\n```\n```py\\n    def beautifulSubarrays(self, A):\\n        dp = Counter({0: 1})\\n        res = pre = 0\\n        for a in A:\\n            pre ^= a\\n            res += dp[pre]\\n            dp[pre] += 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3286489,
                "title": "image-explanation-prefix-xor-complete-intuition",
                "content": "# Video Solution\\nhttps://youtu.be/8jx35mkivJ8\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/33e3605d-65a5-4696-a39a-99f3423e95bd_1678594403.6260314.png)\\n![image.png](https://assets.leetcode.com/users/images/2f7e0fdd-3764-4c8d-adfd-aaae3f8338e0_1678594417.845141.png)\\n![image.png](https://assets.leetcode.com/users/images/4706a235-877f-4448-ab43-4cfde6cf97ee_1678594440.4704385.png)\\n![image.png](https://assets.leetcode.com/users/images/8fd1008f-6671-4950-81eb-ec6d6cc06624_1678594448.2350805.png)\\n![image.png](https://assets.leetcode.com/users/images/966d528f-5076-4644-a67d-05c64d6b933a_1678594464.594322.png)\\n\\n\\n# Code\\n```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> prefXor(n+1, 0);\\n        \\n        for(int i=0;i<n;i++){\\n            prefXor[i+1] = prefXor[i] ^ nums[i];\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        mp[0] = 1;\\n        ll ans = 0;\\n        for(int i=1;i<=n;i++){\\n            if(mp[prefXor[i]]) ans += mp[prefXor[i]];\\n            mp[prefXor[i]]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> prefXor(n+1, 0);\\n        \\n        for(int i=0;i<n;i++){\\n            prefXor[i+1] = prefXor[i] ^ nums[i];\\n        }\\n        \\n        unordered_map<int, int> mp;\\n        mp[0] = 1;\\n        ll ans = 0;\\n        for(int i=1;i<=n;i++){\\n            if(mp[prefXor[i]]) ans += mp[prefXor[i]];\\n            mp[prefXor[i]]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286256,
                "title": "count-subarrays-with-zero-xor",
                "content": "\\n\\nBits in a beautiful subarray should appear even number of times. \\n    \\nTherefore, XOR of elements of a beautiful subarray should be zero.\\n    \\nCounting subarrays with a specific XOR in O(n) is a classic problem (you can find it by the name).\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        cnt = Counter({0: 1})\\n        for val in accumulate(nums, operator.xor):\\n            cnt[val] += 1\\n        return sum(v * (v - 1) // 2 for v in cnt.values())\\n```\\n\\n**C++**\\n```cpp\\nlong long beautifulSubarrays(vector<int>& nums) {\\n    unordered_map<int, int> cnt{{0, 1}};\\n    partial_sum(begin(nums), end(nums), begin(nums), bit_xor<>());\\n    return accumulate(begin(nums), end(nums), 0LL, [&](long long s, int n){ return s + cnt[n]++; });\\n}",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        cnt = Counter({0: 1})\\n        for val in accumulate(nums, operator.xor):\\n            cnt[val] += 1\\n        return sum(v * (v - 1) // 2 for v in cnt.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286469,
                "title": "explained-map-count-very-simple-easy-to-understand-solution",
                "content": "# Approach\\nThis is similar to the one - [subarray-sum-equals-k](https://leetcode.com/problems/subarray-sum-equals-k/). If you have not solve this before then go through that problem first.\\n\\n\\n\\nNow back to this problem, here in place of sum of sub array we need to \\nevaluate the XOR of the elements and check if the XOR value is same as \\npreviously seen XOR value.\\n\\nThis can be achieved by using a unordered map to keep storing the XOR\\nvalues count in the map and then calculate total subarray possible.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        unordered_map<int, long long> mp;\\n        long long ans = 0;\\n        int val = 0;\\n        mp[val] = 1;\\n        for(auto n: nums){\\n            val = val^n;\\n            mp[val]++;\\n        }\\n        for(auto m: mp){\\n            ans += ((m.second -1)*m.second)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        unordered_map<int, long long> mp;\\n        long long ans = 0;\\n        int val = 0;\\n        mp[val] = 1;\\n        for(auto n: nums){\\n            val = val^n;\\n            mp[val]++;\\n        }\\n        for(auto m: mp){\\n            ans += ((m.second -1)*m.second)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286435,
                "title": "prefix-xor-simple-video-explanation-comments",
                "content": "# Intuition\\nSimilar to the problem to count the subarrays with sum = k.\\nWe can record the prefix sum to solve it.\\n\\nHere we are counting the subarrays with xor = 0.\\nwe can record the prefix xor to solve it.\\n\\n\\n# Explanation\\npre records the prefix xor,\\nwhere pre[i] = pre[i-1] ^ A[i].\\n\\ndp counts the frequency for prefix different value.\\nAt first pre = 0,\\nso we initilize dp[0] = 1.\\n\\nAs we iterate every A[i],\\nwe update pre ^= A[i],\\nthe number of current dp[pre],\\nmeans the number prefix array with xor is pre,\\ncorresponding the number of subarray ending at A[j] with xor = pre ^ pre = 0.\\nso we update the result res += dp[pre] and dp[pre] += 1\\n\\nFinally we return res.\\n\\n# Approach\\n\\nhttps://youtu.be/rElX3T4tjvo\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long beautifulSubarrays(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n            \\n        int res = 0;\\n        map<int,int>mp;\\n        mp[res]++;\\n        \\n        long long count = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            res ^= arr[i];\\n            mp[res]++;\\n            count += mp[res]-1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long beautifulSubarrays(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n            \\n        int res = 0;\\n        map<int,int>mp;\\n        mp[res]++;\\n        \\n        long long count = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            res ^= arr[i];\\n            mp[res]++;\\n            count += mp[res]-1;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286439,
                "title": "2588-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Define the function beautifulSubarrays that takes a list of integers nums as input and returns an integer.\\n2. Initialize a variable res to 0 to keep track of the number of beautiful subarrays.\\n3. Get the length of the input list nums and store it in a variable n.\\n4. Initialize a list pre_xor with n+1 elements and fill it with zeros.\\n5. Set the first element of pre_xor to 0.\\n6. Initialize a list cnt with (1<<20) elements and fill it with zeros. This list will be used to count the number of occurrences of each prefix xor value.\\n7. Set the first element of cnt to 1, since the empty subarray has a prefix xor of 0.\\n8. Loop through the indices i in the range [1, n]:\\n    1. Compute the prefix xor value of the subarray nums[0:i] and store it in pre_xor[i].\\n    2. Update the res variable by adding the value of cnt[pre_xor[i]].\\n    3. Increment the value of cnt[pre_xor[i]].\\n9. Return the value of res.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        res = 0\\n        n = len(nums)\\n        pre_xor = [0] * (n+1)\\n        pre_xor[0]=0\\n        cnt = [0]*(1<<20)\\n        cnt[0] = 1\\n        \\n        for i in range(1,n+1):\\n            pre_xor[i] = pre_xor[i-1] ^ nums[i-1]\\n            res += cnt[pre_xor[i]]\\n            cnt[pre_xor[i]] += 1\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        res = 0\\n        n = len(nums)\\n        pre_xor = [0] * (n+1)\\n        pre_xor[0]=0\\n        cnt = [0]*(1<<20)\\n        cnt[0] = 1\\n        \\n        for i in range(1,n+1):\\n            pre_xor[i] = pre_xor[i-1] ^ nums[i-1]\\n            res += cnt[pre_xor[i]]\\n            cnt[pre_xor[i]] += 1\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286861,
                "title": "c-easy-prefix-xor",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        map<long long,long long> m;\\n        long long sum=0;\\n        long long cnt=0;\\n        m[0]=1;\\n        for(auto x:nums)\\n        {\\n            sum=sum^x;\\n            cnt+=m[sum];\\n            m[sum]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        map<long long,long long> m;\\n        long long sum=0;\\n        long long cnt=0;\\n        m[0]=1;\\n        for(auto x:nums)\\n        {\\n            sum=sum^x;\\n            cnt+=m[sum];\\n            m[sum]++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286613,
                "title": "xor-map-c-easy-to-understand",
                "content": "# Explanation\\nLet\\'s consider the first testcase: \\n\\n```   \\n[4, 3, 1, 2, 4]\\n```\\nBinary representation:\\n\\n```\\n[100, 011, 001, 010, 100]\\n```\\n\\nSubtract 2^k from ```nums[i]``` and ```nums[j]```.\\n\\nIt means, in binary representation, ```kth``` position of ```nums[i]``` and ```nums[j]```  will be zero.\\n\\nAs we need all numbers in subarray to be ```Zero```, it indicates that, in binary form, all the position have only ```even``` no of ```1```. \\n\\nSo, ```XOR``` of all numbers in that subarray will be ```0```.\\n\\n\\nFinally  we have to calculate how many subarray are there, that ```XOR``` of all numbers of that subarray is equal to Zero.\\n\\nFor calculating that I have used ```HashMap```.  \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0,x=0;\\n        map<long long, long long>mp;\\n        mp[0]++;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            x = x^nums[i];\\n            \\n            if(mp[x]){\\n                ans+=mp[x];\\n            }\\n            mp[x]++;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```   \\n[4, 3, 1, 2, 4]\\n```\n```\\n[100, 011, 001, 010, 100]\\n```\n```nums[i]```\n```nums[j]```\n```kth```\n```nums[i]```\n```nums[j]```\n```Zero```\n```even```\n```1```\n```XOR```\n```0```\n```XOR```\n```HashMap```\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0,x=0;\\n        map<long long, long long>mp;\\n        mp[0]++;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            x = x^nums[i];\\n            \\n            if(mp[x]){\\n                ans+=mp[x];\\n            }\\n            mp[x]++;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286473,
                "title": "c-clean-easy-to-understand-code-map",
                "content": "![image](https://assets.leetcode.com/users/images/2b20156a-5aba-4088-a525-1f3e4a000066_1678594244.9609652.png)\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long beautifulSubarrays(vector<int>& nums) {\\n\\t\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\tlong long ans = 0, prefix = 0;\\n\\n\\t\\t\\t\\tunordered_map<int, long long> freq{{0, 1}};\\n\\n\\t\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\t\\tprefix ^= nums[i];\\n\\n\\t\\t\\t\\t\\tif (freq.count(prefix)) {\\n\\t\\t\\t\\t\\t\\tans += freq[prefix];\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfreq[prefix]++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long beautifulSubarrays(vector<int>& nums) {\\n\\t\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\tlong long ans = 0, prefix = 0;\\n\\n\\t\\t\\t\\tunordered_map<int, long long> freq{{0, 1}",
                "codeTag": "Java"
            },
            {
                "id": 3286295,
                "title": "xor-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n\\n        long long ans=0;\\n        unordered_map<int,int> mp;\\n        mp[0]=1;\\n\\n        int val=0;\\n        for(auto ele:nums){\\n            val = val^ele;\\n\\n            if(mp.find(val) != mp.end()){\\n                ans+= mp[val];\\n            }\\n            mp[val]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n\\n        long long ans=0;\\n        unordered_map<int,int> mp;\\n        mp[0]=1;\\n\\n        int val=0;\\n        for(auto ele:nums){\\n            val = val^ele;\\n\\n            if(mp.find(val) != mp.end()){\\n                ans+= mp[val];\\n            }\\n            mp[val]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287128,
                "title": "simple-c-solution-using-hashing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we can observe the subarray which have xor value 0 as Beutiful Subarray. because at one operation we can remove 2 bits and and this way only even number of bits at same position can become zero hence xor of subarray should be 0.This problem is similiar to finding subarray of sum 0.Here we will use a map and prefix sum to count the beutiful sub array in O(N).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Intialise ans as 0, c (current xor) as 0 and initialise a unordered map.\\n2. Traverse through the vector. Take xor and check if xor value is present or not.\\n3. If xor is present then just add mp[xor value] to ans.\\n4. Increase mp[xor value]++ at end of loop everytime.\\n5. Return the ans.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        long long ans=0;\\n        unordered_map<int,int> mp;\\n        int c=0;\\n        mp[c]++;\\n        for(int i=0;i<n;i++)\\n        {\\n            c=c^nums[i];\\n            if(mp.count(c)==1)\\n            {\\n                ans+=(mp[c]);\\n            }\\n            mp[c]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        long long ans=0;\\n        unordered_map<int,int> mp;\\n        int c=0;\\n        mp[c]++;\\n        for(int i=0;i<n;i++)\\n        {\\n            c=c^nums[i];\\n            if(mp.count(c)==1)\\n            {\\n                ans+=(mp[c]);\\n            }\\n            mp[c]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286633,
                "title": "video-explain-2-approaches-o-n-log-n-c-map",
                "content": "If you don\\'t know hindi skip video and read the blog below :) ,Video Explanation in Hindi :-[https://youtu.be/-GC29IuP13M]()\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis type of problems are really famous where we sometimes subarray with \"sum multiple of x\" ,  or \"XOR to be K\" etc.\\n\\nThere are two approach I am going to share  \\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\nSince the numbers can be stored in 32 bit easily , we can use a 32 bit frequency array to store the count of each bit  ,\\nWhen we are ith index , we update the frequency bit arrray ,\\n* we make fre[j] bit = fre[j]%2 , but why ?\\n   - because we can form pair of two so bits remaining are remainder with 2.\\n\\nNow we check if that \"frequency\" array has already occured in past , if it is occured in past this means all the avlues in between have even frequecy , and we are able to make pairs and delete the bits .\\nSo **number** of good **subarrays** is **count** of that **frequency** array **till now** .\\n   \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n* 32 * log n) ~ O(n log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n**Approach 1**\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans = 0;\\n        \\n        map<vector<int>,long long>count;\\n        vector<int>fre(32);\\n\\n        //since the values can be fit in 32 bit \\n        //we can maintain one frequency array for bits\\n        //count will store no of time in past we have same frerquency \\n        //array\\n        count[fre]++;\\n        \\n        for(auto&x:nums){\\n            \\n            string temp = bitset<32>(x).to_string();\\n            reverse(temp.begin(),temp.end());\\n            //updating the bits frequency \\n            for(int i=0;i<32;++i){\\n                if(temp[i] == \\'1\\'){\\n                    fre[i]++;\\n                }\\n                //we are doing this because bits occuring even no of times\\n                //can be deleted \\n                fre[i]%=2;\\n            }\\n            \\n            //if current frequency array have already occured in past \\n            //this means all the values in between have even frequency bits \\n            //and those many beautiful subarrays are formed\\n            ans += count[fre];\\n            count[fre]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n \\n# Approach 2\\nyou can get a hint that in XOR we do same operation\\n        if we have two set bits then XOR of them will remove that bit\\n        so this whole problem comes down to finding number of **subarrays** with \\n        **XOR** values to be **0**\\n\\nWe will do the same , we will maitain one **cur** which store the xor value of elements till now ,  and one count array which store how many times the XOR value (cur) has already occured ,\\n-- if **cur** has occured in **past** this means that values in between have **XOR = 0**.So we have those subarrays with XOR = 0\\n\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n) -- due to map - We can use count array for O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans = 0;\\n        \\n        map<int,long long>count;\\n         \\n        //you can get a hint that in XOR we do same operation\\n        //if we have two set bits then XOR of them will remove that bit\\n        //so this whole problem comes down to finding number of subarrays with \\n        //XOR values to be \\'0\\'\\n        count[0]++;\\n        int cur = 0;\\n        for(auto&x:nums){\\n            \\n            cur^=x;\\n\\n            ans += count[cur];\\n            count[cur]++;\\n        }\\n        \\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans = 0;\\n        \\n        map<vector<int>,long long>count;\\n        vector<int>fre(32);\\n\\n        //since the values can be fit in 32 bit \\n        //we can maintain one frequency array for bits\\n        //count will store no of time in past we have same frerquency \\n        //array\\n        count[fre]++;\\n        \\n        for(auto&x:nums){\\n            \\n            string temp = bitset<32>(x).to_string();\\n            reverse(temp.begin(),temp.end());\\n            //updating the bits frequency \\n            for(int i=0;i<32;++i){\\n                if(temp[i] == \\'1\\'){\\n                    fre[i]++;\\n                }\\n                //we are doing this because bits occuring even no of times\\n                //can be deleted \\n                fre[i]%=2;\\n            }\\n            \\n            //if current frequency array have already occured in past \\n            //this means all the values in between have even frequency bits \\n            //and those many beautiful subarrays are formed\\n            ans += count[fre];\\n            count[fre]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans = 0;\\n        \\n        map<int,long long>count;\\n         \\n        //you can get a hint that in XOR we do same operation\\n        //if we have two set bits then XOR of them will remove that bit\\n        //so this whole problem comes down to finding number of subarrays with \\n        //XOR values to be \\'0\\'\\n        count[0]++;\\n        int cur = 0;\\n        for(auto&x:nums){\\n            \\n            cur^=x;\\n\\n            ans += count[cur];\\n            count[cur]++;\\n        }\\n        \\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3286278,
                "title": "simple-java-solution-using-xor-operation",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        int n=nums.length;\\n        long ans = 0;\\n        int b[] = new int[n];\\n        int m=0;\\n        HashMap<Integer,Integer> nm = new HashMap<>();\\n        b[0] = nums[0];\\n        for (int i = 1; i < n; i++)\\n        {\\n            b[i] = b[i - 1] ^ nums[i];\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            int xx = m^b[i];\\n            ans=ans+(!nm.containsKey(xx) ? 0 : ((long)nm.get(xx)));\\n            if(b[i] == m)\\n            {\\n                ans++;\\n            }\\n            if(nm.containsKey(b[i]))\\n            {\\n                nm.put(b[i], nm.get(b[i]) + 1);\\n            }\\n            else\\n            {\\n                nm.put(b[i], 1);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        int n=nums.length;\\n        long ans = 0;\\n        int b[] = new int[n];\\n        int m=0;\\n        HashMap<Integer,Integer> nm = new HashMap<>();\\n        b[0] = nums[0];\\n        for (int i = 1; i < n; i++)\\n        {\\n            b[i] = b[i - 1] ^ nums[i];\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            int xx = m^b[i];\\n            ans=ans+(!nm.containsKey(xx) ? 0 : ((long)nm.get(xx)));\\n            if(b[i] == m)\\n            {\\n                ans++;\\n            }\\n            if(nm.containsKey(b[i]))\\n            {\\n                nm.put(b[i], nm.get(b[i]) + 1);\\n            }\\n            else\\n            {\\n                nm.put(b[i], 1);\\n            }\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292517,
                "title": "can-someone-explain-why-0-0-returns-3",
                "content": "Since the i,j should be different, isn\\'t the answer 1 instead of 3?",
                "solutionTags": [
                    "Python3"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3287139,
                "title": "python-3-2-lines-counter-and-accumulate-t-m-975-ms-36-mb",
                "content": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        \\n        ctr = Counter(accumulate(nums, xor, initial = 0))\\n\\n        return sum (n*(n-1) for n in ctr.values())//2\\n\\n```\\n[https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/913653762/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*NlogN*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        \\n        ctr = Counter(accumulate(nums, xor, initial = 0))\\n\\n        return sum (n*(n-1) for n in ctr.values())//2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286843,
                "title": "video-explanation-building-the-solution-step-by-step-from-intuition",
                "content": "# Explanation\\n\\nhttps://youtu.be/wPD_n7UWuDM\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/wPD_n7UWuDM)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<vector<int>> prefix (n+1, vector<int>(20, 0));\\n        for (int j = 1; j <= n; j ++) {\\n            prefix[j] = prefix[j-1];\\n            \\n            for (int bit = 0; bit < 20; bit ++) {\\n                if ((1 << bit) & nums[j-1]) prefix[j][bit] ++;\\n            }\\n            for (int bit = 0; bit < 20; bit ++) \\n                prefix[j][bit] %= 2;\\n        }\\n        \\n        map<vector<int>, int> frq;\\n        long long result = 0;\\n        for (int j = 0; j <= n; j ++) {\\n            result += frq[prefix[j]];\\n            frq[prefix[j]] ++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<vector<int>> prefix (n+1, vector<int>(20, 0));\\n        for (int j = 1; j <= n; j ++) {\\n            prefix[j] = prefix[j-1];\\n            \\n            for (int bit = 0; bit < 20; bit ++) {\\n                if ((1 << bit) & nums[j-1]) prefix[j][bit] ++;\\n            }\\n            for (int bit = 0; bit < 20; bit ++) \\n                prefix[j][bit] %= 2;\\n        }\\n        \\n        map<vector<int>, int> frq;\\n        long long result = 0;\\n        for (int j = 0; j <= n; j ++) {\\n            result += frq[prefix[j]];\\n            frq[prefix[j]] ++;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286250,
                "title": "java-subarraysum-xor-o-n-explained",
                "content": "# Intuition\\nSimilar problem,  [LC560 Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/). Make k = 0.\\n\\nQuick recap\\n```\\nrangeSum(i, j) = prefixSum[j] - prefixSum[i];\\n\\nIf want 0 sum, for prefixSum[j], find all previous prefixSum[i];\\n\\nTo quickly find, use  HashMap<PrefixSum, Freq> map\\n\\n```\\nCode template\\n```java\\n\\tprefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n\\tMap<Integer, Integer> counter = new HashMap<>();\\n\\tfor (int i = 0; i < prefixSum.length; i++) {\\n\\t\\tint left = prefixSum[i] - k; // k = 0\\n\\t\\tres += counter.getOrDefault(left, 0);\\n\\t\\tcounter.put(prefixSum[i], counter.getOrDefault(prefixSum[i], 0) + 1);\\n\\t}\\n        \\n```\\n\\n---\\n\\nWhy XOR works ?\\n```\\na^ b = c ===> c ^ b = a\\n\\na1 ^ a2 ^ ... an = X      ===>  a1 = X ^ (a2 ^ .... an)\\n```\\n\\n# Algorithm\\n\\n1. generate prefix xor array\\n2. for p[i] in prefix array:\\n\\ta. find same value in map and update result\\n\\tb. update map with p[i]\\n\\t\\n\\t\\n# Code\\n```java\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        int n = nums.length;\\n        int[] prefix = new int[n];\\n        prefix[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] ^ nums[i];\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        \\n        long ret = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int curr = prefix[i];\\n            ret += map.getOrDefault(curr, 0);\\n            map.put(curr, map.getOrDefault(curr, 0) + 1);\\n        }\\n        return ret;\\n    }   \\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nrangeSum(i, j) = prefixSum[j] - prefixSum[i];\\n\\nIf want 0 sum, for prefixSum[j], find all previous prefixSum[i];\\n\\nTo quickly find, use  HashMap<PrefixSum, Freq> map\\n\\n```\n```java\\n\\tprefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n\\tMap<Integer, Integer> counter = new HashMap<>();\\n\\tfor (int i = 0; i < prefixSum.length; i++) {\\n\\t\\tint left = prefixSum[i] - k; // k = 0\\n\\t\\tres += counter.getOrDefault(left, 0);\\n\\t\\tcounter.put(prefixSum[i], counter.getOrDefault(prefixSum[i], 0) + 1);\\n\\t}\\n        \\n```\n```\\na^ b = c ===> c ^ b = a\\n\\na1 ^ a2 ^ ... an = X      ===>  a1 = X ^ (a2 ^ .... an)\\n```\n```java\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        int n = nums.length;\\n        int[] prefix = new int[n];\\n        prefix[0] = nums[0];\\n        for (int i = 1; i < n; i++) {\\n            prefix[i] = prefix[i - 1] ^ nums[i];\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0, 1);\\n        \\n        long ret = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int curr = prefix[i];\\n            ret += map.getOrDefault(curr, 0);\\n            map.put(curr, map.getOrDefault(curr, 0) + 1);\\n        }\\n        return ret;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292832,
                "title": "prefix-xor-map-time-o-n-worst-case-o-n-2-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long int ans = 0,x=0;\\n        unordered_map<long long int,long long int> mp;\\n        mp[0]++;\\n        for(auto &i: nums){\\n            x ^= i;\\n            if(mp.count(x)){\\n                ans += mp[x];\\n            }\\n            mp[x]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long int ans = 0,x=0;\\n        unordered_map<long long int,long long int> mp;\\n        mp[0]++;\\n        for(auto &i: nums){\\n            x ^= i;\\n            if(mp.count(x)){\\n                ans += mp[x];\\n            }\\n            mp[x]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288318,
                "title": "go-python-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc beautifulSubarrays(nums []int) int64 {\\n    counter := make(map[int]int)\\n    counter[0] = 1\\n    answer := 0\\n    xor := 0\\n    for _,num := range(nums){\\n        xor^=num\\n        answer+=counter[xor]\\n        counter[xor]+=1\\n    }\\n    return int64(answer)\\n}\\n```\\n```python []\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        counter = defaultdict(int)\\n        counter[0] = 1\\n        answer = 0\\n        xor = 0\\n        for num in nums:\\n            xor^=num\\n            answer+=counter[xor]\\n            counter[xor]+=1\\n        return answer\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```golang []\\nfunc beautifulSubarrays(nums []int) int64 {\\n    counter := make(map[int]int)\\n    counter[0] = 1\\n    answer := 0\\n    xor := 0\\n    for _,num := range(nums){\\n        xor^=num\\n        answer+=counter[xor]\\n        counter[xor]+=1\\n    }\\n    return int64(answer)\\n}\\n```\n```python []\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        counter = defaultdict(int)\\n        counter[0] = 1\\n        answer = 0\\n        xor = 0\\n        for num in nums:\\n            xor^=num\\n            answer+=counter[xor]\\n            counter[xor]+=1\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286326,
                "title": "easy-short-efficient-clean-code",
                "content": "Think of any subarray \\'arr\\'. Think of any bit position \\'i\\'.\\nIf in arr, the number of elements having bit at pos i set is odd, then regardless of how many operations you do (including none), there will exactly be 1 element left with its bit at i set. How can we quickly check the parity of the occurances of \\'1\\' at a given i? Use xor.\\n\\nSo for any subarray, it can be made beautiful, if each bit position can be made zero, meaning xor of each bit position must be zero, meaning xor of all the elements of the subarray must be zero. So, all that remains is to find count of subarrays having xcor zero.\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll beautifulSubarrays(const vector<int>&v) {\\n        ll sz=v.size(), ans=0;\\n        unordered_map<ll,ll>ump={{0, 1}};\\n        for(ll i=0, xo=0;i<sz;++i){\\n            xo^=v[i];\\n            ans+=ump[xo]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll beautifulSubarrays(const vector<int>&v) {\\n        ll sz=v.size(), ans=0;\\n        unordered_map<ll,ll>ump={{0, 1}};\\n        for(ll i=0, xo=0;i<sz;++i){\\n            xo^=v[i];\\n            ans+=ump[xo]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634617,
                "title": "short-easy-java-and-python-solutions",
                "content": "##### Python \\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        count = 0\\n        xor = 0\\n        d = defaultdict(int)\\n        d[0] = 1\\n        \\n        for num in nums:\\n            xor ^= num\\n            \\n            count += d[xor]\\n            \\n            d[xor] += 1\\n            \\n        return count;\\n```\\n\\n##### Java 1st\\n\\n```\\n        public long beautifulSubarrays(int[] nums) {\\n        long count = 0;\\n        int xor = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        map.put(0,1);\\n\\t\\t\\n        for(int num : nums){\\n            xor = xor ^ num;\\n            \\n            count += (long)map.getOrDefault(xor,0); \\n            \\n            map.put(xor , map.getOrDefault(xor,0) + 1);\\n        }\\n        return count;\\n    }\\n```\\n##### 2nd\\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        long count = 0;\\n        int xor = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        map.put(0,1);\\n        \\n        for(int num : nums){\\n            count += map.merge(xor ^= num, 1, Integer::sum)-1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        count = 0\\n        xor = 0\\n        d = defaultdict(int)\\n        d[0] = 1\\n        \\n        for num in nums:\\n            xor ^= num\\n            \\n            count += d[xor]\\n            \\n            d[xor] += 1\\n            \\n        return count;\\n```\n```\\n        public long beautifulSubarrays(int[] nums) {\\n        long count = 0;\\n        int xor = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        map.put(0,1);\\n\\t\\t\\n        for(int num : nums){\\n            xor = xor ^ num;\\n            \\n            count += (long)map.getOrDefault(xor,0); \\n            \\n            map.put(xor , map.getOrDefault(xor,0) + 1);\\n        }\\n        return count;\\n    }\\n```\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        long count = 0;\\n        int xor = 0;\\n        Map<Integer,Integer> map = new HashMap<>();\\n        map.put(0,1);\\n        \\n        for(int num : nums){\\n            count += map.merge(xor ^= num, 1, Integer::sum)-1;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465642,
                "title": "python-easy-to-understand-beats-72-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAn array is beautiful if xor sum of the array is zero\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe store all the encountered xor sums in a hash map. Whenever we encounter a xor sum which is present in the map, it means that the xor sum between the first encounter and now is zero. We just keep track of the count afterwards\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for te xor sum mapxo\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python []\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        xorMap, xorSum, count = defaultdict(int), 0, 0\\n        xorMap[0] = 1\\n        for idx in range(len(nums)):\\n            xorSum ^= nums[idx]\\n            if xorSum in xorMap:\\n                count += xorMap[xorSum]\\n            xorMap[xorSum] += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```python []\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        xorMap, xorSum, count = defaultdict(int), 0, 0\\n        xorMap[0] = 1\\n        for idx in range(len(nums)):\\n            xorSum ^= nums[idx]\\n            if xorSum in xorMap:\\n                count += xorMap[xorSum]\\n            xorMap[xorSum] += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322971,
                "title": "c-hashmap-bit-manipulation-faster-easy-to-understand",
                "content": "* ***Using Hashmap && Bit Manipulation***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        long long ans = 0;\\n        \\n        // declare an unordered map\\n        \\n        unordered_map<int, int> mp;\\n        \\n        // insert 0 with the frequncy of 1\\n        \\n        mp[0] = 1;\\n        \\n        int curr_xorr = 0;\\n        \\n        // traverse over the nums\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // find xorr\\n            \\n            curr_xorr = (curr_xorr ^ nums[i]);\\n            \\n            // if curr_xorr exit in map then update ans\\n            \\n            if(mp.count(curr_xorr))\\n            {\\n                ans += mp[curr_xorr];\\n            }\\n            \\n            // increment the freq of curr_xorr\\n            \\n            mp[curr_xorr]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        long long ans = 0;\\n        \\n        // declare an unordered map\\n        \\n        unordered_map<int, int> mp;\\n        \\n        // insert 0 with the frequncy of 1\\n        \\n        mp[0] = 1;\\n        \\n        int curr_xorr = 0;\\n        \\n        // traverse over the nums\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // find xorr\\n            \\n            curr_xorr = (curr_xorr ^ nums[i]);\\n            \\n            // if curr_xorr exit in map then update ans\\n            \\n            if(mp.count(curr_xorr))\\n            {\\n                ans += mp[curr_xorr];\\n            }\\n            \\n            // increment the freq of curr_xorr\\n            \\n            mp[curr_xorr]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301947,
                "title": "c-dp-faster-90-2-lines",
                "content": "**Code** \\u2705\\n\\n```c++\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums, long long res = 0, int calc = 0) {\\n        unordered_map<int, int> cache; cache[0] = 1;\\n        for (auto num: nums) calc ^= num, res += cache[calc]++;\\n        return res;\\n    }\\n};\\n```\\n\\n**Previous Attempt** ( Gets TLE \\u274C)\\n\\n```c++\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums, long long res = 0) {\\n        for (int i = 0; i < nums.size(); i++) \\n            for (int j = i, calc = 0; j < nums.size(); j++) {\\n                calc ^= nums[j];\\n                if (calc == 0) res++;\\n            }\\n        return res;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums, long long res = 0, int calc = 0) {\\n        unordered_map<int, int> cache; cache[0] = 1;\\n        for (auto num: nums) calc ^= num, res += cache[calc]++;\\n        return res;\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums, long long res = 0) {\\n        for (int i = 0; i < nums.size(); i++) \\n            for (int j = i, calc = 0; j < nums.size(); j++) {\\n                calc ^= nums[j];\\n                if (calc == 0) res++;\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297093,
                "title": "bit-manipulation-xor-easy-to-undertsand",
                "content": "# Intuition\\nPrefixSum, Similar to count subarry sum to zeros.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nXOR operation with every number. Keep track of how many times XOR has appeared (frequency). Add the related result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar beautifulSubarrays = function(nums) {\\n    let res = 0\\n    let map = new Map();\\n    map.set(0, 1);\\n    let xor = 0;\\n    for(let no of nums) {\\n        xor = xor ^ no;\\n        if(map.has(xor)) {\\n            res = res + map.get(xor);\\n            map.set(xor, map.get(xor) + 1)\\n        } else {\\n            map.set(xor, 1)\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar beautifulSubarrays = function(nums) {\\n    let res = 0\\n    let map = new Map();\\n    map.set(0, 1);\\n    let xor = 0;\\n    for(let no of nums) {\\n        xor = xor ^ no;\\n        if(map.has(xor)) {\\n            res = res + map.get(xor);\\n            map.set(xor, map.get(xor) + 1)\\n        } else {\\n            map.set(xor, 1)\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3292414,
                "title": "map-prefix-xor-6-lines-easy-cpp-solution",
                "content": "\\n\\tlong long beautifulSubarrays(vector<int>& nums) {\\n\\t\\t\\tlong long res = 0,a=0; // res is resultant answer and a is cur prefix XOR\\n\\t\\t\\tmap<int ,int> mp;      // for keeping track of previous XOR\\'s\\n\\t\\t\\tmp[a] = 1;             // initially setting count of 0 as 1;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\ta = a^nums[i];\\n\\t\\t\\t\\tres+= mp[a];        \\n\\t\\t\\t\\tmp[a]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "solutionTags": [],
                "code": "\\n\\tlong long beautifulSubarrays(vector<int>& nums) {\\n\\t\\t\\tlong long res = 0,a=0; // res is resultant answer and a is cur prefix XOR\\n\\t\\t\\tmap<int ,int> mp;      // for keeping track of previous XOR\\'s\\n\\t\\t\\tmp[a] = 1;             // initially setting count of 0 as 1;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\ta = a^nums[i];\\n\\t\\t\\t\\tres+= mp[a];        \\n\\t\\t\\t\\tmp[a]++;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3289355,
                "title": "using-xor-simplest-way-8line-of-codes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$ \\n\\n- Space complexity:\\n-  $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n      unordered_map<int,int>mp;\\n      mp[0]++;\\n      int nk=0;\\n        for(int i=0;i<n;i++){\\n          nk=nk^nums[i];\\n          mp[nk]++;\\n          ans+=mp[nk]-1;\\n\\n        }\\n      \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n      unordered_map<int,int>mp;\\n      mp[0]++;\\n      int nk=0;\\n        for(int i=0;i<n;i++){\\n          nk=nk^nums[i];\\n          mp[nk]++;\\n          ans+=mp[nk]-1;\\n\\n        }\\n      \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288167,
                "title": "count-the-number-of-subarray-whose-xor-is-zero-c",
                "content": "# Intuition\\nsubtracting the 2^k from nums[i] & nums[j] is similar operation to XOR of two nums. So, find the subarray whose xor is zero.\\n\\n# Complexity\\n- Time complexity : O(N)\\n\\n\\n- Space complexity : O(N)\\n** **\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        ll ans = 0, XOR = 0, n = nums.size();\\n        unordered_map<ll, ll> mp;\\n        for(int i = 0; i < n; i++) {\\n            XOR ^= nums[i];\\n            if(mp.find(XOR) != mp.end()) {\\n                ans += mp[XOR];\\n            }\\n            if(XOR == 0) ans++;\\n            mp[XOR]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        ll ans = 0, XOR = 0, n = nums.size();\\n        unordered_map<ll, ll> mp;\\n        for(int i = 0; i < n; i++) {\\n            XOR ^= nums[i];\\n            if(mp.find(XOR) != mp.end()) {\\n                ans += mp[XOR];\\n            }\\n            if(XOR == 0) ans++;\\n            mp[XOR]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288066,
                "title": "java-prefix-xor",
                "content": "```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        int[] map = new int[2_000_001];\\n        map[0] = 1;\\n        int preXor = 0;\\n        long answer = 0;\\n        for (int num : nums) {\\n            preXor ^= num;\\n            answer += map[preXor];\\n            map[preXor]++;\\n        }\\n        return answer;\\n    }\\n}\\n\\n\\n/*\\n\\n    a beatiful subarray will have bit wise XOR of (0)\\n    \\n\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        int[] map = new int[2_000_001];\\n        map[0] = 1;\\n        int preXor = 0;\\n        long answer = 0;\\n        for (int num : nums) {\\n            preXor ^= num;\\n            answer += map[preXor];\\n            map[preXor]++;\\n        }\\n        return answer;\\n    }\\n}\\n\\n\\n/*\\n\\n    a beatiful subarray will have bit wise XOR of (0)\\n    \\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287713,
                "title": "swift-solution-using-hashmap-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    func beautifulSubarrays(_ nums: [Int]) -> Int {\\n        var res = 0\\n        var subres = 0\\n        var map: [Int: Int] = [0: 1]\\n\\n        for i in 0..<nums.count {\\n            subres ^= nums[i]\\n            res += map[subres, default: 0]\\n            map[subres, default: 0] += 1\\n        }\\n\\n        return res\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func beautifulSubarrays(_ nums: [Int]) -> Int {\\n        var res = 0\\n        var subres = 0\\n        var map: [Int: Int] = [0: 1]\\n\\n        for i in 0..<nums.count {\\n            subres ^= nums[i]\\n            res += map[subres, default: 0]\\n            map[subres, default: 0] += 1\\n        }\\n\\n        return res\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286779,
                "title": "java-xor-solution-with-comments-simple-and-clean-code",
                "content": "\\n\\n# Approach\\nThis question is similar to count subarray with sum s, instead of storing prefix sum we need to store prefix xor.\\n\\n# For reference:\\n\\nhttps://leetcode.com/problems/subarray-sum-equals-k/\\nyou can refer to this question for better understanding of this solution, as the approach for counting subarray is same.\\n\\n# Complexity\\n- Time complexity:\\n```\\no(n)\\n```\\n\\n- Space complexity:\\n```\\no(n)\\n```\\n\\n# Code\\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        int n = nums.length;\\n        \\n       \\n        int sum = 0;\\n        long count = 0;\\n        // We will store the frequency of prefix xor\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        freq.put(0 , 1);\\n        \\n        for(int i = 0; i < n ;i++){\\n            // prefix xor\\n            sum ^= nums[i];\\n            if(freq.containsKey(sum)){ \\n\\n            //here we are checking that whether the same prefix xor\\n            // occured or not, if yes then we increase the count to\\n            // the freq \\n\\n                count += freq.get(sum);\\n                \\n            }\\n            freq.put(sum , freq.getOrDefault(sum , 0) + 1);\\n        }\\n        \\n       \\n       return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\no(n)\\n```\n```\\no(n)\\n```\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        int n = nums.length;\\n        \\n       \\n        int sum = 0;\\n        long count = 0;\\n        // We will store the frequency of prefix xor\\n        Map<Integer, Integer> freq = new HashMap<>();\\n        freq.put(0 , 1);\\n        \\n        for(int i = 0; i < n ;i++){\\n            // prefix xor\\n            sum ^= nums[i];\\n            if(freq.containsKey(sum)){ \\n\\n            //here we are checking that whether the same prefix xor\\n            // occured or not, if yes then we increase the count to\\n            // the freq \\n\\n                count += freq.get(sum);\\n                \\n            }\\n            freq.put(sum , freq.getOrDefault(sum , 0) + 1);\\n        }\\n        \\n       \\n       return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286549,
                "title": "count-sub-arrays-with-xor-equal-to-0-with-intuition-o-n-time-o-n-space",
                "content": "Count sub-arrays with XOR equal to 0 | O(n) time and O(1) space \\n\\n\\n# Intuition\\n\\nThis problem is a rephrased version of the problem count the number of sub-arrays with given XOR k where k = 0.\\n\\nObservations:\\n1. We are only allowed to subtract 2^k if the kth bit in any two numbers in the sub-arrays is 1. This can also be said in a way, if the XOR of the kth bit of any 2 numbers in the array is 0, then either kth bit was 1 or 0 in both the numbers. If it was 1 then we can remove the kth bit by substracting 2^k from both the numbers. Else if the bit was 0 we dont need to do anything.\\n2. If the XOR of the sub-array, is not equal to 0, then that sub-array cannot be reduced to 0. If the sub-arrary xor is not equal to 0, then we are sure that some bits in a number cannot be paired with any other number in the sub-array, because then the XOR of these bits would be 0.\\n\\nLet\\'s see this with an example\\n```\\nnums       = [3, 1, 2]\\nprefix_xor = [3, 2, 0] \\n\\nBit representation:\\n\\n4 2 1\\n-----\\n0 1 1 -> 3\\n0 0 1 -> 1\\n0 1 0 -> 2\\n-----\\n0 0 0 -> 0(XOR)\\n\\nXOR = 0\\n\\nObserve, that all the set bits can be paired and hence all of them can be \\nremoved by subtracting 2^k. Thus, the sub-array [3, 1, 2] can be reduced \\nto zero in some number of operations.\\n\\nBut, if\\nnums       = [3, 1, 4]\\nprefix_xor = [3, 2, 7]\\n\\nBit representation:\\n\\n4 2 1\\n-----\\n0 1 1 -> 3\\n0 0 1 -> 1\\n1 0 0 -> 4\\n-----\\n1 1 0 -> 7(XOR)\\n\\n2 bits here cannot be paired with among any of the numbers, and hence will \\nbe set in the final XOR. Thus, array cannot be reduced to 0 as these 2\\nbits cannot be removed.\\n```\\n\\n\\n# Approach\\n\\nThe problem then simplifies to finding all the sub-arrays with XOR equal to 0.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity:  $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution(object):\\n    def beautifulSubarrays(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        prefix = nums[0]\\n        hashmap = defaultdict(int)\\n        hashmap[0] = 1\\n        \\n        cnt = 0\\n        \\n        for i in xrange(0, len(nums)):\\n            if i>0: prefix = nums[i] ^ prefix\\n            if prefix in hashmap:\\n               # print(i, prefix)\\n               cnt += hashmap[prefix]\\n            hashmap[prefix] += 1\\n            \\n        return cnt\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nnums       = [3, 1, 2]\\nprefix_xor = [3, 2, 0] \\n\\nBit representation:\\n\\n4 2 1\\n-----\\n0 1 1 -> 3\\n0 0 1 -> 1\\n0 1 0 -> 2\\n-----\\n0 0 0 -> 0(XOR)\\n\\nXOR = 0\\n\\nObserve, that all the set bits can be paired and hence all of them can be \\nremoved by subtracting 2^k. Thus, the sub-array [3, 1, 2] can be reduced \\nto zero in some number of operations.\\n\\nBut, if\\nnums       = [3, 1, 4]\\nprefix_xor = [3, 2, 7]\\n\\nBit representation:\\n\\n4 2 1\\n-----\\n0 1 1 -> 3\\n0 0 1 -> 1\\n1 0 0 -> 4\\n-----\\n1 1 0 -> 7(XOR)\\n\\n2 bits here cannot be paired with among any of the numbers, and hence will \\nbe set in the final XOR. Thus, array cannot be reduced to 0 as these 2\\nbits cannot be removed.\\n```\n```\\nclass Solution(object):\\n    def beautifulSubarrays(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        prefix = nums[0]\\n        hashmap = defaultdict(int)\\n        hashmap[0] = 1\\n        \\n        cnt = 0\\n        \\n        for i in xrange(0, len(nums)):\\n            if i>0: prefix = nums[i] ^ prefix\\n            if prefix in hashmap:\\n               # print(i, prefix)\\n               cnt += hashmap[prefix]\\n            hashmap[prefix] += 1\\n            \\n        return cnt\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286483,
                "title": "simple-python3-prefix-dictionary-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        prefixDict = defaultdict(list)\\n        prefixDict[0].append(-1)\\n        prefix = 0\\n        res = 0\\n        for i, num in enumerate(nums):\\n            p = 1\\n            while num > 0:\\n                if num % 2 == 1:\\n                    if (prefix // p) % 2 == 1:\\n                        prefix -= p\\n                    else:\\n                        prefix += p\\n                p *= 2\\n                num = num // 2\\n            res += len(prefixDict[prefix])\\n            prefixDict[prefix].append(i)\\n        return res\\n            \\n```\\n\\n\\n# Complexity\\n- Time complexity: O(N * K)\\n- Space complexity: O(N)\\nN: length of nums, K: log(maximum number)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        prefixDict = defaultdict(list)\\n        prefixDict[0].append(-1)\\n        prefix = 0\\n        res = 0\\n        for i, num in enumerate(nums):\\n            p = 1\\n            while num > 0:\\n                if num % 2 == 1:\\n                    if (prefix // p) % 2 == 1:\\n                        prefix -= p\\n                    else:\\n                        prefix += p\\n                p *= 2\\n                num = num // 2\\n            res += len(prefixDict[prefix])\\n            prefixDict[prefix].append(i)\\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286482,
                "title": "c-prefix-xor-hashmap-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        \\n        unordered_map<int,int>mp;\\n        nums.insert(0+nums.begin(),0);\\n        \\n        long long sum=0,res=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            sum^=nums[i];\\n            if(mp.find(sum)!=mp.end()){\\n                res+=mp[sum];\\n            }\\n                mp[sum]++;            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        \\n        unordered_map<int,int>mp;\\n        nums.insert(0+nums.begin(),0);\\n        \\n        long long sum=0,res=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            sum^=nums[i];\\n            if(mp.find(sum)!=mp.end()){\\n                res+=mp[sum];\\n            }\\n                mp[sum]++;            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286437,
                "title": "easiest-solution-c-6-linear",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        map<int, int> pref;\\n        long long ans=0,x=0;\\n        pref[0]=1;\\n        for(int i=0;i<nums.size();i++){\\n            x^=nums[i];\\n            if(pref.find(x)!=pref.end()) ans=ans+pref[x];\\n            pref[x]+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        map<int, int> pref;\\n        long long ans=0,x=0;\\n        pref[0]=1;\\n        for(int i=0;i<nums.size();i++){\\n            x^=nums[i];\\n            if(pref.find(x)!=pref.end()) ans=ans+pref[x];\\n            pref[x]+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286418,
                "title": "python3-count-subarrays-with-zero-xor",
                "content": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        hmap = {0:1}\\n        x,ans = 0,0\\n        for i in nums:\\n            x ^= i\\n            if x in hmap:\\n                ans += hmap[x]\\n                hmap[x] += 1\\n            else:\\n                hmap[x] = 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        hmap = {0:1}\\n        x,ans = 0,0\\n        for i in nums:\\n            x ^= i\\n            if x in hmap:\\n                ans += hmap[x]\\n                hmap[x] += 1\\n            else:\\n                hmap[x] = 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286399,
                "title": "c-map-solution-easy-to-understand-count-subarray-with-xor",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n         map<int, int> seen;\\n        seen[0]++;\\n        long long ans = 0;\\n        int sum =0;\\n        for(int v : nums){\\n            sum ^= v;\\n            ans += seen[sum];\\n            seen[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n         map<int, int> seen;\\n        seen[0]++;\\n        long long ans = 0;\\n        int sum =0;\\n        for(int v : nums){\\n            sum ^= v;\\n            ans += seen[sum];\\n            seen[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286376,
                "title": "easy-solution-count-subarraysum-xor-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll beautifulSubarrays(vector<int>& aa) {\\n        map<ll,ll>mp;\\n           mp[0]=1;\\n           ll ans=0,sum=0;\\n           for(int i=0; i<aa.size(); i++) {\\n               sum^=aa[i];\\n               ans+=mp[sum];\\n               mp[sum]++;\\n           }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll beautifulSubarrays(vector<int>& aa) {\\n        map<ll,ll>mp;\\n           mp[0]=1;\\n           ll ans=0,sum=0;\\n           for(int i=0; i<aa.size(); i++) {\\n               sum^=aa[i];\\n               ans+=mp[sum];\\n               mp[sum]++;\\n           }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286310,
                "title": "count-the-number-of-subarrays-with-xor-equals-zero",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo remove any bit, we need it to be present even number of times, and XOR has the property of even occurring bit XORed gives zero. So find Subarrays with XOR = 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long subarrayXor(vector<int> arr, int n, int m)\\n{\\n    long long ans = 0;\\n    int* xorArr = new int[n];\\n    unordered_map<int, int> mp;\\n    xorArr[0] = arr[0];\\n    for (int i = 1; i < n; i++)\\n        xorArr[i] = xorArr[i - 1] ^ arr[i];\\n    for (int i = 0; i < n; i++) {\\n        int tmp = m ^ xorArr[i];\\n        ans = ans + ((long long)mp[tmp]);\\n        if (xorArr[i] == m)\\n            ans++;\\n        mp[xorArr[i]]++;\\n    }\\n    return ans;\\n}\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        return subarrayXor(nums, nums.size(), 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long subarrayXor(vector<int> arr, int n, int m)\\n{\\n    long long ans = 0;\\n    int* xorArr = new int[n];\\n    unordered_map<int, int> mp;\\n    xorArr[0] = arr[0];\\n    for (int i = 1; i < n; i++)\\n        xorArr[i] = xorArr[i - 1] ^ arr[i];\\n    for (int i = 0; i < n; i++) {\\n        int tmp = m ^ xorArr[i];\\n        ans = ans + ((long long)mp[tmp]);\\n        if (xorArr[i] == m)\\n            ans++;\\n        mp[xorArr[i]]++;\\n    }\\n    return ans;\\n}\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        return subarrayXor(nums, nums.size(), 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286309,
                "title": "c-map-using-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        unordered_map<int,int> mp;\\n        long long xr = 0;\\n        for(int i=0;i<nums.size();i++){\\n            xr ^= nums[i];\\n            if(mp.find(xr)!=mp.end()){\\n                ans += mp[xr];\\n                mp[xr] += 1;\\n            }else{\\n                mp[xr] = 1;\\n            }\\n        }\\n        if(mp.find(0) != mp.end()) ans += mp[0];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        unordered_map<int,int> mp;\\n        long long xr = 0;\\n        for(int i=0;i<nums.size();i++){\\n            xr ^= nums[i];\\n            if(mp.find(xr)!=mp.end()){\\n                ans += mp[xr];\\n                mp[xr] += 1;\\n            }else{\\n                mp[xr] = 1;\\n            }\\n        }\\n        if(mp.find(0) != mp.end()) ans += mp[0];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286292,
                "title": "easy-c",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        map<long long, long long> m;\\n        m[0]++;\\n\\n        long long temp = 0, ans = 0;\\n\\n        for(auto &i: nums){\\n            temp ^= i;\\n\\n            if(m.find(temp) != m.end()) ans += m[temp];\\n\\n            m[temp]++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        map<long long, long long> m;\\n        m[0]++;\\n\\n        long long temp = 0, ans = 0;\\n\\n        for(auto &i: nums){\\n            temp ^= i;\\n\\n            if(m.find(temp) != m.end()) ans += m[temp];\\n\\n            m[temp]++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286261,
                "title": "javascript-prefix-bitmasks-hashmap",
                "content": "**Solution: Prefix Bitmasks & Hashmap**\\n\\nKeep track of the running prefix bitmask as we go through nums.\\nSince we only need to know whether the number of 1 bits at each position is even or odd, we can use `0` to represent an even number of bits, and `1` to represent an odd number of bits.\\nFor each index `i`, count the number of previous prefix bitmasks with the exact same state as the current bitmask.\\nIf the bitmasks are the same, that means each bit has an even count for the subarray between index `i` and the previous bitmask.\\nUse a hashmap to count the occurances of each bitmask.\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(n)`\\n```\\nvar beautifulSubarrays = function(nums) {\\n  let mask = 0, count = new Map(), ans = 0;\\n  count.set(0, 1);\\n  for (let i = 0; i < nums.length; i++) {\\n    mask = mask ^ nums[i];\\n    ans += (count.get(mask) || 0);\\n    count.set(mask, (count.get(mask) || 0) + 1);\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar beautifulSubarrays = function(nums) {\\n  let mask = 0, count = new Map(), ans = 0;\\n  count.set(0, 1);\\n  for (let i = 0; i < nums.length; i++) {\\n    mask = mask ^ nums[i];\\n    ans += (count.get(mask) || 0);\\n    count.set(mask, (count.get(mask) || 0) + 1);\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3286259,
                "title": "c-o-n-20-bitmasks-dp",
                "content": "```\\n\\tclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans = 0;\\n        long long mp[22] = {};\\n        long long dep[22] = {};\\n        int dp[2097153] = {};\\n        dp[0] = 1;\\n        for(int i = 0; i < nums.size(); i++){\\n            int t = nums[i], k = 0;\\n            while(t){\\n                if(t&1) mp[k]++;\\n                k++;\\n                t>>=1;\\n            }\\n            int cur = 0;\\n            int need = 0;\\n            for(int i = 0; i < 21; i++) if(mp[i]%2 == 0) cur += (1<<i);\\n            else need += (1<<i);\\n            ans += dp[need];\\n            dp[need]++;\\n        }\\n        return ans;\\n    }\\n};\\n// bitmask each state",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans = 0;\\n        long long mp[22] = {}",
                "codeTag": "Java"
            },
            {
                "id": 3286249,
                "title": "c-easy-and-simple-solution-using-hashmap",
                "content": "\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n# complexity\\n* Time \\n    O(N)\\n* Space\\n  O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long xorr=0;\\n        unordered_map<int,int>mapping;\\n        mapping[xorr]++;\\n        long long count=0;\\n        for(int i=0;i<nums.size();i++){\\n            xorr=xorr^nums[i];\\n            count+=mapping[xorr];\\n            mapping[xorr]++;\\n        }\\n        \\n        \\n        return count ;\\n    }\\n};\\n\\n\\n```\\n\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long xorr=0;\\n        unordered_map<int,int>mapping;\\n        mapping[xorr]++;\\n        long long count=0;\\n        for(int i=0;i<nums.size();i++){\\n            xorr=xorr^nums[i];\\n            count+=mapping[xorr];\\n            mapping[xorr]++;\\n        }\\n        \\n        \\n        return count ;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028750,
                "title": "easiest-solution-for-beginners-o-n-very-simple-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need the find the sum with xor as 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe question is similar to counting the subarrays with sum k. So in place of sum here we have xor as 0. So everything remains as it is. Replace the sum+=nums[i] with sum^=nums[i] And also replace mp.containsKey(sum-k) with mp.containsKey(sum^0).\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        long count=0;\\n        int sum=0;\\n        HashMap<Integer,Integer> mp=new HashMap<>();\\n       mp.put(0,1);\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum^=nums[i];\\n            \\n            if(mp.containsKey(sum^0))\\n                {\\n                   count+=mp.get(sum^0);\\n                }\\n           \\n\\n           if(!mp.containsKey(sum))\\n            {\\n                mp.put(sum,1);\\n            }\\n            else if(mp.containsKey(sum))\\n            {\\n                mp.put(sum,mp.get(sum)+1);\\n            }\\n      \\n                 \\n        }\\n     return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        long count=0;\\n        int sum=0;\\n        HashMap<Integer,Integer> mp=new HashMap<>();\\n       mp.put(0,1);\\n\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum^=nums[i];\\n            \\n            if(mp.containsKey(sum^0))\\n                {\\n                   count+=mp.get(sum^0);\\n                }\\n           \\n\\n           if(!mp.containsKey(sum))\\n            {\\n                mp.put(sum,1);\\n            }\\n            else if(mp.containsKey(sum))\\n            {\\n                mp.put(sum,mp.get(sum)+1);\\n            }\\n      \\n                 \\n        }\\n     return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006326,
                "title": "golang-hash-table-solution",
                "content": "# Code\\n```go\\nfunc beautifulSubarrays(nums []int) int64 {\\n\\thash := make(map[int]int)\\n\\thash[0] = 1\\n\\tmagic := 0\\n\\tbs := 0\\n\\tfor _, v := range nums {\\n\\t\\tfor i := 0; v != 0; i++ {\\n\\t\\t\\tif v & 1 == 1 {\\n\\t\\t\\t\\tmagic ^= 1 << i\\n\\t\\t\\t}\\n\\t\\t\\tv >>= 1\\n\\t\\t}\\n\\t\\tbs += hash[magic]\\n\\t\\thash[magic]++\\n\\t}\\n\\treturn int64(bs)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```go\\nfunc beautifulSubarrays(nums []int) int64 {\\n\\thash := make(map[int]int)\\n\\thash[0] = 1\\n\\tmagic := 0\\n\\tbs := 0\\n\\tfor _, v := range nums {\\n\\t\\tfor i := 0; v != 0; i++ {\\n\\t\\t\\tif v & 1 == 1 {\\n\\t\\t\\t\\tmagic ^= 1 << i\\n\\t\\t\\t}\\n\\t\\t\\tv >>= 1\\n\\t\\t}\\n\\t\\tbs += hash[magic]\\n\\t\\thash[magic]++\\n\\t}\\n\\treturn int64(bs)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3993296,
                "title": "one-pass-using-dp-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is similar to count the number of subarray sum satisfy certain requirement, e.g. sum equal to 1.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHow we do it is, we apply certain operations on the prefix so that we can use it to check whether we can form the condition with some operation for the new prefix. e.g. we sum all the prefix and use substract to check whether the new prefix satisfy the condition \"sum to a certain nubmer\".\\n\\nAnd then when we iterate on a new item and update the prefix, we check the DP to see how many subarray satisfy the condition. \\n\\nAnd we update the DP with the new Prefix.\\n\\n\\n# Complexity\\n- Time complexity: O(n) - one pass\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) - prefix count\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# similar to use prefix sum to count num of subarray = certain nubmer , here the certain nubmer is 0\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        prefix = 0\\n        prefix_cnt = Counter({0:1})\\n        ans = 0\\n\\n        for num in nums:\\n            prefix = prefix ^ num\\n            # check how many prefix already there can form the certain we are looking for \\n            # check existance before usage for python dict\\n            ans += prefix_cnt[prefix]\\n            prefix_cnt[prefix] += 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# similar to use prefix sum to count num of subarray = certain nubmer , here the certain nubmer is 0\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        prefix = 0\\n        prefix_cnt = Counter({0:1})\\n        ans = 0\\n\\n        for num in nums:\\n            prefix = prefix ^ num\\n            # check how many prefix already there can form the certain we are looking for \\n            # check existance before usage for python dict\\n            ans += prefix_cnt[prefix]\\n            prefix_cnt[prefix] += 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984885,
                "title": "c-beginner-solution-easy-to-catch-prefix-sum-string-iit-roorkee",
                "content": "# Complexity\\n- Time complexity: O(32*N)=O(N)\\n\\n- Space complexity:O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) \\n    {\\n        long long count=0;\\n        string str;\\n        unordered_map<string,long long >mp;\\n        for(int i=0;i<32;i++)\\n        {\\n            if (nums[0] & (1 << i))\\n            {\\n                str+=\"O\";\\n            }\\n            else\\n            {\\n                str+=\"E\";\\n            }\\n        }\\n        if(nums[0]==0)\\n        {\\n            count++;\\n        }\\n        mp[str]++;\\n        for(int j=1;j<nums.size();j++)\\n        {\\n            int even=0;\\n            for(int i=0;i<32;i++)\\n            {\\n            if (nums[j] & (1 << i))\\n            {\\n                if(str[i]==\\'E\\')\\n                {\\n                    str[i]=\\'O\\';\\n                }\\n                else\\n                {\\n                    \\n                    str[i]=\\'E\\';\\n                }\\n                \\n            }\\n           \\n                if(str[i]==\\'E\\')\\n                {\\n                    even++; \\n                }\\n            }\\n            if(even==32)\\n            {\\n                count++;\\n            }\\n            count+=mp[str];\\n            mp[str]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) \\n    {\\n        long long count=0;\\n        string str;\\n        unordered_map<string,long long >mp;\\n        for(int i=0;i<32;i++)\\n        {\\n            if (nums[0] & (1 << i))\\n            {\\n                str+=\"O\";\\n            }\\n            else\\n            {\\n                str+=\"E\";\\n            }\\n        }\\n        if(nums[0]==0)\\n        {\\n            count++;\\n        }\\n        mp[str]++;\\n        for(int j=1;j<nums.size();j++)\\n        {\\n            int even=0;\\n            for(int i=0;i<32;i++)\\n            {\\n            if (nums[j] & (1 << i))\\n            {\\n                if(str[i]==\\'E\\')\\n                {\\n                    str[i]=\\'O\\';\\n                }\\n                else\\n                {\\n                    \\n                    str[i]=\\'E\\';\\n                }\\n                \\n            }\\n           \\n                if(str[i]==\\'E\\')\\n                {\\n                    even++; \\n                }\\n            }\\n            if(even==32)\\n            {\\n                count++;\\n            }\\n            count+=mp[str];\\n            mp[str]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942711,
                "title": "ruby-o-n",
                "content": "```ruby\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef beautiful_subarrays(nums)\\n  counter = Hash.new(0)\\n  counter[0] = 1\\n  nums.inject([0, 0]) { | (res, prefix_xor), num |\\n    prefix_xor = prefix_xor ^ num\\n    res += counter[prefix_xor]\\n    counter[prefix_xor] += 1\\n    [res, prefix_xor]\\n  }[0]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef beautiful_subarrays(nums)\\n  counter = Hash.new(0)\\n  counter[0] = 1\\n  nums.inject([0, 0]) { | (res, prefix_xor), num |\\n    prefix_xor = prefix_xor ^ num\\n    res += counter[prefix_xor]\\n    counter[prefix_xor] += 1\\n    [res, prefix_xor]\\n  }[0]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3861899,
                "title": "similar-to-count-subarrays-with-xor-as-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a Count Subarrays with Xor as K problem. \\nBits in a beautiful subarray should appear even number of times. Therefore, XOR of elements of a beautiful subarray should be zero.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int l=nums.size();\\n        int req=0;\\n        int xorr=0;\\n        long long ans=0;\\n        unordered_map<int, int>mp;\\n\\n        for(auto i:nums){\\n            xorr=xorr^i;\\n\\n            if(xorr==req)\\n            ans++;\\n\\n            if(mp.find(xorr^req)!=mp.end())\\n            ans+=mp[xorr^req];\\n\\n            mp[xorr]++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int l=nums.size();\\n        int req=0;\\n        int xorr=0;\\n        long long ans=0;\\n        unordered_map<int, int>mp;\\n\\n        for(auto i:nums){\\n            xorr=xorr^i;\\n\\n            if(xorr==req)\\n            ans++;\\n\\n            if(mp.find(xorr^req)!=mp.end())\\n            ans+=mp[xorr^req];\\n\\n            mp[xorr]++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850473,
                "title": "just-wanted-to-share-this-fun-little-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo make a beautiful subarray, every flipped bit (basically every 1\\'s) must have a pair. This means that in order to find out whether a subarray is beautiful, it must have an a total xor of 0 (that means that every flipped bit of every number must have a pair somewhere in the subarray).\\n\\nThe idea is to iterate over the entire array while simultaneously saving the \"running xor\" (lets call this index \\'j\\').\\n\\nWhile getting the \"running xor\", we can use the same idea we utilize in prefix sum problems in order to get an index (lets call this \\'i\\') that once removed, could give us an xor total of 0. So basically indices which have the same xor as our current index.\\n\\nex.\\narr = [4, 3, 1, 2, 4]\\nrunning_xor = [4, 7, 6, 4, 0]\\n\\nAs you can see, in index j = 3, we have a \"current running xor\" 4. If we remove the \"running xor\" at index i = 0 (which has the same \"running xor\"), we could get a total xor of 0.\\n\\nSo we simply save every \"running xor\" in a map and call it a day.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\niterate over the nums array while saving a \"running xor\" and saving them in a map but in one line to be as obnoxious as i can\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& n, int mask = 0, unordered_map<int, int> d = {{0, 1}}) {\\n      return accumulate(begin(n), end(n), 0LL, [&](long long &r, int &i) { return r + d[mask ^= i]++; } );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& n, int mask = 0, unordered_map<int, int> d = {{0, 1}}) {\\n      return accumulate(begin(n), end(n), 0LL, [&](long long &r, int &i) { return r + d[mask ^= i]++; } );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849053,
                "title": "c-solution-beats-57",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        map<int,int> mp;\\n        mp[0]=1;\\n        vector<int> pxor(nums.size());\\n        pxor[0]=nums[0];\\n        mp[pxor[0]]++;\\n        if(pxor[0]==0)\\n            ans++;\\n        //cout<<pxor[0]<<\" \";\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            pxor[i]=pxor[i-1]^nums[i];\\n            //cout<<pxor[i]<<\" \";\\n            if(mp.find(pxor[i])!=mp.end())\\n                ans+=mp[pxor[i]];\\n            mp[pxor[i]]++;    \\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        map<int,int> mp;\\n        mp[0]=1;\\n        vector<int> pxor(nums.size());\\n        pxor[0]=nums[0];\\n        mp[pxor[0]]++;\\n        if(pxor[0]==0)\\n            ans++;\\n        //cout<<pxor[0]<<\" \";\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            pxor[i]=pxor[i-1]^nums[i];\\n            //cout<<pxor[i]<<\" \";\\n            if(mp.find(pxor[i])!=mp.end())\\n                ans+=mp[pxor[i]];\\n            mp[pxor[i]]++;    \\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3845899,
                "title": "bit-manipulation",
                "content": "# Intuition\\nintution is subarray make all element equal to zero only if count of sum of each bit is even and it will even only when there bitwise xor is 0\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n        long long sum=0;\\n        map<long long,long long>m;\\n        for(int i=0;i<n;i++){\\n             sum =sum ^ nums[i];\\n             if(sum==0)\\n               ans++;\\n             if(m.find(sum)!=m.end())\\n               ans +=m[sum];\\n             m[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n        long long sum=0;\\n        map<long long,long long>m;\\n        for(int i=0;i<n;i++){\\n             sum =sum ^ nums[i];\\n             if(sum==0)\\n               ans++;\\n             if(m.find(sum)!=m.end())\\n               ans +=m[sum];\\n             m[sum]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834436,
                "title": "python-medium",
                "content": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n\\n        lookup = defaultdict(int)\\n\\n        \\n        lookup[0] += 1\\n\\n        current = 0\\n        ans = 0\\n\\n        for x in nums:\\n            current ^= x\\n            ans += lookup[current]\\n            lookup[current] += 1\\n\\n        return ans\\n        \\n        \\n        \\n\\n            \\n            \\n            \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n\\n        lookup = defaultdict(int)\\n\\n        \\n        lookup[0] += 1\\n\\n        current = 0\\n        ans = 0\\n\\n        for x in nums:\\n            current ^= x\\n            ans += lookup[current]\\n            lookup[current] += 1\\n\\n        return ans\\n        \\n        \\n        \\n\\n            \\n            \\n            \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785670,
                "title": "as-simple-as-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0,curr=0;\\n        int i;\\n        unordered_map<int,int> mp;\\n        mp[0]=1;\\n        for(i=0;i<nums.size();i++){\\n            curr^=nums[i];\\n            if(mp[curr]>0) {\\n                ans+=mp[curr];\\n            }\\n            mp[curr]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0,curr=0;\\n        int i;\\n        unordered_map<int,int> mp;\\n        mp[0]=1;\\n        for(i=0;i<nums.size();i++){\\n            curr^=nums[i];\\n            if(mp[curr]>0) {\\n                ans+=mp[curr];\\n            }\\n            mp[curr]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761101,
                "title": "fastest-and-easiest-solution-with-intuition-and-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nWhen the question is saying of selecting two elements having same bit is set and making it to zero by reducing 2^i that implies that we will reduce the number by 2^i that can also be done by xor of those elements.And for other bits to be zero we need to find elements having similar index bit is same. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIf we can find xor of a subarray to be zero in a range or we get the same xor again then it will be going to count in our ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        unordered_map<int,int>m;\\n        int curr=0;\\n        for(int i=0;i<nums.size();i++){\\n            curr^=nums[i];\\n            if(curr==0){\\n                ans+=1;\\n            }\\n            if(m.count(curr)){\\n                ans+=m[curr];\\n            }\\n            m[curr]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        unordered_map<int,int>m;\\n        int curr=0;\\n        for(int i=0;i<nums.size();i++){\\n            curr^=nums[i];\\n            if(curr==0){\\n                ans+=1;\\n            }\\n            if(m.count(curr)){\\n                ans+=m[curr];\\n            }\\n            m[curr]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747145,
                "title": "count-all-the-subarrays-with-xor-0-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long count=0;\\n        int n=nums.size();\\n        map<int,long long> m;\\n        int prefix=0;\\n        m[0]++;\\n        for(int i=0;i<n;i++){\\n            prefix=prefix^nums[i];\\n            if(m.find(prefix)!=m.end()){\\n                count+=m[prefix];\\n            }\\n            m[prefix]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long count=0;\\n        int n=nums.size();\\n        map<int,long long> m;\\n        int prefix=0;\\n        m[0]++;\\n        for(int i=0;i<n;i++){\\n            prefix=prefix^nums[i];\\n            if(m.find(prefix)!=m.end()){\\n                count+=m[prefix];\\n            }\\n            m[prefix]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3723205,
                "title": "c-solution-using-prefix-xor-and-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        /* \\n\\t\\ta subarray can be valid , if count of set bits (1) in every position is even. \\n\\t\\tso the xor of this subarray will be 0.\\n        \\n         for example, consider [3, 1 , 2] where 011, 001, 010 are corresponding binary respresentation of the subarray . \\n\\t\\t This subarray is valid becasue count of set bits in every position is even\\n\\t\\t i.e 0th bit have total 2 set bits, 1st bit have 2 set bits and 2nd bit have 0 set bits. \\n\\t\\t so if we find the xor to this subarray it will be 0.\\n        \\n        // lets say [0...i] has a xor of \\'k\\' and xor of [0...j] is computed to be again \\'k\\' where j > i. \\n\\t\\tso we say the subarray [i+1...j] has xor = 0\\n\\t\\t*/\\n        \\n        unordered_map<long long,long long> hm;\\n        \\n        hm[0] = 1;\\n        \\n        long long preXor = 0;\\n        \\n        long long ans = 0;\\n        \\n        for(int num : nums){\\n            preXor ^= num;\\n    \\n            \\n            ans += hm[preXor];\\n            \\n            hm[preXor]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        /* \\n\\t\\ta subarray can be valid , if count of set bits (1) in every position is even. \\n\\t\\tso the xor of this subarray will be 0.\\n        \\n         for example, consider [3, 1 , 2] where 011, 001, 010 are corresponding binary respresentation of the subarray . \\n\\t\\t This subarray is valid becasue count of set bits in every position is even\\n\\t\\t i.e 0th bit have total 2 set bits, 1st bit have 2 set bits and 2nd bit have 0 set bits. \\n\\t\\t so if we find the xor to this subarray it will be 0.\\n        \\n        // lets say [0...i] has a xor of \\'k\\' and xor of [0...j] is computed to be again \\'k\\' where j > i. \\n\\t\\tso we say the subarray [i+1...j] has xor = 0\\n\\t\\t*/\\n        \\n        unordered_map<long long,long long> hm;\\n        \\n        hm[0] = 1;\\n        \\n        long long preXor = 0;\\n        \\n        long long ans = 0;\\n        \\n        for(int num : nums){\\n            preXor ^= num;\\n    \\n            \\n            ans += hm[preXor];\\n            \\n            hm[preXor]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699329,
                "title": "java-easy-way",
                "content": "# Intuition\\nSince we n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        \\n        // if we observe this beutifull subarray is that where xor of all element is ZERO\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        long cnt=0;\\n        int xor = 0;\\n\\n        for(int n : nums){\\n            xor ^= n;\\n\\n            if(xor == 0){\\n                cnt++;\\n            }\\n            if(map.containsKey(xor)){\\n                cnt += map.get(xor);\\n            }\\n            map.put(xor, map.getOrDefault(xor, 0)+1);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        \\n        // if we observe this beutifull subarray is that where xor of all element is ZERO\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        long cnt=0;\\n        int xor = 0;\\n\\n        for(int n : nums){\\n            xor ^= n;\\n\\n            if(xor == 0){\\n                cnt++;\\n            }\\n            if(map.containsKey(xor)){\\n                cnt += map.get(xor);\\n            }\\n            map.put(xor, map.getOrDefault(xor, 0)+1);\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678573,
                "title": "count-subarray-with-0-xor-sum",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        p = 0\\n        ctr = Counter()\\n        ctr[0] = 1\\n        res = 0\\n        for el in nums:\\n            p ^= el\\n            res += ctr[p]\\n            ctr[p] += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        p = 0\\n        ctr = Counter()\\n        ctr[0] = 1\\n        res = 0\\n        for el in nums:\\n            p ^= el\\n            res += ctr[p]\\n            ctr[p] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617219,
                "title": "java-bit-manipulation-xor-property-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n      HashMap<Long,Long>map=new HashMap<>();\\n\\n           map.put(0L,1L);\\n           long ans=0L;\\n           long xor=0;\\n      for(int j=0;j<nums.length;j++){\\n          int val=nums[j];\\n          \\n          for(int i=31;i>=0;i--){\\n              int bit=(val>>i)&1;\\n              if(bit==1){\\n                xor^=(long)Math.pow(2,i);\\n              }\\n          }\\n\\n          if(map.containsKey(xor)){\\n              ans+=map.get(xor);\\n          }\\n          map.put(xor,map.getOrDefault(xor,0L)+1L);\\n\\n          \\n      }\\n\\n      return ans;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n      HashMap<Long,Long>map=new HashMap<>();\\n\\n           map.put(0L,1L);\\n           long ans=0L;\\n           long xor=0;\\n      for(int j=0;j<nums.length;j++){\\n          int val=nums[j];\\n          \\n          for(int i=31;i>=0;i--){\\n              int bit=(val>>i)&1;\\n              if(bit==1){\\n                xor^=(long)Math.pow(2,i);\\n              }\\n          }\\n\\n          if(map.containsKey(xor)){\\n              ans+=map.get(xor);\\n          }\\n          map.put(xor,map.getOrDefault(xor,0L)+1L);\\n\\n          \\n      }\\n\\n      return ans;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3603389,
                "title": "easy-java-xor-map",
                "content": "Here the only way the operation would give us a zero where count of number of 1s appearing at a bit position is even over that subarray.\\nIt reduces to ques of subarray with zero xor. So basically i have to count the subarrays with zero xor.\\nSaving mask in a hashmap with the count of occurence of that mask.\\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n        map.put(0,1);\\n        int mask=0;\\n        long count=0;\\n        for(int val:nums)\\n        {\\n            mask=mask^val;\\n            if(!map.containsKey(mask))\\n            {\\n               map.put(mask,1);\\n                \\n            }\\n            else\\n            {\\n                int fr=map.get(mask);\\n                count+=fr;\\n                map.put(mask,fr+1);\\n            }\\n        \\n        }\\n        return count;\\n    }\\n}\\n```\\nTime Complexity is O(n)\\nSpace Complexity is O(n)",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n        map.put(0,1);\\n        int mask=0;\\n        long count=0;\\n        for(int val:nums)\\n        {\\n            mask=mask^val;\\n            if(!map.containsKey(mask))\\n            {\\n               map.put(mask,1);\\n                \\n            }\\n            else\\n            {\\n                int fr=map.get(mask);\\n                count+=fr;\\n                map.put(mask,fr+1);\\n            }\\n        \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3548002,
                "title": "using-prexor-code-like-a-pro",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n<!-- Please upvote if you like this solution -->\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        mp[0]=1;\\n        int Xor=0;\\n        for(int i=0;i<n;i++){\\n            Xor^=nums[i];\\n            if(mp.find(Xor)!=mp.end()){\\n                ans+=mp[Xor];\\n            }\\n            mp[Xor]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n<!-- Please upvote if you like this solution -->\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        mp[0]=1;\\n        int Xor=0;\\n        for(int i=0;i<n;i++){\\n            Xor^=nums[i];\\n            if(mp.find(Xor)!=mp.end()){\\n                ans+=mp[Xor];\\n            }\\n            mp[Xor]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527799,
                "title": "rust-solution-using-sorting-and-run-length-encoding",
                "content": "# Intuition\\n1. A subarray is \"beautiful\" if it has an xor sum of 0.\\n2. Therefore, given the xor prefix sum of the list, a beautiful subarray exists for each pair of equivalent values.\\n    i.e. given [3, 1, 2], which has prefix xor sum [0, 3, 2, 0], there is one beautiful subarray, because there is one pair of equivalent elements, 0 and 0.\\n\\n# Approach\\nCompute the xor prefix sum, sort it, find the count of each element, and compute the number of prefix sums using the following formula:\\n$$\\\\sum\\\\frac{count(count-1)}{2}$$\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$ (due to sorting)\\n\\n- Space complexity: $$O(log(n))$$ (due to sorting)\\n\\nNote: this could be made faster with radix sort.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn beautiful_subarrays(mut nums: Vec<i32>) -> i64 {\\n        let mut xor_sum = 0;\\n\\n        // compute prefix xor-sum\\n        for n in &mut nums {\\n            xor_sum ^= *n;\\n            *n = xor_sum;\\n        }\\n        // start prefix xor-sum with 0\\n        nums.insert(0, 0);\\n\\n        // sort and insert sentinel value\\n        nums.sort_unstable();\\n        nums.push(-1);\\n        \\n        let mut prev = nums[0];\\n        let mut len = 0;\\n\\n        nums\\n            .into_iter()\\n            // transform iterator into an iterator over\\n            // the length of each subarray containing\\n            // exactly one unique value\\n            .filter_map(|n| {\\n                if n == prev {\\n                    len += 1;\\n                    None\\n                } else {\\n                    let out = Some(len);\\n                    prev = n;\\n                    len = 1;\\n                    out\\n                }\\n            })\\n            // compute number of beautiful subarrays\\n            // given lengths\\n            .map(|n| n as i64 * (n as i64 - 1) / 2)\\n            .sum()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn beautiful_subarrays(mut nums: Vec<i32>) -> i64 {\\n        let mut xor_sum = 0;\\n\\n        // compute prefix xor-sum\\n        for n in &mut nums {\\n            xor_sum ^= *n;\\n            *n = xor_sum;\\n        }\\n        // start prefix xor-sum with 0\\n        nums.insert(0, 0);\\n\\n        // sort and insert sentinel value\\n        nums.sort_unstable();\\n        nums.push(-1);\\n        \\n        let mut prev = nums[0];\\n        let mut len = 0;\\n\\n        nums\\n            .into_iter()\\n            // transform iterator into an iterator over\\n            // the length of each subarray containing\\n            // exactly one unique value\\n            .filter_map(|n| {\\n                if n == prev {\\n                    len += 1;\\n                    None\\n                } else {\\n                    let out = Some(len);\\n                    prev = n;\\n                    len = 1;\\n                    out\\n                }\\n            })\\n            // compute number of beautiful subarrays\\n            // given lengths\\n            .map(|n| n as i64 * (n as i64 - 1) / 2)\\n            .sum()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3463016,
                "title": "cpp-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums)  \\n    {\\n       unordered_map<int,int>v;\\n       int a=0;\\n       v[0]=1;\\n       long long c=0;\\n       int i=0;\\n        \\n        while(i<nums.size())\\n        {\\n            a=a^nums[i];\\n            if(v.find(a)!=v.end())\\n            {\\n             c=c+(long long)v[a];\\n            }\\n            ++v[a];\\n            ++i;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums)  \\n    {\\n       unordered_map<int,int>v;\\n       int a=0;\\n       v[0]=1;\\n       long long c=0;\\n       int i=0;\\n        \\n        while(i<nums.size())\\n        {\\n            a=a^nums[i];\\n            if(v.find(a)!=v.end())\\n            {\\n             c=c+(long long)v[a];\\n            }\\n            ++v[a];\\n            ++i;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449771,
                "title": "c-simple-solution-99-o-n-tc-and-sc-witrh-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nevery subarray whose xor is 0 is a beautiful subarray\\nwhy? subarray xor ->0 means at every position from 0->32 in binary rep of any no,there are even no of set bits in the subarray and those even no of set bits can be selected in pairs and setto 0 by reducing bot no by (100..) or (1<<k) if it is kth bit and hence all no in sbarray can be reduced to 0.\\nnow some hashing is used to store the count of every prefix value to get the no of possibe beautiful subarrays starting from ith index in O(1) \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nprefix XOR array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) + static array of size(1<<21)-1\\n\\n![image.png](https://assets.leetcode.com/users/images/7808fad4-7a30-4a2a-b1fd-5128a71f0bcf_1682322874.5358467.png)\\n\\n\\n**PLS UPVOTE IF IT HELPED**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int arr[(1<<21)]={};\\n        int n=nums.size();\\n        vector<int> pre(n);\\n        pre[0]=nums[0];\\n        arr[nums[0]]++;\\n        for(int i=1;i<n;i++){\\n            pre[i]=nums[i] ^ pre[i-1];\\n            arr[pre[i]]++;\\n        }\\n        long long ans=arr[0];\\n        for(int i=0;i<n-1;i++){\\n            arr[pre[i]]--;\\n            ans+=arr[pre[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int arr[(1<<21)]={};\\n        int n=nums.size();\\n        vector<int> pre(n);\\n        pre[0]=nums[0];\\n        arr[nums[0]]++;\\n        for(int i=1;i<n;i++){\\n            pre[i]=nums[i] ^ pre[i-1];\\n            arr[pre[i]]++;\\n        }\\n        long long ans=arr[0];\\n        for(int i=0;i<n-1;i++){\\n            arr[pre[i]]--;\\n            ans+=arr[pre[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428021,
                "title": "c-faster-than-90-o-n-prefix-sum",
                "content": "# Intuition\\nCalculate the number of pairs (prefix, suffix) such as their bit sum is equal to the bit sum of the whole array.\\n\\n# Approach\\nAt first calculate the total bit sum:\\n```\\nvar sum = GetSum(nums);\\n```\\nThen calculate the left sums:\\n```\\nvar lefts = GetLeftsMinusSum(nums, sum);\\n```\\n, where `lefts[i]` is equal to the bit sum of all items from `nums` \\nto the left of the current one minus sum:\\n```\\ncurrSum ^= nums[i - 1];\\nrs[i] = currSum;\\nrs[i] ^= sum;\\n```\\nAfter that calculate the right sum:\\n```\\nvar rights = GetRights(nums);\\n```\\nFinally go through the `lefts` array and calculate the result:\\n```\\nfor (int i = 0; i < lefts.Length; i++)\\n{\\n    if (!dic.ContainsKey(lefts[i]))\\n    {\\n        dic.Add(lefts[i], 1);\\n    }\\n    else\\n    {\\n        dic[lefts[i]]++;\\n    }\\n    if (dic.ContainsKey(rights[i])) rs += dic[rights[i]];\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public long BeautifulSubarrays(int[] nums) {\\n        var sum = GetSum(nums);\\n        var lefts = GetLeftsMinusSum(nums, sum);\\n        var rights = GetRights(nums);\\n        var rs = 0L;\\n        var dic = new Dictionary<int, int>();\\n        for (int i = 0; i < lefts.Length; i++)\\n        {\\n            if (!dic.ContainsKey(lefts[i]))\\n            {\\n                dic.Add(lefts[i], 1);\\n            }\\n            else\\n            {\\n                dic[lefts[i]]++;\\n            }\\n            if (dic.ContainsKey(rights[i])) rs += dic[rights[i]];\\n        }\\n        return rs;\\n    }\\n    private int[] GetLeftsMinusSum(int[] nums, int sum)\\n    {\\n        var rs = new int[nums.Length];\\n        rs[0] ^= sum;\\n        var currSum = 0;\\n        for (int i = 1; i < rs.Length; i++)\\n        {\\n            currSum ^= nums[i - 1];\\n            rs[i] = currSum;\\n            rs[i] ^= sum;\\n        }\\n        return rs;\\n    }\\n    private int[] GetRights(int[] nums)\\n    {\\n        var rs = new int[nums.Length];\\n        var sum = 0;\\n        for (int i = rs.Length - 2; i >= 0; i--)\\n        {\\n            sum ^= nums[i + 1];\\n            rs[i] = sum;\\n        }\\n        return rs;\\n    }\\n    private int GetSum(int[] nums)\\n    {\\n        var rs = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            rs ^= nums[i];\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nvar sum = GetSum(nums);\\n```\n```\\nvar lefts = GetLeftsMinusSum(nums, sum);\\n```\n```\\ncurrSum ^= nums[i - 1];\\nrs[i] = currSum;\\nrs[i] ^= sum;\\n```\n```\\nvar rights = GetRights(nums);\\n```\n```\\nfor (int i = 0; i < lefts.Length; i++)\\n{\\n    if (!dic.ContainsKey(lefts[i]))\\n    {\\n        dic.Add(lefts[i], 1);\\n    }\\n    else\\n    {\\n        dic[lefts[i]]++;\\n    }\\n    if (dic.ContainsKey(rights[i])) rs += dic[rights[i]];\\n}\\n```\n```\\npublic class Solution {\\n    public long BeautifulSubarrays(int[] nums) {\\n        var sum = GetSum(nums);\\n        var lefts = GetLeftsMinusSum(nums, sum);\\n        var rights = GetRights(nums);\\n        var rs = 0L;\\n        var dic = new Dictionary<int, int>();\\n        for (int i = 0; i < lefts.Length; i++)\\n        {\\n            if (!dic.ContainsKey(lefts[i]))\\n            {\\n                dic.Add(lefts[i], 1);\\n            }\\n            else\\n            {\\n                dic[lefts[i]]++;\\n            }\\n            if (dic.ContainsKey(rights[i])) rs += dic[rights[i]];\\n        }\\n        return rs;\\n    }\\n    private int[] GetLeftsMinusSum(int[] nums, int sum)\\n    {\\n        var rs = new int[nums.Length];\\n        rs[0] ^= sum;\\n        var currSum = 0;\\n        for (int i = 1; i < rs.Length; i++)\\n        {\\n            currSum ^= nums[i - 1];\\n            rs[i] = currSum;\\n            rs[i] ^= sum;\\n        }\\n        return rs;\\n    }\\n    private int[] GetRights(int[] nums)\\n    {\\n        var rs = new int[nums.Length];\\n        var sum = 0;\\n        for (int i = rs.Length - 2; i >= 0; i--)\\n        {\\n            sum ^= nums[i + 1];\\n            rs[i] = sum;\\n        }\\n        return rs;\\n    }\\n    private int GetSum(int[] nums)\\n    {\\n        var rs = 0;\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            rs ^= nums[i];\\n        }\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418038,
                "title": "simple-with-explanation-map",
                "content": "# Intuition\\nthe question changes down to find the number of subarray whose xor is equal to 0.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n// simple logic : humlog saare elements ka xor nikal rhe h .. \\n// and let\\'s say ki humlog ne xor array ko store kr lia h and now \\n// ab humlog hr ek element ka count dekh rhe h ki xor array mein \\n// vo wla element kitni baar aaya h..\\n\\n// example h : 5 1 3 2 5\\n// maan lo ye hamari xor array h toh isme 5 jo h 2 baar repeat ho \\n// rha h that means ki 5 se 5 tk ke jitne v beech ke elements ho\\n// unka xor 0 aayega tabhi 5 phir se repeat ho rha h.\\n\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans = 0;\\n        map<int, long long> mp;\\n        mp[0]++;\\n        int curr = 0;\\n        for(auto &x : nums){\\n            curr = curr ^ x;\\n            ans += mp[curr];\\n            mp[curr]++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n// simple logic : humlog saare elements ka xor nikal rhe h .. \\n// and let\\'s say ki humlog ne xor array ko store kr lia h and now \\n// ab humlog hr ek element ka count dekh rhe h ki xor array mein \\n// vo wla element kitni baar aaya h..\\n\\n// example h : 5 1 3 2 5\\n// maan lo ye hamari xor array h toh isme 5 jo h 2 baar repeat ho \\n// rha h that means ki 5 se 5 tk ke jitne v beech ke elements ho\\n// unka xor 0 aayega tabhi 5 phir se repeat ho rha h.\\n\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans = 0;\\n        map<int, long long> mp;\\n        mp[0]++;\\n        int curr = 0;\\n        for(auto &x : nums){\\n            curr = curr ^ x;\\n            ans += mp[curr];\\n            mp[curr]++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416392,
                "title": "java-prefix-sum-frequency-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        int n=nums.length;\\n        long ans=0;\\n        int curXOR=0;\\n        Map<Integer,Integer>mp=new HashMap<>();\\n        mp.put(0,1);\\n        for(int i=0;i<n;i++){\\n           curXOR^=nums[i];\\n           if(mp.containsKey(curXOR)){\\n               mp.put(curXOR,mp.get(curXOR)+1);\\n           }else mp.put(curXOR,1);\\n          \\n        }\\n        for(Map.Entry<Integer,Integer>m:mp.entrySet()){\\n            ans+= ((long)m.getValue()*((long)m.getValue()-1))/2;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        int n=nums.length;\\n        long ans=0;\\n        int curXOR=0;\\n        Map<Integer,Integer>mp=new HashMap<>();\\n        mp.put(0,1);\\n        for(int i=0;i<n;i++){\\n           curXOR^=nums[i];\\n           if(mp.containsKey(curXOR)){\\n               mp.put(curXOR,mp.get(curXOR)+1);\\n           }else mp.put(curXOR,1);\\n          \\n        }\\n        for(Map.Entry<Integer,Integer>m:mp.entrySet()){\\n            ans+= ((long)m.getValue()*((long)m.getValue()-1))/2;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367660,
                "title": "solid-principles-xor-processing-with-frequency-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA prefix array of valuations throughout the list will in turn work as a prefix sum of the sub arays possible if we use the XOR result of a value and the prior. By doing this we are in turn finding the beautiful sub arrays. This is because only those instances where we can take the binary xor of a numer and end up with a result will we have an array that we can reduce to 0. Due to this, we can utilize xor to effectively determine the number of places to wipe out to as we go along, where places are the size of the sub array. \\n\\nThis then leads us to the approach progression. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo complete our problem, we will need a total amount, an ongoing prefix xor result, a frequency map of prefix xor results, and a setup that has 0 mapping to 1 as the base for when we have prefix arrays of zero set. (the weird test case they put in...) \\n\\nAfter, to comply with SOLID, we will be making functional components to complete only one responsibility if we can. \\n\\nOur first is an update prefix xor value, which, when given a value, updates our current prefix xor result as the xor of the current prefix xor result and the passed value. \\n\\nOur second is a method to get the number of beautiful sub arrays up to here. To do this, we will either return 0, or if the current prefix xor result is in the frequency map, we will return the count there. \\n\\nNext we need a method to update the total. To update the total, we need the count up to here. Then we can increment the total by the count. Then we need to update the frequency based on the count. \\n\\nNow we need a way to update frequency\\nThe update to frequency depends on accessing our map of prefix xor result frequencies at the current prefix xor result and then setting that to the passed value of count + 1. \\n\\nFinally, we need a way to process all of our values in nums, which will be passed in to this final sub routinue function. \\nWe enumerate over nums\\n- As we do, we update the prefix xor result by passing the value \\n- We then update the total \\n\\nIn our original problem, we make a call to process nums, and then return the result. \\n\\n# Complexity\\n- Time complexity: O(N) where N is the number of Nums \\n    - Process nums is the only iterative element, and we can tell that it only occurs the number of times equal to the length of nums  \\n\\n- Space complexity: O(U) where O(U) is the number of unique prefix xor results due to nums. This may or may not be smaller than O(N). \\n\\n# Code\\n```\\nclass Solution:\\n    # initialize fields needed \\n    def __init__(self) : \\n        self.total = 0\\n        self.prefix_xor = 0 \\n        self.prefix_frequency = collections.defaultdict(int)\\n        self.prefix_frequency[0] = 1\\n\\n    # update prefix xor given a value \\n    def update_prefix_xor(self, value) : \\n        self.prefix_xor ^= value\\n\\n    # get count up to this point in nums \\n    def get_count_up_to_here(self) : \\n        # if our xor is in the frequency dictionary\\n        if self.prefix_xor in self.prefix_frequency : \\n            # return what we had there \\n            return self.prefix_frequency[self.prefix_xor]\\n        # otherwise, return 0 \\n        return 0 \\n\\n    # get the update to total \\n    def update_total(self) : \\n        # get the count \\n        count = self.get_count_up_to_here()\\n        # increment total \\n        self.total += count\\n        # update the frequency \\n        self.update_frequency(count)\\n\\n    # update frequency after updating total \\n    def update_frequency(self, count) : \\n        self.prefix_frequency[self.prefix_xor] = count + 1\\n\\n    # process all of our nums \\n    def process_nums(self, nums) : \\n        # enumerate nums \\n        for index, value in enumerate(nums) : \\n            # update xor result \\n            self.update_prefix_xor(value)\\n            # update total\\n            self.update_total()\\n\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        # call to process \\n        self.process_nums(nums)\\n        # return result \\n        return self.total\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # initialize fields needed \\n    def __init__(self) : \\n        self.total = 0\\n        self.prefix_xor = 0 \\n        self.prefix_frequency = collections.defaultdict(int)\\n        self.prefix_frequency[0] = 1\\n\\n    # update prefix xor given a value \\n    def update_prefix_xor(self, value) : \\n        self.prefix_xor ^= value\\n\\n    # get count up to this point in nums \\n    def get_count_up_to_here(self) : \\n        # if our xor is in the frequency dictionary\\n        if self.prefix_xor in self.prefix_frequency : \\n            # return what we had there \\n            return self.prefix_frequency[self.prefix_xor]\\n        # otherwise, return 0 \\n        return 0 \\n\\n    # get the update to total \\n    def update_total(self) : \\n        # get the count \\n        count = self.get_count_up_to_here()\\n        # increment total \\n        self.total += count\\n        # update the frequency \\n        self.update_frequency(count)\\n\\n    # update frequency after updating total \\n    def update_frequency(self, count) : \\n        self.prefix_frequency[self.prefix_xor] = count + 1\\n\\n    # process all of our nums \\n    def process_nums(self, nums) : \\n        # enumerate nums \\n        for index, value in enumerate(nums) : \\n            # update xor result \\n            self.update_prefix_xor(value)\\n            # update total\\n            self.update_total()\\n\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        # call to process \\n        self.process_nums(nums)\\n        # return result \\n        return self.total\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348471,
                "title": "xor-and-map-with-explanation-of-the-basics",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen I encountered this problem in a contest (weekly 336), I wasn\\'t able to solve it because I didn\\'t have experience with two techniques needed for this problem that I learned from looking at other solutions:\\n\\n- Use XOR (invoked with the ^ operator) to test subarrays. Let\\'s say we want to test whether [a, b, c] is beautiful. ((0 ^ a) ^ b) ^c == 0 will be true if and only if [a, b, c] is beautiful. Further, for [N, a, b, c], we can use ((N ^ a) ^ b) ^ c == N to test the subarray [a, b, c].\\n- We can create a Map to collect an XOR value for each element in the subarray. Then, if we encounter that value again (\"N\" in the example above), we know we have a beautiful subarray. Let\\'s look at [N, a, b, c, a, b, c, a, b, c]. If [a, b, c] is beautiful, we\\'ll have 6 beautiful subarrays: [a, b, c] x 3, [a, b, c, a, b, c] x 2, and [a, b, c, a, b, c, a, b, c]. Using a map, we can increment our count each time we encounter N and add the incremented value to our answer.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a for loop to populate a map with XOR values and count repeats in the map.  If there\\'s a repeat, add the current number of repeats to the answer.\\n\\nSeed the map with 0, because there is one single-element subarray, [0], that is beautiful.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n), because we look at each element in the nums array once with a constant-time test.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n), because the map size depends on the size of nums.\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar beautifulSubarrays = function(nums) {\\n    let ans = 0;\\n    let current = 0;\\n    // use a map of xor values and their frequencies to determine how many subarrays are beautiful.\\n    // seed the map with 0 because each occurence of 0 by itself is a beautiful subarray.\\n    let map = new Map([[0, 0]]);\\n    for (let i = 0; i < nums.length; i++){\\n        current = current ^ nums[i];\\n        if (map.has(current)){\\n            map.set(current, map.get(current) + 1);\\n            ans += map.get(current);\\n        } else {\\n            map.set(current, 0);\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar beautifulSubarrays = function(nums) {\\n    let ans = 0;\\n    let current = 0;\\n    // use a map of xor values and their frequencies to determine how many subarrays are beautiful.\\n    // seed the map with 0 because each occurence of 0 by itself is a beautiful subarray.\\n    let map = new Map([[0, 0]]);\\n    for (let i = 0; i < nums.length; i++){\\n        current = current ^ nums[i];\\n        if (map.has(current)){\\n            map.set(current, map.get(current) + 1);\\n            ans += map.get(current);\\n        } else {\\n            map.set(current, 0);\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337079,
                "title": "python3-prefix-xor-with-prints-to-help-understand",
                "content": "My solution\\n\\n```python\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        total = xor = 0\\n        xor_map = Counter()\\n        for num in nums:\\n            xor_map[xor] += 1\\n            xor ^= num\\n            total += xor_map[xor]\\n        return total\\n```\\n\\nSolution that prints the subarrays for clarity\\n\\n```python\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        total = xor = 0\\n        xor_map = defaultdict(set)\\n        xor_map[0].add(0)\\n        for j, num in enumerate(nums):\\n            xor_map[xor].add(j)\\n            xor ^= num\\n            total += len(xor_map[xor])\\n            for i in xor_map[xor]:\\n                print(f\"nums[{i}:{j+1}] =\", nums[i:j+1])\\n        return total\\n```\\n\\nEssentially, we typically start xoring from 0 at the start of the subarray and aim to get back to 0 by the end of it. But it\\'s equivalent and more efficient if we \"start\" xoring from any xor we\\'ve been to previously and aim to get back to that value.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        total = xor = 0\\n        xor_map = Counter()\\n        for num in nums:\\n            xor_map[xor] += 1\\n            xor ^= num\\n            total += xor_map[xor]\\n        return total\\n```\n```python\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        total = xor = 0\\n        xor_map = defaultdict(set)\\n        xor_map[0].add(0)\\n        for j, num in enumerate(nums):\\n            xor_map[xor].add(j)\\n            xor ^= num\\n            total += len(xor_map[xor])\\n            for i in xor_map[xor]:\\n                print(f\"nums[{i}:{j+1}] =\", nums[i:j+1])\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334710,
                "title": "c-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) \\n    {\\n        long long xr=0,ans;\\n        int n=nums.size();\\n        map<long long,int> dp{{0,1}};\\n        for(int i=0;i<n;i++)\\n        {\\n            xr^=nums[i];\\n            ans+=dp[xr]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) \\n    {\\n        long long xr=0,ans;\\n        int n=nums.size();\\n        map<long long,int> dp{{0,1}};\\n        for(int i=0;i<n;i++)\\n        {\\n            xr^=nums[i];\\n            ans+=dp[xr]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332395,
                "title": "problem-scaled-down-to-count-of-subarrays-with-xor-0-handwritten-explaination-clean-code",
                "content": "### A\\n![a.jpeg](https://assets.leetcode.com/users/images/1c947ecf-c495-45bd-b67f-f6280cb2e319_1679578809.656745.jpeg)\\n\\n### B\\n![b.jpeg](https://assets.leetcode.com/users/images/f7d1b4f5-86e6-469b-b647-21da23c15193_1679578829.852715.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: $$O(N + N)$$  \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$ map takes at worst\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        unordered_map<ll, ll> mpp; //value, count\\n        ll xorv = 0;\\n        for(int no : nums){\\n            xorv = xorv ^ no;\\n            mpp[xorv]++;\\n        }\\n\\n        ll ctr = 0;\\n        //nc2 = n*n-1 / 2\\n        for(auto it : mpp){\\n            ll choose2 = (it.second * (it.second-1))/2;\\n            if(it.first == 0){\\n                ctr+= (choose2 + it.second);\\n            }\\n            else{\\n                ctr += choose2;\\n            }\\n        }\\n        return ctr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        unordered_map<ll, ll> mpp; //value, count\\n        ll xorv = 0;\\n        for(int no : nums){\\n            xorv = xorv ^ no;\\n            mpp[xorv]++;\\n        }\\n\\n        ll ctr = 0;\\n        //nc2 = n*n-1 / 2\\n        for(auto it : mpp){\\n            ll choose2 = (it.second * (it.second-1))/2;\\n            if(it.first == 0){\\n                ctr+= (choose2 + it.second);\\n            }\\n            else{\\n                ctr += choose2;\\n            }\\n        }\\n        return ctr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327487,
                "title": "c-code-using-prefix-xor",
                "content": "c++  code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& v) {\\n        \\n        unordered_map<int,int> mp;\\n        mp[0]=1;\\n        \\n        long long ans = 0, prev = 0;\\n        for (auto x : v)\\n        {\\n            ans += mp[prev ^= x];\\n            mp[prev]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& v) {\\n        \\n        unordered_map<int,int> mp;\\n        mp[0]=1;\\n        \\n        long long ans = 0, prev = 0;\\n        for (auto x : v)\\n        {\\n            ans += mp[prev ^= x];\\n            mp[prev]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318368,
                "title": "easy-solution-by-counting-subarrays-of-zero-sum-in-c",
                "content": "```\\nlong long beautifulSubarrays(vector<int>& nums) {\\n        unordered_map<long long,long long>mp;\\n        int n=nums.size();\\n        int x=0;\\n        for(int i=0;i<n;i++){\\n            x^=nums[i];\\n            if(mp.find(x)==mp.end()) mp[x]=1;\\n            else mp[x]++;\\n        }\\n        long long ans=0;\\n        for(auto i : mp ){\\n            long long cnt=i.second;\\n            \\n            if(i.first==0) ans+= ((cnt*(cnt-1))/2) +cnt;\\n            else ans+= ((cnt*(cnt-1))/2);\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n**Please Upvote if found Usefull **",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nlong long beautifulSubarrays(vector<int>& nums) {\\n        unordered_map<long long,long long>mp;\\n        int n=nums.size();\\n        int x=0;\\n        for(int i=0;i<n;i++){\\n            x^=nums[i];\\n            if(mp.find(x)==mp.end()) mp[x]=1;\\n            else mp[x]++;\\n        }\\n        long long ans=0;\\n        for(auto i : mp ){\\n            long long cnt=i.second;\\n            \\n            if(i.first==0) ans+= ((cnt*(cnt-1))/2) +cnt;\\n            else ans+= ((cnt*(cnt-1))/2);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3313050,
                "title": "java-easy-hash-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long beautifulSubarrays(int[] nums) {\\n    long ans = 0;\\n    int x = 0;\\n    HashMap<Integer, Integer> t = new HashMap<>();\\n    t.put(0,1);\\n\\n    for(int n : nums){\\n      Integer num = t.get(x^=n);\\n      if(num == null) t.put(x, 1);\\n      else{\\n        ans += num;\\n        t.put(x, ++num);\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long beautifulSubarrays(int[] nums) {\\n    long ans = 0;\\n    int x = 0;\\n    HashMap<Integer, Integer> t = new HashMap<>();\\n    t.put(0,1);\\n\\n    for(int n : nums){\\n      Integer num = t.get(x^=n);\\n      if(num == null) t.put(x, 1);\\n      else{\\n        ans += num;\\n        t.put(x, ++num);\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310691,
                "title": "prefix-xor-unordered-map-c",
                "content": "# Intuition\\nWe have to take an positive integer k, such that kth bit of nums[i] & nums[j] is 1 & then subtract 2^k from both nums[i] & nums[j].\\n    4: 100\\n    3: 011  --> 2nd bit is 1\\n    1: 001\\n    2: 010  --> 2nd bit is 1    So, subtract 2^1 from 3 and 2 i.e. just unset kth bit\\n    4: 100\\nSo, we just have to unset kth bit of both element & ultimately find the subarray where all elements will be of 0bits. That actually means that find a subarray where XOR of all elements will be 0.\\n```\\nnums:   4 3 1 2 4\\numap: 0 4 7 6 4 0\\n    0 is repeating i.e. XOR(4,3,1,2,4) = 0\\n    4 is repeating i.e. XOR(3,1,2) = 0\\n```\\n\\n# Approach\\n  So, we will take a unordered_map that will previously store 0. In each iteration, we will maintain a prefixXor value of the elements from 0 to ith element & will check whether the value is already present in the map or not. If that is already present, then increment our answer by that map-value. Then increment the map[prefixXor] by 1. Finally, return the answer.\\n\\n```\\numap :  0 4 1 2 3 4 5 6 4 7 8 4\\nfound:    .       .     .     .\\nans  :    0       1     3     6\\n\\n    The 6 Subarrays: [1,2,3,4], [5,6,4], [7,8,4], [1,2,3,4,5,6,4],\\n[5,6,4,7,8,4], [1,2,3,4,5,6,4,7,8,4].\\n```\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long prefixXor=0, ans=0;\\n        unordered_map<long long, int> umap;\\n        umap[0] = 1;    // if again 0 found in the umap\\n\\n        for(int i=0; i<nums.size(); i++){\\n            prefixXor ^= nums[i];\\n            if(umap.find(prefixXor) != umap.end()){\\n                ans += umap[prefixXor];\\n            }\\n            umap[prefixXor]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnums:   4 3 1 2 4\\numap: 0 4 7 6 4 0\\n    0 is repeating i.e. XOR(4,3,1,2,4) = 0\\n    4 is repeating i.e. XOR(3,1,2) = 0\\n```\n```\\numap :  0 4 1 2 3 4 5 6 4 7 8 4\\nfound:    .       .     .     .\\nans  :    0       1     3     6\\n\\n    The 6 Subarrays: [1,2,3,4], [5,6,4], [7,8,4], [1,2,3,4,5,6,4],\\n[5,6,4,7,8,4], [1,2,3,4,5,6,4,7,8,4].\\n```\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long prefixXor=0, ans=0;\\n        unordered_map<long long, int> umap;\\n        umap[0] = 1;    // if again 0 found in the umap\\n\\n        for(int i=0; i<nums.size(); i++){\\n            prefixXor ^= nums[i];\\n            if(umap.find(prefixXor) != umap.end()){\\n                ans += umap[prefixXor];\\n            }\\n            umap[prefixXor]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309164,
                "title": "simple-xor-logic",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    ll beautifulSubarrays(vector<int>& a) {\\n        ll ans=0,cnt=0;\\n        unordered_map<ll,ll> mp;\\n        mp[cnt]=1;\\n    \\n        for(ll i=0;i<a.size();i++){\\n            cnt^=a[i];\\n            ans+=mp[cnt]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    ll beautifulSubarrays(vector<int>& a) {\\n        ll ans=0,cnt=0;\\n        unordered_map<ll,ll> mp;\\n        mp[cnt]=1;\\n    \\n        for(ll i=0;i<a.size();i++){\\n            cnt^=a[i];\\n            ans+=mp[cnt]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309015,
                "title": "using-prefix-array",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n       vector<long long>prefix(nums.size()+1 ) ;\\n       prefix[0]=nums[0];\\n       for(int i=1;i<nums.size();i++)\\n       prefix[i]=prefix[i-1]^nums[i];\\n    //    for(int i=0;i<prefix.size();i++)\\n    //    cout<<prefix[i]<<\"  \";\\n       long long ans=0;\\n       map<int,int>m;\\n       m[0]=1;\\n       for(int i=0;i<prefix.size();i++)\\n       cout<<prefix[i]<<\"  \";\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           if(m.find(prefix[i])!=m.end())\\n           ans+=m[prefix[i]];\\n           m[prefix[i]]++;\\n       }  \\n       return ans;\\n       \\n       }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n       vector<long long>prefix(nums.size()+1 ) ;\\n       prefix[0]=nums[0];\\n       for(int i=1;i<nums.size();i++)\\n       prefix[i]=prefix[i-1]^nums[i];\\n    //    for(int i=0;i<prefix.size();i++)\\n    //    cout<<prefix[i]<<\"  \";\\n       long long ans=0;\\n       map<int,int>m;\\n       m[0]=1;\\n       for(int i=0;i<prefix.size();i++)\\n       cout<<prefix[i]<<\"  \";\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           if(m.find(prefix[i])!=m.end())\\n           ans+=m[prefix[i]];\\n           m[prefix[i]]++;\\n       }  \\n       return ans;\\n       \\n       }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3307250,
                "title": "clean-go-solution-with-analysis-video",
                "content": "# Intuition\\nA little bit wordy, but once analyzed and understood, the problem becomes pretty easy and clean to code.\\n\\n# Approach\\nWe see that subarray of index i to j is beautiful only if the xor of these values is zero. This leads to O(N^2) solution where we can iterate through i and j.\\nA linear solution reveals itself when we understand that, the subarray from i to j is also beautiful if accumulated xor values from 0 to i is equal to 0 to j.\\nThen we can keep a running xor and storing the value in hashmap to check if we have seen it before\\n\\nDetailed analysis and code in Go, C++, Python can be seen at: https://youtu.be/XBd9SNdaHmc\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n// Compute Complexity = O(N)\\n// Space Complexity = O(N)\\n\\nfunc beautifulSubarrays(nums []int) int64 {\\n    xorHist := map[int]int64 {0: 1}\\n    sum := int64(0)\\n    currXor := 0\\n\\n    for _, v := range(nums) {\\n        currXor ^= v\\n        sum += xorHist[currXor]\\n        xorHist[currXor]++\\n    }\\n\\n    return sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// Compute Complexity = O(N)\\n// Space Complexity = O(N)\\n\\nfunc beautifulSubarrays(nums []int) int64 {\\n    xorHist := map[int]int64 {0: 1}\\n    sum := int64(0)\\n    currXor := 0\\n\\n    for _, v := range(nums) {\\n        currXor ^= v\\n        sum += xorHist[currXor]\\n        xorHist[currXor]++\\n    }\\n\\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3306414,
                "title": "easy-c-code-in-o-n",
                "content": "# Intuition\\nHere we have to make all the elements of the subarray 0. and we can make two elements\\' kth bit 0 when they both are 1. So, we have to make set bits of all the elements in the subarray as 0. This means that we have to find subarray with xor as 0.\\n\\n# Approach\\nWe will keep iterating the array and store the xor till now in the \\'curr\\' variable. Now, if the \\'curr\\' becomes 0 then it means that the xor of elements from 0th index to ith index is 0 and it is good subarray and we will add 1 in the count. \\n\\nWe also need to check if the \\'curr\\' value has been previously encountered, and if that is the case then there is definietly subarray which is between \\'the index where the value was previously encountered\\' and \\'current index\\' and there can be many such indexes. So we will add the frequency of such occurence to count.\\n\\nIn the end the value stored in count will be our answer.  \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        \\n        int curr=0;\\n        \\n        long long count=0;\\n        for(int i=0;i<nums.size();i++){\\n            curr = curr^nums[i];\\n            \\n            if(curr == 0) count++;\\n            \\n            if(mp.find(curr) != mp.end()){\\n                count += mp[curr];\\n            }\\n                mp[curr]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        \\n        int curr=0;\\n        \\n        long long count=0;\\n        for(int i=0;i<nums.size();i++){\\n            curr = curr^nums[i];\\n            \\n            if(curr == 0) count++;\\n            \\n            if(mp.find(curr) != mp.end()){\\n                count += mp[curr];\\n            }\\n                mp[curr]++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3305328,
                "title": "two-short-solutions-1-pair-counting-2-dp",
                "content": "# Key observation\\nImagine that for a subarray you stack all the numbers in binary and sum how many ones there are in each binary position. For an array to be beautiful, **all `1`\\'s need to come in pairs**. This is equivalent to all numbers in the subarray xor collectively to zero.\\n\\n# solution 1\\nCount the number of pairs with the same prefix XOR:\\n```\\ndef beautifulSubarrays(self, nums: List[int]) -> int:\\n    c = Counter(accumulate(nums, xor, initial = 0))\\n    return sum (n*(n-1) for n in c.values()) // 2\\n```\\n\\n# solution 2, DP:\\nState of a given number `num` is `state[num ^ xorant]`.\\nIn each DP step we want to count the number of beautiful arrays ending at `num`. From the previous step we know all the subarrays left to it which xor together to any number. In the step we want to include the new number into the cumulative `xorant`, include an array of lenth one consisting of `[num]`, which is represented as `state[old_xorant ^ num ^ num]` which boils down to `state[old_xorant]` and we want to add to the `ret` return value all previous arrays extended by `[num]` which is `state[0 ^ xorant]`, because `0` is when we there is a beautiful array (all bits are come in pairs)\\n\\n```\\ndef beautifulSubarrays(self, nums: List[int]) -> int:\\n    state = defaultdict(int)\\n    xorant = 0\\n    ret = 0\\n    for num in nums:\\n        state[xorant] += 1\\n        xorant ^= num\\n        ret += state[xorant]\\n    return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef beautifulSubarrays(self, nums: List[int]) -> int:\\n    c = Counter(accumulate(nums, xor, initial = 0))\\n    return sum (n*(n-1) for n in c.values()) // 2\\n```\n```\\ndef beautifulSubarrays(self, nums: List[int]) -> int:\\n    state = defaultdict(int)\\n    xorant = 0\\n    ret = 0\\n    for num in nums:\\n        state[xorant] += 1\\n        xorant ^= num\\n        ret += state[xorant]\\n    return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3303303,
                "title": "c-solution-using-bit-manipulation-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing hash map and xor operation in  bit manipulation\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //xor operation\\n    long long beautifulSubarrays(vector<int>& nums) {\\n       \\n        int n=nums.size();\\n        \\n        unordered_map<int,int> map;\\n        \\n        map.insert({0,1});\\n        \\n        int _xor=0;\\n        long long count=0;\\n        for(int i=0;i<n;i++){\\n            _xor^=nums[i];\\n            \\n            if(map.find(_xor)!=map.end()){\\n                count+=map[_xor];\\n            }\\n            if(map.find(_xor)!=map.end()){\\n                map[_xor]+=1;\\n            }else{\\n                map[_xor]=1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //xor operation\\n    long long beautifulSubarrays(vector<int>& nums) {\\n       \\n        int n=nums.size();\\n        \\n        unordered_map<int,int> map;\\n        \\n        map.insert({0,1});\\n        \\n        int _xor=0;\\n        long long count=0;\\n        for(int i=0;i<n;i++){\\n            _xor^=nums[i];\\n            \\n            if(map.find(_xor)!=map.end()){\\n                count+=map[_xor];\\n            }\\n            if(map.find(_xor)!=map.end()){\\n                map[_xor]+=1;\\n            }else{\\n                map[_xor]=1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302017,
                "title": "c-golang-map-prefix-xor",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans = 0, currXor = 0;\\n        unordered_map<int, int> Map;\\n        Map[0] = 1;\\n        for(int num: nums) {\\n            currXor ^= num;\\n            ans += Map[currXor];\\n            Map[currXor]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc beautifulSubarrays(nums []int) int64 {\\n    var ans int64 = 0\\n    var currXor int = 0\\n    Map := make(map[int]int)\\n    Map[0] = 1\\n    for _, num := range nums {\\n        currXor ^= num\\n        ans += int64(Map[currXor])\\n        Map[currXor]++\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Hash Table",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans = 0, currXor = 0;\\n        unordered_map<int, int> Map;\\n        Map[0] = 1;\\n        for(int num: nums) {\\n            currXor ^= num;\\n            ans += Map[currXor];\\n            Map[currXor]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc beautifulSubarrays(nums []int) int64 {\\n    var ans int64 = 0\\n    var currXor int = 0\\n    Map := make(map[int]int)\\n    Map[0] = 1\\n    for _, num := range nums {\\n        currXor ^= num\\n        ans += int64(Map[currXor])\\n        Map[currXor]++\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296572,
                "title": "c-solution",
                "content": "# Watch This for detail Explanation :\\nhttps://youtu.be/8jx35mkivJ8\\n- Time Complexity : O(n)\\n- Space Complexity : O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        \\n        int prefXor = 0;\\n        long long ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            prefXor = prefXor ^ nums[i];\\n            if(mp.find(prefXor) != mp.end()) ans += mp[prefXor];\\n            mp[prefXor]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        \\n        int prefXor = 0;\\n        long long ans = 0;\\n        \\n        for(int i=0; i<n; i++) {\\n            prefXor = prefXor ^ nums[i];\\n            if(mp.find(prefXor) != mp.end()) ans += mp[prefXor];\\n            mp[prefXor]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296021,
                "title": "easy-approach-xor-sum-linear-time-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& arr) {\\n        int n = arr.size();\\n        long long count = 0;\\n        unordered_map<int, int> mp;\\n        mp[0] = 1;\\n        int xor_sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            xor_sum ^= arr[i];\\n            count += mp[xor_sum];\\n            mp[xor_sum]++;\\n        }\\n        return count;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& arr) {\\n        int n = arr.size();\\n        long long count = 0;\\n        unordered_map<int, int> mp;\\n        mp[0] = 1;\\n        int xor_sum = 0;\\n        for (int i = 0; i < n; i++) {\\n            xor_sum ^= arr[i];\\n            count += mp[xor_sum];\\n            mp[xor_sum]++;\\n        }\\n        return count;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294378,
                "title": "python3-o-n-bitwise-xor-prefix-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery op is targeted to remove same bit 1 in two numbers, the opration can be done with xor. The beautiful subarrays are arrays that xor of all values in 0. We use a dict to store all prefix values of nums[0,...,r].\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        dt, cur = {0: 1}, 0\\n        for v in nums:\\n            cur ^= v\\n            dt[cur] = dt.get(cur, 0) + 1\\n        return sum(v * (v - 1) // 2 for v in dt.values())\\n         \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        dt, cur = {0: 1}, 0\\n        for v in nums:\\n            cur ^= v\\n            dt[cur] = dt.get(cur, 0) + 1\\n        return sum(v * (v - 1) // 2 for v in dt.values())\\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294072,
                "title": "from-knowing-nothing-and-deriving-prefix-xor-on-my-own",
                "content": "\\nI never read anything about the XOR trick. When I see this question, my first thought is, we need to find subarray that for each unit bit, it must be even numbers of 1 / all zeroes, we want things to \\'balance out\\'. XOR , can cancelled out duplicates. If this pattern resembles the hashmap counting (subarray xxx equals xxx / divisible xxx), there must be some way, telling us which \\'segment\\' satisfy this property. In order for things to cancel out and become zero, we want the XOR , return to its original state. So for each number in the \\'prefix xor\\', we want to look back to find the same number, which is the \\'nothing has been done state\\'.\\n\\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        pref = 0\\n        rmap = defaultdict(int)\\n        rmap[pref] = 1\\n        res = 0\\n        for i in range(len(nums)):\\n            pref ^= nums[i]\\n            res += rmap.get(pref,0)\\n            rmap[pref] += 1\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\nI never read anything about the XOR trick. When I see this question, my first thought is, we need to find subarray that for each unit bit, it must be even numbers of 1 / all zeroes, we want things to \\'balance out\\'. XOR , can cancelled out duplicates. If this pattern resembles the hashmap counting (subarray xxx equals xxx / divisible xxx), there must be some way, telling us which \\'segment\\' satisfy this property. In order for things to cancel out and become zero, we want the XOR , return to its original state. So for each number in the \\'prefix xor\\', we want to look back to find the same number, which is the \\'nothing has been done state\\'.\\n\\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        pref = 0\\n        rmap = defaultdict(int)\\n        rmap[pref] = 1\\n        res = 0\\n        for i in range(len(nums)):\\n            pref ^= nums[i]\\n            res += rmap.get(pref,0)\\n            rmap[pref] += 1\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 3293942,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public long beautifulSubarrays(int[] nums) {\\n        long res = 0;\\n        int fre[] = new int[1048576];\\n        fre[0] = 1;\\n        int xor = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            xor ^= nums[i];\\n            res += (long) fre[xor];\\n            fre[xor]++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public long beautifulSubarrays(int[] nums) {\\n        long res = 0;\\n        int fre[] = new int[1048576];\\n        fre[0] = 1;\\n        int xor = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            xor ^= nums[i];\\n            res += (long) fre[xor];\\n            fre[xor]++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293569,
                "title": "very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        vector<int> count(2000002,0);\\n        count[0]=1; //if the curr xor is 0, that means so far, every bit pair was all 1s, or all 0s, and they can be subtracted. so we would add one.  if the curr xor is not 0, then there does not exist the same bit yet that is all 1 or all 0\\n        long long ans =0;\\n        int cur =0;\\n        for (int i=0; i < nums.size(); i++)\\n        {\\n            cur ^= nums[i];\\n            ans += count[cur]; //if cur==0, +1, there is a subarray that can be subtracted to be 0\\n            count[cur]++; //if we encounter cur==0 (or any cur) again, then there will be 2 subarrays, the one now, and the one that will happen again\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        vector<int> count(2000002,0);\\n        count[0]=1; //if the curr xor is 0, that means so far, every bit pair was all 1s, or all 0s, and they can be subtracted. so we would add one.  if the curr xor is not 0, then there does not exist the same bit yet that is all 1 or all 0\\n        long long ans =0;\\n        int cur =0;\\n        for (int i=0; i < nums.size(); i++)\\n        {\\n            cur ^= nums[i];\\n            ans += count[cur]; //if cur==0, +1, there is a subarray that can be subtracted to be 0\\n            count[cur]++; //if we encounter cur==0 (or any cur) again, then there will be 2 subarrays, the one now, and the one that will happen again\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293495,
                "title": "java-c-explanation-using-prefix-xor-and-map",
                "content": "# Intuition\\n\\nWe have to find a subarray whose elements are zero after performing some number of given operations on the subarray.Such a subarray would be possible only if each bit(power of 2) would exist an even number of times across the elements of subarray.This in turn would imply that the xor of the subarray would be 0.Thus we have to count the number of subarray with xor 0.\\n\\n# Approach\\n\\nTo solve the problem of counting subarrays with xor 0 we make use of prefix xor and a map.A variable is used to keep track of xor of elements of array till current point and map is used to keep track of different xor values encountered till now and their count.Whenever we reach a xor value if this value is present in map this means the subarray of elements between the two values would have its xor as 0.Thus we add all such number of subarrays to get our answer.Simply put if we reach a xor value again this means the xor of elements in between the two values would have xor 0.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n\\nC++\\n\\n```\\nclass Solution \\n{\\n    public:\\n    long long beautifulSubarrays(vector<int>& nums)\\n    {\\n        unordered_map<int,int> mp;\\n        long long prxor=0,ans=0;\\n        mp[0]=1;\\n        for(int x:nums)\\n        {\\n            prxor^=x;\\n            if(mp.find(prxor)!=mp.end())\\n            {\\n                ans+=mp[prxor];\\n                mp[prxor]+=1;\\n            }\\n            else\\n            {\\n                mp[prxor]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nJava\\n\\n```\\nclass Solution\\n{\\n    public long beautifulSubarrays(int[] a) \\n    {\\n        Map<Long,Integer> map=new HashMap<>();\\n        long ans=0,x=0;\\n        map.put(x,1);\\n        for(int n:a)\\n        {\\n            x^=n;\\n            if(map.containsKey(x))\\n            {\\n                ans+=map.get(x);\\n                map.put(x,map.get(x)+1);\\n            }\\n            else\\n            {\\n                map.put(x,1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nDo upvote if you like!!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Ordered Map",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    long long beautifulSubarrays(vector<int>& nums)\\n    {\\n        unordered_map<int,int> mp;\\n        long long prxor=0,ans=0;\\n        mp[0]=1;\\n        for(int x:nums)\\n        {\\n            prxor^=x;\\n            if(mp.find(prxor)!=mp.end())\\n            {\\n                ans+=mp[prxor];\\n                mp[prxor]+=1;\\n            }\\n            else\\n            {\\n                mp[prxor]=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\n    public long beautifulSubarrays(int[] a) \\n    {\\n        Map<Long,Integer> map=new HashMap<>();\\n        long ans=0,x=0;\\n        map.put(x,1);\\n        for(int n:a)\\n        {\\n            x^=n;\\n            if(map.containsKey(x))\\n            {\\n                ans+=map.get(x);\\n                map.put(x,map.get(x)+1);\\n            }\\n            else\\n            {\\n                map.put(x,1);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293020,
                "title": "python3-precomputation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        M = DefaultDict(int)\\n\\n        val = 0\\n        M[val] += 1\\n\\n        for i in range(0, len(nums)):\\n            val = val ^ nums[i]\\n            M[val] += 1\\n\\n        res = 0\\n\\n        for m in M:\\n            res += (M[m] * (M[m]-1)) // 2\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        M = DefaultDict(int)\\n\\n        val = 0\\n        M[val] += 1\\n\\n        for i in range(0, len(nums)):\\n            val = val ^ nums[i]\\n            M[val] += 1\\n\\n        res = 0\\n\\n        for m in M:\\n            res += (M[m] * (M[m]-1)) // 2\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292796,
                "title": "c-solution-using-hashmap-and-prefix-count-without-xor",
                "content": "# Intuition\\n\\n\\n \\n\\n# Approach\\nIf you cannot come up with a xor solution on the first glance, try to go a bit deeper and understand the basic underlying problem.\\n\\nSimilar to prefix sum array, instead getting sum of the numbers maintain array with count of set bits from 0th index to ith index.\\n\\nAt ith index, if for a given bit position, count of the numbers from 0th index to ith index with bit set, \\n- is even, get the count of previous numbers for which prefix count of the given bit is even.\\n- is odd, get the count of previous numbers for which prefix count of the given bit is odd.\\n\\nWhile computing prefix array, \\nmaintain a bitmap that captures even or odd number of set bits for each bit position. \\n\\nbitmap -  bit value 1 represent - count is odd, bit value 0 represents count is even for that particular bit position.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nconstexpr int TOTAL_BITS = sizeof(int) * 8;\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        long long res = 0;\\n        unordered_map<uint, int> bitmapCount; // bitmap, count\\n        vector<int> prefix(TOTAL_BITS);\\n        for(int i = 0; i < nums.size(); ++i) {\\n            uint bitmap = 0U;\\n           for(int bit = 0; bit < TOTAL_BITS; ++bit) {\\n                if((1U << bit) & nums[i])\\n                    ++prefix[bit];\\n                if(prefix[bit] % 2 == 1) {\\n                    bitmap |= 1U << bit;\\n                }                        \\n           }\\n           res += bitmapCount[bitmap];\\n           if(bitmap == 0) ++res;\\n           ++bitmapCount[bitmap];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconstexpr int TOTAL_BITS = sizeof(int) * 8;\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        long long res = 0;\\n        unordered_map<uint, int> bitmapCount; // bitmap, count\\n        vector<int> prefix(TOTAL_BITS);\\n        for(int i = 0; i < nums.size(); ++i) {\\n            uint bitmap = 0U;\\n           for(int bit = 0; bit < TOTAL_BITS; ++bit) {\\n                if((1U << bit) & nums[i])\\n                    ++prefix[bit];\\n                if(prefix[bit] % 2 == 1) {\\n                    bitmap |= 1U << bit;\\n                }                        \\n           }\\n           res += bitmapCount[bitmap];\\n           if(bitmap == 0) ++res;\\n           ++bitmapCount[bitmap];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291848,
                "title": "c-easy-approach-explanation-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen you deely analyse the question you will get it is same problem as finding the number of subarrays who xor is equal to 0.\\n\\nThe main idea is to observe the prefix xor of the array. Prefix Xor is just another array, where each index contains XOR of all elements of the original array starting from index 0 up to that index. In other words\\nprefix_xor[i] = XOR(a[0], a[1], a[2],\\u2026\\u2026,a[I])\\n\\nOnce we have made the prefix xor array, we observe a fact:\\n\\nP = xor(a[0], a[1], a[2],\\u2026\\u2026, a[q], a[q+1],\\u2026.., a[p])\\nQ = xor(a[0], a[1], a[2],\\u2026\\u2026, a[q])\\n\\nTherefore,\\nP^Q = xor(a[q+1],\\u2026.., a[p]) = M                                \\nSo, now we understand that from the prefix xor array when we XOR two elements at different indices we get the xor of the elements (in the original array) that were between those indices.\\nLet\\u2019s say, we got P == Q . What does this mean?\\nThis means that the subarray between q and p is having xor = 0. To understand this we just use simple examples:\\nlet nums = {1,2,3,4,5,6,6,5,7,8,9}\\n, P = {1,2,3,4,5,6,6,5}\\nand Q = {1,2,3,4}\\nand XOR(P) = p and XOR(Q) = q\\nWe find that p == q , this means elements between subarrays P and Q have an XOR equal to 0 i.e. XOR){5,6,6,5} = 0 , which is indeed true.\\n\\nIMP NOTE: although we talk about prefix xor \\u201Carray\\u201D, it should be noted that at a time we need only one element of this array. Hence, we can just use a variable to maintain the prefix xor. \\n\\n# Approach \\nWe need to traverse the array while we maintain variables for current_perfix_xor, counter, and also a map to keep track of visited xors. This map will maintain the frequency count of all previous visited current_prefix_xor values. If for any index current_prefix_xor is equal to 0, we increment the counter. If for any index we find that current_prefix_xor is present in the visited map, we increment the counter by visited[current_prefix_xor]. At every index, we insert the current_prefix_xor into the visited map with its frequency.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long cpx=0;\\n        long long cnt=0;\\n        unordered_map<long long , int> mp;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            cpx = cpx^nums[i];\\n            if(cpx==0){\\n                cnt++;\\n            }\\n            if(mp.find(cpx)!=mp.end()){\\n                cnt += mp[cpx];\\n            }\\n            mp[cpx]++;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long cpx=0;\\n        long long cnt=0;\\n        unordered_map<long long , int> mp;\\n        for(int i=0 ; i<nums.size() ; i++){\\n            cpx = cpx^nums[i];\\n            if(cpx==0){\\n                cnt++;\\n            }\\n            if(mp.find(cpx)!=mp.end()){\\n                cnt += mp[cpx];\\n            }\\n            mp[cpx]++;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291501,
                "title": "prefix-sum-xor-method",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int prefix[nums.size()];\\n        memset(prefix,0,sizeof(prefix));\\n        prefix[0]=nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            prefix[i]=(prefix[i-1]^nums[i]);\\n        }\\n        map<int,int>m;\\n        long long ans=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(prefix[i]==0) ans++;\\n            ans+=m[prefix[i]];\\n            m[prefix[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int prefix[nums.size()];\\n        memset(prefix,0,sizeof(prefix));\\n        prefix[0]=nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            prefix[i]=(prefix[i-1]^nums[i]);\\n        }\\n        map<int,int>m;\\n        long long ans=0;\\n        for(int i=0; i<nums.size(); i++){\\n            if(prefix[i]==0) ans++;\\n            ans+=m[prefix[i]];\\n            m[prefix[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291416,
                "title": "100-o-n-simple-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& a) {\\n        unordered_map<int,int> m;\\n        \\n        int n = a.size();\\n  \\n        m[0]=0;      \\n        int x = 0;  \\n        long long ans = 0;\\n        \\n        int temp=0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            x = x ^ a[i];\\n\\n            temp = 0;\\n\\n            if(m.find(x)!=m.end()){\\n                temp = m[x]+1;\\n                ans+=temp;              \\n            }\\n            \\n            m[x]=temp;\\n         \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& a) {\\n        unordered_map<int,int> m;\\n        \\n        int n = a.size();\\n  \\n        m[0]=0;      \\n        int x = 0;  \\n        long long ans = 0;\\n        \\n        int temp=0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            x = x ^ a[i];\\n\\n            temp = 0;\\n\\n            if(m.find(x)!=m.end()){\\n                temp = m[x]+1;\\n                ans+=temp;              \\n            }\\n            \\n            m[x]=temp;\\n         \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291293,
                "title": "c-prefix-xor",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long pre = 0, ans = 0;\\n        unordered_map<int, int> mp;\\n        mp[0]++;\\n        for(int i = 0, n = nums.size(); i < n; i++){\\n            pre ^= nums[i];\\n            ans += mp[pre];\\n            mp[pre]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long pre = 0, ans = 0;\\n        unordered_map<int, int> mp;\\n        mp[0]++;\\n        for(int i = 0, n = nums.size(); i < n; i++){\\n            pre ^= nums[i];\\n            ans += mp[pre];\\n            mp[pre]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290996,
                "title": "simple-prefix-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nprefix XOR ===> exactly same problem like no of subarrays with zero sum; \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nprefix Xor\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        long long ans = 0;\\n        int prex = 0;\\n        \\n        map<int, int> mp;\\n        \\n        for(int i = 0; i<n; i++){\\n            prex ^= nums[i];\\n            if(mp.count(prex)){\\n\\n                ans+=mp[prex];\\n            }\\n            \\n            if(prex==0){\\n                ans++;\\n            }\\n            mp[prex]++;\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        long long ans = 0;\\n        int prex = 0;\\n        \\n        map<int, int> mp;\\n        \\n        for(int i = 0; i<n; i++){\\n            prex ^= nums[i];\\n            if(mp.count(prex)){\\n\\n                ans+=mp[prex];\\n            }\\n            \\n            if(prex==0){\\n                ans++;\\n            }\\n            mp[prex]++;\\n        }\\n        \\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290918,
                "title": "dict-and-check-solution-with-xor-python",
                "content": "1- A Solution Format\\n```\\n\"\"\"\\nTreatment: dict and check\\n\\nIdea: for each index j, find the number of beautiful subarrays ending at j.\\n\\nHow to do the counting? This is very routine: assume the XOR result \\n\\nXOR(nums[0...j]) = f = nums[0] ^ ... ^ nums[i] ^ nums^[i+1] ^... ^ nums[j]\\nXOR(nums[0...i]) = f = nums[0] ^ ... ^ nums[i] \\n\\nThen XOR(nums[i+1...j]) = f ^ f = 0\\n\\nTherefore, to count the number of beautiful subarrays ending at j, we just need\\nto use a dict to retrieve the frequency of f appeared before j\\n\\n\\nA walkthrough of eg-1: nums = [4,3,1,2,4]\\n\\nindex is 0; xor res: 4, prev appreared times: 0\\nindex is 1; xor res: 7, prev appreared times: 0\\nindex is 2; xor res: 6, prev appreared times: 0\\nindex is 3; xor res: 4, prev appreared times: 1\\nindex is 4; xor res: 0, prev appreared times: 1\\n\\nreturn 1 + 1 = 2\\n\\n# T = O(n) where n = len(nums)\\n\\n# Extension: can you find specifically all the beautiful subarraries?\\n\\n\"\"\"\\n\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        \\n        d = {0:1}\\n        res = 0\\n        prod_xor = 0\\n        for y in nums:\\n            prod_xor ^= y\\n            freq = d.get(prod_xor, 0)\\n            res += freq\\n            d[prod_xor] = freq + 1\\n        return res\\n        \\n```\\n2- Video Explanation: [Click Here](https://youtu.be/aVNIPCteyrE;)\\n\\nFollow up channel for more problems of the same type and other problems and analysis.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nTreatment: dict and check\\n\\nIdea: for each index j, find the number of beautiful subarrays ending at j.\\n\\nHow to do the counting? This is very routine: assume the XOR result \\n\\nXOR(nums[0...j]) = f = nums[0] ^ ... ^ nums[i] ^ nums^[i+1] ^... ^ nums[j]\\nXOR(nums[0...i]) = f = nums[0] ^ ... ^ nums[i] \\n\\nThen XOR(nums[i+1...j]) = f ^ f = 0\\n\\nTherefore, to count the number of beautiful subarrays ending at j, we just need\\nto use a dict to retrieve the frequency of f appeared before j\\n\\n\\nA walkthrough of eg-1: nums = [4,3,1,2,4]\\n\\nindex is 0; xor res: 4, prev appreared times: 0\\nindex is 1; xor res: 7, prev appreared times: 0\\nindex is 2; xor res: 6, prev appreared times: 0\\nindex is 3; xor res: 4, prev appreared times: 1\\nindex is 4; xor res: 0, prev appreared times: 1\\n\\nreturn 1 + 1 = 2\\n\\n# T = O(n) where n = len(nums)\\n\\n# Extension: can you find specifically all the beautiful subarraries?\\n\\n\"\"\"\\n\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        \\n        d = {0:1}\\n        res = 0\\n        prod_xor = 0\\n        for y in nums:\\n            prod_xor ^= y\\n            freq = d.get(prod_xor, 0)\\n            res += freq\\n            d[prod_xor] = freq + 1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290807,
                "title": "xor-and-map",
                "content": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        unordered_map<int,int>mpp;\\n        \\n        mpp[0]=1;\\n        \\n        long long cnt=0,ans=0;\\n        \\n        for(auto it:nums){\\n            \\n            ans^=it;\\n            \\n            if(mpp[ans]>0) cnt+=mpp[ans];\\n            \\n            mpp[ans]++;\\n            \\n        }\\n        \\n        return cnt;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        unordered_map<int,int>mpp;\\n        \\n        mpp[0]=1;\\n        \\n        long long cnt=0,ans=0;\\n        \\n        for(auto it:nums){\\n            \\n            ans^=it;\\n            \\n            if(mpp[ans]>0) cnt+=mpp[ans];\\n            \\n            mpp[ans]++;\\n            \\n        }\\n        \\n        return cnt;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290689,
                "title": "anyone-else-feel-the-problem-statement-is-wrong",
                "content": "The problem said\\n```\\nChoose two different indices i and j such that 0 <= i, j < nums.length.\\n```\\n, which is wrong. It should have said, the two indices **must be within the beautiful subarray**.\\n\\nOtherwise, given `[1,1]`, I can choose `i=0` and `j=1` with `k=0` and make the array `[0,0]`. Within that there are three subarrys:\\n```\\n[0]\\n  [0]\\n[0,0]\\n```\\n",
                "solutionTags": [],
                "code": "```\\nChoose two different indices i and j such that 0 <= i, j < nums.length.\\n```\n```\\n[0]\\n  [0]\\n[0,0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3290680,
                "title": "detailed-solution-with-approach",
                "content": "1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n    int n = nums.length;\\n    int[] prefix = new int[n];\\n    long count = 0;\\n    Map<Integer, Integer> prefixCount = new HashMap<>();\\n    prefixCount.put(0, 1);\\n    int prefixXor = 0;\\n    for (int i = 0; i < n; i++) {\\n        prefixXor ^= nums[i];\\n        prefix[i] = prefixXor;\\n        int beautifulSubarraysEndingHere = prefixCount.getOrDefault(prefixXor, 0);\\n        count += beautifulSubarraysEndingHere;\\n        prefixCount.put(prefixXor, beautifulSubarraysEndingHere + 1);\\n    }\\n    return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n    int n = nums.length;\\n    int[] prefix = new int[n];\\n    long count = 0;\\n    Map<Integer, Integer> prefixCount = new HashMap<>();\\n    prefixCount.put(0, 1);\\n    int prefixXor = 0;\\n    for (int i = 0; i < n; i++) {\\n        prefixXor ^= nums[i];\\n        prefix[i] = prefixXor;\\n        int beautifulSubarraysEndingHere = prefixCount.getOrDefault(prefixXor, 0);\\n        count += beautifulSubarraysEndingHere;\\n        prefixCount.put(prefixXor, beautifulSubarraysEndingHere + 1);\\n    }\\n    return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290551,
                "title": "explanation-easy-to-understand-c",
                "content": "# Approach\\nHere we are record the prefix xor and count the range where XOR=0 count answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n    int n=nums.size();\\n    vector<int> v(n+1,0);\\n    for(int i=0;i<n;i++) v[i+1]=v[i]^nums[i];\\n    long long ans=0;\\n    unordered_map<int,int> m;\\n    for(auto i:v){\\n        if(m[i])\\n        ans+=m[i];\\n        m[i]++;\\n    }\\n    return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n    int n=nums.size();\\n    vector<int> v(n+1,0);\\n    for(int i=0;i<n;i++) v[i+1]=v[i]^nums[i];\\n    long long ans=0;\\n    unordered_map<int,int> m;\\n    for(auto i:v){\\n        if(m[i])\\n        ans+=m[i];\\n        m[i]++;\\n    }\\n    return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290446,
                "title": "c-java-python3-prefix-freq-table",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/15456f4294fa2d2de5e056fc441f28872a0c2a71) for solutions of weekly 336. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans = 0; \\n        int prefix = 0; \\n        unordered_map<int, int> freq = {{0, 1}}; \\n        for (auto& x : nums) {\\n            prefix ^= x; \\n            ans += freq[prefix]++; \\n        }\\n        return ans; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        long ans = 0; \\n        int prefix = 0; \\n        HashMap<Integer, Integer> freq = new HashMap(); \\n        freq.put(0, 1); \\n        for (var x : nums) {\\n            prefix ^= x; \\n            ans += freq.getOrDefault(prefix, 0); \\n            freq.merge(prefix, 1, Integer::sum); \\n        }\\n        return ans; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        ans = prefix = 0 \\n        freq = Counter({0 : 1})\\n        for i, x in enumerate(nums): \\n            prefix ^= x\\n            ans += freq[prefix]\\n            freq[prefix] += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans = 0; \\n        int prefix = 0; \\n        unordered_map<int, int> freq = {{0, 1}}; \\n        for (auto& x : nums) {\\n            prefix ^= x; \\n            ans += freq[prefix]++; \\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        long ans = 0; \\n        int prefix = 0; \\n        HashMap<Integer, Integer> freq = new HashMap(); \\n        freq.put(0, 1); \\n        for (var x : nums) {\\n            prefix ^= x; \\n            ans += freq.getOrDefault(prefix, 0); \\n            freq.merge(prefix, 1, Integer::sum); \\n        }\\n        return ans; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        ans = prefix = 0 \\n        freq = Counter({0 : 1})\\n        for i, x in enumerate(nums): \\n            prefix ^= x\\n            ans += freq[prefix]\\n            freq[prefix] += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290359,
                "title": "easy-to-understand-c-100-code",
                "content": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long result = 0;\\n        unordered_map<int,int> mp;\\n        int acc = 0;\\n        mp[0] = 1;\\n        for (auto &n : nums) {\\n            acc = acc ^ n;\\n            auto it = mp.find(acc);\\n            // if same xor value is seen earlier, which means all number between last\\n            // seen xor value and current sums to 0\\n            if (it != mp.end()) {\\n                result += mp[acc];\\n            }\\n            mp[acc]++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long result = 0;\\n        unordered_map<int,int> mp;\\n        int acc = 0;\\n        mp[0] = 1;\\n        for (auto &n : nums) {\\n            acc = acc ^ n;\\n            auto it = mp.find(acc);\\n            // if same xor value is seen earlier, which means all number between last\\n            // seen xor value and current sums to 0\\n            if (it != mp.end()) {\\n                result += mp[acc];\\n            }\\n            mp[acc]++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290296,
                "title": "python-approach-with-bitwise-operator-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the remaining after substracting 2<sup>x</sup> between two numbers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, by initializing the prefix=0, and store the times that we have occured prefix x in preBefore. \\nThen, start finding the remainings between each number and the prefix by **bitwise operator** XOR.\\n```\\n# bitwise operator XOR\\na=0b101 # a=5\\nb=0b110 # b=6\\nc=a^b   # c=0b011=3\\n```\\nAfter substracting 2<sup>x</sup> between the prefix and the current number, look if we have got to the same number before.\\nThen add the times that we have reached the prefix.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        preBefore=Counter({0:1})\\n        res=0\\n        pre=0\\n\\n        for a in nums:\\n            # the bitwise operator xor^ will eliminate the 2^x we can subtract\\n            pre^=a\\n            # if we have reached the element before\\n            res+=preBefore[pre]\\n            # add the times we reached the element\\n            preBefore[pre]+=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# bitwise operator XOR\\na=0b101 # a=5\\nb=0b110 # b=6\\nc=a^b   # c=0b011=3\\n```\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        preBefore=Counter({0:1})\\n        res=0\\n        pre=0\\n\\n        for a in nums:\\n            # the bitwise operator xor^ will eliminate the 2^x we can subtract\\n            pre^=a\\n            # if we have reached the element before\\n            res+=preBefore[pre]\\n            # add the times we reached the element\\n            preBefore[pre]+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290117,
                "title": "python3-xor-o-n-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        xor_arr = []\\n        start = 0\\n        for element in nums:\\n            start = start ^ element\\n            xor_arr.append(start)\\n\\n        lookup = defaultdict(int)\\n        lookup[0] = 1\\n\\n        res = 0\\n\\n        for element in xor_arr:\\n            lookup[element] += 1\\n\\n        #(n choose 2)\\n        for _, value in lookup.items():\\n            res += int((value * (value - 1)) / 2)\\n        \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        xor_arr = []\\n        start = 0\\n        for element in nums:\\n            start = start ^ element\\n            xor_arr.append(start)\\n\\n        lookup = defaultdict(int)\\n        lookup[0] = 1\\n\\n        res = 0\\n\\n        for element in xor_arr:\\n            lookup[element] += 1\\n\\n        #(n choose 2)\\n        for _, value in lookup.items():\\n            res += int((value * (value - 1)) / 2)\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289721,
                "title": "golang-168-ms-10-mb",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n# Code\\n```\\nfunc beautifulSubarrays(nums []int) int64 {\\n\\th := make(map[uint32]uint32)\\n\\th[0] = 1\\n\\tvar result int64\\n\\tvar prefix int\\n\\tfor _, num := range nums {\\n\\t\\tprefix ^= num\\n\\t\\tresult += int64(h[uint32(prefix)])\\n\\t\\th[uint32(prefix)]++\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc beautifulSubarrays(nums []int) int64 {\\n\\th := make(map[uint32]uint32)\\n\\th[0] = 1\\n\\tvar result int64\\n\\tvar prefix int\\n\\tfor _, num := range nums {\\n\\t\\tprefix ^= num\\n\\t\\tresult += int64(h[uint32(prefix)])\\n\\t\\th[uint32(prefix)]++\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3289627,
                "title": "python-prefix-bit-count-explained",
                "content": "The idea is the same as the problem of finding the number of subarray with target sum equals to k.\\n\\nWe can use the same idea of tracking the count of prefix sum in the problem. In stead of prefix sum, we track the count of bit 1 of all the 32 bits up to each index. Since the problem is asking to find a beautiful subarray, which can apply any number of bit flips from 1 to 0 on two numbers, therefore, we acutually are finding a subarray that the total count of bit 1 at each bit index of all the numbers in this subarray is multiple of 2.\\n\\nFor example, a beautiful array [1, 3, 2]:\\nthe count of bit 1 at each bit index for this subarray is:\\nbit0 == 2 (from number 1 and 3)\\nbit1 == 2 (from number 3 and 2)\\n\\nAnother example of non-beautiful array [2, 4, 5]:\\nthe count of bit 1 at each bit index for this subarray is:\\nbit0 == 1 (from number 5)\\nbit1 == 1 (from number 2)\\nbit2 == 2 (from number 4, 5)\\n\\nAs we are checking if the count is multiple of 2, we only need to track the bit1 count mod by 2. We use the bit_count[32] to track the count pattern while sweeping the array, record it in a hash map.\\n\\nWhenever, we found a bit count pattern that is already in the hash map, we know that the subarray from current index to the previous index that has the same bit count pattern is a beautiful subarray.\\n\\nSum up all the beautiful subarrays while we sweep the list.\\n\\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        # Count the number of each bits in the subarray\\n        bit_count = [0] * 32\\n        prefix_bit_count = collections.defaultdict(int)\\n        prefix_bit_count[(*bit_count,)] = 1\\n        \\n        ans = 0\\n        for num in nums:\\n            bit_idx = 0\\n            while num:\\n                if num & 0x1:\\n                    bit_count[bit_idx] = (bit_count[bit_idx] + 1) % 2\\n                bit_idx += 1\\n                num = num >> 1\\n            bit_count_tuple = (*bit_count,)\\n            ans += prefix_bit_count[bit_count_tuple] \\n            prefix_bit_count[bit_count_tuple] += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        # Count the number of each bits in the subarray\\n        bit_count = [0] * 32\\n        prefix_bit_count = collections.defaultdict(int)\\n        prefix_bit_count[(*bit_count,)] = 1\\n        \\n        ans = 0\\n        for num in nums:\\n            bit_idx = 0\\n            while num:\\n                if num & 0x1:\\n                    bit_count[bit_idx] = (bit_count[bit_idx] + 1) % 2\\n                bit_idx += 1\\n                num = num >> 1\\n            bit_count_tuple = (*bit_count,)\\n            ans += prefix_bit_count[bit_count_tuple] \\n            prefix_bit_count[bit_count_tuple] += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289521,
                "title": "python-solution-xor-and-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        s = {}\\n        run = 0\\n        ans = 0\\n        s[0] = 0\\n        for num in nums:\\n            run ^= num\\n            if(run in s):\\n                s[run] += 1\\n            else:\\n                s[run] = 0\\n        for k,v in s.items():\\n            if(v > 0):\\n                ans += (v*(v+1))//2\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        s = {}\\n        run = 0\\n        ans = 0\\n        s[0] = 0\\n        for num in nums:\\n            run ^= num\\n            if(run in s):\\n                s[run] += 1\\n            else:\\n                s[run] = 0\\n        for k,v in s.items():\\n            if(v > 0):\\n                ans += (v*(v+1))//2\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288846,
                "title": "python-simple-prefix-sum-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubarrays(self, nums):\\n        n, val, count, dict1 = len(nums), 0, 0, defaultdict(int)\\n\\n        for i in range(n):\\n            val = val^nums[i]\\n\\n            if val == 0:\\n                count += 1\\n\\n            if val^0 in dict1:\\n                count += dict1[val^0]\\n\\n            dict1[val] += 1\\n\\n        return count\\n            \\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums):\\n        n, val, count, dict1 = len(nums), 0, 0, defaultdict(int)\\n\\n        for i in range(n):\\n            val = val^nums[i]\\n\\n            if val == 0:\\n                count += 1\\n\\n            if val^0 in dict1:\\n                count += dict1[val^0]\\n\\n            dict1[val] += 1\\n\\n        return count\\n            \\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288690,
                "title": "c-100-fastest-time-space-203-ms-95-6-mb",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    int cnt[1048576];\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        memset(cnt, 0, sizeof cnt);\\n        cnt[0]=1;\\n        int currXor = 0;\\n        long long ans = 0;\\n        for (int i = 0; i < nums.size(); i++){\\n            currXor ^= nums[i];\\n            ans += cnt[currXor];\\n            cnt[currXor]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int cnt[1048576];\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        memset(cnt, 0, sizeof cnt);\\n        cnt[0]=1;\\n        int currXor = 0;\\n        long long ans = 0;\\n        for (int i = 0; i < nums.size(); i++){\\n            currXor ^= nums[i];\\n            ans += cnt[currXor];\\n            cnt[currXor]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288588,
                "title": "rust-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA subarray is beautiful <=> the # of 1\\'s in a specific bit of binary represetation is an even number.\\n\\nTherefore, if we keep tracking the the # of 1\\'s in a specific bit of binary represetation, we only care if the # is even or odd. All these cases could be represented as an i32.\\n   \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn beautiful_subarrays(nums: Vec<i32>) -> i64 {\\n        let mut sum = vec![0; 31];\\n        let mut mp = HashMap::<i32, i64>::new();\\n        let mut ret = 0;\\n        \\n       *mp.entry(0).or_default() += 1;\\n        for it in nums {\\n            let mut temp = 0;\\n            for i in 0 .. 31 {\\n                if (1 << i) & it != 0 { sum[i] = (sum[i] + 1) % 2; }\\n                if sum[i] == 1 { temp |= 1 << i; }\\n            }\\n\\n            if let Some(cnt) = mp.get(&temp) { ret += *cnt; }\\n            *mp.entry(temp).or_default() += 1;\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn beautiful_subarrays(nums: Vec<i32>) -> i64 {\\n        let mut sum = vec![0; 31];\\n        let mut mp = HashMap::<i32, i64>::new();\\n        let mut ret = 0;\\n        \\n       *mp.entry(0).or_default() += 1;\\n        for it in nums {\\n            let mut temp = 0;\\n            for i in 0 .. 31 {\\n                if (1 << i) & it != 0 { sum[i] = (sum[i] + 1) % 2; }\\n                if sum[i] == 1 { temp |= 1 << i; }\\n            }\\n\\n            if let Some(cnt) = mp.get(&temp) { ret += *cnt; }\\n            *mp.entry(temp).or_default() += 1;\\n        }\\n        \\n        ret\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3288566,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\nLet `X` be the suffix xors of the input array `A`.  Return the accumulated pairs of each count `n` of xor values `x`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun beautifulSubarrays(A: IntArray): Long {\\n        var X = longArrayOf(*A.map{ it.toLong() }.toLongArray(), 0L)\\n        for (i in A.size - 1 downTo 0)\\n            X[i] = X[i] xor X[i + 1]\\n        var cnt = mutableMapOf<Long, Long>()\\n        for (x in X)\\n            cnt[x] = 1 + (cnt[x] ?: 0)\\n        return cnt.map{ (_, n) -> n * (n - 1) / 2 }.sum()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet beautifulSubarrays = (A, cnt = new Map()) => {\\n    let X = [...A, 0];\\n    for (let i = A.length - 1; 0 <= i; --i)\\n        X[i] ^= X[i + 1];\\n    for (let x of X)\\n        cnt.set(x, 1 + (cnt.get(x) || 0));\\n    return _.sum([...cnt].map(([_, n]) => Math.floor(n * (n - 1) / 2)));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def beautifulSubarrays(self, A: List[int]) -> int:\\n        X = A[:] + [0]\\n        for i in reversed(range(len(A))):\\n            X[i] ^= X[i + 1]\\n        return sum(n * (n - 1) // 2 for n in Counter(X).values())\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\ntype VL = Vec<i64>;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn beautiful_subarrays(mut A: VI) -> i64 {\\n        let mut X = A.drain(..).into_iter().map(|x| x as i64).collect::<VL>(); X.push(0i64);\\n        for i in (0..X.len() - 1).rev() {\\n            X[i] ^= X[i + 1];\\n        }\\n        let mut cnt = HashMap::new();\\n        for x in X {\\n            *cnt.entry(x).or_insert(0) += 1;\\n        }\\n        cnt.into_iter().map(|(_, n)| n * (n - 1) / 2).sum::<i64>()\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using Map = unordered_map<LL, LL>;\\n    LL beautifulSubarrays(VI& A, VL X = {}, Map cnt = {}) {\\n        copy(A.begin(), A.end(), back_inserter(X)), X.push_back(0LL);\\n        for (auto i{ int(A.size()) - 1 }; 0 <= i; --i)\\n            X[i] ^= X[i + 1];\\n        for (auto x: X)\\n            ++cnt[x];\\n        return accumulate(cnt.begin(), cnt.end(), 0LL, [](auto t, auto& pair) {\\n            auto [_, n] = pair;\\n            return t + n * (n - 1) / 2;\\n        });\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun beautifulSubarrays(A: IntArray): Long {\\n        var X = longArrayOf(*A.map{ it.toLong() }.toLongArray(), 0L)\\n        for (i in A.size - 1 downTo 0)\\n            X[i] = X[i] xor X[i + 1]\\n        var cnt = mutableMapOf<Long, Long>()\\n        for (x in X)\\n            cnt[x] = 1 + (cnt[x] ?: 0)\\n        return cnt.map{ (_, n) -> n * (n - 1) / 2 }.sum()\\n    }\\n}\\n```\n```\\nlet beautifulSubarrays = (A, cnt = new Map()) => {\\n    let X = [...A, 0];\\n    for (let i = A.length - 1; 0 <= i; --i)\\n        X[i] ^= X[i + 1];\\n    for (let x of X)\\n        cnt.set(x, 1 + (cnt.get(x) || 0));\\n    return _.sum([...cnt].map(([_, n]) => Math.floor(n * (n - 1) / 2)));\\n};\\n```\n```\\nclass Solution:\\n    def beautifulSubarrays(self, A: List[int]) -> int:\\n        X = A[:] + [0]\\n        for i in reversed(range(len(A))):\\n            X[i] ^= X[i + 1]\\n        return sum(n * (n - 1) // 2 for n in Counter(X).values())\\n```\n```\\ntype VI = Vec<i32>;\\ntype VL = Vec<i64>;\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn beautiful_subarrays(mut A: VI) -> i64 {\\n        let mut X = A.drain(..).into_iter().map(|x| x as i64).collect::<VL>(); X.push(0i64);\\n        for i in (0..X.len() - 1).rev() {\\n            X[i] ^= X[i + 1];\\n        }\\n        let mut cnt = HashMap::new();\\n        for x in X {\\n            *cnt.entry(x).or_insert(0) += 1;\\n        }\\n        cnt.into_iter().map(|(_, n)| n * (n - 1) / 2).sum::<i64>()\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using Map = unordered_map<LL, LL>;\\n    LL beautifulSubarrays(VI& A, VL X = {}, Map cnt = {}) {\\n        copy(A.begin(), A.end(), back_inserter(X)), X.push_back(0LL);\\n        for (auto i{ int(A.size()) - 1 }; 0 <= i; --i)\\n            X[i] ^= X[i + 1];\\n        for (auto x: X)\\n            ++cnt[x];\\n        return accumulate(cnt.begin(), cnt.end(), 0LL, [](auto t, auto& pair) {\\n            auto [_, n] = pair;\\n            return t + n * (n - 1) / 2;\\n        });\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288547,
                "title": "easy-best-solution-in-c-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n### PLease Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int n=nums.size(),xoR=0;\\n        long count=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            xoR^=nums[i];\\n            if(xoR==0)\\n                count++;\\n            if(mp.find(xoR)!=mp.end())\\n                count+=mp[xoR];\\n            mp[xoR]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int n=nums.size(),xoR=0;\\n        long count=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            xoR^=nums[i];\\n            if(xoR==0)\\n                count++;\\n            if(mp.find(xoR)!=mp.end())\\n                count+=mp[xoR];\\n            mp[xoR]++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288542,
                "title": "easy-c-solution-prefix-xor",
                "content": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0,x=0;\\n        map<long long,long long> mp;\\n        mp[0]++;\\n        for(int i=0;i<nums.size();i++){\\n            x=x^nums[i];\\n            if(mp[x]){\\n                ans+=mp[x];\\n            }\\n            mp[x]++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0,x=0;\\n        map<long long,long long> mp;\\n        mp[0]++;\\n        for(int i=0;i<nums.size();i++){\\n            x=x^nums[i];\\n            if(mp[x]){\\n                ans+=mp[x];\\n            }\\n            mp[x]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288523,
                "title": "count-subarrays-with-xor-equal-to-0-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n   long long beautifulSubarrays(vector<int>& nums) \\n    {\\n      \\n    long long ans = 0;                     // Initialize answer to be returned\\n    int n=nums.size();\\n        \\n    // Create a prefix xor-sum array such that\\n    // xorArr[i] has value equal to XOR\\n    // of all elements in arr[0 ..... i]\\n        \\n    int xorArr[n];\\n \\n    // Create map that stores number of prefix array\\n    // elements corresponding to a XOR value\\n        \\n    unordered_map<int, int> mp;\\n \\n    // Initialize first element of prefix array\\n    xorArr[0] = nums[0];\\n \\n    // Computing the prefix array.\\n    for (int i = 1; i < n; i++)\\n        xorArr[i] = xorArr[i - 1] ^ nums[i];\\n \\n    // Calculate the answer\\n    for (int i = 0; i < n; i++)\\n    {  \\n        int tmp =  xorArr[i];\\n \\n        // If above XOR exists in map, then there\\n        // is another previous prefix with same XOR\\n        \\n        ans = ans + ((long long)mp[tmp]);\\n \\n        // If this subarray has XOR equal to 0 \\n        if (xorArr[i] == 0)\\n            ans++;\\n \\n        // Add the XOR of this subarray to the map\\n        mp[xorArr[i]]++;\\n    }\\n \\n    // Return total count of subarrays having XOR  0\\n    return ans;\\n} \\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   long long beautifulSubarrays(vector<int>& nums) \\n    {\\n      \\n    long long ans = 0;                     // Initialize answer to be returned\\n    int n=nums.size();\\n        \\n    // Create a prefix xor-sum array such that\\n    // xorArr[i] has value equal to XOR\\n    // of all elements in arr[0 ..... i]\\n        \\n    int xorArr[n];\\n \\n    // Create map that stores number of prefix array\\n    // elements corresponding to a XOR value\\n        \\n    unordered_map<int, int> mp;\\n \\n    // Initialize first element of prefix array\\n    xorArr[0] = nums[0];\\n \\n    // Computing the prefix array.\\n    for (int i = 1; i < n; i++)\\n        xorArr[i] = xorArr[i - 1] ^ nums[i];\\n \\n    // Calculate the answer\\n    for (int i = 0; i < n; i++)\\n    {  \\n        int tmp =  xorArr[i];\\n \\n        // If above XOR exists in map, then there\\n        // is another previous prefix with same XOR\\n        \\n        ans = ans + ((long long)mp[tmp]);\\n \\n        // If this subarray has XOR equal to 0 \\n        if (xorArr[i] == 0)\\n            ans++;\\n \\n        // Add the XOR of this subarray to the map\\n        mp[xorArr[i]]++;\\n    }\\n \\n    // Return total count of subarrays having XOR  0\\n    return ans;\\n} \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288491,
                "title": "java-easy-intuitive-solution-beats-100-space-and-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLets consider i\\'th bit of all the elements in a subarray and see if we can make that bit 0 in all the elements. The condition need to be that the count of set i\\'th positioned bits need to be even then only we can chose them as pairs in the operation.\\n\\nSimilarly we can wholesumly track the sum of the set bits in each position and calculate the number of sub arrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nApproach would be similar to the problem of finding number of pairs in an array whose sum is equal to X.\\n\\n$$Key$$: In the j\\'th iteration i\\'th bit of key represents whether the sum of bits positioned at i is even or not.\\n\\nIn every iteration we calculate $$key$$ and find if there are any previous occurances and the sub-array between these two similar $$key$$ appearances will be a beautiful $$key$$. \\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$ Because we traverse each bit of every number\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        long ans = 0, key = 0;\\n        Map<Long, Long>  countMap = new HashMap<>();\\n        countMap.put(0L, 1L);\\n        for (int num: nums) {\\n            for(int i = 0;i<31;i++) {\\n                key = key ^ (num & (1<<i));\\n            }\\n            \\n            long val = countMap.getOrDefault(key, 0L);\\n            ans += val;\\n            countMap.put(key, val+1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        long ans = 0, key = 0;\\n        Map<Long, Long>  countMap = new HashMap<>();\\n        countMap.put(0L, 1L);\\n        for (int num: nums) {\\n            for(int i = 0;i<31;i++) {\\n                key = key ^ (num & (1<<i));\\n            }\\n            \\n            long val = countMap.getOrDefault(key, 0L);\\n            ans += val;\\n            countMap.put(key, val+1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288436,
                "title": "python-clean-solution-with-xor-o-n",
                "content": "\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        counter = Counter()\\n        counter[0] = 1\\n        xor = 0\\n        res = 0\\n        for num in nums:\\n            xor ^= num\\n            res += counter[xor]\\n            counter[xor] += 1\\n        return res\\n    \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        counter = Counter()\\n        counter[0] = 1\\n        xor = 0\\n        res = 0\\n        for num in nums:\\n            xor ^= num\\n            res += counter[xor]\\n            counter[xor] += 1\\n        return res\\n    \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288369,
                "title": "swift-solution",
                "content": "# Approach\\n1. Set n to the length of the array, m to 0, ans to 0, and xorArr to an array of length n filled with 0s.\\n2. Set mp to an empty dictionary.\\n3. Set xorArr[0] to arr[0].\\n4. Starting from i = 1, repeat the following until i = n - 1:\\n    1. Set xorArr[i] to xorArr[i - 1] xor arr[i].\\n5. Starting from i = 0, repeat the following until i = n - 1:\\n    1. Set tmp to m xor xorArr[i].\\n    2. Set ans to ans plus mp[tmp] if mp[tmp] is not nil, 0 otherwise.\\n    3. If xorArr[i] is equal to m, set ans to ans plus 1.\\n    4. If mp[xorArr[i]] is not nil, set mp[xorArr[i]] to mp[xorArr[i]] plus 1, otherwise set mp[xorArr[i]] to 1.\\n6. Return ans.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution\\n{\\n    func beautifulSubarrays(_ arr: [Int]) -> Int\\n    {\\n        var n = arr.count\\n        var m = 0\\n        var ans = 0\\n        var xorArr = [Int](repeating: 0, count: n)\\n        var mp = [Int: Int]()\\n        xorArr[0] = arr[0]\\n        for i in 1..<n\\n        {\\n            xorArr[i] = xorArr[i - 1] ^ arr[i]\\n        }\\n        for i in 0..<n\\n        {\\n            var tmp = m ^ xorArr[i]\\n            ans = ans + (mp[tmp] ?? 0)\\n            if xorArr[i] == m\\n            {\\n                ans += 1\\n            }\\n            if mp[xorArr[i]] != nil\\n            {\\n                mp[xorArr[i]]! += 1\\n            }\\n            else\\n            {\\n                mp[xorArr[i]] = 1\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution\\n{\\n    func beautifulSubarrays(_ arr: [Int]) -> Int\\n    {\\n        var n = arr.count\\n        var m = 0\\n        var ans = 0\\n        var xorArr = [Int](repeating: 0, count: n)\\n        var mp = [Int: Int]()\\n        xorArr[0] = arr[0]\\n        for i in 1..<n\\n        {\\n            xorArr[i] = xorArr[i - 1] ^ arr[i]\\n        }\\n        for i in 0..<n\\n        {\\n            var tmp = m ^ xorArr[i]\\n            ans = ans + (mp[tmp] ?? 0)\\n            if xorArr[i] == m\\n            {\\n                ans += 1\\n            }\\n            if mp[xorArr[i]] != nil\\n            {\\n                mp[xorArr[i]]! += 1\\n            }\\n            else\\n            {\\n                mp[xorArr[i]] = 1\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288326,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string hash(vector<int>num)\\n    {\\n        string ans=\"\";\\n        for(int i=0;i<num.size();i++){\\n            ans += num[i]%2;\\n        }\\n        return ans;\\n    }\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int LIMIT = 20;\\n        \\n        map<string, int>h;\\n        vector<vector<int>>a;\\n        long long ans=0;\\n        \\n        vector<int>temp(LIMIT);\\n        h[hash(temp)]=1;\\n        \\n        for(int num:nums){\\n            for(int i=0;i<LIMIT;i++){\\n                if(num & 1<<i) {\\n                    temp[i]+=1;\\n                }\\n            }\\n            string hash_now = hash(temp);\\n            ans += h[hash_now];\\n            h[hash_now] += 1;\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string hash(vector<int>num)\\n    {\\n        string ans=\"\";\\n        for(int i=0;i<num.size();i++){\\n            ans += num[i]%2;\\n        }\\n        return ans;\\n    }\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int LIMIT = 20;\\n        \\n        map<string, int>h;\\n        vector<vector<int>>a;\\n        long long ans=0;\\n        \\n        vector<int>temp(LIMIT);\\n        h[hash(temp)]=1;\\n        \\n        for(int num:nums){\\n            for(int i=0;i<LIMIT;i++){\\n                if(num & 1<<i) {\\n                    temp[i]+=1;\\n                }\\n            }\\n            string hash_now = hash(temp);\\n            ans += h[hash_now];\\n            h[hash_now] += 1;\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288285,
                "title": "map-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long c=0,res=0;\\n        unordered_map<int,int> m;\\n        m[0]++;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            c=c^nums[i];\\n            if(m.count(c)>0)\\n            {\\n                res+=m[c];\\n            }\\n            m[c]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long c=0,res=0;\\n        unordered_map<int,int> m;\\n        m[0]++;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            c=c^nums[i];\\n            if(m.count(c)>0)\\n            {\\n                res+=m[c];\\n            }\\n            m[c]++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288270,
                "title": "c-prefix-xor-and-grouping",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all, a subarray is beautiful if and only if `xor` of all its items is `0`.\\n\\nNow let\\'s compute the xor prefix for all items within `num`, e.g. for `[4, 3, 1, 2, 4]` we\\'ll get\\n\\n```\\n    4, 3, 1, 2, 4 => compute XOR prefixes => \\n[0, 4, 7, 6, 4, 0]\\n    |        |\\n     <--  -->\\n     beautiful, corresponds to [3, 2, 1]\\n```\\n\\nNow, all we have to note, that any subarray between two equal prefixes (in the example above between `4`th) is beautiful: the xor of its items is `left ^ right == 4 ^ 4 == 0`.  \\n\\nTo compute all beautiful subarrays, we should count all unique items in the `prefix`; each `count` adds `count * (count - 1) / 2` to the total result. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Compute `prefix` array based on xor\\n2. Query the array with a help of Linq\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public long BeautifulSubarrays(int[] nums) {\\n        int[] prefix = new int[nums.Length + 1];\\n\\n        for (int i = 0; i < nums.Length; ++i)\\n            prefix[i + 1] = prefix[i] ^ nums[i];\\n\\n        return prefix\\n           .GroupBy(item => item)\\n           .Select(group => (long)group.Count())\\n           .Sum(count => count * (count - 1) / 2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n    4, 3, 1, 2, 4 => compute XOR prefixes => \\n[0, 4, 7, 6, 4, 0]\\n    |        |\\n     <--  -->\\n     beautiful, corresponds to [3, 2, 1]\\n```\n```\\npublic class Solution {\\n    public long BeautifulSubarrays(int[] nums) {\\n        int[] prefix = new int[nums.Length + 1];\\n\\n        for (int i = 0; i < nums.Length; ++i)\\n            prefix[i + 1] = prefix[i] ^ nums[i];\\n\\n        return prefix\\n           .GroupBy(item => item)\\n           .Select(group => (long)group.Count())\\n           .Sum(count => count * (count - 1) / 2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288158,
                "title": "xor-manipulation",
                "content": "The idea is based on the fact that 0 xor 0 is 0 and 1 xor 1 is 0\\nthis means that for a particular subarray for each index bit k, the number of 1 bits must be even hence having a xor of 0. \\n1100\\n0011\\n1111\\nobserve that for each column the number of 1 bits is even\\nhence the xor of the numbers is 0.\\nNow find the cummulative xor of all numbers in the array then use the property of prefix sum to verify if a particular subarray\\'s cummulative xor was 0.\\n\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        map<int,int>store;\\n        vector<int>pref(nums.size());\\n        pref[0] = nums[0];\\n    \\n        for(int i = 1; i < nums.size(); i++){\\n             pref[i] = pref[i-1]^nums[i];\\n        }\\n        \\n        long long answer = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n     \\n            if(store[pref[i]]>=1){\\n                 answer+=store[pref[i]];\\n            }\\n            if(pref[i]==0)++answer;\\n            \\n            store[pref[i]]++;\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        map<int,int>store;\\n        vector<int>pref(nums.size());\\n        pref[0] = nums[0];\\n    \\n        for(int i = 1; i < nums.size(); i++){\\n             pref[i] = pref[i-1]^nums[i];\\n        }\\n        \\n        long long answer = 0;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n     \\n            if(store[pref[i]]>=1){\\n                 answer+=store[pref[i]];\\n            }\\n            if(pref[i]==0)++answer;\\n            \\n            store[pref[i]]++;\\n        }\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288055,
                "title": "c-hashmap-and-prefix-array-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        \\n        // Create a map to store the frequency of each XOR value\\n        map<int, long long>mp;\\n        \\n        // Initialize the frequency of XOR value 0 to 1\\n        mp[0]++;\\n        long long calXOR = 0, ans = 0;\\n        \\n        // Traverse through the array\\n        for(int i = 0; i < nums.size(); i++) {\\n            \\n            // Calculate XOR of all the elements so far\\n            calXOR = calXOR ^ nums[i];\\n            \\n            // If the XOR value is already present in the map, add the frequency of the value to the answer\\n            if(mp.find(calXOR) != mp.end()) {\\n                ans += mp[calXOR];\\n            }\\n            \\n            // Increment the frequency of the XOR value in the map\\n            mp[calXOR]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        \\n        // Create a map to store the frequency of each XOR value\\n        map<int, long long>mp;\\n        \\n        // Initialize the frequency of XOR value 0 to 1\\n        mp[0]++;\\n        long long calXOR = 0, ans = 0;\\n        \\n        // Traverse through the array\\n        for(int i = 0; i < nums.size(); i++) {\\n            \\n            // Calculate XOR of all the elements so far\\n            calXOR = calXOR ^ nums[i];\\n            \\n            // If the XOR value is already present in the map, add the frequency of the value to the answer\\n            if(mp.find(calXOR) != mp.end()) {\\n                ans += mp[calXOR];\\n            }\\n            \\n            // Increment the frequency of the XOR value in the map\\n            mp[calXOR]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288009,
                "title": "easy-to-understand-prefix-xor",
                "content": "# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n````\\nclass Solution:\\n    def beautifulSubarrays(self, A):\\n        n = len(A)\\n        pf = [0]*n\\n        hm = {}\\n        ans = 0\\n        for i in range(n):\\n            if(i == 0):\\n                pf[i] = pf[i]^A[i]\\n            else:\\n                pf[i] = pf[i-1]^A[i]\\n            if(pf[i] in hm and hm[pf[i]] >= 1):\\n                ans+=hm[pf[i]]\\n                hm[pf[i]]+=1\\n            else:\\n                hm[pf[i]] = 1\\n            if(pf[i] == 0):\\n                ans+=1\\n        return ans\\n````\\n```\\nclass Solution:\\n    def beautifulSubarrays(self, A):\\n        pf = Counter({0:1})\\n        ans,xor = 0,0\\n        for i in A:\\n            xor ^= i\\n            ans+=pf[xor]\\n            pf[xor] += 1\\n        return ans             \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "````\\nclass Solution:\\n    def beautifulSubarrays(self, A):\\n        n = len(A)\\n        pf = [0]*n\\n        hm = {}\\n        ans = 0\\n        for i in range(n):\\n            if(i == 0):\\n                pf[i] = pf[i]^A[i]\\n            else:\\n                pf[i] = pf[i-1]^A[i]\\n            if(pf[i] in hm and hm[pf[i]] >= 1):\\n                ans+=hm[pf[i]]\\n                hm[pf[i]]+=1\\n            else:\\n                hm[pf[i]] = 1\\n            if(pf[i] == 0):\\n                ans+=1\\n        return ans\\n```\n```\\nclass Solution:\\n    def beautifulSubarrays(self, A):\\n        pf = Counter({0:1})\\n        ans,xor = 0,0\\n        for i in A:\\n            xor ^= i\\n            ans+=pf[xor]\\n            pf[xor] += 1\\n        return ans             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287925,
                "title": "memory-55-7-mb-beats-100-runtime-63-ms-beats-100",
                "content": "# Intuition\\nnumber of subarrays with xor zero\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        //if the same number appears after some xor operation that means thats somwhere in the middle subarray  exist that will be having a xor =0;\\n        int xor=0;\\n        hm.put(0,1); //initially the xor is zero \\n        for(int i=0;i<nums.length;i++){\\n            xor^=nums[i]; //finding xor\\n            hm.put(xor,hm.getOrDefault(xor,0)+1);\\n\\n        }\\n        long ans=0;\\n        for(long beautiful:hm.values()){\\n            ans+=(beautiful*(beautiful-1))/2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        //if the same number appears after some xor operation that means thats somwhere in the middle subarray  exist that will be having a xor =0;\\n        int xor=0;\\n        hm.put(0,1); //initially the xor is zero \\n        for(int i=0;i<nums.length;i++){\\n            xor^=nums[i]; //finding xor\\n            hm.put(xor,hm.getOrDefault(xor,0)+1);\\n\\n        }\\n        long ans=0;\\n        for(long beautiful:hm.values()){\\n            ans+=(beautiful*(beautiful-1))/2;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287807,
                "title": "c-4-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long res = 0, sum = 0;\\n        unordered_map<int, int> counter = {{0, 1}};\\n        for(auto x:nums) res += counter[sum ^= x]++;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long res = 0, sum = 0;\\n        unordered_map<int, int> counter = {{0, 1}};\\n        for(auto x:nums) res += counter[sum ^= x]++;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287800,
                "title": "python3-prefix-xor",
                "content": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        count = collections.defaultdict(int)\\n        count[0] = 1\\n        mask = ans = 0\\n\\n        for i, num in enumerate(nums):\\n            mask ^= num\\n            ans += count[mask]\\n            count[mask] += 1\\n\\t\\t\\t\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        count = collections.defaultdict(int)\\n        count[0] = 1\\n        mask = ans = 0\\n\\n        for i, num in enumerate(nums):\\n            mask ^= num\\n            ans += count[mask]\\n            count[mask] += 1\\n\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287742,
                "title": "count-no-of-pairs-in-prefix-sum",
                "content": "# Intuition\\nWe can see that the beautiful subarray would be the subarray with xor 0.\\n\\n# Approach\\nwe start with calculating the prefix sum by doing XOR of the given array. we will notice that :\\n\\n2,7,5,0,2,7.\\n\\nconsider this prefix xor for example , we can notice that the element 7 is repeating again..\\n\\nwhat does it says ??\\n\\nit says that the subarray 5,0,2 has XOR equals to **zero** \\nalso if there is a zero in this prefix array then count it also because it means that the subarray from starting till here has XOR as zero.\\n\\nso I am counting no of pairs (of 2) of same elements in the prefix array and also counting extra 1 for a element zero(0).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long nCr(int n, int r) {\\n    long long result = 1;\\n    for (int i = 1; i <= r; i++) {\\n        result *= n - r + i;\\n        result /= i;\\n    }\\n    return result;\\n}\\n\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long n = nums.size(),cnt=0;\\n        long long pre[n];\\n        pre[0] = nums[0];\\n        map<int,int> m;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            pre[i] = pre[i-1]^nums[i];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            //cout<<pre[i]<<\" \";\\n            if(pre[i] == 0)\\n            cnt++;\\n            \\n                m[pre[i]]++;\\n            \\n        }\\n\\n        for(auto x : m)\\n        {\\n            cnt += nCr(x.second,2);\\n        }\\n\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long nCr(int n, int r) {\\n    long long result = 1;\\n    for (int i = 1; i <= r; i++) {\\n        result *= n - r + i;\\n        result /= i;\\n    }\\n    return result;\\n}\\n\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long n = nums.size(),cnt=0;\\n        long long pre[n];\\n        pre[0] = nums[0];\\n        map<int,int> m;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            pre[i] = pre[i-1]^nums[i];\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            //cout<<pre[i]<<\" \";\\n            if(pre[i] == 0)\\n            cnt++;\\n            \\n                m[pre[i]]++;\\n            \\n        }\\n\\n        for(auto x : m)\\n        {\\n            cnt += nCr(x.second,2);\\n        }\\n\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3287716,
                "title": "count-of-number-of-beautiful-subarrays-c-explained-solution",
                "content": "**Do Upvote If Found Helpful !**\\n\\n# Approach\\nThe problem here is quite nice and needs a simple but good observation. One thing that can be construed from problem statement is that the number of set bits should be even in order to form beautiful arrays. Now what can we do to check so. One thing is keeping count of every bit but this idea is no better than checking naively each subarray. The next idea is to use property of **XOR** as whenever the count of bits becomes even, that bit becomes off in result. Thus we maintain a variable that stores contiguous xor with each number. Now this question turns into a very similar problem of finding number of subarrays with given sum. In our case, this problem has turned into number of subarrays with given xor. For this problem, that specific XOR value is **0**. We can also generalise to find subarrays with XOR value **K**, where K is some random whole number. The next is just the implementation of the approach of sum problem but with modification of xor. It goes below :\\n\\n# Complexity\\n- Time complexity: **O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        ios_base::sync_with_stdio(0);\\n        map<ll,ll>mp; ll ans = 0,k = 0; mp[0]++;\\n        for(auto it : nums){\\n            k ^= it;\\n            ans += mp[k];\\n            mp[k]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        ios_base::sync_with_stdio(0);\\n        map<ll,ll>mp; ll ans = 0,k = 0; mp[0]++;\\n        for(auto it : nums){\\n            k ^= it;\\n            ans += mp[k];\\n            mp[k]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287621,
                "title": "prefix-zor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int n = nums.size() ;\\n        int sum = 0 ;\\n        long long ans = 0 ;\\n        unordered_map<long long , long long> mp ;\\n        mp[0] = 1 ;\\n        for(int i = 0 ; i < n ; i++){\\n            sum = sum ^ nums[i];\\n            if(mp.find(sum) != mp.end()){\\n                ans += mp[sum];\\n            }\\n            mp[sum]++;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int n = nums.size() ;\\n        int sum = 0 ;\\n        long long ans = 0 ;\\n        unordered_map<long long , long long> mp ;\\n        mp[0] = 1 ;\\n        for(int i = 0 ; i < n ; i++){\\n            sum = sum ^ nums[i];\\n            if(mp.find(sum) != mp.end()){\\n                ans += mp[sum];\\n            }\\n            mp[sum]++;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287548,
                "title": "easy-and-understandable-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        unordered_map<int, int> dic = {{0, 1}};\\n        long long x = 0;\\n        long long sol = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (int i : nums) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 x = x^i;\\n            \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (dic.count(x)) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 sol = sol + dic[x];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 dic[x]++;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 } \\n            else {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 dic[x] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return sol;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        unordered_map<int, int> dic = {{0, 1}};\\n        long long x = 0;\\n        long long sol = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (int i : nums) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 x = x^i;\\n            \\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (dic.count(x)) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 sol = sol + dic[x];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 dic[x]++;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 } \\n            else {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 dic[x] = 1;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return sol;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287504,
                "title": "short-and-concise-code-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nso the first thing is when a subarray would be beautiful , the answer to this is when all the bits appearing at any position from 0 to 31 appears even number of times, because it would help you in cancelling out the bits, now if you think of something which could take care of these bits wether they are even or odd, you can think of xor , what xor does is that it tells wether the bits at pos i has appeared even or odd times......... \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nnow to know whether a subarray is beautiful or not there are two ways-:\\na) the xor becomes zero.\\nb) the xor calculated till now has already been seen in the past means the array between the curr and past appearnce of xor would be the one that is beautiful.\\nso to know the past appearances you can just use a map, and you are done..\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nlinear\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nlinear\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        map<int,int> mp;\\n        int val=0;\\n        for(int i=0;i<nums.size();i++){\\n            val=val^nums[i];\\n            ans+=mp[val];\\n            if(val==0){\\n                ans++;\\n            }\\n            mp[val]+=1;\\n            //cout<<val<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        map<int,int> mp;\\n        int val=0;\\n        for(int i=0;i<nums.size();i++){\\n            val=val^nums[i];\\n            ans+=mp[val];\\n            if(val==0){\\n                ans++;\\n            }\\n            mp[val]+=1;\\n            //cout<<val<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3287472,
                "title": "simple-prefix-xor-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        long long  n=nums.size();\\n        vector<long long>preXor(n);\\n        preXor[0]=nums[0];\\n        for(long long i=1;i<n;i++){\\n            preXor[i]=preXor[i-1]^nums[i];\\n        }\\n        unordered_map<long long,long long>m;\\n        m[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(m.find(preXor[i])!=m.end())ans+=m[preXor[i]];\\n            m[preXor[i]]++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long ans=0;\\n        long long  n=nums.size();\\n        vector<long long>preXor(n);\\n        preXor[0]=nums[0];\\n        for(long long i=1;i<n;i++){\\n            preXor[i]=preXor[i-1]^nums[i];\\n        }\\n        unordered_map<long long,long long>m;\\n        m[0]=1;\\n        for(int i=0;i<n;i++){\\n            if(m.find(preXor[i])!=m.end())ans+=m[preXor[i]];\\n            m[preXor[i]]++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287415,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n    long long n=nums.size();\\n    long long prefix[n];\\n    prefix[0] = nums[0];\\n\\n    // create prefix array\\n    for(long long i=1; i<n; i++) {\\n        prefix[i] = prefix[i-1] ^ nums[i];\\n    }\\n\\n    // count subarrays with XOR 0\\n    long long count = 0;\\n    unordered_map<long long, long long> mp;\\n    for(long long i=0; i<n; i++) {\\n        if(prefix[i] == 0) {\\n            count++;\\n        }\\n        if(mp.find(prefix[i]) != mp.end()) {\\n            count += mp[prefix[i]];\\n        }\\n        mp[prefix[i]]++;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n    long long n=nums.size();\\n    long long prefix[n];\\n    prefix[0] = nums[0];\\n\\n    // create prefix array\\n    for(long long i=1; i<n; i++) {\\n        prefix[i] = prefix[i-1] ^ nums[i];\\n    }\\n\\n    // count subarrays with XOR 0\\n    long long count = 0;\\n    unordered_map<long long, long long> mp;\\n    for(long long i=0; i<n; i++) {\\n        if(prefix[i] == 0) {\\n            count++;\\n        }\\n        if(mp.find(prefix[i]) != mp.end()) {\\n            count += mp[prefix[i]];\\n        }\\n        mp[prefix[i]]++;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287205,
                "title": "prefix-xorsum-very-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) \\n    {\\n        long long ans=0;\\n        map<long long,long long> m;\\n        m[0]=1;\\n        int n=nums.size();\\n        int xo=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            xo^=(long long)nums[x];\\n            if(m[xo]>0) ans+=m[xo];\\n            m[xo]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) \\n    {\\n        long long ans=0;\\n        map<long long,long long> m;\\n        m[0]=1;\\n        int n=nums.size();\\n        int xo=0;\\n        for(int x=0; x<n; x++)\\n        {\\n            xo^=(long long)nums[x];\\n            if(m[xo]>0) ans+=m[xo];\\n            m[xo]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287203,
                "title": "python-2-line-solution-counter",
                "content": "```\\ndef beautifulSubarrays(self, nums: List[int]) -> int:\\n\\tpxor = Counter([0]+list(accumulate(nums, ixor)))\\n\\treturn sum(x*(x-1)//2 for x in pxor.values())\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautifulSubarrays(self, nums: List[int]) -> int:\\n\\tpxor = Counter([0]+list(accumulate(nums, ixor)))\\n\\treturn sum(x*(x-1)//2 for x in pxor.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3287101,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn beautiful_subarrays(nums: Vec<i32>) -> i64 {\\n        let mut res = 0;\\n        let mut cnt = std::collections::HashMap::new();\\n        cnt.insert(0, 1);\\n        let mut val = 0;\\n        for i in 0..nums.len() {\\n            val ^= nums[i];\\n            res += *cnt.entry(val).or_insert(0);\\n            *cnt.entry(val).or_insert(0) += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn beautiful_subarrays(nums: Vec<i32>) -> i64 {\\n        let mut res = 0;\\n        let mut cnt = std::collections::HashMap::new();\\n        cnt.insert(0, 1);\\n        let mut val = 0;\\n        for i in 0..nums.len() {\\n            val ^= nums[i];\\n            res += *cnt.entry(val).or_insert(0);\\n            *cnt.entry(val).or_insert(0) += 1;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3287100,
                "title": "simple-solution-using-xor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1^1=0\\n1^0=1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nxor of beautiful subarray is equal to 0.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        long long ans=0;\\n\\n        int xorr=0;\\n        m[xorr]++;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            xorr = (xorr ^ nums[i]);\\n            ans+= m[xorr];\\n            m[xorr]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        long long ans=0;\\n\\n        int xorr=0;\\n        m[xorr]++;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            xorr = (xorr ^ nums[i]);\\n            ans+= m[xorr];\\n            m[xorr]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287098,
                "title": "o-n-time-simple-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe basic intution behind solving this problem is that the XOR of all the elements in beautiful subarray will come out to be 0 everytime.\\n\\nNow we have to count the number subarrays in which XOR of all elements of that subarray is ZERO.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nTo solve this problem in $$o(n)$$ time, we can build our approach similar to the problem of counting subarrays with target sum.\\n\\n\\nSo we will iterate over the array and at each index-i\\n1. we will find number of subarray which ends at i-th index and has xor = 0. \\n2. For this, we will count the subarrays which have xor equal to xor of subarray(0 to i). Use `map<int, long long>` to store prefix xor.\\n3. And finally, the number of beautiful subarray will be added to final answer.\\n\\nBelow is the simple cpp implementation.\\n\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n\\n        map<int, long long> map;\\n        map[0]++;\\n        long long ans=0;\\n        int xor =0;\\n        for(auto ele: nums){\\n            xor = xor ^ ele;\\n            ans+=  map[xor];\\n            map[xor]++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n\\n        map<int, long long> map;\\n        map[0]++;\\n        long long ans=0;\\n        int xor =0;\\n        for(auto ele: nums){\\n            xor = xor ^ ele;\\n            ans+=  map[xor];\\n            map[xor]++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287031,
                "title": "specially-designed-for-beginner-s-with-complete-explanation-count-the-subarray-having-xor-0",
                "content": "For any two number\\'s X and Y, We need to make all of their values as Zero. It means in the whole subarray we need even count of bitset present at each bit. So that we subtract 2^k from both X and Y, So in other words, It means we have to count the number of subarray in which their XOR=0 , Because XOR =0 means that the elements are present in pair\\'s.\\n\\nNow their\\'s is a very popular problem of count subarray having sum K.\\n[560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)\\n\\nWe can use the same approach to count the XOR having value=0;\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        ll ans=0;\\n        unordered_map<ll,ll>mp;\\n        mp[0]=1;\\n        ll currPrefix = 0;\\n        for(int i=0;i<nums.size();i++){\\n            currPrefix = currPrefix ^ nums[i];\\n            ans+=mp[currPrefix];\\n            mp[currPrefix]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nTime Complexity -> O(n) and\\nSpace Complexity -> O(1)\\n\\nIn case you liked my explanation, Please do a UPVOTE. It helps me to write more discussions and solutions...\\n\\nHAVE A GOOD DAY, LEETCODER\\'S",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        ll ans=0;\\n        unordered_map<ll,ll>mp;\\n        mp[0]=1;\\n        ll currPrefix = 0;\\n        for(int i=0;i<nums.size();i++){\\n            currPrefix = currPrefix ^ nums[i];\\n            ans+=mp[currPrefix];\\n            mp[currPrefix]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286971,
                "title": "prefix-xor-and-hashmap",
                "content": "# Intuition\\nIf a subarray is beautiful - the bitwise XOR of all elements in it is 0.\\n\\nThis is as each number that\\'s being turned into 0 in a beautiful array, must have its 1\\'s removed(in binary form). That can only happen if there\\'s another number to pair with it,so that it can be operated upon (subtracting 2^k from both numbers in the pair)\\n\\n# Approach\\nWe can use a prefix XOR array and store results in a map\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        Map<Integer, Integer> xorPrefixCount = new HashMap<Integer, Integer>();\\n        xorPrefixCount.put(0, 1);\\n        int xor = 0;\\n        long result = 0;\\n        for(int num : nums) {\\n            xor = xor ^ num;\\n            if(xorPrefixCount.get(xor) != null) {\\n                result += xorPrefixCount.get(xor);\\n            }\\n            \\n            xorPrefixCount.putIfAbsent(xor, 0);\\n            xorPrefixCount.put(xor, xorPrefixCount.get(xor) + 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long beautifulSubarrays(int[] nums) {\\n        Map<Integer, Integer> xorPrefixCount = new HashMap<Integer, Integer>();\\n        xorPrefixCount.put(0, 1);\\n        int xor = 0;\\n        long result = 0;\\n        for(int num : nums) {\\n            xor = xor ^ num;\\n            if(xorPrefixCount.get(xor) != null) {\\n                result += xorPrefixCount.get(xor);\\n            }\\n            \\n            xorPrefixCount.putIfAbsent(xor, 0);\\n            xorPrefixCount.put(xor, xorPrefixCount.get(xor) + 1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286903,
                "title": "c-bit-manipulation-and-prefix-sum-fully-explained",
                "content": "# Intuition\\nActually the idea is to store the prefix sum of number of 1 at each index bit. Now we can check if any two pair have a difference in number of 1 at every bit as a multiple of two then it should be our subarray(i,j).\\nTo do that we can store the prefix sum of number of 1 at each bit as modulo of 2. Now we can use a map and can calculate the answer.\\n\\n# Approach\\nBit Manipulation and Prefix sum.\\n\\n# Complexity\\n- Time complexity: Nx32\\n\\n- Space complexity: Nx32\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n         long long ans=0;\\n        int n = nums.size();\\n        vector<int> vec(32,0);\\n        vector<vector<int>> v;\\n        v.push_back(vec);\\n        for(int i=0;i<n;i++){\\n            int x = nums[i];\\n            for(int j=0;j<32;j++){\\n                if(x&(1<<j)){\\n                    vec[j]++;\\n                }\\n                vec[j]%=2;\\n            }\\n            v.push_back(vec);\\n        }\\n        map<vector<int>,int> mp;\\n        for(int i=0;i<n+1;i++){\\n            ans+=(long long)mp[v[i]];\\n            mp[v[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n         long long ans=0;\\n        int n = nums.size();\\n        vector<int> vec(32,0);\\n        vector<vector<int>> v;\\n        v.push_back(vec);\\n        for(int i=0;i<n;i++){\\n            int x = nums[i];\\n            for(int j=0;j<32;j++){\\n                if(x&(1<<j)){\\n                    vec[j]++;\\n                }\\n                vec[j]%=2;\\n            }\\n            v.push_back(vec);\\n        }\\n        map<vector<int>,int> mp;\\n        for(int i=0;i<n+1;i++){\\n            ans+=(long long)mp[v[i]];\\n            mp[v[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286902,
                "title": "c-code-using-xor-easy-yo-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n       \\n        unordered_map<long long ,long long> count;\\n        count[0] = 1;\\n        long long xo= 0, b = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            xo ^= nums[i];\\n            b += count[xo];\\n            count[xo]++;\\n        }\\n        return b;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n       \\n        unordered_map<long long ,long long> count;\\n        count[0] = 1;\\n        long long xo= 0, b = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            xo ^= nums[i];\\n            b += count[xo];\\n            count[xo]++;\\n        }\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286870,
                "title": "c-prefix-bit-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    // if bit of curr is 1, then cancel (set 0) that bit of prev (i.e. canceling corresponding k value)\\n    int util(int prev, int curr){\\n        \\n        for(int i=0; i < 20; i++){\\n            if( (curr & (1 << i))){\\n                if((prev & (1 << i))) prev = prev  & ~(1 << i);\\n                else prev = ((1 << i) | prev);\\n            }\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // store pre-processed k-values (using bits) \\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        \\n        long long int res = 0;\\n        int prev = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            int curr = util(prev, nums[i]);\\n            prev = curr;\\n            \\n            // if already exits such combination of k values (i.e bits) then we can cancel, hence we get a beautiful subarray\\n            if(mp.count(curr) > 0) res += mp[curr];\\n            mp[curr] += 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    // if bit of curr is 1, then cancel (set 0) that bit of prev (i.e. canceling corresponding k value)\\n    int util(int prev, int curr){\\n        \\n        for(int i=0; i < 20; i++){\\n            if( (curr & (1 << i))){\\n                if((prev & (1 << i))) prev = prev  & ~(1 << i);\\n                else prev = ((1 << i) | prev);\\n            }\\n        }\\n        \\n        return prev;\\n    }\\n    \\n    long long beautifulSubarrays(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // store pre-processed k-values (using bits) \\n        unordered_map<int,int> mp;\\n        mp[0] = 1;\\n        \\n        long long int res = 0;\\n        int prev = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            int curr = util(prev, nums[i]);\\n            prev = curr;\\n            \\n            // if already exits such combination of k values (i.e bits) then we can cancel, hence we get a beautiful subarray\\n            if(mp.count(curr) > 0) res += mp[curr];\\n            mp[curr] += 1;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286863,
                "title": "c-easy-solution-dp-memoization-optimal-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long c=0;\\n        unordered_map<int,int> mp;\\n        int n=nums.size();\\n        vector<int> prefix(n,0);\\n        prefix[0]=nums[0];\\n        mp[nums[0]]++;\\n        if(prefix[0]==0){\\n            c++;\\n        }\\n        for(int i=1;i<nums.size();i++){\\n            prefix[i]=nums[i]^prefix[i-1];\\n            if(mp.find(prefix[i])!=mp.end()){\\n                c+=(mp[prefix[i]]);\\n            }\\n            if(prefix[i]==0){\\n                c++;\\n            }\\n            mp[prefix[i]]++;\\n        }\\n        return c;\\n    }\\n};\\n```\\n# AUTHOR: JAYESH BADGUJAR\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long c=0;\\n        unordered_map<int,int> mp;\\n        int n=nums.size();\\n        vector<int> prefix(n,0);\\n        prefix[0]=nums[0];\\n        mp[nums[0]]++;\\n        if(prefix[0]==0){\\n            c++;\\n        }\\n        for(int i=1;i<nums.size();i++){\\n            prefix[i]=nums[i]^prefix[i-1];\\n            if(mp.find(prefix[i])!=mp.end()){\\n                c+=(mp[prefix[i]]);\\n            }\\n            if(prefix[i]==0){\\n                c++;\\n            }\\n            mp[prefix[i]]++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286833,
                "title": "count-subarrays-with-xor-zero",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        long long ans=0;\\n        long long x = 0;\\n        int i =0;\\n        mp[0] = 1;\\n        while(i < nums.size()){\\n            x = x^nums[i];\\n            \\n            ans += mp[x];\\n            mp[x]++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n        long long ans=0;\\n        long long x = 0;\\n        int i =0;\\n        mp[0] = 1;\\n        while(i < nums.size()){\\n            x = x^nums[i];\\n            \\n            ans += mp[x];\\n            mp[x]++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286771,
                "title": "python-3-o-n-tc-2588-count-the-number-of-beautiful-subarrays",
                "content": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        xor_count = defaultdict(int)\\n        xor_count[0] += 1 \\n        xor = count = 0 \\n        for item in nums :\\n            xor ^= item \\n            if xor in xor_count :\\n                count += xor_count[xor]\\n            \\n            xor_count[xor] += 1 \\n            \\n        return count \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubarrays(self, nums: List[int]) -> int:\\n        xor_count = defaultdict(int)\\n        xor_count[0] += 1 \\n        xor = count = 0 \\n        for item in nums :\\n            xor ^= item \\n            if xor in xor_count :\\n                count += xor_count[xor]\\n            \\n            xor_count[xor] += 1 \\n            \\n        return count \\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1829828,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1829882,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1831007,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1840938,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1831584,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1831446,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1829871,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1831118,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1831082,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1830936,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1829828,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1829882,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1831007,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1840938,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1831584,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1831446,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1829871,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1831118,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1831082,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            },
            {
                "id": 1830936,
                "content": [
                    {
                        "username": "anurag-k",
                        "content": "I knew it was XOR but wasn\\'t able to derive a 0(n) to count all 0 XOR subarrays."
                    },
                    {
                        "username": "wenwendududu",
                        "content": "Not sure how you guys check the test case `[0]` and returns 1.\\n\\nIn the question it said : `Choose two different indices i and j such that 0 <= i, j < nums.length.`, if the input length  is less than 1, how did you apply the operation? "
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "The question says you can use the operation any number of times ( >= 0) to a subarray containing only 0s. So in this case, you need not apply the operation at all."
                    },
                    {
                        "username": "seungjun_dev",
                        "content": "wondering same thing"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here\\'s one way to solve the problem:\\n\\n1. Use a prefix array to keep track of the prefix XORs up to each index of the input array.\\n2. Iterate over all subarrays of the input array.\\n3. For each subarray, compute the XOR of all the elements in the subarray.\\n4. If the XOR is non-zero, there is no way to make all elements in the subarray equal to zero using the allowed operation. Move on to the next subarray.\\n5. If the XOR is zero, we can make all elements in the subarray equal to zero using the allowed operation. Compute the number of beautiful subarrays that end at the current index by counting the number of previous prefix XORs that are equal to the current prefix XOR. Add this count to the total number of beautiful subarrays.\\n\\n\\n# Let\\'s understand the approach with an example:\\n\\nConsider the input array nums = [4, 3, 1, 2, 4].\\n\\nWe will maintain a prefix XOR array prefix of the input array. At any index i, prefix[i] stores the XOR of elements from index 0 to index i of the input array.\\n\\nprefix = [4, 7, 6, 4, 0]\\nFor every index i of the prefix array, we need to count the number of beautiful subarrays that end at i. To do this, we will maintain a hashmap prefixCount, where the key is the prefix XOR value and the value is the count of subarrays that have that prefix XOR value.\\n\\nWe will initialize prefixCount with (0, 1). This is because the prefix XOR value of an empty subarray is 0, and we have one such subarray (which is the empty subarray itself).\\n\\nWe will traverse the prefix array from left to right and at each index i, we will calculate the prefix XOR value prefixXor = prefix[i]. We will then get the count of subarrays that end at i with prefix XOR value prefixXor from prefixCount. Let\\'s call this count beautifulSubarraysEndingHere.\\n\\nWe will then add beautifulSubarraysEndingHere to the running total count.\\n\\nWe will update prefixCount by incrementing the count of subarrays with prefix XOR value prefixXor.\\n\\nFinally, we will return the total count of beautiful subarrays, which is stored in the variable count.\\n\\nIn this example, the count of beautiful subarrays is 2. The beautiful subarrays are [4, 3, 1, 2, 4] and [3, 1, 2]. The prefix XOR values of these subarrays are 0 and 2, respectively. The corresponding counts of subarrays in prefixCount are (0, 1) and (2, 1)."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290680/detailed-solution-with-approach/"
                    },
                    {
                        "username": "jaspier",
                        "content": "It is only me or \"turn off the 2^k bit from nums[i] and nums[j]\" explain better than \"Subtract 2^k from nums[i] and nums[j]\""
                    },
                    {
                        "username": "c-m-d-",
                        "content": "its intentionally confusing"
                    },
                    {
                        "username": "kotlinc",
                        "content": "Anyone else feel the problem statement is wrong? \\n\\nsee my post\\nhttps://leetcode.com/problems/count-the-number-of-beautiful-subarrays/solutions/3290689/anyone-else-feel-the-problem-statement-is-wrong/"
                    },
                    {
                        "username": "RyanChen99",
                        "content": "If test case if [1,0,0], there is only ONE beautiful subarray which would be [0,0]. But in this problem, the correct answer for [1,0,0] is 3. I am so confused of that, correct me if I am wrong."
                    },
                    {
                        "username": "JHoke",
                        "content": "There are 3 beautiful subarrays in this case. [0], [0], and [0, 0]"
                    },
                    {
                        "username": "jithu7432",
                        "content": "How did you guys come up with XOR, I couldn\\'t even get the question right.\\n`bin(4 & 4)` is `100` and the `k` th bit (2) is `0` not `1` ?"
                    },
                    {
                        "username": "sarthak_045",
                        "content": "for this type of bits problem note down what u want to do.\\ncheck all properties of all gates.(and or xor ) then choose between them .e.g this  problem states we have to remove kth bit (substract 2^k) \\nXOR is preffred for it."
                    },
                    {
                        "username": "saiabhishek1",
                        "content": "what would be output for [4,0] it must be 0 i think"
                    },
                    {
                        "username": "neel19",
                        "content": "A rough idea: \\nThe main idea behind using prefix array works because if at index $i $the value of $prefix[i]$ is $k$ and after some indices at another index say $j | (j>i) $and value of $prefix[j]$ is $k$ this is possible only when the other values were $0$ or the other values have cancelled out each other in the XOR operation. \\n\\nMy Solution: [link](https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/submissions/914223048/)"
                    },
                    {
                        "username": "kirilchukvadim",
                        "content": "The following hint is extremely confusing:\n\nCompute the prefix xor for every index, then the xor of `subarray [left, right] is equal to zero if prefix_xor[left] ^ perfix_xor[right] == 0`\n\nFor the first example, the `prefix_xor=[4,7,6,4,0]` and while prefix_xor[0] == prefix_xor[3], it doesn't mean that subarray [0,3] is beautiful, as 4,3,1,2 is not a beautiful subarray, the beautiful one is 3,1,2! So, seems like indexing is messed up.\nAlso, this tip doesn't say anything about prefix_xor[4] which is 0.."
                    }
                ]
            }
        ]
    }
]