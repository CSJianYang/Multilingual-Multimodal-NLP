[
    {
        "title": "Shift 2D Grid",
        "question_content": "Given a 2D grid of size m x n&nbsp;and an integer k. You need to shift the grid&nbsp;k times.\nIn one shift operation:\n\n\tElement at grid[i][j] moves to grid[i][j + 1].\n\tElement at grid[i][n - 1] moves to grid[i + 1][0].\n\tElement at grid[m&nbsp;- 1][n - 1] moves to grid[0][0].\n\nReturn the 2D grid after applying shift operation k times.\n&nbsp;\nExample 1:\n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1\nOutput: [[9,1,2],[3,4,5],[6,7,8]]\n\nExample 2:\n\nInput: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4\nOutput: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]\n\nExample 3:\n\nInput: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9\nOutput: [[1,2,3],[4,5,6],[7,8,9]]\n\n&nbsp;\nConstraints:\n\n\tm ==&nbsp;grid.length\n\tn ==&nbsp;grid[i].length\n\t1 <= m <= 50\n\t1 <= n <= 50\n\t-1000 <= grid[i][j] <= 1000\n\t0 <= k <= 100",
        "solutions": [
            {
                "id": 1934961,
                "title": "c-simple-clean-code-with-explanation",
                "content": "***It is a observation based question.***\\n\\nIf **k** is **1** then new column is **(j+1)** and if **k** is **k** then new column is **(j+k)** and new column should in range **[0,m-1]**. So new column is **(j+k)%m**.\\n\\nFor row, we have to first **find the number of rows added to previous row** which is equal to the **number of times (j+k) exceeds m**. So, number of rows added is **(j+k)/m**.\\n\\nSo, new row is **(i + (j+k)/m)** and new row should in range **[0,n-1]**. So new row is **(i + (j+k)/m)%n**.\\n\\n```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; // (j + numbers of columns added)%m\\n                \\n                int newI=(i+(j+k)/m)%n; // (i + numbers of rows added)%n \\n                \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; // (j + numbers of columns added)%m\\n                \\n                int newI=(i+(j+k)/m)%n; // (i + numbers of rows added)%n \\n                \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934848,
                "title": "easy-java-code-with-explanation",
                "content": "\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> result = new ArrayList();\\n        int rows = grid.length, col = grid[0].length;\\n\\n        for (int r = 0; r < rows; r++)// filling all the rows of result with empty lists\\n            result.add(new ArrayList());\\n        k %= (rows * col);// every rows*col shifts grid became the same, skipping the similar shifts\\n        int dimension = rows * col;\\n        int begin = dimension - k;// element at (begin) will be at 0,0 in new grid\\n        int x = 0;// counter variable\\n        for (int i = begin; i < begin + dimension; i++) {\\n            int r = (i / col) % rows, c = i % col;// calculating row and cell for new grid\\n            result.get(x / col).add(grid[r][c]);// adding new element in new row\\n            x++;\\n        }\\n        return result;// returning result list\\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n***Time Complexity =O(N+N)=O(2N)=O(N)\\nSpace Complexity=O(N)***\\n\\n<hr>\\n<hr>\\n\\n***UPVOTE if you like the post(^///^)***\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> result = new ArrayList();\\n        int rows = grid.length, col = grid[0].length;\\n\\n        for (int r = 0; r < rows; r++)// filling all the rows of result with empty lists\\n            result.add(new ArrayList());\\n        k %= (rows * col);// every rows*col shifts grid became the same, skipping the similar shifts\\n        int dimension = rows * col;\\n        int begin = dimension - k;// element at (begin) will be at 0,0 in new grid\\n        int x = 0;// counter variable\\n        for (int i = begin; i < begin + dimension; i++) {\\n            int r = (i / col) % rows, c = i % col;// calculating row and cell for new grid\\n            result.get(x / col).add(grid[r][c]);// adding new element in new row\\n            x++;\\n        }\\n        return result;// returning result list\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431225,
                "title": "python-functional-programming-3-lines",
                "content": "shift all the numbers `k` steps, is the same idea as, moving last `k` numbers to head of the list: `nums = nums[-k:] + nums[:-k]`\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        col, nums = len(grid[0]), sum(grid, [])\\n        k = k % len(nums)\\n        nums = nums[-k:] + nums[:-k]\\n        return [nums[i:i+col] for i in range(0, len(nums), col)]\\n```\\n# Functional Programming, 3 lines:\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        f1 = lambda col, nums: [nums[i:i+col] for i in range(0, len(nums), col)]\\n        f2 = lambda nums, k: nums[-k%len(nums):] + nums[:-k%len(nums)]\\n        return f1(len(grid[0]), f2(sum(grid, []), k))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        col, nums = len(grid[0]), sum(grid, [])\\n        k = k % len(nums)\\n        nums = nums[-k:] + nums[:-k]\\n        return [nums[i:i+col] for i in range(0, len(nums), col)]\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        f1 = lambda col, nums: [nums[i:i+col] for i in range(0, len(nums), col)]\\n        f2 = lambda nums, k: nums[-k%len(nums):] + nums[:-k%len(nums)]\\n        return f1(len(grid[0]), f2(sum(grid, []), k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458848,
                "title": "c-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for (int i = 0; i < m * n; ++i) {\\n            int ori_y = i / n;\\n            int ori_x = i % n;\\n            int new_y = (ori_y + (ori_x + k) / n) % m;\\n            int new_x = (ori_x + k) % n;\\n            \\n            ans[new_y][new_x] = grid[ori_y][ori_x];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nHere are some similar matrix(2D Grid) problems.\\n* 498 [Diagonal Traverse](https://leetcode.com/problems/diagonal-traverse/)\\n* 566 [Reshape the Matrix](https://leetcode.com/problems/reshape-the-matrix/)\\n* 867 [Transpose Matrix](https://leetcode.com/problems/transpose-matrix/)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        const int m = grid.size();\\n        const int n = grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for (int i = 0; i < m * n; ++i) {\\n            int ori_y = i / n;\\n            int ori_x = i % n;\\n            int new_y = (ori_y + (ori_x + k) / n) % m;\\n            int new_x = (ori_x + k) % n;\\n            \\n            ans[new_y][new_x] = grid[ori_y][ori_x];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934852,
                "title": "python-3-lines-3-steps-clean-and-simple-solution",
                "content": "\\n**Please UPVOTE if you LIKE!** \\uD83D\\uDE01\\n```\\nclass Solution(object):\\n    def shiftGrid(self, grid, k):\\n        l, m, n, k = [num for row in grid for num in row], len(grid), len(grid[0]), k % (len(grid) * len(grid[0]))  # grid to list\\n        l = l[-k:] + l[:-k]  # shift k times\\n        return [l[i * n: i * n + n] for i in range(m)]  # list to grid\\n```\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def shiftGrid(self, grid, k):\\n        l, m, n, k = [num for row in grid for num in row], len(grid), len(grid[0]), k % (len(grid) * len(grid[0]))  # grid to list\\n        l = l[-k:] + l[:-k]  # shift k times\\n        return [l[i * n: i * n + n] for i in range(m)]  # list to grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060180,
                "title": "java-100-1ms-o-m-n-matrix-to-matrix-copy-optimized-for-speed-explanation",
                "content": "This code is optimized for speed.  It usually runs in 1ms, although sometimes 2ms, as of Feb 10, 2021.  May be slower in future years if more test cases are added or running on different server.\\n\\nThis algorithm first creates a result matrix the same size as `grid[][]`, then uses two loops to copy-and-shift from `grid[][]` to the result matrix.  The result matrix is converted to a `List<List<Integer>>` in the return statement, by using the `Arrays.asList()` method.\\n\\nFor copying from the input matrix `grid[][]` to the output `result[][]` matrix, first calculate the row and column of the `grid[][]` value that will be copied to `result[0][0]` in the output result matrix.  The start row and column to copy from `grid[][]` with be the `k`th value from the rottom right end of the `grid[][]` matrix.  This start row and column are the variables `kRow` and `kCol`.  The start row and column to the output `result[][]` matrix, are `r=0` and `c=0`.  While copying, `kCol` will advance along the columns in a row, until the end of the row, then start copying from column 0 in the next row.\\n![image](https://assets.leetcode.com/users/images/16a7cd10-62f3-4410-b697-bbe760e4bbd3_1614849399.1848493.png)\\n\\nTo make the copying of each numeric value faster, the current rows of `grid` and `result` are referenced by one-dimensional array variables.  The one-dimensional array variables `innRow[]` and `outRow` are references to a single row of the matrix `grid[][]` and `result[][]` respectively.  So changing a value in `outRow[]` also changes the corresponding value in a row of `result[][]` because the changed value is actually the same memory location within both variables.  The one-dimensional arrays `innRow[]` and `outRow[]` are simply short-cuts to a single row of `grid[][]` or `result[][]`.   These one-dimensional array variables for the current rows are changed when advancing to a new row in either `grid` or `result`.  The one-dimensional array variables make the copying faster because each time a single numeric value is copied from `grid` to `result`, the compiled code only has to calculate one-dimensional references within the rows (i.e. `innRow[kCol]` or `outRow[r]`), instead repeatedly calculating two-dimensional references within a matrix (i.e. `grid[kRow][kCol]` or `result[r][c]`).\\n\\nIf useful, please upvote.\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int rowCount = grid.length;                         // Number of rows in grid.\\n        int colCount = grid[0].length;                      // Number of columns in grid.\\n        int gridCount = rowCount * colCount;                // Number of cells (i.e. values) in grid.\\n        k = k % gridCount;                                  // Limit k to max number of cells in grid.  Avoid negatives in next lines.\\n        int kCol = (gridCount - k) % colCount;              // Column to start copying from.\\n        int kRow = ((gridCount - k) % gridCount) / colCount;// Row to start copying from.\\n        int[] innRow = grid[kRow];                          // Array for the row to start copying from.\\n        int[][] result = new int[rowCount][colCount];       // Create result matrix, to hold shifted values.\\n        for (int r = 0; r < rowCount; r++) {                // Loop through \"to\" rows.\\n            int[] outRow = result[r];                       // Get row array to copy into, so only faster 1D reference in inner loop.\\n            for (int c = 0; c < colCount; c++) {            // Loop through \"to\" columns.\\n                outRow[c] = innRow[kCol];                   // Copy value from grid to result, shifting by copying.\\n                if (++kCol >= colCount) {                   // Next \"from\" column.  If at end of row...\\n                    kCol = 0;                               // Then start \"from\" columns at first column.\\n                    if (++kRow >= rowCount)                 // When starting new column, next \"from\" row.  If at end of grid...\\n                        kRow = 0;                           // Then start \"from\" rows at first row.\\n                    innRow = grid[kRow];                    // Get row array to copy from, so only faster 1D reference when copying.\\n                }\\n            }\\n        }\\n        return (List)Arrays.asList(result);                 // Return result matrix, converting it to a List<List<Integer>>.\\n    }\\n}\\n```\\n--- Update ---:\\nAfter a question about the `\"return (List)Arrays.asList(result);\"` statement in the above code, asking how this statement works, I decided to explain this further.  The `Arrays.asList(result)` is used to supposedly create a List from `result`, by creating a `List<List<Integer>>` from the `int[][] result`.  But the `List<List<Integer>>` is **not** a copy of the `result` array, but instead is a `List` that contains **references into** the `result` array.  Changing a value in the `result` array will change the corresponding value in the `List`, and changing a value in the `List` will change the corresponding value in `result`, because both of these are the same value stored in a single memory location, with two different paths to access that value.  The `List` created by `Arrays.asList(...)` is also a **fixed** size `List` which cannot be added to and cannot be removed from.  In other words, the `List` resulting from `Arrays.asList(...)` is not a normal simple `List`.\\n\\nI am not completely sure why the cast `(List)` is needed before the `Arrays.asList`, but the compiler is unhappy without this cast.\\n\\nI used `(List)Arrays.asList(result)` because I assumed `Arrays.asList` could create the List of Lists faster than writing my own code to create the Lists one value at a time.  I have not tested to see if this method is faster than writing my own code to create the List of Lists.\\n\\nAnother curious thing is inserting the following lines before the `return` statement in the code above:\\n```\\n        System.out.println((Arrays.asList(result)).getClass().getName());\\n        System.out.println(((List)Arrays.asList(result)).getClass().getName());\\n        List<List<Integer>> test = new ArrayList();\\n        System.out.println(test.getClass().getName());\\n```\\nThese inserted lines of code will print the following output:\\n\\n ` ` ` ` ` ` `java.util.Arrays$ArrayList`\\n ` ` ` ` ` ` `java.util.Arrays$ArrayList`\\n ` ` ` ` ` ` `java.util.ArrayList`\\n\\nWhich shows that the `List` created by `Arrays.asList` is not quite the same as a `List` created in the more normal way.  I do not yet understand enough of the internal details of Java to explain this difference, and I cannot explain why the cast of `(List)` is needed to make the compiler happy.  If someone knows why the cast `(List)` is needed, or how Lists created by `Arrays.asList(...)` are different than normal Lists, please inform us in the comments.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int rowCount = grid.length;                         // Number of rows in grid.\\n        int colCount = grid[0].length;                      // Number of columns in grid.\\n        int gridCount = rowCount * colCount;                // Number of cells (i.e. values) in grid.\\n        k = k % gridCount;                                  // Limit k to max number of cells in grid.  Avoid negatives in next lines.\\n        int kCol = (gridCount - k) % colCount;              // Column to start copying from.\\n        int kRow = ((gridCount - k) % gridCount) / colCount;// Row to start copying from.\\n        int[] innRow = grid[kRow];                          // Array for the row to start copying from.\\n        int[][] result = new int[rowCount][colCount];       // Create result matrix, to hold shifted values.\\n        for (int r = 0; r < rowCount; r++) {                // Loop through \"to\" rows.\\n            int[] outRow = result[r];                       // Get row array to copy into, so only faster 1D reference in inner loop.\\n            for (int c = 0; c < colCount; c++) {            // Loop through \"to\" columns.\\n                outRow[c] = innRow[kCol];                   // Copy value from grid to result, shifting by copying.\\n                if (++kCol >= colCount) {                   // Next \"from\" column.  If at end of row...\\n                    kCol = 0;                               // Then start \"from\" columns at first column.\\n                    if (++kRow >= rowCount)                 // When starting new column, next \"from\" row.  If at end of grid...\\n                        kRow = 0;                           // Then start \"from\" rows at first row.\\n                    innRow = grid[kRow];                    // Get row array to copy from, so only faster 1D reference when copying.\\n                }\\n            }\\n        }\\n        return (List)Arrays.asList(result);                 // Return result matrix, converting it to a List<List<Integer>>.\\n    }\\n}\\n```\n```\\n        System.out.println((Arrays.asList(result)).getClass().getName());\\n        System.out.println(((List)Arrays.asList(result)).getClass().getName());\\n        List<List<Integer>> test = new ArrayList();\\n        System.out.println(test.getClass().getName());\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734727,
                "title": "javascript-es6-simple-solution",
                "content": "Brief explanation: \\n1. Convert the matrix to an array \\n2. Move the array bottom to the start K times\\n3. Convert the array back to a matrix and return \\n\\n```\\nvar shiftGrid = function (grid, k) {\\n  var arr = grid.flat(),\\n    len = grid[0].length,\\n    res = [];\\n\\n  while (k--) {\\n    arr.unshift(arr.pop());\\n  }\\n\\n  while (arr.length) {\\n    res.push(arr.splice(0, len));\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function (grid, k) {\\n  var arr = grid.flat(),\\n    len = grid[0].length,\\n    res = [];\\n\\n  while (k--) {\\n    arr.unshift(arr.pop());\\n  }\\n\\n  while (arr.length) {\\n    res.push(arr.splice(0, len));\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 434335,
                "title": "python3-2-simple-approaches-with-explanations-by-creating-a-vector",
                "content": "# **Algorithm:**\\n1)  put the matrix row by row to a vector.\\n2)  rotate the vector k times.\\n3)  put the vector to the matrix back the same way.\\n\\nThe **second step** is the same as problem [#189 (Rotate an Array)](https://leetcode.com/problems/rotate-array/), and can be solved in many ways, but here we consider **two approaches** that are simple and have reasonable time and space complexities: \\n**(a) direct shift approach**\\n**(b) reverse approach**\\n\\nAs an example of **Approach (a)**, imagine we want to rotate the vector [1, 2, 3, 4, 5, 6, 7] for k = 3 times. We just need to add these two subsets of the vector, respectively: last k elements and first len(vec)-k elements:\\n[5, 6, 7] +  [1, 2, 3, 4] = [5, 6, 7, 1, 2, 3, 4]\\n\\nAn example of **Approach (b)**:\\nreverse all elements     : [7, 6, 5, 4, 3, 2, 1]\\nreverse first k elements : [5, 6, 7, 4, 3, 2, 1]\\nreverse last len(vec)-k elements : [5, 6, 7, 1, 2, 3, 4]\\n\\nAlthough approach (a) seems simpler, it take additional space (needs an extra vector in addition to the vector created in step 1). Approach (b) might need extra code lines, but does not take additional space.\\n\\n# **Python3 codes:**\\n\\n**Approach (a), direct shift:**\\n```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        #dimensions:\\n\\t\\tNR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        #If k is greater than the length of vector, \\n\\t\\t#the shift will repeat itself in a cycle; \\n\\t\\t#hence, we only care about the remainder.\\n        k = k % (NR * NC)  \\n        \\n\\t\\t#step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by direct shift approach\\n        vec = vec[-k:] + vec[:-k]\\n\\t\\t\\n        # step 3: put vector to matrix back the same way\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n```\\n\\n\\n**Approach (b), reverse method**: (Note that only step 2 has changed):\\n```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        # dimensions:\\n        NR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        # If k is greater than the length of vector, \\n\\t\\t# the shift will repeat itself in a cycle; \\n\\t\\t# hence, we only care about the remainder.\\n        k = k % (NR * NC)\\n\\t\\t\\n        #step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by reverse approach.\\n        self.Rev(vec, 0, NR * NC - 1) #reverse all elements.\\n        self.Rev(vec, 0, k-1)       #reverse first k elements.\\n        self.Rev(vec, k, NR * NC - 1) #revere last len(vec)-k elements. \\n        \\n        #step 3: put the vector to the matrix back the same way.\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n\\t\\t\\n    # This function returns the reverse a subset of the vector,\\n\\t# bound by \"left\" and \"right\" elements\\n    def Rev(self, vec, left, right):\\n        while left < right:\\n            vec[left], vec[right] = vec[right], vec[left]\\n            left += 1 \\n            right -= 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        #dimensions:\\n\\t\\tNR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        #If k is greater than the length of vector, \\n\\t\\t#the shift will repeat itself in a cycle; \\n\\t\\t#hence, we only care about the remainder.\\n        k = k % (NR * NC)  \\n        \\n\\t\\t#step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by direct shift approach\\n        vec = vec[-k:] + vec[:-k]\\n\\t\\t\\n        # step 3: put vector to matrix back the same way\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n```\n```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        # dimensions:\\n        NR = len(grid)\\n        NC = len(grid[0])\\n        vec = [0] * NR * NC #initialize the vector.\\n        # If k is greater than the length of vector, \\n\\t\\t# the shift will repeat itself in a cycle; \\n\\t\\t# hence, we only care about the remainder.\\n        k = k % (NR * NC)\\n\\t\\t\\n        #step 1: put the matrix row by row to the vector.\\n        for i in range(NR):\\n            for j in range(NC):\\n                vec[i * NC + j] = grid[i][j]\\n\\t\\t\\t\\t\\n        #step 2: rotate vector k times by reverse approach.\\n        self.Rev(vec, 0, NR * NC - 1) #reverse all elements.\\n        self.Rev(vec, 0, k-1)       #reverse first k elements.\\n        self.Rev(vec, k, NR * NC - 1) #revere last len(vec)-k elements. \\n        \\n        #step 3: put the vector to the matrix back the same way.\\n        for i in range(NR):\\n            for j in range(NC):\\n                grid[i][j] = vec[i * NC + j]\\n        return grid\\n\\t\\t\\n    # This function returns the reverse a subset of the vector,\\n\\t# bound by \"left\" and \"right\" elements\\n    def Rev(self, vec, left, right):\\n        while left < right:\\n            vec[left], vec[right] = vec[right], vec[left]\\n            left += 1 \\n            right -= 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1934644,
                "title": "c-flatten-array-then-convert-back-to-2d-struggled-live-on-stream",
                "content": "This one was tricky for me, had to get lots of help from chat.\\n\\nWe stream everyday 6PM PT.  There are dozens of us.  Link in profile.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ROWS = grid.size();\\n        int COLS = grid[0].size();\\n        \\n        int total = ROWS * COLS;\\n        \\n        vector<vector<int>> ans(ROWS, vector<int>(COLS, 0));\\n        for(int r = 0; r < ROWS; r++) {\\n            for(int c = 0; c < COLS; c++) {\\n                int flatI = r * COLS + c;\\n                \\n                int newFlatI = (flatI + k) % total;\\n                \\n                int nr = newFlatI / COLS;\\n                int nc = newFlatI % COLS;\\n                ans[nr][nc] = grid[r][c];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ROWS = grid.size();\\n        int COLS = grid[0].size();\\n        \\n        int total = ROWS * COLS;\\n        \\n        vector<vector<int>> ans(ROWS, vector<int>(COLS, 0));\\n        for(int r = 0; r < ROWS; r++) {\\n            for(int c = 0; c < COLS; c++) {\\n                int flatI = r * COLS + c;\\n                \\n                int newFlatI = (flatI + k) % total;\\n                \\n                int nr = newFlatI / COLS;\\n                int nc = newFlatI % COLS;\\n                ans[nr][nc] = grid[r][c];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937723,
                "title": "python-2-solutions-clean-concise-easy-o-1-in-space-complexity",
                "content": "- If we treat grid as an array, we can solve this problem as the same idea with **[189. Rotate Array](https://leetcode.com/problems/rotate-array/discuss/258789/)** problem.\\n- That is, the index of the array `idx`, will be map with the grid cell at `grid[idx // nCols][idx % nCols]`.\\n\\n**\\u2714\\uFE0F Solution 1: Using Extra Space**\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        \\n        n = nRows * nCols\\n        arr = [0] * n\\n        for i in range(n):\\n            idx = (i + n - k) % n\\n            arr[i] = grid[idx // nCols][idx % nCols]\\n        \\n        for i in range(len(arr)):\\n            grid[i // nCols][i % nCols] = arr[i]\\n        return grid\\n```\\nComplexity:\\n- Time: `O(nRows * nCols)`\\n- Space: `O(nRows * nCols)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Reverse in splace**\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        n = nRows * nCols\\n        \\n        def reverse(grid, left, right):\\n            while left < right:\\n                grid[left//nCols][left%nCols], grid[right//nCols][right%nCols] = grid[right//nCols][right%nCols], grid[left//nCols][left%nCols]\\n                left += 1\\n                right -= 1\\n                \\n        reverse(grid, 0, n-1)\\n        reverse(grid, 0, k-1)\\n        reverse(grid, k, n-1)\\n        return grid\\n```\\nComplexity:\\n- Time: `O(nRows * nCols)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        \\n        n = nRows * nCols\\n        arr = [0] * n\\n        for i in range(n):\\n            idx = (i + n - k) % n\\n            arr[i] = grid[idx // nCols][idx % nCols]\\n        \\n        for i in range(len(arr)):\\n            grid[i // nCols][i % nCols] = arr[i]\\n        return grid\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        nRows, nCols = len(grid), len(grid[0])\\n        k %= nRows * nCols\\n        if k == 0: return grid\\n        n = nRows * nCols\\n        \\n        def reverse(grid, left, right):\\n            while left < right:\\n                grid[left//nCols][left%nCols], grid[right//nCols][right%nCols] = grid[right//nCols][right%nCols], grid[left//nCols][left%nCols]\\n                left += 1\\n                right -= 1\\n                \\n        reverse(grid, 0, n-1)\\n        reverse(grid, 0, k-1)\\n        reverse(grid, k, n-1)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934795,
                "title": "c-two-approaches-with-intuition",
                "content": "# Shift 2D Grid\\nThe problem at hand requires us to shift a 2D grid to the right cyclically k times. It is the equivalent of applying right shift operation k times.\\nOne right shift operation does the following:\\n(i,j) becomes (i, j+1)\\nif j == n-1, then it becomes (i+1, 0)\\nif j == n-1 and i == m-1, then it becomes (0, 0)\\n\\n## Approach 1 Calculate Indices for each element\\nIn this approach, we make a copy of the entire matrix, and then fill it with the corresponding elements according to the shifted coordinates.\\n```\\npair<int, int> shift(int i, int j, int k) {\\n\\tj+=k;\\n\\tif(j >= n) {\\n\\t\\ti += j/n;\\n\\t\\tj = j%n;\\n\\t}\\n\\tif(i >= m) {\\n\\t\\ti = i%m;\\n\\t}\\n\\treturn {i,j};\\n}\\n```\\nThe above function gives the shifted coordinates given the original coordinates and the shifted amount. We could call this function at every (i,j) in the matrix and fill the corresponding place.\\n\\nBut this approach would be slow, as we would have to make O(m*n) calls just to this function.\\nA better way to do this is to just call it once for the starting point, and then keep right shifting once for every subsequent element.\\n\\n```\\nnj++;\\nif(nj == n) {\\n\\tni++;\\n\\tnj = 0;\\n}\\nif(ni == m) {\\n\\tni = 0;\\n}\\n```\\n\\nThis code calculates the next position given the new position of the previous point (ni, nj)\\n\\nSo the full code for this approach is as follows:\\n### Code (C++)\\n```\\nclass Solution {\\n    int m, n;\\n    pair<int, int> shift(int i, int j, int k) {\\n        j+=k;\\n        if(j >= n) {\\n            i += j/n;\\n            j = j%n;\\n        }\\n        if(i >= m) {\\n            i = i%m;\\n        }\\n        return {i,j};\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> newGrid(m, vector<int>(n));\\n        auto [ni, nj] = shift(0, 0, k);\\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                newGrid[ni][nj] = grid[i][j];\\n                nj++;\\n                if(nj == n) {\\n                    ni++;\\n                    nj = 0;\\n                }\\n                if(ni == m) {\\n                    ni = 0;\\n                }\\n            }\\n        }\\n        return newGrid;\\n    }\\n};\\n```\\n\\n### Complexity\\n**Time Complexity:** O(m * n)\\n**Space Complexity:** O(m * n) (for returning the new matrix)\\n\\n## Approach 2: Treat Matrix as Array and Right Shift k Times\\nWe already have a good approach for right shifting an array k times;\\n```\\nreverse(arr, 0, n-1);\\nreverse(arr, 0, k-1);\\nreverse(arr, k, n-1);\\n```\\nIf we can treat the whole matrix as a flat array, we can apply the same algorithm and solve this question very easily.\\nTo do this, we can\\'t use the normal reverse function, as it warrants flattening the matrix, which we actually don\\'t need. We just need to *pretend* that the matrix is flattened..\\nThis is accomplished by taking the array coordinates and mapping them to row and column indices underneath.\\n```\\nvoid reverse(vector<vector<int>>& grid, int l, int r) {\\n\\twhile(l<r) {\\n\\t\\tint lr = l/n, lc = l%n;\\n\\t\\tint rr = r/n, rc = r%n;\\n\\t\\tif(rr == m) rr = 0;\\n\\t\\tswap(grid[lr][lc], grid[rr][rc]);\\n\\t\\tl++;\\n\\t\\tr--;\\n\\t}\\n}\\n```\\nOnce this modification is made, the whole problem reduces to just three more statements\\n```\\nreverse(grid, 0, m*n-1);\\nreverse(grid, 0, k-1);\\nreverse(grid, k, m*n-1);\\n```\\n\\n### Code (C++) \\n```\\nclass Solution {\\n    int m, n;\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l<r) {\\n            int lr = l/n, lc = l%n;\\n            int rr = r/n, rc = r%n;\\n            if(rr == m) rr = 0;\\n            swap(grid[lr][lc], grid[rr][rc]);\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n);\\n        if(k == 0) return grid;\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        return grid;\\n    }\\n};\\n```\\n\\n### Caution!\\nThis code modifies the input matrix itself.\\nI regard this as a *hacky* way of achieving O(1) extra space, since one is bound to require some space for storing the output of the program. Plus this approach can lead to loss of information if implemented incorrectly. So take care while using it, or just make a copy of the input matrix and apply this algorithm on it instead.\\n\\n### Complexity\\n**Time Complexity:** O(m * n)\\n**Space Complexity:** O(1) (see above Caution)\\n\\n\\n**Upvote** if you liked this post and would like to see more of these in the future. Leave any doubts or suggestions in the comments.\\nDo you agree with the notion of modifying the input itself in order to get O(1) space?",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npair<int, int> shift(int i, int j, int k) {\\n\\tj+=k;\\n\\tif(j >= n) {\\n\\t\\ti += j/n;\\n\\t\\tj = j%n;\\n\\t}\\n\\tif(i >= m) {\\n\\t\\ti = i%m;\\n\\t}\\n\\treturn {i,j};\\n}\\n```\n```\\nnj++;\\nif(nj == n) {\\n\\tni++;\\n\\tnj = 0;\\n}\\nif(ni == m) {\\n\\tni = 0;\\n}\\n```\n```\\nclass Solution {\\n    int m, n;\\n    pair<int, int> shift(int i, int j, int k) {\\n        j+=k;\\n        if(j >= n) {\\n            i += j/n;\\n            j = j%n;\\n        }\\n        if(i >= m) {\\n            i = i%m;\\n        }\\n        return {i,j};\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        vector<vector<int>> newGrid(m, vector<int>(n));\\n        auto [ni, nj] = shift(0, 0, k);\\n        for(int i = 0; i<m; i++) {\\n            for(int j = 0; j<n; j++) {\\n                newGrid[ni][nj] = grid[i][j];\\n                nj++;\\n                if(nj == n) {\\n                    ni++;\\n                    nj = 0;\\n                }\\n                if(ni == m) {\\n                    ni = 0;\\n                }\\n            }\\n        }\\n        return newGrid;\\n    }\\n};\\n```\n```\\nreverse(arr, 0, n-1);\\nreverse(arr, 0, k-1);\\nreverse(arr, k, n-1);\\n```\n```\\nvoid reverse(vector<vector<int>>& grid, int l, int r) {\\n\\twhile(l<r) {\\n\\t\\tint lr = l/n, lc = l%n;\\n\\t\\tint rr = r/n, rc = r%n;\\n\\t\\tif(rr == m) rr = 0;\\n\\t\\tswap(grid[lr][lc], grid[rr][rc]);\\n\\t\\tl++;\\n\\t\\tr--;\\n\\t}\\n}\\n```\n```\\nreverse(grid, 0, m*n-1);\\nreverse(grid, 0, k-1);\\nreverse(grid, k, m*n-1);\\n```\n```\\nclass Solution {\\n    int m, n;\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l<r) {\\n            int lr = l/n, lc = l%n;\\n            int rr = r/n, rc = r%n;\\n            if(rr == m) rr = 0;\\n            swap(grid[lr][lc], grid[rr][rc]);\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n);\\n        if(k == 0) return grid;\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708897,
                "title": "java-simple-one-loop",
                "content": "```\\n    public List<List<Integer>> shiftGrid(int[][] g, int k) {\\n        int m = g.length, n = g[0].length, tot = m * n;\\n        List<List<Integer>> res= new ArrayList<>();\\n        k = k % tot;\\n        for (int i = 0; i < m; i++) res.add(new ArrayList<>());\\n        for (int l = 0; l < tot; l++) {\\n            int idx = (l - k + tot) % tot;\\n            res.get(l / n).add(g[idx / n][idx % n]);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> shiftGrid(int[][] g, int k) {\\n        int m = g.length, n = g[0].length, tot = m * n;\\n        List<List<Integer>> res= new ArrayList<>();\\n        k = k % tot;\\n        for (int i = 0; i < m; i++) res.add(new ArrayList<>());\\n        for (int l = 0; l < tot; l++) {\\n            int idx = (l - k + tot) % tot;\\n            res.get(l / n).add(g[idx / n][idx % n]);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935498,
                "title": "c-intuitive-approach-clean-solution-with-comments",
                "content": "Make a 1-D vector and push all element in that\\nNow calculate the index from which the modified grid will be started and then update the grid\\n| PLEASE UPVOTE IF YOU LIKE THE SOLUTION |\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>temp;\\n        int mod=m*n;\\n        \\n        //push all elements in a 1-d array\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        k=k%mod;\\n        \\n        // if k==0 then no shifting is done so return original grid\\n        if(k==0)return grid;\\n        \\n        // elements in last row are shifted to 1st row that\\'s why we start from mod-k index i.e kth element from last\\n        \\n        int idx=mod-k;\\n        \\n        // now update grid according to shifting\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid[i][j]=temp[idx];\\n                idx=(idx+1)%mod;\\n            }\\n        }      \\n        return grid;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>temp;\\n        int mod=m*n;\\n        \\n        //push all elements in a 1-d array\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        k=k%mod;\\n        \\n        // if k==0 then no shifting is done so return original grid\\n        if(k==0)return grid;\\n        \\n        // elements in last row are shifted to 1st row that\\'s why we start from mod-k index i.e kth element from last\\n        \\n        int idx=mod-k;\\n        \\n        // now update grid according to shifting\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid[i][j]=temp[idx];\\n                idx=(idx+1)%mod;\\n            }\\n        }      \\n        return grid;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934690,
                "title": "very-simple-solution",
                "content": "```\\n// Please upvote if you like my solution :)\\nvoid reverse(vector<int> &nums,int start,int end){\\n        for(int i=start,j=end;i<j;i++,j--){\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ro = grid.size();\\n        int col = grid[0].size();\\n        vector<int> v;\\n        for(auto &gri:grid){\\n            for(auto &val:gri){\\n                v.push_back(val);\\n            }\\n        }\\n        k = k % v.size();\\n        reverse(v,0,v.size()-k-1);\\n        reverse(v,v.size()-k,v.size()-1);\\n        reverse(v,0,v.size()-1);\\n        int vec = 0;\\n        for(int i=0;i<ro;i++){\\n            for(int j=0;j<col;j++){\\n                grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n// Please upvote if you like my solution :)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\n// Please upvote if you like my solution :)\\nvoid reverse(vector<int> &nums,int start,int end){\\n        for(int i=start,j=end;i<j;i++,j--){\\n            swap(nums[i],nums[j]);\\n        }\\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int ro = grid.size();\\n        int col = grid[0].size();\\n        vector<int> v;\\n        for(auto &gri:grid){\\n            for(auto &val:gri){\\n                v.push_back(val);\\n            }\\n        }\\n        k = k % v.size();\\n        reverse(v,0,v.size()-k-1);\\n        reverse(v,v.size()-k,v.size()-1);\\n        reverse(v,0,v.size()-1);\\n        int vec = 0;\\n        for(int i=0;i<ro;i++){\\n            for(int j=0;j<col;j++){\\n                grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n// Please upvote if you like my solution :)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 516488,
                "title": "c-clean-code-98-runtime-100-space",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res (m, vector<int> (n, 0));\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                int newCol = (j+k)%n;\\n                int countWrapArounds = (j+k)/n;\\n                int newRow = (i+countWrapArounds)%m;\\n                res[newRow][newCol] = grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res (m, vector<int> (n, 0));\\n        for (int i=0;i<m;i++){\\n            for (int j=0;j<n;j++){\\n                int newCol = (j+k)%n;\\n                int countWrapArounds = (j+k)/n;\\n                int newRow = (i+countWrapArounds)%m;\\n                res[newRow][newCol] = grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934572,
                "title": "java-simple-solution-time-o-n-space-o-1-faster-than-95-74",
                "content": "If the return ArrayList does not count space then its space complexity is O(1).\\nThe time complexity is O(n) where n is the count of all grid items.\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m * n;\\n        // if shifting total times, it shifts back to orignal state\\n        k = k % (total);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i = 0; i < m; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            result.add(list);\\n            for (int j = 0; j < n; j++) {   \\n                // i * n + j original place index in 1D array\\n                // i * n + j - k  is to get value k steps before                 \\n                int index = ((i * n + j) - k + total) % total;\\n                list.add(grid[index / n][index % n]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m * n;\\n        // if shifting total times, it shifts back to orignal state\\n        k = k % (total);\\n        List<List<Integer>> result = new ArrayList<>();\\n        for(int i = 0; i < m; i++) {\\n            List<Integer> list = new ArrayList<>();\\n            result.add(list);\\n            for (int j = 0; j < n; j++) {   \\n                // i * n + j original place index in 1D array\\n                // i * n + j - k  is to get value k steps before                 \\n                int index = ((i * n + j) - k + total) % total;\\n                list.add(grid[index / n][index % n]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936908,
                "title": "conceptually-straightforward-javascript-solution-nested-unshift-pop-76ms",
                "content": "My first concrete idea was a map adding each element by k % n or some sort of length but then the pop push shift came to mind and was more straight forward for me to implement. \\n\\nIt works the way I visualize the matrix to shift in the example. The element at the end of each row is popped off and unshifted to the beginning of the next. The last row wraps around to the first row with the modulo. \\n\\nMy fastest submission was 68ms - 100% \\n```javascript\\nvar shiftGrid = function(grid, k) {\\n    m = grid.length;\\n    n = grid[0].length;\\n\\n    for(let j = 0; j < k; j++){\\n        for(let i = 0; i < (m); i++){\\n            grid[i].unshift(grid[((m + i -1) % (m))].pop()); \\n        }\\n    }\\n    return grid;\\n};\\n```\\n\\nMy fastest submission was 78ms -- 100% as of 4/11\\n\\n![image](https://assets.leetcode.com/users/images/794f6eed-1983-4020-8bd8-68d7cb788a37_1649695793.5833466.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar shiftGrid = function(grid, k) {\\n    m = grid.length;\\n    n = grid[0].length;\\n\\n    for(let j = 0; j < k; j++){\\n        for(let i = 0; i < (m); i++){\\n            grid[i].unshift(grid[((m + i -1) % (m))].pop()); \\n        }\\n    }\\n    return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934734,
                "title": "python-in-place-solution-with-explanation",
                "content": "### Introduction\\n\\nGiven a 2D array `grid`, we want to return the array after its elements have been shifted to the right (wrapped by rows) by `k` positions.\\n\\nMany solutions involve initialising the resultant array and mapping each element in the original array to its final position in the resultant array. However, these solutions require O(mn) space (note: O(1) auxiliary space, but O(mn) space), where `m` is the number of rows in `grid` and `n` is the number of columns in `grid`.\\n\\nThis post presents an in-place solution; we are able to get the resultant array by modifying the original array. And yes, this will be done in the most optimal way possible; the time complexity for this solution is O(mn), which is comparable to many other solutions.\\n\\n---\\n\\n### Explanation\\n\\nThe main logic behind how the code operates is as follows: Upon mapping an element from its original index to its resultant index, **we will swap the element at the current index with the resultant element, and continue by finding the resultant index for the new element**. We do this until either 1) all the elements have been swapped; or 2) we reaxh the initial index. To illustrate, the following sequence is for one shift operation, i.e., `k = 1`:\\n\\n```text\\n1 2 3    _ 2 3    _ 1 3    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    9 1 2\\n4 5 6 -> 4 5 6 -> 4 5 6 -> 4 5 6 -> 3 5 6 -> 3 4 6 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5\\n7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    6 8 9    6 7 9    6 7 8    6 7 8\\nstart    cur=1    cur=2    cur=3    cur=4    cur=5    cur=6    cur=7    cur=8    cur=9     end\\n```\\n\\nSometimes, we will end up on the initial index before all the elements have been successfully swapped. Take for example:\\n\\n```text\\nk = 4\\n1 2 3    _ 2 3    _ 2 3    _ 2 5    3 2 5\\n4 5 6 -> 4 5 6 -> 4 1 6 -> 4 1 6 -> 4 1 6\\nstart    cur=1    cur=5    cur=3    cur=_\\n```\\n\\nIn such instances, **we would need to increment the initial index by 1 and continue with the next element**. Note that if we know that some elements have not yet been swapped, then we know that the element after the index has incremented by 1 has not been swapped, since if `k = 1`, all the elements would have been swapped before the initial index has been reached.\\n\\n---\\n\\n### Approach 1: GCD\\n\\nHow then do we know if the loop will reach the initial index before all elements are swapped, and how many times do we need to increment the initial index? **One way is to use the greatest common divisor (GCD) between the number of elements in `grid` and `k`, which gives us the number of times we need to increment the initial index**.\\n\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:  # after k shifts, final array = grid\\n            return grid\\n        div = gcd(m*n, k)  # math.gcd\\n        for i in range(div):\\n            r, c = divmod(i, n)\\n            curr = grid[r][c]  # obtain initial element\\n            for j in range(m*n//div):\\n                r, c = divmod((i+k*(j+1))%(m*n), n)  # get the resultant index\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n        return grid\\n ```\\n \\n **TC: O(mn)**, since each index is looped through only once.\\n Note: for time complexity of `math.gcd()`, you can read more [here](https://codility.com/media/train/10-Gcd.pdf).\\n **SC: O(1)**, as discussed previously.\\n \\n ---\\n \\n ### Approach 2: Counter\\n \\n A simpler way to determine if all elements have been swapped is to **have a counter for the number of elements that have been swapped so far**. If there are elements left to swap, increment the initial index; otherwise, return the resultant array.\\n \\n ```python\\n class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:\\n            return grid\\n        count = i = 0\\n        while count < m*n:\\n            r, c = divmod(i, n)\\n            curr, j = grid[r][c], (i+k)%(m*n)  # get initial element and its final position\\n            while True:\\n                r, c = divmod(j, n)\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n                count += 1  # increment swap counter\\n                if j == i:  # initial index reached\\n                    break\\n                j = (j+k)%(m*n)\\n            i += 1  # increment initial index if not all elements have been swapped\\n        return grid\\n```\\n\\n**TC: O(mn)**, as discussed previously.\\n**SC: O(1)**, as discussed previously.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [],
                "code": "```text\\n1 2 3    _ 2 3    _ 1 3    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    _ 1 2    9 1 2\\n4 5 6 -> 4 5 6 -> 4 5 6 -> 4 5 6 -> 3 5 6 -> 3 4 6 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5 -> 3 4 5\\n7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    7 8 9    6 8 9    6 7 9    6 7 8    6 7 8\\nstart    cur=1    cur=2    cur=3    cur=4    cur=5    cur=6    cur=7    cur=8    cur=9     end\\n```\n```text\\nk = 4\\n1 2 3    _ 2 3    _ 2 3    _ 2 5    3 2 5\\n4 5 6 -> 4 5 6 -> 4 1 6 -> 4 1 6 -> 4 1 6\\nstart    cur=1    cur=5    cur=3    cur=_\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:  # after k shifts, final array = grid\\n            return grid\\n        div = gcd(m*n, k)  # math.gcd\\n        for i in range(div):\\n            r, c = divmod(i, n)\\n            curr = grid[r][c]  # obtain initial element\\n            for j in range(m*n//div):\\n                r, c = divmod((i+k*(j+1))%(m*n), n)  # get the resultant index\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n        return grid\\n ```\n```python\\n class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        if (k := k%(m*n)) == 0:\\n            return grid\\n        count = i = 0\\n        while count < m*n:\\n            r, c = divmod(i, n)\\n            curr, j = grid[r][c], (i+k)%(m*n)  # get initial element and its final position\\n            while True:\\n                r, c = divmod(j, n)\\n                grid[r][c], curr = curr, grid[r][c]  # perform swap operation\\n                count += 1  # increment swap counter\\n                if j == i:  # initial index reached\\n                    break\\n                j = (j+k)%(m*n)\\n            i += 1  # increment initial index if not all elements have been swapped\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431311,
                "title": "easy-solution-with-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> temp;\\n        temp = grid;\\n        int n = grid.size(), m = grid[0].size();\\n        while(k--){\\n            for(int i = 0; i < n; ++i){\\n                for(int j = 1; j < m; ++j){\\n                    temp[i][j] = grid[i][j-1];\\n                }\\n                    \\n            }\\n            for(int i = 0; i < n-1; ++i){\\n                temp[i+1][0] = grid[i][m-1];\\n            }\\n            temp[0][0] = grid[n-1][m-1]; // special case\\n            grid = temp;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> temp;\\n        temp = grid;\\n        int n = grid.size(), m = grid[0].size();\\n        while(k--){\\n            for(int i = 0; i < n; ++i){\\n                for(int j = 1; j < m; ++j){\\n                    temp[i][j] = grid[i][j-1];\\n                }\\n                    \\n            }\\n            for(int i = 0; i < n-1; ++i){\\n                temp[i+1][0] = grid[i][m-1];\\n            }\\n            temp[0][0] = grid[n-1][m-1]; // special case\\n            grid = temp;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934602,
                "title": "4-liner-code-of-c-without-k-times-rotation",
                "content": "**C++ Easy Solution Without Actually Rotating Matrix K times \\n4 Liner Code**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>>arr(grid.size(),vector<int>(grid[0].size(),0));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                arr[(i+(j+k)/grid[i].size())%grid.size()][(j+k)%grid[i].size()]=grid[i][j];\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```\\n**Please Upvote and Like**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>>arr(grid.size(),vector<int>(grid[0].size(),0));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                arr[(i+(j+k)/grid[i].size())%grid.size()][(j+k)%grid[i].size()]=grid[i][j];\\n            }\\n        }\\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935964,
                "title": "python-o-mn-solution-explained",
                "content": "Let us create `ans` with zeroes. Then for each element we calculate where it should go and fill this element.\\n\\n#### Complexity\\nIt is `O(mn)` for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def shiftGrid(self, G, k):\\n        m, n = len(G), len(G[0])\\n        ans = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                delta, c2 = divmod(c + k, n)\\n                ans[(r + delta) % m][c2] = G[r][c]\\n                \\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, G, k):\\n        m, n = len(G), len(G[0])\\n        ans = [[0] * n for _ in range(m)]\\n        for r in range(m):\\n            for c in range(n):\\n                delta, c2 = divmod(c + k, n)\\n                ans[(r + delta) % m][c2] = G[r][c]\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935910,
                "title": "just-flatten-and-rotate-the-array",
                "content": "**OBSERVATION:**\\nIf we trace the path of any number/index as we do the operation multiple times we find that the number is merely traversing the matrix row-wise. Take 1 for example and look at its path.\\n\\n1. This gives us an idea to flatten out the array and rotate it k times to get the final matrix in Row Major Order. \\n2. One other thing to notice is that after M X N number of operations, the resulting matrix is the original matrix. Hence we can update k as **`k = k % ( m * n )`.** \\n3. The rotation algorithm can be practiced from [Leetcode 189. Rotate Array](https://leetcode.com/problems/rotate-array/).\\n\\n![image](https://assets.leetcode.com/users/images/9d02625d-10dc-4598-88d5-0ae7d26efc96_1649671829.3801272.png)\\n\\n**STEPS:**\\n1. Flatten out the array.\\n2. Rotate the array k times.\\n3. Resulting list is a Row Major representation of our answer array. So convert this 1d Array to 2d Matrix.\\n\\n\\n**CODE:**\\n```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None: # From Leetcode Problem 189. Rotate Array\\n        n = len(nums)\\n        k = k % n\\n        nums[:] = nums[n - k:] + nums[:n - k]\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        arr = [i for sublist in grid for i in sublist] # Flatten out the array\\n        self.rotate(arr,k) # Rotate the array \\n        grid = [[arr[i*n+j] for j in range(n)] for i in range(m)] # Convert Flattened output to 2d Matrix\\n        return grid # Return 2d Result\\n```\\n**NOTE:** \\n**`grid = [[arr[i*n+j] for j in range(n)] for i in range(m)]`** is just a shorter way for doing the following:\\n```\\ngrid = []\\nfor i in range(m):\\n    temp = []\\n    for j in range(n):\\n        temp.append(arr[i*n+j])\\n    grid.append(temp)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rotate(self, nums: List[int], k: int) -> None: # From Leetcode Problem 189. Rotate Array\\n        n = len(nums)\\n        k = k % n\\n        nums[:] = nums[n - k:] + nums[:n - k]\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0])\\n        arr = [i for sublist in grid for i in sublist] # Flatten out the array\\n        self.rotate(arr,k) # Rotate the array \\n        grid = [[arr[i*n+j] for j in range(n)] for i in range(m)] # Convert Flattened output to 2d Matrix\\n        return grid # Return 2d Result\\n```\n```\\ngrid = []\\nfor i in range(m):\\n    temp = []\\n    for j in range(n):\\n        temp.append(arr[i*n+j])\\n    grid.append(temp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598647,
                "title": "c-neat-easily-understandable-indented-code",
                "content": "I have used deque from the STL library.\\n\\n```\\nauto speedup=[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& G, int k) \\n    {\\n        int m= G.size();\\n        int n= G[0].size();\\n        \\n        deque <int> tmp {};\\n\\n        for(auto i=0; i<m; i++)\\n\\t        for(auto j=0; j<n; j++)\\n                tmp.push_back(G[i][j]);\\n    \\n        while(k--)\\n\\t    {\\n            int b= tmp.back();\\n            tmp.pop_back();\\n            tmp.push_front(b);\\n        }\\n\\n        for(auto i=0; i<m; i++)\\n        {\\n\\t        for(auto j=0; j<n; j++)\\n\\t        { \\n                G[i][j]= tmp.front();\\n                tmp.pop_front();\\n\\t        }\\n        }\\n        return G;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nauto speedup=[]()\\n{\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return nullptr;\\n}();\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& G, int k) \\n    {\\n        int m= G.size();\\n        int n= G[0].size();\\n        \\n        deque <int> tmp {};\\n\\n        for(auto i=0; i<m; i++)\\n\\t        for(auto j=0; j<n; j++)\\n                tmp.push_back(G[i][j]);\\n    \\n        while(k--)\\n\\t    {\\n            int b= tmp.back();\\n            tmp.pop_back();\\n            tmp.push_front(b);\\n        }\\n\\n        for(auto i=0; i<m; i++)\\n        {\\n\\t        for(auto j=0; j<n; j++)\\n\\t        { \\n                G[i][j]= tmp.front();\\n                tmp.pop_front();\\n\\t        }\\n        }\\n        return G;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 488404,
                "title": "python-simple-o-m-n-95-100-extra-space-used",
                "content": "```\\n    def shiftGrid(self, grid, k):\\n        \\n        k = k % (len(grid) * len(grid[0]))\\n        \\n        linear = []\\n        for level in grid :\\n            linear.extend(level)\\n        \\n        linear = linear[-k:] + linear[:-k]\\n        l = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid[i][j] = linear[l]\\n                l += 1\\n        \\n        return grid\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def shiftGrid(self, grid, k):\\n        \\n        k = k % (len(grid) * len(grid[0]))\\n        \\n        linear = []\\n        for level in grid :\\n            linear.extend(level)\\n        \\n        linear = linear[-k:] + linear[:-k]\\n        l = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                grid[i][j] = linear[l]\\n                l += 1\\n        \\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 433298,
                "title": "javascript-solution-with-comments",
                "content": "this might not be the most efficient way but at least makes sence:\\n\\n```\\nvar shiftGrid = function(grid, k) {\\n    if(!grid.length || k < 1) return grid\\n    \\n    // first flatten the array \\n    let flattened = grid.reduce((acc, el) => {\\n        return acc.concat(el)\\n    },[])\\n    \\n    // now that we have one array, just rotate it k times\\n    for(let i = 0; i < k; i++) {\\n        flattened.unshift(flattened.pop())\\n    }\\n    \\n    // turn it back into a grid\\n    let res = []\\n    let size = grid[0].length\\n      for(let i = 0; i < flattened.length; i = i+size)\\n      res.push(flattened.slice(i,i+size));\\n      return res;\\n};",
                "solutionTags": [],
                "code": "this might not be the most efficient way but at least makes sence:\\n\\n```\\nvar shiftGrid = function(grid, k) {\\n    if(!grid.length || k < 1) return grid\\n    \\n    // first flatten the array \\n    let flattened = grid.reduce((acc, el) => {\\n        return acc.concat(el)\\n    },[])\\n    \\n    // now that we have one array, just rotate it k times\\n    for(let i = 0; i < k; i++) {\\n        flattened.unshift(flattened.pop())\\n    }\\n    \\n    // turn it back into a grid\\n    let res = []\\n    let size = grid[0].length\\n      for(let i = 0; i < flattened.length; i = i+size)\\n      res.push(flattened.slice(i,i+size));\\n      return res;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1937275,
                "title": "c-very-easy-to-logic",
                "content": "I would suggest just dry run the code and you will get the intution.\\n\\n```class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<row;i++)\\n            {\\n                for(int j=col-1;j>=1;j--)\\n                {\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }\\n            }\\n            for(int i=row-1;i>=1;i--)\\n            {\\n                swap(grid[i][0],grid[i-1][0]);\\n            }\\n        }\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<row;i++)\\n            {\\n                for(int j=col-1;j>=1;j--)\\n                {\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1934777,
                "title": "java-easy-to-understand-explanation-iterate-and-add-as-though-a-1d-array",
                "content": "**Understanding the fundamentals**\\n\\nConsider a single dimensional array of size n :\\na[[1,2,3,4,5,6,7,8,9]. Here n = 9\\nFor instance, we have k=2 which means that the array should rotate clockwise twice,\\nthen array would become\\n[8,9,1,2,3,4,5,6,7]\\nyou would notice that there is a pattern while rotating.\\na[0] will be a[7] which can also be written as a[9 - 2 + 0]\\na[1] will be a[8], which can also be written as a[9 - 2 + 1]\\na[2] will be a[0] , which can also be written as a[9 - 2 + 2] - but a[9] is not there, so we need to do a modulus on 9 to get a[0]\\n... and so on,\\n\\nWe need to concentrate on the pivot position to arrive at the generalized formula to find the value at given index after rotation\\nIn a nutshell, if you need to rotate an array k elements in clockwise direction, you need to apply the formula\\n*a[i] = a[(n - k + i) % n] ---- > formula 1*\\n\\nSimilarly, if you need to rotate the array in anticlockwise direction, that is left shift twice in the above example, \\n\\nthe array [1,2,3,4,5,6,7,8,9] would become [3,4,5,6,7,8,9,1,2]\\nHere a[0] = a[2] which can also be written as a[(9 + 2 + 0) % 9]\\na[1] = a[3], which can also be written as a[(9 + 2 + 1)% 9]...\\nand so on,\\na[7] = a[0] which can also be written as a[(9 + 2 + 7) % 9]\\nthus, general formula in this case can be written as \\n*a[i] = a[(n + k + i ) % n]*\\n\\n**Applying 1D array rotation  logic to 2D array**\\nNow that you have understood how the array rotation in 1D array works, lets apply the logic on 2D array of size m*n;\\nHere, total number of elements would be m * n\\neach row will contain n elements\\nSo, to find out where the xth element in the 1D representation would fit in,\\n*m = x/n; --- > formula 2*\\n*n = x%n; ---- > formula 3*\\n\\nNow in the given question, you are expecting an arraylist which in turn contains arraylist representing each row,\\n\\nSo, first we create the arraylist for each row.\\n\\nNow we apply formula 1 to get the index variable value.\\n\\nThen we use formula for getting the mth arraylist to add the grid item calculated using formula 2 and formula 3.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m*n;\\n        // the following is done to make sure that you dont rotate more than total number of times.\\n        k = k % total;\\n        List<List<Integer>> list = new ArrayList<>();\\n        // create arraylist for each row.\\n        for(int i = 0; i < m; i++){\\n            list.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < total; i++) {\\n            // the index below is used to calculate m and n position\\n            // for a given row, m = index/n, n = index%n\\n            // this is while trying to iterate the array as a 1D array\\n            // with index pointing to current index of the imaginary single dimension array\\n            int index = (total - k + i) % total;\\n            // i%n gives you the list bucket to which the element should be added.\\n            list.get(i/n).add(grid[index/n][index%n]);\\n            \\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int total = m*n;\\n        // the following is done to make sure that you dont rotate more than total number of times.\\n        k = k % total;\\n        List<List<Integer>> list = new ArrayList<>();\\n        // create arraylist for each row.\\n        for(int i = 0; i < m; i++){\\n            list.add(new ArrayList<>());\\n        }\\n        for(int i = 0; i < total; i++) {\\n            // the index below is used to calculate m and n position\\n            // for a given row, m = index/n, n = index%n\\n            // this is while trying to iterate the array as a 1D array\\n            // with index pointing to current index of the imaginary single dimension array\\n            int index = (total - k + i) % total;\\n            // i%n gives you the list bucket to which the element should be added.\\n            list.get(i/n).add(grid[index/n][index%n]);\\n            \\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934646,
                "title": "java-brute-froce-slow-but-intuitive",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][] temp = grid;\\n        \\n        while (k-- > 0) {\\n            // init for each loop\\n            temp = new int[n][m];\\n            \\n            // 1. shift right\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 1; j < m; j++) {\\n                    temp[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            \\n            // 2. move last one in this row to the next row\\n            for (int i = 1; i < n; i++) {\\n                temp[i][0] = grid[i - 1][m - 1];\\n            }\\n            \\n            // 3. move the last one to the first place\\n            temp[0][0] = grid[n - 1][m - 1];\\n            \\n            // repeat\\n            grid = temp;\\n        }\\n        \\n        return (List)Arrays.asList(temp);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int n = grid.length, m = grid[0].length;\\n        int[][] temp = grid;\\n        \\n        while (k-- > 0) {\\n            // init for each loop\\n            temp = new int[n][m];\\n            \\n            // 1. shift right\\n            for (int i = 0; i < n; i++) {\\n                for (int j = 1; j < m; j++) {\\n                    temp[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            \\n            // 2. move last one in this row to the next row\\n            for (int i = 1; i < n; i++) {\\n                temp[i][0] = grid[i - 1][m - 1];\\n            }\\n            \\n            // 3. move the last one to the first place\\n            temp[0][0] = grid[n - 1][m - 1];\\n            \\n            // repeat\\n            grid = temp;\\n        }\\n        \\n        return (List)Arrays.asList(temp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462152,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for(int i=0; i<n*m; i++){\\n           int temp=(i+k)%(n*m);\\n           ans[temp/n][temp%n]=grid[i/n][i%n];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        for(int i=0; i<n*m; i++){\\n           int temp=(i+k)%(n*m);\\n           ans[temp/n][temp%n]=grid[i/n][i%n];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506983,
                "title": "easy-to-follow-go-solution",
                "content": "```\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n\\tn := len(grid)\\n\\tm := len(grid[0])\\n\\n\\tans := make([][]int, n)\\n\\tfor i := 0; i < len(ans); i++ {\\n\\t\\tans[i] = make([]int, m)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tx := (k / m) % n\\n\\t\\t\\ty := k % m\\n\\n\\t\\t\\tans[x][y] = grid[i][j]\\n\\t\\t\\tk++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n\\tn := len(grid)\\n\\tm := len(grid[0])\\n\\n\\tans := make([][]int, n)\\n\\tfor i := 0; i < len(ans); i++ {\\n\\t\\tans[i] = make([]int, m)\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tfor j := 0; j < m; j++ {\\n\\t\\t\\tx := (k / m) % n\\n\\t\\t\\ty := k % m\\n\\n\\t\\t\\tans[x][y] = grid[i][j]\\n\\t\\t\\tk++\\n\\t\\t}\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1639737,
                "title": "99-time-99-21-memory-flatten-the-matrix-and-then-use-rotate-c",
                "content": "Space and time-complexity: O(N)\\nThis algorithm is significantly fast due to fewer cache misses/crimes. \\n\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint r=grid.size(), c=grid[0].size();\\n\\tvector<int> data(r*c);\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tdata[i*c+j] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tk %= (r*c);\\n\\trotate(data.rbegin(), data.rbegin()+k, data.rend());\\n\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tgrid[i][j] = data[i*c+j];\\n\\t\\t}\\n\\t}\\n\\treturn move(grid);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint r=grid.size(), c=grid[0].size();\\n\\tvector<int> data(r*c);\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tdata[i*c+j] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\n\\tk %= (r*c);\\n\\trotate(data.rbegin(), data.rbegin()+k, data.rend());\\n\\n\\tfor(int i=0; i<r; ++i) {\\n\\t\\tfor(int j=0; j<c; ++j) {\\n\\t\\t\\tgrid[i][j] = data[i*c+j];\\n\\t\\t}\\n\\t}\\n\\treturn move(grid);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 462852,
                "title": "java-99-100-17-lines-solution",
                "content": "```\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int row=grid.length, col=grid[0].length;\\n        int newK=k%(row*col);\\n        List<List<Integer>> ret=new LinkedList<List<Integer>>();\\n        int endPoint= newK==0? 0:row*col-newK;\\n        int boundry=row*col;\\n        Integer newGrid[][]=new Integer[row][col];\\n        for(int i=0,j=endPoint;i<boundry;i++,j++)\\n        {\\n            if(j==boundry)\\n                j=0;\\n            newGrid[i/col][i%col]=grid[j/col][j%col];\\n        }\\n        for(Integer[] a:newGrid)\\n            ret.add(Arrays.asList(a));\\n        return ret;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int row=grid.length, col=grid[0].length;\\n        int newK=k%(row*col);\\n        List<List<Integer>> ret=new LinkedList<List<Integer>>();\\n        int endPoint= newK==0? 0:row*col-newK;\\n        int boundry=row*col;\\n        Integer newGrid[][]=new Integer[row][col];\\n        for(int i=0,j=endPoint;i<boundry;i++,j++)\\n        {\\n            if(j==boundry)\\n                j=0;\\n            newGrid[i/col][i%col]=grid[j/col][j%col];\\n        }\\n        for(Integer[] a:newGrid)\\n            ret.add(Arrays.asList(a));\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 431111,
                "title": "simple-to-understand-java",
                "content": "```\\n  public static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int[][] temp = new int[grid.length][grid[0].length]; // took temp grid\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int mod = n * m;\\n        k = k % mod; // minimize the k value\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int p = j + k; // defines which col\\n                int r = p / (m); // defines which row\\n                if (p < m) {\\n                    temp[i][p] = grid[i][j];\\n                } else {\\n                    temp[(i + r) % n][p % m] = grid[i][j];\\n                }\\n            }\\n        }\\n\\t\\t// making temp grid into list\\n        List<List<Integer>> result = new LinkedList<>();\\n        for (int[] t : temp) {\\n            LinkedList<Integer> c = new LinkedList<>();\\n            for (int i : t) {\\n                c.add(i);\\n            }\\n            result.add(c);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  public static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int[][] temp = new int[grid.length][grid[0].length]; // took temp grid\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int mod = n * m;\\n        k = k % mod; // minimize the k value\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int p = j + k; // defines which col\\n                int r = p / (m); // defines which row\\n                if (p < m) {\\n                    temp[i][p] = grid[i][j];\\n                } else {\\n                    temp[(i + r) % n][p % m] = grid[i][j];\\n                }\\n            }\\n        }\\n\\t\\t// making temp grid into list\\n        List<List<Integer>> result = new LinkedList<>();\\n        for (int[] t : temp) {\\n            LinkedList<Integer> c = new LinkedList<>();\\n            for (int i : t) {\\n                c.add(i);\\n            }\\n            result.add(c);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937480,
                "title": "c-matrix-o-mxn-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                //for k=1 new column is (j+1), similarly for k=k new column is (j+k) \\n                //(j+k)%c for maintain total no. of columns\\n                int newj = (j+k)%c;\\n                \\n                //divide (j+k) with c to maintain no. of columns and move to next row\\n                //(i+(j+k)/c)%r for maintain no. of rows and if all rows end\\n                //we start from beginning\\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                //for k=1 new column is (j+1), similarly for k=k new column is (j+k) \\n                //(j+k)%c for maintain total no. of columns\\n                int newj = (j+k)%c;\\n                \\n                //divide (j+k) with c to maintain no. of columns and move to next row\\n                //(i+(j+k)/c)%r for maintain no. of rows and if all rows end\\n                //we start from beginning\\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936023,
                "title": "cpp-easy-manipulation-without-mod-with-intuition",
                "content": "```\\n step 1:  for k=1, store the last column in vector.\\n step 2:  take temp variable to store bottom right corner element \\n step 3:  simply right rotate every row of the \\n\\t\\t\\t matrix by 1.\\n step 4: copy temp variable to top left element.\\n step 5: copy the elements stored in vector in the first column\\n step 6: repeat the above steps k times.\\n\\t\\t\\t \\nclass Solution {\\npublic:\\n      \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int temp = 0;\\n        for(int t=0;t<k;t++){\\n            vector<int> v;\\n            for(int p=0;p<n;p++){\\n                v.push_back(grid[p][m-1]);\\n            }\\n            int temp = grid[n-1][m-1];\\n        for(int i=0;i<n;i++){\\n            for(int j=m-1;j>0;j--){\\n                grid[i][j] = grid[i][j-1];\\n            }\\n        }\\n        grid[0][0] = temp;\\n        for(int r=1;r<n;r++){\\n            grid[r][0] = v[r-1];\\n        }\\n        }  \\n        return grid;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n      \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int temp = 0;\\n        for(int t=0;t<k;t++){\\n            vector<int> v;\\n            for(int p=0;p<n;p++){\\n                v.push_back(grid[p][m-1]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1934599,
                "title": "python-easy-to-understand",
                "content": "We compute the new dimensions for every character and insert it there.\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        res=[[0]*n for _ in range(m)]\\n        for c in range(n):\\n            c2=(c+k)%n\\n            for r in range(m):\\n                r2=(r+(c+k)//n)%m\\n                res[r2][c2]=grid[r][c]        \\n        return res",
                "solutionTags": [],
                "code": "We compute the new dimensions for every character and insert it there.\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        res=[[0]*n for _ in range(m)]\\n        for c in range(n):\\n            c2=(c+k)%n\\n            for r in range(m):\\n                r2=(r+(c+k)//n)%m\\n                res[r2][c2]=grid[r][c]        \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1934598,
                "title": "python-2-approach-with-example-shown",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # m*n space:\\n#         ans = [[0]*n for _ in range(m)]  \\n#         for i in range(m):\\n#             for j in range(n):\\n#                 ix = (i*n + j + k)%(m*n)\\n#                 ans[ix//n][ix%n] = grid[i][j]     \\n#         return ans\\n\\n\\n# 0(1) space\\n        def reverse(l,r):\\n            while l <= r:\\n                lr, lc = l//n, l%n\\n                rr, rc = r//n, r%n\\n                grid[lr][lc], grid[rr][rc] = grid[rr][rc], grid[lr][lc]\\n                l += 1\\n                r -= 1\\n        \\n        k = k%(m*n)\\n        reverse(0, m*n-1)\\n        reverse(0,k-1)\\n        reverse(k, m*n-1)\\n        return grid\\n                                \\n# case --> k ==2\\n\\n#     123\\n#     456\\n#     789\\n\\n#     891\\n#     234\\n#     567\\n\\n# 123456789\\n# (reverse whole) becomes -->\\n# 98|7654321\\n# (reverse 0:k) and (reverse k:) becomes -->\\n# 89|1234567\\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        m, n = len(grid), len(grid[0])\\n        \\n        # m*n space:\\n#         ans = [[0]*n for _ in range(m)]  \\n#         for i in range(m):\\n#             for j in range(n):\\n#                 ix = (i*n + j + k)%(m*n)\\n#                 ans[ix//n][ix%n] = grid[i][j]     \\n#         return ans\\n\\n\\n# 0(1) space\\n        def reverse(l,r):\\n            while l <= r:\\n                lr, lc = l//n, l%n\\n                rr, rc = r//n, r%n\\n                grid[lr][lc], grid[rr][rc] = grid[rr][rc], grid[lr][lc]\\n                l += 1\\n                r -= 1\\n        \\n        k = k%(m*n)\\n        reverse(0, m*n-1)\\n        reverse(0,k-1)\\n        reverse(k, m*n-1)\\n        return grid\\n                                \\n# case --> k ==2\\n\\n#     123\\n#     456\\n#     789\\n\\n#     891\\n#     234\\n#     567\\n\\n# 123456789\\n# (reverse whole) becomes -->\\n# 98|7654321\\n# (reverse 0:k) and (reverse k:) becomes -->\\n# 89|1234567\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660025,
                "title": "c-linear-2-pointer-in-place-solution-explained-99-time-16ms-100-space-13-7mb",
                "content": "Really funny problem; and a bit more challenge can be given to us if we try to do it in linear time and in place - is it possible to do both at once?\\n\\nI would say so; let\\'s consider the problem with a 1D array for simplicity first, assuming we have `{1,2,3,4,5,6,7}` as an array to shift by `4` positions. In order to do it linearly and in constant space, we can keep writing a value in its future place, keeping track of the previous value of the target slot and then repeat the operation over and over again with the value we stored.\\n\\nIn our example, we would have (the commented number is the one we store somewhere and write at the next round):\\n\\n```cpp\\n1 2 3 4 1 6 7 // 5\\n1 5 3 4 1 6 7 // 2\\n1 5 3 4 1 2 7 // 6\\n1 5 6 4 1 2 7 // 3\\n1 5 6 4 1 2 3 // 7\\n1 5 6 7 1 2 3 // 4\\n4 5 6 7 1 2 3 // 1\\n```\\n\\nA tricky part here is to notice that once the length of our array and `k` are not co-primes, we will have some loop that will NOT include all the elements as it happened before (try for example with `k` still equal to `4`, but with `8` elements to shift); we can easily fix it running our main shifting algorithm `gcd(nums.size(), k)` times, with a starting value of `0` and it will just work fine :)\\n\\nAnother optimisation trick might be to reduce `k` by the total of all the elements (shifting a grid of `100` elements by `100` will just give us the starting grid!) and, of course, to return the base grid itself for `k == 0`.\\n\\nNow, time to put all of this into code, first of all with a few support variables to help us:\\n* `w` and `h` will store the width (number of columns) and height (numbers of rows) of the grid, respectively;\\n* `tot`, computed as the product of the above variables, to store the overall number of elements;\\n* `target`, of type `div_t` (an object that will store `quot`ient and `rem`inder of a division with `div`), which will help us move later in our shifting/juggling logic.\\n\\nWe will then potentially reduce `k` to be the modulo of `tot`, and, in case it is `0`, directly `return` `grid`, as explained above.\\n\\nTime for our main loop, that will go with `i` as our starting point from `0` to `gcd(tot, k)` (excluded), using also `tmp` and `j` as loop variables; we will then:\\n* assign `i` as initial value to `j`;\\n* the result of `div(j, w)` to target, since we will have to convert our 1D example above to a 2D scenario, where each index will be converted to be the row number (`target.quot`) and the column number (`target.rem`) - in a grid of `3` rows and `4` columns, for example, the index `7` would give us `1` as a row number (the quotient) and `3` as column number (the reminder);\\n* get the initial value of `tmp`, taken as the `j`th element in our grid, using `target.quot` and `target.rem` as explained in the bullet point above;\\n* loop while`j != i` (but it is a do...while, so we will ignore the condition at the first run) and:\\n\\t* increase `j` by `k`;\\n\\t* check if `j` went over `tot`, in which case we will subtract it from `j` (which is basically equivalent of doing `j &= tot`, just way cheaper);\\n\\t* update `target` to be the current result of `div(j, w)`;\\n\\t* `swap` `tmp` and `grid[target.quot][target.rem]`.\\n\\nOnce done, we can just `return` `grid` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```\\n\\nAnd since I forgot about having solved this problem already, I came up with a slightly different solution today, that I prefer somehow a bit more; also, not using modulo boosted the speed significantly:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int maxX = grid[0].size(), maxY = grid.size(), tot = maxX * maxY, tmp;\\n        // normalising k\\n        k %= tot;\\n        // edge case\\n        if (!k) return grid;\\n        // main loop, running gcd(k, tot) times\\n        for (int i = 0, lmtI = gcd(k, tot), x, y; i < lmtI; i++) {\\n            // initialising pointers and starting value\\n            x = i, y = 0;\\n            while (x >= maxX) x -= maxX, y++;\\n            tmp = grid[y][x];\\n            // inner loop, advancing every k elements from i\\n            for (int j = 0, lmtJ = tot / lmtI; j < lmtJ; j++) {\\n                // advancing pointers\\n                x += k;\\n                while (x >= maxX) x -= maxX, y++;\\n                if (y >= maxY) y -= maxY;\\n                // updating values\\n                swap(tmp, grid[y][x]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```cpp\\n1 2 3 4 1 6 7 // 5\\n1 5 3 4 1 6 7 // 2\\n1 5 3 4 1 2 7 // 6\\n1 5 6 4 1 2 7 // 3\\n1 5 6 4 1 2 3 // 7\\n1 5 6 7 1 2 3 // 4\\n4 5 6 7 1 2 3 // 1\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        // support variables\\n        int maxX = grid[0].size(), maxY = grid.size(), tot = maxX * maxY, tmp;\\n        // normalising k\\n        k %= tot;\\n        // edge case\\n        if (!k) return grid;\\n        // main loop, running gcd(k, tot) times\\n        for (int i = 0, lmtI = gcd(k, tot), x, y; i < lmtI; i++) {\\n            // initialising pointers and starting value\\n            x = i, y = 0;\\n            while (x >= maxX) x -= maxX, y++;\\n            tmp = grid[y][x];\\n            // inner loop, advancing every k elements from i\\n            for (int j = 0, lmtJ = tot / lmtI; j < lmtJ; j++) {\\n                // advancing pointers\\n                x += k;\\n                while (x >= maxX) x -= maxX, y++;\\n                if (y >= maxY) y -= maxY;\\n                // updating values\\n                swap(tmp, grid[y][x]);\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 491883,
                "title": "python-3-in-one-line",
                "content": "# Explanation\\n\\nThere is a clear one-to-one mapping for every element in the grid to its new location. We just need to figure out that mapping.. it\\'s a bit of math involving modulo and division.\\n\\nFrom grid -> shifted location:\\n```\\nx := (x + k) % w\\ny := (y + ((x + k) / w)) % h\\n```\\nIn reverse, from shifted location -> original location:\\n```\\nx := (x - k) % w\\ny := (y - (((k - x - 1) / w) + 1)) % h\\n```\\nNote that in Python, `-1 % 3` is `2` and not `-1` like in Java / C / etc.\\n\\n# Two lines\\n\\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    h, w = len(grid), len(grid[0])\\n    return [[grid[(y - (((k - x - 1) // w) + 1)) % h][(x - k) % w] for x in range(w)] for y in range(h)]\\n```\\n\\n# One line\\n\\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    return [[grid[(y - (((k - x - 1) // len(grid[0])) + 1)) % len(grid)][(x - k) % len(grid[0])] for x in range(len(grid[0]))] for y in range(len(grid))]\\n```",
                "solutionTags": [],
                "code": "```\\nx := (x + k) % w\\ny := (y + ((x + k) / w)) % h\\n```\n```\\nx := (x - k) % w\\ny := (y - (((k - x - 1) / w) + 1)) % h\\n```\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    h, w = len(grid), len(grid[0])\\n    return [[grid[(y - (((k - x - 1) // w) + 1)) % h][(x - k) % w] for x in range(w)] for y in range(h)]\\n```\n```python\\nclass Solution:\\n  def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n    return [[grid[(y - (((k - x - 1) // len(grid[0])) + 1)) % len(grid)][(x - k) % len(grid[0])] for x in range(len(grid[0]))] for y in range(len(grid))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452350,
                "title": "straight-forward-c-with-linq",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var n = grid.Length;\\n        var m = grid[0].Length;\\n        var values = grid.SelectMany(x => x);\\n        var mod = k % (n * m);  \\n\\t\\t\\n        var flattened = values.Skip(n * m - mod).Concat(values.Take(n * m - mod));\\n        return Enumerable\\n            .Range(0, n)\\n            .Select(x => flattened.Skip(x * m).Take(m).ToList())\\n            .ToList<IList<int>>();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var n = grid.Length;\\n        var m = grid[0].Length;\\n        var values = grid.SelectMany(x => x);\\n        var mod = k % (n * m);  \\n\\t\\t\\n        var flattened = values.Skip(n * m - mod).Concat(values.Take(n * m - mod));\\n        return Enumerable\\n            .Range(0, n)\\n            .Select(x => flattened.Skip(x * m).Take(m).ToList())\\n            .ToList<IList<int>>();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432357,
                "title": "fast-java-with-reverse-function",
                "content": "Shift by k is equivalent with the following:\\n1. reverse whole array\\n2. reverse first subarray of k elements\\n3. reverse the remaining subarray\\n\\nCheck out similar question: https://leetcode.com/problems/rotate-array/\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n    \\n        int m = grid.length, n = grid[0].length;\\n        k = k % (m*n);\\n        int[] arr = new int[m*n];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                arr[i*n+j] = grid[i][j];\\n            }\\n        }\\n\\n        reverseArray(arr, 0, m*n-1);\\n        reverseArray(arr, 0, k-1);\\n        reverseArray(arr, k, m*n-1);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++){\\n            List<Integer> row = new ArrayList<>();\\n            for (int j = 0; j < n; j++){\\n                row.add(arr[i*n+j]);\\n            }\\n            res.add(row);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void reverseArray(int[] arr, int start, int end) {\\n        while (start < end) {\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n    \\n        int m = grid.length, n = grid[0].length;\\n        k = k % (m*n);\\n        int[] arr = new int[m*n];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                arr[i*n+j] = grid[i][j];\\n            }\\n        }\\n\\n        reverseArray(arr, 0, m*n-1);\\n        reverseArray(arr, 0, k-1);\\n        reverseArray(arr, k, m*n-1);\\n        \\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++){\\n            List<Integer> row = new ArrayList<>();\\n            for (int j = 0; j < n; j++){\\n                row.add(arr[i*n+j]);\\n            }\\n            res.add(row);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void reverseArray(int[] arr, int start, int end) {\\n        while (start < end) {\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516657,
                "title": "c-no-extra-memory-solution",
                "content": "This is slow, but if you want in-place (no extra memory), then this is viable solution.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int col = grid[0].size();\\n        int n = grid.size() * col;\\n\\n        k = k % n;\\n        if (k == 0) return grid;\\n\\n        while (k-- > 0) {\\n            int prev = grid[0][0];\\n            \\n            for (int i = 0; i < n-1; i++) {\\n                int idx = (i + 1) % n;\\n                int tmp = grid[idx / col][idx % col];\\n                grid[idx / col][idx % col] = prev;\\n                prev = tmp;\\n            }\\n    \\n            grid[0][0] = prev;\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int col = grid[0].size();\\n        int n = grid.size() * col;\\n\\n        k = k % n;\\n        if (k == 0) return grid;\\n\\n        while (k-- > 0) {\\n            int prev = grid[0][0];\\n            \\n            for (int i = 0; i < n-1; i++) {\\n                int idx = (i + 1) % n;\\n                int tmp = grid[idx / col][idx % col];\\n                grid[idx / col][idx % col] = prev;\\n                prev = tmp;\\n            }\\n    \\n            grid[0][0] = prev;\\n        }\\n\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099596,
                "title": "best-o-m-n-time-complexity-o-m-n-space-complexity-approach-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSeemed Truly Easy At First, Turned Out To Be Easier.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Approach Taken Is Explained Below :-\\n\\n(1) Initialise A Single Dimensional Array Of Size m*n and Pass Each Value Of The Matrix Sequentially Into The Single Dimensional Array.\\n\\n(2) Rotate The Array K Times Using The Following Algorithm :-\\n\\nStep (i) - Reverse The Entire Array\\nStep (ii) - Reverse The First K Elements (From Indexes 0 To K-1)\\nStep (iii) - Reverse The Rest of The Elements (From Indexes K To arr.length-1)\\n\\n(3) Store Each Element Of The Rotated Array In an ArrayList Of Size Equal To Number of Columns In Each Row. After Each Row, Pass The ArrayList Into an ArrayList<ArrayList<Integer>> Which Will Hold The Values Of All Rows Respectively.\\n\\n(4) Return The ArrayList<ArrayList<Integer>>.\\n\\nGood Luck!\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> Final_List=new ArrayList<List<Integer>>();\\n        k = k % (grid.length*grid[0].length);\\n        int[] arr=new int[grid.length*grid[0].length];\\n        int index=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                arr[index++]=grid[i][j];\\n            }\\n        }\\n        //Reverse The Entire Array\\n        reverseArray(arr,0,arr.length-1);\\n        //Reverse First K Elements\\n        reverseArray(arr,0,k-1);\\n        //Reverse Rest Elements\\n        reverseArray(arr,k,arr.length-1);\\n        int index1=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            ArrayList<Integer> list=new ArrayList<Integer>();\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                list.add(arr[index1++]);\\n            }\\n            Final_List.add(list);\\n        }\\n        return Final_List;\\n    }\\n    public static void reverseArray(int[] arr,int start, int end)\\n    {\\n        while(start<end)\\n        {\\n            int temp=arr[start];\\n            arr[start]=arr[end];\\n            arr[end]=temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> Final_List=new ArrayList<List<Integer>>();\\n        k = k % (grid.length*grid[0].length);\\n        int[] arr=new int[grid.length*grid[0].length];\\n        int index=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                arr[index++]=grid[i][j];\\n            }\\n        }\\n        //Reverse The Entire Array\\n        reverseArray(arr,0,arr.length-1);\\n        //Reverse First K Elements\\n        reverseArray(arr,0,k-1);\\n        //Reverse Rest Elements\\n        reverseArray(arr,k,arr.length-1);\\n        int index1=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            ArrayList<Integer> list=new ArrayList<Integer>();\\n            for(int j=0;j<grid[i].length;j++)\\n            {\\n                list.add(arr[index1++]);\\n            }\\n            Final_List.add(list);\\n        }\\n        return Final_List;\\n    }\\n    public static void reverseArray(int[] arr,int start, int end)\\n    {\\n        while(start<end)\\n        {\\n            int temp=arr[start];\\n            arr[start]=arr[end];\\n            arr[end]=temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937545,
                "title": "python-solution-using-simple-methods-just-8-lines",
                "content": "# Code\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(grid), len(grid[0])\\n        k%=n*m\\n        new_grid = [[False for j in range(m)] for i in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                i0, j0 = ((i*m+j+k)//m)%n, (i*m+j+k)%m\\n                new_grid[i0][j0]=grid[i][j]       \\n        return new_grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n, m = len(grid), len(grid[0])\\n        k%=n*m\\n        new_grid = [[False for j in range(m)] for i in range(n)]\\n        for i in range(n):\\n            for j in range(m):\\n                i0, j0 = ((i*m+j+k)//m)%n, (i*m+j+k)%m\\n                new_grid[i0][j0]=grid[i][j]       \\n        return new_grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720118,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; \\n                \\n                int newI=(i+(j+k)/m)%n; \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>> ans(n,vector<int>(m));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                int newJ=(j+k)%m; \\n                \\n                int newI=(i+(j+k)/m)%n; \\n                ans[newI][newJ]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937662,
                "title": "c-1-liner-just-for-fun",
                "content": "This is actually pretty efficient due to lazy evaluation, but admittingly not the most intuitive solution. Commented for readability.\\n\\n```cs\\npublic IList<IList<int>> ShiftGrid(int[][] grid, int k) => grid\\n    // flatten the grid to a list\\n    .SelectMany(x => x)\\n    // we need 2 lists and we are going to select a window of numbers\\n    .Concat(grid.SelectMany(x => x))\\n    // calculate the offset of charcters to skip\\n    .Skip(grid.Length * grid[0].Length - k % (grid.Length * grid[0].Length))\\n    // chunk the flat list into rows\\n    .Chunk(grid[0].Length)\\n    // the number of rows should be unchanged\\n    .Take(grid.Length)\\n    // we need a type compatiable with IList\\n    .ToArray();\\n```\\n\\nCheck out my other C# 1-liners!\\n* https://leetcode.com/discuss/general-discussion/2905237/c-sharp-1-liners",
                "solutionTags": [],
                "code": "```cs\\npublic IList<IList<int>> ShiftGrid(int[][] grid, int k) => grid\\n    // flatten the grid to a list\\n    .SelectMany(x => x)\\n    // we need 2 lists and we are going to select a window of numbers\\n    .Concat(grid.SelectMany(x => x))\\n    // calculate the offset of charcters to skip\\n    .Skip(grid.Length * grid[0].Length - k % (grid.Length * grid[0].Length))\\n    // chunk the flat list into rows\\n    .Chunk(grid[0].Length)\\n    // the number of rows should be unchanged\\n    .Take(grid.Length)\\n    // we need a type compatiable with IList\\n    .ToArray();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936825,
                "title": "kotlin-beats-98-april-2022",
                "content": "\\n\\tclass Solution {\\n    \\n\\tfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n\\t\\n\\t\\tval result = MutableList(grid.size) { MutableList<Int>(grid[0].size) { 0 } } \\n\\t\\t\\n        for (i in grid.indices) { \\n            for (j in grid[0].indices) {\\n                val n = (i + (j + k) / grid[0].size) % grid.size\\n                val m = (j + k) % grid[0].size\\n\\n                result[n][m] = grid[i][j]\\n            }\\n        }\\n        \\n        return result\\n    }\\n\\t}",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "class Solution {\\n    \\n\\tfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n\\t\\n\\t\\tval result = MutableList(grid.size) { MutableList<Int>(grid[0].size) { 0 }",
                "codeTag": "Java"
            },
            {
                "id": 1936818,
                "title": "c-29ms-faster-than-80-easy-solution",
                "content": "I just created a vector and stored all values of matrix in that vector.\\n\\n        vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n\\t\\t\\nThen I create a int x from which the values to be filled in matrix from the vector.\\n\\t\\t\\n        int x;\\n        if(k<=ans.size())\\n             x = ans.size()-k;\\n        else \\n            x = ans.size()-(k%ans.size());\\n\\t\\t\\t\\nNow just filling values from vector to matrix(grid).\\nand if x>=vector size\\nx=0;\\n\\t\\t\\t\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(x>=ans.size())\\n                    x=0;\\n                grid[i][j] = ans[x];\\n                x++;\\n                \\n            }\\n                  \\n        }\\n        return grid;\\n    }",
                "solutionTags": [
                    "Array",
                    "Matrix"
                ],
                "code": "I just created a vector and stored all values of matrix in that vector.\\n\\n        vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n\\t\\t\\nThen I create a int x from which the values to be filled in matrix from the vector.\\n\\t\\t\\n        int x;\\n        if(k<=ans.size())\\n             x = ans.size()-k;\\n        else \\n            x = ans.size()-(k%ans.size());\\n\\t\\t\\t\\nNow just filling values from vector to matrix(grid).\\nand if x>=vector size\\nx=0;\\n\\t\\t\\t\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(x>=ans.size())\\n                    x=0;\\n                grid[i][j] = ans[x];\\n                x++;\\n                \\n            }\\n                  \\n        }\\n        return grid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1936444,
                "title": "c",
                "content": "![image](https://assets.leetcode.com/users/images/924e5ed5-c56a-4f93-bfd3-5cad4ddedd6a_1649685169.9793317.png)\\n\\n```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes) {\\n    int RowSize = gridSize, ColSize = gridColSize[0], totalSize = RowSize * ColSize, shift = k % totalSize;\\n    *returnSize = gridSize;\\n    *returnColumnSizes = gridColSize;\\n    if(shift == 0) return grid;\\n    \\n    int arridx = 0;\\n    int* arr = (int*) malloc(2 * totalSize * sizeof(int));\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            arr[arridx] = grid[i][j];\\n            arr[arridx + totalSize] = grid[i][j];\\n            arridx++;\\n        }\\n    }\\n    \\n    arridx = totalSize - shift;\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            grid[i][j] = arr[arridx];\\n            arridx++;\\n        }\\n    }\\n    free(arr);\\n    return grid;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes) {\\n    int RowSize = gridSize, ColSize = gridColSize[0], totalSize = RowSize * ColSize, shift = k % totalSize;\\n    *returnSize = gridSize;\\n    *returnColumnSizes = gridColSize;\\n    if(shift == 0) return grid;\\n    \\n    int arridx = 0;\\n    int* arr = (int*) malloc(2 * totalSize * sizeof(int));\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            arr[arridx] = grid[i][j];\\n            arr[arridx + totalSize] = grid[i][j];\\n            arridx++;\\n        }\\n    }\\n    \\n    arridx = totalSize - shift;\\n    for(int i = 0; i < RowSize; i++) {\\n        for(int j = 0; j < ColSize; j++) {\\n            grid[i][j] = arr[arridx];\\n            arridx++;\\n        }\\n    }\\n    free(arr);\\n    return grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936378,
                "title": "c-solution-runtime-160-ms-faster-than-96-00-of-c-online-submissions",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        if (k % (n*m) == 0) return grid;\\n        \\n        var result = new int[m][];\\n        for (var i=0; i<m; i++) result[i] = new int[n];\\n        var mn = m*n;\\n        for (var i=0; i < mn; i++) {\\n            var c = (i + k) % mn;\\n            result[c/n][c%n] = grid[i/n][i%n];\\n        }        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        if (k % (n*m) == 0) return grid;\\n        \\n        var result = new int[m][];\\n        for (var i=0; i<m; i++) result[i] = new int[n];\\n        var mn = m*n;\\n        for (var i=0; i < mn; i++) {\\n            var c = (i + k) % mn;\\n            result[c/n][c%n] = grid[i/n][i%n];\\n        }        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936052,
                "title": "c-time-o-n-space-o-1-explanation",
                "content": "The final solution is here. \\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>>& shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        int r = gcd(n,k);\\n        for(int i = 0; i<r;i++) {\\n            int temp = grid[i/cols][i%cols];\\n            int curr_idx = i;\\n            for(int j = 0;j<n/r;j++) {\\n                int next_idx = (curr_idx+k)%n;\\n                int prev_temp = temp;\\n                temp = grid[next_idx/cols][next_idx%cols];\\n                grid[next_idx/cols][next_idx%cols] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        } \\n        return grid;\\n    }    \\n};\\n```\\nspace complexity O (1), time complexity O(N).  \\nN is mean rows * cols  here. \\n\\n# Explanation\\n\\nThe above solution is optimized from following code\\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> answer1(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> ans = grid;\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        for(int curr = 0; curr < n;curr++) { \\n            int next = (curr+k)%n;\\n            ans[next/cols][next%cols]= grid[curr/cols][curr%cols];\\n        }\\n        return ans;\\n    } \\n};\\n```\\nThis code using time O(N) and space O(N). \\nAnd the idea of this code is to represent two dimension into one dimension array. \\nProcess it in. one dimension array and problem become easy. \\n\\nAnd this is a rorate array problem now. \\nThen we need to optimize this solution from this article\\nhttps://leetcode.com/problems/rotate-array/discuss/1729976/C%2B%2B-or-O(N)-or-GCD\\nIn this article, it solve rorate array problem by this way. \\n```C++\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int rows = gcd(n, k);\\n        for(int i = 0; i < rows; i++) {\\n            int temp = nums[i];\\n            int curr_idx = i;                \\n            for(int j = 0 ; j < n / rows; j++) {\\n                int next_idx = (curr_idx + k) % n;\\n                int prev_temp = temp;\\n                temp = nums[next_idx];\\n                nums[next_idx] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        }   \\n    }\\n};\\n```\\nThen I adjust this code to become our solution.  \\nThat\\'s how I solve this problem in Time O(N) & Space O(1) in the final solution.\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>>& shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        int r = gcd(n,k);\\n        for(int i = 0; i<r;i++) {\\n            int temp = grid[i/cols][i%cols];\\n            int curr_idx = i;\\n            for(int j = 0;j<n/r;j++) {\\n                int next_idx = (curr_idx+k)%n;\\n                int prev_temp = temp;\\n                temp = grid[next_idx/cols][next_idx%cols];\\n                grid[next_idx/cols][next_idx%cols] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        } \\n        return grid;\\n    }    \\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    vector<vector<int>> answer1(vector<vector<int>>& grid, int k) {\\n        vector<vector<int>> ans = grid;\\n        int rows = grid.size(), cols = grid[0].size(), n = rows*cols; \\n        for(int curr = 0; curr < n;curr++) { \\n            int next = (curr+k)%n;\\n            ans[next/cols][next%cols]= grid[curr/cols][curr%cols];\\n        }\\n        return ans;\\n    } \\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int rows = gcd(n, k);\\n        for(int i = 0; i < rows; i++) {\\n            int temp = nums[i];\\n            int curr_idx = i;                \\n            for(int j = 0 ; j < n / rows; j++) {\\n                int next_idx = (curr_idx + k) % n;\\n                int prev_temp = temp;\\n                temp = nums[next_idx];\\n                nums[next_idx] = prev_temp;\\n                curr_idx = next_idx;\\n            }\\n        }   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935848,
                "title": "convert-grid-into-1d-list-and-then-make-it-simpler",
                "content": "class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> temp=new ArrayList<>();\\n        \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                temp.add(grid[i][j]);\\n            }\\n        }\\n        Collections.rotate(temp,k);\\n        \\n        for(int j=0;j<m*n;j+=n){\\n            List<Integer> my=new ArrayList<>();\\n            for(int p=j;p<j+n;p++){\\n                my.add(temp.get(p));\\n            }\\n            ans.add(my);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> temp=new ArrayList<>();\\n        \\n        int m=grid.length;\\n        int n=grid[0].length;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                temp.add(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1935176,
                "title": "c-easy-understanding",
                "content": "\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int x) {\\n        int n=grid.size();\\n        int m=grid[0].size();        \\n        for(int k=0;k<x;k++){\\n            int temp;\\n            for (int i=n-1;i>=0;i--){\\n                for(int j=m-1;j>=0;j--){\\n                    if(i==n-1 && j==m-1) temp=grid[i][j];\\n                    else if(j==m-1){\\n                        grid[i+1][0]=grid[i][j];\\n                    }\\n                    else{\\n                        grid[i][j+1]=grid[i][j];\\n                    }\\n                }\\n            }\\n            grid[0][0]=temp;\\n        }\\n        \\n        return grid;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int x) {\\n        int n=grid.size();\\n        int m=grid[0].size();        \\n        for(int k=0;k<x;k++){\\n            int temp;\\n            for (int i=n-1;i>=0;i--){\\n                for(int j=m-1;j>=0;j--){\\n                    if(i==n-1 && j==m-1) temp=grid[i][j];\\n                    else if(j==m-1){\\n                        grid[i+1][0]=grid[i][j];\\n                    }\\n                    else{\\n                        grid[i][j+1]=grid[i][j];\\n                    }\\n                }\\n            }\\n            grid[0][0]=temp;\\n        }\\n        \\n        return grid;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1934883,
                "title": "javascript",
                "content": "```\\nvar shiftGrid = function(g, k, arr1=[],arr2=[],arr3=[], res=[]) {\\n    arr1=g.flat()\\n    k=k%arr1.length\\n    arr2=arr1.splice(-k,k)\\n    arr3=[...arr2, ...arr1]\\n    for(let q=0;q<g.length;q++){\\n        res.push(arr3.splice(0,g[0].length))\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(g, k, arr1=[],arr2=[],arr3=[], res=[]) {\\n    arr1=g.flat()\\n    k=k%arr1.length\\n    arr2=arr1.splice(-k,k)\\n    arr3=[...arr2, ...arr1]\\n    for(let q=0;q<g.length;q++){\\n        res.push(arr3.splice(0,g[0].length))\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 756166,
                "title": "python3-simple-solution-linear-index-to-array-index",
                "content": "class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        # figure out the number of rows and columns, m by n\\n        m = len(grid)\\n        n = len(grid[0])\\n        tot_len = m * n\\n        # new grid\\n        new_grid = [[0 for i in range(n)] for j in range(m)]\\n        # \\n        for i in range(tot_len):\\n            new_linear_index = (i + k) % (tot_len)\\n            new_row_index, new_column_index = divmod(new_linear_index, n)\\n            old_row_index, old_column_index = divmod(i, n)\\n            new_grid[new_row_index][new_column_index] = grid[old_row_index][old_column_index]\\n        return(new_grid)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        # figure out the number of rows and columns, m by n\\n        m = len(grid)\\n        n = len(grid[0])\\n        tot_len = m * n\\n        # new grid\\n        new_grid = [[0 for i in range(n)] for j in range(m)]\\n        # \\n        for i in range(tot_len):\\n            new_linear_index = (i + k) % (tot_len)\\n            new_row_index, new_column_index = divmod(new_linear_index, n)\\n            old_row_index, old_column_index = divmod(i, n)\\n            new_grid[new_row_index][new_column_index] = grid[old_row_index][old_column_index]\\n        return(new_grid)",
                "codeTag": "Java"
            },
            {
                "id": 529823,
                "title": "1260-javascript-solution-with-comments",
                "content": "I tried *other* ways of doing it, but none of them seemed really *better*.\\n\\nThis isn\\'t a 1-line solution, but each operation in the solution is only 1 line.\\n\\n> Runtime: **92 ms**, faster than *100.00%* of JavaScript online submissions\\n> Memory Usage: **45.3 MB**, less than *35.62%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nconst shiftGrid = (grid, k) => {\\n  // Store the width and the height of the grid\\n  const [w, h] = [grid[0].length, grid.length];\\n  // Calculate the total items in the grid\\n  const t = w * h;\\n  // Use the total to avoid extraneous whole-grid shifts\\n  k %= t;\\n  // Flatten the grid for easy shifting\\n  const flattened = grid.flat();\\n  // Shift the grid using slice for speed\\n  const sFlattened = [...flattened.slice(-k), ...flattened.slice(0, -k)];\\n  // Make a new two-dimensional shifted grid\\n  const shifted = []; // The second dimension is added on the next line\\n  // Store the flat shifted grid in the new two-dimensional shifted grid\\n  for (let i = 0; i < t; i += w) shifted.push(sFlattened.slice(i, i + w));\\n  // Return the new two-dimensional shifted grid\\n  return shifted;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nconst shiftGrid = (grid, k) => {\\n  // Store the width and the height of the grid\\n  const [w, h] = [grid[0].length, grid.length];\\n  // Calculate the total items in the grid\\n  const t = w * h;\\n  // Use the total to avoid extraneous whole-grid shifts\\n  k %= t;\\n  // Flatten the grid for easy shifting\\n  const flattened = grid.flat();\\n  // Shift the grid using slice for speed\\n  const sFlattened = [...flattened.slice(-k), ...flattened.slice(0, -k)];\\n  // Make a new two-dimensional shifted grid\\n  const shifted = []; // The second dimension is added on the next line\\n  // Store the flat shifted grid in the new two-dimensional shifted grid\\n  for (let i = 0; i < t; i += w) shifted.push(sFlattened.slice(i, i + w));\\n  // Return the new two-dimensional shifted grid\\n  return shifted;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 437060,
                "title": "python-o-1-space-rotate-virtual-1d-array",
                "content": "Assuming you already know how to rotate a 1D array by \"k\" steps in O(1) space:\\n1. Swap all elements on the left side: arr[:k], \\n2. Swap all element on the right side: arr[k:]\\n3. Swap all element in the whole array: arr[::]\\n\\nThis problem is 2D array, not 1D array. But we can solve it the same way as 1D array, just by presenting the 2D array as a \"virtual\" 1D array.\\n\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n=len(grid)\\n        m=len(grid[0]) if grid else 0\\n        nm=n*m\\n        k=-k%nm\\n        def getAt(i):\\n            x,y=divmod(i,m)\\n            return grid[x][y]\\n        def setAt(i,v):\\n            x,y=divmod(i,m)\\n            grid[x][y]=v\\n        def reverse(start,end):\\n            for i in range((end-start+1)//2):\\n                a=getAt(start+i)\\n                setAt(start+i,getAt(end-i))\\n                setAt(end-i,a)\\n        reverse(0,k-1)\\n        reverse(k,nm-1)\\n        reverse(0,nm-1)\\n        return grid\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n=len(grid)\\n        m=len(grid[0]) if grid else 0\\n        nm=n*m\\n        k=-k%nm\\n        def getAt(i):\\n            x,y=divmod(i,m)\\n            return grid[x][y]\\n        def setAt(i,v):\\n            x,y=divmod(i,m)\\n            grid[x][y]=v\\n        def reverse(start,end):\\n            for i in range((end-start+1)//2):\\n                a=getAt(start+i)\\n                setAt(start+i,getAt(end-i))\\n                setAt(end-i,a)\\n        reverse(0,k-1)\\n        reverse(k,nm-1)\\n        reverse(0,nm-1)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431163,
                "title": "c-brute-force-o-k-m-n-by-storing-prev",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int K) {\\n        for(int k = 0; k < K; k++) {\\n            int n = grid.size(), m = grid[0].size();\\n            int prev = grid[0][0]; grid[0][0] = grid[n - 1][m - 1];\\n            for(int i = 0; i < n; i++) {\\n                for(int j = 0; j < m; j++) {\\n                    if(i == 0 && j == 0)\\n                        continue;\\n                    int temp = grid[i][j];\\n                    grid[i][j] = prev;\\n                    prev = temp;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int K) {\\n        for(int k = 0; k < K; k++) {\\n            int n = grid.size(), m = grid[0].size();\\n            int prev = grid[0][0]; grid[0][0] = grid[n - 1][m - 1];\\n            for(int i = 0; i < n; i++) {\\n                for(int j = 0; j < m; j++) {\\n                    if(i == 0 && j == 0)\\n                        continue;\\n                    int temp = grid[i][j];\\n                    grid[i][j] = prev;\\n                    prev = temp;\\n                }\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848373,
                "title": "easiest-solution-c-plusplus-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n        while(k--){\\n            int a = ans.back();\\n            ans.pop_back();\\n            ans.insert(ans.begin(),a);\\n        }\\n        int ind = 0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=ans[ind++];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> ans;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n        while(k--){\\n            int a = ans.back();\\n            ans.pop_back();\\n            ans.insert(ans.begin(),a);\\n        }\\n        int ind = 0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=ans[ind++];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658087,
                "title": "js-very-easy-solution",
                "content": "```\\nvar shiftGrid = function(grid, k) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    const move = (grid) => {\\n        for (let i = 0; i < m; i++) {\\n            const current = [];\\n            for (let j = 0; j < n; j++) {\\n                current[j] = grid[i][j];\\n                grid[i][j] = j === 0 ? grid[i][n - 1] : current[j - 1];\\n            }\\n        }\\n        \\n        const current = [];\\n        for (let i = 0; i < m; i++) {\\n            current[i] = grid[i][0];\\n            grid[i][0] = i === 0 ? grid[m - 1][0] : current[i - 1];\\n        }\\n    }\\n    \\n    for (let i = 1; i <= k; i++) {\\n        move(grid);\\n    }\\n    \\n    return grid;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(grid, k) {\\n    const m = grid.length;\\n    const n = grid[0].length;\\n\\n    const move = (grid) => {\\n        for (let i = 0; i < m; i++) {\\n            const current = [];\\n            for (let j = 0; j < n; j++) {\\n                current[j] = grid[i][j];\\n                grid[i][j] = j === 0 ? grid[i][n - 1] : current[j - 1];\\n            }\\n        }\\n        \\n        const current = [];\\n        for (let i = 0; i < m; i++) {\\n            current[i] = grid[i][0];\\n            grid[i][0] = i === 0 ? grid[m - 1][0] : current[i - 1];\\n        }\\n    }\\n    \\n    for (let i = 1; i <= k; i++) {\\n        move(grid);\\n    }\\n    \\n    return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937545,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int i=grid.size();\\n        int j=grid[i-1].size();\\n        while(k--){\\n            int last_element=grid[i-1][j-1];\\n            for(int a=i-1;a>=0;a--){\\n                for(int b=j-1;b>=0;b--){\\n                    \\n                    if(a==0&&b==0)\\n                        grid[a][b]=last_element;\\n                    else if(b==0)\\n                        grid[a][b]=grid[a-1][j-1];\\n                    else\\n                        grid[a][b]=grid[a][b-1];\\n                }\\n            }\\n        }\\n        return grid;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int i=grid.size();\\n        int j=grid[i-1].size();\\n        while(k--){\\n            int last_element=grid[i-1][j-1];\\n            for(int a=i-1;a>=0;a--){\\n                for(int b=j-1;b>=0;b--){\\n                    \\n                    if(a==0&&b==0)\\n                        grid[a][b]=last_element;\\n                    else if(b==0)\\n                        grid[a][b]=grid[a-1][j-1];\\n                    else\\n                        grid[a][b]=grid[a][b-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1937314,
                "title": "c-simple-solution",
                "content": "```\\n void op(vector<vector<int>>& grid){\\n    for(int i=0;i<grid.size();i++){\\n        swap(grid[i][0],grid[i][grid[0].size()-1]);\\n    }\\n  \\n    for(int j=grid[0].size()-1;j>=2;j--){\\n        \\n        for(int i=0;i<grid.size();i++){\\n            swap(grid[i][j],grid[i][j-1]);\\n        }\\n    }\\n        \\n    for(int i=grid.size()-1;i>=1;i--){\\n        swap(grid[i][0],grid[i-1][0]);\\n    }\\n        \\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        for(int j=0;j<k;j++){\\n            op(grid);\\n        }\\n        \\n        return grid;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n void op(vector<vector<int>>& grid){\\n    for(int i=0;i<grid.size();i++){\\n        swap(grid[i][0],grid[i][grid[0].size()-1]);\\n    }\\n  \\n    for(int j=grid[0].size()-1;j>=2;j--){\\n        \\n        for(int i=0;i<grid.size();i++){\\n            swap(grid[i][j],grid[i][j-1]);\\n        }\\n    }\\n        \\n    for(int i=grid.size()-1;i>=1;i--){\\n        swap(grid[i][0],grid[i-1][0]);\\n    }\\n        \\n    }\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        for(int j=0;j<k;j++){\\n            op(grid);\\n        }\\n        \\n        return grid;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937282,
                "title": "python-super-simple-solution",
                "content": "Here is a simple intuitve implementation of mine. **Upvote** if you find this helpful.\\nI am looking to make it more efficient, any suggestions?\\n\\n```class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for foo in range(k):\\n            for i in range(len(grid)-1):\\n                grid[i+1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop(-1))\\n        return(grid)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Here is a simple intuitve implementation of mine. **Upvote** if you find this helpful.\\nI am looking to make it more efficient, any suggestions?\\n\\n```class Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for foo in range(k):\\n            for i in range(len(grid)-1):\\n                grid[i+1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop(-1))\\n        return(grid)",
                "codeTag": "Java"
            },
            {
                "id": 1937050,
                "title": "two-js-solutions",
                "content": "1. Flatten the matrix and move k elements from the back to the front\\n```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.splice(0, 0, ...nums.slice(nums.length - k, nums.length));\\n\\tnums.splice(-k, k);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n```\\n2. Flatten and reverse the array, reverse the first k elements, and then reverse the rest\\n```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.reverse();\\n\\treverse(nums, 0, k - 1);\\n\\treverse(nums, k, nums.length - 1);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n\\nfunction reverse(arr, start, end) {\\n\\twhile (start <= end) {\\n\\t\\tconst temp = arr[start];\\n\\t\\tarr[start] = arr[end];\\n\\t\\tarr[end] = temp;\\n\\t\\tstart++;\\n\\t\\tend--;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.splice(0, 0, ...nums.slice(nums.length - k, nums.length));\\n\\tnums.splice(-k, k);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n```\n```\\nconst shiftGrid = function (grid, k) {\\n\\tconst m = grid.length,\\n\\t\\tn = grid[0].length,\\n\\t\\tnums = grid.flat();\\n\\tk = k % nums.length;\\n\\tnums.reverse();\\n\\treverse(nums, 0, k - 1);\\n\\treverse(nums, k, nums.length - 1);\\n\\tlet i = 0;\\n\\twhile (nums.length) grid[i++] = nums.splice(0, n);\\n\\treturn grid;\\n};\\n\\nfunction reverse(arr, start, end) {\\n\\twhile (start <= end) {\\n\\t\\tconst temp = arr[start];\\n\\t\\tarr[start] = arr[end];\\n\\t\\tarr[end] = temp;\\n\\t\\tstart++;\\n\\t\\tend--;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936979,
                "title": "extremely-easy-and-clean-code-c-recursive",
                "content": "[](http://)\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        if(k == 0)\\n            return grid;\\n        \\n        int temp = INT_MAX;\\n        \\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                swap(temp, grid[i][j]);\\n            }\\n        }\\n        \\n        swap(temp, grid[0][0]);\\n        \\n        return shiftGrid(grid, k - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        \\n        if(k == 0)\\n            return grid;\\n        \\n        int temp = INT_MAX;\\n        \\n        for(int i = 0;i < m;i++){\\n            for(int j = 0;j < n;j++){\\n                swap(temp, grid[i][j]);\\n            }\\n        }\\n        \\n        swap(temp, grid[0][0]);\\n        \\n        return shiftGrid(grid, k - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936822,
                "title": "c-with-diagram-simple-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n       \\n        if(k==row*col || k==0){\\n            return grid;\\n        }\\n        \\n        \\n        int last;\\n        int temp;\\n        while(k--){\\n            last = grid[row-1][col-1];\\n            for(int i=0;i<row;i++){\\n                temp=grid[i][col-1];\\n                for(int j=col-1;j>0;j--){\\n                    grid[i][j]=grid[i][j-1];\\n                }\\n                grid[i][0]=last;\\n                last=temp;\\n            }\\n            \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/8ac1f774-8ece-41ea-be5b-7f6ddfa9a71a_1649693338.3010826.png)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n       \\n        if(k==row*col || k==0){\\n            return grid;\\n        }\\n        \\n        \\n        int last;\\n        int temp;\\n        while(k--){\\n            last = grid[row-1][col-1];\\n            for(int i=0;i<row;i++){\\n                temp=grid[i][col-1];\\n                for(int j=col-1;j>0;j--){\\n                    grid[i][j]=grid[i][j-1];\\n                }\\n                grid[i][0]=last;\\n                last=temp;\\n            }\\n            \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936721,
                "title": "c-simple-clean-code-with-explanation",
                "content": "\\n1. Convert (row,col) into 1d array. `index =  (currRow * number of elements in each column + currentColum)`\\n2. Now add k to index and mod it by number of elements in matrix to avoid going out of bounds. `index = (index + k) % (no of rows * no of cols)`\\n3. now we have calculated the index, we just have to convert this index to (row,col) format. `newRow = (index / no of columns)`\\nand `newCol = (index %  no of columns)`\\n4. now copy (row,col) to (newRow,newCol).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        k = k % (n * m);\\n        int counter = 0;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int index = m * i + j;\\n                \\n                int shiftedPosition = (index + k)%(m*n);\\n                \\n                int row = (shiftedPosition/m);\\n                int col = (shiftedPosition % m);\\n                ans[row][col] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nTime Complexity = O(n * m)\\nSpace Complexity = O(n * m)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        k = k % (n * m);\\n        int counter = 0;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int index = m * i + j;\\n                \\n                int shiftedPosition = (index + k)%(m*n);\\n                \\n                int row = (shiftedPosition/m);\\n                int col = (shiftedPosition % m);\\n                ans[row][col] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936433,
                "title": "c-easy-solution-explaining-similar-to-1-d-shifting-clean-code-with-explanation",
                "content": "**Solution using 1-D array Rotation Tricks in the 2-D Like we Did in *Search in 2-D Matrix* (Binary Search Solution)**\\n\\n**TC :** ***O(n x m)***\\n**SC :** ***O(1)***\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid. size(), m = grid[0].size();\\n        vector<vector<int>> resGrid(n,vector<int> (m));\\n        int total = n * m; //total distance we need to move is this\\n        for(int i = 0; i< total ; i++){\\n          int row = i/m, col = i%m;//easy trick to find indices via 1-D array trick in 2-D arrays\\n\\t\\t  \\n         /*now if the value shifts to the k times then for K > N*M we need to do k  % total \\n\\t\\t taking example of K = 3 and n = 3 , m= 3 then for index (i = 8) in 1-D \\n\\t\\t will equal to (i = 8+3 =11) which crosses the n*m(total) so for preventing this rotation we do modulo */\\n            \\n\\t\\t\\tint shift = (i+k)%total;  /*this is the final place (for 1-D representation where value need to \\n\\t\\t\\tbe shift now this the index in 1-D representationnow again we need to \\n\\t\\t\\tfind the right index for 2-D grid via 1-D array using same operation as we did above)*/\\n            int newRow = shift/m , newCol = shift%m;\\n\\t\\t\\t\\n\\t\\t\\t//put these values after shifting into the grid\\n            resGrid[newRow][newCol] = grid[row][col];\\n        }\\n        return resGrid;\\n    }\\n};\\n```\\n\\n**Please UPVOTE If you Like the Clear Solution With Simple Explained Intuition**\\n\\n***Thank You***\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid. size(), m = grid[0].size();\\n        vector<vector<int>> resGrid(n,vector<int> (m));\\n        int total = n * m; //total distance we need to move is this\\n        for(int i = 0; i< total ; i++){\\n          int row = i/m, col = i%m;//easy trick to find indices via 1-D array trick in 2-D arrays\\n\\t\\t  \\n         /*now if the value shifts to the k times then for K > N*M we need to do k  % total \\n\\t\\t taking example of K = 3 and n = 3 , m= 3 then for index (i = 8) in 1-D \\n\\t\\t will equal to (i = 8+3 =11) which crosses the n*m(total) so for preventing this rotation we do modulo */\\n            \\n\\t\\t\\tint shift = (i+k)%total;  /*this is the final place (for 1-D representation where value need to \\n\\t\\t\\tbe shift now this the index in 1-D representationnow again we need to \\n\\t\\t\\tfind the right index for 2-D grid via 1-D array using same operation as we did above)*/\\n            int newRow = shift/m , newCol = shift%m;\\n\\t\\t\\t\\n\\t\\t\\t//put these values after shifting into the grid\\n            resGrid[newRow][newCol] = grid[row][col];\\n        }\\n        return resGrid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935977,
                "title": "python-fastest-solution-using-simple-mathematical-formulation-o-n-m-time",
                "content": "Please UPVOTE if you LIKE! \\uD83D\\uDE01 This solution beats 100% of the approaches submitted till now.\\n\\nI have provided hints for you to try it out once more. Please do so if you have time. Hints:\\n1) Is there a repetition in your code based on \"k\"? How would you simplify this? Try to find out the pattern there.\\n2) Once you remove the repetition, Can you simplify the next process by creating some mathematical formula.\\n\\nI hope you have tried the problem once more before looking at the below solution. \\nThere are two critical steps to look for here. let m = num of columns, n = num of rows\\n1) If K >= m that means you can simply the problem by doing row transformation depending on k//m\\n2) Now for k % m, you can simply open up the matrix and rotate the list by k and then again convert it into matrix. For example, suppose k%m = 3 and matrix is [ [ 1,2,3,4], [5,6,7,8], [9,10,11,12] ] then opening the list would be like [1,2,3,4,5,6,7,8,9,10,11,12 ] and then rotate the list would result this list to become [10,11,12,1,2,3,4,5,6,7,8,9] and again convert it into matrix like this [ [10,11,12,1], [2,3,4,5], [6,7,8,9] ].\\n\\nWorking code is as follows:\\n\\n\\n\\tdef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        row_trans = k // m\\n        for i in range(row_trans):\\n            grid = [ grid[n-1] ] + grid[:n-1]\\n        \\n        k = k % m\\n        \\n        arr = [ grid[i][j] for i in range(n) for j in range(m)]\\n        \\n        arr = arr[-k:] + arr[:-k]\\n        grid = []\\n        for i in range(n):\\n            grid.append(arr[m*i:m*(i+1)])\\n        return grid\\n\\nIf you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "Please UPVOTE if you LIKE! \\uD83D\\uDE01 This solution beats 100% of the approaches submitted till now.\\n\\nI have provided hints for you to try it out once more. Please do so if you have time. Hints:\\n1) Is there a repetition in your code based on \"k\"? How would you simplify this? Try to find out the pattern there.\\n2) Once you remove the repetition, Can you simplify the next process by creating some mathematical formula.\\n\\nI hope you have tried the problem once more before looking at the below solution. \\nThere are two critical steps to look for here. let m = num of columns, n = num of rows\\n1) If K >= m that means you can simply the problem by doing row transformation depending on k//m\\n2) Now for k % m, you can simply open up the matrix and rotate the list by k and then again convert it into matrix. For example, suppose k%m = 3 and matrix is [ [ 1,2,3,4], [5,6,7,8], [9,10,11,12] ] then opening the list would be like [1,2,3,4,5,6,7,8,9,10,11,12 ] and then rotate the list would result this list to become [10,11,12,1,2,3,4,5,6,7,8,9] and again convert it into matrix like this [ [10,11,12,1], [2,3,4,5], [6,7,8,9] ].\\n\\nWorking code is as follows:\\n\\n\\n\\tdef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        n = len(grid)\\n        m = len(grid[0])\\n        \\n        row_trans = k // m\\n        for i in range(row_trans):\\n            grid = [ grid[n-1] ] + grid[:n-1]\\n        \\n        k = k % m\\n        \\n        arr = [ grid[i][j] for i in range(n) for j in range(m)]\\n        \\n        arr = arr[-k:] + arr[:-k]\\n        grid = []\\n        for i in range(n):\\n            grid.append(arr[m*i:m*(i+1)])\\n        return grid\\n\\nIf you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1935716,
                "title": "c-vector-push-pop-simple-solution-explained",
                "content": "1. `` First of all I just convert the matrix into a linear vector``\\n2. `` Then the last element have inserted into the first position of the vector and poped out the last element from it``\\n3. `` Then again have made the matrix from the vector and returned it``\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int mod = row*col;\\n        vector<int>vec;\\n        \\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                vec.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        for(int i=0; i<k%mod; i++){\\n            vec.insert(vec.begin(), vec.back());\\n            vec.pop_back();\\n        }\\n        int x=0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = vec[x++];\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int mod = row*col;\\n        vector<int>vec;\\n        \\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                vec.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        for(int i=0; i<k%mod; i++){\\n            vec.insert(vec.begin(), vec.back());\\n            vec.pop_back();\\n        }\\n        int x=0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = vec[x++];\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1935669,
                "title": "c-simple-observation-based-solution-with-explanation",
                "content": "To solve this question we required two observations.\\n**Observation 1:-** If k is linear multiple of row(r in code) and column(c in code) than we get initial grid after shifting.Means answer after k shift=answer after k%(r*c).\\n**Observation 2:-**  At every n * c shifting(linear multiple of length of column) , we are shifting  whole row with other row.\\n\\nAfter these two observations only column shifting is remain.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //for number of raw\\n        int r=grid.size();\\n\\t\\t\\n        //for number of column\\n        int c=grid[0].size();\\n        \\n        //to make the copy of the grid\\n        vector<vector<int>>ans=grid;\\n        \\n        k=k%(r*c);//by observation 1\\n        \\n        //to calculate the number of row shift required.\\n        int r_shift=k/c;\\n        \\n        //to calculate the total column shift required .\\n        int c_shift=k%c;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            grid[(i+r_shift)%r]=ans[i];//row shift by observation 2.\\n        }\\n        \\n        ans=grid;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                grid[(i+(j+c_shift)/c)%r][(j+c_shift)%c]=ans[i][j];//coloumn shift.\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n//If you like my approach than plz upvote me.\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //for number of raw\\n        int r=grid.size();\\n\\t\\t\\n        //for number of column\\n        int c=grid[0].size();\\n        \\n        //to make the copy of the grid\\n        vector<vector<int>>ans=grid;\\n        \\n        k=k%(r*c);//by observation 1\\n        \\n        //to calculate the number of row shift required.\\n        int r_shift=k/c;\\n        \\n        //to calculate the total column shift required .\\n        int c_shift=k%c;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            grid[(i+r_shift)%r]=ans[i];//row shift by observation 2.\\n        }\\n        \\n        ans=grid;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                grid[(i+(j+c_shift)/c)%r][(j+c_shift)%c]=ans[i][j];//coloumn shift.\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n//If you like my approach than plz upvote me.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935303,
                "title": "easy-c-solution-o-1-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(),n=grid[0].size();\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=n-1;j>0;j--){\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }\\n            }\\n             for(int i=m-1;i>0;i--){\\n            swap(grid[i][0],grid[i-1][0]);\\n        }\\n        }\\n       \\n        return grid;\\n    }\\n};\\n```\\n**PLEASE DO UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(),n=grid[0].size();\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=n-1;j>0;j--){\\n                    swap(grid[i][j],grid[i][j-1]);\\n                }\\n            }\\n             for(int i=m-1;i>0;i--){\\n            swap(grid[i][0],grid[i-1][0]);\\n        }\\n        }\\n       \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935270,
                "title": "easy-to-understand-cpp-solution-same-concept-as-rotate-array-problem",
                "content": "```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> v;\\n        for(int i = 0 ; i<grid.size() ; i++)\\n            for(int j = 0 ; j<grid[0].size() ; j++)\\n                v.push_back(grid[i][j]);\\n        \\n          k%=v.size();\\n        reverse(v.begin() , v.end());\\n        reverse(v.begin() , v.begin()+k);\\n        reverse(v.begin()+k , v.end());\\n        int x=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=v[x];\\n                x++;\\n            }\\n        }\\n        return grid;     \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> v;\\n        for(int i = 0 ; i<grid.size() ; i++)\\n            for(int j = 0 ; j<grid[0].size() ; j++)\\n                v.push_back(grid[i][j]);\\n        \\n          k%=v.size();\\n        reverse(v.begin() , v.end());\\n        reverse(v.begin() , v.begin()+k);\\n        reverse(v.begin()+k , v.end());\\n        int x=0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                grid[i][j]=v[x];\\n                x++;\\n            }\\n        }\\n        return grid;     \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935255,
                "title": "most-simplest-and-easiest-solution-c-brute-force-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n       int n=grid[0].size();\\n        int m=grid.size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            { \\n                for(int j=0;j<n;j++)\\n                {\\n                    if(j==(n-1))\\n                {\\n                    if(i==(m-1))\\n                    {\\n                        ans[0][0]=grid[i][j];\\n                    }\\n                    else\\n                    {\\n                        ans[i+1][0]=grid[i][j];\\n                }\\n                }\\n                 else\\n                 {\\n                        ans[i][j+1]=grid[i][j];\\n                    \\n                }\\n            }\\n        }\\n        grid=ans;\\n        }\\n        return grid;\\n    }\\n};\\n```\\n**IF YOU FOUND THIS HELPFUL , PLEASE UPVOTE IT**",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n       int n=grid[0].size();\\n        int m=grid.size();\\n        vector<vector<int>> ans(m, vector<int>(n, 0));\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            { \\n                for(int j=0;j<n;j++)\\n                {\\n                    if(j==(n-1))\\n                {\\n                    if(i==(m-1))\\n                    {\\n                        ans[0][0]=grid[i][j];\\n                    }\\n                    else\\n                    {\\n                        ans[i+1][0]=grid[i][j];\\n                }\\n                }\\n                 else\\n                 {\\n                        ans[i][j+1]=grid[i][j];\\n                    \\n                }\\n            }\\n        }\\n        grid=ans;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935247,
                "title": "c-brute-force-approach-dlc-april-11",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        //push all elements to vector\\n        for(auto i: grid){\\n            for(auto j: i){\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        //put k%n elements in the starting of the vector\\n        int n = temp.size();\\n        k = k % n;\\n        vector<int> res;    //to store correct sequence\\n        for(int i= n-k; i<n; i++){\\n            res.push_back(temp[i]);\\n        }\\n            \\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n           \\n        //make rows of size m and put in grid\\n        int m = grid[0].size();\\n        grid.clear();\\n        temp.clear();\\n        for(int i=0; i<res.size(); i++){\\n            cout<<res[i]<<\"\\\\t\";\\n            if(temp.size() < m)\\n                 temp.push_back(res[i]);\\n            \\n            if(temp.size()== m){\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n                \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        //push all elements to vector\\n        for(auto i: grid){\\n            for(auto j: i){\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        //put k%n elements in the starting of the vector\\n        int n = temp.size();\\n        k = k % n;\\n        vector<int> res;    //to store correct sequence\\n        for(int i= n-k; i<n; i++){\\n            res.push_back(temp[i]);\\n        }\\n            \\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n           \\n        //make rows of size m and put in grid\\n        int m = grid[0].size();\\n        grid.clear();\\n        temp.clear();\\n        for(int i=0; i<res.size(); i++){\\n            cout<<res[i]<<\"\\\\t\";\\n            if(temp.size() < m)\\n                 temp.push_back(res[i]);\\n            \\n            if(temp.size()== m){\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n                \\n        }\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1934978,
                "title": "simple-self-understanding-c-solution",
                "content": "If we linearly arrange all the elements of each row of a matrix , we will have an array. \\nAdd k to the current index of the array and convert that index to represent grid indices.\\n\\nA m*n matrix can be converted into an array or matrix can be represented in the form of a long array\\n\\t\\t\\tmatrix[ i ][ j ] = arr[ i*n + j ]\\nAn element in the long array of size m*n , can be taken into the form of matrix or into matrices indices using\\n\\t\\t\\tarr[ i ] = matrix[ i / n ][ i % n ];\\nTime Complexity of below code: O( m * n )\\nSpace Complexity of below code : O( m * n )\\n```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res(m, vector<int>(n, -1));\\n        \\n        int low = 0, high = m*n;\\n        for(int i = 0; i < high; i++){\\n            int ni = ( (i+k)%high ) / n;\\n            int nj = ( (i+k)%high ) % n;\\n            \\n            res[ni][nj] = grid[i/n][i%n];\\n        }\\n        return res;\\n    }\\n```\\nPlease upvote if u find it helpful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> res(m, vector<int>(n, -1));\\n        \\n        int low = 0, high = m*n;\\n        for(int i = 0; i < high; i++){\\n            int ni = ( (i+k)%high ) / n;\\n            int nj = ( (i+k)%high ) % n;\\n            \\n            res[ni][nj] = grid[i/n][i%n];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934975,
                "title": "c-time-o-n-and-space-o-1-in-place-solution",
                "content": "It\\'s same idea as 189.rotate array, just convert to grid type!\\n\\nif we want to take the k last to the begin, we have to do 3 steps:\\n(1) rotate  whole list\\n(2) rotate the first k elements\\n(3) rotate else elements\\n\\nWe can change the position in list to grid by simply divide column number and module column number.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k %= n * m;\\n\\t\\t// (1) rotate whole list (First half swap with last half)\\n        for (int i = 0; i < n * m / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1-i)/m][(n*m-1-i)%m]);\\n\\t\\t// (2)  rotate the first k elements\\n        for (int i = 0; i < k / 2; i++) swap(grid[i/m][i%m], grid[(k-1-i)/m][(k-1-i)%m]);\\n\\t\\t// (3) rotate else elements\\n        for (int i = k; i < k + (n * m - k) / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1+k-i)/m][(n*m-1+k-i)%m]);\\n        return grid;\\n    }\\n};\\n```\\n\\nIf this solution is helpful, please upvote!!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k %= n * m;\\n\\t\\t// (1) rotate whole list (First half swap with last half)\\n        for (int i = 0; i < n * m / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1-i)/m][(n*m-1-i)%m]);\\n\\t\\t// (2)  rotate the first k elements\\n        for (int i = 0; i < k / 2; i++) swap(grid[i/m][i%m], grid[(k-1-i)/m][(k-1-i)%m]);\\n\\t\\t// (3) rotate else elements\\n        for (int i = k; i < k + (n * m - k) / 2; i++) swap(grid[i/m][i%m], grid[(n*m-1+k-i)/m][(n*m-1+k-i)%m]);\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934967,
                "title": "c-simple-approach-beginner-friendly-neat-and-clean-code",
                "content": "\\t\\t int n = grid.size();\\n        int m = grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<m;j++)\\n                {\\n                    swap(grid[i][0],grid[i][j]);\\n                }\\n            }\\n            \\n            for(int i=1; i<n; i++)\\n            {\\n                swap(grid[0][0], grid[i][0]);\\n            }\\n        }\\n       \\n        return grid;",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t\\t int n = grid.size();\\n        int m = grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=1;j<m;j++)\\n                {\\n                    swap(grid[i][0],grid[i][j]);\\n                }\\n            }\\n            \\n            for(int i=1; i<n; i++)\\n            {\\n                swap(grid[0][0], grid[i][0]);\\n            }\\n        }\\n       \\n        return grid;",
                "codeTag": "Unknown"
            },
            {
                "id": 1934551,
                "title": "python",
                "content": "```python\\n        rows, cols = len(grid), len(grid[0])\\n        res = [[0] * cols for _ in range(rows)]\\n\\t\\t\\n        for r in range(rows):\\n            for c in range(cols):\\n                pos = (r * cols + c + k) % (rows * cols)\\n                _r, _c = divmod(pos, cols)\\n                res[_r][_c] = grid[r][c]\\n\\t\\t\\t\\t\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        rows, cols = len(grid), len(grid[0])\\n        res = [[0] * cols for _ in range(rows)]\\n\\t\\t\\n        for r in range(rows):\\n            for c in range(cols):\\n                pos = (r * cols + c + k) % (rows * cols)\\n                _r, _c = divmod(pos, cols)\\n                res[_r][_c] = grid[r][c]\\n\\t\\t\\t\\t\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1934534,
                "title": "easy-to-comprehend-js-solution",
                "content": "Going backwards column wise shift one time over.\\nThen going backwards row wise move one up.\\nThats one rotation.\\nThen increment down k, do that however many times.\\nThere can be probably be a check for k where it would return the same solutions if its a a certian mod of a the size of the \\ngrid.\\n```\\nvar shiftGrid = function(g, k) {\\n    while(k>0){\\n        for(let i=0;i<g.length;i++){\\n            for(let j=g[0].length-1;j>0;j--){\\n                [g[i][j],g[i][j-1]]= [g[i][j-1],g[i][j]]\\n            }\\n        }\\n    \\n        for(let i=g.length-1;i>0;i--){\\n            [g[i][0],g[i-1][0]]= [g[i-1][0],g[i][0]]\\n        }\\n        k--\\n    }\\n    return g\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(g, k) {\\n    while(k>0){\\n        for(let i=0;i<g.length;i++){\\n            for(let j=g[0].length-1;j>0;j--){\\n                [g[i][j],g[i][j-1]]= [g[i][j-1],g[i][j]]\\n            }\\n        }\\n    \\n        for(let i=g.length-1;i>0;i--){\\n            [g[i][0],g[i-1][0]]= [g[i-1][0],g[i][0]]\\n        }\\n        k--\\n    }\\n    return g\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1615647,
                "title": "java-easy-to-understand-using-modulo-arithmetic",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length, size = m * n;\\n        k = (size - k % size) % size;\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            List<Integer> tmp = new ArrayList<>();\\n            for (int j = 0; j < n; j++) {\\n                int x = k / n, y = k % n;\\n                tmp.add(grid[x][y]);\\n                k = (k + 1) % size;\\n            }\\n            res.add(tmp);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length, size = m * n;\\n        k = (size - k % size) % size;\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            List<Integer> tmp = new ArrayList<>();\\n            for (int j = 0; j < n; j++) {\\n                int x = k / n, y = k % n;\\n                tmp.add(grid[x][y]);\\n                k = (k + 1) % size;\\n            }\\n            res.add(tmp);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451785,
                "title": "c-inplace",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        k %= m * n;\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c += 1000;\\n        for (int i = 0; i < m * n; i++) {\\n            int j = (i + k) % (m * n);\\n            grid[j / n][j % n] |= (grid[i / n][i % n] & 2047) << 11;\\n        }\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c = (c >> 11) - 1000;\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        k %= m * n;\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c += 1000;\\n        for (int i = 0; i < m * n; i++) {\\n            int j = (i + k) % (m * n);\\n            grid[j / n][j % n] |= (grid[i / n][i % n] & 2047) << 11;\\n        }\\n        for (auto &r : grid)\\n            for (auto &c : r)\\n                c = (c >> 11) - 1000;\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419979,
                "title": "ez-solution-c-single-loop-sanyam-shah",
                "content": "# EZ Solution C++\\n```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        for(int i = 0; i < n*m; i++){\\n             int temp = (i+k)%(n*m);\\n             ans[temp/m][temp%m] = grid[i/m][i%m];\\n        }\\n        return ans;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<int>>ans(n,vector<int>(m,0));\\n        for(int i = 0; i < n*m; i++){\\n             int temp = (i+k)%(n*m);\\n             ans[temp/m][temp%m] = grid[i/m][i%m];\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1269002,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         vector<vector<int>>grid1=grid;\\n        while(k--)\\n        {\\n            int n=grid.size();\\n            int m=grid[0].size();\\n            \\n            for(int i=0;i<grid.size();i++)\\n            {\\n                for(int j=0;j<grid[0].size();j++)\\n                {\\n                       \\n                    if(j+1<m)\\n                    {\\n                      grid1[i][j+1]=grid[i][j]; \\n                    }\\n\\n                    if(i+1<n)\\n                    {\\n                     grid1[i+1][0]=grid[i][m-1];   \\n                    }\\n                     \\n                }\\n            }\\n                            \\n            grid1[0][0]=grid[n-1][m-1];\\n            grid=grid1;\\n        }\\n        return grid1;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/81a94899-35d9-4f72-abdf-cc0d37ae83e6_1623567794.6917243.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         vector<vector<int>>grid1=grid;\\n        while(k--)\\n        {\\n            int n=grid.size();\\n            int m=grid[0].size();\\n            \\n            for(int i=0;i<grid.size();i++)\\n            {\\n                for(int j=0;j<grid[0].size();j++)\\n                {\\n                       \\n                    if(j+1<m)\\n                    {\\n                      grid1[i][j+1]=grid[i][j]; \\n                    }\\n\\n                    if(i+1<n)\\n                    {\\n                     grid1[i+1][0]=grid[i][m-1];   \\n                    }\\n                     \\n                }\\n            }\\n                            \\n            grid1[0][0]=grid[n-1][m-1];\\n            grid=grid1;\\n        }\\n        return grid1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144081,
                "title": "c-solution",
                "content": "```\\n// Runtime: 20 ms, faster than 86.55% of C++ online submissions for Shift 2D Grid.\\n// Memory Usage: 13.8 MB, less than 95.69% of C++ online submissions for Shift 2D Grid.\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size(), n = grid[0].size();\\n\\tvector<vector<int>> res(m, vector<int>(n, 0));\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tint newPos = (i * n + j + k) % (m * n);\\n\\t\\t\\tres[newPos / n][newPos % n] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Runtime: 20 ms, faster than 86.55% of C++ online submissions for Shift 2D Grid.\\n// Memory Usage: 13.8 MB, less than 95.69% of C++ online submissions for Shift 2D Grid.\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size(), n = grid[0].size();\\n\\tvector<vector<int>> res(m, vector<int>(n, 0));\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tint newPos = (i * n + j + k) % (m * n);\\n\\t\\t\\tres[newPos / n][newPos % n] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1015725,
                "title": "easy-clear-solution-python-3",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        res=[]\\n        m,n=len(grid),len(grid[0])\\n        k=k%(m*n)\\n        for i in grid:\\n            for j in i:\\n                res.append(j)\\n        res=res[m*n-k:]+res[0:m*n-k]\\n        cp=n\\n        aux=[]\\n        ans=[]\\n        for i in res:\\n            aux.append(i)\\n            cp-=1\\n            if cp==0:\\n                ans.append(aux)\\n                aux=[]\\n                cp=n\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        res=[]\\n        m,n=len(grid),len(grid[0])\\n        k=k%(m*n)\\n        for i in grid:\\n            for j in i:\\n                res.append(j)\\n        res=res[m*n-k:]+res[0:m*n-k]\\n        cp=n\\n        aux=[]\\n        ans=[]\\n        for i in res:\\n            aux.append(i)\\n            cp-=1\\n            if cp==0:\\n                ans.append(aux)\\n                aux=[]\\n                cp=n\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008659,
                "title": "using-k-rotations-on-1d-vector-o-m-n-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<int> a;\\n        \\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                a.push_back(grid[i][j]);\\n        \\n        int s = a.size() - k % a.size();\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                grid[i][j] = a[s++%a.size()];\\n        \\n        return grid;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        vector<int> a;\\n        \\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                a.push_back(grid[i][j]);\\n        \\n        int s = a.size() - k % a.size();\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                grid[i][j] = a[s++%a.size()];\\n        \\n        return grid;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 910356,
                "title": "python-deque-rotate",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        flat = deque(itertools.chain(*grid))\\n        flat.rotate(k)\\n        flat = list(flat)\\n\\n        m, n = len(grid), len(grid[0])\\n        return [flat[i*n:(i+1)*n] for i in range(m)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        flat = deque(itertools.chain(*grid))\\n        flat.rotate(k)\\n        flat = list(flat)\\n\\n        m, n = len(grid), len(grid[0])\\n        return [flat[i*n:(i+1)*n] for i in range(m)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 883235,
                "title": "simple-python-solution-which-beats-99-84-of-submissions-by-using-the-deque-object",
                "content": "```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        lst = []\\n        for row in grid:\\n            lst.extend(row)\\n        items = deque(lst)\\n        k %= len(items)\\n        items.rotate(k)\\n        items = list(items)\\n        lst = []\\n        for i in range(0, len(items), cols):\\n            lst.append(items[i:i+cols])\\n        return lst\\n```",
                "solutionTags": [],
                "code": "```\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        cols = len(grid[0])\\n        lst = []\\n        for row in grid:\\n            lst.extend(row)\\n        items = deque(lst)\\n        k %= len(items)\\n        items.rotate(k)\\n        items = list(items)\\n        lst = []\\n        for i in range(0, len(items), cols):\\n            lst.append(items[i:i+cols])\\n        return lst\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 594791,
                "title": "easy-java-solution",
                "content": "This problem has horrible return type for java! I guess in-place way would be simpler than returning List<List<>>.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        for (int t = 0; t < k; t++) {\\n            \\n            int last = grid[m-1][n-1];\\n            for (int r = m-1; r >= 0; r--) {\\n                for (int c = n-1; c > 0; c--) {\\n                    grid[r][c] = grid[r][c-1];\\n                }\\n                if (r > 0)\\n                    grid[r][0] = grid[r-1][n-1];\\n                else\\n                    grid[0][0] = last;\\n            }\\n            \\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            res.add(new ArrayList<Integer>());\\n            for (int j = 0; j < n; j++) {\\n                res.get(i).add(grid[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        for (int t = 0; t < k; t++) {\\n            \\n            int last = grid[m-1][n-1];\\n            for (int r = m-1; r >= 0; r--) {\\n                for (int c = n-1; c > 0; c--) {\\n                    grid[r][c] = grid[r][c-1];\\n                }\\n                if (r > 0)\\n                    grid[r][0] = grid[r-1][n-1];\\n                else\\n                    grid[0][0] = last;\\n            }\\n            \\n        }\\n        List<List<Integer>> res = new ArrayList<>();\\n        for (int i = 0; i < m; i++) {\\n            res.add(new ArrayList<Integer>());\\n            for (int j = 0; j < n; j++) {\\n                res.get(i).add(grid[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 552572,
                "title": "c-one-pass-solution-2-d-array-to-1-d-array",
                "content": "**1-dimensional array index to 2-dimensional array index**\\nFor a given 1-dimensional array element **array[i]**, the corresponding row and column in 2-dimensional array will be **(i / n)** and **(i % n)**, where n is the number of columns of the 2-dimensional array. \\n\\n**2-dimensional array index to 1-dimensional array index**\\nFor a given  2-dimensional array element **array[i][j]**, the corresponding index of 1-dimensional array will be **(i * n + j)** , where n is the number of columns of the 2-dimensional array. \\n\\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, total = m * n; \\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        // convert 2-D array to 1-D array\\n        for(int pos = 0; pos < total; pos++)\\n        {\\n            // new position after shifting k times\\n            int newPos = (pos + k) % total;       \\n            \\n            // convert 1-D array back to 2-D array\\n            res[newPos / n][newPos % n] = grid[pos / n][pos % n];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n\\nApproach 2: Reverse\\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, size = m * n;\\n        \\n        k %= size;\\n        reverse(grid, 0, size - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, size - 1);\\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n                res[i][j] = grid[i][j];\\n        }\\n       \\n        return res;\\n    }\\n    \\n    private void reverse(int[][] grid, int left, int right)\\n    {\\n        int m = grid.Length, n = grid[0].Length;\\n        \\n        while(left < right)\\n        {\\n            int r = left / n, c = left % n;\\n            int nr = right / n, nc = right % n;\\n            \\n            int tmp = grid[r][c];\\n            grid[r][c] = grid[nr][nc];\\n            grid[nr][nc] = tmp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, total = m * n; \\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        // convert 2-D array to 1-D array\\n        for(int pos = 0; pos < total; pos++)\\n        {\\n            // new position after shifting k times\\n            int newPos = (pos + k) % total;       \\n            \\n            // convert 1-D array back to 2-D array\\n            res[newPos / n][newPos % n] = grid[pos / n][pos % n];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        \\n        int m = grid.Length, n = grid[0].Length, size = m * n;\\n        \\n        k %= size;\\n        reverse(grid, 0, size - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, size - 1);\\n        \\n        int[][] res = new int[m][];\\n        for(int i = 0; i < m; i++)\\n            res[i] = new int[n];\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n                res[i][j] = grid[i][j];\\n        }\\n       \\n        return res;\\n    }\\n    \\n    private void reverse(int[][] grid, int left, int right)\\n    {\\n        int m = grid.Length, n = grid[0].Length;\\n        \\n        while(left < right)\\n        {\\n            int r = left / n, c = left % n;\\n            int nr = right / n, nc = right % n;\\n            \\n            int tmp = grid[r][c];\\n            grid[r][c] = grid[nr][nc];\\n            grid[nr][nc] = tmp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466350,
                "title": "concise-o-m-n-rust-solution",
                "content": "```rust\\npub fn shift_grid(mut A: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n\\tlet (m, n) = (A.len(), A[0].len());\\n\\tlet mut R = vec![vec![0; n]; m];\\n\\tlet k = k as usize;\\n\\tfor i in 0..m {\\n\\t\\tfor j in 0..n {\\n\\t\\t\\tlet y = (j + k) % n;           // j shift right k times\\n\\t\\t\\tlet x = (i + (j + k) / n) % m; // i shift down (j + k) / n times\\n\\t\\t\\tR[x][y] = A[i][j];\\n\\t\\t}\\n\\t}\\n\\tR\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn shift_grid(mut A: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n\\tlet (m, n) = (A.len(), A[0].len());\\n\\tlet mut R = vec![vec![0; n]; m];\\n\\tlet k = k as usize;\\n\\tfor i in 0..m {\\n\\t\\tfor j in 0..n {\\n\\t\\t\\tlet y = (j + k) % n;           // j shift right k times\\n\\t\\t\\tlet x = (i + (j + k) / n) % m; // i shift down (j + k) / n times\\n\\t\\t\\tR[x][y] = A[i][j];\\n\\t\\t}\\n\\t}\\n\\tR\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 437034,
                "title": "three-solutions-in-python-3-two-lines-beats-98",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        return [[G[i%P//N][i%N] for i in range(P-k+j*N,P-k+N+j*N)] for j in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, H, k = len(G), len(G[0]), sum(G,[]), k % (len(G)*len(G[0]))\\n        I = H[-k:] + H[:-k]\\n        return [I[i*N:(i+1)*N] for i in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        A = [[0]*N for _ in range(M)]\\n        for i in range(P): A[(i+k)%P//N][((i+k)%P)%N]= G[i//N][i%N]\\n        return A\\n\\t\\t\\n\\n\\n- Junaid Mansuri",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        return [[G[i%P//N][i%N] for i in range(P-k+j*N,P-k+N+j*N)] for j in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, H, k = len(G), len(G[0]), sum(G,[]), k % (len(G)*len(G[0]))\\n        I = H[-k:] + H[:-k]\\n        return [I[i*N:(i+1)*N] for i in range(M)]\\n\\n\\n\\nclass Solution:\\n    def shiftGrid(self, G: List[List[int]], k: int) -> List[List[int]]:\\n        M, N, P = len(G), len(G[0]), len(G)*len(G[0])\\n        A = [[0]*N for _ in range(M)]\\n        for i in range(P): A[(i+k)%P//N][((i+k)%P)%N]= G[i//N][i%N]\\n        return A\\n\\t\\t\\n\\n\\n- Junaid Mansuri",
                "codeTag": "Java"
            },
            {
                "id": 433799,
                "title": "java-100-space-with-comments",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        \\n        // column width of the grid\\n        int colWidth = grid[0].length;\\n        \\n        // row height of the grid\\n        int rowHeight = grid.length;\\n        \\n        // totalElements in the grid\\n        int modulo = colWidth * rowHeight;\\n        \\n        //temp flat one dimensional array to store the values, when they have finally shifted by K times\\n        int[] finalIndexes = new int[colWidth * rowHeight];\\n        \\n        //go thru every element in the grid\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                \\n                // final index within a grid is calculated as currentIndex \\n// (imagine it is not a 2-d grid but a 1-d array so that element in 2nd row 2nd column is at index 4 in the 1-d array... ), \\n// we just add K to it and then divide by total number of elements \\n// and whatever is there a reminder then it would be the final location\\n                int finalIndex = ((i * colWidth) + j + k ) % modulo;\\n              \\n                //assign a value to it\\'s final index\\n                finalIndexes[finalIndex] = grid[i][j];\\n            }\\n        }\\n        \\n        \\n        // the below part is just a boilerplate for returning the value in the desired output format\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        \\n        // since this is a list of list , then the outer list would contain sublists equal to the height of the original grid\\n        for(int i = 0; i < rowHeight; i++){\\n            resultList.add(new ArrayList<>());\\n        }\\n        \\n        int counter = 0;\\n        int rowCount = -1;\\n        \\n        for(int i = 0; i < finalIndexes.length; i++){\\n            if(i % colWidth == 0){\\n                rowCount++; // increment row count if all the elements are filled in the previous row\\n            }    \\n            //add to the row where it belongs    \\n            resultList.get(rowCount).add(finalIndexes[i]);\\n        }\\n        \\n        // the answer\\n        return resultList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        \\n        // column width of the grid\\n        int colWidth = grid[0].length;\\n        \\n        // row height of the grid\\n        int rowHeight = grid.length;\\n        \\n        // totalElements in the grid\\n        int modulo = colWidth * rowHeight;\\n        \\n        //temp flat one dimensional array to store the values, when they have finally shifted by K times\\n        int[] finalIndexes = new int[colWidth * rowHeight];\\n        \\n        //go thru every element in the grid\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                \\n                // final index within a grid is calculated as currentIndex \\n// (imagine it is not a 2-d grid but a 1-d array so that element in 2nd row 2nd column is at index 4 in the 1-d array... ), \\n// we just add K to it and then divide by total number of elements \\n// and whatever is there a reminder then it would be the final location\\n                int finalIndex = ((i * colWidth) + j + k ) % modulo;\\n              \\n                //assign a value to it\\'s final index\\n                finalIndexes[finalIndex] = grid[i][j];\\n            }\\n        }\\n        \\n        \\n        // the below part is just a boilerplate for returning the value in the desired output format\\n        List<List<Integer>> resultList = new ArrayList<>();\\n        \\n        // since this is a list of list , then the outer list would contain sublists equal to the height of the original grid\\n        for(int i = 0; i < rowHeight; i++){\\n            resultList.add(new ArrayList<>());\\n        }\\n        \\n        int counter = 0;\\n        int rowCount = -1;\\n        \\n        for(int i = 0; i < finalIndexes.length; i++){\\n            if(i % colWidth == 0){\\n                rowCount++; // increment row count if all the elements are filled in the previous row\\n            }    \\n            //add to the row where it belongs    \\n            resultList.get(rowCount).add(finalIndexes[i]);\\n        }\\n        \\n        // the answer\\n        return resultList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431470,
                "title": "python-4-lines-beat-100-speed-and-space-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/koten0224/image_1573995656.png)\\n\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        r,c = len(grid),len(grid[0]) #get the nums of rows and columns\\n        temp=[j for i in grid for j in i] #make grid flatten\\n        temp=temp[-k%len(temp):]+temp[:-k%len(temp)] #do the shift\\n        return [[temp[i*c+j] for j in range(c)]for i in range(r)] #trans into grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        r,c = len(grid),len(grid[0]) #get the nums of rows and columns\\n        temp=[j for i in grid for j in i] #make grid flatten\\n        temp=temp[-k%len(temp):]+temp[:-k%len(temp)] #do the shift\\n        return [[temp[i*c+j] for j in range(c)]for i in range(r)] #trans into grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918501,
                "title": "easy-c-solution-easy-to-understand-simple-clean-code-with-explanationeasy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Store the last column into a vector\\n2. Move the values of (i-1) th column to i th column\\n3. Move the element at grid[m - 1][n - 1] to grid[0][0] from \"tmp\"\\n4. Replace the rest of the column-1 with the stored values from \"tmp\"\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        while(k--){\\n            // Take a vector of length m with initial value of 0 to store the last column\\n            vector<int> tmp(m,0);\\n            //Store the values of last column in \"tmp\" for later \\n            for(int i = 0; i < m; i++){\\n                tmp[i] = grid[i][n-1];\\n                cout << tmp[i];\\n            }\\n            //iterate from last column to the second column\\n            for(int i = 0; i < m; i++){\\n                for(int j = n - 1; j >= 1 ; j--){\\n                     // Store the values of previous column in the current column\\n                    grid[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            // Move the element at grid[m - 1][n - 1] to grid[0][0]\\n            grid[0][0] = tmp[m-1];\\n            // Move the rest of the values in the first column\\n            for(int i = 1; i < m; i++){\\n                grid[i][0] = tmp[i-1];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size(), n = grid[0].size();\\n        while(k--){\\n            // Take a vector of length m with initial value of 0 to store the last column\\n            vector<int> tmp(m,0);\\n            //Store the values of last column in \"tmp\" for later \\n            for(int i = 0; i < m; i++){\\n                tmp[i] = grid[i][n-1];\\n                cout << tmp[i];\\n            }\\n            //iterate from last column to the second column\\n            for(int i = 0; i < m; i++){\\n                for(int j = n - 1; j >= 1 ; j--){\\n                     // Store the values of previous column in the current column\\n                    grid[i][j] = grid[i][j - 1];\\n                }\\n            }\\n            // Move the element at grid[m - 1][n - 1] to grid[0][0]\\n            grid[0][0] = tmp[m-1];\\n            // Move the rest of the values in the first column\\n            for(int i = 1; i < m; i++){\\n                grid[i][0] = tmp[i-1];\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3075497,
                "title": "beats-99-43-python3",
                "content": "# Approach\\nFirst of all accessing each list of grid through index, popping the last element and inserting it to the starting of next list. \\n\\nFinally, accessing the last list popping the last element and inserting it to the first list. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def shift(grid):\\n            for i in range(len(grid) - 1):\\n                grid[i + 1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop())\\n            return grid\\n        for i in range(k):\\n            shift(grid)\\n        return grid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def shift(grid):\\n            for i in range(len(grid) - 1):\\n                grid[i + 1].insert(0, grid[i].pop())\\n            grid[0].insert(0, grid[-1].pop())\\n            return grid\\n        for i in range(k):\\n            shift(grid)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689101,
                "title": "o-1-space-easy-to-understand-python",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        n = len(grid)\\n        m  = len(grid[0])\\n        \\n        temp = float(\"inf\")\\n        \\n        \\n        for t in range(0,k):\\n        \\n            for i in range(0,n):\\n\\n                for j in range(0,m):\\n\\n                    if(i == 0 and j == 0 ):\\n\\n                        temp =  grid[i][j]\\n\\n                    else:\\n\\n                        t1 = grid[i][j]\\n\\n                        grid[i][j] = temp \\n\\n                        temp = t1 \\n\\n            grid[0][0] = temp\\n        \\n        \\n        return grid\\n\\n                    \\n                    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        n = len(grid)\\n        m  = len(grid[0])\\n        \\n        temp = float(\"inf\")\\n        \\n        \\n        for t in range(0,k):\\n        \\n            for i in range(0,n):\\n\\n                for j in range(0,m):\\n\\n                    if(i == 0 and j == 0 ):\\n\\n                        temp =  grid[i][j]\\n\\n                    else:\\n\\n                        t1 = grid[i][j]\\n\\n                        grid[i][j] = temp \\n\\n                        temp = t1 \\n\\n            grid[0][0] = temp\\n        \\n        \\n        return grid\\n\\n                    \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446323,
                "title": "no-extra-space-taken-in-place-time-k-o-n-m-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int m = col;\\n        int total = row*col;\\n        int temp;\\n        while(k>0){\\n            temp = grid[row-1][col-1];\\n            for(int i = row*col-1 ; i>=1 ; i--){\\n                grid[i/m][i%m] = grid[(i-1)/m][(i-1)%m];\\n            }\\n            \\n            grid[0][0] = temp;\\n            \\n            k--;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row = grid.size();\\n        int col = grid[0].size();\\n        int m = col;\\n        int total = row*col;\\n        int temp;\\n        while(k>0){\\n            temp = grid[row-1][col-1];\\n            for(int i = row*col-1 ; i>=1 ; i--){\\n                grid[i/m][i%m] = grid[(i-1)/m][(i-1)%m];\\n            }\\n            \\n            grid[0][0] = temp;\\n            \\n            k--;\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444389,
                "title": "js-two-solutions-offset-in-place-runtime-83-58-memory-98-51",
                "content": "```\\n// Using .flat() + offset and refilling the grid in-place.\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length, N = grid[0].length;\\n\\tlet flat = grid.flat();\\n\\tif (k > flat.length) k = k % flat.length;\\n\\tlet shft = flat.splice(flat.length - k, k);\\n\\tflat.unshift(...shft);\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++) {\\n\\t\\t\\tgrid[i][j] = flat[i*N + j];\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};\\n```\\n\\n```\\n// Grid copy + new position calculation\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length;\\n\\tconst N = grid[0].length;\\n\\tlet res = Array.from({length: M}, (v, k) => new Int16Array(N));\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++){\\n\\t\\t\\tlet newCol = (j + k) % N;\\n\\t\\t\\tlet newRow = (i + (j+k)/N) % M;\\n\\t\\t\\tres[~~newRow][newCol] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Using .flat() + offset and refilling the grid in-place.\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length, N = grid[0].length;\\n\\tlet flat = grid.flat();\\n\\tif (k > flat.length) k = k % flat.length;\\n\\tlet shft = flat.splice(flat.length - k, k);\\n\\tflat.unshift(...shft);\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++) {\\n\\t\\t\\tgrid[i][j] = flat[i*N + j];\\n\\t\\t}\\n\\t}\\n\\treturn grid;\\n};\\n```\n```\\n// Grid copy + new position calculation\\nvar shiftGrid = function(grid, k) {\\n\\tconst M = grid.length;\\n\\tconst N = grid[0].length;\\n\\tlet res = Array.from({length: M}, (v, k) => new Int16Array(N));\\n\\tfor (let i = 0; i < M; i++) {\\n\\t\\tfor (let j = 0; j < N; j++){\\n\\t\\t\\tlet newCol = (j + k) % N;\\n\\t\\t\\tlet newRow = (i + (j+k)/N) % M;\\n\\t\\t\\tres[~~newRow][newCol] = grid[i][j];\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2440236,
                "title": "c-solution-beats-96-21-of-cpp-submissions",
                "content": "The problem is similar to right rotating a 1d array k times. We can implement the same in this problem. Reverse the last k elements of the flattened version of the input array, and reverse the first n-k elements of the input array.  Then Reverse the whole 2d array. This solution does the job in-place.\\n\\n```\\n\\tvoid reverse(vector<vector<int>> &grid, int l, int r, int n){\\n        int r1, c1, r2, c2;\\n        for(int i = l, j = r; i < j; i++, j--){\\n            r1 = i/n;\\n            c1 = i%n;\\n            r2 = j/n;\\n            c2 = j%n;\\n            swap(grid[r1][c1], grid[r2][c2]);\\n        }\\n    }\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int sz = m*n;\\n        k = k % sz;\\n        reverse(grid, sz-k, sz-1, n);\\n        reverse(grid, 0, sz-k-1, n);\\n        reverse(grid, 0, sz-1, n);\\n        return grid;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n\\tvoid reverse(vector<vector<int>> &grid, int l, int r, int n){\\n        int r1, c1, r2, c2;\\n        for(int i = l, j = r; i < j; i++, j--){\\n            r1 = i/n;\\n            c1 = i%n;\\n            r2 = j/n;\\n            c2 = j%n;\\n            swap(grid[r1][c1], grid[r2][c2]);\\n        }\\n    }\\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int sz = m*n;\\n        k = k % sz;\\n        reverse(grid, sz-k, sz-1, n);\\n        reverse(grid, 0, sz-k-1, n);\\n        reverse(grid, 0, sz-1, n);\\n        return grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2023525,
                "title": "c-flatten-rotate-locate",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& a, int k) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int> b(n*m);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                b[i*m + j] = a[i][j];\\n            }\\n        }\\n        \\n        k %= (n*m);\\n        \\n        rotate(b.begin(), b.end()-k, b.end());\\n        \\n        for(int i=0; i<n*m; i++)\\n        {\\n            a[i/m][i%m] = b[i];\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& a, int k) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int> b(n*m);\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                b[i*m + j] = a[i][j];\\n            }\\n        }\\n        \\n        k %= (n*m);\\n        \\n        rotate(b.begin(), b.end()-k, b.end());\\n        \\n        for(int i=0; i<n*m; i++)\\n        {\\n            a[i/m][i%m] = b[i];\\n        }\\n        \\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941495,
                "title": "c-clean-code-simple-concise-easy",
                "content": "**Runtime: 16 ms**\\n***Faster than 90% solution in c++***\\n```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> res(m, vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int newpos= (i*n+j+k) % (m*n);      \\n                res[newpos/n][newpos%n]=grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        vector<vector<int>> res(m, vector<int>(n,0));\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int newpos= (i*n+j+k) % (m*n);      \\n                res[newpos/n][newpos%n]=grid[i][j];\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937791,
                "title": "python-pop-insert-in-next-row",
                "content": "Remove the last element in each row and insert it at the beggining of the next row. \\n\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for i in range(k):\\n\\t\\t\\t#take last element in the matrix and move it to first position\\n            grid[0].insert(0, grid[-1].pop())\\n\\t\\t\\t\\n\\t\\t\\t# for each row after 1st row, pop last element in previous row, then add it to the beginning of current row\\n            for j in range(1,len(grid)):\\n                grid[j].insert(0, grid[j-1].pop())\\n        return grid\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for i in range(k):\\n\\t\\t\\t#take last element in the matrix and move it to first position\\n            grid[0].insert(0, grid[-1].pop())\\n\\t\\t\\t\\n\\t\\t\\t# for each row after 1st row, pop last element in previous row, then add it to the beginning of current row\\n            for j in range(1,len(grid)):\\n                grid[j].insert(0, grid[j-1].pop())\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937731,
                "title": "c-simple-solution-with-explanation-o-n-m-100-faster",
                "content": "The idea is to map the two dimensional array position to a postion in an imaginary one dimensional array from (0 to m*n -1).\\nIt can be done with i * n + j. \\nThen sum k to get the 1d array new position and get module to avoid having a number greater than the max length of the imaginary 1d array.\\nLast, convert the 1d new position to the 2d array postions with the x = newPosition/n and y = newPosition%n\\n```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        var maxLength = m * n;\\n        \\n        // initialize result\\n        var result = new List<IList<int>>(m);\\n        for (int i = 0; i < m; i++)\\n        {\\n            result.Add(new List<int>(n));\\n            for (int j = 0; j < n; j++)\\n            {\\n               result[i].Add(0);\\n            }\\n        }\\n        \\n        // make the shifted grid\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                var currPosition = i*n + j;\\n                var newPosition = (currPosition + k) % maxLength;\\n                var x = newPosition / n;\\n                var y = newPosition % n;\\n                result[x][y] = grid[i][j];\\n            }\\n        }        \\n        return result;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/236a29de-fbe5-48ac-847c-01a10f7994fa_1649719535.5562575.png)\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> ShiftGrid(int[][] grid, int k) {\\n        var m = grid.Length;\\n        var n = grid[0].Length;\\n        var maxLength = m * n;\\n        \\n        // initialize result\\n        var result = new List<IList<int>>(m);\\n        for (int i = 0; i < m; i++)\\n        {\\n            result.Add(new List<int>(n));\\n            for (int j = 0; j < n; j++)\\n            {\\n               result[i].Add(0);\\n            }\\n        }\\n        \\n        // make the shifted grid\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                var currPosition = i*n + j;\\n                var newPosition = (currPosition + k) % maxLength;\\n                var x = newPosition / n;\\n                var y = newPosition % n;\\n                result[x][y] = grid[i][j];\\n            }\\n        }        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937678,
                "title": "python-3-inplace-triple-reverse-doug-mcilroy-and-gcd-solutions",
                "content": "Straightforward solution is very boring, how could we do that inplace?\\n\\nAnother boring thing is Programming Pearls solution (page 33) aka triple reverse (by Doug Mcilroy). Even if it\\'s 1D you can easlily remap it to 2D grid:\\n\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        def reverse(a, b):\\n            for i in range(a, (a + b)//2):\\n                j = a + b - i - 1\\n                grid[j//w][j%w], grid[i//w][i%w] = grid[i//w][i%w], grid[j//w][j%w]\\n        reverse(0, shift)\\n        reverse(shift, n)\\n        reverse(0, n)\\n        return grid\\n```\\n\\nIt\\'s very suboptimal though, because you have to address every element at least twice not counting the swaps. There\\'s an optimal solution that works in O(n) for 1D, or O(n x m) for 2D grid mentioned here: https://stackoverflow.com/questions/876293/fastest-algorithm-for-circle-shift-n-sized-array-for-m-position\\n\\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        for i in range(gcd(n, shift)):\\n            j = i\\n            while (k := (j + shift) % n) != i:\\n                grid[j//w][j%w], grid[k//w][k%w] = grid[k//w][k%w], grid[j//w][j%w]\\n                j = k\\n        return grid\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        def reverse(a, b):\\n            for i in range(a, (a + b)//2):\\n                j = a + b - i - 1\\n                grid[j//w][j%w], grid[i//w][i%w] = grid[i//w][i%w], grid[j//w][j%w]\\n        reverse(0, shift)\\n        reverse(shift, n)\\n        reverse(0, n)\\n        return grid\\n```\n```python\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        h, w = len(grid), len(grid[0])\\n        n = h * w\\n        shift = n - (k % n)\\n        for i in range(gcd(n, shift)):\\n            j = i\\n            while (k := (j + shift) % n) != i:\\n                grid[j//w][j%w], grid[k//w][k%w] = grid[k//w][k%w], grid[j//w][j%w]\\n                j = k\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937599,
                "title": "javascript-neat-3-methods-flat-flat-in-place-in-place",
                "content": "## 1. Flat\\nComplexity: time **O(3mn)**, extra space **O(2mn)**\\n\\n```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = m * n;\\n  k = mn - k % mn;\\n  const res = grid.flat();\\n  res.splice(0, 0, ...res.splice(k));\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\\n\\n## 2. Flat In Place\\nComplexity: time **O(4mn)**, extra space **O(mn)**\\n\\n```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const res = grid.flat();\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j)\\n      [res[i], res[j]] = [res[j], res[i]]\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\\n\\n## 3. In Place\\nComplexity: time **O(2mn)**, extra space **O(1)**\\n\\n```js\\nconst shiftGrid = (grid, k) => {\\n  const n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const xy = (i) => [i % n, (i / n) | 0];\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j) {\\n      const [Xi, Yi] = xy(i), [Xj, Yj] = xy(j);\\n      [grid[Yi][Xi], grid[Yj][Xj]] = [grid[Yj][Xj], grid[Yi][Xi]];\\n    }\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return grid;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = m * n;\\n  k = mn - k % mn;\\n  const res = grid.flat();\\n  res.splice(0, 0, ...res.splice(k));\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\n```js\\nconst shiftGrid = (grid, k) => {\\n  const m = grid.length, n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const res = grid.flat();\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j)\\n      [res[i], res[j]] = [res[j], res[i]]\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return [...Array(m)].map(() => res.splice(0, n));\\n};\\n```\n```js\\nconst shiftGrid = (grid, k) => {\\n  const n = grid[0].length, mn = grid.length * n;\\n  k %= mn;\\n  const xy = (i) => [i % n, (i / n) | 0];\\n  const reverse = (i, j) => {\\n    for (j = j - 1; i < j; ++i, --j) {\\n      const [Xi, Yi] = xy(i), [Xj, Yj] = xy(j);\\n      [grid[Yi][Xi], grid[Yj][Xj]] = [grid[Yj][Xj], grid[Yi][Xi]];\\n    }\\n  };\\n  reverse(0, mn);\\n  reverse(0, k);\\n  reverse(k, mn);\\n  return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937582,
                "title": "easy-c",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n\\n                int newj = (j+k)%c;\\n                \\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        int r=grid.size(), c=grid[0].size();\\n        vector<vector<int>> ans(r, vector<int>(c));\\n        \\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n\\n                int newj = (j+k)%c;\\n                \\n                int newi = (i + (j+k)/c)%r;\\n                \\n                //put value into ans with new i, j\\n                ans[newi][newj] = grid[i][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1937552,
                "title": "kotlin-100-time-and-space-easy-solution-with-explanation",
                "content": "At first, I was trying an approach where I calculate a toRow and toCol, but had difficulty getting them right without a paper and pencil.  Then I realized it\\'s much easier to just have a one-dimensional array for the elements, start at the kth position (called \"to\"), and just copy the items from the beginning of the grid to \"to\" and keep incrementing \"to\" by 1.\\n\\n\"to\" starts at k % size (# of rows * # of columns), which automatically makes is zero-based.  To save time, the first check is to see if k % size is 0, in which case nothing needs to be shifted, just turn the rows into lists and add them to the output list, and return.\\n\\nThe second speed saving is if the size of each row is 1.  In that case, still create an output array the size of the grid and copy the items in, starting at to, always column 0 in th grid.  Then, each item is its own list, so go through the array and add each one as a list, and return.\\n\\nWhenever \"to\" reaches the end of the list ( == size), reset to 0.\\n\\nFinally, starting at the begining of the output grid (to = 0), create a new list for each row, and add column number of items to the list, and then add that list to the out list.\\n\\n```\\nfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n        var out = MutableList<List<Int>>(0) { List<Int>(0) { 0 } }\\n        var rows = grid.size\\n        var cols = grid[0].size\\n        var size = rows * cols\\n        if (k % size == 0) {\\n            var list : List<Int>\\n            for (line in grid) {\\n                list = line.toList()\\n                out.add(list)\\n            }\\n            return out\\n        }\\n        var outGrid = IntArray(size) \\n        var to = k % size\\n        if (cols == 1) {\\n            for (row in 0..rows - 1) {\\n                outGrid[to++] = grid[row][0]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n            for (n in outGrid) {\\n                out.add(listOf(n))\\n                }\\n            return out\\n        }\\n        for (row in 0..rows - 1) {\\n            for (col in 0..cols - 1) {\\n                outGrid[to++] = grid[row][col]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n        }\\n        to = 0\\n        var list : MutableList<Int>\\n        for (row in 0..rows - 1) {\\n            list = mutableListOf<Int>(outGrid[to++])\\n            for (col in 1..cols - 1) {\\n                list.add(outGrid[to++])\\n            }\\n            out.add(list)\\n        }\\n        return out\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfun shiftGrid(grid: Array<IntArray>, k: Int): List<List<Int>> {\\n        var out = MutableList<List<Int>>(0) { List<Int>(0) { 0 } }\\n        var rows = grid.size\\n        var cols = grid[0].size\\n        var size = rows * cols\\n        if (k % size == 0) {\\n            var list : List<Int>\\n            for (line in grid) {\\n                list = line.toList()\\n                out.add(list)\\n            }\\n            return out\\n        }\\n        var outGrid = IntArray(size) \\n        var to = k % size\\n        if (cols == 1) {\\n            for (row in 0..rows - 1) {\\n                outGrid[to++] = grid[row][0]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n            for (n in outGrid) {\\n                out.add(listOf(n))\\n                }\\n            return out\\n        }\\n        for (row in 0..rows - 1) {\\n            for (col in 0..cols - 1) {\\n                outGrid[to++] = grid[row][col]\\n                if (to == size) {\\n                    to = 0\\n                }\\n            }\\n        }\\n        to = 0\\n        var list : MutableList<Int>\\n        for (row in 0..rows - 1) {\\n            list = mutableListOf<Int>(outGrid[to++])\\n            for (col in 1..cols - 1) {\\n                list.add(outGrid[to++])\\n            }\\n            out.add(list)\\n        }\\n        return out\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937526,
                "title": "golang-o-1-space",
                "content": "```go\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    \\n    i := func(x int) int { return x / n }\\n    j := func(x int) int { return x % n }\\n    \\n    for k = k % (m*n); k > 0; k-- {\\n        tmp := grid[m-1][n-1]\\n        for ii := m*n-1; ii > 0; ii-- {\\n            grid[i(ii)][j(ii)] = grid[i(ii-1)][j(ii-1)]\\n        }\\n        grid[0][0] = tmp\\n    }\\n    \\n    return grid\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc shiftGrid(grid [][]int, k int) [][]int {\\n    m, n := len(grid), len(grid[0])\\n    \\n    i := func(x int) int { return x / n }\\n    j := func(x int) int { return x % n }\\n    \\n    for k = k % (m*n); k > 0; k-- {\\n        tmp := grid[m-1][n-1]\\n        for ii := m*n-1; ii > 0; ii-- {\\n            grid[i(ii)][j(ii)] = grid[i(ii-1)][j(ii-1)]\\n        }\\n        grid[0][0] = tmp\\n    }\\n    \\n    return grid\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937511,
                "title": "python-short-functional-programming-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: list[list[int]], k_: int) -> list[list[int]]:\\n        m, n = len(grid), len(grid[0])\\n        t = m * n\\n        k = k_ % t\\n        \\n        initial_nums = chain.from_iterable(grid)\\n        shifted_nums = islice(cycle(initial_nums), t - k, t - k + t)\\n        \\n        # If asked for inplace (side effects and not FP):\\n        # for i, j in product(range(m), range(n)): grid[i][j] = next(shifted_nums)\\n        # return grid\\n        \\n        return [list(islice(shifted_nums, n)) for _ in range(m)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: list[list[int]], k_: int) -> list[list[int]]:\\n        m, n = len(grid), len(grid[0])\\n        t = m * n\\n        k = k_ % t\\n        \\n        initial_nums = chain.from_iterable(grid)\\n        shifted_nums = islice(cycle(initial_nums), t - k, t - k + t)\\n        \\n        # If asked for inplace (side effects and not FP):\\n        # for i, j in product(range(m), range(n)): grid[i][j] = next(shifted_nums)\\n        # return grid\\n        \\n        return [list(islice(shifted_nums, n)) for _ in range(m)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937476,
                "title": "rust-rotate-in-place-same-as-189-rotate-array",
                "content": "The \"shift\" steps describe how to \"rotate\" a 1-D array by 1 element to the right by using its 2-d representation. Take the first example - if we convert the 2D matrix to 1D array:`[[1,2,3],[4,5,6],[7,8,9]] => [1,2,3,4,5,6,7,8,9]` and then rotate the 1D array by 1 element to the right we will get `[9, 1,2,3,4,5,6,7,8]` and then in order to get the answer we have to convert it back to a 2D representation: `[[9,1,2],[3,4,5],[6,7,8]]` \\n\\nIf we execute the steps of the \"shift\" algorithm we find out that it actually shifts all cells by 1 to the right. So doing the \"shift\" operation K times is equivalient to shiftingk by K positons only once. \\n\\nFrom  [189. Rotate Array](https://github.com/SvetlinZarev/coding-challenges/blob/main/leetcode/100%20-%20199/189%20-%20Rotate%20Array.md) we have already learned how to rorate (shift) a 1D array. We just have to apply that knowledge by extending it to a 2D array. This can be done by finding out how to go from 1D index, to a 2D index and vice cersa:\\n\\n* The formula to convert from 2D index to 1D index is `row * columns + column`\\n* The formula to convert from 1D index to 2D index is:\\n    * `row = index / columns`\\n    * `col = index % columns`\\n\\n\\n\\nNow we know that we can go from 2D to 1D matrix, rotate it, and then go back to 2D matrix.This means that we can use the same approach as in [189. Rotate Array](https://github.com/SvetlinZarev/coding-challenges/blob/main/leetcode/100%20-%20199/189%20-%20Rotate%20Array.md):\\n\\n```rust\\npub fn shift_grid(mut grid: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n    let elements = grid.len() * grid[0].len();\\n    let k = (k as usize) % elements;\\n    if k == 0 || elements == 1 {\\n        return grid;\\n    }\\n\\n    reverse(&mut grid, 0, elements);\\n    reverse(&mut grid, 0, k);\\n    reverse(&mut grid, k, elements);\\n    grid\\n}\\n\\nfn reverse(grid: &mut [Vec<i32>], from: usize, to: usize) {\\n    if from >= to {\\n        return;\\n    }\\n    let cols = grid[0].len();\\n\\n    let mut a = from;\\n    let mut b = to - 1;\\n\\n    while a < b {\\n        let cell = grid[a / cols][a % cols];\\n        grid[a / cols][a % cols] = grid[b / cols][b % cols];\\n        grid[b / cols][b % cols] = cell;\\n\\n        a += 1;\\n        b -= 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\npub fn shift_grid(mut grid: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\\n    let elements = grid.len() * grid[0].len();\\n    let k = (k as usize) % elements;\\n    if k == 0 || elements == 1 {\\n        return grid;\\n    }\\n\\n    reverse(&mut grid, 0, elements);\\n    reverse(&mut grid, 0, k);\\n    reverse(&mut grid, k, elements);\\n    grid\\n}\\n\\nfn reverse(grid: &mut [Vec<i32>], from: usize, to: usize) {\\n    if from >= to {\\n        return;\\n    }\\n    let cols = grid[0].len();\\n\\n    let mut a = from;\\n    let mut b = to - 1;\\n\\n    while a < b {\\n        let cell = grid[a / cols][a % cols];\\n        grid[a / cols][a % cols] = grid[b / cols][b % cols];\\n        grid[b / cols][b % cols] = cell;\\n\\n        a += 1;\\n        b -= 1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937433,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func shiftGrid(_ g: [[Int]], _ k: Int) -> [[Int]] {\\n        if k == 0 { return g }\\n        let row = g.count, col = g[0].count\\n        var grid = g\\n        for r in 0..<row {\\n            for c in 0..<col {\\n                let rw1 = (r + (c + k) / col) % row\\n                let cl1 = (c + k) % col\\n                grid[rw1][cl1] = g[r][c]\\n            }\\n        }\\n        return grid\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 1)\\n        XCTAssertEqual(value, [[9,1,2],[3,4,5],[6,7,8]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.shiftGrid([[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], 4)\\n        XCTAssertEqual(value, [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]])\\n    }\\n    \\n    func test2() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 9)\\n        XCTAssertEqual(value, [[1,2,3],[4,5,6],[7,8,9]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func shiftGrid(_ g: [[Int]], _ k: Int) -> [[Int]] {\\n        if k == 0 { return g }\\n        let row = g.count, col = g[0].count\\n        var grid = g\\n        for r in 0..<row {\\n            for c in 0..<col {\\n                let rw1 = (r + (c + k) / col) % row\\n                let cl1 = (c + k) % col\\n                grid[rw1][cl1] = g[r][c]\\n            }\\n        }\\n        return grid\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n\\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 1)\\n        XCTAssertEqual(value, [[9,1,2],[3,4,5],[6,7,8]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.shiftGrid([[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], 4)\\n        XCTAssertEqual(value, [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]])\\n    }\\n    \\n    func test2() {\\n        let value = solution.shiftGrid([[1,2,3],[4,5,6],[7,8,9]], 9)\\n        XCTAssertEqual(value, [[1,2,3],[4,5,6],[7,8,9]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937377,
                "title": "c-easy-solution-using-extra-and-without-extra-space",
                "content": "**Method 1:**\\nTime Complexity : O(n*m)\\nSpace Complexity : O(m*n)\\n\\n\\n```\\n  vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        deque<int>dq;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                dq.push_back(grid[i][j]);\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            dq.push_front(dq.back());\\n            dq.pop_back();\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                grid[i][j]=dq.front();\\n                dq.pop_front();\\n            }\\n        }\\n    return grid;\\n    }\\n```\\n\\n**Method 2:\\nTime Complexity: O(n*m*k)**\\n**Space Complexity : O(k)**\\n\\n```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n      \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        int temp = -1;\\n        if(k==0)\\n           return grid;\\n            for(int i=0;i<m;i++)\\n           {  \\n             for(int j=0;j<n;j++)\\n             {\\n                swap(temp,grid[i][j]);\\n             }\\n          }\\n        swap(temp,grid[0][0]);\\n       \\n       return shiftGrid(grid,k-1); \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\n  vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        deque<int>dq;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                dq.push_back(grid[i][j]);\\n            }\\n        }\\n        for(int i=0;i<k;i++)\\n        {\\n            dq.push_front(dq.back());\\n            dq.pop_back();\\n        }\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                grid[i][j]=dq.front();\\n                dq.pop_front();\\n            }\\n        }\\n    return grid;\\n    }\\n```\n```\\n vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n      \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        int temp = -1;\\n        if(k==0)\\n           return grid;\\n            for(int i=0;i<m;i++)\\n           {  \\n             for(int j=0;j<n;j++)\\n             {\\n                swap(temp,grid[i][j]);\\n             }\\n          }\\n        swap(temp,grid[0][0]);\\n       \\n       return shiftGrid(grid,k-1); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937351,
                "title": "c-2-approach-with-extra-space-without-extra-space",
                "content": "**First Approach :** Without extra space (Optimal Solution)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int temp =-1;\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                swap(grid[i][j], temp);\\n            }\\n        }\\n        swap(temp,grid[0][0]);\\n        return shiftGrid(grid,k-1);  //recursive call \\n        \\n    }\\n};\\n\\n```\\n\\n**Second Approach :** Here extra space used and call the recursion for k-1 steps.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        // set all the values of the matrix is zero\\n        vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return shiftGrid(v,k-1);  //recursive call     \\n    }\\n};\\n```\\n\\nIf anyone didn\\'t understand how  the recursion works they can understand the concept by the below code.\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>myfunction(vector<vector<int>>&grid, int m, int n){\\n          vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return v;\\n    }  \\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>temp(m,vector<int>(n,0));\\n        while(k-->0){\\n            temp = myfunction(grid,m,n);\\n            grid = temp;   \\n        }\\n        \\n        return temp;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int temp =-1;\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                swap(grid[i][j], temp);\\n            }\\n        }\\n        swap(temp,grid[0][0]);\\n        return shiftGrid(grid,k-1);  //recursive call \\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n         if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        // set all the values of the matrix is zero\\n        vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return shiftGrid(v,k-1);  //recursive call     \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>>myfunction(vector<vector<int>>&grid, int m, int n){\\n          vector<vector<int>>v(m,vector<int>(n,0));\\n         for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==m-1 and j==n-1){\\n                    v[0][0]=grid[i][j];\\n                }\\n                else if(j==n-1){\\n                    v[i+1][0] = grid[i][j];\\n                }\\n                else{\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n        }\\n        return v;\\n    }  \\n    \\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0){\\n            return grid;\\n        }\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        vector<vector<int>>temp(m,vector<int>(n,0));\\n        while(k-->0){\\n            temp = myfunction(grid,m,n);\\n            grid = temp;   \\n        }\\n        \\n        return temp;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937324,
                "title": "c-clean",
                "content": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> shift_grid(m, vector<int> (n));\\n        \\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j) {\\n                int rowPlus = (j + k) / n;\\n                int colnOffset = (j + k) % n;\\n                int rowOffset = (i + rowPlus) % m;\\n                \\n                shift_grid[rowOffset][colnOffset] = grid[i][j];\\n            }\\n        return shift_grid;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> shift_grid(m, vector<int> (n));\\n        \\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j) {\\n                int rowPlus = (j + k) / n;\\n                int colnOffset = (j + k) % n;\\n                int rowOffset = (i + rowPlus) % m;\\n                \\n                shift_grid[rowOffset][colnOffset] = grid[i][j];\\n            }\\n        return shift_grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937312,
                "title": "c-solution-no-extra-space-hard-solution",
                "content": "Maybe the hardest solution but I found this approach a little intresting....\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size(),col=grid[0].size(),temp=grid[0][0],prev;\\n\\t\\tk=k%(row*col);\\n        while(k!=0){\\n\\t\\t\\n        for(int i=0;i<row;i++){\\n\\t\\t\\n            for(int j=0;j<col;j++){\\n\\t\\t\\t\\n                if(j==(col-1)){\\n\\t\\t\\t\\t\\n                    if(i==(row-1)){\\n\\t\\t\\t\\t\\t\\n                        grid[0][0]=temp;\\n                        swap(grid[0][0],grid[i][j]);\\n\\t\\t\\t\\t\\t\\t\\n                    }\\n\\t\\t\\t\\t\\t\\n                    else{\\n\\t\\t\\t\\t\\t\\n                        prev=grid[i][j];\\n                        grid[i][j]=temp;\\n                        temp=prev;\\n\\t\\t\\t\\t\\t\\t\\n                    }\\n\\t\\t\\t\\t\\t\\n                }\\n\\t\\t\\t\\t\\n                else{\\n\\t\\t\\t\\t\\n                    prev=grid[i][j];\\n                    grid[i][j]=temp;\\n                    temp=prev;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n           \\t}\\n\\t\\t\\t\\n            k--;\\n\\t\\t\\t\\n        }\\n\\t\\t\\n        return grid;      \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int row=grid.size(),col=grid[0].size(),temp=grid[0][0],prev;\\n\\t\\tk=k%(row*col);\\n        while(k!=0){\\n\\t\\t\\n        for(int i=0;i<row;i++){\\n\\t\\t\\n            for(int j=0;j<col;j++){\\n\\t\\t\\t\\n                if(j==(col-1)){\\n\\t\\t\\t\\t\\n                    if(i==(row-1)){\\n\\t\\t\\t\\t\\t\\n                        grid[0][0]=temp;\\n                        swap(grid[0][0],grid[i][j]);\\n\\t\\t\\t\\t\\t\\t\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1937310,
                "title": "simple-code-easy-to-understand",
                "content": "\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0)\\n            return grid;\\n        vector<int>v,ans,v4;\\n       int n= grid.size();\\n        vector<vector<int>>res;\\n        int m=grid[0].size();\\n        for(int i=0; i<n; i++)\\n        {\\n             \\n             for(int j=0; j<m; j++)\\n              {\\n                 v.push_back(grid[i][j]);\\n              }\\n        }\\n        int k1=k;\\n      \\n        k=k%(m*n);\\n           for(int j=v.size()-1; j>=v.size()-k; j--)\\n              {\\n                 ans.push_back(v[j]);\\n              }\\n        reverse(ans.begin(),ans.end());\\n        for(int j=0; j<v.size()-k; j++)\\n              {\\n                 ans.push_back(v[j]);\\n              }\\n         \\n        int j=1;\\n        vector<int>v3;\\n        for(int i=0; i<ans.size(); i++)\\n        {\\n            if(j%m==0)\\n            {   v3.push_back(ans[i]);\\n                res.push_back(v3);\\n                v3.clear();\\n            }\\n            else\\n                v3.push_back(ans[i]);\\n            j++;\\n            \\n            \\n        }\\n              \\n     return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        if(k==0)\\n            return grid;\\n        vector<int>v,ans,v4;\\n       int n= grid.size();\\n        vector<vector<int>>res;\\n        int m=grid[0].size();\\n        for(int i=0; i<n; i++)\\n        {\\n             \\n             for(int j=0; j<m; j++)\\n              {\\n                 v.push_back(grid[i][j]);\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1937228,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n   \\tpublic static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t\\tshift(grid);\\n\\n\\t\\tfor (int[] arr : grid) {\\n\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\tfor (int i = 0; i < arr.length; i++)\\n\\t\\t\\t\\tlist.add(Integer.valueOf(arr[i]));\\n\\t\\t\\tres.add(list);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tpublic static void shift(int[][] grid) {\\n\\t\\tList<Integer> lastElements = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < grid.length; i++) {\\n\\t\\t\\tlastElements.add(grid[i][grid[i].length - 1]);\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < grid.length; i++) {\\n\\n\\t\\t\\tfor (int j = grid[i].length - 1; j > 0; j--) {\\n\\t\\t\\t\\tgrid[i][j] = grid[i][j - 1];\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < grid.length; i++)\\n\\t\\t\\tif (i != grid.length - 1)\\n\\t\\t\\t\\tgrid[i + 1][0] = lastElements.get(i);\\n\\n\\t\\tgrid[0][0] = lastElements.get(lastElements.size() - 1);\\n\\n\\t}\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n   \\tpublic static List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t\\tshift(grid);\\n\\n\\t\\tfor (int[] arr : grid) {\\n\\t\\t\\tList<Integer> list = new ArrayList<>();\\n\\t\\t\\tfor (int i = 0; i < arr.length; i++)\\n\\t\\t\\t\\tlist.add(Integer.valueOf(arr[i]));\\n\\t\\t\\tres.add(list);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1937118,
                "title": "c-easy-understanding-algorithm-explanation",
                "content": "**Please Upvote If It Helps**\\n\\n**Algorithm**\\n* **Store all the values** in a **vector** temporary\\n\\n* Then maintain the **order that vector** \\n* Put **k values at the start from behind**\\n* Then after maintaining the order **make the pairs** according to the **size of column** \\n* after storing just **return** that \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        // store all the elements in a temp vector\\n        vector<int> temp;\\n        for(auto i : grid)\\n        {\\n            for(auto j : i)\\n            {\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        int n = temp.size();\\n        k = k % n;\\n        \\n        // for storing in the correct sequence\\n        vector<int> res; \\n        \\n        // last k vales at the start\\n        for(int i= n-k; i<n; i++)\\n        {\\n            res.push_back(temp[i]);\\n        }\\n        \\n        // starting values at the end\\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n        \\n        int m = grid[0].size();\\n        temp.clear();\\n        grid.clear();\\n        \\n        for(int i=0;i<res.size();i++)\\n        {\\n            if(temp.size() < m)\\n                temp.push_back(res[i]);\\n            \\n            if(temp.size()==m)\\n            {\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n    {\\n        // store all the elements in a temp vector\\n        vector<int> temp;\\n        for(auto i : grid)\\n        {\\n            for(auto j : i)\\n            {\\n                temp.push_back(j);\\n            }\\n        }\\n        \\n        int n = temp.size();\\n        k = k % n;\\n        \\n        // for storing in the correct sequence\\n        vector<int> res; \\n        \\n        // last k vales at the start\\n        for(int i= n-k; i<n; i++)\\n        {\\n            res.push_back(temp[i]);\\n        }\\n        \\n        // starting values at the end\\n        for(int i=0; i<n-k; i++){\\n             res.push_back(temp[i]);\\n        }\\n        \\n        int m = grid[0].size();\\n        temp.clear();\\n        grid.clear();\\n        \\n        for(int i=0;i<res.size();i++)\\n        {\\n            if(temp.size() < m)\\n                temp.push_back(res[i]);\\n            \\n            if(temp.size()==m)\\n            {\\n                grid.push_back(temp);\\n                temp.clear();\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937111,
                "title": "clean-code-c-fast-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        vector<vector<int>> ans(rows,vector<int>(cols,0));\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                int newVal=((i*cols+j)+k)%(rows*cols);\\n                int newR=newVal/cols;\\n                int newC=newVal%cols;\\n                ans[newR][newC]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        vector<vector<int>> ans(rows,vector<int>(cols,0));\\n        \\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                int newVal=((i*cols+j)+k)%(rows*cols);\\n                int newR=newVal/cols;\\n                int newC=newVal%cols;\\n                ans[newR][newC]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937107,
                "title": "c-simple-solution-single-traversal-m-n-extra-to-make-new-matrix",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        k = k % (m*n);\\n        vector<vector<int>> res(m, vector<int>(n, 0));\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                res[(((k + j) / n) + i) % m ][(k + j) % n] = grid[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        k = k % (m*n);\\n        vector<vector<int>> res(m, vector<int>(n, 0));\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                res[(((k + j) / n) + i) % m ][(k + j) % n] = grid[i][j];\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1937009,
                "title": "java-easy-beginner-less-complexity-based-on-o-1-space-solution",
                "content": "If you are familiar with [RotateArray](https://leetcode.com/problems/rotate-array/submissions/) and  [Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/) this is using concept of both .\\n\\njust assuming matrix as 1D array using arr[i/lenOfRow][i%lenOfRow] and reverse the array and fill the matrix into arraylist and return \\nTC:O(N*M)    SC:O(1)\\nComment if needed improvements ;)\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans= new ArrayList<>();\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int len=n*m;\\n            k=k%(m*n);\\n        reverse(grid,len-k,len-1);\\n        reverse(grid,0,len-k-1);\\n        reverse(grid,0,len-1);\\n        for(int i=0;i<m;i++){\\n              List<Integer> l= new ArrayList<>();\\n            for(int j=0;j<n;j++){\\n                l.add(grid[i][j]);\\n            }\\n            ans.add(l);       \\n        }\\n        return ans;\\n    }\\n    public void reverse(int [][] grid,int i,int j){\\n        int n=grid[0].length;\\n        while(i<j){\\n            int temp=grid[i/n][i%n];\\n            grid[i/n][i%n]=grid[j/n][j%n];\\n            grid[j/n][j%n]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> ans= new ArrayList<>();\\n        int m=grid.length;\\n        int n=grid[0].length;\\n        int len=n*m;\\n            k=k%(m*n);\\n        reverse(grid,len-k,len-1);\\n        reverse(grid,0,len-k-1);\\n        reverse(grid,0,len-1);\\n        for(int i=0;i<m;i++){\\n              List<Integer> l= new ArrayList<>();\\n            for(int j=0;j<n;j++){\\n                l.add(grid[i][j]);\\n            }\\n            ans.add(l);       \\n        }\\n        return ans;\\n    }\\n    public void reverse(int [][] grid,int i,int j){\\n        int n=grid[0].length;\\n        while(i<j){\\n            int temp=grid[i/n][i%n];\\n            grid[i/n][i%n]=grid[j/n][j%n];\\n            grid[j/n][j%n]=temp;\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936972,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int w = grid[0].size(), h = grid.size(), tot = h * w;\\n        div_t target;\\n        // fixing k if needed\\n        k %= tot;\\n        // edge case: no need to loop\\n        if (!k) return grid;\\n        for (int i = 0, lmt = gcd(tot, k), tmp, j; i < lmt; i++) {\\n            j = i;\\n            target = div(j, w);\\n            tmp = grid[target.quot][target.rem];\\n            do {\\n                j += k;\\n                if (j >= tot) j -= tot;\\n                target = div(j, w);\\n                swap(tmp, grid[target.quot][target.rem]);\\n            } while (j != i);\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936874,
                "title": "java-faster-than-98-right-rotation-of-array",
                "content": "**Flatten 2D Array to 1D Array and apply right rotation. Then convert back to 2D Array.**\\n\\n```\\n public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n      int n = grid.length, m = grid[0].length;  \\n      int arr[] = new int[n*m]; \\n        \\n      int ind = 0;\\n      for(int i=0; i<n; i++){\\n          for(int j=0; j<m; j++)\\n              arr[ind++] = grid[i][j];\\n      }\\n      \\n      k = k%(m*n);\\n      int left = n*m-k-1, right = n*m-k;\\n      reverse(0, left, arr);\\n      reverse(right, n*m-1, arr);\\n      reverse(0, n*m-1, arr);\\n        \\n      List<List<Integer>> ans = new ArrayList<>();\\n      for(int i=0; i<n; i++){\\n         List<Integer> temp = new ArrayList<>();\\n         for(int j=i*m; j<(i+1)*m; j++)\\n             temp.add(arr[j]);\\n         \\n         ans.add(temp);\\n       }\\n        \\n       return ans;\\n    }\\n    \\n    void reverse(int s, int e, int arr[]){\\n       int mid = (s+e)/2; \\n       for(int i=s, j=e; i<=mid && j>=mid; i++,j--){\\n          int temp = arr[i];\\n           arr[i] = arr[j];\\n           arr[j] = temp;\\n       }\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\n public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n      int n = grid.length, m = grid[0].length;  \\n      int arr[] = new int[n*m]; \\n        \\n      int ind = 0;\\n      for(int i=0; i<n; i++){\\n          for(int j=0; j<m; j++)\\n              arr[ind++] = grid[i][j];\\n      }\\n      \\n      k = k%(m*n);\\n      int left = n*m-k-1, right = n*m-k;\\n      reverse(0, left, arr);\\n      reverse(right, n*m-1, arr);\\n      reverse(0, n*m-1, arr);\\n        \\n      List<List<Integer>> ans = new ArrayList<>();\\n      for(int i=0; i<n; i++){\\n         List<Integer> temp = new ArrayList<>();\\n         for(int j=i*m; j<(i+1)*m; j++)\\n             temp.add(arr[j]);\\n         \\n         ans.add(temp);\\n       }\\n        \\n       return ans;\\n    }\\n    \\n    void reverse(int s, int e, int arr[]){\\n       int mid = (s+e)/2; \\n       for(int i=s, j=e; i<=mid && j>=mid; i++,j--){\\n          int temp = arr[i];\\n           arr[i] = arr[j];\\n           arr[j] = temp;\\n       }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936841,
                "title": "c-90-faster-41-space-8-lines",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n    int m = grid.size(), n=grid[0].size(), row, col, ele;\\n    vector<vector<int>> result(m, vector<int>(n,0));\\n    k%=(m*n);\\n    for(int i=0;i<m;++i)\\n        for(int j=0;j<n;++j){\\n            ele = (i*n)+j+k;\\n            row = (ele/n)%m;\\n            col = (j+k)%n;\\n            result[row][col] = grid[i][j];\\n        }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n    int m = grid.size(), n=grid[0].size(), row, col, ele;\\n    vector<vector<int>> result(m, vector<int>(n,0));\\n    k%=(m*n);\\n    for(int i=0;i<m;++i)\\n        for(int j=0;j<n;++j){\\n            ele = (i*n)+j+k;\\n            row = (ele/n)%m;\\n            col = (j+k)%n;\\n            result[row][col] = grid[i][j];\\n        }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936727,
                "title": "js-modulo-arithmetic-no-stdlib-methods-faster-than-98",
                "content": "This solution is based on a circular list approach, where we \"connect\" the end to the beginning. Knowing dimensions of a matrix, we can work with it as a 1-dimensional array, where iterating all elements looks like `rowIndex * rowSize + columnIndex`. This also means that given an element index `i`, we can find row and column indices - `rowIndex = i / rowSize` (as an integer), `columnIndex = i mod rowSize`.\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar shiftGrid = function(grid, k) {\\n  const xSize = grid[0].length;\\n  const elements = xSize * grid.length;\\n\\n  // no need to shift if it\\'s a full loop\\n  if (k === elements) {\\n    return grid;\\n  }\\n  \\n  const offset = k % elements;\\n  \\n  // use modulo arithmetic to map 1-dim array index to matrix row and column position (2-dim array)\\n  // X is a column index, Y is a row index\\n  const coord = (idx) => [\\n    idx % xSize, // X\\n    Math.floor(idx / xSize), // Y\\n  ];\\n  \\n  const overflow = Array(offset);\\n  for (let i = elements - 1; i >= 0; i--) {\\n    // matrix coordinates of where an element is going to be moved\\n    const [newX, newY] = coord(i);\\n\\n    // save the last \"offset\" elements to be prepended later\\n    if (i >= elements - offset) {\\n      overflow[elements - i - 1] = grid[newY][newX];\\n    }    \\n    \\n    // get the saved elements and write them to the beginning\\n    if (i < offset) {\\n      grid[newY][newX] = overflow[offset - i - 1];\\n      continue;\\n    }\\n    \\n    // move the rest by offset positions\\n    const [oldX, oldY] = coord(i - offset);\\n    grid[newY][newX] = grid[oldY][oldX];\\n  }\\n  \\n  return grid;\\n};\\n```\\n\\nI\\'m new to Leetcode and I don\\'t understand how performance measurement works but the best run was **80ms with 47MB** of memory used, which is **faster than 98.7% and takes less memory than 93.51%** of solutions at the time of submission.",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number} k\\n * @return {number[][]}\\n */\\nvar shiftGrid = function(grid, k) {\\n  const xSize = grid[0].length;\\n  const elements = xSize * grid.length;\\n\\n  // no need to shift if it\\'s a full loop\\n  if (k === elements) {\\n    return grid;\\n  }\\n  \\n  const offset = k % elements;\\n  \\n  // use modulo arithmetic to map 1-dim array index to matrix row and column position (2-dim array)\\n  // X is a column index, Y is a row index\\n  const coord = (idx) => [\\n    idx % xSize, // X\\n    Math.floor(idx / xSize), // Y\\n  ];\\n  \\n  const overflow = Array(offset);\\n  for (let i = elements - 1; i >= 0; i--) {\\n    // matrix coordinates of where an element is going to be moved\\n    const [newX, newY] = coord(i);\\n\\n    // save the last \"offset\" elements to be prepended later\\n    if (i >= elements - offset) {\\n      overflow[elements - i - 1] = grid[newY][newX];\\n    }    \\n    \\n    // get the saved elements and write them to the beginning\\n    if (i < offset) {\\n      grid[newY][newX] = overflow[offset - i - 1];\\n      continue;\\n    }\\n    \\n    // move the rest by offset positions\\n    const [oldX, oldY] = coord(i - offset);\\n    grid[newY][newX] = grid[oldY][oldX];\\n  }\\n  \\n  return grid;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936571,
                "title": "js-time-o-mn-space-o-1-in-place-operations",
                "content": "The main idea of the solution is to count greatest common divisor between number of shifts we need to make and the total amount of elements. gcd here will show us the number of operations, before our algorithm starts to cycle. After each cycle we will start to proceed the remaining elements. And so on.\\n\\n```\\nvar shiftGrid = function(grid, k) {\\n    const m=grid.length,n=grid[0].length,count=m*n;\\n    const turns = k%count;\\n    \\n    const divisor = gcd(count, turns);\\n    \\n    for (let i=0;i<divisor;i++) {\\n        let previousElement = grid[countX(i,n)][countY(i,n)]; // store initial element\\n        let currentElement = i; // current element index if we imagine our matrix as 1d array(x*m+y)\\n        for (let j=0;j<count/divisor;j++) {\\n            currentElement = (currentElement + k) % count; // shifting current element\\n            const x = countX(currentElement, n);\\n            const y = countY(currentElement, n);\\n            const temp = grid[x][y]; // performs swapping in old fashion way to reduce space complexity\\n            grid[x][y] = previousElement;\\n            previousElement = temp;\\n        }\\n    }\\n\\n    return grid;\\n};\\n\\nfunction countX(val, columns) {\\n    return ~~(val/columns); // surprisingly, it performs much faster than Math.trunc/round\\n}\\n\\nfunction countY(val, columns) {\\n    return val%columns;\\n}\\n\\nfunction gcd(a, b) {\\n  if (!b) {\\n    return a;\\n  }\\n\\n  return gcd(b, a % b);\\n}\\n```\\n\\nTime complexity: O(mn)\\nSpace complexity: O(1)\\nFeature: In-place",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftGrid = function(grid, k) {\\n    const m=grid.length,n=grid[0].length,count=m*n;\\n    const turns = k%count;\\n    \\n    const divisor = gcd(count, turns);\\n    \\n    for (let i=0;i<divisor;i++) {\\n        let previousElement = grid[countX(i,n)][countY(i,n)]; // store initial element\\n        let currentElement = i; // current element index if we imagine our matrix as 1d array(x*m+y)\\n        for (let j=0;j<count/divisor;j++) {\\n            currentElement = (currentElement + k) % count; // shifting current element\\n            const x = countX(currentElement, n);\\n            const y = countY(currentElement, n);\\n            const temp = grid[x][y]; // performs swapping in old fashion way to reduce space complexity\\n            grid[x][y] = previousElement;\\n            previousElement = temp;\\n        }\\n    }\\n\\n    return grid;\\n};\\n\\nfunction countX(val, columns) {\\n    return ~~(val/columns); // surprisingly, it performs much faster than Math.trunc/round\\n}\\n\\nfunction countY(val, columns) {\\n    return val%columns;\\n}\\n\\nfunction gcd(a, b) {\\n  if (!b) {\\n    return a;\\n  }\\n\\n  return gcd(b, a % b);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936568,
                "title": "a-in-place-solution",
                "content": "It consists of two concepts:\\n1. In-place array shifting/rotating can be decomposed into 3 reverse operations.\\n\\te.x.\\n\\t\\t[1, 2, 3, 4, 5] right rotate 2  => [4, 5, 1, 2, 3]\\n\\tequals to \\n\\t\\t[1, 2, 3, 4, 5] reverse  =>  [5, 4, 3, 2, 1] reverse first 2  => [<u>4, 5</u>, 3, 2, 1] reverse rest of the elements  =>  [4, 5, <u>1, 2, 3</u>]\\n2. The coordinate conversion between 1D and 2D can be achieved by \\'/\\' and \\'%\\' operators with the width n of the 2D matrix.\\n```\\nvoid reverse(vector<vector<int>>& grid, int n, int a, int b)\\n{\\n\\tint ix, iy, jx, jy;\\n\\t\\n\\tfor (int i = a, j = b; i < j; ++i, --j)\\n\\t{\\n\\t\\tix = i / n;\\n\\t\\tiy = i % n;\\n\\t\\tjx = j / n;\\n\\t\\tjy = j % n;\\n\\t\\t\\n\\t\\tswap(grid[ix][iy], grid[jx][jy]);\\n\\t}\\n}\\n\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size();\\n\\tint n = grid[0].size();\\n\\tint l = m * n;\\n\\tk %= l;\\n\\t\\n\\treverse(grid, n, 0, l - 1);\\n\\treverse(grid, n, 0, k - 1);\\n\\treverse(grid, n, k, l - 1);\\n\\t\\n\\treturn grid;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid reverse(vector<vector<int>>& grid, int n, int a, int b)\\n{\\n\\tint ix, iy, jx, jy;\\n\\t\\n\\tfor (int i = a, j = b; i < j; ++i, --j)\\n\\t{\\n\\t\\tix = i / n;\\n\\t\\tiy = i % n;\\n\\t\\tjx = j / n;\\n\\t\\tjy = j % n;\\n\\t\\t\\n\\t\\tswap(grid[ix][iy], grid[jx][jy]);\\n\\t}\\n}\\n\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\tint m = grid.size();\\n\\tint n = grid[0].size();\\n\\tint l = m * n;\\n\\tk %= l;\\n\\t\\n\\treverse(grid, n, 0, l - 1);\\n\\treverse(grid, n, 0, k - 1);\\n\\treverse(grid, n, k, l - 1);\\n\\t\\n\\treturn grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936555,
                "title": "c-3-approaches-in-decreasing-order-of-intuitiveness",
                "content": "### **Approach 1:** Brute Force Shifting using temp matrix\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> temp = grid;\\n        k = k%(m*n);\\n        \\n        while(k--) {\\n            // Shifting all columns except 0th column\\n            for(int i=0; i<m; i++) {\\n                for(int j=1; j<n; j++) {\\n                    temp[i][j] = grid[i][j-1]; \\n                }\\n            }\\n            // Modifying first column\\n            for(int i=0; i<m-1; i++)\\n                temp[i+1][0] = grid[i][n-1];\\n            // First element case\\n            temp[0][0] = grid[m-1][n-1];\\n            grid = temp;  // temp is the new grid\\n        }\\n        return grid;\\n    }\\n};\\n```\\n---\\n### **Approach 2:** Convert Matrix to 1-D Array (Brute Force)\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);    // For k>m*n\\n        vector<int> vect;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                vect.push_back(grid[i][j]);\\n            }\\n        }\\n        vector<int> t = vect;\\n        vect.insert(vect.begin(), t.begin()+m*n-k, t.end()); // Performing shift in 1-D Vector\\n        int id=0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                grid[i][j] = vect[id];  // Copying shifted values back to 2-D Matrix\\n                id++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\\n---\\n### **Approach 3:** Calculate New Position of each element(Better Version of Approach 2)\\nFor an M*N matrix \\\\-\\n- 1-D index for [i, j] = `i*N + j`\\n- Shift 1-D index : `index = (index+k)%(M*N)`\\n- Calculate shifted 2-D coordinates : `[index/N, index%N]`\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int index = i*n + j;\\n                index = (index+k)%(m*n);\\n                int newI = index/n;\\n                int newJ = index%n;\\n                ans[newI][newJ] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> temp = grid;\\n        k = k%(m*n);\\n        \\n        while(k--) {\\n            // Shifting all columns except 0th column\\n            for(int i=0; i<m; i++) {\\n                for(int j=1; j<n; j++) {\\n                    temp[i][j] = grid[i][j-1]; \\n                }\\n            }\\n            // Modifying first column\\n            for(int i=0; i<m-1; i++)\\n                temp[i+1][0] = grid[i][n-1];\\n            // First element case\\n            temp[0][0] = grid[m-1][n-1];\\n            grid = temp;  // temp is the new grid\\n        }\\n        return grid;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);    // For k>m*n\\n        vector<int> vect;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                vect.push_back(grid[i][j]);\\n            }\\n        }\\n        vector<int> t = vect;\\n        vect.insert(vect.begin(), t.begin()+m*n-k, t.end()); // Performing shift in 1-D Vector\\n        int id=0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                grid[i][j] = vect[id];  // Copying shifted values back to 2-D Matrix\\n                id++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        k = k%(m*n);\\n        vector<vector<int>> ans(m, vector<int>(n));\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int index = i*n + j;\\n                index = (index+k)%(m*n);\\n                int newI = index/n;\\n                int newJ = index%n;\\n                ans[newI][newJ] = grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936534,
                "title": "simple-python-using-deque",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for x in range(k):\\n            lst=collections.deque()\\n            for i in range(len(grid)):\\n                grid[i]=collections.deque(grid[i])\\n                grid[i].rotate(1)\\n                # print(i)\\n                lst.append(grid[i][0])\\n            # print(grid)\\n            lst.rotate(1)\\n            for i in grid:\\n                a=lst.popleft()\\n                i[0]=a\\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for x in range(k):\\n            lst=collections.deque()\\n            for i in range(len(grid)):\\n                grid[i]=collections.deque(grid[i])\\n                grid[i].rotate(1)\\n                # print(i)\\n                lst.append(grid[i][0])\\n            # print(grid)\\n            lst.rotate(1)\\n            for i in grid:\\n                a=lst.popleft()\\n                i[0]=a\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936475,
                "title": "python3-shifting-in-2d-simple",
                "content": "Here I have shifted in 2D List in an extended manner (without using any list comprehension or one liner). It can also be done in shorter and more efficient manner.\\n**Logic:** Pop the last element from each sub list and insert it at 0 index in another sub list and for last sub list pop the last element and insert it at 0 index in first sub list.\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for j in range(k):  # Shifting k times\\n            for i in range(len(grid)):  # Shifting without disturbing the structure\\n                if i==len(grid)-1:\\n                    a=grid[i].pop()\\n                    grid[0].insert(0,a)\\n                else:\\n                    a=grid[i].pop()\\n                    grid[i+1].insert(0,a)\\n        return grid\\n```\\n**Please upvote if the solution helps**\\n**Feel free to ask any question**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        for j in range(k):  # Shifting k times\\n            for i in range(len(grid)):  # Shifting without disturbing the structure\\n                if i==len(grid)-1:\\n                    a=grid[i].pop()\\n                    grid[0].insert(0,a)\\n                else:\\n                    a=grid[i].pop()\\n                    grid[i+1].insert(0,a)\\n        return grid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936463,
                "title": "c-solution-basic-optimized",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\t\\n        vector<vector<int>>temp;\\n        temp=grid;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    temp[i][j]=grid[i][j-1];\\n                }\\n            }\\n            for(int i=0;i<m-1;i++)temp[i+1][0]=grid[i][n-1];\\n            temp[0][0]=grid[m-1][n-1];\\n            grid=temp;\\n        }\\n        return temp;\\n    }\\n};\\n(Optimized)\\nClass Solution {\\npublic:\\n    \\n\\tvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) \\n\\t          {   \\n\\t        int m=grid.size();\\n            int n=grid[0].size();\\n           vector<vector<int>>temp(m,vector<int>(n));\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n                temp[(i+(j+k)/n)%m][(j+k)%n]=grid[i][j];\\n        }\\n        return temp;\\n    }\\n};\\n**Please do upvote if you liked it!**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\t\\n        vector<vector<int>>temp;\\n        temp=grid;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        while(k--)\\n        {\\n            for(int i=0;i<m;i++)\\n            {\\n                for(int j=1;j<n;j++)\\n                {\\n                    temp[i][j]=grid[i][j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1936392,
                "title": "python-flatten-array-and-convert-back-2d",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        N = rows*cols\\n        shift = k%N # since max shift is N - 1 otherwise it\\'s just a cycle\\n        \\n        if shift == 0: # no need to shift\\n            return grid\\n\\t\\t\\t\\n        # flatten array\\n        flattened = []\\n        for y in range(rows):\\n            for x in range(cols):\\n                flattened.append(grid[y][x])\\n                \\n\\t\\t# shift array\\n        flattened = flattened[-shift:] + flattened[:-shift]\\n\\t\\t\\n        return  [[ flattened[y*cols + x] for x in range(cols)] for y in range(rows)] #convert back to 2d array\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        \\n        rows = len(grid)\\n        cols = len(grid[0])\\n        N = rows*cols\\n        shift = k%N # since max shift is N - 1 otherwise it\\'s just a cycle\\n        \\n        if shift == 0: # no need to shift\\n            return grid\\n\\t\\t\\t\\n        # flatten array\\n        flattened = []\\n        for y in range(rows):\\n            for x in range(cols):\\n                flattened.append(grid[y][x])\\n                \\n\\t\\t# shift array\\n        flattened = flattened[-shift:] + flattened[:-shift]\\n\\t\\t\\n        return  [[ flattened[y*cols + x] for x in range(cols)] for y in range(rows)] #convert back to 2d array\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936366,
                "title": "python-simple-solution-faster-than-90",
                "content": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        a=[]\\n        ans1=[]\\n        ans=[]\\n        c=0\\n        if m==1 and n==1:\\n            return grid\\n        for i in range(m):\\n            for j in range(n):\\n                a.append(grid[i][j])\\n        l=len(a)\\n        for i in range(k):\\n            x=a[l-1]\\n            a.pop(l-1)\\n            a.insert(0,x)\\n        for i in range(l):\\n            if c==n:\\n                ans1.append(ans)\\n                ans=[]\\n                c=0\\n            ans.append(a[i])\\n            c+=1\\n        ans1.append(ans)\\n        return(ans1)      \\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m=len(grid)\\n        n=len(grid[0])\\n        a=[]\\n        ans1=[]\\n        ans=[]\\n        c=0\\n        if m==1 and n==1:\\n            return grid\\n        for i in range(m):\\n            for j in range(n):\\n                a.append(grid[i][j])\\n        l=len(a)\\n        for i in range(k):\\n            x=a[l-1]\\n            a.pop(l-1)\\n            a.insert(0,x)\\n        for i in range(l):\\n            if c==n:\\n                ans1.append(ans)\\n                ans=[]\\n                c=0\\n            ans.append(a[i])\\n            c+=1\\n        ans1.append(ans)\\n        return(ans1)      \\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936342,
                "title": "cpp-easy",
                "content": "class Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //get the row and col\\n        int m=grid.size();//row\\n        int n=grid[0].size();//col\\n        // create a space for storing value\\n        vector<vector<int>> temp(m,vector<int>(n,0));\\n        //use for loopto store value\\n        for(int r=0;r<m;r++){\\n            for(int c=0;c<n;c++){\\n                //assume that it will be in single array and add the k poistion\\n                int newVal=((r*n +c)+k)%(m*n);\\n                //create newr and newc\\n                int newr=newVal/n;\\n                int newc=newVal%n;\\n                //store the result in temp\\n                temp[newr][newc]=grid[r][c];\\n            }\\n        }\\n        return temp;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        //get the row and col\\n        int m=grid.size();//row\\n        int n=grid[0].size();//col\\n        // create a space for storing value\\n        vector<vector<int>> temp(m,vector<int>(n,0));\\n        //use for loopto store value\\n        for(int r=0;r<m;r++){\\n            for(int c=0;c<n;c++){\\n                //assume that it will be in single array and add the k poistion\\n                int newVal=((r*n +c)+k)%(m*n);\\n                //create newr and newc\\n                int newr=newVal/n;\\n                int newc=newVal%n;\\n                //store the result in temp\\n                temp[newr][newc]=grid[r][c];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1936218,
                "title": "python-very-easy-o-1-space",
                "content": "**Solution 1**\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        d = m*n\\n        ans = [[0] * n for _ in range(m)]\\n        \\n        start = d - k\\n        for i in range(m):\\n            for j in range(n):\\n                start %= d\\n                r = start // n\\n                c = start % n\\n                ans[i][j] = grid[r][c]\\n                start += 1\\n        return ans\\n```\\n\\n***\\n```Time Complexity: O(N*M)```\\n```Space Complexity: O(N*M)```\\n***\\n\\n\\n**Solution 2**\\nSame approach as this question  [Click](https://leetcode.com/problems/rotate-array/)\\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def reverse(start, end, n):\\n            while start < end:\\n                grid[start // n][start % n], grid[end // n][end % n] = grid[end // n][end % n], grid[start // n][start % n]\\n                start += 1\\n                end -= 1\\n        \\n        n = len(grid[0])\\n        d = len(grid) * n\\n        k = k % d\\n        reverse(0, d - k - 1, n)\\n        reverse(d - k, d - 1, n)\\n        reverse(0, d - 1, n)\\n        \\n        return grid\\n```\\n\\n***\\n```Time Complexity: O(N*M)```\\n```Space Complexity: O(1)```\\n***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m = len(grid)\\n        n = len(grid[0])\\n        d = m*n\\n        ans = [[0] * n for _ in range(m)]\\n        \\n        start = d - k\\n        for i in range(m):\\n            for j in range(n):\\n                start %= d\\n                r = start // n\\n                c = start % n\\n                ans[i][j] = grid[r][c]\\n                start += 1\\n        return ans\\n```\n```Time Complexity: O(N*M)```\n```Space Complexity: O(N*M)```\n```\\nclass Solution:\\n    def shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        def reverse(start, end, n):\\n            while start < end:\\n                grid[start // n][start % n], grid[end // n][end % n] = grid[end // n][end % n], grid[start // n][start % n]\\n                start += 1\\n                end -= 1\\n        \\n        n = len(grid[0])\\n        d = len(grid) * n\\n        k = k % d\\n        reverse(0, d - k - 1, n)\\n        reverse(d - k, d - 1, n)\\n        reverse(0, d - 1, n)\\n        \\n        return grid\\n```\n```Time Complexity: O(N*M)```\n```Space Complexity: O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1936191,
                "title": "c-o-1-space-solution",
                "content": "# **Non Constant Space Solution**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& A, int k) {\\n        int n = A.size(), m = A[0].size();\\n        vector<int> B; // just convert the grid array to 1D array\\n        vector<vector<int>> result(n, vector<int>(m)); // return array\\n        k %= n * m;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                B.push_back(A[i][j]);\\n        for(int i = k; i < B.size(); i++){\\n            int row = i / m, col = i % m; // finding out the index \\n\\t\\t\\t// in 2D array. For example, if \"i\" is equal to 5 (6th element) and array is 3x4\\n\\t\\t\\t// the 6th element of B will be placed to \\n\\t\\t\\t// row = i / m = 5 / 4 = 1,   col = i % m = 5 % 4 = 1\\n\\t\\t\\t// So, it will be placed in result[1][1]\\n            result[row][col] = B[i - k];\\n        }\\n        for(int i = 0; i < k; i++){\\n            int row = i / m, col = i % m;\\n            result[row][col] = B[B.size() - k + i];\\n        }\\n        return result;\\n    }\\n};\\n```\\n```\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n```\\n# **O(1) Space Solution**\\nThe Testcase: \\n```\\n[1, 2, 3]\\n[4, 5, 6]\\n[7, 8, 9]\\nk = 2\\n```\\n**The Explanation:**\\nThe idea is simple, let\\'s assume that the given array grid is 1D array, to rotate it, we will just need to do 3 reverse operations:\\n1. reverse the whole array:\\n2. reverse the values before k [0, k - 1]\\n3. reverse the values from k to the end [k, n * m - 1]\\n\\nAfter the first reverse operation (reverse the whole array):\\n```\\n[9 ,8, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\\nAfter the second reverse operation (reverse the values before k):\\n```\\n[8, 9, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\\nAnd finally, after the third operation (reverse the values from k to the end) we get:\\n```\\n[8, 9, 1]\\n[2, 3, 4]\\n[5, 6, 7]\\n```\\nWhich is the right answer!\\n\\nHere is the **implementation**: \\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        n = grid.size(), m = grid[0].size(), k %= n * m;\\n        reverse(grid, 0, n * m - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, n * m - 1);\\n        return grid;\\n    }\\n    void reverse(vector<vector<int>>& grid, int i, int j){\\n        while(i < j){\\n            int rowI = i / m, colI = i % m, rowJ = j / m, colJ = j % m;\\n            int temp = grid[rowI][colI];\\n            grid[rowI][colI] = grid[rowJ][colJ];\\n            grid[rowJ][colJ] = temp;\\n            i++, j--;\\n        }\\n    }\\n};\\n```\\n```\\nTime Complexity: O(n * m)\\nSpace Complexity: O(1)\\n```\\n\\n**Hope it helped! Your Upvote can make my day :D**\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& A, int k) {\\n        int n = A.size(), m = A[0].size();\\n        vector<int> B; // just convert the grid array to 1D array\\n        vector<vector<int>> result(n, vector<int>(m)); // return array\\n        k %= n * m;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++)\\n                B.push_back(A[i][j]);\\n        for(int i = k; i < B.size(); i++){\\n            int row = i / m, col = i % m; // finding out the index \\n\\t\\t\\t// in 2D array. For example, if \"i\" is equal to 5 (6th element) and array is 3x4\\n\\t\\t\\t// the 6th element of B will be placed to \\n\\t\\t\\t// row = i / m = 5 / 4 = 1,   col = i % m = 5 % 4 = 1\\n\\t\\t\\t// So, it will be placed in result[1][1]\\n            result[row][col] = B[i - k];\\n        }\\n        for(int i = 0; i < k; i++){\\n            int row = i / m, col = i % m;\\n            result[row][col] = B[B.size() - k + i];\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nTime Complexity: O(m * n)\\nSpace Complexity: O(m * n)\\n```\n```\\n[1, 2, 3]\\n[4, 5, 6]\\n[7, 8, 9]\\nk = 2\\n```\n```\\n[9 ,8, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\n```\\n[8, 9, 7]\\n[6, 5, 4]\\n[3, 2, 1]\\n```\n```\\n[8, 9, 1]\\n[2, 3, 4]\\n[5, 6, 7]\\n```\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        n = grid.size(), m = grid[0].size(), k %= n * m;\\n        reverse(grid, 0, n * m - 1);\\n        reverse(grid, 0, k - 1);\\n        reverse(grid, k, n * m - 1);\\n        return grid;\\n    }\\n    void reverse(vector<vector<int>>& grid, int i, int j){\\n        while(i < j){\\n            int rowI = i / m, colI = i % m, rowJ = j / m, colJ = j % m;\\n            int temp = grid[rowI][colI];\\n            grid[rowI][colI] = grid[rowJ][colJ];\\n            grid[rowJ][colJ] = temp;\\n            i++, j--;\\n        }\\n    }\\n};\\n```\n```\\nTime Complexity: O(n * m)\\nSpace Complexity: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936181,
                "title": "daily-leetcoding-challenge-april-day-11-solution",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k = k%(m*n);\\n        int a;\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n            for(int i=0;i<k;i++){\\n                a = v[m*n - 1];\\n                v.pop_back();\\n                v.insert (v.begin(), a);\\n            }\\n            int x = 0;\\n            for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                grid[i][j] = v[x];\\n                x++;\\n            }\\n        }\\n        return grid;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        k = k%(m*n);\\n        int a;\\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                v.push_back(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1936143,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        k= k% (r*c);\\n        while(k-->0){\\n            int last = grid[r-1][c-1];\\n            for(int i=r-1;i>=0;i--){\\n                for(int j=c-1;j>=0;j--){\\n                    if(i==0 && j==0) grid[i][j]=last;\\n                    else if( i!=0 && j==0) grid[i][j]=grid[i-1][c-1];\\n                    else grid[i][j] = grid[i][j-1];\\n                }\\n            }\\n           \\n        }\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        int r = grid.length;\\n        int c = grid[0].length;\\n        k= k% (r*c);\\n        while(k-->0){\\n            int last = grid[r-1][c-1];\\n            for(int i=r-1;i>=0;i--){\\n                for(int j=c-1;j>=0;j--){\\n                    if(i==0 && j==0) grid[i][j]=last;\\n                    else if( i!=0 && j==0) grid[i][j]=grid[i-1][c-1];\\n                    else grid[i][j] = grid[i][j-1];\\n                }\\n            }\\n           \\n        }\\n        \\n        ArrayList<Integer> list = new ArrayList<>();\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936041,
                "title": "c-100-faster-than-all-bruteforce-single-pass-approch",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n//         Brute force Time limit exceed error\\n        // while(k){\\n        //     int temp=grid[grid.size()-1][grid[0].size()-1];\\n        //     for(int i=grid.size()-1;i>=0;i--){\\n        //         for(int j=grid[i].size()-1;j>0;j--){\\n        //             cout<<i<<\" , \"<<j<<endl;\\n        //             grid[i][j]=grid[i][j-1];\\n        //         }\\n        //         if(i>0)\\n        //             grid[i][0]=grid[i-1][grid[i].size()-1];\\n        //         // for(int i=0;i<grid.size();i++){\\n        //         //     for(int j=0;j<grid[i].size();j++){\\n        //         //         cout<<grid[i][j]<<\" \";\\n        //         //     }\\n        //         //     cout<<endl;\\n        //         // }\\n        //     }\\n        //     grid[0][0]=temp;\\n        //  k--;   \\n        // }\\n        // return grid;\\n        //\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int newj=(j+k)%n;\\n                int newi = (i+(j+k)/n)%m;\\n                ans[newi][newj]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n//         Brute force Time limit exceed error\\n        // while(k){\\n        //     int temp=grid[grid.size()-1][grid[0].size()-1];\\n        //     for(int i=grid.size()-1;i>=0;i--){\\n        //         for(int j=grid[i].size()-1;j>0;j--){\\n        //             cout<<i<<\" , \"<<j<<endl;\\n        //             grid[i][j]=grid[i][j-1];\\n        //         }\\n        //         if(i>0)\\n        //             grid[i][0]=grid[i-1][grid[i].size()-1];\\n        //         // for(int i=0;i<grid.size();i++){\\n        //         //     for(int j=0;j<grid[i].size();j++){\\n        //         //         cout<<grid[i][j]<<\" \";\\n        //         //     }\\n        //         //     cout<<endl;\\n        //         // }\\n        //     }\\n        //     grid[0][0]=temp;\\n        //  k--;   \\n        // }\\n        // return grid;\\n        //\\n        int m=grid.size(),n=grid[0].size();\\n        vector<vector<int>> ans(m,vector<int>(n));\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int newj=(j+k)%n;\\n                int newi = (i+(j+k)/n)%m;\\n                ans[newi][newj]=grid[i][j];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1936035,
                "title": "daily-challenge-11-04-2022-faster-than-99-solution",
                "content": "The trick is to make a function for shifting grid by 1 position.\\nAfter that is done, just run a loop K times calling that function and return the answer!\\n\\n```\\nclass Solution {\\n    \\n    public int[][] oneShift(int[][] grid, int m, int n) \\n    {           \\n        int newVal= grid[m-1][n-1];\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int temp= grid[i][j];\\n                grid[i][j]= newVal;\\n                newVal= temp;\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) \\n    {\\n        while(k-->0) {\\n            grid= oneShift(grid, grid.length, grid[0].length);\\n        }\\n\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int[][] oneShift(int[][] grid, int m, int n) \\n    {           \\n        int newVal= grid[m-1][n-1];\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int temp= grid[i][j];\\n                grid[i][j]= newVal;\\n                newVal= temp;\\n            }\\n        }\\n        \\n        return grid;\\n    }\\n    \\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) \\n    {\\n        while(k-->0) {\\n            grid= oneShift(grid, grid.length, grid[0].length);\\n        }\\n\\n        return (List)Arrays.asList(grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935927,
                "title": "c-o-m-n",
                "content": "```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\\n    *returnSize = gridSize;\\n    *returnColumnSizes = calloc(gridSize, sizeof(int));\\n    for (int i = 0; i < gridSize; i++)\\n        *((*returnColumnSizes) + i) = *gridColSize;\\n\\n    if (k == gridSize * *gridColSize || (1 == gridSize && 1 == *gridColSize))\\n        return grid;\\n    \\n    k %= gridSize * *gridColSize;\\n    int *shifted = calloc(gridSize * *gridColSize, sizeof(int));\\n    int ptr = k;\\n    \\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++) {\\n            *(shifted + ptr) = *(*(grid + i) + j);\\n            if (gridSize * *gridColSize == ++ptr)\\n                ptr = 0;\\n        }\\n    }\\n\\n    ptr = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++)\\n            *(*(grid + i) + j) = *(shifted + ptr++);\\n    }\\n    \\n    return grid;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint** shiftGrid(int** grid, int gridSize, int* gridColSize, int k, int* returnSize, int** returnColumnSizes){\\n    *returnSize = gridSize;\\n    *returnColumnSizes = calloc(gridSize, sizeof(int));\\n    for (int i = 0; i < gridSize; i++)\\n        *((*returnColumnSizes) + i) = *gridColSize;\\n\\n    if (k == gridSize * *gridColSize || (1 == gridSize && 1 == *gridColSize))\\n        return grid;\\n    \\n    k %= gridSize * *gridColSize;\\n    int *shifted = calloc(gridSize * *gridColSize, sizeof(int));\\n    int ptr = k;\\n    \\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++) {\\n            *(shifted + ptr) = *(*(grid + i) + j);\\n            if (gridSize * *gridColSize == ++ptr)\\n                ptr = 0;\\n        }\\n    }\\n\\n    ptr = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++)\\n            *(*(grid + i) + j) = *(shifted + ptr++);\\n    }\\n    \\n    return grid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935923,
                "title": "171ms-solution-easiest-explanation-python",
                "content": "The trickiest part in this problem is to handle the edge elements. If the value is at the last column of a row, then we have to shift it to the first column of the next row. Interestingly using this approach is the key to this problem.\\n\\n---\\nLet\\'s only focus on a matrix of two rows for now.\\n\\nWhat we need to do is \\'pop\\' the element from the second row and \\'insert\\' it at the first index of the first row.\\nNow if `m` is the number of elements in a row(or columns in the matrix), then after this operation the first row has `m+1` elements and the second row has `m-1` elements.\\nBut we still have to `pop` the last element of the first row and insert it the `0`<sup>th</sup> index of the second one to complete the iteration.\\nOn doing this operation, both our rows have the same number of elements, `m`, and our matrix is successfully shifted by one.\\n\\nWe need to repeat this cycle `k` times to arrive at the expected output.\\nFor a generalized solution for matrices with more than 2 rows, check out the well-documented python code below.\\n\\n---\\n**Time Complexity: O(kmn)** where **k** is the number of elements, **m** is the number of columns and **n** is the number of rows\\n\\n**Space Complexity: O(1)** as no extra space is required\\n\\n*Do upvote if you found the explanation deserving enough. Thanks for reading!*\\n\\n---\\nPython code:\\n```\\ndef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        while k>0:\\n            # Pop the last element from the last row of the matrix\\n\\t        curr_elem=grid[-1].pop()\\n            \\n            # Loop through all the rows except the last one\\n\\t        for i in range(rows-1):\\n                # Insert the last element popped at each iteration at\\n                # the first position of the current row of the matrix\\n                \\n                # This step takes care of the edge elements\\n\\t\\t        grid[i].insert(0,curr_elem)\\n                \\n                # Update curr with the value of latest popped element\\n                # from current row\\n\\t\\t        curr_elem=grid[i].pop()\\n            \\n            # Insert the latest curr element at the first position of the last row\\n\\t        grid[-1].insert(0,curr_elem)\\n\\t        k-=1  \\n        return grid\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\ndef shiftGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        rows = len(grid)\\n        while k>0:\\n            # Pop the last element from the last row of the matrix\\n\\t        curr_elem=grid[-1].pop()\\n            \\n            # Loop through all the rows except the last one\\n\\t        for i in range(rows-1):\\n                # Insert the last element popped at each iteration at\\n                # the first position of the current row of the matrix\\n                \\n                # This step takes care of the edge elements\\n\\t\\t        grid[i].insert(0,curr_elem)\\n                \\n                # Update curr with the value of latest popped element\\n                # from current row\\n\\t\\t        curr_elem=grid[i].pop()\\n            \\n            # Insert the latest curr element at the first position of the last row\\n\\t        grid[-1].insert(0,curr_elem)\\n\\t        k-=1  \\n        return grid\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1935919,
                "title": "simple-solution-c",
                "content": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> v(m,vector<int>(n));\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n-1;j++){\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n            for(int i=0;i<m-1;i++){\\n                v[i+1][0]=grid[i][n-1];\\n            }\\n            v[0][0]=grid[m-1][n-1];\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    grid[i][j]=v[i][j];\\n                    v[i][j]=0;\\n                }\\n            }\\n        }   \\n        \\n        return grid;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        \\n        int m=grid.size();\\n        int n = grid[0].size();\\n        vector<vector<int>> v(m,vector<int>(n));\\n        while(k--){\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n-1;j++){\\n                    v[i][j+1]=grid[i][j];\\n                }\\n            }\\n            for(int i=0;i<m-1;i++){\\n                v[i+1][0]=grid[i][n-1];\\n            }\\n            v[0][0]=grid[m-1][n-1];\\n            for(int i=0;i<m;i++){\\n                for(int j=0;j<n;j++){\\n                    grid[i][j]=v[i][j];\\n                    v[i][j]=0;\\n                }\\n            }\\n        }   \\n        \\n        return grid;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1935728,
                "title": "c-easy-to-understand-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        int total=m*n;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                int pos=i*m+j;\\n                \\n                int pos1=(pos+k)%total;\\n                int row=pos1/m;\\n                int col=pos1%m;\\n                \\n                ans[row][col]=grid[i][j];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        int total=m*n;\\n        vector<vector<int>> ans(n,vector<int>(m,0));\\n        \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                int pos=i*m+j;\\n                \\n                int pos1=(pos+k)%total;\\n                int row=pos1/m;\\n                int col=pos1%m;\\n                \\n                ans[row][col]=grid[i][j];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935704,
                "title": "c-simplest-solution-convert-to-1d-array",
                "content": "**Time Complexity :** ```O(m*n)```\\n\\n**Space Complexity :** ```O(m*n)```\\n\\n\\n**APPROACH :**\\n\\n* Convert the array into a 1D array ```v```.\\n\\n* Reverse the array from index ```0``` to index ```v.size() - k - 1```.\\n\\n* Then reverse the array from index ```v.size() - k``` to ```v.size() - 1```.\\n\\n* Then reverse the whole array.\\n\\n** ( Do a dry run on 1 of the examples to understand)\\n\\n**Code :**\\n```\\nclass Solution {\\n    void reverse(vector<int> &v, int start, int end) {\\n        while(start < end) {\\n            swap(v[start++], v[end--]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        vector<int> v;\\n        \\n        for(auto &i: grid) {\\n            for(auto &j: i) {\\n                v.push_back(j);\\n            }\\n        }\\n        \\n        k = k%v.size();\\n        reverse(v, 0, v.size()-k-1);\\n        reverse(v, v.size()-k, v.size()-1);\\n        reverse(v, 0, v.size()-1);\\n        \\n        int vec = 0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n               grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```\\n**Do upvote if you like my solution :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```O(m*n)```\n```O(m*n)```\n```v```\n```0```\n```v.size() - k - 1```\n```v.size() - k```\n```v.size() - 1```\n```\\nclass Solution {\\n    void reverse(vector<int> &v, int start, int end) {\\n        while(start < end) {\\n            swap(v[start++], v[end--]);\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        int m=grid.size(), n=grid[0].size();\\n        \\n        vector<int> v;\\n        \\n        for(auto &i: grid) {\\n            for(auto &j: i) {\\n                v.push_back(j);\\n            }\\n        }\\n        \\n        k = k%v.size();\\n        reverse(v, 0, v.size()-k-1);\\n        reverse(v, v.size()-k, v.size()-1);\\n        reverse(v, 0, v.size()-1);\\n        \\n        int vec = 0;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n               grid[i][j] = v[vec];\\n                vec++;\\n            }\\n        }\\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935646,
                "title": "easy-c-o-k-m-n-solution",
                "content": "**Algorithm**\\n\\n* Preserve the last index element.\\n* copy all index to their next\\n* Copy the saved last element to first\\n* Apply a set of if-else blocks for boundary conditions\\n* Repeat the above 3 steps k times.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\n        while(k--)\\n        {\\n            int element = grid[0][0],nextElement;\\n            for(int i=0;i<grid.size();i++)\\n        {\\n            int m = grid.size();\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                int n= grid[i].size();\\n                \\n                if(i == (m-1) && j == (n-1))\\n                {\\n                    nextElement = grid[0][0];\\n                    grid[0][0] = element;\\n                    element = nextElement;\\n                }\\n                else if(j == (n-1))\\n                {\\n                    nextElement = grid[i+1][0]; \\n                    grid[i+1][0] = element; \\n                    element = nextElement; \\n                }\\n                else{\\n                    nextElement = grid[i][j+1]; \\n                    grid[i][j+1] = element; \\n                    element = nextElement; \\n                }\\n            }\\n        }\\n        }\\n\\n        \\n        return grid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n\\n        while(k--)\\n        {\\n            int element = grid[0][0],nextElement;\\n            for(int i=0;i<grid.size();i++)\\n        {\\n            int m = grid.size();\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                int n= grid[i].size();\\n                \\n                if(i == (m-1) && j == (n-1))\\n                {\\n                    nextElement = grid[0][0];\\n                    grid[0][0] = element;\\n                    element = nextElement;\\n                }\\n                else if(j == (n-1))\\n                {\\n                    nextElement = grid[i+1][0]; \\n                    grid[i+1][0] = element; \\n                    element = nextElement; \\n                }\\n                else{\\n                    nextElement = grid[i][j+1]; \\n                    grid[i][j+1] = element; \\n                    element = nextElement; \\n                }\\n            }\\n        }\\n        }\\n\\n        \\n        return grid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935613,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> list = new ArrayList();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int ans[] = new int[m*n];   \\n        int total = m*n;\\n        \\n        int index = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[(index + k)% total] = grid[i][j];\\n                index++;\\n            }\\n        }\\n        \\n        List<Integer> a = new ArrayList();\\n        for(int i=0;i<total;i++){\\n            a.add(ans[i]);\\n            if(a.size() == n){         \\n                System.out.println(a);\\n                list.add(a);\\n                a = new ArrayList();\\n            } \\n        }\\n        return list;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> shiftGrid(int[][] grid, int k) {\\n        List<List<Integer>> list = new ArrayList();\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int ans[] = new int[m*n];   \\n        int total = m*n;\\n        \\n        int index = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans[(index + k)% total] = grid[i][j];\\n                index++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1935549,
                "title": "c-reversal-algorithm-to-rotate-an-array",
                "content": "**Optimal Approach (Reversal Algorithm)**\\n```\\nclass Solution {\\n    // row and column\\n    int m, n;\\n    \\n    // As the asked form is in 2D matrix, we have to find out \\n    // our desirable row and column index for swapping, rest \\n    // the reverse algorithm is pretty much the same\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l < r) \\n        {\\n            // calculating the first element to be swapped\\n            int lr = l/n, lc = l%n;\\n            \\n            // second element\\n            int snd_row = r/n, snd_col = r%n;\\n            if(snd_row == m) snd_row = 0;\\n            \\n            swap(grid[fst_row][fst_col], grid[snd_row][snd_col]);\\n            \\n            // updating 1D array indexes\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        /*\\n        This is similar question like rotate an array, but this time it\\'s given as \\n        2D matrix, we\\'ll go for the similar reversal algorithm approach\\n        \\n        reverse(arr, 0, n-1);\\n        reverse(arr, 0, k-1);\\n        reverse(arr, k, n-1);\\n        */\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n); // a little optimisation over k rotations\\n        \\n        // a simple base case\\n        if(k == 0) return grid;\\n        \\n        // as total elements are m*n, we are passing last index as (m*n-1)\\n        // we\\'re considering 2D matrix as 1D array and will calculate the \\n        // index accordingly in the function body\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        \\n        // returning the answer\\n        return grid;\\n    }\\n};\\n\\n```\\n**Time - O(M.N)\\nSpace - O(1)**\\n\\n`As we are changing our input matrix loss of information happens, to prevent that we can make another \\'ans\\' matrix and in this case the space complexity would be O(M.N)`\\n\\n*NB: If I could help you a little consider upvoting the solution and comment your doubts and thoughts for this problem*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // row and column\\n    int m, n;\\n    \\n    // As the asked form is in 2D matrix, we have to find out \\n    // our desirable row and column index for swapping, rest \\n    // the reverse algorithm is pretty much the same\\n    void reverse(vector<vector<int>>& grid, int l, int r) {\\n        while(l < r) \\n        {\\n            // calculating the first element to be swapped\\n            int lr = l/n, lc = l%n;\\n            \\n            // second element\\n            int snd_row = r/n, snd_col = r%n;\\n            if(snd_row == m) snd_row = 0;\\n            \\n            swap(grid[fst_row][fst_col], grid[snd_row][snd_col]);\\n            \\n            // updating 1D array indexes\\n            l++;\\n            r--;\\n        }\\n    }\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        /*\\n        This is similar question like rotate an array, but this time it\\'s given as \\n        2D matrix, we\\'ll go for the similar reversal algorithm approach\\n        \\n        reverse(arr, 0, n-1);\\n        reverse(arr, 0, k-1);\\n        reverse(arr, k, n-1);\\n        */\\n        m = grid.size(), n = grid[0].size();\\n        k = k%(m*n); // a little optimisation over k rotations\\n        \\n        // a simple base case\\n        if(k == 0) return grid;\\n        \\n        // as total elements are m*n, we are passing last index as (m*n-1)\\n        // we\\'re considering 2D matrix as 1D array and will calculate the \\n        // index accordingly in the function body\\n        reverse(grid, 0, m*n-1);\\n        reverse(grid, 0, k-1);\\n        reverse(grid, k, m*n-1);\\n        \\n        // returning the answer\\n        return grid;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566057,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2012899,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1753271,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1739733,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/shift-2d-grid/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Simulation\n\n  \n**Approach 2:** Simulation, Recycling Same Array\n\n  \n**Approach 3:** Using Modulo Arithmetic\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "webguru77777",
                        "content": "How on earth 2D array rotation is easy when [1D array rotation](https://leetcode.com/problems/rotate-array/) is medium?\\n"
                    },
                    {
                        "username": "eduard92",
                        "content": "My first impression to this problem would be to flatten this 2d array and do some modulo with k if is bigger than the length. \\nWould be a bad approach in an interview? "
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Answer(c++) : \\nFirst we convert the 2D array into 1D and than rotate it and then again converting into 2D array.\\n\\ncode: \\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {\\n        vector<int> temp;\\n        int row = grid.size();\\n        int col = grid[0].size();\\n\\n        // Converting the 2D array into 1D array.\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // Rotating the 1D Array\\n        vector<int> v(temp.size());\\n        for(int i=0; i<temp.size(); i++){\\n                v[(i+k)%temp.size()] = temp[i];\\n        }\\n\\n        // Converting the 1D array into 2D \\n        int l = 0;\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                grid[i][j] = v[l++];\\n            }\\n        }\\n        return grid;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Elements in a Contaminated Binary Tree",
        "question_content": "<p>Given a binary tree with the following rules:</p>\n\n<ol>\n\t<li><code>root.val == 0</code></li>\n\t<li>If <code>treeNode.val == x</code> and <code>treeNode.left != null</code>, then <code>treeNode.left.val == 2 * x + 1</code></li>\n\t<li>If <code>treeNode.val == x</code> and <code>treeNode.right != null</code>, then <code>treeNode.right.val == 2 * x + 2</code></li>\n</ol>\n\n<p>Now the binary tree is contaminated, which means all <code>treeNode.val</code> have been changed to <code>-1</code>.</p>\n\n<p>Implement the <code>FindElements</code> class:</p>\n\n<ul>\n\t<li><code>FindElements(TreeNode* root)</code> Initializes the object with a contaminated binary tree and recovers it.</li>\n\t<li><code>bool find(int target)</code> Returns <code>true</code> if the <code>target</code> value exists in the recovered binary tree.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/06/untitled-diagram-4-1.jpg\" style=\"width: 320px; height: 119px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,null,-1]],[1],[2]]\n<strong>Output</strong>\n[null,false,true]\n<strong>Explanation</strong>\nFindElements findElements = new FindElements([-1,null,-1]); \nfindElements.find(1); // return False \nfindElements.find(2); // return True </pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/06/untitled-diagram-4.jpg\" style=\"width: 400px; height: 198px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,-1,-1,-1,-1]],[1],[3],[5]]\n<strong>Output</strong>\n[null,true,true,false]\n<strong>Explanation</strong>\nFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);\nfindElements.find(1); // return True\nfindElements.find(3); // return True\nfindElements.find(5); // return False</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/11/07/untitled-diagram-4-1-1.jpg\" style=\"width: 306px; height: 274px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;FindElements&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;,&quot;find&quot;]\n[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]\n<strong>Output</strong>\n[null,true,false,false,true]\n<strong>Explanation</strong>\nFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);\nfindElements.find(2); // return True\nfindElements.find(3); // return False\nfindElements.find(4); // return False\nfindElements.find(5); // return True\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>TreeNode.val == -1</code></li>\n\t<li>The height of the binary tree is less than or equal to <code>20</code></li>\n\t<li>The total number of nodes is between <code>[1, 10<sup>4</sup>]</code></li>\n\t<li>Total calls of <code>find()</code> is between <code>[1, 10<sup>4</sup>]</code></li>\n\t<li><code>0 &lt;= target &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 431229,
                "title": "python-special-way-for-find-without-hashset-o-1-space-o-logn-time",
                "content": "It\\'s obvious to use `BFS` for the initial part. However, a lot of people use HashSet(`set()` in python) to pre-store all the values in the initial part, which may cause MLE when the values are huge. There is a special way to implement `find()` that  costs O(1) in space and O(logn) in time. \\n\\nFirstly, let\\'s see what a complete tree will look like in this problem: \\n\\n\\nIt\\'s very easy to find that numbers in each layer range from `[2^i-1,2^(i+1)-2]`\\nwhat if we add 1 to each number? Then it should range from `[2^i, 2^(i+1)-1]`\\nSee?  the binary of all numbers in each layer should be: `100..00` to `111...11`\\n\\nHence we could discover that maybe we could use the `binary number` of `target+1` to find a path:\\n\\n![image](https://assets.leetcode.com/users/qingdu_river/image_1573968285.png)\\n\\nI\\'m not proficient in English, so I would prefer to show my code here to explain my idea:\\n\\n```python\\ndef find(self, target: int) -> bool:\\n\\t\\tbinary = bin(target+1)[3:]                  # remove the useless first `1`\\n        index = 0\\n        root = self.root                                    # use a new pointer `root` to traverse the tree\\n        while root and index <= len(binary): # traverse the binary number from left to right\\n            if root.val == target:\\n                return True\\n            if  binary[index] == \\'0\\':  # if it\\'s 0, we have to go left\\n                root = root.left\\n            else:  # if it\\'s 1, we have to go right\\n                root = root.right\\n            index += 1\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\ndef find(self, target: int) -> bool:\\n\\t\\tbinary = bin(target+1)[3:]                  # remove the useless first `1`\\n        index = 0\\n        root = self.root                                    # use a new pointer `root` to traverse the tree\\n        while root and index <= len(binary): # traverse the binary number from left to right\\n            if root.val == target:\\n                return True\\n            if  binary[index] == \\'0\\':  # if it\\'s 0, we have to go left\\n                root = root.left\\n            else:  # if it\\'s 1, we have to go right\\n                root = root.right\\n            index += 1\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 431107,
                "title": "java-python-3-dfs-and-bfs-clean-codes-w-analysis",
                "content": "**DFS**\\n\\n```java\\n    private Set<Integer> seen = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        dfs(root, 0);\\n    }\\n    private void dfs(TreeNode n, int v) {\\n        if (n == null) return;\\n        seen.add(v);\\n        n.val = v;\\n        dfs(n.left, 2 * v + 1);\\n        dfs(n.right, 2 * v + 2);\\n    }\\n    \\n    public boolean find(int target) {\\n        return seen.contains(target);\\n    }\\n```\\n```python\\n    def __init__(self, root: TreeNode):\\n        self.seen = set()\\n        \\n        def dfs(node: TreeNode, v: int) -> None:\\n            if node:\\n                node.val = v    \\n                self.seen.add(v)\\n                dfs(node.left, 2 * v + 1)\\n                dfs(node.right, 2 * v + 2)\\n            \\n        dfs(root, 0)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.seen\\n```\\n\\n----\\n\\n**BFS** - inspired by **@MichaelZ**.\\n```java\\n    private Set<Integer> seen = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        if (root != null) {\\n            root.val = 0;\\n            seen.add(root.val);\\n            bfs(root);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return seen.contains(target);\\n    }\\n    \\n    private void bfs(TreeNode node) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(node);\\n        while (!q.isEmpty()) {\\n            TreeNode cur = q.poll();\\n            if (cur.left != null) {\\n                cur.left.val = 2 * cur.val + 1;\\n                q.offer(cur.left);\\n                seen.add(cur.left.val);\\n            }\\n            if (cur.right != null) {\\n                cur.right.val = 2 * cur.val + 2;\\n                q.offer(cur.right);\\n                seen.add(cur.right.val);\\n            }\\n        }\\n    }\\n```\\n```python\\n    def __init__(self, root: TreeNode):\\n\\n        def bfs(root: TreeNode) -> None:\\n            dq = collections.deque([root])\\n            while dq:\\n                node = dq.popleft()\\n                if node.left:\\n                    node.left.val = 2 * node.val + 1\\n                    dq.append(node.left)\\n                    self.seen.add(node.left.val)\\n                if node.right:\\n                    node.right.val = 2 * node.val + 2\\n                    dq.append(node.right)\\n                    self.seen.add(node.right.val)\\n            \\n        self.seen = set()\\n        if root:\\n            root.val = 0\\n            bfs(root)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.seen    \\n```\\n\\n**Analysis:**\\nHashSet cost space `O(N)`, *dfs()* cost space ((H) and time `O(N)`, *bfs()* cost time and space O(N), therefore\\n\\n*FindElements() (dfs() and bfs()) cost*\\ntime & space: `O(N)`.\\n\\n*find() cost*\\ntime & space: `O(1)` excluding the space of HashSet.\\n\\nWhere `N` is the total number of nodes in the tree.",
                "solutionTags": [],
                "code": "```java\\n    private Set<Integer> seen = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        dfs(root, 0);\\n    }\\n    private void dfs(TreeNode n, int v) {\\n        if (n == null) return;\\n        seen.add(v);\\n        n.val = v;\\n        dfs(n.left, 2 * v + 1);\\n        dfs(n.right, 2 * v + 2);\\n    }\\n    \\n    public boolean find(int target) {\\n        return seen.contains(target);\\n    }\\n```\n```python\\n    def __init__(self, root: TreeNode):\\n        self.seen = set()\\n        \\n        def dfs(node: TreeNode, v: int) -> None:\\n            if node:\\n                node.val = v    \\n                self.seen.add(v)\\n                dfs(node.left, 2 * v + 1)\\n                dfs(node.right, 2 * v + 2)\\n            \\n        dfs(root, 0)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.seen\\n```\n```java\\n    private Set<Integer> seen = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        if (root != null) {\\n            root.val = 0;\\n            seen.add(root.val);\\n            bfs(root);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return seen.contains(target);\\n    }\\n    \\n    private void bfs(TreeNode node) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(node);\\n        while (!q.isEmpty()) {\\n            TreeNode cur = q.poll();\\n            if (cur.left != null) {\\n                cur.left.val = 2 * cur.val + 1;\\n                q.offer(cur.left);\\n                seen.add(cur.left.val);\\n            }\\n            if (cur.right != null) {\\n                cur.right.val = 2 * cur.val + 2;\\n                q.offer(cur.right);\\n                seen.add(cur.right.val);\\n            }\\n        }\\n    }\\n```\n```python\\n    def __init__(self, root: TreeNode):\\n\\n        def bfs(root: TreeNode) -> None:\\n            dq = collections.deque([root])\\n            while dq:\\n                node = dq.popleft()\\n                if node.left:\\n                    node.left.val = 2 * node.val + 1\\n                    dq.append(node.left)\\n                    self.seen.add(node.left.val)\\n                if node.right:\\n                    node.right.val = 2 * node.val + 2\\n                    dq.append(node.right)\\n                    self.seen.add(node.right.val)\\n            \\n        self.seen = set()\\n        if root:\\n            root.val = 0\\n            bfs(root)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.seen    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 431362,
                "title": "java-bit-path-time-o-logn",
                "content": "Think about it with complete binary tree and the whole idea is to binary serialize the target number. It\\'s actually tha order we doing the dfs.\\nLet\\'s say our target : 9 we shall take it as 10 : 1010  ignoring the first digit 1 the path ( 010 )  means left -> right -> left  \\nSo \\'0\\' means going to the left and \\'1\\' means going to the right.\\nHere is the picture, very straightforward.\\n\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1574045418.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\tTreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        return dfs(root, binSerialize(target + 1), 1);\\n    }\\n\\t\\n\\tpublic boolean dfs(TreeNode root, String str, int pos){\\n        if(root == null)    return false;\\n        if(pos == str.length()) return true;\\n        return str.charAt(pos) == \\'0\\'? dfs(root.left, str, pos+1) : dfs(root.right, str, pos+1);\\n    }\\n    \\n    public String binSerialize(int num){\\n        StringBuilder sb = new StringBuilder();\\n        while(num > 0){\\n            sb.insert(0, num & 1);\\n            num /= 2;\\n        }\\n        return sb.toString();\\n    }\\n    \\n\\n",
                "solutionTags": [],
                "code": "Think about it with complete binary tree and the whole idea is to binary serialize the target number. It\\'s actually tha order we doing the dfs.\\nLet\\'s say our target : 9 we shall take it as 10 : 1010  ignoring the first digit 1 the path ( 010 )  means left -> right -> left  \\nSo \\'0\\' means going to the left and \\'1\\' means going to the right.\\nHere is the picture, very straightforward.\\n\\n![image](https://assets.leetcode.com/users/jiaweizhang1994/image_1574045418.png)\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\tTreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        return dfs(root, binSerialize(target + 1), 1);\\n    }\\n\\t\\n\\tpublic boolean dfs(TreeNode root, String str, int pos){\\n        if(root == null)    return false;\\n        if(pos == str.length()) return true;\\n        return str.charAt(pos) == \\'0\\'? dfs(root.left, str, pos+1) : dfs(root.right, str, pos+1);\\n    }\\n    \\n    public String binSerialize(int num){\\n        StringBuilder sb = new StringBuilder();\\n        while(num > 0){\\n            sb.insert(0, num & 1);\\n            num /= 2;\\n        }\\n        return sb.toString();\\n    }\\n    \\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 434127,
                "title": "c-simple-and-easy-to-understand",
                "content": "```\\nclass FindElements {\\n    unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass FindElements {\\n    unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431462,
                "title": "intuitive-c-code-beats-100-in-memory",
                "content": "```\\nclass FindElements {\\n    TreeNode* head=new TreeNode(-1);\\npublic:\\n    FindElements(TreeNode* root) {\\n        head=root;\\n        head->val=0;\\n        recover(head);\\n    }\\n    \\n    void recover(TreeNode* root)\\n    {\\n        if(root->left)\\n        {\\n            root->left->val=(root->val)*2+1;\\n            recover(root->left);\\n        }\\n        if(root->right)\\n        {\\n            root->right->val=(root->val)*2+2;\\n            recover(root->right);\\n        }\\n        return;\\n    }\\n    \\n    bool find(int target) {\\n        return get(target,head);\\n    }\\n    \\n    bool get(int target,TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return false;\\n        if(root->val==target)\\n            return true;\\n        \\n        bool t1=get(target,root->left);\\n        bool t2=get(target,root->right);\\n        \\n        if(t1||t2)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass FindElements {\\n    TreeNode* head=new TreeNode(-1);\\npublic:\\n    FindElements(TreeNode* root) {\\n        head=root;\\n        head->val=0;\\n        recover(head);\\n    }\\n    \\n    void recover(TreeNode* root)\\n    {\\n        if(root->left)\\n        {\\n            root->left->val=(root->val)*2+1;\\n            recover(root->left);\\n        }\\n        if(root->right)\\n        {\\n            root->right->val=(root->val)*2+2;\\n            recover(root->right);\\n        }\\n        return;\\n    }\\n    \\n    bool find(int target) {\\n        return get(target,head);\\n    }\\n    \\n    bool get(int target,TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return false;\\n        if(root->val==target)\\n            return true;\\n        \\n        bool t1=get(target,root->left);\\n        bool t2=get(target,root->right);\\n        \\n        if(t1||t2)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431283,
                "title": "python-binary-path-without-set",
                "content": "bin(9 + 1) = 1 010\\nStart from the second digit: 0/1/0 means left/right/left when traverse if 9 exists.\\nrecover: T: O(n), S: O(n) (DFS worst case)\\nfind: T: O(logn), S: O(logn) (for the string of path encoding, can be O(1) if use bit mask) \\n```\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.root = root\\n        if not root:\\n            return\\n        root.val = 0\\n        self.recover(root)\\n        return\\n    def recover(self, root):\\n        if not root:\\n            return\\n        if root.left:\\n            root.left.val = root.val * 2 + 1\\n            self.recover(root.left)\\n        if root.right:\\n            root.right.val = root.val * 2 + 2\\n            self.recover(root.right)\\n\\n    def find(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        node = self.root\\n        encoding = bin(target + 1)[3:]\\n        counter = 0\\n        while counter < len(encoding):\\n            if encoding[counter] == \"0\":\\n                if node.left:\\n                    node = node.left\\n                    counter += 1\\n                else:\\n                    return False\\n            else:\\n                if node.right:\\n                    node = node.right\\n                    counter += 1\\n                else:\\n                    return False\\n        return True",
                "solutionTags": [],
                "code": "bin(9 + 1) = 1 010\\nStart from the second digit: 0/1/0 means left/right/left when traverse if 9 exists.\\nrecover: T: O(n), S: O(n) (DFS worst case)\\nfind: T: O(logn), S: O(logn) (for the string of path encoding, can be O(1) if use bit mask) \\n```\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.root = root\\n        if not root:\\n            return\\n        root.val = 0\\n        self.recover(root)\\n        return\\n    def recover(self, root):\\n        if not root:\\n            return\\n        if root.left:\\n            root.left.val = root.val * 2 + 1\\n            self.recover(root.left)\\n        if root.right:\\n            root.right.val = root.val * 2 + 2\\n            self.recover(root.right)\\n\\n    def find(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        node = self.root\\n        encoding = bin(target + 1)[3:]\\n        counter = 0\\n        while counter < len(encoding):\\n            if encoding[counter] == \"0\":\\n                if node.left:\\n                    node = node.left\\n                    counter += 1\\n                else:\\n                    return False\\n            else:\\n                if node.right:\\n                    node = node.right\\n                    counter += 1\\n                else:\\n                    return False\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 3172058,
                "title": "c-simple-solution-tc-o-log-n-sc-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(log(N))\\n\\n- Space complexity:\\nO(log(N))\\n# Code\\n```\\nclass FindElements\\n{\\npublic:\\n    TreeNode *root;\\n    FindElements(TreeNode *root2)\\n    {\\n        root = root2;\\n    }\\n\\n    bool find(int tar)\\n    {\\n        stack<int> st;\\n        while (tar > 0)\\n        {\\n            int x = 0;\\n            if ((tar & 1) == 1)\\n            {\\n                x = 1;\\n            }\\n            tar--;\\n            tar >>= 1;\\n            st.push(x);\\n        }\\n        TreeNode *temp = root;\\n        while (!st.empty())\\n        {\\n\\n            if (st.top() == 1)\\n            {\\n                if (temp->left)\\n                {\\n                    temp = temp->left;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                if (temp->right)\\n                {\\n                    temp = temp->right;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            st.pop();\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements\\n{\\npublic:\\n    TreeNode *root;\\n    FindElements(TreeNode *root2)\\n    {\\n        root = root2;\\n    }\\n\\n    bool find(int tar)\\n    {\\n        stack<int> st;\\n        while (tar > 0)\\n        {\\n            int x = 0;\\n            if ((tar & 1) == 1)\\n            {\\n                x = 1;\\n            }\\n            tar--;\\n            tar >>= 1;\\n            st.push(x);\\n        }\\n        TreeNode *temp = root;\\n        while (!st.empty())\\n        {\\n\\n            if (st.top() == 1)\\n            {\\n                if (temp->left)\\n                {\\n                    temp = temp->left;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                if (temp->right)\\n                {\\n                    temp = temp->right;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            st.pop();\\n        }\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466109,
                "title": "java-bit-representation-of-target-1-solution-with-explanation",
                "content": "if the root.val is 1 instead of 0, then the values of tree node are:\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t1\\n\\t\\t\\t\\t\\t 2                           3\\n\\t\\t   4                5           6               7\\n      8 \\t\\t9       10     11   12     13       14     15\\n  ....           .....              ....            ....         ...        ...\\n  ```\\n\\nThe bits starting from index 1(ignore the most significant bit) of binary representation of a val decide the path to reach it:\\n0 -> go to left\\n1 -> go the right;\\n\\nFor example:  \\n2  = 10 => ignore the most significant bit, the representation is \"0\" => 2 is the left child of root.\\n4 = 100 => ignore the most significant bit, the representation is \"00\" => go 2 lefts;\\n11 =1011 => ignore the most significant bit, the represenation is \"011\" => go one left, then 2 rights.\\n\\n```\\nclass FindElements {\\n\\n    private TreeNode root;\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        \\n    }\\n    \\n    public boolean find(int target) {\\n        String binaryRep = Long.toString(target + 1L, 2);\\n        TreeNode curr = root;\\n        int i = 1;\\n        int len = binaryRep.length();\\n        while(i < len && curr != null) {\\n            char ch = binaryRep.charAt(i);\\n            curr = ch == \\'1\\' ? curr.right : curr.left;\\n            ++i;\\n        }\\n        \\n        return curr != null;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t1\\n\\t\\t\\t\\t\\t 2                           3\\n\\t\\t   4                5           6               7\\n      8 \\t\\t9       10     11   12     13       14     15\\n  ....           .....              ....            ....         ...        ...\\n  ```\n```\\nclass FindElements {\\n\\n    private TreeNode root;\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        \\n    }\\n    \\n    public boolean find(int target) {\\n        String binaryRep = Long.toString(target + 1L, 2);\\n        TreeNode curr = root;\\n        int i = 1;\\n        int len = binaryRep.length();\\n        while(i < len && curr != null) {\\n            char ch = binaryRep.charAt(i);\\n            curr = ch == \\'1\\' ? curr.right : curr.left;\\n            ++i;\\n        }\\n        \\n        return curr != null;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449680,
                "title": "simple-java-dsf-solution-use-bitset-double-100",
                "content": "```\\n    class FindElements {\\n\\n        private BitSet sets = new BitSet();\\n\\n        public FindElements(TreeNode root) {\\n            dsf(root, 0);\\n        }\\n\\n        public boolean find(int target) {\\n            return sets.get(target);\\n        }\\n\\n        private void dsf(TreeNode root, int val) {\\n            if (root == null) return;\\n            sets.set(val);\\n            dsf(root.left, 2 * val + 1);\\n            dsf(root.right, 2 * val + 2);\\n        }\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    class FindElements {\\n\\n        private BitSet sets = new BitSet();\\n\\n        public FindElements(TreeNode root) {\\n            dsf(root, 0);\\n        }\\n\\n        public boolean find(int target) {\\n            return sets.get(target);\\n        }\\n\\n        private void dsf(TreeNode root, int val) {\\n            if (root == null) return;\\n            sets.set(val);\\n            dsf(root.left, 2 * val + 1);\\n            dsf(root.right, 2 * val + 2);\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202354,
                "title": "easy-java-solution-easy-peasy-lemon-squeezy-simple",
                "content": "\\n# Code\\n```\\nclass FindElements {\\n    TreeNode root;\\n    Set<Integer> set = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        if(root != null){ root.val = 0; set.add(root.val); }\\n        recover(root,set);\\n    }\\n    \\n    public boolean find(int target) {\\n      return set.contains(target);\\n    }\\n\\n    private void recover(TreeNode root, Set<Integer> set){\\n        if(root.left != null){\\n            root.left.val = 2 * root.val + 1;\\n            set.add(root.left.val);\\n            recover(root.left, set);\\n        }\\n       if(root.right != null){\\n            root.right.val = 2 * root.val + 2;\\n            set.add(root.right.val);\\n            recover(root.right, set);\\n       } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n    TreeNode root;\\n    Set<Integer> set = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        if(root != null){ root.val = 0; set.add(root.val); }\\n        recover(root,set);\\n    }\\n    \\n    public boolean find(int target) {\\n      return set.contains(target);\\n    }\\n\\n    private void recover(TreeNode root, Set<Integer> set){\\n        if(root.left != null){\\n            root.left.val = 2 * root.val + 1;\\n            set.add(root.left.val);\\n            recover(root.left, set);\\n        }\\n       if(root.right != null){\\n            root.right.val = 2 * root.val + 2;\\n            set.add(root.right.val);\\n            recover(root.right, set);\\n       } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797703,
                "title": "easy-python-o-1-find-recursion-queue",
                "content": "**Easy Python | O(1) Find | Recursion + Queue**\\n\\n**A) Standard Code**\\n\\nIn this problem, we can recover the values of the original Binary Tree, and store them in a \"set\" directly. (There\\'s no need to keep the Binary Tree itself)\\n\\nThis way, we can \"find\" any element with O(1) time/space complexity. The initialization method still runs with O(n) time/space complexity though.\\n\\n```\\nclass FindElements(object):\\n    def __init__(self, root):\\n        self.A = A = set()\\n        #\\n        def recover(n,x):\\n            if n:\\n                A.add(x)\\n                recover(n.left , 2*x + 1)\\n                recover(n.right, 2*x + 2)\\n        #\\n        recover(root,0)\\n    #\\n    def find(self, target):\\n        return target in self.A\\n```\\n\\n**B) 4 Lines of Code**\\n\\nOne-Liner version of the \"Recover\" function :)\\n\\n```\\nclass FindElements:\\n    def __init__(self, root):\\n        self.A = A = set()\\n        recover = lambda n,x: [ A.add(x) , recover(n.left,2*x+1) , recover(n.right,2*x+2) ] if n else None\\n        recover(root,0)\\n    def find(self, target):\\n        return target in self.A\\n```\\n\\n**C) Queue Method**\\n\\nThe previous code versions work fine. However, recursion consumes a lot of system resources, due to the initialization, namespace, and environment variables of each function call. Besides, many compilers have a hardcoded limit for Max. Recursion Depth, and there can be complicaitons by constantly needing to edit global settings.\\n\\nThere\\'s still hope in the galaxy though. We can use \"Queues\" to traverse the original Binary Tree without applying recursion.\\n\\nHere\\'s the code:\\n\\n```\\n# C) Improved Function without Recursion\\nclass FindElements:\\n    def __init__(self, root):\\n        self.A = A = set()\\n        # ---------------------------------------------------------------\\n        #     Queue Version of the Binary Tree \"Recovery\" Method \\n        # ---------------------------------------------------------------\\n        if not root:\\n            return\\n        #\\n        queue = collections.deque([[root,0]])\\n        while queue:\\n            n,x = queue.popleft()\\n            A.add(x)\\n            if n.left:\\n                queue.append( [n.left  , 2*x+1] )\\n            if n.right:\\n                queue.append( [n.right , 2*x+2] )\\n    #\\n    def find(self, target):\\n        return target in self.A\\n```\\n\\nI hope the code was helpful. Cheers,\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass FindElements(object):\\n    def __init__(self, root):\\n        self.A = A = set()\\n        #\\n        def recover(n,x):\\n            if n:\\n                A.add(x)\\n                recover(n.left , 2*x + 1)\\n                recover(n.right, 2*x + 2)\\n        #\\n        recover(root,0)\\n    #\\n    def find(self, target):\\n        return target in self.A\\n```\n```\\nclass FindElements:\\n    def __init__(self, root):\\n        self.A = A = set()\\n        recover = lambda n,x: [ A.add(x) , recover(n.left,2*x+1) , recover(n.right,2*x+2) ] if n else None\\n        recover(root,0)\\n    def find(self, target):\\n        return target in self.A\\n```\n```\\n# C) Improved Function without Recursion\\nclass FindElements:\\n    def __init__(self, root):\\n        self.A = A = set()\\n        # ---------------------------------------------------------------\\n        #     Queue Version of the Binary Tree \"Recovery\" Method \\n        # ---------------------------------------------------------------\\n        if not root:\\n            return\\n        #\\n        queue = collections.deque([[root,0]])\\n        while queue:\\n            n,x = queue.popleft()\\n            A.add(x)\\n            if n.left:\\n                queue.append( [n.left  , 2*x+1] )\\n            if n.right:\\n                queue.append( [n.right , 2*x+2] )\\n    #\\n    def find(self, target):\\n        return target in self.A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645499,
                "title": "java-18ms-92-faster",
                "content": "The speed is obtained by not modifiying the tree and using bitwise operator\\nleftshift by 1 == multiplication by 2 and it is much faster than multiplication operator\\n\\nFor the fast lookup use hashmap, because the lookup time is O(1) (avg)\\n```\\nclass FindElements {\\n\\n    Set<Integer> set = new HashSet<>();\\n    void solve(TreeNode root ,int NodeVal){\\n        if(root == null) return;\\n        set.add(NodeVal);\\n        solve(root.left,(NodeVal<<1) + 1); \\n        solve(root.right,(NodeVal<<1) + 2);\\n    }\\n    public FindElements(TreeNode root) {\\n        solve(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n\\n    Set<Integer> set = new HashSet<>();\\n    void solve(TreeNode root ,int NodeVal){\\n        if(root == null) return;\\n        set.add(NodeVal);\\n        solve(root.left,(NodeVal<<1) + 1); \\n        solve(root.right,(NodeVal<<1) + 2);\\n    }\\n    public FindElements(TreeNode root) {\\n        solve(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906458,
                "title": "java-easiest-cosise-beginer-friendly-slow",
                "content": "```\\nclass FindElements {\\n    TreeNode root;\\n    public FindElements(TreeNode r) {\\n        root = r;\\n        r.val = 0;\\n    }\\n    public boolean find(int target) {\\n        return find(root,target);\\n    }\\n    public boolean find(TreeNode root,int target){\\n        if(root == null) return false;\\n        if(root.val == target) return true;\\n        if(root.left != null) root.left.val = 2 * root.val + 1; \\n        if(root.right != null) root.right.val = 2 * root.val + 2;\\n        return find(root.left,target) || find(root.right,target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n    TreeNode root;\\n    public FindElements(TreeNode r) {\\n        root = r;\\n        r.val = 0;\\n    }\\n    public boolean find(int target) {\\n        return find(root,target);\\n    }\\n    public boolean find(TreeNode root,int target){\\n        if(root == null) return false;\\n        if(root.val == target) return true;\\n        if(root.left != null) root.left.val = 2 * root.val + 1; \\n        if(root.right != null) root.right.val = 2 * root.val + 2;\\n        return find(root.left,target) || find(root.right,target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530059,
                "title": "c-code-using-bfs-o-n",
                "content": "```\\nclass FindElements {\\n    unordered_map<int, int> m;\\npublic:\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val = 0;\\n        q.push(root);\\n        m[0]++;\\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            m[temp->val]++;\\n            if(temp->left){\\n                temp->left->val = 2 * temp->val + 1;\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                temp->right->val = 2 * temp->val + 2;\\n                q.push(temp->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target) != m.end())\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    unordered_map<int, int> m;\\npublic:\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val = 0;\\n        q.push(root);\\n        m[0]++;\\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            m[temp->val]++;\\n            if(temp->left){\\n                temp->left->val = 2 * temp->val + 1;\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                temp->right->val = 2 * temp->val + 2;\\n                q.push(temp->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target) != m.end())\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439249,
                "title": "clean-easy-understand-python",
                "content": "\\tdef __init__(self, root: TreeNode):\\n        root.val = 0\\n        self.s = set()\\n        q = [(root, 0)]\\n        self.s.add(0)\\n        while len(q) > 0:\\n            t,v = q.pop()\\n            if t.left:\\n                q.append((t.left, v * 2 + 1))\\n                self.s.add(v * 2 + 1)\\n            if t.right:\\n                q.append((t.right, v * 2 + 2))\\n                self.s.add(v * 2 + 2)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.s",
                "solutionTags": [],
                "code": "\\tdef __init__(self, root: TreeNode):\\n        root.val = 0\\n        self.s = set()\\n        q = [(root, 0)]\\n        self.s.add(0)\\n        while len(q) > 0:\\n            t,v = q.pop()\\n            if t.left:\\n                q.append((t.left, v * 2 + 1))\\n                self.s.add(v * 2 + 1)\\n            if t.right:\\n                q.append((t.right, v * 2 + 2))\\n                self.s.add(v * 2 + 2)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.s",
                "codeTag": "Python3"
            },
            {
                "id": 438239,
                "title": "python-hacks",
                "content": "```\\nclass FindElements(object):\\n    def __init__(self, root):\\n        def v(r, x):\\n            return r and {x} | v(r.left, 2*x+1) | v(r.right, 2*x+2) or set()\\n        self.find = v(root, 0).__contains__\\n```\\n\\nAnother, based on [this one](https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/discuss/431229/Python-Special-Way-for-find()-without-HashSet-O(1)-Space-O(logn)-Time/394342):\\n```\\nclass FindElements(object):\\n    def __init__(self, r):\\n        self.find = lambda t: reduce(lambda n, b: n and (n.left, n.right)[int(b)], bin(t+1)[3:], r)\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass FindElements(object):\\n    def __init__(self, root):\\n        def v(r, x):\\n            return r and {x} | v(r.left, 2*x+1) | v(r.right, 2*x+2) or set()\\n        self.find = v(root, 0).__contains__\\n```\n```\\nclass FindElements(object):\\n    def __init__(self, r):\\n        self.find = lambda t: reduce(lambda n, b: n and (n.left, n.right)[int(b)], bin(t+1)[3:], r)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543983,
                "title": "python-explained-tree-traversal",
                "content": "* We can use any tree traversal method to make the tree contaminated, here we are using preorder traversal it is more favorable here since value of child nodes are dependent on the value of thier parent node.\\n* For efficient target searching we will maintain a set and keep adding the values in it whenever we modify node value.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.root.val = 0\\n        self.st = set()\\n        self.st.add(0)\\n        \\n        def preorder(root):\\n            if root:\\n                if root.left:\\n                    root.left.val = 2*root.val+1\\n                    self.st.add(2*root.val+1)\\n                    preorder(root.left)\\n                if root.right:\\n                    root.right.val = 2*root.val+2\\n                    self.st.add(2*root.val+2)\\n                    preorder(root.right)\\n        preorder(self.root)\\n\\n    def find(self, target: int) -> bool:\\n        return True if target in self.st else False\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```\\n-----------------\\n**Upvote the post if you find it helpful.**\\n**Happy coding.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.root.val = 0\\n        self.st = set()\\n        self.st.add(0)\\n        \\n        def preorder(root):\\n            if root:\\n                if root.left:\\n                    root.left.val = 2*root.val+1\\n                    self.st.add(2*root.val+1)\\n                    preorder(root.left)\\n                if root.right:\\n                    root.right.val = 2*root.val+2\\n                    self.st.add(2*root.val+2)\\n                    preorder(root.right)\\n        preorder(self.root)\\n\\n    def find(self, target: int) -> bool:\\n        return True if target in self.st else False\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176160,
                "title": "simple-and-clean-c-solution-using-dfs-and-a-hashset",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n\\n```\\n    unordered_set<int> s;\\n    void solve(TreeNode* root)\\n    {\\n        if(root==nullptr)\\n            return;\\n        s.insert(root->val);\\n        if(root->left!=nullptr)\\n            root->left->val=root->val*2+1;\\n        if(root->right!=nullptr)\\n            root->right->val=root->val*2+2;\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n    unordered_set<int> s;\\n    void solve(TreeNode* root)\\n    {\\n        if(root==nullptr)\\n            return;\\n        s.insert(root->val);\\n        if(root->left!=nullptr)\\n            root->left->val=root->val*2+1;\\n        if(root->right!=nullptr)\\n            root->right->val=root->val*2+2;\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        else\\n            return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 921735,
                "title": "c-o-n-to-build-o-1-query",
                "content": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int> cache;\\n    \\n    void recover(TreeNode *root, int prev)\\n    {\\n        if(!root) return;\\n        \\n        root->val = prev;\\n        cache.insert(root->val);\\n        \\n        recover(root->left, 2*prev + 1);\\n        recover(root->right, 2*prev + 2);\\n    }\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target)  {\\n        return cache.count(target) > 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int> cache;\\n    \\n    void recover(TreeNode *root, int prev)\\n    {\\n        if(!root) return;\\n        \\n        root->val = prev;\\n        cache.insert(root->val);\\n        \\n        recover(root->left, 2*prev + 1);\\n        recover(root->right, 2*prev + 2);\\n    }\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target)  {\\n        return cache.count(target) > 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750532,
                "title": "easy-c-solution-using-hashmap",
                "content": "```\\nclass FindElements\\n{\\npublic:\\n    unordered_map<int,int>m;\\n\\n    FindElements(TreeNode* root)\\n    {\\n        if(root)\\n        {\\n            root->val = 0;\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            m[0]++;\\n\\n            while(!q.empty())\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                int x = temp->val;\\n                if(temp->left)\\n                {\\n                    temp->left->val = x*2 + 1;\\n\\n                    m[x*2 + 1]++;\\n                    q.push(temp->left);\\n                }\\n\\n                if(temp->right)\\n                {\\n                    temp->right->val = x*2 + 2;\\n\\n                    m[x*2 + 2]++;\\n                    q.push(temp->right);\\n                }\\n            }\\n        }\\n    }\\n\\n    bool find(int target)\\n    {\\n        return (m.find(target) != m.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass FindElements\\n{\\npublic:\\n    unordered_map<int,int>m;\\n\\n    FindElements(TreeNode* root)\\n    {\\n        if(root)\\n        {\\n            root->val = 0;\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            m[0]++;\\n\\n            while(!q.empty())\\n            {\\n                TreeNode* temp = q.front();\\n                q.pop();\\n                int x = temp->val;\\n                if(temp->left)\\n                {\\n                    temp->left->val = x*2 + 1;\\n\\n                    m[x*2 + 1]++;\\n                    q.push(temp->left);\\n                }\\n\\n                if(temp->right)\\n                {\\n                    temp->right->val = x*2 + 2;\\n\\n                    m[x*2 + 2]++;\\n                    q.push(temp->right);\\n                }\\n            }\\n        }\\n    }\\n\\n    bool find(int target)\\n    {\\n        return (m.find(target) != m.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708923,
                "title": "java-simple-dfs-and-set",
                "content": "```\\nclass FindElements {\\n    Set<Integer> st = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        if (root == null) return;\\n        dfs(root, 0);\\n    }\\n    \\n    private void dfs(TreeNode node, int val) {\\n        st.add(val);\\n        if (node.left != null) dfs(node.left, val * 2 + 1);\\n        if (node.right != null) dfs(node.right, val * 2 + 2);\\n    }\\n    \\n    public boolean find(int target) {\\n        return st.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    Set<Integer> st = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        if (root == null) return;\\n        dfs(root, 0);\\n    }\\n    \\n    private void dfs(TreeNode node, int val) {\\n        st.add(val);\\n        if (node.left != null) dfs(node.left, val * 2 + 1);\\n        if (node.right != null) dfs(node.right, val * 2 + 2);\\n    }\\n    \\n    public boolean find(int target) {\\n        return st.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509767,
                "title": "c-c-solution-the-find-is-o-1-uses-a-bitset-instead-of-a-set-saves-memory",
                "content": "If the tree is not too sparse, using a bitset uses less memory than an unordered_set. I think it amounts to only 8KiB, given the problem\\'s upper node limit, enough to fit entirely in the CPU\\'s cache. I also expect element access to compare favorably with an unordered_set\\'s.\\nIf lots of small trees are to be expected, preallocating a full-size bitset may be a pessimization, but replacing it with a (dynamic-sized) vector is fairly straightforward.\\n\\n```\\nclass FindElements {\\n    std::bitset< (2<<20) > vv;\\n    \\n    void recover(TreeNode* n, int ii) {\\n        if(!n) { return; }\\n        \\n        vv[ii] = true;\\n        recover(n->left, ii*2+1);\\n        recover(n->right, ii*2+2);\\n    }\\npublic:\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return vv[target] == true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FindElements {\\n    std::bitset< (2<<20) > vv;\\n    \\n    void recover(TreeNode* n, int ii) {\\n        if(!n) { return; }\\n        \\n        vv[ii] = true;\\n        recover(n->left, ii*2+1);\\n        recover(n->right, ii*2+2);\\n    }\\npublic:\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return vv[target] == true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758852,
                "title": "bfs-level-order-traversal-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse **BFS (Level Order Traversal Format)** to assign values to the nodes and store them in an **unordered map** to return the answer in **O(1) time** in the **find() function**.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FindElements {\\npublic:\\n    unordered_map<int,bool> mp;\\n    FindElements(TreeNode* root) {\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n        while(!q.empty())\\n        {\\n            int n = q.size(),f = 1;\\n            for(int i = 0;i<n;i++)\\n            {\\n              TreeNode*  node = q.front().first;\\n              int val = q.front().second;\\n              q.pop();\\n              if(node) mp[val] = true;\\n             if(node)\\n             {\\n                q.push({node->left,2*val+1});\\n                q.push({node->right,2*val+2});\\n                f = 0;\\n             }\\n             else\\n             {\\n                q.push({NULL,2*val+1});\\n                q.push({NULL,2*val+2});\\n              }\\n            }\\n            if(f) break;\\n        }  \\n    }\\n    bool find(int t) {\\n         return mp[t]==true;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/64c6c860-2b36-4c39-bf33-7b4a44813c67_1689243388.5248017.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_map<int,bool> mp;\\n    FindElements(TreeNode* root) {\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n        while(!q.empty())\\n        {\\n            int n = q.size(),f = 1;\\n            for(int i = 0;i<n;i++)\\n            {\\n              TreeNode*  node = q.front().first;\\n              int val = q.front().second;\\n              q.pop();\\n              if(node) mp[val] = true;\\n             if(node)\\n             {\\n                q.push({node->left,2*val+1});\\n                q.push({node->right,2*val+2});\\n                f = 0;\\n             }\\n             else\\n             {\\n                q.push({NULL,2*val+1});\\n                q.push({NULL,2*val+2});\\n              }\\n            }\\n            if(f) break;\\n        }  \\n    }\\n    bool find(int t) {\\n         return mp[t]==true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086295,
                "title": "simple-dfs-solution-beats-others",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* curr;\\n    FindElements(TreeNode* root) {\\n        curr=root;\\n    }\\n    bool findVal(TreeNode*root,int val,int x){\\n        if(!root)return false;\\n        if(val==0)return true;\\n        root->val=x;\\n        if(root->val==val)return true;       \\n        return findVal(root->left,val,(2*root->val)+1)||  findVal(root->right,val,(2*root->val)+2);\\n    }\\n    \\n    bool find(int target) {\\n        return findVal(curr,target,0);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* curr;\\n    FindElements(TreeNode* root) {\\n        curr=root;\\n    }\\n    bool findVal(TreeNode*root,int val,int x){\\n        if(!root)return false;\\n        if(val==0)return true;\\n        root->val=x;\\n        if(root->val==val)return true;       \\n        return findVal(root->left,val,(2*root->val)+1)||  findVal(root->right,val,(2*root->val)+2);\\n    }\\n    \\n    bool find(int target) {\\n        return findVal(curr,target,0);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3076480,
                "title": "easy-understading-and-memory-efficient-solution-in-js",
                "content": "```\\nvar FindElements = function(root) {\\n    this.tree = root\\n};\\n\\n/** \\n * @param {number} target\\n * @return {boolean}\\n */\\nFindElements.prototype.find = function(target) {\\n    this.tree.val = 0;\\n    function find(target,root){\\n        if(!root) return false;\\n        let val = root.val\\n        if(val === target) return true;\\n        if(root.left) {\\n            root.left.val = 2*val +1;\\n            if(find(target,root.left)) return true\\n        }\\n        if(root.right) {\\n            root.right.val = 2*val +2;\\n            if(find(target,root.right))return true\\n        }\\n        return false\\n    }\\n     return find(target,this.tree)\\n    \\n};",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nvar FindElements = function(root) {\\n    this.tree = root\\n};\\n\\n/** \\n * @param {number} target\\n * @return {boolean}\\n */\\nFindElements.prototype.find = function(target) {\\n    this.tree.val = 0;\\n    function find(target,root){\\n        if(!root) return false;\\n        let val = root.val\\n        if(val === target) return true;\\n        if(root.left) {\\n            root.left.val = 2*val +1;\\n            if(find(target,root.left)) return true\\n        }\\n        if(root.right) {\\n            root.right.val = 2*val +2;\\n            if(find(target,root.right))return true\\n        }\\n        return false\\n    }\\n     return find(target,this.tree)\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2998771,
                "title": "c-array-and-tree-easiest-approach",
                "content": "\\n# Approach\\nForming a array to store binary tree. The values that is asked to store is similar to index that we use to store element of tree in array. Only storing a tree will take O(n). Otherwise find function will take O(1) time as it is only checking whether at target value, i.e., same as index of array is -1 or not.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ ---- where n is the number of nodes in tree.\\n\\n# Code\\n```\\nclass FindElements {\\n    vector<int> treeArr;\\npublic:\\n    FindElements(TreeNode* root) {\\n        treeArr = vector<int>(1e6+1, -1);\\n        dfs(root, 0);\\n    }\\n\\n    void dfs(TreeNode* root, int i){\\n        if(root == NULL || i > 1e6)\\n            return;\\n\\n        treeArr[i] = i;\\n        dfs(root->left, 2*i+1);\\n        dfs(root->right, 2*i+2);\\n    }\\n    \\n    bool find(int target) {\\n        if(treeArr[target] == -1)\\n            return false;\\n\\n        return true;\\n    }\\n};\\n```\\n\\n---\\n\\n```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass FindElements {\\n    vector<int> treeArr;\\npublic:\\n    FindElements(TreeNode* root) {\\n        treeArr = vector<int>(1e6+1, -1);\\n        dfs(root, 0);\\n    }\\n\\n    void dfs(TreeNode* root, int i){\\n        if(root == NULL || i > 1e6)\\n            return;\\n\\n        treeArr[i] = i;\\n        dfs(root->left, 2*i+1);\\n        dfs(root->right, 2*i+2);\\n    }\\n    \\n    bool find(int target) {\\n        if(treeArr[target] == -1)\\n            return false;\\n\\n        return true;\\n    }\\n};\\n```\n```\\nIf you learn/found something new please upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816045,
                "title": "java-easy-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSave all the nodes value in HashSet\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FindElements {\\n\\n    Set<Integer> nodes;\\n    public FindElements(TreeNode root) {\\n        nodes = new HashSet<>();\\n        recover(root,0);\\n    }\\n    private void recover(TreeNode root, int parent){\\n        if(root == null){\\n            return;\\n        }\\n        root.val = parent;\\n        nodes.add(root.val);\\n        recover(root.left,2*parent+1);\\n        recover(root.right,2*parent+2);\\n    }\\n    public boolean find(int target) {\\n        return nodes.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass FindElements {\\n\\n    Set<Integer> nodes;\\n    public FindElements(TreeNode root) {\\n        nodes = new HashSet<>();\\n        recover(root,0);\\n    }\\n    private void recover(TreeNode root, int parent){\\n        if(root == null){\\n            return;\\n        }\\n        root.val = parent;\\n        nodes.add(root.val);\\n        recover(root.left,2*parent+1);\\n        recover(root.right,2*parent+2);\\n    }\\n    public boolean find(int target) {\\n        return nodes.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025906,
                "title": "easy-python-solution-faster-than-99-76-ms-comments",
                "content": "# Easy Python Solution | Faster than 99% (76 ms) | With Comments\\n\\n**Runtime: 76 ms, faster than 99.13% of Python3 online submissions for Find Elements in a Contaminated Binary Tree.\\nMemory Usage: 17.9 MB**\\n\\n```\\nclass FindElements:\\n    \\n    def dfs(self, node, val):\\n        if node:\\n            self.store[val] = 1  # adding the value of node to hashmap\\n            if node.left:\\n                vl = (2 * val) + 1  # correcting the value of left node\\n                self.dfs(node.left,vl)  # left sub tree traversal\\n            if node.right:\\n                vr = (2* val) + 2  # correcting the value of right node\\n                self.dfs(node.right, vr)  # right sub tree traversal\\n\\n    def __init__(self, root: TreeNode):\\n        self.store = {}  # hashmap for storing the corrected node values. And searching the values.\\n        self.dfs(root, 0)  # Traversing the incorrect tree and saving correct values on the way\\n\\n    def find(self, target: int) -> bool:\\n\\t\\t# checking if the target value exists in O(1) time\\n        if self.store.get(target, None) is not None:\\n            return True\\n        else:\\n            return False\\n```\\n![image](https://assets.leetcode.com/users/images/378c2109-1b90-48a2-829e-fab65cc6abbc_1652190280.408396.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass FindElements:\\n    \\n    def dfs(self, node, val):\\n        if node:\\n            self.store[val] = 1  # adding the value of node to hashmap\\n            if node.left:\\n                vl = (2 * val) + 1  # correcting the value of left node\\n                self.dfs(node.left,vl)  # left sub tree traversal\\n            if node.right:\\n                vr = (2* val) + 2  # correcting the value of right node\\n                self.dfs(node.right, vr)  # right sub tree traversal\\n\\n    def __init__(self, root: TreeNode):\\n        self.store = {}  # hashmap for storing the corrected node values. And searching the values.\\n        self.dfs(root, 0)  # Traversing the incorrect tree and saving correct values on the way\\n\\n    def find(self, target: int) -> bool:\\n\\t\\t# checking if the target value exists in O(1) time\\n        if self.store.get(target, None) is not None:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772130,
                "title": "beginner-friendly-python-soluiton",
                "content": "**Time Complexity : O(N)**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        self.st = set()\\n        \\n        def recover(root, val) :\\n            if(root):\\n                self.st.add(val)\\n                recover(root.left, 2 * val + 1)\\n                recover(root.right, 2 * val + 2)\\n        \\n        recover(root, 0)\\n        \\n\\n    def find(self, target):\\n        return target in self.st\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        self.st = set()\\n        \\n        def recover(root, val) :\\n            if(root):\\n                self.st.add(val)\\n                recover(root.left, 2 * val + 1)\\n                recover(root.right, 2 * val + 2)\\n        \\n        recover(root, 0)\\n        \\n\\n    def find(self, target):\\n        return target in self.st\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702451,
                "title": "c-easy-and-concise",
                "content": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int>st;\\n    void makeTree(TreeNode* root,int data)\\n    {\\n        if(!root) return;\\n        root->val=data;\\n        st.insert(data);\\n        makeTree(root->left,(data*2+1));\\n        makeTree(root->right,(data*2+2));\\n            \\n    }\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        makeTree(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return st.find(target)!=st.end();\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int>st;\\n    void makeTree(TreeNode* root,int data)\\n    {\\n        if(!root) return;\\n        root->val=data;\\n        st.insert(data);\\n        makeTree(root->left,(data*2+1));\\n        makeTree(root->right,(data*2+2));\\n            \\n    }\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        makeTree(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return st.find(target)!=st.end();\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628594,
                "title": "c-easy-to-implementation",
                "content": "class FindElements {\\npublic:\\n\\n    set<int>s;\\n    void solve(TreeNode *root)\\n    {\\n          if(root)\\n          {\\n             int x=root->val;\\n             if(root->left)\\n             {\\n               root->left->val=2*x+1;\\n               s.insert(2*x+1);\\n               solve(root->left);\\n             }\\n            if(root->right)\\n            {\\n              root->right->val=2*x+2;\\n              s.insert(2*x+2);\\n              solve(root->right);\\n            }\\n          }\\n    }\\n    FindElements(TreeNode* root) {\\n         root->val=0;\\n         s.insert(0);\\n         solve(root);\\n    } \\n    \\n    bool find(int t) {\\n        if(s.find(t)!=s.end())\\n          return true;\\n      return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "class FindElements {\\npublic:\\n\\n    set<int>s;\\n    void solve(TreeNode *root)\\n    {\\n          if(root)\\n          {\\n             int x=root->val;\\n             if(root->left)\\n             {\\n               root->left->val=2*x+1;\\n               s.insert(2*x+1);\\n               solve(root->left);\\n             }\\n            if(root->right)\\n            {\\n              root->right->val=2*x+2;\\n              s.insert(2*x+2);\\n              solve(root->right);\\n            }\\n          }\\n    }\\n    FindElements(TreeNode* root) {\\n         root->val=0;\\n         s.insert(0);\\n         solve(root);\\n    } \\n    \\n    bool find(int t) {\\n        if(s.find(t)!=s.end())\\n          return true;\\n      return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1626666,
                "title": "c-easy-map",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    int x = 0 ; \\n    map<int,int>mp ; \\n    void build(TreeNode *root , int x)\\n    {\\n        if(root == nullptr)\\n        {\\n            return ; \\n        }\\n        root->val = x ; \\n        mp[x]++ ; \\n        build(root->left,2*x+1);\\n        build(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n         build(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target) != mp.end())\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    int x = 0 ; \\n    map<int,int>mp ; \\n    void build(TreeNode *root , int x)\\n    {\\n        if(root == nullptr)\\n        {\\n            return ; \\n        }\\n        root->val = x ; \\n        mp[x]++ ; \\n        build(root->left,2*x+1);\\n        build(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n         build(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target) != mp.end())\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 1514524,
                "title": "c-easy-solution",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> set;\\n    void recover(TreeNode* root , int x){\\n        if(!root ){\\n            return ;\\n        }\\n        set.insert(x);\\n        recover(root->left , 2*x+1);\\n        recover(root->right , 2*x+2);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n              recover(root, 0);\\n\\n    }\\n\\n    bool find(int target) {\\n    return set.count(target);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> set;\\n    void recover(TreeNode* root , int x){\\n        if(!root ){\\n            return ;\\n        }\\n        set.insert(x);\\n        recover(root->left , 2*x+1);\\n        recover(root->right , 2*x+2);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n              recover(root, 0);\\n\\n    }\\n\\n    bool find(int target) {\\n    return set.count(target);\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1363748,
                "title": "c-99-faster-simple-dfs",
                "content": "```\\nclass FindElements {\\npublic:\\n    vector<bool> mapper;\\n    FindElements(TreeNode* root) {\\n        mapper.resize(1000005,false);\\n        filterThis(root,0);\\n    }\\n    void filterThis(TreeNode* root, int x) {\\n        if(!root) return;\\n        if(x<=1000001) {\\n            mapper[x] = true; \\n            filterThis(root->left, 2*x+1);\\n            filterThis(root->right,2*x+2);\\n        }\\n    }\\n    bool find(int target) {\\n        return mapper[target];\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\npublic:\\n    vector<bool> mapper;\\n    FindElements(TreeNode* root) {\\n        mapper.resize(1000005,false);\\n        filterThis(root,0);\\n    }\\n    void filterThis(TreeNode* root, int x) {\\n        if(!root) return;\\n        if(x<=1000001) {\\n            mapper[x] = true; \\n            filterThis(root->left, 2*x+1);\\n            filterThis(root->right,2*x+2);\\n        }\\n    }\\n    bool find(int target) {\\n        return mapper[target];\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 431461,
                "title": "c-simple-easy-brute-force",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass FindElements {\\nprivate: \\n    TreeNode* root;\\npublic:\\n    \\n    void itr(TreeNode *root, int vl){\\n        if(!root) return;\\n        root->val = vl;\\n        itr(root->left,2*vl+1);\\n        itr(root->right,2*vl+2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n            if(!root)\\n                return;\\n            itr(root,0);\\n            this->root = root;\\n        \\n    }\\n    \\n    bool fnd(TreeNode * root, int target){\\n        if(!root)\\n            return false;\\n        if(root->val==target)\\n            return true;\\n        return fnd(root->left, target) || fnd(root->right, target);\\n    }\\n    \\n    bool find(int target) {\\n        return fnd(root, target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass FindElements {\\nprivate: \\n    TreeNode* root;\\npublic:\\n    \\n    void itr(TreeNode *root, int vl){\\n        if(!root) return;\\n        root->val = vl;\\n        itr(root->left,2*vl+1);\\n        itr(root->right,2*vl+2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n            if(!root)\\n                return;\\n            itr(root,0);\\n            this->root = root;\\n        \\n    }\\n    \\n    bool fnd(TreeNode * root, int target){\\n        if(!root)\\n            return false;\\n        if(root->val==target)\\n            return true;\\n        return fnd(root->left, target) || fnd(root->right, target);\\n    }\\n    \\n    bool find(int target) {\\n        return fnd(root, target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063151,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n\\n    static void recover(TreeNode root){\\n        if(root==null) return;\\n\\n        int x = root.val;\\n        if(root.left!=null) root.left.val = 2*x+1;\\n        if(root.right!=null) root.right.val = 2*x+2;\\n        recover(root.left);\\n        recover(root.right);\\n    }\\n\\n    static boolean check(TreeNode root, int a){\\n        if(root==null) return false;\\n        if(root.val==a) return true;\\n\\n        return check(root.left,a) || check(root.right,a);\\n    }\\n\\n    public FindElements(TreeNode x) {\\n        root = x;\\n        root.val = 0;\\n        recover(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return check(root,target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n\\n    static void recover(TreeNode root){\\n        if(root==null) return;\\n\\n        int x = root.val;\\n        if(root.left!=null) root.left.val = 2*x+1;\\n        if(root.right!=null) root.right.val = 2*x+2;\\n        recover(root.left);\\n        recover(root.right);\\n    }\\n\\n    static boolean check(TreeNode root, int a){\\n        if(root==null) return false;\\n        if(root.val==a) return true;\\n\\n        return check(root.left,a) || check(root.right,a);\\n    }\\n\\n    public FindElements(TreeNode x) {\\n        root = x;\\n        root.val = 0;\\n        recover(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return check(root,target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026035,
                "title": "easy-friendly-c-solution-based-on-precomputation-o-1-query-runtime",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt uses preorder DFS to recover all the nodes recursively, while also maintaining a hashmap for the found values so that we can easily hunt for the target value in the query.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ in recovering the tree, $$O(1)$$ for queries.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for the recursive stack and the hashmap.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FindElements {\\npublic:\\n    unordered_map <int, bool> map;\\n\\n    void solve (TreeNode* root, int i) {\\n        if (!root) return;\\n        root->val = i;\\n        map[i] = true;\\n        solve (root->left, 2*i + 1);\\n        solve(root->right, 2*i + 2);\\n    }\\n\\n    FindElements(TreeNode* root) {\\n        solve(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        if (map.find(target) != map.end()) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_map <int, bool> map;\\n\\n    void solve (TreeNode* root, int i) {\\n        if (!root) return;\\n        root->val = i;\\n        map[i] = true;\\n        solve (root->left, 2*i + 1);\\n        solve(root->right, 2*i + 2);\\n    }\\n\\n    FindElements(TreeNode* root) {\\n        solve(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        if (map.find(target) != map.end()) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019065,
                "title": "simple-solution-with-depth-first-search-hashset-in-python3",
                "content": "# Intuition\\nThe problem description is the following:\\n- there\\'s a **Binary Tree**, all of its values equal to `-1`\\n- our goal is to **recover** all nodes by changing values according to the schema\\n\\n```py\\n# Example\\ntree = TreeNode(-1, None, TreeNode(-1, TreeNode(-1)))\\n\\n# The original values in left parentheses and \\n# restored in right ones \\n#   (-1) => (0)\\n#     \\\\       \\\\\\n#     (-1) => (2)\\n#      /      /\\n#    (-1)=> (5)\\n\\n# The formulae to calculate value for a particular node\\n# is the following (for root.val == 0)\\n# node.left.val = parentNode.val * 2 + 1 \\n# node.right.val = parentNode.val * 2 + 2\\n \\n```\\n\\n# Approach \\n1. define a `set`, that\\'ll store all of the traversed values from `root` to quick search inside `find` method\\n2. define `recover` function to recover the values of a tree\\n3. if there\\'s no `node` return `None`\\n4. if the `left` or `right` children exist, change the values according to the schema and store the values inside `self.set`\\n5. implement the `find` method with checking value in `self.set`\\n\\n# Complexity\\n- Time complexity: **O(n)**, because of iterating over `root`\\n\\n- Space complexity: **O(n)**, because of recursive call stack and storing all the values inside `self.set`\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def recover(self, node):\\n        if not node: \\n            return node\\n\\n        node.val = 0\\n        \\n        def dfs(node, val = 0):\\n            if not node:\\n                return \\n            if node.left:\\n                node.left.val = val * 2 + 1\\n                self.set.add(node.left.val)\\n                dfs(node.left, node.left.val)\\n            if node.right:\\n                node.right.val = val * 2 + 2\\n                self.set.add(node.right.val)\\n                dfs(node.right, node.right.val)\\n\\n        dfs(node)\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.set = {0}\\n        self.recover(root)\\n        self.root = root\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.set\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```py\\n# Example\\ntree = TreeNode(-1, None, TreeNode(-1, TreeNode(-1)))\\n\\n# The original values in left parentheses and \\n# restored in right ones \\n#   (-1) => (0)\\n#     \\\\       \\\\\\n#     (-1) => (2)\\n#      /      /\\n#    (-1)=> (5)\\n\\n# The formulae to calculate value for a particular node\\n# is the following (for root.val == 0)\\n# node.left.val = parentNode.val * 2 + 1 \\n# node.right.val = parentNode.val * 2 + 2\\n \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def recover(self, node):\\n        if not node: \\n            return node\\n\\n        node.val = 0\\n        \\n        def dfs(node, val = 0):\\n            if not node:\\n                return \\n            if node.left:\\n                node.left.val = val * 2 + 1\\n                self.set.add(node.left.val)\\n                dfs(node.left, node.left.val)\\n            if node.right:\\n                node.right.val = val * 2 + 2\\n                self.set.add(node.right.val)\\n                dfs(node.right, node.right.val)\\n\\n        dfs(node)\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.set = {0}\\n        self.recover(root)\\n        self.root = root\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.set\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637883,
                "title": "easy-solution-using-set-and-traversal-in-c",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    set<int> num;\\n    void traverse(TreeNode *root) {\\n        \\n        if(root == NULL) {\\n            return;\\n        }\\n        if(root->left) {\\n            root->left->val = 2 * root->val + 1;\\n            num.insert(2 * root->val + 1);\\n            traverse(root->left);\\n        }\\n        if(root->right) {\\n            root->right->val = 2 * root->val + 2;\\n            num.insert(2 * root->val + 2);\\n            traverse(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        num.insert(0);\\n        traverse(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(num.find(target) != num.end()) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    set<int> num;\\n    void traverse(TreeNode *root) {\\n        \\n        if(root == NULL) {\\n            return;\\n        }\\n        if(root->left) {\\n            root->left->val = 2 * root->val + 1;\\n            num.insert(2 * root->val + 1);\\n            traverse(root->left);\\n        }\\n        if(root->right) {\\n            root->right->val = 2 * root->val + 2;\\n            num.insert(2 * root->val + 2);\\n            traverse(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        num.insert(0);\\n        traverse(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(num.find(target) != num.end()) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589532,
                "title": "c-solution-using-preorder-traversal-and-hashmap",
                "content": "# Intuition\\nWe simply need to store the appropriate values for non-empty nodes and update their values as required. As the values for the left or right child depend on the root value, so we update that first.\\n\\n# Approach\\nWe apply pre-order traversal where we first visit the root, then the left child and right child respectively. Map is used to store the node values accordingly. \\n\\n# Complexity\\n- Time complexity:\\nFor FindElements:- O(N)\\nFor find:- O(1)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nmap<int,int> mp;\\nvoid preorder(TreeNode* root){\\n        //base case\\n        if(root==NULL){\\n        return;\\n        }\\n        if(root->left){\\n            mp[2*root->val +1];\\n            root->left->val = 2*root->val+1;\\n        preorder(root->left);\\n        }\\n        if(root->right){\\n            mp[2*root->val + 2];\\n            root->right->val = 2*root->val+2;\\n        preorder(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        if(root!=NULL) {mp[0]++;\\n        root->val = 0;\\n        preorder(root);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return mp.find(target) != mp.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```\\nPlease upvote if you understod the solution!\\nHave a great day :)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nmap<int,int> mp;\\nvoid preorder(TreeNode* root){\\n        //base case\\n        if(root==NULL){\\n        return;\\n        }\\n        if(root->left){\\n            mp[2*root->val +1];\\n            root->left->val = 2*root->val+1;\\n        preorder(root->left);\\n        }\\n        if(root->right){\\n            mp[2*root->val + 2];\\n            root->right->val = 2*root->val+2;\\n        preorder(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        if(root!=NULL) {mp[0]++;\\n        root->val = 0;\\n        preorder(root);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return mp.find(target) != mp.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576674,
                "title": "map-post-order",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    FindElements(TreeNode* r) {\\n        dfs(r,0);\\n    }\\n    \\n    void dfs(TreeNode* r,int val)\\n    {\\n        if(!r)\\n            return;\\n        mp[val] = val;\\n        dfs(r->left,val*2+1);\\n        dfs(r->right,val*2+2);\\n        \\n    }\\n    \\n    bool find(int t) {\\n        return mp.count(t)>0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    FindElements(TreeNode* r) {\\n        dfs(r,0);\\n    }\\n    \\n    void dfs(TreeNode* r,int val)\\n    {\\n        if(!r)\\n            return;\\n        mp[val] = val;\\n        dfs(r->left,val*2+1);\\n        dfs(r->right,val*2+2);\\n        \\n    }\\n    \\n    bool find(int t) {\\n        return mp.count(t)>0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394657,
                "title": "easy-c",
                "content": "# Intuition :\\nDeclare global variable head in which we will store root and then pass it to find function and inside findelement function intialize root.val 0 and make new function help and pass root.\\n\\n# Approach : \\nBinary Tree\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode *head;\\n    void help(TreeNode *p){\\n        if(p->left != NULL){\\n            p->left->val = 2*p->val+1;\\n            help(p->left);\\n        }\\n        if(p->right != NULL){\\n            p->right->val = 2*p->val + 2;\\n            help(p->right);\\n        }\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        head = root;\\n        help(root);\\n    }\\n    bool findnode(TreeNode *root, int target){\\n        if(root==NULL) return false;\\n    if(root->val == target){\\n        return true;\\n    }\\n    else\\n    {\\n        bool ans=findnode(root->left , target);\\n        if(ans==true) return true;\\n        bool ans2=findnode(root->right , target);\\n        if(ans2==true) return true;\\n    }\\n    return false;\\n    }\\n    bool find(int target) {\\n       return findnode(head, target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode *head;\\n    void help(TreeNode *p){\\n        if(p->left != NULL){\\n            p->left->val = 2*p->val+1;\\n            help(p->left);\\n        }\\n        if(p->right != NULL){\\n            p->right->val = 2*p->val + 2;\\n            help(p->right);\\n        }\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        head = root;\\n        help(root);\\n    }\\n    bool findnode(TreeNode *root, int target){\\n        if(root==NULL) return false;\\n    if(root->val == target){\\n        return true;\\n    }\\n    else\\n    {\\n        bool ans=findnode(root->left , target);\\n        if(ans==true) return true;\\n        bool ans2=findnode(root->right , target);\\n        if(ans2==true) return true;\\n    }\\n    return false;\\n    }\\n    bool find(int target) {\\n       return findnode(head, target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394585,
                "title": "easy-using-unordered-map",
                "content": "# Intuition\\nThe intuition behind this code is to leverage the properties of a binary tree to efficiently check whether a particular value exists in it or not.\\n\\nThe constructor sets up a map that will keep track of all the integer values that exist in the binary tree. It uses a pre-order traversal to assign integer values to each node of the binary tree. The integer value of a node is calculated based on its position in the binary tree, where the root node has a value of 0, the left child of a node with value x has a value of 2x+1, and the right child of a node with value x has a value of 2x+2. This ensures that all nodes in the binary tree have a unique integer value.\\n\\nOnce all the integer values have been assigned to each node in the binary tree, the \"sexy\" map is updated to indicate that the integer value of each node exists in the binary tree.\\n\\nThe \"find\" method simply checks if the target value is present in the \"sexy\" map. Since the \"sexy\" map only contains integer values that exist in the binary tree, this allows for a quick check to determine if the target value exists in the binary tree or not.\\n\\nOverall, the intuition behind this code is to trade off additional memory usage for faster lookup times for checking whether a value exists in a binary tree.\\n\\n# Approach\\nThis code defines a class called \"FindElements\" which provides a way to find whether a target value exists in a binary tree. The binary tree is represented by a TreeNode* pointer to its root node.\\n\\nThe class has two public methods: \"FindElements\" (constructor) and \"find\". The constructor takes in a TreeNode* pointer to the root of the binary tree and sets up a map called \"sexy\" (not a very appropriate name) which maps integer values to boolean flags. The \"setting\" method is called recursively to traverse the binary tree in a pre-order manner and set the values of each node with an increasing integer value starting from 0, which represents the root node. As each node\\'s value is set, the \"sexy\" map is updated to mark that value as present in the binary tree.\\n\\nThe \"find\" method takes in a target integer value and returns whether that value is present in the binary tree by looking it up in the \"sexy\" map. If the target value exists in the binary tree, the method returns true, otherwise false.\\n\\nOverall, this code provides a simple way to check whether a particular value exists in a binary tree without having to traverse the entire tree each time. The downside is that it requires additional memory to maintain the \"sexy\" map.\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    unordered_map<int,bool> sexy;\\npublic:\\n\\n    void setting(TreeNode* root , int x){\\n        if(!root) return;\\n        root->val = x;\\n        sexy[x] = true;\\n        \\n        setting(root->left,2*x+1);\\n        setting(root->right,2*x+2);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        setting(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return sexy[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    unordered_map<int,bool> sexy;\\npublic:\\n\\n    void setting(TreeNode* root , int x){\\n        if(!root) return;\\n        root->val = x;\\n        sexy[x] = true;\\n        \\n        setting(root->left,2*x+1);\\n        setting(root->right,2*x+2);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        setting(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return sexy[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118073,
                "title": "c-solution",
                "content": "```\\nclass FindElements {\\npublic:\\n    void help(TreeNode* root){\\n        if(root->left){\\n            root->left->val = (2*root->val) +1;\\n            help(root->left);\\n        }\\n        \\n        if(root->right){\\n            root->right->val = (2*root->val) +2;\\n            help(root->right);\\n        }\\n    }\\n    \\n    TreeNode* head;\\n    \\n    FindElements(TreeNode* root) {\\n        head= root;\\n        root->val=0;\\n        help(root);\\n    }\\n    \\n    bool findd(TreeNode* root, int tar){\\n        if(!root)return false;\\n        if(root->val== tar) return true;\\n        \\n        return findd(root->left, tar)||findd(root->right, tar);\\n    }\\n    \\n    bool find(int target) {\\n        return findd(head, target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    void help(TreeNode* root){\\n        if(root->left){\\n            root->left->val = (2*root->val) +1;\\n            help(root->left);\\n        }\\n        \\n        if(root->right){\\n            root->right->val = (2*root->val) +2;\\n            help(root->right);\\n        }\\n    }\\n    \\n    TreeNode* head;\\n    \\n    FindElements(TreeNode* root) {\\n        head= root;\\n        root->val=0;\\n        help(root);\\n    }\\n    \\n    bool findd(TreeNode* root, int tar){\\n        if(!root)return false;\\n        if(root->val== tar) return true;\\n        \\n        return findd(root->left, tar)||findd(root->right, tar);\\n    }\\n    \\n    bool find(int target) {\\n        return findd(head, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921408,
                "title": "easy-to-understand-c-solution-using-recursion-and-bt",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* root1;\\n    TreeNode* answer(TreeNode* root,int x)\\n    {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        root->val=x;\\n        if(root->left!=NULL)\\n        {\\n          answer(root->left,2*x+1);\\n        }\\n        if(root->right!=NULL)\\n        {\\n          answer(root->right,2*x+2);\\n        }\\n        return root;\\n    }\\n    FindElements(TreeNode* root) {\\n        int x=0;\\n        root1=answer(root,x);\\n    }\\n    int maxi(TreeNode* temp,int target)//To find if target is in tree or not\\n    {\\n        if(temp==NULL)\\n        {\\n            return 0;\\n        }\\n         if(temp->val==target)\\n        {\\n            return 1;\\n        }\\n        int left=maxi(temp->left,target);\\n        int right=maxi(temp->right,target);\\n        return max(left,right);\\n    }\\n    bool find(int target) {\\n        TreeNode* temp=root1;\\n        int ans=maxi(temp,target);\\n        if(ans==0)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* root1;\\n    TreeNode* answer(TreeNode* root,int x)\\n    {\\n        if(root==NULL)\\n        {\\n            return root;\\n        }\\n        root->val=x;\\n        if(root->left!=NULL)\\n        {\\n          answer(root->left,2*x+1);\\n        }\\n        if(root->right!=NULL)\\n        {\\n          answer(root->right,2*x+2);\\n        }\\n        return root;\\n    }\\n    FindElements(TreeNode* root) {\\n        int x=0;\\n        root1=answer(root,x);\\n    }\\n    int maxi(TreeNode* temp,int target)//To find if target is in tree or not\\n    {\\n        if(temp==NULL)\\n        {\\n            return 0;\\n        }\\n         if(temp->val==target)\\n        {\\n            return 1;\\n        }\\n        int left=maxi(temp->left,target);\\n        int right=maxi(temp->right,target);\\n        return max(left,right);\\n    }\\n    bool find(int target) {\\n        TreeNode* temp=root1;\\n        int ans=maxi(temp,target);\\n        if(ans==0)\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720120,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n  unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n  unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672559,
                "title": "recursive-approach",
                "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* start;\\n    void modify(TreeNode* root)  //function to modify tree\\n    {  if(!root)\\n        return;        \\n        if(root->left!=NULL)\\n            root->left->val=2*root->val+1;\\n        if(root->right!=NULL)\\n            root->right->val=2*root->val+2;\\n        modify(root->left);\\n        modify(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        start=root;\\n        if(!root)\\n            return;\\n        root->val=0;\\n        modify(root);\\n        \\n    }\\n    \\n    bool find(int target) {\\n        return findval(start,target);\\n    }\\n    bool findval(TreeNode* root,int target)\\n    {\\n       if(!root)\\n           return false;\\n        \\n        if(root->val==target)\\n            return true;\\n        else\\n            return findval(root->left,target) || findval(root->right,target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* start;\\n    void modify(TreeNode* root)  //function to modify tree\\n    {  if(!root)\\n        return;        \\n        if(root->left!=NULL)\\n            root->left->val=2*root->val+1;\\n        if(root->right!=NULL)\\n            root->right->val=2*root->val+2;\\n        modify(root->left);\\n        modify(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        start=root;\\n        if(!root)\\n            return;\\n        root->val=0;\\n        modify(root);\\n        \\n    }\\n    \\n    bool find(int target) {\\n        return findval(start,target);\\n    }\\n    bool findval(TreeNode* root,int target)\\n    {\\n       if(!root)\\n           return false;\\n        \\n        if(root->val==target)\\n            return true;\\n        else\\n            return findval(root->left,target) || findval(root->right,target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2553191,
                "title": "simple-dfs-solution-c",
                "content": "**Please upvote if you like my solution .**\\n```\\nclass FindElements {\\npublic:\\n    // to return answer in O( 1 )  by storing if node with value is present or not\\n    vector<bool> node;\\n    // doing dfs and updating node value \\n    void dfs(TreeNode* r, int i){\\n        if(r == NULL) return;\\n        if(i < 1000000)\\n            node[i] = 1;\\n        dfs(r->left ,i*2 + 1);\\n        dfs(r->right,i*2 + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        node.reserve(1000000); // max value of node is 1000000 \\n        for(int i = 0 ; i < 1000000; i++) node[i] = 0; // in start \\n        dfs(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return node[target]; // return present or not \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    // to return answer in O( 1 )  by storing if node with value is present or not\\n    vector<bool> node;\\n    // doing dfs and updating node value \\n    void dfs(TreeNode* r, int i){\\n        if(r == NULL) return;\\n        if(i < 1000000)\\n            node[i] = 1;\\n        dfs(r->left ,i*2 + 1);\\n        dfs(r->right,i*2 + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        node.reserve(1000000); // max value of node is 1000000 \\n        for(int i = 0 ; i < 1000000; i++) node[i] = 0; // in start \\n        dfs(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return node[target]; // return present or not \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469299,
                "title": "c-easy-fully-commented-logic",
                "content": "```   \\n//this will store values of all the nodes\\n    map<int,int>m;\\n    \\n    void calc(TreeNode* root,int &r)\\n    {\\n        //if not root then simply return\\n        if(!root)\\n            return;\\n        //if it is a root then make it 0\\n        if(r==-1)\\n        {\\n            m[0]++;\\n            root->val=0;\\n            //change r so that no other node gets value 0\\n            r=10;\\n        }\\n        //if left child exists then update it\\'s value\\n        if(root->left)\\n        {\\n             root->left->val=2*root->val+1;\\n            //don\\'t forget to map the value\\n            m[root->left->val]++;\\n        }\\n        //if right child exists then update it\\'s value\\n        if(root->right)\\n        {\\n            root->right->val=2*root->val+2;\\n            //don\\'t forget to map the value\\n            m[root->right->val]++;\\n        }\\n        //recursively do the same with other nodes\\n        calc(root->left,r);\\n        calc(root->right,r);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        //this r will help us recognise root so that we can initialise root with 0\\n        int r=-1;\\n        calc(root,r);\\n    }\\n    \\n    bool find(int target) {\\n        //since we don\\'t have root in this func hence we used map to map all the values of node and now we will just check if target is there in the tree or not\\n       if(m.find(target)!=m.end())\\n           return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```   \\n//this will store values of all the nodes\\n    map<int,int>m;\\n    \\n    void calc(TreeNode* root,int &r)\\n    {\\n        //if not root then simply return\\n        if(!root)\\n            return;\\n        //if it is a root then make it 0\\n        if(r==-1)\\n        {\\n            m[0]++;\\n            root->val=0;\\n            //change r so that no other node gets value 0\\n            r=10;\\n        }\\n        //if left child exists then update it\\'s value\\n        if(root->left)\\n        {\\n             root->left->val=2*root->val+1;\\n            //don\\'t forget to map the value\\n            m[root->left->val]++;\\n        }\\n        //if right child exists then update it\\'s value\\n        if(root->right)\\n        {\\n            root->right->val=2*root->val+2;\\n            //don\\'t forget to map the value\\n            m[root->right->val]++;\\n        }\\n        //recursively do the same with other nodes\\n        calc(root->left,r);\\n        calc(root->right,r);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        //this r will help us recognise root so that we can initialise root with 0\\n        int r=-1;\\n        calc(root,r);\\n    }\\n    \\n    bool find(int target) {\\n        //since we don\\'t have root in this func hence we used map to map all the values of node and now we will just check if target is there in the tree or not\\n       if(m.find(target)!=m.end())\\n           return true;\\n        return false;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2421082,
                "title": "c-simple-and-very-easy-to-understand",
                "content": "Do upvote , if you find this helpful.\\n```\\n\\nunordered_set<int>s;\\n    void contaminate(TreeNode *root)\\n    {\\n        if(!root) return;\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=(2*root->val)+1;\\n            s.emplace(root->left->val);\\n        }\\n        contaminate(root->left);\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=(2*root->val)+2;\\n            s.emplace(root->right->val);\\n        }\\n        contaminate(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.emplace(0);\\n        contaminate(root);\\n    }\\n    \\n    bool find(int target) {\\n        return s.count(target);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\n\\nunordered_set<int>s;\\n    void contaminate(TreeNode *root)\\n    {\\n        if(!root) return;\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=(2*root->val)+1;\\n            s.emplace(root->left->val);\\n        }\\n        contaminate(root->left);\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=(2*root->val)+2;\\n            s.emplace(root->right->val);\\n        }\\n        contaminate(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.emplace(0);\\n        contaminate(root);\\n    }\\n    \\n    bool find(int target) {\\n        return s.count(target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2323971,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-dfs-hashset",
                "content": "```C#\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class FindElements {\\n    private readonly HashSet<int> _values = new ();\\n    \\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n        Recover(root);\\n    }\\n    \\n    public bool Find(int target) => this._values.Contains(target);\\n    \\n    private void Recover(TreeNode node) {\\n        if (node != null) {\\n            this._values.Add(node.val);\\n            if (node.left != null) { node.left.val = node.val * 2 + 1; this.Recover(node.left); }\\n            if (node.right != null) { node.right.val = node.val * 2 + 2; this.Recover(node.right); }\\n        }\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * bool param_1 = obj.Find(target);\\n */\\n ```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```C#\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class FindElements {\\n    private readonly HashSet<int> _values = new ();\\n    \\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n        Recover(root);\\n    }\\n    \\n    public bool Find(int target) => this._values.Contains(target);\\n    \\n    private void Recover(TreeNode node) {\\n        if (node != null) {\\n            this._values.Add(node.val);\\n            if (node.left != null) { node.left.val = node.val * 2 + 1; this.Recover(node.left); }\\n            if (node.right != null) { node.right.val = node.val * 2 + 2; this.Recover(node.right); }\\n        }\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * bool param_1 = obj.Find(target);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2317652,
                "title": "c-binarytree-traversal-simple-logic",
                "content": "![image](https://assets.leetcode.com/users/images/8bdb09f3-956f-429a-8de1-214e5e31cff0_1658493827.5027375.png)\\n\\n**n==No. of Nodes\\nFindElements Operation T->O(n)\\nFind Opeartion T->O(n)**\\n\\n\\tclass FindElements {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* r;\\n\\t\\t\\tvoid recover(TreeNode* curr,int x){\\n\\t\\t\\t\\tif(!curr)return ;\\n\\t\\t\\t\\tcurr->val=x;\\n\\t\\t\\t\\trecover(curr->left,2*x+1);\\n\\t\\t\\t\\trecover(curr->right,2*x+2);\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool f(TreeNode* curr,int target){\\n\\t\\t\\t\\tif(!curr)return false;\\n\\t\\t\\t\\tif(curr->val==target)return true;\\n\\t\\t\\t\\treturn f(curr->left,target) || f(curr->right,target);\\n\\t\\t\\t}\\n\\n\\t\\t\\tFindElements(TreeNode* root) {\\n\\t\\t\\t\\tr=root;\\n\\t\\t\\t\\trecover(root,0);\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool find(int target) {\\n\\t\\t\\t\\treturn f(r,target);\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/8bdb09f3-956f-429a-8de1-214e5e31cff0_1658493827.5027375.png)\\n\\n**n==No. of Nodes\\nFindElements Operation T->O(n)\\nFind Opeartion T->O(n)**\\n\\n\\tclass FindElements {\\n\\t\\tpublic:\\n\\t\\t\\tTreeNode* r;\\n\\t\\t\\tvoid recover(TreeNode* curr,int x){\\n\\t\\t\\t\\tif(!curr)return ;\\n\\t\\t\\t\\tcurr->val=x;\\n\\t\\t\\t\\trecover(curr->left,2*x+1);\\n\\t\\t\\t\\trecover(curr->right,2*x+2);\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool f(TreeNode* curr,int target){\\n\\t\\t\\t\\tif(!curr)return false;\\n\\t\\t\\t\\tif(curr->val==target)return true;\\n\\t\\t\\t\\treturn f(curr->left,target) || f(curr->right,target);\\n\\t\\t\\t}\\n\\n\\t\\t\\tFindElements(TreeNode* root) {\\n\\t\\t\\t\\tr=root;\\n\\t\\t\\t\\trecover(root,0);\\n\\t\\t\\t}\\n\\n\\t\\t\\tbool find(int target) {\\n\\t\\t\\t\\treturn f(r,target);\\n\\t\\t\\t}\\n\\t\\t};",
                "codeTag": "Java"
            },
            {
                "id": 2307892,
                "title": "c-dfs-hash-set-time-o-n-space-o-n",
                "content": "DFS solution\\n* the constructor, perform DFS traversal on the tree and insert values into a hash set if the nodes exist\\n* find() searchs the target from the hash set in O(1) time\\n```\\n// time: O(n) for constructor, O(1) for find()\\n// space: O(n)\\n\\nclass FindElements {\\npublic:\\n  FindElements(TreeNode* root) {\\n    traverse(root, 0);\\n  }\\n  \\n  bool find(int target) {\\n    return valueSet.count(target);\\n  }\\n  \\nprivate:\\n  unordered_set<int> valueSet;\\n  \\n  void traverse(TreeNode* node, int val) {\\n    if (!node)\\n      return;\\n    \\n    valueSet.insert(val);\\n    \\n    traverse(node->left, val * 2 + 1);\\n    traverse(node->right, val * 2 + 2);\\n  }\\n};\\n```\\n\\nThanks for watching : )",
                "solutionTags": [],
                "code": "```\\n// time: O(n) for constructor, O(1) for find()\\n// space: O(n)\\n\\nclass FindElements {\\npublic:\\n  FindElements(TreeNode* root) {\\n    traverse(root, 0);\\n  }\\n  \\n  bool find(int target) {\\n    return valueSet.count(target);\\n  }\\n  \\nprivate:\\n  unordered_set<int> valueSet;\\n  \\n  void traverse(TreeNode* node, int val) {\\n    if (!node)\\n      return;\\n    \\n    valueSet.insert(val);\\n    \\n    traverse(node->left, val * 2 + 1);\\n    traverse(node->right, val * 2 + 2);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290791,
                "title": "go-with-map",
                "content": "```\\ntype FindElements struct {\\n    m map[int]struct{}\\n}\\n\\nfunc Constructor(root *TreeNode) FindElements {\\n    m := make(map[int]struct{})\\n    \\n    var recoverTree func(*TreeNode, int)\\n    recoverTree = func(root *TreeNode, val int)  {\\n        if root == nil {\\n            return\\n        }\\n        \\n        m[val] = struct{}{}\\n        \\n        recoverTree(root.Left, 2*val+1)\\n        recoverTree(root.Right, 2*val+2)\\n    }\\n    \\n    recoverTree(root, 0)\\n    \\n    return FindElements {\\n        m: m,\\n    }\\n}\\n\\n\\nfunc (this *FindElements) Find(target int) bool {\\n    if _, ok := this.m[target]; ok {\\n        return true\\n    }\\n    \\n    return false\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\ntype FindElements struct {\\n    m map[int]struct{}\\n}\\n\\nfunc Constructor(root *TreeNode) FindElements {\\n    m := make(map[int]struct{})\\n    \\n    var recoverTree func(*TreeNode, int)\\n    recoverTree = func(root *TreeNode, val int)  {\\n        if root == nil {\\n            return\\n        }\\n        \\n        m[val] = struct{}{}\\n        \\n        recoverTree(root.Left, 2*val+1)\\n        recoverTree(root.Right, 2*val+2)\\n    }\\n    \\n    recoverTree(root, 0)\\n    \\n    return FindElements {\\n        m: m,\\n    }\\n}\\n\\n\\nfunc (this *FindElements) Find(target int) bool {\\n    if _, ok := this.m[target]; ok {\\n        return true\\n    }\\n    \\n    return false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2099200,
                "title": "golang",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\ntype FindElements struct {\\n    set map[int]bool\\n}\\n\\nfunc (this *FindElements)constructTree(root *TreeNode, x int) {\\n    if root==nil {\\n        return\\n    }\\n    root.Val=x\\n    this.set[x]=true \\n    this.constructTree(root.Left, (2*x)+1)\\n    this.constructTree(root.Right, (2*x)+2)\\n}\\nfunc Constructor(root *TreeNode) FindElements {\\n    m:=map[int]bool{}\\n    \\n    this:=FindElements{}\\n    this.set=m\\n    this.constructTree(root, 0)\\n    return this\\n}\\n\\n\\nfunc (this *FindElements) Find(target int) bool {\\n    return this.set[target];\\n}\\n\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * obj := Constructor(root);\\n * param_1 := obj.Find(target);\\n */\\n```",
                "solutionTags": [
                    "Go",
                    "Design",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\ntype FindElements struct {\\n    set map[int]bool\\n}\\n\\nfunc (this *FindElements)constructTree(root *TreeNode, x int) {\\n    if root==nil {\\n        return\\n    }\\n    root.Val=x\\n    this.set[x]=true \\n    this.constructTree(root.Left, (2*x)+1)\\n    this.constructTree(root.Right, (2*x)+2)\\n}\\nfunc Constructor(root *TreeNode) FindElements {\\n    m:=map[int]bool{}\\n    \\n    this:=FindElements{}\\n    this.set=m\\n    this.constructTree(root, 0)\\n    return this\\n}\\n\\n\\nfunc (this *FindElements) Find(target int) bool {\\n    return this.set[target];\\n}\\n\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * obj := Constructor(root);\\n * param_1 := obj.Find(target);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2060336,
                "title": "c-solution-bfs",
                "content": "```\\n map<int,int>mp;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n           int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                mp[temp->val]++;\\n                if(temp->left)\\n                {\\n                    temp->left->val=(temp->val*2+1);\\n                    q.push(temp->left);\\n                }\\n                if(temp->right)\\n                {\\n                    temp->right->val=(temp->val*2+2);\\n                    q.push(temp->right);\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target)!=mp.end())\\n            return true;\\n        return false;\\n    }",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n map<int,int>mp;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*>q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n           int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* temp=q.front();\\n                q.pop();\\n                mp[temp->val]++;\\n                if(temp->left)\\n                {\\n                    temp->left->val=(temp->val*2+1);\\n                    q.push(temp->left);\\n                }\\n                if(temp->right)\\n                {\\n                    temp->right->val=(temp->val*2+2);\\n                    q.push(temp->right);\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target)!=mp.end())\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2038820,
                "title": "java-dfs-binartysearch-log-n-space-time-easy-to-understand-with-comments",
                "content": "The key idea in search for any value X if (X-1)%2==0 it would be on left branch of a node else it would be on a right branch of a node. Now we are storing directions in a stack to find if node value exists or not in the tree. \\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    \\n    TreeNode rootref;\\n    public FindElements(TreeNode root) {\\n        rootref=root; // Assigining root to reference node which can be used later on\\n        root.val=0;\\n        recover(root.left,root.val,0);\\n        recover(root.right,root.val,1);\\n        //0 indicates left child,1 indicates right child\\n    }\\n    public void recover(TreeNode node,int parent,int dir)\\n    {\\n        if(node==null)\\n            return;\\n        if(dir==1)\\n        {\\n            node.val=parent*2+2; //Assigning value for right child\\n        }\\n        else\\n        {\\n            node.val=parent*2+1; //Assigning value for left child\\n        }\\n        recover(node.left,node.val,0);\\n        recover(node.right,node.val,1);\\n        \\n    }\\n    \\n    public boolean find(int target) {\\n        Stack<Integer> direction=new Stack<Integer>();\\n        //Stack to store direction in which we need to traverse to find the element (0 left,1 right)\\n        while(target!=0)\\n        {\\n            if((target-1)%2==0)\\n            {\\n                target=(target-1)/2;\\n                direction.add(0);\\n            }\\n            else\\n            {\\n                target=(target-2)/2;\\n                direction.add(1);\\n            }\\n            \\n            //If number-1 is divisible by 2 it would be on left side else it would be on right side\\n        }\\n        TreeNode node=rootref;\\n        //Maximum size of stack is height of binary tree\\n        while(!direction.isEmpty())\\n        {\\n            int dir=direction.pop(); //Popping entries from stack\\n            if(dir==1)\\n            {\\n                //Checking if there are nodes in right subtree.\\n                if(node.right!=null)\\n                {\\n                    node=node.right;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                //Checking if there are nodes in left subtree.\\n                if(node.left!=null)\\n                {\\n                    node=node.left;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n ```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    \\n    TreeNode rootref;\\n    public FindElements(TreeNode root) {\\n        rootref=root; // Assigining root to reference node which can be used later on\\n        root.val=0;\\n        recover(root.left,root.val,0);\\n        recover(root.right,root.val,1);\\n        //0 indicates left child,1 indicates right child\\n    }\\n    public void recover(TreeNode node,int parent,int dir)\\n    {\\n        if(node==null)\\n            return;\\n        if(dir==1)\\n        {\\n            node.val=parent*2+2; //Assigning value for right child\\n        }\\n        else\\n        {\\n            node.val=parent*2+1; //Assigning value for left child\\n        }\\n        recover(node.left,node.val,0);\\n        recover(node.right,node.val,1);\\n        \\n    }\\n    \\n    public boolean find(int target) {\\n        Stack<Integer> direction=new Stack<Integer>();\\n        //Stack to store direction in which we need to traverse to find the element (0 left,1 right)\\n        while(target!=0)\\n        {\\n            if((target-1)%2==0)\\n            {\\n                target=(target-1)/2;\\n                direction.add(0);\\n            }\\n            else\\n            {\\n                target=(target-2)/2;\\n                direction.add(1);\\n            }\\n            \\n            //If number-1 is divisible by 2 it would be on left side else it would be on right side\\n        }\\n        TreeNode node=rootref;\\n        //Maximum size of stack is height of binary tree\\n        while(!direction.isEmpty())\\n        {\\n            int dir=direction.pop(); //Popping entries from stack\\n            if(dir==1)\\n            {\\n                //Checking if there are nodes in right subtree.\\n                if(node.right!=null)\\n                {\\n                    node=node.right;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                //Checking if there are nodes in left subtree.\\n                if(node.left!=null)\\n                {\\n                    node=node.left;\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1872558,
                "title": "c-short-and-simple-hashtable",
                "content": "\\nfirst try to recover the tree using preorder traversal \\nduring the traversal, store the values in hash table for fast searching\\n\\n```\\nclass FindElements \\n{\\n    TreeNode *root;\\n    unordered_set<int> set;\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        \\n        this -> root = root;\\n        \\n        recoverTree(this -> root, 0);\\n    }\\n    \\n    void recoverTree(TreeNode *itr, int val){\\n        \\n        if(!itr)\\n            return ;\\n        \\n        itr -> val = val;\\n        set.insert(val);\\n        \\n        recoverTree(itr -> left, val*2 + 1);\\n        recoverTree(itr -> right, val*2 + 2);\\n    }\\n    \\n    bool find(int target) {\\n        \\n        return set.count(target);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass FindElements \\n{\\n    TreeNode *root;\\n    unordered_set<int> set;\\n    \\npublic:\\n    FindElements(TreeNode* root) {\\n        \\n        this -> root = root;\\n        \\n        recoverTree(this -> root, 0);\\n    }\\n    \\n    void recoverTree(TreeNode *itr, int val){\\n        \\n        if(!itr)\\n            return ;\\n        \\n        itr -> val = val;\\n        set.insert(val);\\n        \\n        recoverTree(itr -> left, val*2 + 1);\\n        recoverTree(itr -> right, val*2 + 2);\\n    }\\n    \\n    bool find(int target) {\\n        \\n        return set.count(target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846192,
                "title": "java-code-2-ways-to-solve",
                "content": "```\\n\\npublic class FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        Queue<TreeNode> q = new LinkedList<>();\\n\\n        q.offer(root);\\n        root.val = 0;\\n\\n        while (!q.isEmpty()){\\n\\n            int queueSize = q.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                TreeNode temp = q.peek();\\n\\n                if (temp.left != null){\\n                    q.offer(temp.left);\\n                    temp.left.val = 2* temp.val +1;\\n                }\\n\\n                if (temp.right!= null) {\\n                    q.offer(temp.right);\\n                    temp.right.val = 2* temp.val +2;\\n                }\\n                q.poll();\\n            }\\n\\n        }\\n    }\\n\\n    public boolean find(int target) {\\n\\n        return helper(root, target);\\n       \\n    }\\n    public boolean helper(TreeNode rootRec, int target){\\n        if (rootRec == null) return false;\\n        \\n        if (rootRec.val == target) return true;\\n        \\n        boolean bool1 =helper(rootRec.left, target);\\n        if (bool1) return true;\\n        boolean bool2 = helper(rootRec.right, target);\\n        if (bool2) return true;\\n        \\n        return false;\\n    }\\n}\\n\\n\\n\\n\\n```\\n\\n\\n```\\nclass FindElements {\\n    TreeNode root;\\n    HashSet<Integer> set = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        root.val = 0;\\n        set.add(0);\\n        while (!q.isEmpty()){\\n            int queueSize = q.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                TreeNode temp = q.peek();\\n                if (temp.left != null){\\n                    q.offer(temp.left);\\n                    temp.left.val = 2* temp.val +1;\\n                    set.add(temp.left.val);\\n                }\\n                if (temp.right!= null) {\\n                    q.offer(temp.right);\\n                    temp.right.val = 2* temp.val +2;\\n                    set.add(temp.right.val);\\n                }\\n                q.poll();\\n            }\\n        }\\n    }\\n\\n    public boolean find(int target) {\\n\\n        return set.contains(target);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\npublic class FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        Queue<TreeNode> q = new LinkedList<>();\\n\\n        q.offer(root);\\n        root.val = 0;\\n\\n        while (!q.isEmpty()){\\n\\n            int queueSize = q.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                TreeNode temp = q.peek();\\n\\n                if (temp.left != null){\\n                    q.offer(temp.left);\\n                    temp.left.val = 2* temp.val +1;\\n                }\\n\\n                if (temp.right!= null) {\\n                    q.offer(temp.right);\\n                    temp.right.val = 2* temp.val +2;\\n                }\\n                q.poll();\\n            }\\n\\n        }\\n    }\\n\\n    public boolean find(int target) {\\n\\n        return helper(root, target);\\n       \\n    }\\n    public boolean helper(TreeNode rootRec, int target){\\n        if (rootRec == null) return false;\\n        \\n        if (rootRec.val == target) return true;\\n        \\n        boolean bool1 =helper(rootRec.left, target);\\n        if (bool1) return true;\\n        boolean bool2 = helper(rootRec.right, target);\\n        if (bool2) return true;\\n        \\n        return false;\\n    }\\n}\\n\\n\\n\\n\\n```\n```\\nclass FindElements {\\n    TreeNode root;\\n    HashSet<Integer> set = new HashSet<>();\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        root.val = 0;\\n        set.add(0);\\n        while (!q.isEmpty()){\\n            int queueSize = q.size();\\n            for (int i = 0; i < queueSize; i++) {\\n                TreeNode temp = q.peek();\\n                if (temp.left != null){\\n                    q.offer(temp.left);\\n                    temp.left.val = 2* temp.val +1;\\n                    set.add(temp.left.val);\\n                }\\n                if (temp.right!= null) {\\n                    q.offer(temp.right);\\n                    temp.right.val = 2* temp.val +2;\\n                    set.add(temp.right.val);\\n                }\\n                q.poll();\\n            }\\n        }\\n    }\\n\\n    public boolean find(int target) {\\n\\n        return set.contains(target);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780860,
                "title": "bfs-based-solution-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    TreeNode* treeNode;\\n    unordered_map<int,bool> valueMap;\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> bfsQ;\\n        TreeNode *temp;\\n        bfsQ.push(root);\\n        root->val = 0;\\n        valueMap[root->val] = true;\\n        \\n        do {\\n            \\n            temp = bfsQ.front();\\n            if(temp->left != NULL) {\\n                \\n                bfsQ.push(temp->left);\\n                temp->left->val = bfsQ.front()->val * 2 + 1;\\n                valueMap[temp->left->val] = true;\\n                \\n            }\\n            \\n            if(temp->right != NULL) {\\n                \\n                bfsQ.push(temp->right);\\n                temp->right->val = bfsQ.front()->val * 2 + 2;\\n                valueMap[temp->right->val] = true;\\n            }\\n            \\n            bfsQ.pop();\\n            \\n        }while(!bfsQ.empty());\\n        \\n        \\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n        treeNode = root;\\n        recoverTree(treeNode);\\n    }\\n    \\n    bool find(int target) {\\n        \\n        if(valueMap.find(target) != valueMap.end())\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    TreeNode* treeNode;\\n    unordered_map<int,bool> valueMap;\\n    \\n    void recoverTree(TreeNode* root) {\\n        \\n        queue<TreeNode*> bfsQ;\\n        TreeNode *temp;\\n        bfsQ.push(root);\\n        root->val = 0;\\n        valueMap[root->val] = true;\\n        \\n        do {\\n            \\n            temp = bfsQ.front();\\n            if(temp->left != NULL) {\\n                \\n                bfsQ.push(temp->left);\\n                temp->left->val = bfsQ.front()->val * 2 + 1;\\n                valueMap[temp->left->val] = true;\\n                \\n            }\\n            \\n            if(temp->right != NULL) {\\n                \\n                bfsQ.push(temp->right);\\n                temp->right->val = bfsQ.front()->val * 2 + 2;\\n                valueMap[temp->right->val] = true;\\n            }\\n            \\n            bfsQ.pop();\\n            \\n        }while(!bfsQ.empty());\\n        \\n        \\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n        treeNode = root;\\n        recoverTree(treeNode);\\n    }\\n    \\n    bool find(int target) {\\n        \\n        if(valueMap.find(target) != valueMap.end())\\n            return true;\\n        else\\n            return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777486,
                "title": "c-dfs-clean-and-concise",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    TreeNode *troot;\\n    map<int,bool>ma;\\n    void dfs(TreeNode *root,int val)\\n    {\\n        if(!root)\\n            return;\\n        root->val=val;\\n        ma[val]=1;\\n        dfs(root->left,val*2+1);\\n        dfs(root->right,val*2+2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n        dfs(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        \\n       return ma[target];\\n        \\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n ```\\n \\n**Pls upvote if you found helpful.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    \\n    TreeNode *troot;\\n    map<int,bool>ma;\\n    void dfs(TreeNode *root,int val)\\n    {\\n        if(!root)\\n            return;\\n        root->val=val;\\n        ma[val]=1;\\n        dfs(root->left,val*2+1);\\n        dfs(root->right,val*2+2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        \\n        dfs(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        \\n       return ma[target];\\n        \\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1736298,
                "title": "c-easy-recursive-solution",
                "content": "Solution is straight forword we only recursively check current node value greater than target value if we find target value we will return true otherwise false.\\n```\\n\\nTreeNode * head;\\n    FindElements(TreeNode* root) {\\n        head = new TreeNode();\\n        head = root;\\n    }\\n    bool help(TreeNode * root, int val, int target)\\n    {\\n        if(root == NULL)\\n            return false;\\n        if(val == target )\\n            return true;\\n        return help(root->left , 2*val+1 , target) || help(root->right , 2*val+2 , target);\\n    }\\n\\tbool find(int target) {\\n        return help(head, 0,target);\\n    }\\n```\\n\\t\\nIf you have any suggestion comment.Thank you for your suggestion.",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n\\nTreeNode * head;\\n    FindElements(TreeNode* root) {\\n        head = new TreeNode();\\n        head = root;\\n    }\\n    bool help(TreeNode * root, int val, int target)\\n    {\\n        if(root == NULL)\\n            return false;\\n        if(val == target )\\n            return true;\\n        return help(root->left , 2*val+1 , target) || help(root->right , 2*val+2 , target);\\n    }\\n\\tbool find(int target) {\\n        return help(head, 0,target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1690280,
                "title": "c-easy-to-understand-simple-implementation",
                "content": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int> st;\\npublic:\\n    void recover(TreeNode* root,int x)\\n    {\\n        if(!root)\\n        return;\\n        root->val=x;\\n        st.insert(x);\\n        recover(root->left,2*x+1);\\n        recover(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        recover(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return (st.find(target)!=st.end());\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\nprivate:\\n    unordered_set<int> st;\\npublic:\\n    void recover(TreeNode* root,int x)\\n    {\\n        if(!root)\\n        return;\\n        root->val=x;\\n        st.insert(x);\\n        recover(root->left,2*x+1);\\n        recover(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        recover(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return (st.find(target)!=st.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660470,
                "title": "c-solution-using-set-to-find-element-in-o-1",
                "content": "```\\nclass FindElements {\\npublic:\\n    set<int> s;\\n    void store(TreeNode *root)\\n    {\\n        if(root!=NULL)\\n        {\\n            s.insert(root->val);\\n            store(root->left);\\n            store(root->right);\\n        }\\n    }\\n    void solve(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            int x=root->val;\\n            int k=2*x+1;\\n            root->left->val=k;\\n        }\\n        if(root->right!=NULL)\\n        {\\n            int x=root->val;\\n            int k=2*x+2;\\n            root->right->val=k;\\n        }\\n        solve(root->left);\\n        solve(root->right);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n        store(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    set<int> s;\\n    void store(TreeNode *root)\\n    {\\n        if(root!=NULL)\\n        {\\n            s.insert(root->val);\\n            store(root->left);\\n            store(root->right);\\n        }\\n    }\\n    void solve(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            int x=root->val;\\n            int k=2*x+1;\\n            root->left->val=k;\\n        }\\n        if(root->right!=NULL)\\n        {\\n            int x=root->val;\\n            int k=2*x+2;\\n            root->right->val=k;\\n        }\\n        solve(root->left);\\n        solve(root->right);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n        store(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)!=s.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1628305,
                "title": "c-easy-logical-solution-o-log-n-space-pruning-no-hashmap-or-set",
                "content": "```\\nclass FindElements {\\npublic:\\n    \\n    /*\\n        INTUITION\\n        No need to create / restore the tree (although it can be easily done, it is just in the form of a heap (left is 2i + 1, right is 2i + 2)).\\n        For the find operation, we can trace back the path to the root node from the target node.\\n        1. We know for sure that an odd node value will be in the left subtree of its parent, and an even node value will be in the right subtree of its parent.\\n        2. So we push \\'l\\' or \\'r\\' (left, or right) on the stack, based on if it is odd or even.\\n        3. Now we need to move to the nodes\\'s parent and see which side it lies on its own parent. To move to the parent node, we can deconstruct the value based on the formula\\n        If parent is i, then left child is 2i + 1, and right child is 2i + 2, so to get the parent of a node, we can use:\\n            parent = (target - 1)/2 for odd nodes\\n            parent = (target - 2)/2 for even nodes,\\n            and repeat steps 1 to 3 till we reach the root (i.e target is 0)\\n        Then we can start from the root and follow the steps from the stack. If we successfully reach the end of the stack without encountering a nullptr, then it means the target exists, but if we encounter a nullptr before executing all the steps from the stack, the target node does not exist.\\n        \\n        \\n        Optimisation: Maybe by a recursive approach, we can also cache which nodes exist to improve runtime for a large number of queries\\n    */\\n    \\n    TreeNode* tree;\\n    FindElements(TreeNode* root) {\\n        tree = root;\\n    }\\n    \\n    bool find(int target) {\\n        if(target == 0) return true;\\n        stack<char> steps;\\n        while(target > 0) {\\n            if(target % 2 == 1) {\\n                steps.push(\\'l\\');\\n                target = (target - 1)/2;\\n            } else {\\n                steps.push(\\'r\\');\\n                target = (target - 2)/2;\\n            }\\n        }\\n        TreeNode* curr = tree;\\n        while(curr != nullptr) {\\n            char step = steps.top();\\n            steps.pop();\\n            if(step == \\'l\\') {\\n                curr = curr->left;\\n            } else {\\n                curr = curr->right;\\n            }\\n            if(steps.empty() && curr != nullptr) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nPlease upvote if it helped. Happy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    \\n    /*\\n        INTUITION\\n        No need to create / restore the tree (although it can be easily done, it is just in the form of a heap (left is 2i + 1, right is 2i + 2)).\\n        For the find operation, we can trace back the path to the root node from the target node.\\n        1. We know for sure that an odd node value will be in the left subtree of its parent, and an even node value will be in the right subtree of its parent.\\n        2. So we push \\'l\\' or \\'r\\' (left, or right) on the stack, based on if it is odd or even.\\n        3. Now we need to move to the nodes\\'s parent and see which side it lies on its own parent. To move to the parent node, we can deconstruct the value based on the formula\\n        If parent is i, then left child is 2i + 1, and right child is 2i + 2, so to get the parent of a node, we can use:\\n            parent = (target - 1)/2 for odd nodes\\n            parent = (target - 2)/2 for even nodes,\\n            and repeat steps 1 to 3 till we reach the root (i.e target is 0)\\n        Then we can start from the root and follow the steps from the stack. If we successfully reach the end of the stack without encountering a nullptr, then it means the target exists, but if we encounter a nullptr before executing all the steps from the stack, the target node does not exist.\\n        \\n        \\n        Optimisation: Maybe by a recursive approach, we can also cache which nodes exist to improve runtime for a large number of queries\\n    */\\n    \\n    TreeNode* tree;\\n    FindElements(TreeNode* root) {\\n        tree = root;\\n    }\\n    \\n    bool find(int target) {\\n        if(target == 0) return true;\\n        stack<char> steps;\\n        while(target > 0) {\\n            if(target % 2 == 1) {\\n                steps.push(\\'l\\');\\n                target = (target - 1)/2;\\n            } else {\\n                steps.push(\\'r\\');\\n                target = (target - 2)/2;\\n            }\\n        }\\n        TreeNode* curr = tree;\\n        while(curr != nullptr) {\\n            char step = steps.top();\\n            steps.pop();\\n            if(step == \\'l\\') {\\n                curr = curr->left;\\n            } else {\\n                curr = curr->right;\\n            }\\n            if(steps.empty() && curr != nullptr) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482832,
                "title": "c-dfs-using-hash-inorder",
                "content": "**\\nunordered_map<int,int>mpp;\\n    void solve(TreeNode* root,int i)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        else{\\n            root->val=i;\\n        }\\n        solve(root->left,2*i+1);\\n        mpp[root->val]=1;\\n        solve(root->right,2*i+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        solve(root,0);\\n    }\\n    bool find(int target) {\\n        \\n        if(mpp.find(target)!=mpp.end())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n**",
                "solutionTags": [],
                "code": "**\\nunordered_map<int,int>mpp;\\n    void solve(TreeNode* root,int i)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        else{\\n            root->val=i;\\n        }\\n        solve(root->left,2*i+1);\\n        mpp[root->val]=1;\\n        solve(root->right,2*i+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        solve(root,0);\\n    }\\n    bool find(int target) {\\n        \\n        if(mpp.find(target)!=mpp.end())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n**",
                "codeTag": "Unknown"
            },
            {
                "id": 1424594,
                "title": "ac-java-solution-find-elements-in-a-contaminated-binary-tree-beats-84",
                "content": "Strictly by the definition, I contaminate and reconstruct the tree, all the while adding the keys to a set. \\n\\nThe latter makes the initial tree building O(n), but the find operation O(1), since we can look the keys up directly from the set.\\n\\nI\\'m sure I can make this faster by combining \\'contaminate\\' and \\'reconstruct\\', but It\\'s late now and I\\'m tired :)\\n\\n```\\nclass FindElements {\\n\\n    HashSet<Integer> keys;\\n    \\n    public FindElements(TreeNode root) {\\n        keys = new HashSet<Integer>();\\n        contaminate(root);\\n        root.val = 0;\\n        reconstruct(root);\\n    }\\n    \\n    public boolean find(int target) {\\n       return keys.contains(target);\\n    }\\n    \\n    private void contaminate(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        \\n        root.val = -1;\\n        contaminate(root.left);\\n        contaminate(root.right);\\n    }\\n    \\n    public void reconstruct(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        \\n        keys.add(root.val);\\n        \\n        if(root.left != null) {\\n            root.left.val = 2*root.val + 1;\\n            \\n        }\\n        \\n        if(root.right != null) {\\n            root.right.val = 2*root.val + 2;\\n        }\\n        \\n        reconstruct(root.left);\\n        reconstruct(root.right);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass FindElements {\\n\\n    HashSet<Integer> keys;\\n    \\n    public FindElements(TreeNode root) {\\n        keys = new HashSet<Integer>();\\n        contaminate(root);\\n        root.val = 0;\\n        reconstruct(root);\\n    }\\n    \\n    public boolean find(int target) {\\n       return keys.contains(target);\\n    }\\n    \\n    private void contaminate(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        \\n        root.val = -1;\\n        contaminate(root.left);\\n        contaminate(root.right);\\n    }\\n    \\n    public void reconstruct(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        \\n        keys.add(root.val);\\n        \\n        if(root.left != null) {\\n            root.left.val = 2*root.val + 1;\\n            \\n        }\\n        \\n        if(root.right != null) {\\n            root.right.val = 2*root.val + 2;\\n        }\\n        \\n        reconstruct(root.left);\\n        reconstruct(root.right);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1338182,
                "title": "java-dfs-hashset-beats-98",
                "content": "class FindElements {\\n    Set<Integer> elements = new HashSet<>();\\n    \\n    private void dfs(TreeNode root){\\n        if(root == null){return;}\\n        elements.add(root.val);\\n        if(root.left != null){\\n            root.left.val = root.val * 2 + 1;    \\n        }\\n        if(root.right != null){\\n            root.right.val = root.val * 2 + 2;\\n        }\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n\\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n        dfs(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return elements.contains(target);\\n    }\\n}\\n\\nPlease upvote if you find it useful!!!",
                "solutionTags": [],
                "code": "class FindElements {\\n    Set<Integer> elements = new HashSet<>();\\n    \\n    private void dfs(TreeNode root){\\n        if(root == null){return;}\\n        elements.add(root.val);\\n        if(root.left != null){\\n            root.left.val = root.val * 2 + 1;    \\n        }\\n        if(root.right != null){\\n            root.right.val = root.val * 2 + 2;\\n        }\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n\\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n        dfs(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return elements.contains(target);\\n    }\\n}\\n\\nPlease upvote if you find it useful!!!",
                "codeTag": "Java"
            },
            {
                "id": 1272382,
                "title": "c-simple-easy-to-understand-solution",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> ust;\\n    void recoverIt(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return;\\n        ust.insert(root->val);\\n        if(root->left!=NULL)\\n            root->left->val=2*(root->val)+1;\\n        if(root->right!=NULL)\\n            root->right->val=2*(root->val)+2;\\n        recoverIt(root->left);\\n        recoverIt(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        recoverIt(root);\\n    }\\n    bool find(int target) {\\n        return(ust.find(target)!=ust.end());\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> ust;\\n    void recoverIt(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return;\\n        ust.insert(root->val);\\n        if(root->left!=NULL)\\n            root->left->val=2*(root->val)+1;\\n        if(root->right!=NULL)\\n            root->right->val=2*(root->val)+2;\\n        recoverIt(root->left);\\n        recoverIt(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        recoverIt(root);\\n    }\\n    bool find(int target) {\\n        return(ust.find(target)!=ust.end());\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244162,
                "title": "c-hashmap",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_map<int, int> mp;\\n    FindElements(TreeNode* root) \\n    {\\n        if(root)\\n        {\\n            root->val = 0;\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            while(!q.empty())\\n            {\\n                int size = q.size();\\n                for(int i=0; i<size; i++)\\n                {\\n                    TreeNode* temp = q.front(); q.pop();\\n                    int x = temp->val;\\n                    mp[x]++;\\n                    if(temp->left)\\n                    {\\n                        temp->left->val = 2 * x + 1;\\n                        q.push(temp->left);\\n                    }\\n                    if(temp->right)\\n                    {\\n                        temp->right->val = 2 * x + 2;\\n                        q.push(temp->right);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) \\n    {\\n        return (mp.find(target) != mp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_map<int, int> mp;\\n    FindElements(TreeNode* root) \\n    {\\n        if(root)\\n        {\\n            root->val = 0;\\n            queue<TreeNode*> q;\\n            q.push(root);\\n            while(!q.empty())\\n            {\\n                int size = q.size();\\n                for(int i=0; i<size; i++)\\n                {\\n                    TreeNode* temp = q.front(); q.pop();\\n                    int x = temp->val;\\n                    mp[x]++;\\n                    if(temp->left)\\n                    {\\n                        temp->left->val = 2 * x + 1;\\n                        q.push(temp->left);\\n                    }\\n                    if(temp->right)\\n                    {\\n                        temp->right->val = 2 * x + 2;\\n                        q.push(temp->right);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) \\n    {\\n        return (mp.find(target) != mp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233405,
                "title": "c-98-8-faster-very-simple-and-easy-to-understand-using-dfs",
                "content": "```\\n unordered_map<int,bool>m;\\n    void helper(TreeNode* root, int v){\\n        if(!root)return;\\n        helper(root->left, 2*v+1);\\n        m[v]=true;\\n        helper(root->right, 2*v+2);\\n    }\\n    FindElements(TreeNode* root, int v=0) {\\n        helper(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return m[target];\\n    }\\n```\\n**if you find it helpful plz upvote**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n unordered_map<int,bool>m;\\n    void helper(TreeNode* root, int v){\\n        if(!root)return;\\n        helper(root->left, 2*v+1);\\n        m[v]=true;\\n        helper(root->right, 2*v+2);\\n    }\\n    FindElements(TreeNode* root, int v=0) {\\n        helper(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return m[target];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1229967,
                "title": "simple-recursive-approach",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    void helper(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return;\\n        if(root->left != NULL)\\n            root->left->val = 2*root->val + 1;\\n        if(root->right != NULL)\\n            root->right->val = 2*root->val + 2;\\n        helper(root->left);\\n        helper(root->right);\\n        \\n    }\\n    TreeNode* start;\\n    FindElements(TreeNode* root) {\\n         root->val = 0;\\n        start = root;\\n        helper(start);\\n    }\\n       bool helper1(TreeNode* root,int target)\\n       {\\n           if(root == NULL)\\n               return false;\\n           if(root->val == target)\\n               return true;\\n           return helper1(root->left,target) or helper1(root->right,target);\\n               \\n               \\n       }\\n    bool find(int target) {\\n        return helper1(start,target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    void helper(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return;\\n        if(root->left != NULL)\\n            root->left->val = 2*root->val + 1;\\n        if(root->right != NULL)\\n            root->right->val = 2*root->val + 2;\\n        helper(root->left);\\n        helper(root->right);\\n        \\n    }\\n    TreeNode* start;\\n    FindElements(TreeNode* root) {\\n         root->val = 0;\\n        start = root;\\n        helper(start);\\n    }\\n       bool helper1(TreeNode* root,int target)\\n       {\\n           if(root == NULL)\\n               return false;\\n           if(root->val == target)\\n               return true;\\n           return helper1(root->left,target) or helper1(root->right,target);\\n               \\n               \\n       }\\n    bool find(int target) {\\n        return helper1(start,target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228884,
                "title": "c-simple-solution-using-bfs-and-unordered-set",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int>S;\\n    void bfs(TreeNode* root)\\n    {\\n        queue<TreeNode*>Q;\\n        root->val = 0;\\n        S.insert(0);\\n        Q.push(root);\\n        while(Q.size())\\n        {\\n            auto curr = Q.front();\\n            Q.pop();\\n            \\n            if(curr->left)\\n            {\\n                curr->left->val = 2*curr->val + 1;\\n                S.insert(curr->left->val);\\n                Q.push(curr->left);\\n            }\\n            \\n            if(curr->right)\\n            {\\n                curr->right->val = 2*curr->val + 2;\\n                S.insert(curr->right->val);\\n                Q.push(curr->right);\\n            }\\n        }\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        bfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        return S.count(target) > 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int>S;\\n    void bfs(TreeNode* root)\\n    {\\n        queue<TreeNode*>Q;\\n        root->val = 0;\\n        S.insert(0);\\n        Q.push(root);\\n        while(Q.size())\\n        {\\n            auto curr = Q.front();\\n            Q.pop();\\n            \\n            if(curr->left)\\n            {\\n                curr->left->val = 2*curr->val + 1;\\n                S.insert(curr->left->val);\\n                Q.push(curr->left);\\n            }\\n            \\n            if(curr->right)\\n            {\\n                curr->right->val = 2*curr->val + 2;\\n                S.insert(curr->right->val);\\n                Q.push(curr->right);\\n            }\\n        }\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        bfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        return S.count(target) > 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174605,
                "title": "python3-simple-solution",
                "content": "```\\nclass FindElements:\\n    def __init__(self, root: TreeNode):\\n        self.res = set()\\n        x = [(root,0)]\\n        while x:\\n            node, value = x.pop(0)\\n            node.val = value\\n            self.res.add(value)\\n            if node.left:\\n                x.append((node.left,(2*value+1)))\\n            if node.right:\\n                x.append((node.right,(2*value+2)))\\n    def find(self, target: int) -> bool:\\n        return target in self.res\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FindElements:\\n    def __init__(self, root: TreeNode):\\n        self.res = set()\\n        x = [(root,0)]\\n        while x:\\n            node, value = x.pop(0)\\n            node.val = value\\n            self.res.add(value)\\n            if node.left:\\n                x.append((node.left,(2*value+1)))\\n            if node.right:\\n                x.append((node.right,(2*value+2)))\\n    def find(self, target: int) -> bool:\\n        return target in self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1137333,
                "title": "java-clean-and-easy-solution",
                "content": "**If you want to do this in O(1) space than you have to write the O(n) code for searching the target in Binary tree which is pretty slow**\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n   TreeNode nroot;\\n    public FindElements(TreeNode root) {\\n        root.val=0;\\n        helper(root);\\n        nroot=root;\\n    }\\n    public void helper(TreeNode node){\\n      if(node!=null){\\n        \\n        if(node.left!=null){\\n          node.left.val=2*node.val+1;\\n        }\\n        \\n         if(node.right!=null){\\n          node.right.val=2*node.val+2;\\n        }\\n        \\n        helper(node.left);\\n        helper(node.right);\\n        \\n      }\\n    }\\n    \\n public boolean find(int target) {\\n       return  find(nroot,target); \\n    }\\n    public boolean find(TreeNode node,int key){\\n      if(node==null) return false;\\n      \\n      if(node.val==key) return true;\\n      boolean l=find(node.left,key);\\n      boolean r=find(node.right,key);\\n      \\n      return l || r;\\n      \\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```\\n**But if you use Map to store the values as key in map you will be doing the search operation in O(1) which will be fast**\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    Map<Integer,Boolean> mp=new HashMap<>();\\n    public FindElements(TreeNode root) {\\n        root.val=0;\\n        helper(root);\\n    }\\n    public void helper(TreeNode node){\\n      if(node!=null){\\n        mp.put(node.val,true);\\n        if(node.left!=null){\\n          node.left.val=2*node.val+1;\\n        }\\n        \\n         if(node.right!=null){\\n          node.right.val=2*node.val+2;\\n        }\\n        \\n        helper(node.left);\\n        helper(node.right);\\n        \\n      }\\n    }\\n    \\n public boolean find(int target) {\\n       return  mp.get(target)==null ? false : true; \\n    }\\n    \\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n   TreeNode nroot;\\n    public FindElements(TreeNode root) {\\n        root.val=0;\\n        helper(root);\\n        nroot=root;\\n    }\\n    public void helper(TreeNode node){\\n      if(node!=null){\\n        \\n        if(node.left!=null){\\n          node.left.val=2*node.val+1;\\n        }\\n        \\n         if(node.right!=null){\\n          node.right.val=2*node.val+2;\\n        }\\n        \\n        helper(node.left);\\n        helper(node.right);\\n        \\n      }\\n    }\\n    \\n public boolean find(int target) {\\n       return  find(nroot,target); \\n    }\\n    public boolean find(TreeNode node,int key){\\n      if(node==null) return false;\\n      \\n      if(node.val==key) return true;\\n      boolean l=find(node.left,key);\\n      boolean r=find(node.right,key);\\n      \\n      return l || r;\\n      \\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    Map<Integer,Boolean> mp=new HashMap<>();\\n    public FindElements(TreeNode root) {\\n        root.val=0;\\n        helper(root);\\n    }\\n    public void helper(TreeNode node){\\n      if(node!=null){\\n        mp.put(node.val,true);\\n        if(node.left!=null){\\n          node.left.val=2*node.val+1;\\n        }\\n        \\n         if(node.right!=null){\\n          node.right.val=2*node.val+2;\\n        }\\n        \\n        helper(node.left);\\n        helper(node.right);\\n        \\n      }\\n    }\\n    \\n public boolean find(int target) {\\n       return  mp.get(target)==null ? false : true; \\n    }\\n    \\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129234,
                "title": "java-solution-99-faster",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n   HashMap<Integer,Boolean> map = new HashMap<>();\\n    public FindElements(TreeNode root) {\\n       if(root.val!=0){\\n           root.val = 0;\\n          \\n       }\\n        \\n       preorder(root);\\n      \\n         \\n       \\n    }\\n    \\n    public boolean find(int target) {\\n        if(map.get(target)!=null)\\n            return true;\\n        return false;\\n    }\\n    public void preorder(TreeNode root){\\n         \\n        if(root!=null){\\n            map.put(root.val,true);\\n            if(root.left!=null){\\n                root.left.val = 2*root.val+1;\\n                \\n            }\\n            if(root.right!=null){\\n                root.right.val = 2*root.val+2;\\n                   \\n            }\\n            preorder(root.left);\\n            preorder(root.right);\\n        }\\n        \\n    }\\n   \\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n   HashMap<Integer,Boolean> map = new HashMap<>();\\n    public FindElements(TreeNode root) {\\n       if(root.val!=0){\\n           root.val = 0;\\n          \\n       }\\n        \\n       preorder(root);\\n      \\n         \\n       \\n    }\\n    \\n    public boolean find(int target) {\\n        if(map.get(target)!=null)\\n            return true;\\n        return false;\\n    }\\n    public void preorder(TreeNode root){\\n         \\n        if(root!=null){\\n            map.put(root.val,true);\\n            if(root.left!=null){\\n                root.left.val = 2*root.val+1;\\n                \\n            }\\n            if(root.right!=null){\\n                root.right.val = 2*root.val+2;\\n                   \\n            }\\n            preorder(root.left);\\n            preorder(root.right);\\n        }\\n        \\n    }\\n   \\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129172,
                "title": "java-solution-99-faster",
                "content": "```\\nclass FindElements {\\n    HashMap<Integer,Boolean> map = new HashMap<>();\\n    public FindElements(TreeNode root) {\\n        recoverTree(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        if(map.get(target)!=null)\\n            return true;\\n        else return false;\\n    }\\n    public void recoverTree(TreeNode p,int x){\\n        if(p!=null){\\n            p.val = x;\\n            map.put(x,true);\\n            recoverTree(p.left,(2*x)+1);\\n            recoverTree(p.right,(2*x)+2);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    HashMap<Integer,Boolean> map = new HashMap<>();\\n    public FindElements(TreeNode root) {\\n        recoverTree(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        if(map.get(target)!=null)\\n            return true;\\n        else return false;\\n    }\\n    public void recoverTree(TreeNode p,int x){\\n        if(p!=null){\\n            p.val = x;\\n            map.put(x,true);\\n            recoverTree(p.left,(2*x)+1);\\n            recoverTree(p.right,(2*x)+2);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085663,
                "title": "python-iterative-dfs",
                "content": "I think we can use any traversal order to update the node values?\\n```py\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        self.element = set()\\n        root.val = 0\\n        stack = []\\n        while stack or root:\\n            while root:\\n                self.element.add(root.val)\\n                if root.left:\\n                    root.left.val = root.val * 2 + 1\\n                stack.append(root)\\n                root = root.left\\n            \\n            root = stack.pop()\\n            if root.right:\\n                root.right.val = root.val * 2 + 2\\n            root = root.right\\n            \\n\\n    def find(self, target: int) -> bool:\\n        return target in self.element\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```py\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        self.element = set()\\n        root.val = 0\\n        stack = []\\n        while stack or root:\\n            while root:\\n                self.element.add(root.val)\\n                if root.left:\\n                    root.left.val = root.val * 2 + 1\\n                stack.append(root)\\n                root = root.left\\n            \\n            root = stack.pop()\\n            if root.right:\\n                root.right.val = root.val * 2 + 2\\n            root = root.right\\n            \\n\\n    def find(self, target: int) -> bool:\\n        return target in self.element\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046251,
                "title": "i-am-not-sure-if-it-s-allowed-to-use-static-but-that-s-how-i-implemented",
                "content": "\\tclass FindElements {\\n    public void findElements_(TreeNode root){\\n        if(root == null) return;\\n        \\n        if(root.val != -1 && root.left != null) root.left.val = 2 * root.val + 1;\\n        if(root.val != -1 && root.right != null) root.right.val = 2 * root.val + 2;\\n        \\n        set.add(root.val);\\n        \\n        findElements_(root.left);\\n        findElements_(root.right);\\n    }\\n    \\n    public HashSet<Integer> set = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        //here i am not worried about null point exception as because root can\\'t be null according to constraints.\\n        root.val = 0;\\n        findElements_(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n     }\\n\\t}\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "\\tclass FindElements {\\n    public void findElements_(TreeNode root){\\n        if(root == null) return;\\n        \\n        if(root.val != -1 && root.left != null) root.left.val = 2 * root.val + 1;\\n        if(root.val != -1 && root.right != null) root.right.val = 2 * root.val + 2;\\n        \\n        set.add(root.val);\\n        \\n        findElements_(root.left);\\n        findElements_(root.right);\\n    }\\n    \\n    public HashSet<Integer> set = new HashSet<>();\\n    \\n    public FindElements(TreeNode root) {\\n        //here i am not worried about null point exception as because root can\\'t be null according to constraints.\\n        root.val = 0;\\n        findElements_(root);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n     }\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1018682,
                "title": "java-better-than-98-of-runtime",
                "content": "```\\nclass FindElements {\\n    Set<Integer> set=new HashSet<>();   //set will store the values to search for later\\n    public FindElements(TreeNode root) {\\n        \\n        helper(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return (set.contains(target));  //if the set contains the target value then return true\\n    }\\n    \\n    private void helper(TreeNode root, int val){    //helper function will assign each node a value based on the                                                           condition given\\n        if(root==null)                              \\n            return;\\n        root.val=val;\\n        set.add(val);                               //adding each node\\'s val into the set\\n        if(root.left!=null)\\n           {\\n            helper(root.left,(2*val)+1); \\n        }\\n        if(root.right!=null)\\n            helper(root.right, (2*val)+2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n    Set<Integer> set=new HashSet<>();   //set will store the values to search for later\\n    public FindElements(TreeNode root) {\\n        \\n        helper(root,0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return (set.contains(target));  //if the set contains the target value then return true\\n    }\\n    \\n    private void helper(TreeNode root, int val){    //helper function will assign each node a value based on the                                                           condition given\\n        if(root==null)                              \\n            return;\\n        root.val=val;\\n        set.add(val);                               //adding each node\\'s val into the set\\n        if(root.left!=null)\\n           {\\n            helper(root.left,(2*val)+1); \\n        }\\n        if(root.right!=null)\\n            helper(root.right, (2*val)+2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012706,
                "title": "java-hashset",
                "content": "\\n\\tclass FindElements {\\n\\t\\tHashSet<Integer> set=new HashSet<>();\\n\\n\\t\\tpublic FindElements(TreeNode root) {\\n\\t\\t\\tif(root!=null)\\n\\t\\t\\t\\troot.val=0;\\n\\t\\t\\tcreate(root);\\n\\t\\t}\\n\\n\\t\\tpublic void create(TreeNode root){\\n\\n\\t\\t\\tif(root==null)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tset.add(root.val);\\n\\n\\t\\t\\tif(root.left!=null){\\n\\t\\t\\t\\troot.left.val=root.val*2+1;\\n\\t\\t\\t\\tcreate(root.left);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(root.right!=null){\\n\\t\\t\\t\\troot.right.val=root.val*2+2;\\n\\t\\t\\t\\tcreate(root.right);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean find(int target) {\\n\\t\\t\\tif(set.contains(target))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n\\tclass FindElements {\\n\\t\\tHashSet<Integer> set=new HashSet<>();\\n\\n\\t\\tpublic FindElements(TreeNode root) {\\n\\t\\t\\tif(root!=null)\\n\\t\\t\\t\\troot.val=0;\\n\\t\\t\\tcreate(root);\\n\\t\\t}\\n\\n\\t\\tpublic void create(TreeNode root){\\n\\n\\t\\t\\tif(root==null)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tset.add(root.val);\\n\\n\\t\\t\\tif(root.left!=null){\\n\\t\\t\\t\\troot.left.val=root.val*2+1;\\n\\t\\t\\t\\tcreate(root.left);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(root.right!=null){\\n\\t\\t\\t\\troot.right.val=root.val*2+2;\\n\\t\\t\\t\\tcreate(root.right);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean find(int target) {\\n\\t\\t\\tif(set.contains(target))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 984755,
                "title": "java-easty-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    HashSet<Integer> set;\\n    \\n    public FindElements(TreeNode root) {\\n        set = new HashSet<>();\\n        recoverTree(root, 0);\\n    }\\n    \\n    private void recoverTree(TreeNode root, int val){\\n        if(root == null){\\n            return;\\n        }\\n        \\n        set.add(val);\\n        root.val = val;\\n        recoverTree(root.left, 2*val+1);\\n        recoverTree(root.right, 2*val+2);\\n    }\\n    \\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    HashSet<Integer> set;\\n    \\n    public FindElements(TreeNode root) {\\n        set = new HashSet<>();\\n        recoverTree(root, 0);\\n    }\\n    \\n    private void recoverTree(TreeNode root, int val){\\n        if(root == null){\\n            return;\\n        }\\n        \\n        set.add(val);\\n        root.val = val;\\n        recoverTree(root.left, 2*val+1);\\n        recoverTree(root.right, 2*val+2);\\n    }\\n    \\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961877,
                "title": "python-simple-dfs-dict-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def __init__(self, root: TreeNode):\\n        self.d={}\\n        def helper(root):\\n            if root:\\n                self.d[root.val]=0\\n                if root.left:\\n                    root.left.val = root.val*2 +1 \\n                if root.right:\\n                    root.right.val = root.val*2 +2\\n                helper(root.left)\\n                helper(root.right)\\n        root.val = 0\\n        helper(root)\\n    def find(self, target: int) -> bool:\\n        return target in self.d\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def __init__(self, root: TreeNode):\\n        self.d={}\\n        def helper(root):\\n            if root:\\n                self.d[root.val]=0\\n                if root.left:\\n                    root.left.val = root.val*2 +1 \\n                if root.right:\\n                    root.right.val = root.val*2 +2\\n                helper(root.left)\\n                helper(root.right)\\n        root.val = 0\\n        helper(root)\\n    def find(self, target: int) -> bool:\\n        return target in self.d\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 887582,
                "title": "java-dfs-96-faster",
                "content": "kindly do Upvote if you like the solution.\\n\\nclass FindElements {\\n\\n    private Set<Integer> set;\\n    public FindElements(TreeNode root) {\\n        set=new HashSet<>();\\n        root.val=0;\\n        set.add(root.val);\\n        recoverTree(root);\\n    }\\n    \\n    void recoverTree(TreeNode root){\\n        if(root ==null)\\n            return;\\n       if(root.left !=null){\\n           int leftVal=root.val *2 +1;\\n           root.left.val=leftVal;\\n           set.add(leftVal);  \\n        }\\n        if(root.right !=null){\\n           int rightVal=root.val *2 +2;\\n           root.right.val=rightVal;\\n           set.add(rightVal);  \\n       }   \\n        recoverTree(root.left);\\n        recoverTree(root.right);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}",
                "solutionTags": [],
                "code": "kindly do Upvote if you like the solution.\\n\\nclass FindElements {\\n\\n    private Set<Integer> set;\\n    public FindElements(TreeNode root) {\\n        set=new HashSet<>();\\n        root.val=0;\\n        set.add(root.val);\\n        recoverTree(root);\\n    }\\n    \\n    void recoverTree(TreeNode root){\\n        if(root ==null)\\n            return;\\n       if(root.left !=null){\\n           int leftVal=root.val *2 +1;\\n           root.left.val=leftVal;\\n           set.add(leftVal);  \\n        }\\n        if(root.right !=null){\\n           int rightVal=root.val *2 +2;\\n           root.right.val=rightVal;\\n           set.add(rightVal);  \\n       }   \\n        recoverTree(root.left);\\n        recoverTree(root.right);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 884358,
                "title": "java-simple-one-pass-solution",
                "content": "We don\\'t need to technically recover the tree. Just collect all the values the tree is supposed to have and perform a O(1) lookup.\\n\\n```\\nclass FindElements {\\n\\n    Set<Integer> set;\\n    public FindElements(TreeNode root) {\\n        set = new HashSet<>();\\n        recover(root, 0, set);\\n    }\\n    \\n    private void recover(TreeNode root, int val, Set<Integer> set) {\\n        if (root==null)\\n            return;\\n        set.add(val);\\n        recover(root.left, 2 * val + 1, set);\\n        recover(root.right, 2 * val + 2, set);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n\\n    Set<Integer> set;\\n    public FindElements(TreeNode root) {\\n        set = new HashSet<>();\\n        recover(root, 0, set);\\n    }\\n    \\n    private void recover(TreeNode root, int val, Set<Integer> set) {\\n        if (root==null)\\n            return;\\n        set.add(val);\\n        recover(root.left, 2 * val + 1, set);\\n        recover(root.right, 2 * val + 2, set);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812443,
                "title": "c-easy-set-recursion",
                "content": "```\\nclass FindElements {\\npublic:\\n    set<int>st;\\n    void finding(TreeNode* root,int i)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        if(root->val!=i)\\n        {\\n            root->val=i;\\n            st.insert(i);\\n        }\\n        finding(root->left,2*i+1);\\n        finding(root->right,2*i+2);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n        int i=0;\\n         finding(root,i);\\n       }\\n    \\n    bool find(int target) {\\n        if(st.find(target)!=st.end())\\n            return true;\\n        else\\n            return false;\\n      }\\n};\\n",
                "solutionTags": [
                    "Recursion",
                    "Ordered Set"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    set<int>st;\\n    void finding(TreeNode* root,int i)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        if(root->val!=i)\\n        {\\n            root->val=i;\\n            st.insert(i);\\n        }\\n        finding(root->left,2*i+1);\\n        finding(root->right,2*i+2);\\n        \\n    }\\n    FindElements(TreeNode* root) {\\n        int i=0;\\n         finding(root,i);\\n       }\\n    \\n    bool find(int target) {\\n        if(st.find(target)!=st.end())\\n            return true;\\n        else\\n            return false;\\n      }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 750284,
                "title": "recursive-python-solution",
                "content": "```\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        def recoverBinary(node, value, array):\\n            if node is None:\\n                return\\n            array.append(value)\\n            node.val = value\\n            if node.left:\\n                recoverBinary(node.left, (2 * value) + 1, array)\\n            if node.right:\\n                recoverBinary(node.right, (2 * value) + 2, array)\\n                \\n        \\n        self.array = []\\n        recoverBinary(root, 0, self.array)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.array\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        def recoverBinary(node, value, array):\\n            if node is None:\\n                return\\n            array.append(value)\\n            node.val = value\\n            if node.left:\\n                recoverBinary(node.left, (2 * value) + 1, array)\\n            if node.right:\\n                recoverBinary(node.right, (2 * value) + 2, array)\\n                \\n        \\n        self.array = []\\n        recoverBinary(root, 0, self.array)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741098,
                "title": "easy-recursive-c-solution",
                "content": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> s;\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    void recover(TreeNode* root, int val) {\\n        if(root) {\\n            root -> val = val;\\n            s.insert(val);\\n            recover(root->left, 2*val+1);\\n            recover(root->right, 2*val+2);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target) != s.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_set<int> s;\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    void recover(TreeNode* root, int val) {\\n        if(root) {\\n            root -> val = val;\\n            s.insert(val);\\n            recover(root->left, 2*val+1);\\n            recover(root->right, 2*val+2);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target) != s.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 722900,
                "title": "java-recursion-and-set",
                "content": "```\\nclass FindElements {\\n    \\n    private Set<Integer> set;\\n\\n    public FindElements(TreeNode root) {\\n        set = new HashSet<Integer>();\\n        fixRecursive(root, null);\\n    \\n    }\\n    \\n    private void fixRecursive(TreeNode node, TreeNode parent) {\\n        \\n        if (node == null)\\n            return;\\n        \\n        if (parent == null)\\n            node.val = 0;\\n        else\\n            node.val = node == parent.left? 2 * parent.val + 1\\n                        : 2 * parent.val + 2;\\n        \\n        set.add(node.val);\\n        \\n        fixRecursive(node.left, node);\\n        fixRecursive(node.right, node);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass FindElements {\\n    \\n    private Set<Integer> set;\\n\\n    public FindElements(TreeNode root) {\\n        set = new HashSet<Integer>();\\n        fixRecursive(root, null);\\n    \\n    }\\n    \\n    private void fixRecursive(TreeNode node, TreeNode parent) {\\n        \\n        if (node == null)\\n            return;\\n        \\n        if (parent == null)\\n            node.val = 0;\\n        else\\n            node.val = node == parent.left? 2 * parent.val + 1\\n                        : 2 * parent.val + 2;\\n        \\n        set.add(node.val);\\n        \\n        fixRecursive(node.left, node);\\n        fixRecursive(node.right, node);\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681495,
                "title": "iterative-o-logn",
                "content": "class FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        target++;\\n        List<Integer> path = new ArrayList<>();\\n        while (target > 1) {\\n            path.add(0, target);\\n            target /= 2;\\n        }\\n        \\n        TreeNode cur = root;\\n        for (int num : path) {\\n            if (num % 2 == 0) {\\n                cur = cur.left;\\n            } else {\\n                cur = cur.right;\\n            }\\n            if (cur == null) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        target++;\\n        List<Integer> path = new ArrayList<>();\\n        while (target > 1) {\\n            path.add(0, target);\\n            target /= 2;\\n        }\\n        \\n        TreeNode cur = root;\\n        for (int num : path) {\\n            if (num % 2 == 0) {\\n                cur = cur.left;\\n            } else {\\n                cur = cur.right;\\n            }\\n            if (cur == null) {\\n                return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 587897,
                "title": "java-iterative-traversal-using-queue-and-find-using-hashset",
                "content": "1. Traversed iteratively using queue and set the values for the left and right child. Additionally added the same values to the HashSet, since with the given conditions (2*x+1 and 2*x+2 with root initialized to zero) there can be no nodes with the same values.\\n2. find will check the hashset and return the value\\n\\n```\\nclass FindElements {\\n    Set<Integer> treeNodeValues = new HashSet<Integer>();\\n\\t\\n    public FindElements(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\troot.val = 0;\\n\\t\\tTreeNode temp = null;\\n\\t\\t\\n\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\ttemp = queue.poll();\\n\\t\\t\\ttreeNodeValues.add(temp.val);\\n\\t\\t\\t\\n\\t\\t\\tif(temp.left != null) {\\n\\t\\t\\t\\ttemp.left.val = 2 * temp.val + 1;\\n\\t\\t\\t\\t//treeNodeValues.add(temp.left.val);\\n\\t\\t\\t\\tqueue.add(temp.left);\\n\\t\\t\\t}\\n\\t\\t\\tif(temp.right != null) {\\n\\t\\t\\t\\ttemp.right.val = 2 * temp.val + 2;\\n\\t\\t\\t\\t//treeNodeValues.add(temp.right.val);\\n\\t\\t\\t\\tqueue.add(temp.right);\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n    \\n    public boolean find(int target) {\\n        return treeNodeValues.contains(target);\\n    }\\n}\\n```\\nNote: Updated the code after the comment from @stanislav8",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    Set<Integer> treeNodeValues = new HashSet<Integer>();\\n\\t\\n    public FindElements(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n\\t\\tqueue.add(root);\\n\\t\\troot.val = 0;\\n\\t\\tTreeNode temp = null;\\n\\t\\t\\n\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\ttemp = queue.poll();\\n\\t\\t\\ttreeNodeValues.add(temp.val);\\n\\t\\t\\t\\n\\t\\t\\tif(temp.left != null) {\\n\\t\\t\\t\\ttemp.left.val = 2 * temp.val + 1;\\n\\t\\t\\t\\t//treeNodeValues.add(temp.left.val);\\n\\t\\t\\t\\tqueue.add(temp.left);\\n\\t\\t\\t}\\n\\t\\t\\tif(temp.right != null) {\\n\\t\\t\\t\\ttemp.right.val = 2 * temp.val + 2;\\n\\t\\t\\t\\t//treeNodeValues.add(temp.right.val);\\n\\t\\t\\t\\tqueue.add(temp.right);\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n    \\n    public boolean find(int target) {\\n        return treeNodeValues.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523255,
                "title": "java-solution-stick-with-tree",
                "content": "Just in case the examiner likes to tease your brain and restrict not to use HashTable and must traverse the tree :)\\n\\n```java\\tstatic class FindElements {\\n\\n\\t\\tTreeNode root;\\n\\n\\t\\tpublic FindElements(TreeNode r) {\\n\\t\\t\\tif (r == null) {\\n\\t\\t\\t\\tthis.root = null;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.root = new TreeNode(0);\\n\\t\\t\\t\\trecover(this.root, r);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate void recover(TreeNode root, TreeNode referenceRoot) {\\n\\t\\t\\tif (referenceRoot.left != null) {\\n\\t\\t\\t\\troot.left = new TreeNode(root.val * 2 + 1);\\n\\t\\t\\t\\trecover(root.left, referenceRoot.left);\\n\\t\\t\\t}\\n\\t\\t\\tif (referenceRoot.right != null) {\\n\\t\\t\\t\\troot.right = new TreeNode(root.val * 2 + 2);\\n\\t\\t\\t\\trecover(root.right, referenceRoot.right);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean find(int target) {\\n\\t\\t\\tif (target < 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tif (target == 0) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode curr = root;\\n\\t\\t\\tif (curr == null) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tStack<Boolean> stack = new Stack<Boolean>();\\n\\t\\t\\tint tmp = target;\\n\\n\\t\\t\\twhile (tmp > 0) {\\n\\t\\t\\t\\tif (tmp % 2 == 0) {\\n\\t\\t\\t\\t\\t// even\\n\\t\\t\\t\\t\\tstack.push(true);\\n\\t\\t\\t\\t\\ttmp = (tmp - 2) / 2;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// odd\\n\\t\\t\\t\\t\\tstack.push(false);\\n\\t\\t\\t\\t\\ttmp = (tmp - 1) / 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\t\\tif (stack.pop()) {\\n\\t\\t\\t\\t\\t// right\\n\\t\\t\\t\\t\\tif (curr.right == null) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (curr.right.val == target) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurr = curr.right;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// left\\n\\t\\t\\t\\t\\tif (curr.left == null) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (curr.left.val == target) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurr = curr.left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}`\\n``",
                "solutionTags": [],
                "code": "Just in case the examiner likes to tease your brain and restrict not to use HashTable and must traverse the tree :)\\n\\n```java\\tstatic class FindElements {\\n\\n\\t\\tTreeNode root;\\n\\n\\t\\tpublic FindElements(TreeNode r) {\\n\\t\\t\\tif (r == null) {\\n\\t\\t\\t\\tthis.root = null;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.root = new TreeNode(0);\\n\\t\\t\\t\\trecover(this.root, r);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tprivate void recover(TreeNode root, TreeNode referenceRoot) {\\n\\t\\t\\tif (referenceRoot.left != null) {\\n\\t\\t\\t\\troot.left = new TreeNode(root.val * 2 + 1);\\n\\t\\t\\t\\trecover(root.left, referenceRoot.left);\\n\\t\\t\\t}\\n\\t\\t\\tif (referenceRoot.right != null) {\\n\\t\\t\\t\\troot.right = new TreeNode(root.val * 2 + 2);\\n\\t\\t\\t\\trecover(root.right, referenceRoot.right);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tpublic boolean find(int target) {\\n\\t\\t\\tif (target < 0) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tif (target == 0) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tTreeNode curr = root;\\n\\t\\t\\tif (curr == null) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tStack<Boolean> stack = new Stack<Boolean>();\\n\\t\\t\\tint tmp = target;\\n\\n\\t\\t\\twhile (tmp > 0) {\\n\\t\\t\\t\\tif (tmp % 2 == 0) {\\n\\t\\t\\t\\t\\t// even\\n\\t\\t\\t\\t\\tstack.push(true);\\n\\t\\t\\t\\t\\ttmp = (tmp - 2) / 2;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// odd\\n\\t\\t\\t\\t\\tstack.push(false);\\n\\t\\t\\t\\t\\ttmp = (tmp - 1) / 2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\t\\tif (stack.pop()) {\\n\\t\\t\\t\\t\\t// right\\n\\t\\t\\t\\t\\tif (curr.right == null) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (curr.right.val == target) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurr = curr.right;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// left\\n\\t\\t\\t\\t\\tif (curr.left == null) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (curr.left.val == target) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tcurr = curr.left;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}`\\n``",
                "codeTag": "Java"
            },
            {
                "id": 501417,
                "title": "python-o-n-sol-by-correction-in-dfs-approach-90-with-comment",
                "content": "Python O(n) sol. by correction in DFS approach.\\n\\nHint:\\nTake advantage of **average O(1) looking-up** in hashset(i.e., **set()** in **python**),\\nrecording node value during binary tree correction, in order to **speed-up find()** operation later on\\n\\n---\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n\\n    def helper( self, node, correct_value ):\\n        \\n        # Base case:\\n        # Empty tree or empty node\\n        if not node:\\n            return\\n\\n        # Correct current node\\n        # Update node value set\\n        node.val = correct_value\\n        self.node_value.add( correct_value )\\n\\n        # Update next level with DFS\\n        self.helper( node.left, 2 * correct_value + 1)\\n        self.helper( node.right, 2 * correct_value + 2 )\\n\\n    # -----------------------------------------\\n    \\n    \\n    def __init__(self, root: TreeNode):\\n        \\n        \\n        self.root = root\\n\\n        # a set of node value in binary tree with given root\\n        self.node_value = set()\\n        \\n        # correct whole tree, from root node with correction value 0\\n        self.helper( self.root, 0 )\\n        \\n\\n    def find(self, target: int) -> bool:\\n        \\n        # lookup target in node value set\\n        return (target in self.node_value)\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```\\n\\n---\\n\\nRelative leetcode challenge:\\n\\n[Leetcode #114 Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)\\n\\n---\\n\\nReference:\\n[1] [Python official docs about built-in data structure: set()](https://docs.python.org/3/tutorial/datastructures.html#sets)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n\\n    def helper( self, node, correct_value ):\\n        \\n        # Base case:\\n        # Empty tree or empty node\\n        if not node:\\n            return\\n\\n        # Correct current node\\n        # Update node value set\\n        node.val = correct_value\\n        self.node_value.add( correct_value )\\n\\n        # Update next level with DFS\\n        self.helper( node.left, 2 * correct_value + 1)\\n        self.helper( node.right, 2 * correct_value + 2 )\\n\\n    # -----------------------------------------\\n    \\n    \\n    def __init__(self, root: TreeNode):\\n        \\n        \\n        self.root = root\\n\\n        # a set of node value in binary tree with given root\\n        self.node_value = set()\\n        \\n        # correct whole tree, from root node with correction value 0\\n        self.helper( self.root, 0 )\\n        \\n\\n    def find(self, target: int) -> bool:\\n        \\n        # lookup target in node value set\\n        return (target in self.node_value)\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486479,
                "title": "c-no-hashmap-bit-path",
                "content": "idea: Use a stack to store the bit path and then reversely find.\\n```\\nclass FindElements {\\npublic:\\n    FindElements(TreeNode* root) {\\n        r = root;\\n        if (!root) return;\\n        build(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        stack<bool> st;\\n        int t = target;\\n        while (t > 0) {\\n            if (t % 2) {\\n                st.push(true);\\n                t = (t - 1) / 2;\\n            } else {\\n                st.push(false);\\n                t = t / 2 - 1;\\n            }\\n        }\\n        TreeNode *cur = r;\\n        while (!st.empty()) {\\n            if (!cur) return false;\\n            if (st.top()) {\\n                cur = cur->left;\\n            } else {\\n                cur = cur->right;\\n            }\\n            st.pop();\\n        }\\n        if (cur && cur->val == target) return true;\\n        return false;\\n    }\\n    \\nprivate:\\n    TreeNode *r;\\n    \\n    void build(TreeNode* root, int val) {\\n        root->val = val;\\n        int n = 2 * val + 1;\\n        if (root->left) build(root->left, n);\\n        if (root->right) build(root->right, n + 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\npublic:\\n    FindElements(TreeNode* root) {\\n        r = root;\\n        if (!root) return;\\n        build(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        stack<bool> st;\\n        int t = target;\\n        while (t > 0) {\\n            if (t % 2) {\\n                st.push(true);\\n                t = (t - 1) / 2;\\n            } else {\\n                st.push(false);\\n                t = t / 2 - 1;\\n            }\\n        }\\n        TreeNode *cur = r;\\n        while (!st.empty()) {\\n            if (!cur) return false;\\n            if (st.top()) {\\n                cur = cur->left;\\n            } else {\\n                cur = cur->right;\\n            }\\n            st.pop();\\n        }\\n        if (cur && cur->val == target) return true;\\n        return false;\\n    }\\n    \\nprivate:\\n    TreeNode *r;\\n    \\n    void build(TreeNode* root, int val) {\\n        root->val = val;\\n        int n = 2 * val + 1;\\n        if (root->left) build(root->left, n);\\n        if (root->right) build(root->right, n + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479099,
                "title": "python-100-less-space",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x \\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        root.val = 0\\n        # Recover\\n        self.res = []\\n        self.recover(root)\\n        \\n    def recover(self,root):\\n        if not root:\\n            return\\n        self.res.append(root.val)\\n   \\n        if root.left:\\n            root.left.val = 2 * root.val + 1\\n            self.recover(root.left)\\n        if root.right:\\n            root.right.val = 2 * root.val + 2\\n            self.recover(root.right)\\n   \\n    def find(self, target: int) -> bool:\\n        return target in self.res     \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x \\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements:\\n\\n    def __init__(self, root: TreeNode):\\n        root.val = 0\\n        # Recover\\n        self.res = []\\n        self.recover(root)\\n        \\n    def recover(self,root):\\n        if not root:\\n            return\\n        self.res.append(root.val)\\n   \\n        if root.left:\\n            root.left.val = 2 * root.val + 1\\n            self.recover(root.left)\\n        if root.right:\\n            root.right.val = 2 * root.val + 2\\n            self.recover(root.right)\\n   \\n    def find(self, target: int) -> bool:\\n        return target in self.res     \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)",
                "codeTag": "Java"
            },
            {
                "id": 448692,
                "title": "python3-clean-solution-beats-80",
                "content": "\\tclass FindElements:\\n\\n\\t\\tdef __init__(self, root: TreeNode):\\n\\t\\t\\tself.root = root\\n\\n\\t\\tdef find(self, target: int) -> bool:\\n\\n\\t\\t\\tbinaryStr = \\'{0:b}\\'.format(target+1)\\n\\t\\t\\tcurrent = self.root\\n\\t\\t\\tfor c in binaryStr[1:]:\\n\\t\\t\\t\\tcurrent = current.left if c == \\'0\\' else current.right\\n\\t\\t\\t\\tif not current:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True",
                "solutionTags": [],
                "code": "\\tclass FindElements:\\n\\n\\t\\tdef __init__(self, root: TreeNode):\\n\\t\\t\\tself.root = root\\n\\n\\t\\tdef find(self, target: int) -> bool:\\n\\n\\t\\t\\tbinaryStr = \\'{0:b}\\'.format(target+1)\\n\\t\\t\\tcurrent = self.root\\n\\t\\t\\tfor c in binaryStr[1:]:\\n\\t\\t\\t\\tcurrent = current.left if c == \\'0\\' else current.right\\n\\t\\t\\t\\tif not current:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\treturn True",
                "codeTag": "Java"
            },
            {
                "id": 437281,
                "title": "100-space-java-easy-understandable",
                "content": "```\\nclass FindElements {\\n    TreeNode findRoot;\\n    public FindElements(TreeNode root) {\\n        if(root == null){return;}        \\n        findRoot = root;\\n        findRoot.val =0;\\n        assignValues(findRoot);\\n    }\\n    \\n    private void assignValues(TreeNode root){        \\n        if(root.left !=null){\\n            root.left.val = 2 * root.val +1;\\n            assignValues(root.left);\\n        }\\n        if(root.right !=null){\\n            root.right.val = 2 * root.val +2;\\n            assignValues(root.right);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n       return findTarget(findRoot, target); \\n    }\\n    \\n    boolean findTarget(TreeNode findRoot, int target){\\n        if(findRoot.val == target){\\n            return true;\\n        }\\n        if (findRoot.val > target) return false;\\n        boolean left =false, right =false;\\n        if(findRoot.left !=null){\\n           left = findTarget(findRoot.left, target);\\n        }\\n        \\n        if(findRoot.right !=null){\\n            right = findTarget(findRoot.right, target);\\n        }\\n        \\n        return left || right;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    TreeNode findRoot;\\n    public FindElements(TreeNode root) {\\n        if(root == null){return;}        \\n        findRoot = root;\\n        findRoot.val =0;\\n        assignValues(findRoot);\\n    }\\n    \\n    private void assignValues(TreeNode root){        \\n        if(root.left !=null){\\n            root.left.val = 2 * root.val +1;\\n            assignValues(root.left);\\n        }\\n        if(root.right !=null){\\n            root.right.val = 2 * root.val +2;\\n            assignValues(root.right);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n       return findTarget(findRoot, target); \\n    }\\n    \\n    boolean findTarget(TreeNode findRoot, int target){\\n        if(findRoot.val == target){\\n            return true;\\n        }\\n        if (findRoot.val > target) return false;\\n        boolean left =false, right =false;\\n        if(findRoot.left !=null){\\n           left = findTarget(findRoot.left, target);\\n        }\\n        \\n        if(findRoot.right !=null){\\n            right = findTarget(findRoot.right, target);\\n        }\\n        \\n        return left || right;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 437115,
                "title": "python-no-need-to-initialize-tree-top-down-search-by-binary",
                "content": "Look at the binary presentation of \"num+1\", you will find that binary value will append \"1\" when the tree go right, append \"0\" when the tree go left. With this feature, we can do a top down search without initialization.\\n\\nWe can also do it without using binary feature. We notice that even number is always on the right branch, odd number is always on the left branch, using this feature, we can reversely find the path of the number in the tree. Reversing this path and we will have the top-down path.\\n\\n```\\n    def find(self, target: int) -> bool:\\n        tmp=bin(target+1)[3:]\\n        node=self.root\\n        for t in tmp:\\n            if t==\\'0\\':\\n                if not node.left:\\n                    return False\\n                node=node.left\\n            elif t==\\'1\\':\\n                if not node.right:\\n                    return False\\n                node=node.right\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\n    def find(self, target: int) -> bool:\\n        tmp=bin(target+1)[3:]\\n        node=self.root\\n        for t in tmp:\\n            if t==\\'0\\':\\n                if not node.left:\\n                    return False\\n                node=node.left\\n            elif t==\\'1\\':\\n                if not node.right:\\n                    return False\\n                node=node.right\\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 435179,
                "title": "python-easy-to-understand-solution",
                "content": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.s = set()\\n        \\n        head = TreeNode(-1)\\n        head.right = root\\n        arr = [head]\\n        while arr:\\n            top = arr.pop(0)\\n            val = top.val\\n            self.s.add(val)\\n            left, right = top.left, top.right\\n            if left:\\n                left.val = 2 * val + 1\\n                arr.append(left)\\n            if right:\\n                right.val = 2 * val + 2\\n                arr.append(right)\\n        \\n\\n    def find(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        return target in self.s\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [],
                "code": "```python\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass FindElements(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.s = set()\\n        \\n        head = TreeNode(-1)\\n        head.right = root\\n        arr = [head]\\n        while arr:\\n            top = arr.pop(0)\\n            val = top.val\\n            self.s.add(val)\\n            left, right = top.left, top.right\\n            if left:\\n                left.val = 2 * val + 1\\n                arr.append(left)\\n            if right:\\n                right.val = 2 * val + 2\\n                arr.append(right)\\n        \\n\\n    def find(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: bool\\n        \"\"\"\\n        return target in self.s\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434356,
                "title": "python-java-easy-bitwise-trick-with-explanation",
                "content": "Given a number X, what\\'s the path to the corresponding node of X?\\nExample:\\nX = 1, path = left --> 0\\nX = 3, path = left, left --> 00\\nX = 9, path = left, right, left --> 010\\nX = 16, path = left, left, left, right --> 0001\\n......\\nCan you see the trick?\\npath = binary(X+1).substring(1)\\n\\nThen everything be quite easy:\\nPython:\\n```python\\nclass FindElements:\\n    \\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n\\n    def find(self, target: int) -> bool:\\n        target += 1\\n        path = bin(target)[3:]\\n        current = self.root\\n        for p in path:\\n            if not current: \\n                return False\\n            if p == \\'0\\':\\n                current = current.left\\n            else:\\n                current = current.right\\n        return current != None\\n```\\nJava:\\n```java\\nclass FindElements {\\n    \\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        TreeNode current = this.root;\\n        String path = Integer.toBinaryString(target + 1).substring(1);\\n        for (char c: path.toCharArray()) {\\n            if (current == null) return false;\\n            if (c == \\'0\\'){\\n                current = current.left;\\n            }\\n            else {\\n                current = current.right;\\n            }\\n        }\\n        return current != null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass FindElements:\\n    \\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n\\n    def find(self, target: int) -> bool:\\n        target += 1\\n        path = bin(target)[3:]\\n        current = self.root\\n        for p in path:\\n            if not current: \\n                return False\\n            if p == \\'0\\':\\n                current = current.left\\n            else:\\n                current = current.right\\n        return current != None\\n```\n```java\\nclass FindElements {\\n    \\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int target) {\\n        TreeNode current = this.root;\\n        String path = Integer.toBinaryString(target + 1).substring(1);\\n        for (char c: path.toCharArray()) {\\n            if (current == null) return false;\\n            if (c == \\'0\\'){\\n                current = current.left;\\n            }\\n            else {\\n                current = current.right;\\n            }\\n        }\\n        return current != null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433461,
                "title": "c-super-simple-and-straight-forward-solution-with-o-1-find-can-be-easily-implemented-in-5-mins",
                "content": "A BFS solution in C++:\\n```   \\n    unordered_set<int> nums;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty()) {\\n            TreeNode* r=q.front();\\n            q.pop();\\n            nums.insert(r->val);\\n            if(r->left!=NULL) {\\n                r->left->val=r->val*2+1;\\n                q.push(r->left);\\n            }\\n            if(r->right!=NULL) \\n            {\\n                r->right->val=r->val*2+2;\\n                q.push(r->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return nums.find(target)!=nums.end();\\n    }",
                "solutionTags": [],
                "code": "A BFS solution in C++:\\n```   \\n    unordered_set<int> nums;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(!q.empty()) {\\n            TreeNode* r=q.front();\\n            q.pop();\\n            nums.insert(r->val);\\n            if(r->left!=NULL) {\\n                r->left->val=r->val*2+1;\\n                q.push(r->left);\\n            }\\n            if(r->right!=NULL) \\n            {\\n                r->right->val=r->val*2+2;\\n                q.push(r->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return nums.find(target)!=nums.end();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 432956,
                "title": "easy-preorder-traversal-hash-table-c-solution-t-o-n-s-o-n",
                "content": "```\\nclass FindElements {\\n    unordered_set<int> ht;\\npublic:\\n    void helper(TreeNode* root, int x, int child){\\n        if(root==nullptr) return;\\n        if(child==0)    \\n            root->val=2*x+1;\\n        else\\n            root->val=2*x+2;\\n        ht.insert(root->val);\\n        helper(root->left, root->val, 0);\\n        helper(root->right, root->val, 1);\\n    }\\n    FindElements(TreeNode* root) {\\n       if(root==nullptr) return;\\n        root->val=0;\\n        ht.insert(root->val);\\n        helper(root->left, root->val, 0);\\n        helper(root->right, root->val, 1);\\n    }\\n    \\n    \\n    bool find(int target) {\\n        if(ht.find(target)!=ht.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass FindElements {\\n    unordered_set<int> ht;\\npublic:\\n    void helper(TreeNode* root, int x, int child){\\n        if(root==nullptr) return;\\n        if(child==0)    \\n            root->val=2*x+1;\\n        else\\n            root->val=2*x+2;\\n        ht.insert(root->val);\\n        helper(root->left, root->val, 0);\\n        helper(root->right, root->val, 1);\\n    }\\n    FindElements(TreeNode* root) {\\n       if(root==nullptr) return;\\n        root->val=0;\\n        ht.insert(root->val);\\n        helper(root->left, root->val, 0);\\n        helper(root->right, root->val, 1);\\n    }\\n    \\n    \\n    bool find(int target) {\\n        if(ht.find(target)!=ht.end())\\n            return true;\\n        return false;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 431344,
                "title": "c-solution",
                "content": "```\\npublic class FindElements \\n{\\n    private TreeNode root;\\n    \\n    public FindElements(TreeNode r) \\n    {\\n        this.root = r;\\n    }\\n    \\n    public bool Find(int target) \\n    {\\n        return Find(root, target, 0);\\n    }\\n    \\n    private bool Find(TreeNode node, int target, int index)\\n    {\\n        if(target == index) return true;\\n        var left = node.left == null ? false : Find(node.left, target, index * 2 + 1); \\n        var right = node.right == null ? false : Find(node.right, target, index * 2 + 2);\\n        return left || right;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class FindElements \\n{\\n    private TreeNode root;\\n    \\n    public FindElements(TreeNode r) \\n    {\\n        this.root = r;\\n    }\\n    \\n    public bool Find(int target) \\n    {\\n        return Find(root, target, 0);\\n    }\\n    \\n    private bool Find(TreeNode node, int target, int index)\\n    {\\n        if(target == index) return true;\\n        var left = node.left == null ? false : Find(node.left, target, index * 2 + 1); \\n        var right = node.right == null ? false : Find(node.right, target, index * 2 + 2);\\n        return left || right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 431058,
                "title": "java-simple-pre-order-traversal",
                "content": "```\\nclass FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        recover(root, 0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return findAux(target, root);\\n    }\\n    \\n    private void recover(TreeNode node, int val) {\\n        if (node == null) return;\\n        node.val = val;\\n        recover(node.left, 2*val+1);\\n        recover(node.right, 2*val+2);\\n    }\\n    \\n    private boolean findAux(int target, TreeNode node) {\\n        if (node == null) return false;\\n        if (node.val == target) return true;\\n        if (node.val > target) return false;\\n        return findAux(target, node.left) || findAux(target, node.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        recover(root, 0);\\n    }\\n    \\n    public boolean find(int target) {\\n        return findAux(target, root);\\n    }\\n    \\n    private void recover(TreeNode node, int val) {\\n        if (node == null) return;\\n        node.val = val;\\n        recover(node.left, 2*val+1);\\n        recover(node.right, 2*val+2);\\n    }\\n    \\n    private boolean findAux(int target, TreeNode node) {\\n        if (node == null) return false;\\n        if (node.val == target) return true;\\n        if (node.val > target) return false;\\n        return findAux(target, node.left) || findAux(target, node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088287,
                "title": "java-solution-using-bits-manipulation-without-tree-recovery-tc-o-logn-sc-o-1",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass FindElements {\\n    private TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int x) {\\n        int mask = 1;\\n        while (x != 0) {\\n            mask <<= 1;\\n            mask |= (x & 1);\\n            x = (x - 1) >> 1;\\n        }\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (mask == 1) return true;\\n            node = (mask & 1) == 1 ? node.left : node.right;\\n            mask >>= 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass FindElements {\\n    private TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n    }\\n    \\n    public boolean find(int x) {\\n        int mask = 1;\\n        while (x != 0) {\\n            mask <<= 1;\\n            mask |= (x & 1);\\n            x = (x - 1) >> 1;\\n        }\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (mask == 1) return true;\\n            node = (mask & 1) == 1 ? node.left : node.right;\\n            mask >>= 1;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083799,
                "title": "python-easy-solution-for-beginner-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are traversing and add value into our hashset.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def f(self,root,val):\\n        if root==None:\\n            return \\n        self.dict.add(val)\\n        if root.left:\\n            vl=(2*val)+1\\n            self.f(root.left,vl)\\n\\n        if root.right:\\n            vr=(2*val)+2\\n            self.f(root.right,vr)\\n\\n\\n\\n        \\n    def __init__(self, root: Optional[TreeNode]):\\n        self.dict=set()\\n        self.f(root,0)\\n        \\n\\n    def find(self, target: int) -> bool:\\n        if target in self.dict:\\n            return True\\n\\n        else:\\n            return False\\n\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n    def f(self,root,val):\\n        if root==None:\\n            return \\n        self.dict.add(val)\\n        if root.left:\\n            vl=(2*val)+1\\n            self.f(root.left,vl)\\n\\n        if root.right:\\n            vr=(2*val)+2\\n            self.f(root.right,vr)\\n\\n\\n\\n        \\n    def __init__(self, root: Optional[TreeNode]):\\n        self.dict=set()\\n        self.f(root,0)\\n        \\n\\n    def find(self, target: int) -> bool:\\n        if target in self.dict:\\n            return True\\n\\n        else:\\n            return False\\n\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075263,
                "title": "dfs-recover-method-and-hashset",
                "content": "## Result\\n![image.png](https://assets.leetcode.com/users/images/6f702887-d68d-4273-b7d0-cf4a3c8e5c5b_1695363557.7931392.png)\\n\\n## Code\\n```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.node = root\\n        self.values = set()\\n        self.recover(root, 0)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.values\\n    \\n    def recover(self, node, val):\\n        if node is None:\\n            return\\n        node.val = val\\n        self.values.add(val)\\n        self.recover(node.left, 2 * val + 1)\\n        self.recover(node.right, 2 * val + 2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.node = root\\n        self.values = set()\\n        self.recover(root, 0)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.values\\n    \\n    def recover(self, node, val):\\n        if node is None:\\n            return\\n        node.val = val\\n        self.values.add(val)\\n        self.recover(node.left, 2 * val + 1)\\n        self.recover(node.right, 2 * val + 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4029028,
                "title": "recursion-dfs",
                "content": "# Code\\n```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n            \\n\\n    def find(self, target: int) -> bool:\\n        def dfs(node, s, p):\\n            if not node:\\n                return False\\n            if len(s) == p:\\n                return True\\n            return dfs(node.left, s, p+1) if s[p] == \\'0\\' else dfs(node.right, s, p+1)\\n        return dfs(self.root, bin(target+1)[2:], 1)\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n            \\n\\n    def find(self, target: int) -> bool:\\n        def dfs(node, s, p):\\n            if not node:\\n                return False\\n            if len(s) == p:\\n                return True\\n            return dfs(node.left, s, p+1) if s[p] == \\'0\\' else dfs(node.right, s, p+1)\\n        return dfs(self.root, bin(target+1)[2:], 1)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010939,
                "title": "solution-using-hashmap-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will recover the tree initially and then we will store all the values from recovery to a hashmap and then return the query result referring the hashmap.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Steps :**\\n1. First we create a function to traverse the tree that is provided and recover it.\\n2. While recovering, we put all the values recovered in a hashtable.\\n3. Lastly we will check if the target is present in the hashtable and return values accordingly. \\n\\n# Complexity\\n- Time complexity: O(n + q) where **n** = number of nodes present in the tree and **q** is the number of queries.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int, int> um;\\n    void recover(TreeNode * r, int v){\\n        if(r == NULL)\\n            return;\\n\\n        r->val = v;\\n        um[v]++;\\n        recover(r->left, (2 * v) + 1);\\n        recover(r->right, (2 * v) + 2);\\n    }\\n\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        if(um[target] > 0)\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int, int> um;\\n    void recover(TreeNode * r, int v){\\n        if(r == NULL)\\n            return;\\n\\n        r->val = v;\\n        um[v]++;\\n        recover(r->left, (2 * v) + 1);\\n        recover(r->right, (2 * v) + 2);\\n    }\\n\\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        if(um[target] > 0)\\n            return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000237,
                "title": "c-simple-solution",
                "content": "# Approach\\n1. Recover the root first by setting it to 0 and store in map\\n2. Traverse to other nodes and recover them too\\n3. After recovering each node store that in map to search later\\n4. To find target find the value in the map and return true if found\\n\\n# Code\\n```\\nclass FindElements {\\npublic:\\n    unordered_map<int,int>mp;\\n    //function to recover other nodes\\n    void traversal(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        int x=root->val;\\n        //while recovering also store new node values in a map\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=(2*x)+1;\\n            mp[root->left->val]++;\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=(2*x)+2;\\n            mp[root->right->val]++;\\n        }\\n        traversal(root->left);\\n        traversal(root->right);\\n    }\\n    FindElements(TreeNode* root) \\n    {\\n        //recover the root first and store it\\'s value in map\\n        root->val=0;\\n        mp[root->val]++;\\n        traversal(root);\\n    }\\n    bool find(int target) \\n    {\\n        //check if target value is present in the map\\n        if(mp.find(target)!=mp.end())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    unordered_map<int,int>mp;\\n    //function to recover other nodes\\n    void traversal(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        int x=root->val;\\n        //while recovering also store new node values in a map\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=(2*x)+1;\\n            mp[root->left->val]++;\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=(2*x)+2;\\n            mp[root->right->val]++;\\n        }\\n        traversal(root->left);\\n        traversal(root->right);\\n    }\\n    FindElements(TreeNode* root) \\n    {\\n        //recover the root first and store it\\'s value in map\\n        root->val=0;\\n        mp[root->val]++;\\n        traversal(root);\\n    }\\n    bool find(int target) \\n    {\\n        //check if target value is present in the map\\n        if(mp.find(target)!=mp.end())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3956071,
                "title": "easy-java-solution",
                "content": "# Intuition\\nWhen we read about the rules of the binary tree, we can understand that given any node value, we can determine the values of its left and right children. Therefore, if the tree\\'s values are changed to -1, we can still recover the tree\\'s original values by traversing it from the root and assigning the correct values according to the rules provided.\\n\\n# Approach\\n\\n1. Initialization:\\n\\n* Start by setting the root\\'s value to 0.\\n* Use a queue to traverse the tree in a BFS manner. This choice ensures that we visit nodes level by level, which is beneficial because child node values depend on parent node values.\\n* While there are nodes in the queue, pop a node.\\n* If it has a left child, set the left child\\'s value using the formula 2\\xD7node.val+1 and add the left child to the queue.\\n* Similarly, if it has a right child, set the right child\\'s value using the formula  2\\xD7node.val+2\\n* Additionally, for each node we visit, we add its value to a hash set. This set allows for O(1) look-up time when checking if a value exists in the tree.\\n\\n3. 2. Finding a Value:\\n\\n* To check if a value exists in the recovered tree, simply check if it exists in the hash set.\\n\\n\\n# Complexity\\n- Time complexity: O(N), O(1)\\n\\n\\n- Space complexity: O(N)\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    HashSet<Integer> set = new HashSet<>();\\n\\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while(!queue.isEmpty()){\\n            TreeNode node = queue.poll();\\n            set.add(node.val);\\n            if(node.right!=null){\\n                node.right.val = 2*node.val + 2;\\n                queue.add(node.right);\\n            }\\n            if(node.left!=null){\\n                node.left.val = 2*node.val + 1; \\n                queue.add(node.left);\\n            }\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    HashSet<Integer> set = new HashSet<>();\\n\\n    public FindElements(TreeNode root) {\\n        root.val = 0;\\n\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while(!queue.isEmpty()){\\n            TreeNode node = queue.poll();\\n            set.add(node.val);\\n            if(node.right!=null){\\n                node.right.val = 2*node.val + 2;\\n                queue.add(node.right);\\n            }\\n            if(node.left!=null){\\n                node.left.val = 2*node.val + 1; \\n                queue.add(node.left);\\n            }\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return set.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953690,
                "title": "level-order-traversal-binary-search",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass FindElements {\\npublic:\\n    vector <int> num;\\n\\n    // stor level-order traversal of recover BT in vector....\\n\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        if(root != NULL) root->val = 0;\\n        q.push(root);\\n        while(!q.empty()){\\n            auto n = q.front();\\n            q.pop();\\n            num.push_back(n->val);\\n            \\n            if(n->left){\\n                n->left->val = 2*n->val + 1;\\n                q.push(n->left);\\n            }\\n            if(n->right){\\n                n->right->val = 2*n->val + 2;\\n                q.push(n->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int tar) {\\n        // level-order traversal of recover BT is sorted\\n        // so vector-num is sorted array\\n        // now we can apply Binary Search in num...\\n        int s = 0, e = num.size()-1;\\n        while(s <= e){\\n            int mid = s + (e-s)/2;\\n            if(num[mid] == tar) return true;\\n            else if(num[mid] > tar) e = mid-1;\\n            else s = mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    vector <int> num;\\n\\n    // stor level-order traversal of recover BT in vector....\\n\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        if(root != NULL) root->val = 0;\\n        q.push(root);\\n        while(!q.empty()){\\n            auto n = q.front();\\n            q.pop();\\n            num.push_back(n->val);\\n            \\n            if(n->left){\\n                n->left->val = 2*n->val + 1;\\n                q.push(n->left);\\n            }\\n            if(n->right){\\n                n->right->val = 2*n->val + 2;\\n                q.push(n->right);\\n            }\\n        }\\n    }\\n    \\n    bool find(int tar) {\\n        // level-order traversal of recover BT is sorted\\n        // so vector-num is sorted array\\n        // now we can apply Binary Search in num...\\n        int s = 0, e = num.size()-1;\\n        while(s <= e){\\n            int mid = s + (e-s)/2;\\n            if(num[mid] == tar) return true;\\n            else if(num[mid] > tar) e = mid-1;\\n            else s = mid+1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953465,
                "title": "python-easy-clean-solution",
                "content": "# Code\\n```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.db = set()\\n        self.db.add(0)\\n        root.val = 0\\n\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            \\n            if node.left:\\n                node.left.val = 2 * node.val + 1\\n                self.db.add(node.left.val)\\n                stack.append(node.left)\\n            \\n            if node.right:\\n                node.right.val = 2 * node.val + 2\\n                self.db.add(node.right.val)\\n                stack.append(node.right)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.db\\n```\\n![catty.png](https://assets.leetcode.com/users/images/5888e488-44f4-4c24-9b81-552eac175cfc_1692866410.1003535.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.db = set()\\n        self.db.add(0)\\n        root.val = 0\\n\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            \\n            if node.left:\\n                node.left.val = 2 * node.val + 1\\n                self.db.add(node.left.val)\\n                stack.append(node.left)\\n            \\n            if node.right:\\n                node.right.val = 2 * node.val + 2\\n                self.db.add(node.right.val)\\n                stack.append(node.right)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.db\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931318,
                "title": "python3-beats-99",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        root.val = 0\\n        d = [root]\\n        self.s= set()\\n        while d:\\n            x = d.pop()\\n            self.s.add(x.val)\\n            if x.left:\\n                x.left.val = 2*x.val+1\\n                d.append(x.left)\\n            if x.right:\\n                x.right.val = 2*x.val+2\\n                d.append(x.right)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.s\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        root.val = 0\\n        d = [root]\\n        self.s= set()\\n        while d:\\n            x = d.pop()\\n            self.s.add(x.val)\\n            if x.left:\\n                x.left.val = 2*x.val+1\\n                d.append(x.left)\\n            if x.right:\\n                x.right.val = 2*x.val+2\\n                d.append(x.right)\\n        \\n    def find(self, target: int) -> bool:\\n        return target in self.s\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929431,
                "title": "python3-clean-dfs-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        \\n        def f(root,ind):\\n            if not root:\\n                return\\n            self.seen.add(ind)\\n            f(root.left,2*ind+1)\\n            f(root.right,2*ind+2)\\n        \\n        self.seen=set()\\n        f(root,0)\\n        \\n        \\n    def find(self, target: int) -> bool:\\n        \\n        return target in self.seen\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        \\n        def f(root,ind):\\n            if not root:\\n                return\\n            self.seen.add(ind)\\n            f(root.left,2*ind+1)\\n            f(root.right,2*ind+2)\\n        \\n        self.seen=set()\\n        f(root,0)\\n        \\n        \\n    def find(self, target: int) -> bool:\\n        \\n        return target in self.seen\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918921,
                "title": "python-solution-using-map-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the tree and assign the right set of values, also store these values in map or set which can be used later to determine whether the value exists in the tree or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse the tree, and assign the correct set of values i.e. $$(2 * value  + 1)$$ for left and $$(2 * value + 2)$$ for the right. As you assign the value to the tree, store that value in order to determine whether that value exists or not when you will query the tree later.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/95e6bf36-04b7-4288-b8ea-f8bfcf1da870_1692204361.671172.png)\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom queue import Queue\\n\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.map = {}\\n        self.updateTree(self.root)\\n        \\n    def updateTree(self, root, val = 0):\\n        if root == None:\\n            return\\n        \\n        root.val = val\\n        self.map[val] = True\\n\\n        if root.left != None:\\n            self.updateTree(root.left, 2 * val + 1)\\n        \\n        if root.right != None:\\n            self.updateTree(root.right, 2 * val + 2)\\n\\n\\n    def find(self, target: int) -> bool:\\n        if self.root == None:\\n            return False\\n\\n        return target in self.map\\n\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nfrom queue import Queue\\n\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.map = {}\\n        self.updateTree(self.root)\\n        \\n    def updateTree(self, root, val = 0):\\n        if root == None:\\n            return\\n        \\n        root.val = val\\n        self.map[val] = True\\n\\n        if root.left != None:\\n            self.updateTree(root.left, 2 * val + 1)\\n        \\n        if root.right != None:\\n            self.updateTree(root.right, 2 * val + 2)\\n\\n\\n    def find(self, target: int) -> bool:\\n        if self.root == None:\\n            return False\\n\\n        return target in self.map\\n\\n        \\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902473,
                "title": "python3-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.vals = set()\\n        root.val = 0\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            self.vals.add(node.val)\\n\\n            if node.left:\\n                node.left.val = 2 * node.val + 1\\n                queue.append(node.left)\\n            if node.right:\\n                node.right.val = 2 * node.val + 2\\n                queue.append(node.right)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.vals\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.vals = set()\\n        root.val = 0\\n        queue = deque([root])\\n        while queue:\\n            node = queue.popleft()\\n            self.vals.add(node.val)\\n\\n            if node.left:\\n                node.left.val = 2 * node.val + 1\\n                queue.append(node.left)\\n            if node.right:\\n                node.right.val = 2 * node.val + 2\\n                queue.append(node.right)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.vals\\n\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895129,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    TreeNode head=null;\\n    int f=1;\\n    boolean ft=false;\\n    public FindElements(TreeNode root) {\\n        head=create(root);\\n    }\\n\\n    public TreeNode create(TreeNode root){\\n        if(root==null)\\n        return root;\\n        if(f==1){\\n            root.val=0;\\n            f=0;\\n        }\\n        if(root.left!=null){\\n            root.left.val=2*root.val+1;\\n        }\\n        if(root.right!=null){\\n            root.right.val=2*root.val+2;\\n        }\\n        create(root.left);\\n        create(root.right);\\n        return root;\\n    }\\n    public boolean find1(int t,TreeNode root){\\n        if(root==null)\\n        return false;\\n\\n        if(root.val==t)\\n        ft=true;\\n        else{\\n            find1(t,root.left);\\n            find1(t,root.right);\\n        }\\n        return ft;\\n        \\n    }\\n    public boolean find(int target) {\\n        ft=false;\\n        find1(target,head);\\n        return ft;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n    TreeNode head=null;\\n    int f=1;\\n    boolean ft=false;\\n    public FindElements(TreeNode root) {\\n        head=create(root);\\n    }\\n\\n    public TreeNode create(TreeNode root){\\n        if(root==null)\\n        return root;\\n        if(f==1){\\n            root.val=0;\\n            f=0;\\n        }\\n        if(root.left!=null){\\n            root.left.val=2*root.val+1;\\n        }\\n        if(root.right!=null){\\n            root.right.val=2*root.val+2;\\n        }\\n        create(root.left);\\n        create(root.right);\\n        return root;\\n    }\\n    public boolean find1(int t,TreeNode root){\\n        if(root==null)\\n        return false;\\n\\n        if(root.val==t)\\n        ft=true;\\n        else{\\n            find1(t,root.left);\\n            find1(t,root.right);\\n        }\\n        return ft;\\n        \\n    }\\n    public boolean find(int target) {\\n        ft=false;\\n        find1(target,head);\\n        return ft;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890896,
                "title": "simple-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int,int>mp;\\n    void create(TreeNode* root,int x)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        root->val=x;\\n        mp[x]++;\\n        create(root->left,2*x+1);\\n        create(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        create(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target)==mp.end())\\n        {\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int,int>mp;\\n    void create(TreeNode* root,int x)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        root->val=x;\\n        mp[x]++;\\n        create(root->left,2*x+1);\\n        create(root->right,2*x+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        create(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        if(mp.find(target)==mp.end())\\n        {\\n            return false;\\n        }\\n        else{\\n            return true;\\n        }\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875732,
                "title": "python-easy-and-short-dfs-find-0-1",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$ for init\\n$$O(1)$$ for find\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.values = set()\\n        \\n        def dfs(node, val):\\n            if not node: return\\n            self.values.add(val)\\n            dfs(node.left, 2 * val + 1)\\n            dfs(node.right, 2 * val + 2)\\n        \\n        dfs(root, 0)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.values\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass FindElements:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.values = set()\\n        \\n        def dfs(node, val):\\n            if not node: return\\n            self.values.add(val)\\n            dfs(node.left, 2 * val + 1)\\n            dfs(node.right, 2 * val + 2)\\n        \\n        dfs(root, 0)\\n\\n    def find(self, target: int) -> bool:\\n        return target in self.values\\n\\n# Your FindElements object will be instantiated and called as such:\\n# obj = FindElements(root)\\n# param_1 = obj.find(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837024,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nprivate:\\n    TreeNode* root1;\\npublic:\\n    FindElements(TreeNode* root) {\\n        root1 = root;  \\n        value(root , 0);\\n    }\\n\\n    void value(TreeNode* root , int x){\\n        if (root == NULL)\\n            return;\\n        \\n        root->val = x;\\n        value(root->left , 2*x + 1);\\n        value(root->right , 2*x + 2);\\n    }\\n\\n    bool solve(int target , TreeNode* root){\\n        if (root == NULL)\\n            return false;\\n        \\n        if (root->val == target)\\n            return true;\\n        bool left = solve(target , root->left);\\n        bool right = solve(target , root->right);\\n\\n        return left||right;\\n    }\\n    \\n    bool find(int target) {\\n        if (root1->val == target)\\n            return true;\\n        \\n        return solve(target , root1);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nprivate:\\n    TreeNode* root1;\\npublic:\\n    FindElements(TreeNode* root) {\\n        root1 = root;  \\n        value(root , 0);\\n    }\\n\\n    void value(TreeNode* root , int x){\\n        if (root == NULL)\\n            return;\\n        \\n        root->val = x;\\n        value(root->left , 2*x + 1);\\n        value(root->right , 2*x + 2);\\n    }\\n\\n    bool solve(int target , TreeNode* root){\\n        if (root == NULL)\\n            return false;\\n        \\n        if (root->val == target)\\n            return true;\\n        bool left = solve(target , root->left);\\n        bool right = solve(target , root->right);\\n\\n        return left||right;\\n    }\\n    \\n    bool find(int target) {\\n        if (root1->val == target)\\n            return true;\\n        \\n        return solve(target , root1);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825912,
                "title": "c-solution-dfs",
                "content": "```\\nclass FindElements {\\npublic:\\n    TreeNode* m_root;\\n    map<int, int> mp;\\n\\n    FindElements(TreeNode* root) {\\n        m_root = root;\\n        recover(m_root);\\n    }\\n    \\n    bool find(int target) {\\n        return mp.count(target) > 0;\\n    }\\nprivate:\\n    int recover(TreeNode* root, int x = 0) {\\n        if (!root)\\n            return 0;\\n        if (root->left)\\n            root->left->val = recover(root->left, 2 * x + 1);\\n        root->val = x;\\n        mp[x]++;\\n        if (root->right)\\n            root->right->val = recover(root->right, 2 * x + 2);\\n        return root->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    TreeNode* m_root;\\n    map<int, int> mp;\\n\\n    FindElements(TreeNode* root) {\\n        m_root = root;\\n        recover(m_root);\\n    }\\n    \\n    bool find(int target) {\\n        return mp.count(target) > 0;\\n    }\\nprivate:\\n    int recover(TreeNode* root, int x = 0) {\\n        if (!root)\\n            return 0;\\n        if (root->left)\\n            root->left->val = recover(root->left, 2 * x + 1);\\n        root->val = x;\\n        mp[x]++;\\n        if (root->right)\\n            root->right->val = recover(root->right, 2 * x + 2);\\n        return root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819886,
                "title": "find-elements-in-a-contaminated-binary-tree-easiest-with-c",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    map<int, int>mp;\\n    void recoverTree(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        mp[root->val]++;\\n        if(root->left)\\n            root->left->val = 2 * root->val + 1;\\n        if(root->right)\\n            root->right->val = 2 * root->val + 2;\\n\\n        recoverTree(root->left);\\n        recoverTree(root->right);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        recoverTree(root);\\n    }\\n    \\n    bool find(int target) {\\n        return mp[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    map<int, int>mp;\\n    void recoverTree(TreeNode* &root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        mp[root->val]++;\\n        if(root->left)\\n            root->left->val = 2 * root->val + 1;\\n        if(root->right)\\n            root->right->val = 2 * root->val + 2;\\n\\n        recoverTree(root->left);\\n        recoverTree(root->right);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        recoverTree(root);\\n    }\\n    \\n    bool find(int target) {\\n        return mp[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788198,
                "title": "easy-c-solution-dfs-map-efficient-clean-code",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nn= number of nodes\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    unordered_map<int,int> mp;\\n    void solve(TreeNode* root){\\n        if(root==NULL)\\n            return;\\n        mp[root->val]=1;\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=2*root->val+1;\\n            solve(root->left);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=2*root->val+2;\\n            solve(root->right);\\n        }\\n    }\\npublic:\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n    }\\n    \\n    bool find(int t) {\\n        return mp[t];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    unordered_map<int,int> mp;\\n    void solve(TreeNode* root){\\n        if(root==NULL)\\n            return;\\n        mp[root->val]=1;\\n        if(root->left!=NULL)\\n        {\\n            root->left->val=2*root->val+1;\\n            solve(root->left);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=2*root->val+2;\\n            solve(root->right);\\n        }\\n    }\\npublic:\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        solve(root);\\n    }\\n    \\n    bool find(int t) {\\n        return mp[t];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753464,
                "title": "easy-solution-with-dfs-and-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nmap<int,bool>Exist;\\n    FindElements(TreeNode* root) {\\n        RecoveredTree(root,0);\\n    }\\n\\n    void RecoveredTree(TreeNode* root,int value){\\n        if(root==NULL)return;\\n        root->val=value;\\n        Exist[value]=1;\\n        RecoveredTree(root->left,(2*value)+1);\\n        RecoveredTree(root->right,(2*value)+2);\\n    }\\n    \\n    bool find(int target) {\\n        return Exist[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nmap<int,bool>Exist;\\n    FindElements(TreeNode* root) {\\n        RecoveredTree(root,0);\\n    }\\n\\n    void RecoveredTree(TreeNode* root,int value){\\n        if(root==NULL)return;\\n        root->val=value;\\n        Exist[value]=1;\\n        RecoveredTree(root->left,(2*value)+1);\\n        RecoveredTree(root->right,(2*value)+2);\\n    }\\n    \\n    bool find(int target) {\\n        return Exist[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750362,
                "title": "cpp-using-hash-map-clean-code",
                "content": "\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_set<int>s;\\n    void dfs(TreeNode *root){\\n        if(root!=NULL){\\n            if(root->left){\\n                root->left->val=2*root->val +1;\\n                s.insert(root->left->val);\\n            }\\n            dfs(root->left);\\n            if(root->right){\\n                root->right->val=2*root->val +2;\\n                s.insert(root->right->val);\\n            }\\n            dfs(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.insert(0);\\n        dfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)==s.end())return false;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_set<int>s;\\n    void dfs(TreeNode *root){\\n        if(root!=NULL){\\n            if(root->left){\\n                root->left->val=2*root->val +1;\\n                s.insert(root->left->val);\\n            }\\n            dfs(root->left);\\n            if(root->right){\\n                root->right->val=2*root->val +2;\\n                s.insert(root->right->val);\\n            }\\n            dfs(root->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.insert(0);\\n        dfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        if(s.find(target)==s.end())return false;\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746686,
                "title": "easy-c-code",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int,int> mp;\\n    FindElements(TreeNode* root) {\\n        mp.clear();\\n\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n\\n        while(!q.empty()){\\n            TreeNode* node= q.front().first;\\n            int v= q.front().second;\\n            mp[v]=1;\\n            node->val=v;\\n            q.pop();\\n\\n            if(node->left) q.push({node->left,2*v+1});\\n            if(node->right) q.push({node->right,2*v+2});\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return mp[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_map<int,int> mp;\\n    FindElements(TreeNode* root) {\\n        mp.clear();\\n\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,0});\\n\\n        while(!q.empty()){\\n            TreeNode* node= q.front().first;\\n            int v= q.front().second;\\n            mp[v]=1;\\n            node->val=v;\\n            q.pop();\\n\\n            if(node->left) q.push({node->left,2*v+1});\\n            if(node->right) q.push({node->right,2*v+2});\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return mp[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731771,
                "title": "depth-first-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe contaminated binary tree has some of its node values modified. The modification rule is that for any node with value v, its left child\\'s value is 2 * v + 1, and its right child\\'s value is 2 * v + 2.\\nThe goal is to create a data structure that allows us to efficiently determine whether a given value exists in the contaminated tree.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1\\uFE0F\\u20E3 Contaminate Tree: Starting from the root, recursively traverse the tree and modify each node\\'s value based on the contamination rule.\\n2\\uFE0F\\u20E3 Find Operation: Implement a depth-first search (DFS) to traverse the tree and check if the target value is found.\\n\\nIf the current node\\'s value matches the target, mark it as found.\\nIf not found, recursively search in the left and right subtrees.\\n3\\uFE0F\\u20E3 Initialization: Initialize the root node with a value of 0 and call the ContaminateTree function.\\n4\\uFE0F\\u20E3 Construction: Create an instance of the FindElements class with the root of the contaminated tree.\\n5\\uFE0F\\u20E3 Query: Use the find method on the FindElements object to check if a target value exists in the contaminated tree. The find method performs a DFS search and returns true if the target is found, and false otherwise.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nTreeNode* myroot;\\npublic:\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        myroot = root;\\n        ContaminateTree(myroot);\\n    }\\n    \\n    bool find(int target) {\\n        bool found = false;\\n        dfs_find(myroot , target , found);\\n        return found;\\n    };\\n\\n    void ContaminateTree(TreeNode* root){\\n        // Base Case (if current node is leaf node)\\n        if(root->left == nullptr && root->right == nullptr){\\n            return ;\\n        }\\n\\n        // processing\\n        if(root->left != nullptr){\\n            root->left->val = 2*root->val + 1;\\n        }\\n        if(root->right != nullptr){\\n            root->right->val = 2*root->val + 2;\\n        }\\n\\n        // recursive calls\\n        // left\\n        if(root->left != nullptr){\\n            ContaminateTree(root->left);\\n        }\\n        // right\\n        if(root->right != nullptr){\\n            ContaminateTree(root->right);\\n        }\\n\\n        return ;\\n    };\\n    void dfs_find(TreeNode* root , int target , bool &found){\\n        // Base Case (if current node is leaf node)\\n        if(root->left == nullptr && root->right == nullptr){\\n            if(root->val == target){\\n                found = true;\\n            }\\n            return ;\\n        }\\n\\n        // processing\\n        if(root->val == target){\\n            found = true;\\n        }\\n\\n        if(found == true){\\n            return;\\n        }\\n\\n        // recursive calls\\n        // left\\n        if(root->left != nullptr){\\n            dfs_find(root->left , target , found);\\n        }\\n        // right\\n        if(root->right != nullptr){\\n            dfs_find(root->right , target , found);\\n        }\\n\\n        return ;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nTreeNode* myroot;\\npublic:\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        myroot = root;\\n        ContaminateTree(myroot);\\n    }\\n    \\n    bool find(int target) {\\n        bool found = false;\\n        dfs_find(myroot , target , found);\\n        return found;\\n    };\\n\\n    void ContaminateTree(TreeNode* root){\\n        // Base Case (if current node is leaf node)\\n        if(root->left == nullptr && root->right == nullptr){\\n            return ;\\n        }\\n\\n        // processing\\n        if(root->left != nullptr){\\n            root->left->val = 2*root->val + 1;\\n        }\\n        if(root->right != nullptr){\\n            root->right->val = 2*root->val + 2;\\n        }\\n\\n        // recursive calls\\n        // left\\n        if(root->left != nullptr){\\n            ContaminateTree(root->left);\\n        }\\n        // right\\n        if(root->right != nullptr){\\n            ContaminateTree(root->right);\\n        }\\n\\n        return ;\\n    };\\n    void dfs_find(TreeNode* root , int target , bool &found){\\n        // Base Case (if current node is leaf node)\\n        if(root->left == nullptr && root->right == nullptr){\\n            if(root->val == target){\\n                found = true;\\n            }\\n            return ;\\n        }\\n\\n        // processing\\n        if(root->val == target){\\n            found = true;\\n        }\\n\\n        if(found == true){\\n            return;\\n        }\\n\\n        // recursive calls\\n        // left\\n        if(root->left != nullptr){\\n            dfs_find(root->left , target , found);\\n        }\\n        // right\\n        if(root->right != nullptr){\\n            dfs_find(root->right , target , found);\\n        }\\n\\n        return ;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709999,
                "title": "c-implementation-using-set-data-structure",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nset<int>st;\\npublic:\\n    void help(TreeNode* root,int node)\\n    {\\n        if(root==NULL){\\n            return;\\n        }\\n        st.insert(node);\\n        help(root->left,2*node+1);\\n        help(root->right,2*node+2);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        help(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return st.find(target)!=st.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nset<int>st;\\npublic:\\n    void help(TreeNode* root,int node)\\n    {\\n        if(root==NULL){\\n            return;\\n        }\\n        st.insert(node);\\n        help(root->left,2*node+1);\\n        help(root->right,2*node+2);\\n\\n    }\\n    FindElements(TreeNode* root) {\\n        help(root,0);\\n    }\\n    \\n    bool find(int target) {\\n        return st.find(target)!=st.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708836,
                "title": "a-new-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA particular value could be reached from a particular path only. So instead of saving the entire list of nodes in hashset, just save the leaves.\\n\\n# Complexity\\n- Time complexity:\\nFindElements = O(N)\\nfind = O(H); H --> max height;\\nTotal = O(H+N) = O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(H + 2^H); \\nO(H) --> for stack of recursion\\nO(2^H) --> max no. of leaf node that can be saved in the set.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_set<int>st;\\n    int maxi=0;\\n    void p(TreeNode* root, int val) {\\n        if(!root) return;\\n        root->val=val;\\n        if(!root->left && !root->right) {st.insert(val); maxi=max(maxi,val);}\\n        p(root->left,2*val+1);\\n        p(root->right,2*val+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        p(root,0);\\n    }\\n    \\n    bool find(int t) {\\n        queue<int>q;\\n        q.push(t);\\n        while(!q.empty()) {\\n            int k=q.front(); q.pop();\\n            if(st.find(k)!=st.end()) return 1;\\n            if((2*k+1) > maxi) continue;\\n            if((2*k+1) <=maxi) q.push(2*k+1);\\n            if((2*k+2) <= maxi) q.push(2*k+2);\\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    unordered_set<int>st;\\n    int maxi=0;\\n    void p(TreeNode* root, int val) {\\n        if(!root) return;\\n        root->val=val;\\n        if(!root->left && !root->right) {st.insert(val); maxi=max(maxi,val);}\\n        p(root->left,2*val+1);\\n        p(root->right,2*val+2);\\n    }\\n    FindElements(TreeNode* root) {\\n        p(root,0);\\n    }\\n    \\n    bool find(int t) {\\n        queue<int>q;\\n        q.push(t);\\n        while(!q.empty()) {\\n            int k=q.front(); q.pop();\\n            if(st.find(k)!=st.end()) return 1;\\n            if((2*k+1) > maxi) continue;\\n            if((2*k+1) <=maxi) q.push(2*k+1);\\n            if((2*k+2) <= maxi) q.push(2*k+2);\\n        }\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708205,
                "title": "recursive-inorder-solution-c",
                "content": "# Intuition\\nUse inorder traversal\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst, recover the binary by given rule .\\nsecond, store elements in setby inorder traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nTreeNode* head=NULL;\\nset<int> st;\\n   void solv(TreeNode* root,set<int> &st){\\n       if(root==NULL){\\n           return;\\n       }\\n       solv(root->left,st);\\n       st.insert(root->val);\\n       solv(root->right,st);\\n   }\\n   void solve(TreeNode* &root){\\n       if(root==NULL){\\n           return;\\n       }\\n      if(root->left!=NULL){\\n          root->left->val=2*root->val+1;\\n          solve(root->left);\\n      }\\n      if(root->right!=NULL){\\n          root->right->val=2*root->val+2;\\n          solve(root->right);\\n      }\\n     \\n   }\\n    FindElements(TreeNode* root) {\\n        if(root!=NULL){\\n            root->val=0;\\n            solve(root);\\n            solv(root,st);\\n        }\\n        head=root;\\n    }\\n    \\n    bool find(int target) {\\n        if(head==NULL){\\n            return 0;\\n        }\\n       if(st.find(target)!=st.end()){\\n           return 1;\\n       }\\n       return 0;\\n    }\\n};\\n\\n*********************PLEASE UPVOTE IF FOUND USEFUL*********",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "# Intuition\\nUse inorder traversal\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst, recover the binary by given rule .\\nsecond, store elements in setby inorder traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nTreeNode* head=NULL;\\nset<int> st;\\n   void solv(TreeNode* root,set<int> &st){\\n       if(root==NULL){\\n           return;\\n       }\\n       solv(root->left,st);\\n       st.insert(root->val);\\n       solv(root->right,st);\\n   }\\n   void solve(TreeNode* &root){\\n       if(root==NULL){\\n           return;\\n       }\\n      if(root->left!=NULL){\\n          root->left->val=2*root->val+1;\\n          solve(root->left);\\n      }\\n      if(root->right!=NULL){\\n          root->right->val=2*root->val+2;\\n          solve(root->right);\\n      }\\n     \\n   }\\n    FindElements(TreeNode* root) {\\n        if(root!=NULL){\\n            root->val=0;\\n            solve(root);\\n            solv(root,st);\\n        }\\n        head=root;\\n    }\\n    \\n    bool find(int target) {\\n        if(head==NULL){\\n            return 0;\\n        }\\n       if(st.find(target)!=st.end()){\\n           return 1;\\n       }\\n       return 0;\\n    }\\n};\\n\\n*********************PLEASE UPVOTE IF FOUND USEFUL*********",
                "codeTag": "Java"
            },
            {
                "id": 3705988,
                "title": "easy-to-understand-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n   map<int, bool> elements;\\n    void dfs(TreeNode* root){\\n        if(root == NULL){\\n            return;\\n        }\\n        int x = root->val;\\n        elements[x] = true;\\n        if(root->left != NULL){\\n            root->left->val = x+x+1;\\n        }\\n        if(root->right != NULL){\\n            root->right->val = x+x+2;\\n        }\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        dfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        return elements[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n   map<int, bool> elements;\\n    void dfs(TreeNode* root){\\n        if(root == NULL){\\n            return;\\n        }\\n        int x = root->val;\\n        elements[x] = true;\\n        if(root->left != NULL){\\n            root->left->val = x+x+1;\\n        }\\n        if(root->right != NULL){\\n            root->right->val = x+x+2;\\n        }\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val = 0;\\n        dfs(root);\\n    }\\n    \\n    bool find(int target) {\\n        return elements[target];\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3702949,
                "title": "c-bfs-binary-search-99-1-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nvector<int> vec;\\nint s;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(q.size()){\\n            TreeNode* temp=q.front();\\n            int x=temp->val;\\n            q.pop();\\n            vec.push_back(x);\\n            if(temp->left){\\n                temp->left->val=2*x+1;\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                temp->right->val=2*x+2;\\n                q.push(temp->right);\\n            }\\n        }\\n        s=vec.size();\\n    }\\n    \\n    bool find(int target) {\\n        int ind=lower_bound(vec.begin(),vec.end(),target)-vec.begin();\\n        if(ind<s && vec[ind]==target) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nvector<int> vec;\\nint s;\\n    FindElements(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        root->val=0;\\n        q.push(root);\\n        while(q.size()){\\n            TreeNode* temp=q.front();\\n            int x=temp->val;\\n            q.pop();\\n            vec.push_back(x);\\n            if(temp->left){\\n                temp->left->val=2*x+1;\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                temp->right->val=2*x+2;\\n                q.push(temp->right);\\n            }\\n        }\\n        s=vec.size();\\n    }\\n    \\n    bool find(int target) {\\n        int ind=lower_bound(vec.begin(),vec.end(),target)-vec.begin();\\n        if(ind<s && vec[ind]==target) return true;\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693644,
                "title": "java-not-restoring-the-tree-just-deriving-and-following-the-path-to-the-target-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe don\\'t need to compute the values at all, given the formula we can trace back if, at each level in the tree, we have to go through the left or right subtree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGiven the formula, we know that odd values are in left subtree w.r.t. their parent, even values to the right.\\n\\nReworking the formula backward, we can derive the immediate predecessor in the path from root to target (e.g., (value - 1) / 2 for odd values, (value - 2) / 2 for even), in this way we can compute an array with the path root (index 0) to the target value (index equivalent to the depth at which the value lies).\\n\\nWith this array, we can, at each step, decide if we need to go left (odd value), or right (even value), and we just need to follow the right child of the tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log N) for computing the target level, O(log N) for computing the array, O(log N) to traverse, still summing up to O(log N) in total.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe array for each requests is as long as the path, which is O(log N).\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        root.val = 0;\\n    }\\n    \\n    public boolean find(int target) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (target == 0 && root != null) {\\n            return true;\\n        }\\n        \\n        // here we derive the depth where the target element is, knowing that 2^i elements are at level i\\n        int targetLevel = 0;\\n        for (int tot = 1; ; targetLevel++) {\\n            int left = tot - 1;\\n            int right = tot * 2 - 2;\\n            if (target >= left && target <= right) {\\n                break;\\n            }\\n            tot *= 2;\\n        }\\n\\n        // now we compute the path backwards with the reverse of the given formula\\n        int[] path = new int[targetLevel + 1];\\n        path[targetLevel] = target;\\n        for (int i = targetLevel - 1; i >= 0; i--) {\\n            path[i] = (path[i + 1] - (path[i + 1] % 2 != 0 ? 1 : 2)) / 2;\\n        }\\n\\n        // here we traverse the tree, guided by the array\\n        TreeNode curr = root;\\n        for (int i = 1; curr != null && i < path.length; i++) {\\n            boolean left = path[i] % 2 != 0;\\n            curr = left ? curr.left : curr.right;\\n        }\\n        // at the final step, we just need to check that the node is there, if it is, it\\'s our target\\n        return curr != null;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        root.val = 0;\\n    }\\n    \\n    public boolean find(int target) {\\n        if (root == null) {\\n            return false;\\n        }\\n        if (target == 0 && root != null) {\\n            return true;\\n        }\\n        \\n        // here we derive the depth where the target element is, knowing that 2^i elements are at level i\\n        int targetLevel = 0;\\n        for (int tot = 1; ; targetLevel++) {\\n            int left = tot - 1;\\n            int right = tot * 2 - 2;\\n            if (target >= left && target <= right) {\\n                break;\\n            }\\n            tot *= 2;\\n        }\\n\\n        // now we compute the path backwards with the reverse of the given formula\\n        int[] path = new int[targetLevel + 1];\\n        path[targetLevel] = target;\\n        for (int i = targetLevel - 1; i >= 0; i--) {\\n            path[i] = (path[i + 1] - (path[i + 1] % 2 != 0 ? 1 : 2)) / 2;\\n        }\\n\\n        // here we traverse the tree, guided by the array\\n        TreeNode curr = root;\\n        for (int i = 1; curr != null && i < path.length; i++) {\\n            boolean left = path[i] % 2 != 0;\\n            curr = left ? curr.left : curr.right;\\n        }\\n        // at the final step, we just need to check that the node is there, if it is, it\\'s our target\\n        return curr != null;\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687184,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n    Set <Integer> values; \\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        root.val = 0;\\n        values = new HashSet();\\n        recover(root);\\n    }\\n\\n    private void recover(TreeNode root){\\n        values.add(root.val);\\n        if (root.left != null){\\n            root.left.val = 2*root.val +1;\\n            recover (root.left);\\n        }\\n        if (root.right != null){\\n            root.right.val = 2*root.val +2;\\n            recover (root.right);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return values.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass FindElements {\\n\\n    TreeNode root;\\n    Set <Integer> values; \\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        root.val = 0;\\n        values = new HashSet();\\n        recover(root);\\n    }\\n\\n    private void recover(TreeNode root){\\n        values.add(root.val);\\n        if (root.left != null){\\n            root.left.val = 2*root.val +1;\\n            recover (root.left);\\n        }\\n        if (root.right != null){\\n            root.right.val = 2*root.val +2;\\n            recover (root.right);\\n        }\\n    }\\n    \\n    public boolean find(int target) {\\n        return values.contains(target);\\n    }\\n}\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements obj = new FindElements(root);\\n * boolean param_1 = obj.find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687083,
                "title": "java-dfs-preorder",
                "content": "```\\nclass FindElements {\\n    Set<Integer> elements;\\n    public FindElements(TreeNode root) {\\n        this.elements = new HashSet<>();\\n        root.val = 0;\\n        preorder(root);\\n    }\\n    \\n    private void preorder(TreeNode node) {\\n        if(node == null) return;\\n        this.elements.add(node.val);\\n        if(node.left != null) {\\n            node.left.val = 2*node.val + 1;\\n        }\\n        if(node.right != null) {\\n            node.right.val = 2*node.val + 2;\\n        }\\n        preorder(node.left);\\n        preorder(node.right);\\n    }\\n    \\n    public boolean find(int target) {\\n        return this.elements.contains(target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass FindElements {\\n    Set<Integer> elements;\\n    public FindElements(TreeNode root) {\\n        this.elements = new HashSet<>();\\n        root.val = 0;\\n        preorder(root);\\n    }\\n    \\n    private void preorder(TreeNode node) {\\n        if(node == null) return;\\n        this.elements.add(node.val);\\n        if(node.left != null) {\\n            node.left.val = 2*node.val + 1;\\n        }\\n        if(node.right != null) {\\n            node.right.val = 2*node.val + 2;\\n        }\\n        preorder(node.left);\\n        preorder(node.right);\\n    }\\n    \\n    public boolean find(int target) {\\n        return this.elements.contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679723,
                "title": "c-easy-fast-dfs-unordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* node;\\n    unordered_set<int> s;\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.insert(0);\\n        node=root;\\n        solve(root);\\n    }\\n    \\n    void solve(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n\\n        if(root->left!=NULL)\\n        {\\n            \\n            root->left->val=root->val*2+1;\\n            s.insert(root->left->val);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=root->val*2+2;\\n             s.insert(root->right->val);\\n        }\\n\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    \\n    bool find(int target) {\\n       return s.find(target)!=s.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n    TreeNode* node;\\n    unordered_set<int> s;\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        s.insert(0);\\n        node=root;\\n        solve(root);\\n    }\\n    \\n    void solve(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return;\\n\\n        if(root->left!=NULL)\\n        {\\n            \\n            root->left->val=root->val*2+1;\\n            s.insert(root->left->val);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=root->val*2+2;\\n             s.insert(root->right->val);\\n        }\\n\\n        solve(root->left);\\n        solve(root->right);\\n    }\\n    \\n    bool find(int target) {\\n       return s.find(target)!=s.end();\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672040,
                "title": "c-set-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass FindElements {\\npublic:\\n    set<int> s;\\n    void traverse(TreeNode* root){\\n       if(!root) return ;\\n       if(root->left){\\n           root->left->val=(2*root->val)+1;\\n           s.insert((2*root->val)+1);\\n           traverse(root->left);\\n       } \\n       if(root->right){\\n           root->right->val=(2*root->val)+2;\\n           s.insert((2*root->val)+2);\\n           traverse(root->right);\\n       } \\n    }\\n    FindElements(TreeNode* root) {\\n        s.insert(0);\\n        root->val=0;\\n        traverse(root);\\n    }\\n    bool find(int target) {\\n        if(s.find(target)!=s.end()){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass FindElements {\\npublic:\\n    set<int> s;\\n    void traverse(TreeNode* root){\\n       if(!root) return ;\\n       if(root->left){\\n           root->left->val=(2*root->val)+1;\\n           s.insert((2*root->val)+1);\\n           traverse(root->left);\\n       } \\n       if(root->right){\\n           root->right->val=(2*root->val)+2;\\n           s.insert((2*root->val)+2);\\n           traverse(root->right);\\n       } \\n    }\\n    FindElements(TreeNode* root) {\\n        s.insert(0);\\n        root->val=0;\\n        traverse(root);\\n    }\\n    bool find(int target) {\\n        if(s.find(target)!=s.end()){\\n            return 1;\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3662753,
                "title": "recursive-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FindElements {\\nTreeNode * root1;\\nvoid solve(TreeNode* root,int target,bool &ans)\\n{\\n  if(root==NULL)return;\\n  if(root==root1)root->val=0;\\n  if(root->val==target)ans=1;\\n  if(root->left)\\n  {\\n    root->left->val=(2*root->val)+1;\\n  }\\n   if(root->right)\\n  {\\n    root->right->val=(2*root->val)+2;\\n  }\\n  solve(root->left,target,ans);\\n  solve(root->right,target,ans);\\n\\n}\\npublic:\\n    FindElements(TreeNode* root) {\\n       if(root==NULL)return;\\n       root1=root;\\n       root->val=-1;\\n       FindElements(root->right);\\n       FindElements(root->left);\\n    }\\n    \\n    bool find(int target) {\\n        int initial=0;\\n        bool ans=0;\\n        solve(root1,target,ans);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements {\\nTreeNode * root1;\\nvoid solve(TreeNode* root,int target,bool &ans)\\n{\\n  if(root==NULL)return;\\n  if(root==root1)root->val=0;\\n  if(root->val==target)ans=1;\\n  if(root->left)\\n  {\\n    root->left->val=(2*root->val)+1;\\n  }\\n   if(root->right)\\n  {\\n    root->right->val=(2*root->val)+2;\\n  }\\n  solve(root->left,target,ans);\\n  solve(root->right,target,ans);\\n\\n}\\npublic:\\n    FindElements(TreeNode* root) {\\n       if(root==NULL)return;\\n       root1=root;\\n       root->val=-1;\\n       FindElements(root->right);\\n       FindElements(root->left);\\n    }\\n    \\n    bool find(int target) {\\n        int initial=0;\\n        bool ans=0;\\n        solve(root1,target,ans);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660362,
                "title": "dfs-set-beats-100",
                "content": "\\tclass FindElements:                   \\n    def __init__(self, root: Optional[TreeNode]):\\n        root.val=0\\n        self.st=set()\\n        \\n        def depth(root):\\n            if not root:\\n                return None\\n\\n            self.st.add(root.val)\\n            if root.left:\\n                root.left.val=2*root.val+1\\n                \\n            if root.right:\\n                 root.right.val=2*root.val+2\\n\\n            depth(root.left)\\n            depth(root.right)\\n            \\n        depth(root)  \\n\\n    def find(self, target: int) -> bool:\\n        return target in self.st\\n\\n![image](https://assets.leetcode.com/users/images/c0190ecf-6719-4002-a400-825aec3121a1_1687245876.3178642.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass FindElements:                   \\n    def __init__(self, root: Optional[TreeNode]):\\n        root.val=0\\n        self.st=set()\\n        \\n        def depth(root):\\n            if not root:\\n                return None\\n\\n            self.st.add(root.val)\\n            if root.left:\\n                root.left.val=2*root.val+1\\n                \\n            if root.right:\\n                 root.right.val=2*root.val+2\\n\\n            depth(root.left)\\n            depth(root.right)\\n            \\n        depth(root)  \\n\\n    def find(self, target: int) -> bool:\\n        return target in self.st\\n\\n![image](https://assets.leetcode.com/users/images/c0190ecf-6719-4002-a400-825aec3121a1_1687245876.3178642.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3654585,
                "title": "dfs-hashset-c-100-efficient",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***There are two approaches in which this can be solved.***\\n\\n- We can avoid \\'Recover\\' of the tree. But everytime we want to Find a value, we would need to traverse the contaminated tree via BFS to find possibility of existance of the target element.\\n- We can recover the contaminated tree and everytime we recover a node, we\\'ll add it\\'s value to a HashSet. With this the Find can work in O(1).\\n-*<b>If we wish not to use a HashSet, then we can \"Find\" via BFS efficiently compared to DFS</b>. Because, since the elements will be ordered at each level (top-to-bottom + left-to-right), we can conclude that the target element is not present if we encounter any element whose value is greater than our target. The same cannot be concluded via DFS.*\\n\\n![Screenshot 2023-06-19 084844.png](https://assets.leetcode.com/users/images/28d70aee-77ce-4759-9af4-fb451bcf67ad_1687144782.9810998.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) - Recover - as we need to visit every node of the contaminated tree.\\nO(1) - Find\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) - as we use a HashSet\\n*if we wish not use a hashset, we can search via DFS with O(1) space complexity and O(N) runtime complexity*\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\npublic class FindElements {\\n    TreeNode root;\\n    HashSet<int> h;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        h = new HashSet<int>();\\n        RecoverNode(root, 0);\\n    }\\n\\n    private void RecoverNode(TreeNode node, int val)\\n    {\\n        //recover via DFS\\n        if (node == null)\\n            return;\\n\\n        h.Add(val);\\n        node.val = val;\\n        RecoverNode(node.left, 2*val + 1);\\n        RecoverNode(node.right, 2*val + 2);\\n    }\\n    \\n    public bool Find(int target) {\\n        return h.Contains(target);\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Design"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\npublic class FindElements {\\n    TreeNode root;\\n    HashSet<int> h;\\n\\n    public FindElements(TreeNode root) {\\n        this.root = root;\\n        h = new HashSet<int>();\\n        RecoverNode(root, 0);\\n    }\\n\\n    private void RecoverNode(TreeNode node, int val)\\n    {\\n        //recover via DFS\\n        if (node == null)\\n            return;\\n\\n        h.Add(val);\\n        node.val = val;\\n        RecoverNode(node.left, 2*val + 1);\\n        RecoverNode(node.right, 2*val + 2);\\n    }\\n    \\n    public bool Find(int target) {\\n        return h.Contains(target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641333,
                "title": "very-easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nvector<int>v;\\n    FindElements(TreeNode* root) {\\n        if (!root)\\n            return;\\n        root->val=0;\\n        recovery(root);\\n    }\\n    void recovery(TreeNode* root)\\n    {\\n        if (!root)  \\n            return;\\n        if (root->left)\\n        {\\n            root->left->val=(2*root->val)+1;\\n        }\\n        if (root->right)\\n        {\\n            root->right->val=(2*root->val)+2;\\n        }\\n        recovery(root->left);\\n        recovery(root->right);\\n        v.push_back(root->val);\\n    }\\n    bool find(int target) {\\n      for (auto c:v)\\n        {\\n            if (c==target)\\n                return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\nvector<int>v;\\n    FindElements(TreeNode* root) {\\n        if (!root)\\n            return;\\n        root->val=0;\\n        recovery(root);\\n    }\\n    void recovery(TreeNode* root)\\n    {\\n        if (!root)  \\n            return;\\n        if (root->left)\\n        {\\n            root->left->val=(2*root->val)+1;\\n        }\\n        if (root->right)\\n        {\\n            root->right->val=(2*root->val)+2;\\n        }\\n        recovery(root->left);\\n        recovery(root->right);\\n        v.push_back(root->val);\\n    }\\n    bool find(int target) {\\n      for (auto c:v)\\n        {\\n            if (c==target)\\n                return 1;\\n        }\\n        return 0;\\n        \\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605244,
                "title": "c-solution-with-back-traverse",
                "content": "# Intuition\\nWe can go without recovering tree by builing backward path.\\n\\n# Approach\\nleft - odd number\\nright - even number\\nwith this precondition we can rebuild a path for the target value.\\n# Code\\n```\\npublic class FindElements {\\n\\n    private readonly TreeNode _root;\\n\\n    public FindElements(TreeNode root) {\\n        _root = root;   \\n    }\\n    \\n    public bool Find(int target) {\\n        if(target == 0)\\n        {\\n            return _root != null;\\n        }\\n\\n        var path = new int[(int)Math.Log(target + 1, 2)];\\n        path[path.Length - 1] = target;\\n        for(var i = path.Length - 2; i >= 0; i--)\\n        {\\n            path[i] = path[i+1] % 2 == 0 ? (path[i+1] - 2)/2 : (path[i+1] - 1)/2;\\n        }\\n        \\n        var node = _root;\\n        foreach(var p in path)\\n        {\\n            node = p % 2 == 0 ? node.right : node.left;\\n\\n            if(node == null)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}",
                "solutionTags": [
                    "C#"
                ],
                "code": "# Intuition\\nWe can go without recovering tree by builing backward path.\\n\\n# Approach\\nleft - odd number\\nright - even number\\nwith this precondition we can rebuild a path for the target value.\\n# Code\\n```\\npublic class FindElements {\\n\\n    private readonly TreeNode _root;\\n\\n    public FindElements(TreeNode root) {\\n        _root = root;   \\n    }\\n    \\n    public bool Find(int target) {\\n        if(target == 0)\\n        {\\n            return _root != null;\\n        }\\n\\n        var path = new int[(int)Math.Log(target + 1, 2)];\\n        path[path.Length - 1] = target;\\n        for(var i = path.Length - 2; i >= 0; i--)\\n        {\\n            path[i] = path[i+1] % 2 == 0 ? (path[i+1] - 2)/2 : (path[i+1] - 1)/2;\\n        }\\n        \\n        var node = _root;\\n        foreach(var p in path)\\n        {\\n            node = p % 2 == 0 ? node.right : node.left;\\n\\n            if(node == null)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3587328,
                "title": "c-simple-and-interesting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n->To implement this, I chose to use a depth-first traversal of the binary tree. Starting from the root node, I assign the value 0 to the root and recursively recover the values of the left and right subtrees based on the parent node\\'s value.\\n\\n->During the recovery process, I store the recovered values in an unordered set (values) to enable efficient lookup in the find method.\\n\\n->The expression values.count(target) > 0 compares the result of values.count(target) with 0. If the count is greater than 0, it means that the target value was found in the set, which gives us true. Otherwise, if the count is 0, it means that the target value is not present in the set, and we can return false.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS and Unordered_set\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    private:\\n    unordered_set<int>values;  // Using set to remove duplicacy.\\npublic:\\n    FindElements(TreeNode* root) {\\n        if(root->val!=NULL)\\n        {\\n            root->val=0; //  So as the statement is asking you if root is not null then make it null.\\n            recoverTree(root);\\n        }\\n    }\\n    void recoverTree(TreeNode* root)\\n    {\\n        values.insert(root->val); // insert values inside set\\n        if(root->left!=NULL)\\n        {\\n          root->left->val=2*root->val+1;\\n          recoverTree(root->left);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=2*root->val+2;\\n            recoverTree(root->right);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return values.count(target)>0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n    private:\\n    unordered_set<int>values;  // Using set to remove duplicacy.\\npublic:\\n    FindElements(TreeNode* root) {\\n        if(root->val!=NULL)\\n        {\\n            root->val=0; //  So as the statement is asking you if root is not null then make it null.\\n            recoverTree(root);\\n        }\\n    }\\n    void recoverTree(TreeNode* root)\\n    {\\n        values.insert(root->val); // insert values inside set\\n        if(root->left!=NULL)\\n        {\\n          root->left->val=2*root->val+1;\\n          recoverTree(root->left);\\n        }\\n        if(root->right!=NULL)\\n        {\\n            root->right->val=2*root->val+2;\\n            recoverTree(root->right);\\n        }\\n    }\\n    \\n    bool find(int target) {\\n        return values.count(target)>0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585307,
                "title": "c-searching-in-tree",
                "content": "```\\nclass FindElements {\\npublic:\\n    TreeNode* root = nullptr;\\n    FindElements(TreeNode* root) {\\n        this->root = root;\\n    }\\n    bool find(int target) {\\n        vector<bool> path;\\n        int targetCopy = target;\\n        while(targetCopy) {\\n            if (targetCopy % 2 == 0) {\\n                path.push_back(true);\\n                targetCopy -= 2;\\n            } else {\\n                path.push_back(false);\\n                targetCopy -= 1;\\n            }\\n            targetCopy /= 2;\\n        }\\n        TreeNode* head = root;\\n        for(auto it = path.rbegin(); it != path.rend(); it++) {\\n            if (head == nullptr) {\\n                return false;\\n            }\\n            if (*it) {\\n                head = head->right;\\n            } else {\\n                head = head->left;\\n            }\\n        }\\n        return head ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass FindElements {\\npublic:\\n    TreeNode* root = nullptr;\\n    FindElements(TreeNode* root) {\\n        this->root = root;\\n    }\\n    bool find(int target) {\\n        vector<bool> path;\\n        int targetCopy = target;\\n        while(targetCopy) {\\n            if (targetCopy % 2 == 0) {\\n                path.push_back(true);\\n                targetCopy -= 2;\\n            } else {\\n                path.push_back(false);\\n                targetCopy -= 1;\\n            }\\n            targetCopy /= 2;\\n        }\\n        TreeNode* head = root;\\n        for(auto it = path.rbegin(); it != path.rend(); it++) {\\n            if (head == nullptr) {\\n                return false;\\n            }\\n            if (*it) {\\n                head = head->right;\\n            } else {\\n                head = head->left;\\n            }\\n        }\\n        return head ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584270,
                "title": "solution",
                "content": "```C++ []\\nclass FindElements {\\n public:\\n  FindElements(TreeNode* root) {\\n    dfs(root, 0);\\n  }\\n  bool find(int target) {\\n    return vals.count(target);\\n  }\\n private:\\n  unordered_set<int> vals;\\n\\n  void dfs(TreeNode* root, int val) {\\n    if (root == nullptr)\\n      return;\\n\\n    root->val = val;\\n    vals.insert(val);\\n    dfs(root->left, val * 2 + 1);\\n    dfs(root->right, val * 2 + 2);\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass FindElements:\\n    node_list = None\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.node_list = set()\\n        root.val = 0\\n        self.node_list.add(root.val)\\n        myq = collections.deque([root])\\n        l_val = 0\\n        r_val = 0\\n\\n        while myq:\\n            lvl_size = len(myq)\\n           \\n            for _ in range(0, lvl_size):\\n                node = myq.popleft()\\n                x = node.val\\n                \\n                if node.left:\\n                    l_val = 2 * x + 1\\n                    node.left.val = l_val\\n                    myq.append(node.left)\\n                    self.node_list.add(node.left.val)\\n\\n                if node.right:\\n                    r_val = 2 * x + 2\\n                    node.right.val = r_val\\n                    myq.append(node.right)\\n                    self.node_list.add(node.right.val)\\n            \\n    def f(self, target: int) -> bool:\\n        if target in self.node_list:\\n            return True\\n\\n    def find(self, target: int) -> bool:\\n        return self.f(target)\\n```\\n\\n```Java []\\nclass FindElements {\\n    private TreeNode root;\\n    public FindElements(TreeNode root) {\\n        this.root=root;\\n    }\\n    public boolean find(int target) {\\n        target++;\\n        int high=high(target);\\n        TreeNode cur=root;\\n        high=high>>1;\\n        while(high>0){\\n            int bit=target&high;\\n            high=high>>1;\\n            if(bit!=0&&cur.right!=null){\\n                cur=cur.right;\\n            }else if(bit==0&&cur.left!=null){\\n                cur=cur.left;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int high(long target){\\n        target=target|target>>1;\\n        target=target|target>>2;\\n        target=target|target>>4;\\n        target=target|target>>8;\\n        target=target|target>>16;\\n        return (int)((target+1)>>1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass FindElements {\\n public:\\n  FindElements(TreeNode* root) {\\n    dfs(root, 0);\\n  }\\n  bool find(int target) {\\n    return vals.count(target);\\n  }\\n private:\\n  unordered_set<int> vals;\\n\\n  void dfs(TreeNode* root, int val) {\\n    if (root == nullptr)\\n      return;\\n\\n    root->val = val;\\n    vals.insert(val);\\n    dfs(root->left, val * 2 + 1);\\n    dfs(root->right, val * 2 + 2);\\n  }\\n};\\n```\n```Python3 []\\nclass FindElements:\\n    node_list = None\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.node_list = set()\\n        root.val = 0\\n        self.node_list.add(root.val)\\n        myq = collections.deque([root])\\n        l_val = 0\\n        r_val = 0\\n\\n        while myq:\\n            lvl_size = len(myq)\\n           \\n            for _ in range(0, lvl_size):\\n                node = myq.popleft()\\n                x = node.val\\n                \\n                if node.left:\\n                    l_val = 2 * x + 1\\n                    node.left.val = l_val\\n                    myq.append(node.left)\\n                    self.node_list.add(node.left.val)\\n\\n                if node.right:\\n                    r_val = 2 * x + 2\\n                    node.right.val = r_val\\n                    myq.append(node.right)\\n                    self.node_list.add(node.right.val)\\n            \\n    def f(self, target: int) -> bool:\\n        if target in self.node_list:\\n            return True\\n\\n    def find(self, target: int) -> bool:\\n        return self.f(target)\\n```\n```Java []\\nclass FindElements {\\n    private TreeNode root;\\n    public FindElements(TreeNode root) {\\n        this.root=root;\\n    }\\n    public boolean find(int target) {\\n        target++;\\n        int high=high(target);\\n        TreeNode cur=root;\\n        high=high>>1;\\n        while(high>0){\\n            int bit=target&high;\\n            high=high>>1;\\n            if(bit!=0&&cur.right!=null){\\n                cur=cur.right;\\n            }else if(bit==0&&cur.left!=null){\\n                cur=cur.left;\\n            }else{\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int high(long target){\\n        target=target|target>>1;\\n        target=target|target>>2;\\n        target=target|target>>4;\\n        target=target|target>>8;\\n        target=target|target>>16;\\n        return (int)((target+1)>>1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580493,
                "title": "easiest-sol-c-recursion-binary-tree",
                "content": "# Intuition\\ni stored all the recovered elements in a map and then checked whether they are present or not and returned the bool value\\n\\n# Approach\\nmade a build function with index and TreeNode and if its value was -1 then i stored the node with its real value else ignored it and later in the find function just checked whether element was present or not \\n\\n# Complexity\\n- Time complexity:\\nO(n) \\n\\n- Space complexity:\\nO(n)re\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n   map<int,int> m;\\n   void build(int i,TreeNode* root){\\n       if(root==nullptr){\\n           return;\\n       }\\n       m[i]++;\\n       build(2*i+1,root->left);\\n       build(2*i+2,root->right);\\n   }\\n    FindElements(TreeNode* root) {\\n        if(root==nullptr){\\n            return ;\\n        }\\n        build(0,root);\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target)!=m.end()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\npublic:\\n   map<int,int> m;\\n   void build(int i,TreeNode* root){\\n       if(root==nullptr){\\n           return;\\n       }\\n       m[i]++;\\n       build(2*i+1,root->left);\\n       build(2*i+2,root->right);\\n   }\\n    FindElements(TreeNode* root) {\\n        if(root==nullptr){\\n            return ;\\n        }\\n        build(0,root);\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target)!=m.end()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575305,
                "title": "c-2-different-approaches-with-code-explanation-1-runtime-efficient-2-space-efficient",
                "content": "# Intuition\\nI tried to explain both the basic approaches that I did + codes are below, please upvote if you find this helpful : )\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\nFirst approach is having better runtime (better than 90%) as it uses set and we dont have to search in the tree to find hence it saves recursion stack calling, but uses  extra space.\\n\\n# Approach 2 \\n\\nThis approach is having better memory control (better than 90% ), it uses basic methods which saves extra space but the runtime is slower, so have a loook at both\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->Approach 1\\nO(N) in both cases\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nrecursive internal stack and set in approach 1\\n\\n# Code\\n```\\nAPPROACH 1\\n\\nclass FindElements {\\npublic:\\n    unordered_set<int>s;\\n    void recoverTree(TreeNode *node )\\n    {\\n        if(node ==NULL)\\n            return;\\n        s.insert(node->val);\\n        if(node->left != NULL)\\n        {\\n            node->left->val = node->val * 2 + 1;\\n            recoverTree(node->left);     \\n        }\\n        if(node->right !=NULL){\\n            node->right->val = node->val * 2 +2;\\n            recoverTree(node->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val =0;\\n        recoverTree(root);\\n    }\\n    bool find(int target) {\\n        if(s.find(target) != s.end())\\n            return true;\\n        return false;\\n    }\\n};\\n\\n\\n*************************************\\n\\n\\nAPPROACH 2\\n\\nclass FindElements {\\npublic:\\n    TreeNode *head;\\n    void recoverTree(TreeNode *node )\\n    {\\n        if(node ==NULL)\\n            return;\\n        if(node->left != NULL)\\n        {\\n            node->left->val = node->val * 2 + 1;\\n            recoverTree(node->left);\\n            \\n        }\\n        if(node->right !=NULL){\\n            node->right->val = node->val * 2 +2;\\n            recoverTree(node->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val =0;\\n        head = root;\\n        recoverTree(root);\\n    }\\n    bool findInTree(TreeNode *root, int target,bool isFound){\\n        if(root == NULL)\\n            return false;\\n        if(root->val == target)\\n        {\\n            isFound = true;\\n            return true;\\n        }\\n        if(isFound == false)\\n            return findInTree(root->left, target,isFound) || findInTree(root->right,target,isFound);\\n        return false;\\n    }\\n    bool find(int target) {\\n        bool isFound = false;\\n        return findInTree(head, target,isFound);\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nAPPROACH 1\\n\\nclass FindElements {\\npublic:\\n    unordered_set<int>s;\\n    void recoverTree(TreeNode *node )\\n    {\\n        if(node ==NULL)\\n            return;\\n        s.insert(node->val);\\n        if(node->left != NULL)\\n        {\\n            node->left->val = node->val * 2 + 1;\\n            recoverTree(node->left);     \\n        }\\n        if(node->right !=NULL){\\n            node->right->val = node->val * 2 +2;\\n            recoverTree(node->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val =0;\\n        recoverTree(root);\\n    }\\n    bool find(int target) {\\n        if(s.find(target) != s.end())\\n            return true;\\n        return false;\\n    }\\n};\\n\\n\\n*************************************\\n\\n\\nAPPROACH 2\\n\\nclass FindElements {\\npublic:\\n    TreeNode *head;\\n    void recoverTree(TreeNode *node )\\n    {\\n        if(node ==NULL)\\n            return;\\n        if(node->left != NULL)\\n        {\\n            node->left->val = node->val * 2 + 1;\\n            recoverTree(node->left);\\n            \\n        }\\n        if(node->right !=NULL){\\n            node->right->val = node->val * 2 +2;\\n            recoverTree(node->right);\\n        }\\n    }\\n    FindElements(TreeNode* root) {\\n        root->val =0;\\n        head = root;\\n        recoverTree(root);\\n    }\\n    bool findInTree(TreeNode *root, int target,bool isFound){\\n        if(root == NULL)\\n            return false;\\n        if(root->val == target)\\n        {\\n            isFound = true;\\n            return true;\\n        }\\n        if(isFound == false)\\n            return findInTree(root->left, target,isFound) || findInTree(root->right,target,isFound);\\n        return false;\\n    }\\n    bool find(int target) {\\n        bool isFound = false;\\n        return findInTree(head, target,isFound);\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566938,
                "title": "easy-to-understand-javascript-solution-dfs",
                "content": "```\\nvar FindElements = function(root) {\\n    this.treeSet = new Set();\\n\\n    const dfsTree = (node = root, parent = 0, add = 0) => {\\n        if (!node) return;\\n        const { left, right } = node;\\n        const value = parent * 2 + add;\\n\\n        this.treeSet.add(value);\\n        dfsTree(left, value, 1);\\n        dfsTree(right, value, 2);\\n    };\\n\\n    dfsTree();\\n};\\n\\nFindElements.prototype.find = function(target) {\\n    return this.treeSet.has(target);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar FindElements = function(root) {\\n    this.treeSet = new Set();\\n\\n    const dfsTree = (node = root, parent = 0, add = 0) => {\\n        if (!node) return;\\n        const { left, right } = node;\\n        const value = parent * 2 + add;\\n\\n        this.treeSet.add(value);\\n        dfsTree(left, value, 1);\\n        dfsTree(right, value, 2);\\n    };\\n\\n    dfsTree();\\n};\\n\\nFindElements.prototype.find = function(target) {\\n    return this.treeSet.has(target);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566522,
                "title": "c-easiest-solution-recursive",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nprivate:\\n    void solve(TreeNode* &root, int data, unordered_map<int,int> &m){\\n        // base case\\n        if(!root) return;\\n\\n        root->val = data;\\n        m[data]++;\\n\\n        solve(root->left, data*2+1, m);\\n        solve(root->right, data*2+2, m);\\n    }\\npublic:\\n    unordered_map<int,int> m;\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        m[0]++;\\n        solve(root->left,1,m);\\n        solve(root->right,2,m);\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target)!=m.end()) return 1;\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\nprivate:\\n    void solve(TreeNode* &root, int data, unordered_map<int,int> &m){\\n        // base case\\n        if(!root) return;\\n\\n        root->val = data;\\n        m[data]++;\\n\\n        solve(root->left, data*2+1, m);\\n        solve(root->right, data*2+2, m);\\n    }\\npublic:\\n    unordered_map<int,int> m;\\n    FindElements(TreeNode* root) {\\n        root->val=0;\\n        m[0]++;\\n        solve(root->left,1,m);\\n        solve(root->right,2,m);\\n    }\\n    \\n    bool find(int target) {\\n        if(m.find(target)!=m.end()) return 1;\\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574006,
                "content": [
                    {
                        "username": "sushobh",
                        "content": "There are quite a few problems out there which are tagged easy but are should be medium.\\nThis one is the opposite , it should have been easy. Most people are familiar with tree traversal\\nand so i don\\'t understand why this should be tagged medium considering some of the tough medium problems i have solved."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It\\'s trivial if you save the existing values with a hashset for queries. But requires some work otherwise."
                    },
                    {
                        "username": "ashvaibhav",
                        "content": "![image](https://assets.leetcode.com/users/ashvaibhav/image_1573963660.png)\\nFor even simple test cases like:\\n\\n[\"FindElements\",\"find\",\"find\"]\\n[[[-1,null,-1]],[1],[2]]\\n"
                    },
                    {
                        "username": "0icy",
                        "content": "if you are allowed to use hashset this q shld be ez"
                    }
                ]
            },
            {
                "id": 1573193,
                "content": [
                    {
                        "username": "sushobh",
                        "content": "There are quite a few problems out there which are tagged easy but are should be medium.\\nThis one is the opposite , it should have been easy. Most people are familiar with tree traversal\\nand so i don\\'t understand why this should be tagged medium considering some of the tough medium problems i have solved."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It\\'s trivial if you save the existing values with a hashset for queries. But requires some work otherwise."
                    },
                    {
                        "username": "ashvaibhav",
                        "content": "![image](https://assets.leetcode.com/users/ashvaibhav/image_1573963660.png)\\nFor even simple test cases like:\\n\\n[\"FindElements\",\"find\",\"find\"]\\n[[[-1,null,-1]],[1],[2]]\\n"
                    },
                    {
                        "username": "0icy",
                        "content": "if you are allowed to use hashset this q shld be ez"
                    }
                ]
            },
            {
                "id": 2020758,
                "content": [
                    {
                        "username": "sushobh",
                        "content": "There are quite a few problems out there which are tagged easy but are should be medium.\\nThis one is the opposite , it should have been easy. Most people are familiar with tree traversal\\nand so i don\\'t understand why this should be tagged medium considering some of the tough medium problems i have solved."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "It\\'s trivial if you save the existing values with a hashset for queries. But requires some work otherwise."
                    },
                    {
                        "username": "ashvaibhav",
                        "content": "![image](https://assets.leetcode.com/users/ashvaibhav/image_1573963660.png)\\nFor even simple test cases like:\\n\\n[\"FindElements\",\"find\",\"find\"]\\n[[[-1,null,-1]],[1],[2]]\\n"
                    },
                    {
                        "username": "0icy",
                        "content": "if you are allowed to use hashset this q shld be ez"
                    }
                ]
            }
        ]
    }
]